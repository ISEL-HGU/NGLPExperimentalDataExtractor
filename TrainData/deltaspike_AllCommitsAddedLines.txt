 * 
 * <p><b>Note:</b> Please note that DeltaSpike will only find {@link ProjectStageHolder}s
 * which are accessible by this very class. If you deploy the deltaspike-core jar to a
 * shared EAR classloader, it will e.g. <i>not</i> be able to register ProjectStages defined
 * in a web applications WEB-INF/classes directory!
 * </p>
     * by simply touching their classes due loading it with the.
 * <p>This is a marker interface for custom project
 * contains 1 or many {@link ProjectStage}s.</p>
 *
 * <p>Any custom ProjectStageHolder must get registered via the
 * {@link java.util.ServiceLoader} mechanism. Simply create a file
 * <pre>
 *     META-INF/services/org.apache.deltaspike.core.api.projectstage.ProjectStageHolder
 * </pre>
 * and write the fully qualified class name of your ProjectStageHolder into it.
 * </p>
import javax.enterprise.inject.Typed;

@Typed()
    public static String getPropertyValue(String key)
    public static List<String> getAllPropertyValues(String key)
    private static synchronized ConfigSource[] getConfigSources()
    private static List<ConfigSource> resolveConfigSources()
    private static ConfigSource[] sortConfigSources(List<ConfigSource> configSources)
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.api.util.ClassUtils;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
    private static final Logger LOG = Logger.getLogger(ClassDeactivation.class.getName());
        ClassDeactivator classDeactivator = getConfiguredClassDeactivator();
            LOG.info("used class deactivator: "  classDeactivator.toString());
                LOG.info("deactivate: "  deactivatedClass);
    private static ClassDeactivator getConfiguredClassDeactivator()
    {
        List<String> classDeactivatorClassNames = ConfigResolver.getAllPropertyValues(ClassDeactivator.class.getName());
        Set<Class> deactivatedClasses = new HashSet<Class>();

        ClassDeactivator currentClassDeactivator;
        for(String classDeactivatorClassName : classDeactivatorClassNames)
        {
            currentClassDeactivator =
                    ClassUtils.tryToInstantiateClassForName(classDeactivatorClassName, ClassDeactivator.class);

            if(currentClassDeactivator != null)
            {
                deactivatedClasses.addAll(currentClassDeactivator.getDeactivatedClasses());
            }
            else
            {
                LOG.warning(classDeactivatorClassName  " can't be instantiated");
            }
        }

        return new DefaultClassDeactivator(deactivatedClasses);
    }

                    String className = pathToClassName(entryName.substring(0, entryName.length()-(".class".length())));
                String className = pathToClassName(entryName.substring(0, entryName.length()-(".class".length())));

                javaArchive.addAsResource(entryName.replace('\\', '/'));
            String packageName = pathToClassName(jarEntryName);
        String packageName = pathToClassName(jarEntryName);
    private static String pathToClassName(String pathName) {
        return pathName.replace('/', '.').replace('\\', '.');   // replace unix and windows separators
    }



import java.util.logging.Level;
import java.util.logging.Logger;

public abstract class ConfigSource
    protected Logger LOG = Logger.getLogger(getClass().getName());

    //X TODO discuss value
    private static final String ORDINAL_KEY = "org_apache_deltaspike_ORDINAL";

    private int ordinal;

    protected ConfigSource()
    {
        init();
    }

    public int getOrdinal()
    {
        return this.ordinal;
    }
    public abstract String getPropertyValue(String key);
    public abstract String getConfigName();

    /**
     * Provides the default ordinal, if there isn't a custom ordinal for the current
     * {@link ConfigSource}
     * @return value for the default ordinal
     */
    protected int getDefaultOrdinal()
    {
        return 1000;
    }

    /**
     * Init method e.g. for initializing the ordinal
     */
    protected void init()
    {
        this.ordinal = getDefaultOrdinal();

        Integer configuredOrdinal = null;

        String configuredOrdinalString = getPropertyValue(getOrdinalKey());
        try
        {
            if(configuredOrdinalString != null)
            {
                configuredOrdinal = new Integer(configuredOrdinalString.trim());
            }
        }
        catch (NumberFormatException e)
        {
            LOG.log(Level.WARNING,
                    "The configured config-ordinal isn't a valid integer. Invalid value: "  configuredOrdinalString);
        }
        catch (Exception e)
        {
            //do nothing it was just a try
        }

        if(configuredOrdinal != null)
        {
            this.ordinal = configuredOrdinal;
        }
    }

    /**
     * Allows to customize the key which gets used to lookup a customized ordinal for the current
     * {@link ConfigSource}
     * @return key which should be used for the ordinal lookup
     */
    protected String getOrdinalKey()
    {
        return ORDINAL_KEY;
    }
                if (urlString.contains("%20"))
                    urlString = urlString.replaceAll("%20", " ");
                    f = new File( (new URL(ensureCorrectUrlFormat(urlString))).getFile() );
public final class ConfigResolver
    private ConfigResolver()
    {
        // this is a utility class which doesn't get instantiated.
    }

import javax.enterprise.inject.Typed;
@Typed()
public final class BeanProvider
        catch (InstantiationException e)
        {
            //do nothing - it was just a try
        }
        catch (IllegalAccessException e)
public final class ClassDeactivation
import org.apache.deltaspike.core.api.literal.AnyLiteral;

import javax.enterprise.context.Dependent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
     * <p>Get a list of Contextual References by it's type independent of the qualifier.
     * You can use this method to get all contextual references of a given type.
     * A 'Contextual Reference' is a proxy which will automatically resolve
     * the correct contextual instance when you access any method.</p>
     *
     * <p><b>Attention:</b> You shall not use this method to manually resolve a
     * &#064;Dependent bean! The reason is that this contextual instances do usually
     * live in the well defined lifecycle of their injection point (the bean they got
     * injected into). But if we manually resolve a &#064;Dependent bean, then it does <b>not</b>
     * belong to such a well defined lifecycle (because &#064;Dependent it is not
     * &#064;NormalScoped) and thus will not automatically be
     * destroyed at the end of the lifecycle. You need to manually destroy this contextual instance via
     * {@link javax.enterprise.context.spi.Contextual#destroy(Object, javax.enterprise.context.spi.CreationalContext)}.
     * Thus you also need to manually store the CreationalContext and the Bean you
     * used to create the contextual instance which this method will not provide.</p>
     *
     * @param type the type of the bean in question
     * @param optional if <code>true</code> it will return an empty list if no bean could be found or created.
     *                 Otherwise it will throw an {@code IllegalStateException}
     * @param includeDefaultScopedBeans specifies if dependent scoped beans should be included in the in the result
     * @param <T> target type
     * @return the resolved list of Contextual Reference or an empty-list if optional is true
     */
    public static <T> List<T> getContextualReferences(Class<T> type,
                                                      boolean optional,
                                                      boolean includeDefaultScopedBeans)
    {
        BeanManager beanManager = getBeanManager();
        Set<Bean<?>> beans = beanManager.getBeans(type, new AnyLiteral());

        if (beans == null || beans.isEmpty())
        {
            if (optional)
            {
                return Collections.emptyList();
            }

            throw new IllegalStateException("Could not find beans for Type="  type);
        }

        if(!includeDefaultScopedBeans)
        {
            beans = filterDefaultScopedBeans(beans);
        }
        
        List<T> result = new ArrayList<T>(beans.size());
        
        for(Bean<?> bean : beans)
        {
            result.add(getContextualReference(type, beanManager,
                    new HashSet<Bean<?>>((Collection)Arrays.asList(new Object[]{bean}))));
        }
        return result;
    }

    private static Set<Bean<?>> filterDefaultScopedBeans(Set<Bean<?>> beans)
    {
        Set<Bean<?>> result = new HashSet<Bean<?>>(beans.size());

        Iterator<Bean<?>> beanIterator = beans.iterator();

        Bean<?> currentBean;
        while (beanIterator.hasNext())
        {
            currentBean = beanIterator.next();

            if(!Dependent.class.isAssignableFrom(currentBean.getScope()))
            {
                result.add(currentBean);
            }
        }
        return result;
    }

    /**
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
            classDeactivator = resolveAndCacheClassDeactivator();
    private static ClassDeactivator resolveAndCacheClassDeactivator()
        // display deactivated classes here once
        // NOTE that isClassActivated() will be called many times for the same class
        for (Class<?> deactivatedClass : classDeactivator.getDeactivatedClasses())
            LOG.info("deactivate: "  deactivatedClass);
            LOG.info(classDeactivatorClassName  " gets processed");

     * <p>Get a list of Contextual References by it's type independent of the qualifier
     * (including dependent scoped beans).
     *
     * @param <T> target type
     * @return the resolved list of Contextual Reference or an empty-list if optional is true
     */
    public static <T> List<T> getContextualReferences(Class<T> type,
                                                      boolean optional)
    {
        return getContextualReferences(type, optional, true);
    }

    /**
     * <p>Get a list of Contextual References by it's type independent of the qualifier.
     *
     * Further details are available at {@link #getContextualReferences(Class, boolean)}
     *
     * @param type the type of the bean in question
     * @param optional if <code>true</code> it will return an empty list if no bean could be found or created.
     *                 Otherwise it will throw an {@code IllegalStateException}
import org.apache.deltaspike.example.echo.DefaultEchoService;
import org.apache.deltaspike.example.optional.OptionalService;
        List<EchoService> echoServiceList = BeanProvider.getContextualReferences(EchoService.class, false);
            LOG.info(echoService.echo("Hello CDI bean!"));
            LOG.info(echoService.echo("Hello non dependent CDI scoped bean!"));
        LOG.info("---");

        EchoService defaultEchoService = BeanProvider.getContextualReference(DefaultEchoService.class, false);

        LOG.info(defaultEchoService.echo("Hello explicitly resolved CDI bean!"));

        defaultEchoService = BeanProvider.getContextualReference(EchoService.class, false, "defaultEchoService");

        LOG.info(defaultEchoService.echo("Hello CDI bean resolved by name!"));

        OptionalService optionalService = BeanProvider.getContextualReference(OptionalService.class, true);
        
        if(optionalService == null)
        {
            LOG.info("No (optional) implementation found for "  OptionalService.class.getName());
        }
        else 
        {
            LOG.severe("Unexpected implementation found: "  optionalService.getClass().getName());
        }
        
import javax.inject.Named;
@Named("defaultEchoService")
     * An implementation has to add classes which shouldn't be used by DeltaSpike.
 * DeltaSpike has to introduce a proprietary mechanism.
     * <li>ClassLoader of this very ClassUtils class</li>
            //if a custom ProjectStageProducer is needed a custom config-source with a higher ordinal can be used
     * @param name the EL name of the bean
     * @param optional if <code>true</code> it will return <code>null</code> if no bean could be found or created.
     *                 Otherwise it will throw an {@code IllegalStateException}
     * @return the resolved Contextual Reference
     */
    public static Object getContextualReference(String name, boolean optional)
    {
        return getContextualReference(name, optional, Object.class);
    }

    /**
     * <p>Get a Contextual Reference by it's EL Name.
     * This only works for beans with the &#064;Named annotation.</p>
     *
     * @param name the EL name of the bean
     * @param type the type of the bean in question - only use Object.class if the type is unknown in dyn. use-cases
    public static <T> T getContextualReference(String name, boolean optional, Class<T> type)
        defaultEchoService = BeanProvider.getContextualReference("defaultEchoService", false, EchoService.class);
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/provider/MBean01.java
package org.apache.deltaspike.test.core.api.provider;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/provider/MBean02.java
package org.apache.deltaspike.test.core.api.provider;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/provider/MultiBean.java
package org.apache.deltaspike.test.core.api.provider;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/provider/NoBean.java
package org.apache.deltaspike.test.core.api.provider;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/temptestutil/ShrinkWrapArchiveUtil.java
package org.apache.deltaspike.test.core.api.temptestutil;
 * <p>This class provides access to the {@link BeanManager}
 * by registering the current {@link BeanManager} in an extension and
 * making it available via a singleton factory for the current application.</p>
 * <p>If a simple but manual bean-lookup is needed, it's easier to use the {@link BeanProvider}.</p>
 *
 * <p>As soon as an application shuts down, the reference to the {@link BeanManager} will be removed.<p>
     * Returns if the {@link BeanManagerProvider} has been initialized.
     * Usually it isn't needed to call this method in application code.
     * It's e.g. useful for other frameworks to check if DeltaSpike and the CDI container in general have been started.
     *
     * Allows to get the current provider instance which provides access to the current {@link BeanManager}
     *
     * @throws IllegalStateException if the {@link BeanManagerProvider} isn't ready to be used.
     * That's the case if the environment isn't configured properly and therefore the {@link AfterBeanDiscovery}
     * hasn't be called before this method gets called.
            //X TODO Java-EE5 support needs to be discussed
            // workaround for some Java-EE5 environments in combination with a special
            // StartupBroadcaster for bootstrapping CDI

            throw new IllegalStateException("No "  BeanManagerProvider.class.getName()  " in place! " 
                "If your setup is correct, please clear all caches and compiled artifacts.");
     * The active {@link BeanManager} for the current application (/{@link ClassLoader})
     *
     * It basically doesn't matter which of the system events we use,
     * but basically we use the {@link AfterBeanDiscovery} event since it allows to use the
     * {@link BeanManagerProvider} for all events which occur after the {@link AfterBeanDiscovery} event.
     *
     * @param afterBeanDiscovery event which we don't actually use ;)
     * @param beanManager the BeanManager we store and make available.
     */
    public void setBeanManager(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
    {
        BeanManagerProvider bmpFirst = setBeanManagerProvider(this);

        ClassLoader cl = ClassUtils.getClassLoader(null);
        bmpFirst.bms.put(cl, beanManager);

        //X TODO Java-EE5 support needs to be discussed
        //CodiStartupBroadcaster.broadcastStartup();
    }

    /**
     * Cleanup on container shutdown
     * @param beforeShutdown cdi shutdown event
     */
    public void cleanupStoredBeanManagerOnShutdown(@Observes BeforeShutdown beforeShutdown)
    {
        bms.remove(ClassUtils.getClassLoader(null));
    }

    /**
     * Workaround for JBossAS 6 (see EXTCDI-74)
     * is called in context of a different {@link ClassLoader}
     * @return current {@link javax.enterprise.inject.spi.BeanManager} which is provided via JNDI
     *
                        getClass().getName()  " supported operations: "  SimpleOperationEnum.getOperations() 
                        "separator: ';'");
        StringBuilder operations = new StringBuilder();
            operations.append(operation);
            operations.append(" ");
        return operations.toString();
                configuredOrdinal = Integer.valueOf(configuredOrdinalString.trim());
     * <p></p>Get a Contextual Reference by it's type and annotation (qualifier).
     * <p><b>Attention:</b> please see the notes on manually resolving &#064;Dependent bean
     * in {@link #getContextualReference(Class, boolean, java.lang.annotation.Annotation...)}!</p>
     *
     * @param type the type of the bean in question - use {@link #getContextualReference(String, boolean)}
     *             if the type is unknown e.g. in dyn. use-cases
     * <p><b>Attention:</b> please see the notes on manually resolving &#064;Dependent bean
     * in {@link #getContextualReference(Class, boolean, java.lang.annotation.Annotation...)}!</p>
     * Internal helper method to resolve the right bean and resolve the contextual reference.
     *
            if (resourceBundle != null && resourceBundle.containsKey(key))

import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * Implementation of {@link AnnotatedConstructor} to be used in {@link AnnotatedTypeBuilder}
 * and other CDI life cycle events.
    /**
     * Constructor
     */
    public AnnotatedConstructorImpl(AnnotatedTypeImpl<X> type, Constructor<?> constructor, AnnotationStore annotations,
                                    Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> typeOverrides)

import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * Implementation of {@link AnnotatedField} to be used in CDI life cycle events and {@link AnnotatedTypeBuilder}.
    /**
     * Constructor.
     */
    public AnnotatedFieldImpl(AnnotatedType<X> declaringType, Field field, AnnotationStore annotations,
                              Type overridenType)
    @Override
    @Override
    @Override
    @Override
    @Override

import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * An implementation of {@link AnnotatedMember} to be used in CDI life cycle events and {@link AnnotatedTypeBuilder}.
    @Override
    @Override
    @Override

import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * Implementation of {@link AnnotatedMethod} to be used in CDI life cycle events and {@link AnnotatedTypeBuilder}.
    /**
     * Constructor.
     */
    public AnnotatedMethodImpl(AnnotatedType<X> type, Method method, AnnotationStore annotations,
                               Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> parameterTypeOverrides)

    /**
     * Constructor
     */
    public AnnotatedParameterImpl(AnnotatedCallable<X> declaringCallable, Class<?> type, int position,
                                  AnnotationStore annotations, Type genericType, Type typeOverride)
    @Override
    @Override
 * An implementation of {@link AnnotatedType} to be used in CDI life cycle events and {@link AnnotatedTypeBuilder}.
    @Override
    @Override
    @Override
    @Override


    /**
     * Creates a new {@link Parameter} using the member and position passed in.
     *
     * @param declaringMember {@link Method} or {@link Constructor}.
     * @param position        position of the parameter
     * @param <X>             Type of the parameter
     * @return a new instance of Parameter
     */
    /**
     * Returns the actual {@link Member} declaring the parameter.
     *
     * @return Instance of the declaring java member.
     */
    /**
     * Getter
     */
    /**
     * Returns the instance of the annotation on the member, or null if not found
     */
    /**
     * Getter
     */
    /**
     * Simple test if an annotation is present.
     */
    /**
     * Getter
     */

 * Builder to aid in creation of a new {@link AnnotatedType} for use in CDI life cycle events.
 * Using the builder is typically done by reading the annotations from a {@link Class} or an
 * {@link AnnotatedType}. Once the starting class or type has been added all of annotations
 * can be modified: constructor, parameter, class, method and fields.
     * @param redefinition   the redefinition callback
    protected <A extends Annotation> void redefineAnnotationBuilder(Class<A> annotationType,
                                                                    AnnotationRedefiner<A> redefinition,
                                                                    AnnotatedElement annotated, Type baseType,
                                                                    AnnotationBuilder builder, String elementName)
    /**
     * Override the declared type of a parameter.
     *
     * @param parameter the parameter to override the type on
     * @param type      the new type of the parameter
     * @throws IllegalArgumentException if parameter or type is null
     */
    /**
     * getter for the class
     */
    /**
     * setter for the class
     */
import java.util.Collection;
 * A store of annotations to be used {@link AnnotatedTypeBuilder} and other places
 * where a collection of annotations needs manipulation.
    /**
     * Default constructor.
     */
    /**
     * Adds the annotation to the collections.
     *
     * @param annotation annotation to be added
     * @return this
     */
    /**
     * Removes the given annotation from the collections.
     *
     * @param annotationType to be removed
     * @return this
     */
    /**
     * Creates an {@link AnnotationStore} using the annotations from this instance.
     *
     * @return new AnnotationStore
     */
    /**
     * Adds all annotations from the given collection
     *
     * @param annotations collection of annotations to be added
     * @return this
     */
    public AnnotationBuilder addAll(Collection<Annotation> annotations)
    /**
     * Adds all annotations from an {@link AnnotationStore}.
     *
     * @param annotations annotations to be added
     * @return this
     */
    /**
     * Adds all annotations from the given {@link AnnotatedElement}.
     *
     * @param element element containing annotations to be added
     * @return this
     */
    /**
     * Getter.
     */
    /**
     * Simple check for an annotation.
     */
    private static <X, Y extends Member> List<AnnotatedParameter<X>> getAnnotatedParameters(AnnotatedCallableImpl<X, Y> callable, Class<?>[] parameterTypes, Type[] genericTypes,
                                                                                            Map<Integer, AnnotationStore> parameterAnnotations,
                                                                                            Map<Integer, Type> parameterTypeOverrides)
 * Implementation of {@link AnnotatedConstructor} to be used in {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}
 * Implementation of {@link AnnotatedField} to be used in CDI life cycle events and {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}.
 * An implementation of {@link AnnotatedMember} to be used in CDI life cycle events and {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}.
 * Implementation of {@link AnnotatedMethod} to be used in CDI life cycle events and {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}.
 * An implementation of {@link AnnotatedType} to be used in CDI life cycle events and {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}.
    public AnnotatedTypeImpl(Class<X> clazz, AnnotationStore typeAnnotations, Map<Field, AnnotationStore> fieldAnnotations, Map<Method, AnnotationStore> methodAnnotations,
                             Map<Method, Map<Integer, AnnotationStore>> methodParameterAnnotations, Map<Constructor<?>, AnnotationStore> constructorAnnotations,
                             Map<Constructor<?>, Map<Integer, AnnotationStore>> constructorParameterAnnotations, Map<Field, Type> fieldTypes,
                             Map<Method, Map<Integer, Type>> methodParameterTypes, Map<Constructor<?>, Map<Integer, Type>> constructorParameterTypes)
            AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(this, c, constructorAnnotations.get(c), constructorParameterAnnotations.get(c),
                    constructorParameterTypes.get(c));
                AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(this, c.getKey(), c.getValue(), constructorParameterAnnotations.get(c.getKey()),
                        constructorParameterTypes.get(c.getKey()));
                AnnotatedMethodImpl<X> nc = new AnnotatedMethodImpl<X>(this, c.getKey(), c.getValue(), methodParameterAnnotations.get(c.getKey()),
                        methodParameterTypes.get(c.getKey()));
 * {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}, and receives callbacks for each annotation of
 * @see org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder
            return (ownerType == null ? thatOwnerType == null : ownerType.equals(thatOwnerType))
                    && (rawType == null ? thatRawType == null : rawType.equals(thatRawType))
                    && Arrays.equals(actualTypeArguments, that.getActualTypeArguments());
 * @see org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder
     * {@link java.lang.reflect.Field}, if defined on a method, this may be cast to {@link java.lang.reflect.Method},
     * if defined on a constructor, this may be cast to {@link java.lang.reflect.Constructor}, if
//import java.util.Arrays;

            throw new ClassNotFoundException(String.format("Could not load class %s with the context class loader %s or any of the additional ClassLoaders: %s",
                    name, Thread.currentThread().getContextClassLoader(), loaders));
        {
            {
            }
        }
     * a {@link java.security.PrivilegedAction}.
        if (binding.annotationType().isAnnotationPresent(Qualifier.class)
                && binding.annotationType().isAnnotationPresent(Retention.class)
                && binding.annotationType().getAnnotation(Retention.class).value().equals(RetentionPolicy.RUNTIME))
 b/deltaspike/core/integration-test/src/test/java/org/apache/deltaspike/integration/util/ShrinkWrapArchiveUtil.java
package org.apache.deltaspike.integration.util;
 b/deltaspike/core/integration-test/src/test/java/org/apache/deltaspike/integration/category/FullProfileCategory.java
package org.apache.deltaspike.integration.category;
 b/deltaspike/core/integration-test/src/test/java/org/apache/deltaspike/integration/category/SeCategory.java
package org.apache.deltaspike.integration.category;
 b/deltaspike/core/integration-test/src/test/java/org/apache/deltaspike/integration/category/WebProfileCategory.java
package org.apache.deltaspike.integration.category;
import java.util.Collections;
import java.util.Comparator;
            appConfigSources = sortDescending(resolveConfigSources());
    private static ConfigSource[] sortDescending(List<ConfigSource> configSources)
        Collections.sort(configSources, new Comparator<ConfigSource>()
            /**
             * {@inheritDoc}
             */
            @Override
            public int compare(ConfigSource configSource1, ConfigSource configSource2)
                return (configSource1.getOrdinal() > configSource2.getOrdinal()) ? -1 : 1 ;
        });
        return configSources.toArray(new ConfigSource[configSources.size()]);
        return 300;
        return 200;
        return 100;
        return 400;
import org.apache.deltaspike.core.api.literal.NamedLiteral;

public interface ConfigSource
    /**
     * The default name for the ordinal field.
     * Any ConfigSource might use it's own though or even return a hardcoded
     * in {@link #getOrdinal()}.
     */
    static final String DELTASPIKE_ORDINAL = "deltaspike_ordinal";
    
    int getOrdinal();
    String getPropertyValue(String key);
    String getConfigName();
import org.apache.deltaspike.core.api.util.ClassUtils;
import java.io.IOException;
import java.net.URL;
import java.util.Enumeration;
    private static final String PROPERTY_FILE_NAME = "META-INF/apache-deltaspike.properties";


        ClassLoader cl = ClassUtils.getClassLoader(this);
        try 
        {
            Enumeration<URL> propertyFileUrls = cl.getResources(PROPERTY_FILE_NAME);

            while (propertyFileUrls.hasMoreElements())
            {
                URL propertyFileUrl = propertyFileUrls.nextElement();
                this.configSources.add(new PropertyFileConfigSource(propertyFileUrl));
            }
        }
        catch (IOException ioe) 
        {
            throw new RuntimeException("problem while loading DeltaSpike property files", ioe);
        }
        
class EnvironmentPropertyConfigSource implements ConfigSource
    private int ordinal = 300;
    
    public EnvironmentPropertyConfigSource()
    {
        // try to load the ordinal from the environment
        String envOrdinal = System.getenv(ConfigSource.DELTASPIKE_ORDINAL);
        if (envOrdinal != null && envOrdinal.length() > 0)
        {
            ordinal = Integer.parseInt(envOrdinal);
        }
    }
    
    public int getOrdinal()
        return ordinal;
class LocalJndiConfigSource implements ConfigSource
    private Integer ordinal = Integer.valueOf(100);

    public LocalJndiConfigSource()
        String ordinalVal = getPropertyValue(ConfigSource.DELTASPIKE_ORDINAL);
        if (ordinalVal != null && ordinalVal.length() > 0)
        {
            ordinal = Integer.valueOf(ordinalVal);
        }
    }

    @Override
    public int getOrdinal()
    {
        return ordinal;
import java.net.URL;
 * <i>META-INF/apache-deltaspike.properties</i> for the lookup
class PropertyFileConfigSource implements ConfigSource
    private Properties properties;
    private String fileName;
    PropertyFileConfigSource(URL propertyFileUrl)
        fileName = propertyFileUrl.toExternalForm();
        properties = loadProperties(propertyFileUrl);

        String ordinalVal = getPropertyValue(ConfigSource.DELTASPIKE_ORDINAL);
        if (ordinalVal != null && ordinalVal.length() > 0)
        {
            ordinal = Integer.valueOf(ordinalVal);
        }
    }

    private int ordinal = 100;
    
    @Override
    public int getOrdinal()
    {
        return ordinal;
        return (String) properties.get(key);
        return fileName;


    private Properties loadProperties(URL url)
        Properties props = new Properties();

        InputStream inputStream = null;
            inputStream = url.openStream();

            if (inputStream != null)
            {
                props.load(inputStream);
            }
        catch (IOException e)
        finally
                if (inputStream != null)
            }
            catch (IOException e)
            {
                // no worries, means that the file is already closed
        return props;
class SystemPropertyConfigSource implements ConfigSource
    private int ordinal = 400;

    SystemPropertyConfigSource()
    {
        String envOrdinal = getPropertyValue(ConfigSource.DELTASPIKE_ORDINAL);
        if (envOrdinal != null && envOrdinal.length() > 0)
        {
            ordinal = Integer.parseInt(envOrdinal);
        }
    }

    public int getOrdinal()
        return ordinal;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/exclude/AlwaysActiveBean.java
import javax.enterprise.context.Dependent;

@Dependent
public class AlwaysActiveBean
@Exclude(ifProjectStage = {ProjectStage.Development.class, ProjectStage.IntegrationTest.class})
 * {@link org.apache.deltaspike.core.spi.config.ConfigSource}
 * which uses System#getenv
class EnvironmentPropertyConfigSource extends BaseConfigSource

        initOrdinal(300);
 * {@link org.apache.deltaspike.core.spi.config.ConfigSource}
 * which uses JNDI for the lookup
class LocalJndiConfigSource extends BaseConfigSource
        initOrdinal(300);
 * {@link org.apache.deltaspike.core.spi.config.ConfigSource} which uses
class PropertyFileConfigSource extends BaseConfigSource
        initOrdinal(100);
 * {@link org.apache.deltaspike.core.spi.config.ConfigSource}
 * which uses System#getProperty
class SystemPropertyConfigSource extends BaseConfigSource
        initOrdinal(400);
    static String DELTASPIKE_ORDINAL = "deltaspike_ordinal";
     * Lookup order:
     *
     * <ol>
     *     <li>System properties (ordinal 400)</li>
     *     <li>Environment properties (ordinal 300)</li>
     *     <li>JNDI values (ordinal 200)</li>
     *     <li>Properties file values (/META-INF/apache-deltaspike.properties) (ordinal 100)</li>
     * </ol>
     * <p/>
     * <p><b>Important Hints for custom implementations</b>:</p>
     * <p>
     * If a custom implementation should be invoked <b>before</b> the default implementations, use a value &gt; 400
     * </p>
     * <p>
     * If a custom implementation should be invoked <b>after</b> the default implementations, use a value &lt; 100
     * </p>
     * <p>
     *
     *     <b>IMPORTANT: </b> Have a look at the abstract base-implementation DeltaSpike is using internally,
     *     if a custom implementation should load the ordinal value from the config-source like the default
     *     implementations provided by DeltaSpike do.
     *
     * </p>
     * <p/>
     * <p>Reordering of the default order of the config-sources:</p>
     * <p>Example: If the properties file/s should be used <b>before</b> the other implementations,
     * you have to configure an ordinal &gt; 400. That means, you have to add e.g. deltaspike_ordinal=401 to
     * /META-INF/apache-deltaspike.properties . Hint: In case of property files every file is handled as independent
     * config-source, but all of them have ordinal 400 by default (and can be reordered in a fine-grained manner.</p>
     *
    /**
     * {@inheritDoc}
     */

 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/category/FullProfileCategory.java
package org.apache.deltaspike.test.category;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/category/SeCategory.java
package org.apache.deltaspike.test.category;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/category/WebProfileCategory.java
package org.apache.deltaspike.test.category;
import org.apache.webbeans.annotation.NamedLiteral;
    private static <X, Y extends Member> List<AnnotatedParameter<X>> getAnnotatedParameters(AnnotatedCallableImpl<X, Y> callable, Class<?>[] parameterTypes, Type[] genericTypes, Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> parameterTypeOverrides)
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * Implementation of {@link AnnotatedConstructor} to be used in {@link AnnotatedTypeBuilder}
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * Implementation of {@link AnnotatedField} to be used in CDI life cycle events and {@link AnnotatedTypeBuilder}.
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * An implementation of {@link AnnotatedMember} to be used in CDI life cycle events and {@link AnnotatedTypeBuilder}.
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * Implementation of {@link AnnotatedMethod} to be used in CDI life cycle events and {@link AnnotatedTypeBuilder}.
 * An implementation of {@link AnnotatedType} to be used in CDI life cycle events and {@link AnnotatedTypeBuilder}.
    public AnnotatedTypeImpl(Class<X> clazz, AnnotationStore typeAnnotations, Map<Field, AnnotationStore> fieldAnnotations, Map<Method, AnnotationStore> methodAnnotations, Map<Method, Map<Integer, AnnotationStore>> methodParameterAnnotations, Map<Constructor<?>, AnnotationStore> constructorAnnotations, Map<Constructor<?>, Map<Integer, AnnotationStore>> constructorParameterAnnotations, Map<Field, Type> fieldTypes, Map<Method, Map<Integer, Type>> methodParameterTypes, Map<Constructor<?>, Map<Integer, Type>> constructorParameterTypes)
            AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(this, c, constructorAnnotations.get(c), constructorParameterAnnotations.get(c), constructorParameterTypes.get(c));
                AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(this, c.getKey(), c.getValue(), constructorParameterAnnotations.get(c.getKey()), constructorParameterTypes.get(c.getKey()));
                AnnotatedMethodImpl<X> nc = new AnnotatedMethodImpl<X>(this, c.getKey(), c.getValue(), methodParameterAnnotations.get(c.getKey()), methodParameterTypes.get(c.getKey()));
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * {@link AnnotatedTypeBuilder}, and receives callbacks for each annotation of
 * @see AnnotatedTypeBuilder
            return (ownerType == null ? thatOwnerType == null : ownerType.equals(thatOwnerType)) && (rawType == null ? thatRawType == null : rawType.equals(thatRawType)) && Arrays.equals(actualTypeArguments, that.getActualTypeArguments());
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
 * @see AnnotatedTypeBuilder
     * {@link Field}, if defined on a method, this may be cast to {@link Method},
     * if defined on a constructor, this may be cast to {@link Constructor}, if
import java.security.PrivilegedAction;
            throw new ClassNotFoundException("Could not load class "  name  " with the context class loader "  Thread.currentThread().getContextClassLoader().toString()  " or any of the additional ClassLoaders: "  Arrays.toString(loaders));
     * a {@link PrivilegedAction}.
        if (binding.annotationType().isAnnotationPresent(Qualifier.class) && binding.annotationType().isAnnotationPresent(Retention.class) && binding.annotationType().getAnnotation(Retention.class).value().equals(RetentionPolicy.RUNTIME))
 *
    AnnotatedConstructorImpl(AnnotatedTypeImpl<X> type, Constructor<?> constructor, AnnotationStore annotations,
                             Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> typeOverrides)
 *
    AnnotatedFieldImpl(AnnotatedType<X> declaringType, Field field, AnnotationStore annotations, Type overridenType)
 *
 * @author Stuart Douglas
    AnnotatedMethodImpl(AnnotatedType<X> type, Method method, AnnotationStore annotations,
                        Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> parameterTypeOverrides)
    AnnotatedParameterImpl(AnnotatedCallable<X> declaringCallable, Class<?> type, int position,
                           AnnotationStore annotations, Type genericType, Type typeOverride)
 *
 * @author Pete Muir
 *
 * @author pmuir

 * @author Pete Muir
 *
//X TODO: Javadoc
     * @param redefinition   the redefiniton callback
    protected <A extends Annotation> void redefineAnnotationBuilder(Class<A> annotationType, AnnotationRedefiner<A> redefinition, AnnotatedElement annotated, Type baseType, AnnotationBuilder builder, String elementName)
 *
    public AnnotationBuilder addAll(Set<Annotation> annotations)

import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * Implementation of {@link AnnotatedConstructor} to be used in {@link AnnotatedTypeBuilder}
 * and other CDI life cycle events.
    /**
     * Constructor
     */
    public AnnotatedConstructorImpl(AnnotatedTypeImpl<X> type, Constructor<?> constructor, AnnotationStore annotations,
                                    Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> typeOverrides)

import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * Implementation of {@link AnnotatedField} to be used in CDI life cycle events and {@link AnnotatedTypeBuilder}.
    /**
     * Constructor.
     */
    public AnnotatedFieldImpl(AnnotatedType<X> declaringType, Field field, AnnotationStore annotations,
                              Type overridenType)
    @Override
    @Override
    @Override
    @Override
    @Override

import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * An implementation of {@link AnnotatedMember} to be used in CDI life cycle events and {@link AnnotatedTypeBuilder}.
    @Override
    @Override
    @Override

import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;

 * Implementation of {@link AnnotatedMethod} to be used in CDI life cycle events and {@link AnnotatedTypeBuilder}.
    /**
     * Constructor.
     */
    public AnnotatedMethodImpl(AnnotatedType<X> type, Method method, AnnotationStore annotations,
                               Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> parameterTypeOverrides)

    /**
     * Constructor
     */
    public AnnotatedParameterImpl(AnnotatedCallable<X> declaringCallable, Class<?> type, int position,
                                  AnnotationStore annotations, Type genericType, Type typeOverride)
    @Override
    @Override
 * An implementation of {@link AnnotatedType} to be used in CDI life cycle events and {@link AnnotatedTypeBuilder}.
    @Override
    @Override
    @Override
    @Override


    /**
     * Creates a new {@link Parameter} using the member and position passed in.
     *
     * @param declaringMember {@link Method} or {@link Constructor}.
     * @param position        position of the parameter
     * @param <X>             Type of the parameter
     * @return a new instance of Parameter
     */
    /**
     * Returns the actual {@link Member} declaring the parameter.
     *
     * @return Instance of the declaring java member.
     */
    /**
     * Getter
     */
    /**
     * Returns the instance of the annotation on the member, or null if not found
     */
    /**
     * Getter
     */
    /**
     * Simple test if an annotation is present.
     */
    /**
     * Getter
     */

 * Builder to aid in creation of a new {@link AnnotatedType} for use in CDI life cycle events.
 * Using the builder is typically done by reading the annotations from a {@link Class} or an
 * {@link AnnotatedType}. Once the starting class or type has been added all of annotations
 * can be modified: constructor, parameter, class, method and fields.
     * @param redefinition   the redefinition callback
    protected <A extends Annotation> void redefineAnnotationBuilder(Class<A> annotationType,
                                                                    AnnotationRedefiner<A> redefinition,
                                                                    AnnotatedElement annotated, Type baseType,
                                                                    AnnotationBuilder builder, String elementName)
    /**
     * Override the declared type of a parameter.
     *
     * @param parameter the parameter to override the type on
     * @param type      the new type of the parameter
     * @throws IllegalArgumentException if parameter or type is null
     */
    /**
     * getter for the class
     */
    /**
     * setter for the class
     */
import java.util.Collection;
 * A store of annotations to be used {@link AnnotatedTypeBuilder} and other places
 * where a collection of annotations needs manipulation.
    /**
     * Default constructor.
     */
    /**
     * Adds the annotation to the collections.
     *
     * @param annotation annotation to be added
     * @return this
     */
    /**
     * Removes the given annotation from the collections.
     *
     * @param annotationType to be removed
     * @return this
     */
    /**
     * Creates an {@link AnnotationStore} using the annotations from this instance.
     *
     * @return new AnnotationStore
     */
    /**
     * Adds all annotations from the given collection
     *
     * @param annotations collection of annotations to be added
     * @return this
     */
    public AnnotationBuilder addAll(Collection<Annotation> annotations)
    /**
     * Adds all annotations from an {@link AnnotationStore}.
     *
     * @param annotations annotations to be added
     * @return this
     */
    /**
     * Adds all annotations from the given {@link AnnotatedElement}.
     *
     * @param element element containing annotations to be added
     * @return this
     */
    /**
     * Getter.
     */
    /**
     * Simple check for an annotation.
     */
    private static <X, Y extends Member> List<AnnotatedParameter<X>> getAnnotatedParameters(AnnotatedCallableImpl<X, Y> callable, Class<?>[] parameterTypes, Type[] genericTypes,
                                                                                            Map<Integer, AnnotationStore> parameterAnnotations,
                                                                                            Map<Integer, Type> parameterTypeOverrides)
 * Implementation of {@link AnnotatedConstructor} to be used in {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}
 * Implementation of {@link AnnotatedField} to be used in CDI life cycle events and {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}.
 * An implementation of {@link AnnotatedMember} to be used in CDI life cycle events and {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}.
 * Implementation of {@link AnnotatedMethod} to be used in CDI life cycle events and {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}.
 * An implementation of {@link AnnotatedType} to be used in CDI life cycle events and {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}.
    public AnnotatedTypeImpl(Class<X> clazz, AnnotationStore typeAnnotations, Map<Field, AnnotationStore> fieldAnnotations, Map<Method, AnnotationStore> methodAnnotations,
                             Map<Method, Map<Integer, AnnotationStore>> methodParameterAnnotations, Map<Constructor<?>, AnnotationStore> constructorAnnotations,
                             Map<Constructor<?>, Map<Integer, AnnotationStore>> constructorParameterAnnotations, Map<Field, Type> fieldTypes,
                             Map<Method, Map<Integer, Type>> methodParameterTypes, Map<Constructor<?>, Map<Integer, Type>> constructorParameterTypes)
            AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(this, c, constructorAnnotations.get(c), constructorParameterAnnotations.get(c),
                    constructorParameterTypes.get(c));
                AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(this, c.getKey(), c.getValue(), constructorParameterAnnotations.get(c.getKey()),
                        constructorParameterTypes.get(c.getKey()));
                AnnotatedMethodImpl<X> nc = new AnnotatedMethodImpl<X>(this, c.getKey(), c.getValue(), methodParameterAnnotations.get(c.getKey()),
                        methodParameterTypes.get(c.getKey()));
 * {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}, and receives callbacks for each annotation of
 * @see org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder
            return (ownerType == null ? thatOwnerType == null : ownerType.equals(thatOwnerType))
                    && (rawType == null ? thatRawType == null : rawType.equals(thatRawType))
                    && Arrays.equals(actualTypeArguments, that.getActualTypeArguments());
 * @see org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder
     * {@link java.lang.reflect.Field}, if defined on a method, this may be cast to {@link java.lang.reflect.Method},
     * if defined on a constructor, this may be cast to {@link java.lang.reflect.Constructor}, if
//import java.util.Arrays;

            throw new ClassNotFoundException(String.format("Could not load class %s with the context class loader %s or any of the additional ClassLoaders: %s",
                    name, Thread.currentThread().getContextClassLoader(), loaders));
        {
            {
            }
        }
     * a {@link java.security.PrivilegedAction}.
        if (binding.annotationType().isAnnotationPresent(Qualifier.class)
                && binding.annotationType().isAnnotationPresent(Retention.class)
                && binding.annotationType().getAnnotation(Retention.class).value().equals(RetentionPolicy.RUNTIME))
import org.apache.deltaspike.core.api.literal.NamedLiteral;
public interface AnnotationRedefiner
    public void redefine(RedefinitionContext ctx);
public class RedefinitionContext
     * defined on a parameter, this may be cast to {@link org.apache.deltaspike.core.api.metadata.builder.Parameter}
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/metadata/builder/AnnotatedCallableImpl.java
package org.apache.deltaspike.core.api.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/metadata/builder/AnnotatedConstructorImpl.java
package org.apache.deltaspike.core.api.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/metadata/builder/AnnotatedFieldImpl.java
package org.apache.deltaspike.core.api.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/metadata/builder/AnnotatedImpl.java
package org.apache.deltaspike.core.api.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/metadata/builder/AnnotatedMemberImpl.java
package org.apache.deltaspike.core.api.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/metadata/builder/AnnotatedMethodImpl.java
package org.apache.deltaspike.core.api.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/metadata/builder/AnnotatedParameterImpl.java
package org.apache.deltaspike.core.api.metadata.builder;
    public <A extends Annotation> AnnotatedTypeBuilder<X> redefine(Class<A> annotationType, AnnotationRedefiner redefinition)
                                                                    AnnotationRedefiner redefinition,
            redefinition.redefine(new RedefinitionContext(annotated, baseType, builder, elementName));
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/metadata/builder/AnnotatedTypeImpl.java
package org.apache.deltaspike.core.api.metadata.builder;
class AnnotatedTypeImpl<X> extends AnnotatedImpl implements AnnotatedType<X>
    AnnotatedTypeImpl(Class<X> clazz, AnnotationStore typeAnnotations, Map<Field, AnnotationStore> fieldAnnotations, Map<Method, AnnotationStore> methodAnnotations,
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/metadata/builder/AnnotationStore.java
package org.apache.deltaspike.core.api.metadata.builder;
class AnnotationStore
    AnnotationStore(Map<Class<? extends Annotation>, Annotation> annotationMap, Set<Annotation> annotationSet)
    AnnotationStore()
    <T extends Annotation> T getAnnotation(Class<T> annotationType)
    Set<Annotation> getAnnotations()
    boolean isAnnotationPresent(Class<? extends Annotation> annotationType)
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/metadata/builder/Parameter.java
package org.apache.deltaspike.core.api.metadata.builder;
abstract class Parameter<X> implements AnnotatedElement
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/util/ParameterizedTypeImpl.java
package org.apache.deltaspike.core.api.util;
class ParameterizedTypeImpl implements ParameterizedType
    ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type ownerType)
public class NamedAnnotationRedefiner implements AnnotationRedefiner
    public void redefine(RedefinitionContext ctx)
@Named("DefaultEchoService")
//will be changed to defaultEchoService by org.apache.deltaspike.example.metadata.NamingConventionAwareMetadataFilter
    /**
     * {@inheritDoc}
     */
    private static <X, Y extends Member> List<AnnotatedParameter<X>> getAnnotatedParameters(
            AnnotatedCallableImpl<X, Y> callable, Class<?>[] parameterTypes, Type[] genericTypes,
            Map<Integer, AnnotationStore> parameterAnnotations,
            Map<Integer, Type> parameterTypeOverrides)

            AnnotatedParameterImpl<X> p = new AnnotatedParameterImpl<X>(
                    callable, parameterTypes[i], i, builder.create(), genericTypes[i], over);

 * Implementation of {@link AnnotatedConstructor} to be used in
 * {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}
                                    Map<Integer, AnnotationStore> parameterAnnotations,
                                    Map<Integer, Type> typeOverrides)
 * Implementation of {@link AnnotatedField} to be used in CDI life cycle events and
 * {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}.
 * An implementation of {@link AnnotatedMember} to be used in CDI life cycle events and
 * {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}.
 * Implementation of {@link AnnotatedMethod} to be used in CDI life cycle events and
 * {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}.
    public AnnotatedMethodImpl(AnnotatedType<X> type,
                               Method method,
                               AnnotationStore annotations,
                               Map<Integer, AnnotationStore> parameterAnnotations,
                               Map<Integer, Type> parameterTypeOverrides)
    public AnnotatedTypeBuilder<X> removeFromField(AnnotatedField<? super X> field,
                                                   Class<? extends Annotation> annotationType)
    public AnnotatedTypeBuilder<X> removeFromMethod(AnnotatedMethod<? super X> method,
                                                    Class<? extends Annotation> annotationType)
    public AnnotatedTypeBuilder<X> removeFromMethodParameter(Method method,
                                                             int position, Class<? extends Annotation> annotationType)
                throw new IllegalArgumentException(
                        String.format("parameter %s not present on method %s declared on class %s",
    public AnnotatedTypeBuilder<X> removeFromConstructor(Constructor<X> constructor,
                                                         Class<? extends Annotation> annotationType)
    public AnnotatedTypeBuilder<X> removeFromConstructor(AnnotatedConstructor<X> constructor,
                                                         Class<? extends Annotation> annotationType)
    public AnnotatedTypeBuilder<X> addToConstructorParameter(Constructor<X> constructor,
                                                             int position,
                                                             Annotation annotation)
    public AnnotatedTypeBuilder<X> removeFromConstructorParameter(Constructor<X> constructor,
                                                                  int position,
                                                                  Class<? extends Annotation> annotationType)
    public AnnotatedTypeBuilder<X> removeFromParameter(AnnotatedParameter<? super X> parameter,
                                                       Class<? extends Annotation> annotationType)
            throw new IllegalArgumentException("Cannot remove from parameter "  parameter 
                    " - cannot operate on member "  parameter.getDeclaringCallable().getJavaMember());
            throw new IllegalArgumentException("Cannot remove from parameter "  parameter 
                    " - cannot operate on member "  parameter.getDeclaringCallable().getJavaMember());
                for (Map.Entry<Integer, AnnotationBuilder> parameter :
                        constructorParameters.get(constructor.getKey()).entrySet())
                mergeAnnotationsOnElement(
                        p, overwrite, methodParameters.get(method.getJavaMember()).get(p.getPosition()));
                if (constructorParameters.get(
                        constructor.getJavaMember()) == null)
                    constructorParameters.put(
                        constructor.getJavaMember(), new HashMap<Integer, AnnotationBuilder>());
                if (constructorParameters.get(
                        constructor.getJavaMember()).get(p.getPosition()) == null)
                    constructorParameters.get(
                        constructor.getJavaMember()).put(p.getPosition(), new AnnotationBuilder());
                mergeAnnotationsOnElement(
                        p, overwrite, constructorParameters.get(constructor.getJavaMember()).get(p.getPosition()));
    protected void mergeAnnotationsOnElement(Annotated annotated,
                                             boolean overwriteExisting,
                                             AnnotationBuilder typeAnnotations)
        Map<Constructor<?>, Map<Integer, AnnotationStore>> constructorParameterAnnnotations =
                new HashMap<Constructor<?>, Map<Integer, AnnotationStore>>();
        Map<Constructor<?>, AnnotationStore> constructorAnnotations =
                new HashMap<Constructor<?>, AnnotationStore>();
        Map<Method, Map<Integer, AnnotationStore>> methodParameterAnnnotations =
                new HashMap<Method, Map<Integer, AnnotationStore>>();
        Map<Method, AnnotationStore> methodAnnotations =
                new HashMap<Method, AnnotationStore>();
        Map<Field, AnnotationStore> fieldAnnotations =
                new HashMap<Field, AnnotationStore>();
            throw new IllegalArgumentException("Cannot remove from parameter "  parameter 
                    " - cannot operate on member "  parameter.getDeclaringCallable().getJavaMember());
 * An implementation of {@link AnnotatedType} to be used in CDI life cycle events and
 * {@link org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder}.
    AnnotatedTypeImpl(Class<X> clazz,
                      AnnotationStore typeAnnotations,
                      Map<Field, AnnotationStore> fieldAnnotations,
                      Map<Method, AnnotationStore> methodAnnotations,
                      Map<Method, Map<Integer, AnnotationStore>> methodParameterAnnotations,
                      Map<Constructor<?>, AnnotationStore> constructorAnnotations,
                      Map<Constructor<?>, Map<Integer, AnnotationStore>> constructorParameterAnnotations,
                      Map<Field, Type> fieldTypes,
                      Map<Method, Map<Integer, Type>> methodParameterTypes,
                      Map<Constructor<?>, Map<Integer, Type>> constructorParameterTypes)
            AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(
                    this, c, constructorAnnotations.get(c), constructorParameterAnnotations.get(c),
                AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(
                        this, c.getKey(), c.getValue(), constructorParameterAnnotations.get(c.getKey()),
                AnnotatedMethodImpl<X> met = new AnnotatedMethodImpl<X>(this, m, methodAnnotations.get(m),
                        methodParameterAnnotations.get(m), methodParameterTypes.get(m));
                AnnotatedMethodImpl<X> nc = new AnnotatedMethodImpl<X>(
                        this, c.getKey(),
                        c.getValue(),
                        methodParameterAnnotations.get(c.getKey()),
            throw new IllegalArgumentException(
                    "Can only process members of type Method and Constructor, cannot process "  declaringMember);
            return this.getDeclaringMember().equals(that.getDeclaringMember()) &&
                    this.getPosition() == that.getPosition();
import javax.enterprise.inject.Typed;
@Typed()

            @SuppressWarnings("UnnecessaryLocalVariable")
            ParameterizedType parameterizedType =
                    new ParameterizedTypeImpl(clazz, actualTypeParameters, clazz.getDeclaringClass());
import javax.enterprise.inject.Typed;
@Typed()
        return Arrays.hashCode(actualTypeArguments) ^ (ownerType == null ? 0 :
                ownerType.hashCode()) ^ (rawType == null ? 0 : rawType.hashCode());
import javax.enterprise.inject.Typed;
@Typed()
    private Reflections()
    {
    }

            if (annotatedField.getDeclaringType().getJavaClass().equals(field.getDeclaringClass()) &&
                    annotatedField.getJavaMember().getName().equals(field.getName()))
    public static Set<Annotation> getAnnotationsWithMetaAnnotation(Set<Annotation> annotations,
                                                                   Class<? extends Annotation> metaAnnotationType)
            throw new ClassNotFoundException(String.format(
                "Could not load class %s with the context class loader %s or any of the additional ClassLoaders: %s",
                name, Thread.currentThread().getContextClassLoader(), loaders));
            throw new ClassNotFoundException("Could not load class "  name 
                    " using Class.forName or using any of the additional ClassLoaders: "  Arrays.toString(loaders));
        StringBuilder message = new StringBuilder(String.format(
                "Exception invoking method [%s] on object [%s], using arguments [", method.getName(), obj));
                message.append(i > 0 ? "," : "")
                       .append(args[i]);
    public static <T> T invokeMethod(boolean setAccessible,
                                     Method method, Class<T> expectedReturnType,
                                     Object instance, Object... args)
            ExceptionInInitializerError e2 =
                    new ExceptionInInitializerError(buildInvokeMethodErrorMessage(method, instance, args));
            ExceptionInInitializerError e2 =
                    new ExceptionInInitializerError(buildSetFieldValueErrorMessage(field, instance, value));
            ExceptionInInitializerError e2 =
                    new ExceptionInInitializerError(buildGetFieldValueErrorMessage(field, instance));
    public static boolean isAssignableFrom(Class<?> rawType1,
                                           Type[] actualTypeArguments1,
                                           Class<?> rawType2,
                                           Type[] actualTypeArguments2)
        return Types.boxedClass(rawType1).isAssignableFrom(Types.boxedClass(rawType2)) &&
                isAssignableFrom(actualTypeArguments1, actualTypeArguments2);
    public static boolean matches(Class<?> rawType1,
                                  Type[] actualTypeArguments1,
                                  Class<?> rawType2,
                                  Type[] actualTypeArguments2)
        return Types.boxedClass(rawType1).equals(Types.boxedClass(rawType2)) &&
                isAssignableFrom(actualTypeArguments1, actualTypeArguments2);
                if (isAssignableFrom((Class<?>) parameterizedType1.getRawType(),
                                     parameterizedType1.getActualTypeArguments(),
                                     type2))
                if (matches((Class<?>) parameterizedType1.getRawType(),
                        parameterizedType1.getActualTypeArguments(),
                        type2))
                if (isAssignableFrom(
                        rawType1,
                        actualTypeArguments1,
                        (Class<?>) parameterizedType.getRawType(),
                        parameterizedType.getActualTypeArguments()))
                if (matches(
                        rawType1,
                        actualTypeArguments1,
                        (Class<?>) parameterizedType.getRawType(),
                        parameterizedType.getActualTypeArguments()))
        return rawType != null && rawType.isPrimitive();
import javax.enterprise.inject.Typed;
@Typed()
import javax.enterprise.inject.Typed;
@Typed()
    private Types()
    {
    }
    protected Logger log = Logger.getLogger(getClass().getName());
            log.log(Level.WARNING,
    @Override
    private static final Logger LOG = Logger.getLogger(ConfigResolver.class.getName());
        = new ConcurrentHashMap<ClassLoader, ConfigSource[]>();
    private ConfigResolver()
    {
        // this is a utility class which doesn't get instantiated.
    }
            = ServiceLoader.load(ConfigSourceProvider.class);
@Target({ ElementType.TYPE })
    Class<? extends ProjectStage>[] ifProjectStage() default { };
    Class<? extends ProjectStage>[] exceptIfProjectStage() default { };
    private static final String ASTERISK = "*";

    @Override
        for (String expression : foundExpressions)
            if (expression.contains(SimpleOperationEnum.IS.getValue()))
            else if (expression.contains(SimpleOperationEnum.NOT.getValue()))
            if (configuredValue != null)
            if (!ASTERISK.equals(keyValue[1]) && "".equals(configuredValue))
            if (ASTERISK.equals(keyValue[1]) && !"".equals(configuredValue))
            if (SimpleOperationEnum.IS.equals(operation) && !keyValue[1].equalsIgnoreCase(configuredValue))
            else if (SimpleOperationEnum.NOT.equals(operation) && keyValue[1].equalsIgnoreCase(configuredValue))
        for (SimpleOperationEnum operation : SimpleOperationEnum.values())
    @Override
    private final Class<?>[] value;
    private final int position;

    Parameter(int position)
    {
        this.position = position;
    }
    /**
     * Returns the actual {@link Member} declaring the parameter.
     *
     * @return Instance of the declaring java member.
     */
    public abstract Member getDeclaringMember();

    /**
     * Getter
     */
    public int getPosition()
    {
        return position;
    }

    @Override
    public int hashCode()
    {
        int hash = 1;
        hash = hash * 31  getDeclaringMember().hashCode();
        hash = hash * 31  Integer.valueOf(position).hashCode();
        return hash;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof Parameter<?>)
        {
            Parameter<?> that = (Parameter<?>) obj;
            return this.getDeclaringMember().equals(that.getDeclaringMember()) &&
                    this.getPosition() == that.getPosition();
        }
        else
        {
            return false;
        }

    }

    /**
     * Returns the instance of the annotation on the member, or null if not found
     */
    public <T extends Annotation> T getAnnotation(Class<T> annotationClass)
    {
        for (Annotation annotation : getAnnotations())
        {
            if (annotation.annotationType().equals(annotationClass))
            {
                return annotationClass.cast(annotation);
            }
        }
        return null;
    }

    /**
     * Getter
     */
    public Annotation[] getDeclaredAnnotations()
    {
        return getAnnotations();
    }

    /**
     * Simple test if an annotation is present.
     */
    public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)
    {
        return getAnnotation(annotationClass) != null;
    }

    /**
     * Getter
     */
    public abstract Type getBaseType();

        if (bmp == null)
        if (bmp == null)
            if (result != null)
     * @param name     the EL name of the bean
        if (!includeDefaultScopedBeans)


        for (Bean<?> bean : beans)
                    new HashSet<Bean<?>>((Collection) Arrays.asList(new Object[]{bean}))));
            if (!Dependent.class.isAssignableFrom(currentBean.getScope()))
        @SuppressWarnings({ "unchecked", "UnnecessaryLocalVariable" })
        T result = (T) beanManager.getReference(bean, type, creationalContext);
            @Override
        throws ClassNotFoundException, IllegalAccessException, InstantiationException
    private Reflections()
    {
    }

    String DELTASPIKE_ORDINAL = "deltaspike_ordinal";
            if (configuredOrdinalString != null)
    @Override
    private static final long serialVersionUID = -2987762608635612074L;
     * ProjectStageProducers must only be created by subclassing producers
     */
    protected ProjectStageProducer()
    {
    }

    /**
        if (projectStage == null)
        if (projectStage == null)
        if (customProjectStageProducerName != null)
            if (customConfiguredProducer != null)
        if (projectStageProducer == null)
            if (projectStage == null)
                if (projectStage == null)
        for (String classDeactivatorClassName : classDeactivatorClassNames)
            if (currentClassDeactivator != null)
        = new ConcurrentHashMap<ClassLoader, ClassDeactivator>();

    private ClassDeactivatorStorage()
    {
    }
    // HashSet due to Serializable warning in checkstyle rules
    public final synchronized Set<Class> getDeactivatedClasses()
 * <p>A class-deactivator allows to specify deactivated classes which can't be deactivated via std. CDI mechanisms.</p>
 * 
 * <p>A class-deactivator will be resolved from the environment via the default resolvers or via a custom resolver which
 * allows to use any type of configuration-format. See {@link org.apache.deltaspike.core.api.config.ConfigResolver}
 * for more information about how to configure it. The configuration key is
 * <code>org.apache.deltaspike.core.api.activation.ClassDeactivator</code></p>
 * 
 * <p>Furthermore, {@link AbstractClassDeactivator} is a convenience class which
 * with this mechanism. For all other classes/beans, you can use the veto mechanism provided by CDI.</p>
 *
 * This is e.g. used to disable CDI Extensions in DeltaSpike and might get
 * used for other Extension libraries as well.
 * <p>A class-deactivator allows to specify deactivated classes which can't be deactivated via std. CDI mechanisms.
 * This might be the case for CDI Extensions because CDI mechanisms are not available at startup time.</p>
 * <p>All DlassDeactivators will get picked up in order of their ordinal and might explicitely activate or 
 * deactivate {@link Deactivatable} classes. Returning a <code>null</code> value means that the ClassDeactivator
 * doesn't care about the very Deactivatable class.</p>
 * 
     * @return {@link Boolean#FALSE} if class should get activated, {@link Boolean#FALSE} if class must be available
     *         and <code>null</code> to let it as is (defined by default or other 
    Boolean isActivated(Class<? extends Deactivatable> deactivatableClazz);
 * <p>Interface to allow easier detection of deactivatable classes.</p>
 * <p>These classes are activated by default and can be disabled on demand (e.g. via CDI config).
 * Since CDI, JSF,... currently don't allow to deactivate default implementations,
 * DeltaSpike has to introduce a proprietary mechanism.</p>
 *
 * <p>This is e.g. used to disable CDI Extensions in DeltaSpike and might get
 * used for other Extension libraries as well.</p>
 *
 * <p><b>Note:</b> It is suggested that the implementations
 * use the {@link ClassDeactivation} for implementing the lookup</p>
     * Resolve all values for the given key, from all registered ConfigSources ordered by their
     * ordinal value in ascending ways. If more {@link ConfigSource}s have the same ordinal, their
     * order is undefined.
     *
     * @param key under which configuration is stored
     * @return List with all found property values, sorted in ascending order of their ordinal.
     * @see org.apache.deltaspike.core.spi.config.ConfigSource#getOrdinal()
import org.apache.deltaspike.core.api.activation.ClassDeactivation;
    private Boolean isActivated = null;

        if (isActivated == null)
        {
            isActivated = ClassDeactivation.isActivated(getClass());
        }
        return isActivated;
import org.apache.deltaspike.core.api.activation.Deactivatable;

public class ActivatedClass implements Deactivatable

import org.apache.deltaspike.core.api.activation.Deactivatable;

public class DeactivatedClass implements Deactivatable
    /**
     * Cache for the result. It won't contain many classes but it might be accessed frequently.
     * Valid entries are only true or false. If an entry isn't available or null, it gets calculated.
     */
    private static Map<Class<? extends Deactivatable>, Boolean> activationStatusCache
        = new ConcurrentHashMap<Class<? extends Deactivatable>, Boolean>();
    
     * @param targetClass {@link Deactivatable} under test.
    public static boolean isActivated(Class<? extends Deactivatable> targetClass)
        Boolean activatedClassCacheEntry = activationStatusCache.get(targetClass);

        if (activatedClassCacheEntry == null)
        {
            initDeactivatableCacheFor(targetClass);
            activatedClassCacheEntry = activationStatusCache.get(targetClass);
        }
        return activatedClassCacheEntry;
    }

    private static synchronized void initDeactivatableCacheFor(Class<? extends Deactivatable> targetClass)
    {
        Boolean activatedClassCacheEntry = activationStatusCache.get(targetClass);

        if (activatedClassCacheEntry != null) //double-check
        {
            return;
        }

        Boolean isActivated = null;
        Boolean isLocallyActivated;
        Class<? extends ClassDeactivator> deactivationDetected = null;

        LOG.info("start evaluation if "  targetClass.getName()  " is de-/activated");
            isLocallyActivated = classDeactivator.isActivated(targetClass);


            /*
             * Check and log the details across class-deactivators
             */
            if (Boolean.FALSE.equals(isActivated))
            {
                deactivationDetected = classDeactivator.getClass();
                LOG.fine("Deactivating class "  targetClass);
            }
            else if (Boolean.TRUE.equals(isActivated) && deactivationDetected != null)
            {
                LOG.fine("Reactivation of: "  targetClass.getName()  " by "  classDeactivator.getClass().getName() 
                        " - original deactivated by: "  deactivationDetected.getName()  ".");

                LOG.fine("If that isn't the intended behaviour, you have to use a higher ordinal for " 
                        deactivationDetected.getName());
            }
        cacheResult(targetClass, isActivated);
    private static void cacheResult(Class<? extends Deactivatable> targetClass, Boolean activated)
    {
        if (Boolean.FALSE.equals(activated))
        {
            activationStatusCache.put(targetClass, false);
            LOG.info("class: "  targetClass.getName()  " is deactivated.");
        }
        else //in case of true or null (classes are activated by default)
        {
            activationStatusCache.put(targetClass, true);
            LOG.info("class: "  targetClass.getName()  " is activated.");
        }
    }
        ClassLoader classLoader = ClassUtils.getClassLoader(null);
        List<ClassDeactivator> classDeactivators = classDeactivatorMap.get(classLoader);

            return initConfiguredClassDeactivators(classLoader);
    //synchronized isn't needed - #initDeactivatableCacheFor is already synchronized
    private static List<ClassDeactivator> initConfiguredClassDeactivators(ClassLoader classLoader)
                throw new IllegalStateException(e);
        classDeactivatorMap.put(classLoader, classDeactivators);
 * <p>An implementation has to be stateless.</p>
 *
        Boolean isActivated = Boolean.TRUE;
        Class<? extends ClassDeactivator> deactivatedBy = null;
        LOG.fine("start evaluation if "  targetClass.getName()  " is de-/activated");
        // we get the classActivators ordered by it's ordinal
        // thus the last one which returns != null 'wins' ;)
            Boolean isLocallyActivated = classDeactivator.isActivated(targetClass);
                /*
                * Check and log the details across class-deactivators
                */
                if (!isActivated)
                {
                    deactivatedBy = classDeactivator.getClass();
                    LOG.fine("Deactivating class "  targetClass);
                }
                else if (isActivated && deactivatedBy != null)
                {
                    LOG.fine("Reactivation of: "  targetClass.getName()  " by " 
                            classDeactivator.getClass().getName() 
                            " - original deactivated by: "  deactivatedBy.getName()  ".\n" 
                            "If that isn't the intended behaviour, you have to use a higher ordinal for " 
                            deactivatedBy.getName());
                }
        activationStatusCache.put(targetClass, activated);
        LOG.info("class: "  targetClass.getName()  " activated="  activated);
                else if (deactivatedBy != null)
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/spi/activation/ClassDeactivator.java
package org.apache.deltaspike.core.spi.activation;
 * <code>org.apache.deltaspike.core.spi.activation.ClassDeactivator</code></p>
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/spi/activation/Deactivatable.java
package org.apache.deltaspike.core.spi.activation;
 * use the {@link org.apache.deltaspike.core.spi.activation.util.ClassDeactivation} for implementing the lookup</p>
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/spi/activation/util/ClassDeactivation.java
package org.apache.deltaspike.core.spi.activation.util;
import org.apache.deltaspike.core.spi.activation.ClassDeactivator;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.spi.activation.util.ClassDeactivation;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
    protected void setBeanManager(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
    protected void cleanupStoredBeanManagerOnShutdown(@Observes BeforeShutdown beforeShutdown)
import javax.enterprise.event.Observes;
import javax.enterprise.inject.spi.BeanManager;
    
    protected void doSomeObservation(@Observes Cat cat, BeanManager beanManager)
    {
        // whoah, someone fires cats around ^^
        // at least it tests parameter scanning ;)
        this.color = cat.color;
    }
     * @param targetClass class which should be checked
    Boolean isActivated(Class<? extends Deactivatable> targetClass);
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/projectstage/ProjectStageProducer.java
package org.apache.deltaspike.core.api.projectstage;

    /*
     * Methods which might be needed for unti tests
     */

    /**
     * Can be used esp. for internal tests.
     * Usage:
     * <pre>
     * new ProjectStageProducer() {
     *     @Override
     *     protected void reset() { super.reset(); }
     * }.reset();
     * </pre>
     */
    protected void reset()
    {
        projectStage = null;
        projectStageProducer = null;
    }

    /**
     * This function can be used to manually set the ProjectStage for the application.
     * This is e.g. useful in unit tests.
     * @param ps the ProjectStage to set
     */
    public static void setProjectStage(ProjectStage ps)
    {
        projectStage = ps;
    }
import org.apache.deltaspike.core.api.projectstage.ProjectStageProducer;
 *
 * The AnnotatedTypeBuilder is not thread safe and shall not be used concurrently!
     * @deprecated move/merge with ClassUtils
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.HierarchyDiscovery;
import org.apache.deltaspike.core.util.Reflections;
import org.apache.deltaspike.core.util.Reflections;
import org.apache.deltaspike.core.util.ClassUtils;
 * use the {@link org.apache.deltaspike.core.util.ClassDeactivation} for implementing the lookup</p>
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/ClassDeactivation.java
package org.apache.deltaspike.core.util;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/ClassUtils.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.core.util;

import javax.enterprise.inject.Typed;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.jar.Manifest;
import java.util.jar.Attributes;
import java.net.URL;

/**
 * Util methods for classes, {@link ClassLoader} and {@link Manifest} handling
 */
//X TODO quite a few of this methods needs merging with Seam Solder and a few can get dropped at all.
@Typed()
public abstract class ClassUtils
{
    /**
     * Constructor which prevents the instantiation of this class
     */
    private ClassUtils()
    {
        // prevent instantiation
    }

    /**
     * Detect the right ClassLoader.
     * The lookup order is determined by:
     * <ol>
     * <li>ContextClassLoader of the current Thread</li>
     * <li>ClassLoader of the given Object 'o'</li>
     * <li>ClassLoader of this very ClassUtils class</li>
     * </ol>
     *
     * @param o if not <code>null</code> it may get used to detect the classloader.
     * @return The {@link ClassLoader} which should get used to create new instances
     */
    public static ClassLoader getClassLoader(Object o)
    {
        ClassLoader loader = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>()
        {
            /**
             * {@inheritDoc}
             */
            @Override
            public ClassLoader run()
            {
                try
                {
                    return Thread.currentThread().getContextClassLoader();
                }
                catch (Exception e)
                {
                    return null;
                }
            }
        }
        );

        if (loader == null && o != null)
        {
            loader = o.getClass().getClassLoader();
        }

        if (loader == null)
        {
            loader = ClassUtils.class.getClassLoader();
        }

        return loader;
    }

    /**
     * Tries to load a class based on the given name and interface or abstract class.
     * @param name name of the concrete class
     * @param targetType target type (interface or abstract class)
     * @param <T> current type
     * @return loaded class or null if it isn't in the classpath
     */
    public static <T> Class<T> tryToLoadClassForName(String name, Class<T> targetType)
    {
        return (Class<T>) tryToLoadClassForName(name);
    }

    /**
     * Tries to load a class based on the given name
     * @param name name of the class
     * @return loaded class or <code>null</code> if it isn't in the classpath
     */
    public static Class tryToLoadClassForName(String name)
    {
        try
        {
            return loadClassForName(name);
        }
        catch (ClassNotFoundException e)
        {
            //do nothing - it's just a try
            return null;
        }
    }

    /**
     * Loads class for the given name
     * @param name name of the class
     * @return loaded class
     * @throws ClassNotFoundException if the class can't be loaded
     */
    public static Class loadClassForName(String name) throws ClassNotFoundException
    {
        try
        {
            // Try WebApp ClassLoader first
            return Class.forName(name, false, // do not initialize for faster startup
                    getClassLoader(null));
        }
        catch (ClassNotFoundException ignore)
        {
            // fallback: Try ClassLoader for ClassUtils (i.e. the myfaces.jar lib)
            return Class.forName(name, false, // do not initialize for faster startup
                    ClassUtils.class.getClassLoader());
        }
    }

    /**
     * Instantiates a given class via the default constructor
     * @param targetClass class which should be instantiated
     * @param <T> current type
     * @return created instance or null if the instantiation failed
     */
    public static <T> T tryToInstantiateClass(Class<T> targetClass)
    {
        try
        {
            return targetClass.newInstance();
        }
        catch (InstantiationException e)
        {
            //do nothing - it was just a try
        }
        catch (IllegalAccessException e)
        {
            //do nothing - it was just a try
        }
        return null;
    }

    /**
     * Tries to instantiate a class for the given name and type via the default constructor
     * @param className name of the class
     * @param targetType target type
     * @param <T> current type
     * @return created instance or null if the instantiation failed
     */
    public static <T> T tryToInstantiateClassForName(String className, Class<T> targetType)
    {
        Object result = tryToInstantiateClassForName(className);

        //noinspection unchecked
        return result != null ? (T) result : null;
    }

    /**
     * Tries to instantiate a class for the given name via the default constructor
     * @param className name of the class
     * @return created instance or null if the instantiation failed
     */
    public static Object tryToInstantiateClassForName(String className)
    {
        try
        {
            return instantiateClassForName(className);
        }
        catch (Exception e)
        {
            //do nothing - it was just a try
        }
        return null;
    }

    /**
     * Creates an instance for the given class-name
     * @param className name of the class which should be instantiated
     * @return created instance
     * @throws ClassNotFoundException if the instantiation failed
     * @throws IllegalAccessException if the instantiation failed
     * @throws InstantiationException if the instantiation failed
     */
    public static Object instantiateClassForName(String className)
        throws ClassNotFoundException, IllegalAccessException, InstantiationException
    {
        return loadClassForName(className).newInstance();
    }

    /**
     * Reads the version of the jar which contains the given class
     * @param targetClass class within the jar
     * @return version-string which has been found in the manifest or null if there is no version information available
     */
    public static String getJarVersion(Class targetClass)
    {
        String manifestFileLocation = getManifestFileLocationOfClass(targetClass);

        try
        {
            return new Manifest(new URL(manifestFileLocation).openStream())
                    .getMainAttributes().getValue(Attributes.Name.IMPLEMENTATION_VERSION);
        }
        catch (Exception e)
        {
            return null;
        }
    }

    /**
     * Reads the VCS revision which was used for creating the jar
     * @param targetClass class within the jar
     * @return revision-string which has been found in the manifest or null if there is no information available
     */
    public static String getRevision(Class targetClass)
    {
        String manifestFileLocation = getManifestFileLocationOfClass(targetClass);

        try
        {
            return new Manifest(new URL(manifestFileLocation).openStream())
                    .getMainAttributes().getValue("Revision");
        }
        catch (Exception e)
        {
            return null;
        }
    }

    private static String getManifestFileLocationOfClass(Class targetClass)
    {
        String manifestFileLocation;

        try
        {
            manifestFileLocation = getManifestLocation(targetClass);
        }
        catch (Exception e)
        {
            //in this case we have a proxy
            manifestFileLocation = getManifestLocation(targetClass.getSuperclass());
        }
        return manifestFileLocation;
    }

    private static String getManifestLocation(Class targetClass)
    {
        String classFilePath = targetClass.getCanonicalName().replace('.', '/')  ".class";
        String manifestFilePath = "/META-INF/MANIFEST.MF";

        String classLocation = targetClass.getResource(targetClass.getSimpleName()  ".class").toString();
        return classLocation.substring(0, classLocation.indexOf(classFilePath) - 1)  manifestFilePath;
    }
}
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/HierarchyDiscovery.java
package org.apache.deltaspike.core.util;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/ParameterizedTypeImpl.java
package org.apache.deltaspike.core.util;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/ProjectStageProducer.java
package org.apache.deltaspike.core.util;
import org.apache.deltaspike.core.api.projectstage.ProjectStage;
 * <p>Produces {@link org.apache.deltaspike.core.api.projectstage.ProjectStage} configurations.</p>
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/Reflections.java
package org.apache.deltaspike.core.util;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/SetAccessiblePrivilegedAction.java
package org.apache.deltaspike.core.util;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/Types.java
package org.apache.deltaspike.core.util;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.ProjectStageProducer;
import org.apache.deltaspike.core.util.ClassDeactivation;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.ClassUtils;
 * Literal for {@link javax.inject.Singleton}
 * Literal for {@link javax.enterprise.inject.Typed}
 * Implementation of {@link AnnotatedCallable}
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
 * Implementation of {@link AnnotatedParameter}.
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
 *  <li>it is dynamic. Everyone can add their own ProjectStages!</p>
 *
 * contains 1 or more {@link ProjectStage}s.</p>
public interface ProjectStageHolder
 *
 *
 * <p>All ClassDeactivators will get picked up in order of their ordinal and might explicitly activate or
 * doesn't care about the Deactivatable class.</p>
 *
 * <p>An implementation has to be stateless.</p>
     *         and <code>null</code> to let it as is (defined by default or other
     * <p>This factory method should only get used if there is absolutely no way
     * Methods which might be needed for unit tests
     * {@link java.security.PrivilegedAction} before invoking the method if the first argument
     * {@link java.security.PrivilegedAction} before invoking the method.
     * {@link Reflections#setFieldValue(boolean, Field, Object, Object)}, honoring
     * {@link java.security.PrivilegedAction} before invoking the method.
            return null; // TODO: Shouldn't this return an empty Properties? Otherwise we could cause NPE in the getPropertyValue method
    @Override
            throw new IllegalStateException(e);
            //<T> needed to bypass an issue with old jdk versions
            return Reflections.<T>cast(field.get(instance));
     * The active {@link BeanManager} for the current application (/{@link ClassLoader}). This method will throw an
     * {@link IllegalStateException} if the BeanManager cannot be found.
     * 
     * @return the current bean-manager, never <code>null</code>
     * @throws IllegalStateException
     *             if the BeanManager cannot be found
            if (result == null)
                throw new IllegalStateException("Unable to find BeanManager. " 
                        "Please ensure that you configured the CDI implementation of your choice properly.");

            bms.put(classLoader, result);

     * @return the configured property value from the {@link ConfigSource} with the highest ordinal or
     * null if there is no configured value for it.
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.core.util.ClassDeactivation;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.ProjectStageProducer;
import javax.enterprise.inject.Alternative;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.util.Nonbinding;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
    private Boolean isGlobalAlternativeActivated = null;
    protected void vetoBeans(@Observes ProcessAnnotatedType<Object> processAnnotatedType, BeanManager beanManager)
        initActivation();

        //we need to do it before the exclude logic to keep the @Exclude support for global alternatives
        if (this.isGlobalAlternativeActivated)
        {
            activateGlobalAlternatives(processAnnotatedType, beanManager);
        }

        if (!this.isActivated)
        if (!processAnnotatedType.getAnnotatedType().getJavaClass().isAnnotationPresent(Exclude.class))
        {
            return;
        }

    //just #veto the original implementation and remove @Alternative from the ProcessAnnotatedType of
    // the configured alternative doesn't work with OWB (due to OWB-643)
    private void activateGlobalAlternatives(ProcessAnnotatedType<Object> processAnnotatedType, BeanManager beanManager)
    {
        //the current bean is the bean with a potential global alternative
        Class<Object> currentBean = processAnnotatedType.getAnnotatedType().getJavaClass();

        Set<Class> beanBaseTypes = resolveBeanTypes(currentBean);

        boolean isAlternativeBeanImplementation = currentBean.isAnnotationPresent(Alternative.class);

        List<Annotation> qualifiersOfCurrentBean =
            resolveQualifiers(processAnnotatedType.getAnnotatedType().getAnnotations(), beanManager);

        String configuredBeanName;
        List<Annotation> qualifiersOfConfiguredBean;
        Class<Object> alternativeBeanClass;
        Set<Annotation> alternativeBeanAnnotations;
        
        for (Class currentType : beanBaseTypes)
        {
            alternativeBeanAnnotations = new HashSet<Annotation>();

            configuredBeanName = ConfigResolver.getPropertyValue(currentType.getName());
            if (configuredBeanName != null && configuredBeanName.length() > 0)
            {
                alternativeBeanClass = ClassUtils.tryToLoadClassForName(configuredBeanName);

                if (alternativeBeanClass == null)
                {
                    throw new IllegalStateException("Can't find class "  configuredBeanName  " which is configured" 
                            " for "  currentType.getName());
                }
                alternativeBeanAnnotations.addAll(Arrays.asList(alternativeBeanClass.getAnnotations()));
                qualifiersOfConfiguredBean = resolveQualifiers(alternativeBeanAnnotations, beanManager);
            }
            else
            {
                continue;
            }

            if (isAlternativeBeanImplementation)
            {
                if (doQualifiersMatch(qualifiersOfCurrentBean, qualifiersOfConfiguredBean))
                {
                    //veto if the current annotated-type is a global alternative - it replaced the original type already
                    processAnnotatedType.veto();
                    break;
                }
            }
            else
            {
                if (!alternativeBeanClass.isAnnotationPresent(Alternative.class))
                {
                    continue;
                }

                if (doQualifiersMatch(qualifiersOfCurrentBean, qualifiersOfConfiguredBean))
                {
                    AnnotatedTypeBuilder<Object> annotatedTypeBuilder
                        = new AnnotatedTypeBuilder<Object>().readFromType(alternativeBeanClass);

                    //just to avoid issues with switching between app-servers,...
                    annotatedTypeBuilder.removeFromClass(Alternative.class);
                    processAnnotatedType.setAnnotatedType(annotatedTypeBuilder.create());
                }
            }
        }
    }

    private boolean doQualifiersMatch(List<Annotation> qualifiersOfCurrentBean,
                                      List<Annotation> qualifiersOfConfiguredBean)
    {
        if (qualifiersOfCurrentBean.size() != qualifiersOfConfiguredBean.size())
        {
            return false;
        }

        int matchingQualifiers = 0;
        for (Annotation currentQualifier : qualifiersOfCurrentBean)
        {
            for (Annotation qualifierConfiguredBean : qualifiersOfConfiguredBean)
            {
                if (doesQualifierMatch(currentQualifier, qualifierConfiguredBean))
                {
                    matchingQualifiers;
                    break;
                }
            }
        }
        return qualifiersOfConfiguredBean.size() == matchingQualifiers;
    }

    private boolean doesQualifierMatch(Annotation currentQualifier, Annotation qualifierConfiguredBean)
    {
        if (!currentQualifier.annotationType().equals(qualifierConfiguredBean.annotationType()))
        {
            return false;
        }

        Object currentValue;
        Object valueOfQualifierConfiguredBean;
        for (Method currentMethod : currentQualifier.annotationType().getDeclaredMethods())
        {
            if (currentMethod.isAnnotationPresent(Nonbinding.class))
            {
                continue;
            }

            try
            {
                currentMethod.setAccessible(true);
                currentValue = currentMethod.invoke(currentQualifier);
                valueOfQualifierConfiguredBean = currentMethod.invoke(qualifierConfiguredBean);

                if (!currentValue.equals(valueOfQualifierConfiguredBean))
                {
                    return false;
                }
            }
            catch (Exception e)
            {
                throw new IllegalStateException("Can't compare "  currentQualifier.annotationType().getName() 
                    " with "  qualifierConfiguredBean.annotationType().getName());
            }
        }
        return true;
    }

    private List<Annotation> resolveQualifiers(Set<Annotation> annotations, BeanManager beanManager)
    {
        List<Annotation> result = new ArrayList<Annotation>();

        for (Annotation annotation : annotations)
        {
            if (beanManager.isQualifier(annotation.annotationType()))
            {
                result.add(annotation);
            }
        }
        return result;
    }

    private Set<Class> resolveBeanTypes(Class beanClass)
    {
        Set<Class> result = new HashSet<Class>();

        Class<?> currentClass = beanClass;
        while (currentClass != null && !Object.class.getName().equals(currentClass.getName()))
        {
            result.add(currentClass);

            for (Class interfaceClass : currentClass.getInterfaces())
            {
                if (interfaceClass.getName().startsWith("java.") || interfaceClass.getName().startsWith("javax."))
                {
                    continue;
                }
                result.addAll(resolveBeanTypes(interfaceClass));
            }

            currentClass = currentClass.getSuperclass();
        }

        return result;
    }

    public void initActivation()
            isGlobalAlternativeActivated = ClassDeactivation.isActivated(GlobalAlternative.class);
                continue;
    private static Boolean isOwbDetected = null;

            detectCdiImplementation();

            if (isOwbDetected)
            {
                activateGlobalAlternativesOwb(processAnnotatedType, beanManager);
            }
            else
            {
                activateGlobalAlternativesWeld(processAnnotatedType, beanManager);
            }
    private void activateGlobalAlternativesWeld(ProcessAnnotatedType<Object> processAnnotatedType,
        BeanManager beanManager)
    {
        Class<Object> currentBean = processAnnotatedType.getAnnotatedType().getJavaClass();

        if (currentBean.isInterface())
        {
            return;
        }

        Set<Class> beanBaseTypes = resolveBeanTypes(currentBean);

        boolean isAlternativeBeanImplementation = currentBean.isAnnotationPresent(Alternative.class);

        List<Annotation> qualifiersOfCurrentBean =
                resolveQualifiers(processAnnotatedType.getAnnotatedType().getAnnotations(), beanManager);

        String configuredBeanName;
        List<Annotation> qualifiersOfConfiguredBean;
        Class<Object> alternativeBeanClass;
        Set<Annotation> alternativeBeanAnnotations;

        for (Class currentType : beanBaseTypes)
        {
            alternativeBeanAnnotations = new HashSet<Annotation>();

            configuredBeanName = ConfigResolver.getPropertyValue(currentType.getName());
            if (configuredBeanName != null && configuredBeanName.length() > 0)
            {
                alternativeBeanClass = ClassUtils.tryToLoadClassForName(configuredBeanName);

                if (alternativeBeanClass == null)
                {
                    throw new IllegalStateException("Can't find class "  configuredBeanName  " which is configured" 
                            " for "  currentType.getName());
                }

                //check that the configured class is an alternative
                if (!alternativeBeanClass.isAnnotationPresent(Alternative.class))
                {
                    //we have to continue because other classes can be configured as well
                    continue;
                }

                alternativeBeanAnnotations.addAll(Arrays.asList(alternativeBeanClass.getAnnotations()));
                qualifiersOfConfiguredBean = resolveQualifiers(alternativeBeanAnnotations, beanManager);
            }
            else
            {
                continue;
            }

            if (isAlternativeBeanImplementation) //current bean is annotated with @Alternative
            {
                if (doQualifiersMatch(qualifiersOfCurrentBean, qualifiersOfConfiguredBean))
                {
                    AnnotatedTypeBuilder<Object> annotatedTypeBuilder
                        = new AnnotatedTypeBuilder<Object>().readFromType(processAnnotatedType.getAnnotatedType());

                    annotatedTypeBuilder.removeFromClass(Alternative.class);
                    processAnnotatedType.setAnnotatedType(annotatedTypeBuilder.create());
                    return;
                }
            }
            else //current bean is the original implementation
            {
                if (doQualifiersMatch(qualifiersOfCurrentBean, qualifiersOfConfiguredBean))
                {
                    //veto this original implementation because the alternative will be added
                    processAnnotatedType.veto();
                    return;
                }
            }
        }
    }

    //see OWB-643
    private void activateGlobalAlternativesOwb(ProcessAnnotatedType<Object> processAnnotatedType,
        BeanManager beanManager)
        if (currentBean.isInterface())
        {
            return;
        }



    private void detectCdiImplementation()
    {
        if (isOwbDetected == null)
        {
            isOwbDetected = false;

            RuntimeException runtimeException = new RuntimeException();

            for (StackTraceElement element : runtimeException.getStackTrace())
            {
                if (element.toString().contains("org.apache.webbeans."))
                {
                    isOwbDetected = true;
                    break;
                }
            }
        }
    }
 * <p>The custom implementation can be 'registered' using a
 * {@link ConfigSourceProvider} </p>
        initOrdinal(200);
     * The container might throw a DeploymentException or similar on startup.
    void bootContainer();
    void shutdownContainer();
    public void bootContainer()
    public void shutdownContainer()
import org.apache.deltaspike.containerctrl.api.ContainerControl;
import org.apache.deltaspike.containerctrl.api.ContainerControlLoader;
import javax.enterprise.context.ApplicationScoped;
    private SimpleBeanLookupExample()
    {
    }

     *

        ContainerControl containerControl = ContainerControlLoader.getCdiContainer();
        containerControl.bootContainer();
        //containerControl.startContexts();
        containerControl.startContext(ApplicationScoped.class);
        for (EchoService echoService : echoServiceList)
        for (EchoService echoService : echoServiceList)

        if (optionalService == null)
        else

        containerControl.stopContext(ApplicationScoped.class);
        //containerControl.stopContexts();
        containerControl.shutdownContainer();
     *
        if (namedAnnotation != null &&


                    .addToClass(new NamedLiteral(newBeanName));
 b/deltaspike/cdise/api/src/main/java/org/apache/deltaspike/cdise/api/CdiContainer.java
package org.apache.deltaspike.cdise.api;
public interface CdiContainer
 b/deltaspike/cdise/api/src/main/java/org/apache/deltaspike/cdise/api/CdiContainerLoader.java
package org.apache.deltaspike.cdise.api;
public final class CdiContainerLoader
    private CdiContainerLoader()
    public static CdiContainer getCdiContainer()
        CdiContainer testContainer;
        ServiceLoader<CdiContainer> cdiContainerLoader = ServiceLoader.load(CdiContainer.class);
        Iterator<CdiContainer> cdiIt = cdiContainerLoader.iterator();
            throw new RuntimeException("Could not find a CdiContainer available in the classpath!");
            throw new RuntimeException("Too many CdiContainer found in the classpath!");
 b/deltaspike/cdise/impl-owb/src/main/java/org/apache/deltaspike/cdise/owb/MockHttpSession.java
package org.apache.deltaspike.cdise.owb;
 b/deltaspike/cdise/impl-owb/src/main/java/org/apache/deltaspike/cdise/owb/MockServletContext.java
package org.apache.deltaspike.cdise.owb;
 b/deltaspike/cdise/impl-owb/src/main/java/org/apache/deltaspike/cdise/owb/OpenWebBeansContainerControl.java
package org.apache.deltaspike.cdise.owb;
import org.apache.deltaspike.cdise.api.CdiContainer;
 * OpenWebBeans specific implementation of {@link org.apache.deltaspike.cdise.api.CdiContainer}.
public class OpenWebBeansContainerControl implements CdiContainer
 b/deltaspike/cdise/tck/src/main/java/org/apache/deltaspike/cdise/tck/beans/Car.java
package org.apache.deltaspike.cdise.tck.beans;
 b/deltaspike/cdise/tck/src/main/java/org/apache/deltaspike/cdise/tck/beans/CarRepair.java
package org.apache.deltaspike.cdise.tck.beans;
 b/deltaspike/cdise/tck/src/main/java/org/apache/deltaspike/cdise/tck/beans/User.java
package org.apache.deltaspike.cdise.tck.beans;
import org.apache.deltaspike.cdise.api.CdiContainer;
import org.apache.deltaspike.cdise.api.CdiContainerLoader;
        CdiContainer cdiContainer = CdiContainerLoader.getCdiContainer();
        cdiContainer.bootContainer();
        cdiContainer.startContext(ApplicationScoped.class);
        cdiContainer.stopContext(ApplicationScoped.class);
        cdiContainer.shutdownContainer();
import java.util.Arrays;
     *

                LOG.log(Level.FINE, "found value {0} for key {1} in ConfigSource {2}.",

        return null;
        List<ConfigSource> appConfigSources = sortAscending(Arrays.asList(getConfigSources()));






            if (LOG.isLoggable(Level.FINE))
                    LOG.log(Level.FINE, "Adding ordinal {0} ConfigSource {1}",

                return (configSource1.getOrdinal() > configSource2.getOrdinal()) ? -1 : 1;

    private static List<ConfigSource> sortAscending(List<ConfigSource> configSources)
    {
        Collections.sort(configSources, new Comparator<ConfigSource>()
        {
            /**
             * {@inheritDoc}
             */
            @Override
            public int compare(ConfigSource configSource1, ConfigSource configSource2)
            {
                return (configSource1.getOrdinal() > configSource2.getOrdinal()) ? 1 : -1;
            }
        });
        return configSources;
    }
            throw new IllegalStateException("Could not find an implementation of "  CdiContainer.class.getName() 
                " available in the classpath!");
            String foundContainers = getContainerDetails();
            throw new IllegalStateException("Too many implementations of "  CdiContainer.class.getName() 
                " found in the classpath! Details: "  foundContainers);

    private static String getContainerDetails()
    {
        StringBuilder result = new StringBuilder();

        Class containerClass;
        for (CdiContainer cdiContainer : ServiceLoader.load(CdiContainer.class))
        {
            containerClass = cdiContainer.getClass();
            result.append(containerClass.getProtectionDomain().getCodeSource().getLocation().toExternalForm());
            result.append(containerClass.getName());

            result.append(System.getProperty("line.separator"));
        }

        return result.toString();
    }
    private static final Logger LOG = Logger.getLogger(OpenWebBeansContainerControl.class.getName());
            logDestroyOfInactiveContext(Singleton.class.getName());
            logDestroyOfInactiveContext(ApplicationScoped.class.getName());
            logDestroyOfInactiveContext(ConversationScoped.class.getName());
            logDestroyOfInactiveContext(RequestScoped.class.getName());
            logDestroyOfInactiveContext(SessionScoped.class.getName());
    private void logDestroyOfInactiveContext(String contextName)
    {
        LOG.log(Level.WARNING,
                "destroy was called for an inactive context ("  contextName  ")");
    }
    private static final long serialVersionUID = -4171521313675763849L;

    private static final long serialVersionUID = 6805980497117269525L;

        if (constructorParameters.get(constructor) != null &&
            constructorParameters.get(constructor).get(position) != null)
            constructorParameters.get(constructor).get(position).remove(annotationType);
            Reflections.setAccessible(field);

            Reflections.setAccessible(method);

        init(projectStageClassName, this);
    }

    /**
     * This function exists to prevent findbugs to complain about
     * setting a static member from a non-static function.
     *
     * @param projectStageClassName name of the project-stage
     * @param projectStage instance of the project-stage
     */
    private static void init(String projectStageClassName, ProjectStage projectStage)
    {
            projectStages.put(projectStageClassName, projectStage);
        ProjectStage[] result = new ProjectStage[values.length];
        System.arraycopy(values, 0, result, 0, values.length);
        return result;
public abstract class ClassDeactivation
        // prevent instantiation
import java.util.logging.Level;
import java.util.logging.Logger;
            Logger logger = Logger.getLogger(HierarchyDiscovery.class.getName());

            logger.log(Level.WARNING, "type: "  type.toString(), e);
        resetCache();
    }

    /**
     * This function exists to prevent findbugs to complain about
     * setting a static member from a non-static function.
     */
    private static void resetCache()
    {
public abstract class Reflections
        // prevent instantiation
        else if (type instanceof ParameterizedType && ((ParameterizedType) type).getRawType() instanceof Class<?>)
            return (Class<T>) ((ParameterizedType) type).getRawType();
public abstract class Types
        // prevent instantiation
            throw new IllegalStateException("problem while loading DeltaSpike property files", ioe);
            IllegalStateException runtimeException = new IllegalStateException();
public abstract class JndiUtils
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
public class ImmutableInjectionPoint implements InjectionPoint
{
    private final boolean isTransient;
     * @param isTransient    <code>true</code> if the injection point is transient
    public ImmutableInjectionPoint(AnnotatedField<?> field, Set<Annotation> qualifiers, Bean<?> declaringBean,
                                   boolean isTransient, boolean delegate)
    {
        this.isTransient = isTransient;
     * @param isTransient    <code>true</code> if the injection point is transient
    public ImmutableInjectionPoint(AnnotatedField<?> field, BeanManager beanManager, Bean<?> declaringBean,
                                   boolean isTransient, boolean delegate)
    {
        this.isTransient = isTransient;
     * @param isTransient    <code>true</code> if the injection point is transient
    public ImmutableInjectionPoint(AnnotatedParameter<?> parameter, Set<Annotation> qualifiers, Bean<?> declaringBean,
                                   boolean isTransient, boolean delegate)
    {
        this.isTransient = isTransient;
     * @param isTransient    <code>true</code> if the injection point is transient
    public ImmutableInjectionPoint(AnnotatedParameter<?> parameter, BeanManager beanManager, Bean<?> declaringBean,
                                   boolean isTransient, boolean delegate)
    {
        this.isTransient = isTransient;
    public Annotated getAnnotated()
    {
    public Bean<?> getBean()
    {
    public Member getMember()
    {
    public Set<Annotation> getQualifiers()
    {
    public Type getType()
    {
    public boolean isDelegate()
    {
    public boolean isTransient()
    {
        return isTransient;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
public class InjectableMethod<X>
{
    public InjectableMethod(AnnotatedMethod<X> method, Bean<?> declaringBean, BeanManager beanManager)
    {
    public InjectableMethod(AnnotatedMethod<X> method, Collection<InjectionPoint> parameters, BeanManager beanManager)
    {
    protected BeanManager getBeanManager()
    {
    protected List<InjectionPoint> getParameters()
    {
     * <p/>
     * }
    public <T> T invoke(Object receiver, CreationalContext<T> creationalContext)
    {
    public <T> T invoke(Object receiver, CreationalContext<T> creationalContext, ParameterValueRedefiner redefinition)
    {
        for (int i = 0; i < getParameters().size(); i)
        {
            if (redefinition != null)
            {
            }
            else
            {
        T result = (T) invokeMethod(true, method.getJavaMember(), receiver, parameterValues
                .toArray(EMPTY_OBJECT_ARRAY));
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
public interface ParameterValueRedefiner
{
    /**
     * Callback allowing the default parameter value (that which would be
     * injected according to the CDI type safe resolution rules) to be
     * overridden.
     *
     * @param value the default value
     * @return the overridden value
     */
    Object redefineParameterValue(ParameterValue value);
    public static class ParameterValue
    {
        ParameterValue(int position, InjectionPoint injectionPoint, BeanManager beanManager)
        {
        public int getPosition()
        {
        public InjectionPoint getInjectionPoint()
        {
        public Object getDefaultValue(CreationalContext<?> creationalContext)
        {
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
public class Beans
{
    private Beans()
    {
    public static Set<Annotation> getQualifiers(BeanManager beanManager, Iterable<Annotation>... annotations)
    {
        for (Iterable<Annotation> annotationSet : annotations)
        {
            for (Annotation annotation : annotationSet)
            {
                if (beanManager.isQualifier(annotation.annotationType()))
                {
    public static Set<Annotation> getQualifiers(BeanManager beanManager, Iterable<Annotation> annotations)
    {
    public static Set<Annotation> getQualifiers(BeanManager beanManager, Annotation[]... annotations)
    {
        for (Annotation[] annotationArray : annotations)
        {
            for (Annotation annotation : annotationArray)
            {
                if (beanManager.isQualifier(annotation.annotationType()))
                {
    public static void checkReturnValue(Object instance, Bean<?> bean, InjectionPoint injectionPoint,
                                        BeanManager beanManager)
    {
        if (instance == null && !Dependent.class.equals(bean.getScope()))
        {
        }
        else if (instance != null)
        {
            if (passivating && !instanceSerializable)
            {
                throw new IllegalStateException(
                        "Producers cannot declare passivating scope and return a non-serializable class: "  bean);
            if (injectionPoint != null && injectionPoint.getBean() != null)
            {
                if (!instanceSerializable && beanManager.isPassivatingScope(injectionPoint.getBean().getScope()))
                {
                    if (injectionPoint.getMember() instanceof Field)
                    {
                        if (!injectionPoint.isTransient() && instance != null && !instanceSerializable)
                        {
                            throw new IllegalStateException(
                                    "Producers cannot produce non-serializable instances for injection into " 
                                            "non-transient fields of passivating beans. Producer " 
                                            bean  "at injection point "  injectionPoint);
                    }
                    else if (injectionPoint.getMember() instanceof Method)
                    {
                        if (method.isAnnotationPresent(Inject.class))
                        {
                            throw new IllegalStateException("Producers cannot produce non-serializable instances for " 
                                    "injection into parameters of initializers of beans declaring passivating scope. " 
                                    "Producer "  bean  "at injection point "  injectionPoint);
                        if (method.isAnnotationPresent(Produces.class))
                        {
                            throw new IllegalStateException("Producers cannot produce non-serializable instances for " 
                                    "injection into parameters of producer methods declaring passivating scope. " 
                                    "Producer "  bean  "at injection point "  injectionPoint);
                    }
                    else if (injectionPoint.getMember() instanceof Constructor<?>)
                    {
                        throw new IllegalStateException("Producers cannot produce non-serializable instances for " 
                                "injection into parameters of constructors of beans declaring passivating scope. " 
                                "Producer "  bean  "at injection point "  injectionPoint);
    public static <X> List<InjectionPoint> createInjectionPoints(AnnotatedMethod<X> method, Bean<?> declaringBean,
                                                                 BeanManager beanManager)
    {
        for (AnnotatedParameter<X> parameter : method.getParameters())
        {
            InjectionPoint injectionPoint =
                    new ImmutableInjectionPoint(parameter, beanManager, declaringBean, false, false);

import org.apache.deltaspike.core.util.ServiceUtils;
        List<ConfigSourceProvider> configSourceProviderServiceLoader =
            ServiceUtils.loadServiceImplementations(ConfigSourceProvider.class);
import org.apache.deltaspike.core.util.ServiceUtils;

import java.util.List;
        List<ProjectStageHolder> projectStageHolders =
            ServiceUtils.loadServiceImplementations(ProjectStageHolder.class);

            //fallback - see DELTASPIKE-98
            if (!propertyFileUrls.hasMoreElements())
            {
                cl = getClass().getClassLoader();
                propertyFileUrls = cl.getResources(PROPERTY_FILE_NAME);
            }

@SecurityBindingType


import java.io.Serializable;
import java.lang.reflect.Method;

import org.apache.deltaspike.security.impl.SecurityExtension.Authorizer;
 * Provides authorization services for component invocations.
@SecurityInterceptorBinding
public class SecurityInterceptor implements Serializable 
    private static final long serialVersionUID = -6567750187000766925L;
    @Inject private SecurityExtension extension;
    public Object aroundInvoke(InvocationContext invocation) throws Exception 
        Method method = invocation.getMethod();
        for (Authorizer authorizer : extension.lookupAuthorizerStack(method, invocation.getTarget().getClass())) 
        {
            authorizer.authorize(invocation);
        }

        return invocation.proceed();
     * @param method        the method which will be injected upon a call to
     *                      {@link #invoke(Object, CreationalContext)}
     * @param declaringBean the bean which defines the injectable method
     * @param beanManager   the {@link BeanManager} to use to obtain the parameter values
        try
        {
            @SuppressWarnings("unchecked")
            T result = (T) invokeMethod(true, method.getJavaMember(), receiver, parameterValues
                    .toArray(EMPTY_OBJECT_ARRAY));
            return result;
        }
        catch (RuntimeException e)
        {
            //X TODO check if it is compatible with Weld
            //workaround for OWB which wraps InvocationTargetException the original exception
            //see Reflections#invokeMethod
            if (RuntimeException.class.getName().equals(e.getClass().getName()) &&
                    e.getCause() instanceof RuntimeException)
            {
                throw (RuntimeException)e.getCause();
            }
            throw e;
        }
        Method method = invocationContext.getMethod();
        SecurityMetaDataStorage metaDataStorage = SecurityExtension.getMetaDataStorage();
        for (Authorizer authorizer : metaDataStorage.getAuthorizers(invocationContext.getTarget().getClass(), method))
            authorizer.authorize(invocationContext);
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.security.api.Secures;
import org.apache.deltaspike.security.api.SecurityDefinitionException;
import org.apache.deltaspike.security.spi.Authenticator;
import java.lang.annotation.Annotation;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class SecurityExtension implements Extension
    //workaround for OWB
    private static final Map<ClassLoader, SecurityMetaDataStorage> SECURITY_METADATA_STORAGE_MAPPING
        = new ConcurrentHashMap<ClassLoader, SecurityMetaDataStorage>();
    //workaround for OWB
    public static SecurityMetaDataStorage getMetaDataStorage()
    {
        ClassLoader classLoader = ClassUtils.getClassLoader(null);

        SecurityMetaDataStorage securityMetaDataStorage = SECURITY_METADATA_STORAGE_MAPPING.get(classLoader);

        if (securityMetaDataStorage == null)
        {
            securityMetaDataStorage = new SecurityMetaDataStorage();
            SECURITY_METADATA_STORAGE_MAPPING.put(classLoader, securityMetaDataStorage);
        }

        return securityMetaDataStorage;
    }
    @SuppressWarnings("UnusedDeclaration")
    public <X> void processAnnotatedType(@Observes ProcessAnnotatedType<X> event, final BeanManager beanManager)
            if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
                break;
                    registerAuthorizer(m, beanManager);
                    if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
            getMetaDataStorage().addSecuredType(type);
    @SuppressWarnings("UnusedDeclaration")
    public void validateBindings(@Observes AfterBeanDiscovery event, BeanManager beanManager)
        SecurityMetaDataStorage metaDataStorage = getMetaDataStorage();
        for (final AnnotatedType<?> type : metaDataStorage.getSecuredTypes())
                if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
                    for (Authorizer auth : metaDataStorage.getAuthorizers())
                    if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
                        metaDataStorage.registerSecuredMethod(type.getJavaClass(), method.getJavaMember());
        metaDataStorage.resetSecuredTypes();
     * @param beanManager
     * @throws SecurityDefinitionException
    private void registerAuthorizer(AnnotatedMethod<?> m, BeanManager beanManager)
        for (Annotation annotation : m.getAnnotations())
            if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
                binding = annotation;
        Authorizer authorizer = new Authorizer(binding, m, beanManager);
        getMetaDataStorage().addAuthorizer(authorizer);
    @SuppressWarnings("UnusedDeclaration")
    public void validateAuthenticatorImplementation(@Observes ProcessSessionBean<Authenticator> event)
import org.apache.deltaspike.security.spi.SecurityStrategy;
import java.io.Serializable;
 * Interceptor for {@link SecurityInterceptorBinding} - details see {@link SecurityStrategy}
public class SecurityInterceptor implements Serializable
    private static final long serialVersionUID = -7094673146532371976L;
    @Inject
    private SecurityStrategy securityStrategy;
    public Object filterDeniedInvocations(InvocationContext invocationContext) throws Exception
        return this.securityStrategy.execute(invocationContext);
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivation;
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
public class SecurityExtension implements Extension, Deactivatable

    private Boolean isActivated = null;

    protected void init(@Observes BeforeBeanDiscovery afterBeanDiscovery)
    {
        initActivation();
    }

        if (!this.isActivated)
        {
            return;
        }

        if (!this.isActivated)
        {
            return;
        }

                !m.getJavaMember().getReturnType().equals(Boolean.TYPE))
                if (binding != null)

     *
        if (!this.isActivated)
        {
            return;
        }


    public void initActivation()
    {
        if (isActivated == null)
        {
            isActivated = ClassDeactivation.isActivated(getClass());
        }
    }
import org.apache.deltaspike.security.api.annotation.Secured;

 * Marker interface for a pluggable strategy for {@link org.apache.deltaspike.security.api.annotation.Secured}
import org.apache.deltaspike.security.api.annotation.SecurityBindingType;
import org.apache.deltaspike.security.api.annotation.Secured;
import org.apache.deltaspike.security.api.annotation.Secures;
import org.apache.deltaspike.security.api.annotation.Secures;
import org.apache.deltaspike.security.api.annotation.SecurityBindingType;
    AuthenticationResult login();
 * A voter has to be used in combination with {@link org.apache.deltaspike.security.api.annotation.Secured}.<p/>
    public enum AuthenticationResult
    {
        success, failed, exception
    }
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD })
public @interface LoggedIn
{
import org.apache.deltaspike.security.api.annotation.Secured;
import org.apache.deltaspike.security.api.annotation.Secured;
import org.apache.deltaspike.security.api.annotation.Secured;
    void quietLogin();
     * @return AuthenticationResult returns success if user is authenticated, 
     * failed if authentication failed, or
     * exception if an exception occurred during authentication. These response
     * values may be used to control user navigation.  For deferred authentication methods, such as Open ID
     * the login() method will return an immediate result of failed (and subsequently fire
     * a third party authentication service such as an OpenID provider.
@Target({TYPE, METHOD} )
        throws IOException 
    {
@RequestScoped //TODO we might need a different scope for it
     * Helper which calls #bootContainer and #startContexts
     */
    void start();

    /**
     * Helper which calls #stopContexts and #shutdownContainer
     */
    void stop();

    /**
    @Override
    public void start()
    {
        bootContainer();
        startContexts();
    }

    @Override
    public void stop()
    {
        stopContexts();
        shutdownContainer();
    }

 b/deltaspike/examples/jse-examples/src/main/java/org/apache/deltaspike/example/beanmanagement/SimpleBeanLookupExample.java
        //containerControl.startContexts();

        //or:
        //cdiContainer.start();
        cdiContainer.stop();

        //or:
        //cdiContainer.shutdownContainer();

        //cdiContainer.stopContext(ApplicationScoped.class); //doesn't work with weld right now - see WELD-1072
import org.apache.deltaspike.cdise.api.CdiContainer;
import org.apache.webbeans.config.WebBeansContext;
import org.apache.webbeans.context.ContextFactory;
import org.apache.webbeans.context.type.ContextTypes;
import org.apache.webbeans.spi.ContainerLifecycle;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
    private ContainerLifecycle lifecycle;
    private MockServletContext servletContext;
    private MockHttpSession session;

    private Boolean resetSuccessful;

    @Override
    public  BeanManager getBeanManager()
    {
        return lifecycle.getBeanManager();
    }
    @Override

    @Override
    @Override
        ContextFactory contextFactory = getContextFactory();
    @Override
        stopSingletonScope();
    /*
     * start scopes
     */

    private void startApplicationScope()
        ContextFactory contextFactory = getContextFactory();

        contextFactory.initApplicationContext(servletContext);
    }

    private void startSessionScope()
    {
        ContextFactory contextFactory = getContextFactory();

        contextFactory.initSessionContext(session);
    }

    private void startRequestScope()
    {
        ContextFactory contextFactory = getContextFactory();

        contextFactory.initRequestContext(null);
    }

    private void startConversationScope()
    {
        ContextFactory contextFactory = getContextFactory();

        contextFactory.initConversationContext(null);
    }

    /*
     * stop scopes
     */

    private void stopSingletonScope()
    {
        ContextFactory contextFactory = getContextFactory();

        Context context = contextFactory.getStandardContext(ContextTypes.SINGLETON);
        if (context != null && context.isActive())
        {
            contextFactory.destroySingletonContext(servletContext);
            resetCache();
        }
        else
        {
            logDestroyOfInactiveContext(Singleton.class.getName());
        }
    }

    private void stopApplicationScope()
    {
        ContextFactory contextFactory = getContextFactory();

        Context context = contextFactory.getStandardContext(ContextTypes.APPLICATION);
        if (context != null && context.isActive())
        {
            contextFactory.destroyApplicationContext(servletContext);
            resetCache();
        }
        else
        {
            logDestroyOfInactiveContext(ApplicationScoped.class.getName());
        }
    }

    private void stopSessionScope()
    {
        ContextFactory contextFactory = getContextFactory();

        Context context = contextFactory.getStandardContext(ContextTypes.SESSION);
        if (context != null && context.isActive())
        {
            contextFactory.destroySessionContext(session);
            resetCache();
        }
        else
        {
            logDestroyOfInactiveContext(SessionScoped.class.getName());
        }
    }

    private void stopRequestScope()
    {
        ContextFactory contextFactory = getContextFactory();
            resetCache();
    private void stopConversationScope()
        ContextFactory contextFactory = getContextFactory();
        Context context = contextFactory.getStandardContext(ContextTypes.CONVERSATION);
            contextFactory.destroyConversationContext();
            resetCache();
            logDestroyOfInactiveContext(ConversationScoped.class.getName());

    //workaround for OWB-650
    private void resetCache()
        if (Boolean.FALSE.equals(this.resetSuccessful))
        {
            return;
        }

        BeanManager beanManager = getBeanManager();

        try
        {
            Field cacheProxiesField = beanManager.getClass().getDeclaredField("cacheProxies");
            cacheProxiesField.setAccessible(true);
            Map cacheProxies = (Map)cacheProxiesField.get(beanManager);

            if (cacheProxies != null)
            {
                cacheProxies.clear();
                this.resetSuccessful = true;
            }
        }
        catch (Exception e)
        {
            //do nothing - it's a different version of OWB which isn't tested but
            //might not have a cache and is therefore compatible.
            this.resetSuccessful = false;
        }
        catch (LinkageError e)
        {
            //do nothing - a new version of owb is used which introduced other required dependencies.
            //OWB-650 should be fixed in this version already
            this.resetSuccessful = false;
        }
    }

    private ContextFactory getContextFactory()
    {
        WebBeansContext webBeansContext = WebBeansContext.getInstance();
        return webBeansContext.getContextFactory();
import org.jboss.weld.context.api.ContextualInstance;
import org.jboss.weld.context.beanstore.BeanStore;
import java.lang.reflect.Field;
import java.util.Iterator;
    private Boolean resetSuccessful;

        if (Boolean.FALSE.equals(this.resetSuccessful) /*|| TODO detect weld 2.x*/)
        {
            if (applicationContext.isActive())
            {
                applicationContext.invalidate();
                this.applicationScopeStarted = false;
            }
            return;
        }

            //workaround for weld 1.x (see WELD-1072)
            org.jboss.weld.bootstrap.api.Singleton<BeanStore> beanStoreHolder = null;
            BeanStore originalBeanStore = null;
            try
            {
                Field field = this.applicationContext.getClass().getSuperclass().getDeclaredField("beanStore");
                field.setAccessible(true);
                beanStoreHolder = (org.jboss.weld.bootstrap.api.Singleton)field.get(this.applicationContext);
                final BeanStore beanStore = beanStoreHolder.get();
                originalBeanStore = beanStore;

                beanStoreHolder.set(new BeanStore()
                {
                    @Override
                    public <T> ContextualInstance<T> get(String id)
                    {
                        return beanStore.get(id);
                    }

                    @Override
                    public boolean contains(String id)
                    {
                        return beanStore.contains(id);
                    }

                    @Override
                    public void clear()
                    {
                        //do nothing
                    }

                    @Override
                    public Iterator<String> iterator()
                    {
                        return beanStore.iterator();
                    }

                    @Override
                    public <T> void put(String id, ContextualInstance<T> contextualInstance)
                    {
                        beanStore.put(id, contextualInstance);
                    }
                });
            }
            catch (Exception e)
            {
                //do nothing
                this.resetSuccessful = false;
            }
            catch (LinkageError e)
            {
                //do nothing - a new version of weld is used which introduced other required dependencies.
                //WELD-1072 should be fixed in this version already
                this.resetSuccessful = false;
            }


            if (beanStoreHolder != null)
            {
                Iterator<String> idIterator = originalBeanStore.iterator();

                String currentId;
                ContextualInstance<Object> currentContextualInstance;
                while (idIterator.hasNext())
                {
                    currentId = idIterator.next();
                    currentContextualInstance = originalBeanStore.get(currentId);

                    //keep (weld) internal application scoped beans - TODO check possible side-effects
                    if (currentContextualInstance.getInstance().getClass().getName().startsWith("org.jboss."))
                    {
                        //internalBeanList.add(currentContextualInstance);
                        continue;
                    }
                    idIterator.remove();
                }

                beanStoreHolder.set(originalBeanStore);
            }


            this.resetSuccessful = true;
            this.sessionContext.invalidate();
            this.sessionContext.deactivate();
            this.sessionContext.dissociate(this.sessionMap);
            this.sessionMap = null;
            this.conversationContext.invalidate();
            this.conversationContext.deactivate();
            this.conversationContext.dissociate(new MutableBoundRequest(this.requestMap, this.sessionMap));
            this.requestContext.invalidate();
            this.requestContext.deactivate();
            this.requestContext.dissociate(this.requestMap);
            this.requestMap = null;
import java.util.Set;

import javax.management.relation.Role;

import org.apache.deltaspike.security.Group;
import org.apache.deltaspike.security.api.User;

/**
 * An Authenticator implementation is responsible for managing the user authentication process. 
 */
    public enum AuthenticationStatus 
    {
        SUCCESS, 
        FAILURE, 
        DEFERRED
    }
    void authenticate();

    void postAuthenticate();

    AuthenticationStatus getStatus();

    User getUser();

    // TODO we'll likely remove the following two methods - still under discussion
    
    Set<Role>  getRoleMemberships();

    Set<Group>  getGroupMemberships(); 
import org.apache.deltaspike.security.api.AuthenticatorSelector;
import org.apache.deltaspike.security.api.events.PostAuthenticateEvent;
import org.apache.deltaspike.security.api.events.PreAuthenticateEvent;
import org.apache.deltaspike.security.spi.Authenticator.AuthenticationStatus;
    @Inject
    private Instance<AuthenticatorSelector> authenticatorSelector;
    
    private Authenticator activeAuthenticator;
    
    
    /**
     * Flag indicating whether we are currently authenticating
     */
    private boolean authenticating;
        if (authenticating) 
        {
            authenticating = false;
            throw new IllegalStateException("Authentication already in progress.");
        }

        try 
        {
            authenticating = true;

            user = null;

            beanManager.fireEvent(new PreAuthenticateEvent());

            activeAuthenticator = authenticatorSelector.get().getSelectedAuthenticator();

            if (activeAuthenticator == null) 
            {
                authenticating = false;
                throw new AuthenticationException("An Authenticator could not be located");
            }

            activeAuthenticator.authenticate();

            if (activeAuthenticator.getStatus() == null) 
            {
                throw new AuthenticationException("Authenticator must return a valid authentication status");
            }

            switch (activeAuthenticator.getStatus()) 
            {
                case SUCCESS:
                    postAuthenticate();
                    return true;
                case FAILURE:
                default:
                    authenticating = false;
                    return false;
            }
        } 
        catch (Exception ex) 
        {
            authenticating = false;
            if (ex instanceof AuthenticationException) 
            {
                throw (AuthenticationException) ex;
            } 
            else 
            {
                throw new AuthenticationException("Authentication failed.", ex);
            }
        }
    }    
    
    protected void postAuthenticate() 
    {
        if (activeAuthenticator == null) 
        {
            throw new IllegalStateException("activeAuthenticator is null");
        }

        try 
        {
            activeAuthenticator.postAuthenticate();

            if (!activeAuthenticator.getStatus().equals(AuthenticationStatus.SUCCESS))
            {
                return;
            }

            user = activeAuthenticator.getUser();

            if (user == null) 
            {
                throw new AuthenticationException(
                        "Authenticator must provide a non-null User after successful authentication");
            }

            if (isLoggedIn()) 
            {
                // TODO rewrite this once we decide how user privilege state is managed
                
                /**if (!preAuthenticationRoles.isEmpty()) 
                {
                    for (String group : preAuthenticationRoles.keySet()) 
                    {
                        Map<String, List<String>> groupTypeRoles = preAuthenticationRoles.get(group);
                        for (String groupType : groupTypeRoles.keySet()) 
                        {
                            for (String roleType : groupTypeRoles.get(groupType)) 
                            {
                                addRole(roleType, group, groupType);
                            }
                        }
                    }
                    preAuthenticationRoles.clear();
                }

                if (!preAuthenticationGroups.isEmpty()) 
                {
                    for (String group : preAuthenticationGroups.keySet()) 
                    {
                        for (String groupType : preAuthenticationGroups.get(group)) 
                        {
                            activeGroups.add(new SimpleGroup(group, groupType));
                        }
                    }
                    preAuthenticationGroups.clear();
                }*/
            }

            beanManager.fireEvent(new PostAuthenticateEvent());
        } 
        finally 
        {
            // Set credential to null whether authentication is successful or not
            activeAuthenticator = null;
            credentials.setCredential(null);
            authenticating = false;
        }
@Target({TYPE, METHOD } )



 * <p/>
 * <p/>
    private static Boolean testMode;

    private volatile Map<ClassLoader, BeanManagerHolder> bms = new ConcurrentHashMap<ClassLoader, BeanManagerHolder>();
                    "Please ensure that you configured the CDI implementation of your choice properly. " 
                    "If your setup is correct, please clear all caches and compiled artifacts.");
     *
     * @throws IllegalStateException if the BeanManager cannot be found
        BeanManagerHolder resultHolder = bms.get(classLoader);
        BeanManager result;
        if (resultHolder == null)
            if (result != null)
                bms.put(classLoader, new RootBeanManagerHolder(result));
        else
        {
            result = resultHolder.getBeanManager();

            if (!(resultHolder instanceof RootBeanManagerHolder))
            {
                BeanManager jndiBeanManager = resolveBeanManagerViaJndi();

                if (jndiBeanManager != null && /*same instance check:*/jndiBeanManager != result)
                {
                    setRootBeanManager(jndiBeanManager);

                    result = jndiBeanManager;
                }
                else
                {
                    setRootBeanManager(result);
                }
            }
        }

        if (result == null)
        {
            throw new IllegalStateException("Unable to find BeanManager. " 
                    "Please ensure that you configured the CDI implementation of your choice properly.");
        }

     * @param beanManager        the BeanManager we store and make available.
        setBeanManager(new BeanManagerHolder(beanManager));
    }

    public void setRootBeanManager(BeanManager beanManager)
    {
        setBeanManager(new RootBeanManagerHolder(beanManager));
    }

    private void setBeanManager(BeanManagerHolder beanManagerHolder)
    {

        if (beanManagerHolder instanceof RootBeanManagerHolder ||
                //the lat bm wins - as before, but don't replace a root-bmh with a normal bmh
                (!(bmpFirst.bms.get(cl) instanceof RootBeanManagerHolder)))
        {
            bmpFirst.bms.put(cl, beanManagerHolder);
        }

        //override in any case in test-mode
        /*
         * use:
         * new BeanManagerProvider() {
         * @Override
         * public void setTestMode() {
         *     super.setTestMode();
         *   }
         * }.setTestMode();
         *
         * to activate it
         */
        if (Boolean.TRUE.equals(testMode))
        {
            bmpFirst.bms.put(cl, beanManagerHolder);
        }
     *
    public void cleanupStoredBeanManagerOnShutdown(@Observes BeforeShutdown beforeShutdown)
     * <p/>

    protected void setTestMode()
    {
        activateTestMode();
    }

    private static void activateTestMode()
    {
        testMode = true;
    }
    public static final class UnitTest extends ProjectStage implements TestStage
    public static final class SystemTest extends ProjectStage implements TestStage
    public static final class IntegrationTest extends ProjectStage implements TestStage
            bmpFirst.bms.put(cl, new TestBeanManagerHolder(beanManagerHolder.getBeanManager()));
    BeanManager resolveBeanManagerViaJndi()
import org.apache.deltaspike.core.api.projectstage.TestStage;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
                if (TestStage.class.isAssignableFrom(projectStage.getClass()))
                {
                    new BeanManagerProvider()
                    {
                        @Override
                        public void setTestMode()
                        {
                            super.setTestMode();
                        }
                    } .setTestMode();
                }

        //also forces deterministic project-stage initialization
        ProjectStage projectStage = ProjectStageProducer.getInstance().getProjectStage();

        if (!evalExcludeInProjectStage(processAnnotatedType, exclude, projectStage))
        if (!evalExcludeNotInProjectStage(processAnnotatedType, exclude, projectStage))
    private boolean evalExcludeInProjectStage(ProcessAnnotatedType<Object> processAnnotatedType, Exclude exclude,
        ProjectStage currentlyConfiguredProjectStage)
        if (isInProjectStage(activatedIn, currentlyConfiguredProjectStage))
    private boolean evalExcludeNotInProjectStage(ProcessAnnotatedType<Object> processAnnotatedType, Exclude exclude,
        ProjectStage currentlyConfiguredProjectStage)
        if (!isInProjectStage(notIn, currentlyConfiguredProjectStage))
    private boolean isInProjectStage(Class<? extends ProjectStage>[] activatedIn,
        ProjectStage currentlyConfiguredProjectStage)
                if (currentlyConfiguredProjectStage.getClass().equals(activated))
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/Group.java
package org.apache.deltaspike.security.api;
import org.apache.deltaspike.security.api.Group;
import org.apache.deltaspike.security.api.Group;
import org.apache.deltaspike.security.api.Group;
 b/deltaspike/cdictrl/api/src/main/java/org/apache/deltaspike/cdise/api/CdiContainer.java
    void boot();
    void shutdown();
    /**
     * @return ContextControl for the started Container. <code>null</code> if the container is not yet started
     */
    ContextControl getContextControl();
 b/deltaspike/cdictrl/impl-weld/src/main/java/org/apache/deltaspike/cdise/weld/WeldContextControl.java
import javax.enterprise.context.Dependent;
import javax.inject.Inject;
import org.apache.deltaspike.cdise.api.ContextControl;
/**
 * Weld specific impl of the {@link org.apache.deltaspike.cdise.api.ContextControl}
 */
@Dependent
public class WeldContextControl implements ContextControl
{
    @Inject
    private BeanManager beanManager;
        stopApplicationScope(); //can't be done because of WELD-1072
        try
        {
            getContextController().startApplicationScope();
        }
        catch (IllegalStateException ise)
        {
            // weld throws an ISE if the context was already started...
        }
        try
        {
            getContextController().startSessionScope();
        }
        catch (IllegalStateException ise)
        {
            // weld throws an ISE if the context was already started...
        }
        try
        {
            getContextController().startConversationScope(null);
        }
        catch (IllegalStateException ise)
        {
            // weld throws an ISE if the context was already started...
        }
        try
        {
            getContextController().startRequestScope();
        }
        catch (IllegalStateException ise)
        {
            // weld throws an ISE if the context was already started...
        }
        try
        {
            getContextController().stopApplicationScope();
        }
        catch (IllegalStateException ise)
        {
            // weld throws an ISE if the context was already stopped...
        }
        try
        {
            getContextController().stopSessionScope();
        }
        catch (IllegalStateException ise)
        {
            // weld throws an ISE if the context was already stopped...
        }
        try
        {
            getContextController().stopConversationScope();
        }
        catch (IllegalStateException ise)
        {
            // weld throws an ISE if the context was already stopped...
        }
        try
        {
            getContextController().stopRequestScope();
        }
        catch (IllegalStateException ise)
        {
            // weld throws an ISE if the context was already stopped...
        }
        try
        {
            getContextController().stopSingletonScope();
        }
        catch (IllegalStateException ise)
        {
            // weld throws an ISE if the context was already stopped...
        }

import org.apache.deltaspike.cdise.api.ContextControl;
        cdiContainer.boot();

        ContextControl contextControl = cdiContainer.getContextControl();
        contextControl.startContext(ApplicationScoped.class);
        contextControl.stopContext(ApplicationScoped.class);
        cdiContainer.shutdown();
import org.apache.deltaspike.cdise.api.ContextControl;
        cdiContainer.boot();

        ContextControl contextControl = cdiContainer.getContextControl();
        contextControl.startContext(ApplicationScoped.class);
        contextControl.stopContext(ApplicationScoped.class);
        cdiContainer.shutdown();
     * @param qualifiers additional qualifiers which further distinct the resolved bean
     * @param <T> target type
     * @return the resolved Contextual Reference
     * @throws {@code IllegalStateException} if the bean could not be found.
     * @see #getContextualReference(Class, boolean, Annotation...)
     */
    public static <T> T getContextualReference(Class<T> type, Annotation... qualifiers)
    {
        return getContextualReference(type, false, qualifiers);
    }

    /**
     * {@link #getContextualReference(Class, Annotation...)} which returns <code>null</code> if the
     * 'optional' parameter is set to <code>true</code>.
     *
     * @param type the type of the bean in question
     * @see #getContextualReference(Class, Annotation...)
     * @return the resolved Contextual Reference
     * @throws {@code IllegalStateException} if the bean could not be found.
     * @see #getContextualReference(String, boolean)
     */
    public static Object getContextualReference(String name)
    {
        return getContextualReference(name, false);
    }

    /**
     * <p>Get a Contextual Reference by it's EL Name.
     * This only works for beans with the &#064;Named annotation.</p>
     *
     * <p><b>Attention:</b> please see the notes on manually resolving &#064;Dependent bean
     * in {@link #getContextualReference(Class, boolean, java.lang.annotation.Annotation...)}!</p>
     *
     * @param name     the EL name of the bean
    public static <T> List<T> getContextualReferences(Class<T> type, boolean optional)
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.InjectionTarget;
     * @throws IllegalStateException if the bean could not be found.
     * @throws IllegalStateException if the bean could not be found.
            //noinspection unchecked
                new HashSet<Bean<?>>((Collection) Arrays.asList(bean))));
    /**
     * Allows to perform dependency injection for instances which aren't managed by CDI
     * <p/>
     * Attention:<br/>
     * The resulting instance isn't managed by CDI, only fields annotated with @Inject get initialized.
     *
     * @param instance current instance
     * @param <T> current type
     * @return instance with injected fields (if possible - or null if the given instance is null)
     */
    @SuppressWarnings("unchecked")
    public static <T> T injectFields(T instance)
    {
        if (instance == null)
        {
            return null;
        }

        BeanManager beanManager = getBeanManager();

        CreationalContext creationalContext = beanManager.createCreationalContext(null);

        AnnotatedType annotatedType = beanManager.createAnnotatedType(instance.getClass());
        InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotatedType);
        injectionTarget.inject(instance, creationalContext);
        return instance;
    }

     * @return current bean-manager
 * Category marker interface for tests which only run outside of a java-ee server
 * e.g. due to a restriction of our test-setup with packaging resources with the same name from different sources
 * like multiple parallel versions of apache-deltaspike.properties which is caused by the autom. unpack to the
 * integration-test module.
import java.lang.annotation.Annotation;

    //TODO discuss metaDataType
    <S, T> Converter<S, T> create(Class<S> sourceType, Class<T> targetType, Class<? extends Annotation> metaDataType);
            converter = converterFactory.create(String.class, (Class<?>) this.beanType,
                this.customQualifier != null ? customQualifier.annotationType() : null);
                        qualifier = annotation;
    @SuppressWarnings("UnusedDeclaration")
        if (optionalCustomQualifier != null ? !optionalCustomQualifier
                .equals(that.optionalCustomQualifier) : that.optionalCustomQualifier != null)
        {
            return false;
        }
        result = 31 * result  (optionalCustomQualifier != null ? optionalCustomQualifier.hashCode() : 0);
import java.lang.annotation.Annotation;
    private final Class<? extends Annotation> metaDataType;
    ConverterKey(Class sourceType, Class targetType, Class<? extends Annotation> metaDataType)
        this.metaDataType = metaDataType;
        if (metaDataType != null ? !metaDataType.equals(that.metaDataType) : that.metaDataType != null)
        {
            return false;
        }
        result = 31 * result  (metaDataType != null ? metaDataType.hashCode() : 0);
import org.apache.deltaspike.core.api.converter.MetaDataAwareConverter;
import java.lang.annotation.Annotation;
    @Override
    public <S, T> Converter<S, T> create(
        Class<S> sourceType, Class<T> targetType, Class<? extends Annotation> metaDataType)
    {
        //TODO throw an exception if there isn't the correct converter
        Converter<S, T> result;

        //try to find meta-data-aware converter
        result = this.converterMapping.get(new ConverterKey(sourceType, targetType, metaDataType));

        //for a simple custom configuration-annotation a custom converter isn't required
        //in this case the custom annotation is just used to keep the (string-based) property in a central place

        if (result != null)
        {
            return result;
        }

        return this.converterMapping.get(new ConverterKey(sourceType, targetType, null));
    }

        registerConverter(new StringToLongConverter());
        Class metaDataType = null;

                    if (MetaDataAwareConverter.class.isAssignableFrom((Class<?>) parameterizedType.getRawType()))
                    {
                        metaDataType = (Class<?>) parameterizedType.getActualTypeArguments()[2];
                    }
        this.converterMapping.put(new ConverterKey(sourceType, targetType, metaDataType), converter);
import org.apache.deltaspike.core.util.ReflectionUtils;
        for (Field field : ReflectionUtils.getAllDeclaredFields(type))
            ReflectionUtils.setAccessible(field);
        for (Method method : ReflectionUtils.getAllDeclaredMethods(type))
            ReflectionUtils.setAccessible(method);
import org.apache.deltaspike.core.util.ReflectionUtils;
        return ReflectionUtils.<T>cast(annotationMap.get(anType));
import org.apache.deltaspike.core.util.BeanUtils;
        this.qualifiers = BeanUtils.getQualifiers(beanManager, field.getAnnotations());
        this.qualifiers = BeanUtils.getQualifiers(beanManager, parameter.getAnnotations());
import static org.apache.deltaspike.core.util.BeanUtils.createInjectionPoints;
import static org.apache.deltaspike.core.util.ReflectionUtils.EMPTY_OBJECT_ARRAY;
import static org.apache.deltaspike.core.util.ReflectionUtils.invokeMethod;
            //see ReflectionUtils#invokeMethod
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/BeanUtils.java
import static org.apache.deltaspike.core.util.ReflectionUtils.isSerializable;
public class BeanUtils
    private BeanUtils()
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/ReflectionUtils.java
public abstract class ReflectionUtils
    private ReflectionUtils()
     * otherwise the classloader used to load {@link ReflectionUtils} will be used
     * {@link ReflectionUtils#invokeMethod(boolean, Method, Class, Object, Object...)}, with the
     * @see ReflectionUtils#invokeMethod(boolean, Method, Class, Object, Object...)
     * {@link ReflectionUtils#invokeMethod(boolean, Method, Class, Object, Object...)}, with the
     * @see ReflectionUtils#invokeMethod(boolean, Method, Class, Object, Object...)
     * {@link ReflectionUtils#invokeMethod(boolean, Method, Class, Object, Object...)}, with the
     * @see ReflectionUtils#invokeMethod(boolean, Method, Class, Object, Object...)
     * {@link ReflectionUtils#setFieldValue(boolean, Field, Object, Object)}, honoring
            return ReflectionUtils.<T>cast(field.get(instance));
            @SuppressWarnings({ "unchecked", "UnnecessaryLocalVariable" })
            T result =
                    (T) invokeMethod(receiver, method.getJavaMember(), Object.class, true, parameterValues.toArray());
 * use the {@link org.apache.deltaspike.core.util.ClassDeactivationUtils} for implementing the lookup</p>
import org.apache.deltaspike.core.api.metadata.builder.ImmutableInjectionPoint;
import javax.enterprise.inject.Typed;
import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
@Typed()
public abstract class BeanUtils
        // prevent instantiation
        Set<Annotation> qualifiers = new HashSet<Annotation>();

        for (Annotation annotation : annotations)
        {
            if (beanManager.isQualifier(annotation.annotationType()))
            {
                qualifiers.add(annotation);
            }
        }

        return qualifiers;
}
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/ClassDeactivationUtils.java
public abstract class ClassDeactivationUtils
    private static final Logger LOG = Logger.getLogger(ClassDeactivationUtils.class.getName());
    private ClassDeactivationUtils()
//X TODO review
import java.util.Collections;
            Collections.addAll(fields, c.getDeclaredFields());
    public static Field tryToFindDeclaredField(Class<?> clazz, String name)
            Collections.addAll(methods, c.getDeclaredMethods());
                "Details: Exception invoking method [%s] on object [%s], using arguments [", method.getName(), obj));
                message.append(i > 0 ? ", " : "").append(args[i]);
    @Deprecated //X TODO use SecurityService of OWB
    public static <T> T invokeMethod(Object instance, 
                                     boolean setAccessible,
                                     Object... args)
        catch (Exception e)
            String customMessage = createCustomMessage(e, method, instance, args);
            ExceptionUtils.changeAndThrowException(e, customMessage);
            //won't happen
            return null;
    private static String createCustomMessage(Exception e, Method method, Object targetObject, Object... arguments)
        return e.getMessage()  buildInvokeMethodErrorMessage(method, targetObject, arguments);
    private static <T> Class<T> getRawType(Type type)
     * @return true if the class implements serializable or is a primitive (needed for type {@link Void}
    public static Type[] getTypeArguments(Class<?> clazz)
    public static Type[] getTypeArguments(Type type)
    public static boolean isParameterizedTypeWithWildcard(Class<?> type)
    private static boolean containsWildcards(Type[] types)
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
            this.isActivated = ClassDeactivationUtils.isActivated(getClass());
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
            isActivated = ClassDeactivationUtils.isActivated(getClass());
            isGlobalAlternativeActivated = ClassDeactivationUtils.isActivated(GlobalAlternative.class);
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
            isActivated = ClassDeactivationUtils.isActivated(getClass());
    public static Type[] getActualTypeArguments(Class<?> clazz)
        //X TODO discuss direct usage: return clazz.getTypeParameters();

    public static Type[] getActualTypeArguments(Type type)
        //X TODO discuss delegation to getActualTypeArguments(Class) if type is an instance of Class

import org.apache.deltaspike.core.util.StringUtils;
        if (!StringUtils.isEmpty(authenticatorName))
        if (clazz == null)
        {
            throw new IllegalArgumentException("null isn't supported");
        }
        return clazz.getTypeParameters();
        if (type instanceof Class)
        {
            return getActualTypeArguments((Class)type);
        }
        throw new IllegalArgumentException((type != null ? type.getClass().getName() : "null")  " isn't supported");
import org.apache.deltaspike.core.util.ClassUtils;
import org.jboss.shrinkwrap.api.asset.Asset;
import org.jboss.shrinkwrap.api.asset.StringAsset;
    public static JavaArchive[] getDeltaSpikeCoreAndSecurityArchive()
        //X TODO remove this workaround
        boolean isOwbAvailable = ClassUtils.tryToLoadClassForName("org.apache.webbeans.spi.ContainerLifecycle") != null;

        String[] excludedFiles;

        if (isOwbAvailable)
        {
            excludedFiles = new String[]{"META-INF.apache-deltaspike.properties"};
        }
        else
        {
            excludedFiles = new String[]{"META-INF.apache-deltaspike.properties", "META-INF.beans.xml"};
        }


                new String[]{"org.apache.deltaspike.core", "org.apache.deltaspike.security"}, excludedFiles);

    public static Asset getBeansXml()
    {
        @SuppressWarnings("UnnecessaryLocalVariable")
        Asset beansXml = new StringAsset(
            "<beans>" 
                "<interceptors><class>org.apache.deltaspike.security.impl.SecurityInterceptor</class></interceptors>" 
            "</beans>"
        );

        return beansXml;
    }
}
    private TestUser user;
    public TestUser getUser()
        return user;
    public void setUser(TestUser user)
        this.user = user;
import javax.enterprise.inject.spi.BeforeShutdown;
    protected static void removeMetaDataStorage()
    {
        ClassLoader classLoader = ClassUtils.getClassLoader(null);
        SECURITY_METADATA_STORAGE_MAPPING.remove(classLoader);
    }

    protected void cleanup(@Observes BeforeShutdown beforeShutdown)
    {
        removeMetaDataStorage();
    }

        projectStageProducer = new ProjectStageProducer();

    private Boolean servletApiAvailable = null;
    
    private Object session = null;
    private Object servletContext = null;
    
    protected boolean isServletApiAvailable()
    {
        if (servletApiAvailable == null)
        {
            try
            {
                Class servletClass = Class.forName("javax.servlet.http.HttpSession");
                servletApiAvailable = servletClass != null;
                LOG.fine("Servlet API available: "  servletApiAvailable);
            }
            catch (ClassNotFoundException e)
            {
                servletApiAvailable = Boolean.FALSE;
            }
        }
        return servletApiAvailable;
    }
    protected Object getMockSession()
    {
        if (isServletApiAvailable() && session == null)
        {
            session = new MockHttpSession();
        }

        return session;
    }
    
    protected Object getMockServletContext()
    {
        if (isServletApiAvailable() && servletContext == null)
        {
            servletContext  = new MockServletContext();
        }

        return servletContext;
    }
        contextFactory.initSingletonContext(getMockServletContext());
        contextFactory.initApplicationContext(getMockServletContext());
        contextFactory.initSessionContext(getMockSession());
        contextFactory.initApplicationContext(getMockServletContext());
        contextFactory.initSessionContext(getMockSession());
            contextFactory.destroySingletonContext(getMockServletContext());
            contextFactory.destroyApplicationContext(getMockServletContext());
            contextFactory.destroySessionContext(getMockSession());
    public static void throwAsRuntimeException(Throwable throwable)
    {
        //Attention: helper which allows to use a trick to throw a cached checked exception without a wrapping exception
        new ExceptionHelper<RuntimeException>().throwException(throwable);
    }

        //Attention: helper which allows to use a trick to throw a cached checked exception without a wrapping exception
import java.io.Serializable;
public interface Identity extends Serializable
        SUCCESS, FAILED
     * @return AuthenticationResult returns SUCCESS if user is authenticated,
     * FAILED if authentication FAILED, or
     * EXCEPTION if an EXCEPTION occurred during authentication. These response
     * the login() method will return an immediate result of FAILED (and subsequently fire
import javax.enterprise.inject.Typed;
import java.io.Serializable;
@Typed()
public class User implements Serializable
{
    private static final long serialVersionUID = -2234530384311026364L;

    private final String id;

    public User(String id)
    {
        this.id = id;
    }

    public String getId()
    {
        return id;
    }
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/AuthenticationException.java
package org.apache.deltaspike.security.api.authentication;
public class AuthenticationException extends org.apache.deltaspike.security.api.SecurityException
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/UnexpectedCredentialException.java
package org.apache.deltaspike.security.api.authentication;
public class UnexpectedCredentialException extends AuthenticationException
    private static final long serialVersionUID = 4827200587997989123L;
    public UnexpectedCredentialException(String message)
    public UnexpectedCredentialException(String message, Throwable cause)
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/events/AlreadyLoggedInEvent.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.deltaspike.security.api.authentication.events;

/**
 * This event is fired when an already authenticated user attempts to authenticate again
 */
public class AlreadyLoggedInEvent 
{

}
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/events/LoggedInEvent.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.deltaspike.security.api.authentication.events;

/**
 * This event is raised when user successfully logs in.
 */
public class LoggedInEvent 
{
}
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/events/LoginFailedEvent.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.deltaspike.security.api.authentication.events;

/**
 * This event is fired when an authentication attempt fails
 */
public class LoginFailedEvent 
{
    private Exception loginException;

    public LoginFailedEvent(Exception loginException) 
    {
        this.loginException = loginException;
    }

    public Exception getLoginException() 
    {
        return loginException;
    }
}
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/events/PostAuthenticateEvent.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.deltaspike.security.api.authentication.events;

/**
 * This event is raised just after authentication
 */
public class PostAuthenticateEvent 
{

}
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/events/PostLoggedOutEvent.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.security.api.authentication.events;

import org.apache.deltaspike.security.api.User;

/**
 * This event is raised just after the user un-authenticates
 */
public class PostLoggedOutEvent 
{
    private User user;

    public PostLoggedOutEvent(User user)
    {
        this.user = user;
    }

    public User getUser()
    {
        return user;
    }
}
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/events/PreAuthenticateEvent.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.security.api.authentication.events;

/**
 * This event is raised just before authentication.
 */
public class PreAuthenticateEvent 
{

}
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/events/PreLoggedOutEvent.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.security.api.authentication.events;

import org.apache.deltaspike.security.api.User;

/**
 * This event is raised just before the user un-authenticates
 */
public class PreLoggedOutEvent 
{
    private User user;

    public PreLoggedOutEvent(User user)
    {
        this.user = user;
    }

    public User getUser()
    {
        return user;
    }
}
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/AccessDecisionState.java
package org.apache.deltaspike.security.api.authorization;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/AccessDecisionVoter.java
package org.apache.deltaspike.security.api.authorization;
 * A voter has to be used in combination with
 * {@link org.apache.deltaspike.security.api.authorization.annotation.Secured}.<p/>
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/AccessDecisionVoterContext.java
package org.apache.deltaspike.security.api.authorization;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/AccessDeniedException.java
package org.apache.deltaspike.security.api.authorization;
public class AccessDeniedException extends org.apache.deltaspike.security.api.SecurityException
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/AuthorizationException.java
package org.apache.deltaspike.security.api.authorization;
public class AuthorizationException extends org.apache.deltaspike.security.api.SecurityException
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/SecurityDefinitionException.java
package org.apache.deltaspike.security.api.authorization;
public class SecurityDefinitionException extends org.apache.deltaspike.security.api.SecurityException
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/SecurityViolation.java
package org.apache.deltaspike.security.api.authorization;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/annotation/Secured.java
package org.apache.deltaspike.security.api.authorization.annotation;

import org.apache.deltaspike.security.api.authorization.AccessDecisionVoter;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/annotation/Secures.java
package org.apache.deltaspike.security.api.authorization.annotation;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/annotation/SecurityBindingType.java
package org.apache.deltaspike.security.api.authorization.annotation;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/credential/Credential.java
package org.apache.deltaspike.security.api.credential;
public interface Credential<T>
    T getValue();
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/credential/LoginCredential.java
package org.apache.deltaspike.security.api.credential;
 * Only valid during the authentication process
public interface LoginCredential
    String getUserId();
    void setUserId(String userId);
    
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/spi/authentication/Authenticator.java
package org.apache.deltaspike.security.spi.authentication;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/spi/authentication/AuthenticatorSelector.java
package org.apache.deltaspike.security.spi.authentication;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/spi/authentication/BaseAuthenticator.java
package org.apache.deltaspike.security.spi.authentication;
    public AuthenticationStatus getStatus()
    protected void setStatus(AuthenticationStatus status)
    public void postAuthenticate()
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/spi/authorization/EditableAccessDecisionVoterContext.java
package org.apache.deltaspike.security.spi.authorization;
import org.apache.deltaspike.security.api.authorization.AccessDecisionState;
import org.apache.deltaspike.security.api.authorization.AccessDecisionVoterContext;
import org.apache.deltaspike.security.api.authorization.SecurityViolation;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/spi/authorization/SecurityStrategy.java
package org.apache.deltaspike.security.spi.authorization;
 * Marker interface for a pluggable strategy for
 * {@link org.apache.deltaspike.security.api.authorization.annotation.Secured}
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/authentication/DefaultAuthenticatorSelector.java
package org.apache.deltaspike.security.impl.authentication;
import org.apache.deltaspike.security.spi.authentication.Authenticator;
import org.apache.deltaspike.security.spi.authentication.AuthenticatorSelector;

import javax.enterprise.context.RequestScoped;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import java.util.List;
@RequestScoped
public class DefaultAuthenticatorSelector implements AuthenticatorSelector
            // If the user has provided their own custom authenticator then use it
            if (isExternalAuthenticator(auth.getClass()))
        }
        if (selectedAuth == null)
        {
            //X TODO discuss default
        //X TODO specify the behaviour
        return !authClass.getName().startsWith(getClass().getPackage().getName());
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/authorization/Authorizer.java
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.api.authorization.AuthorizationException;
import org.apache.deltaspike.security.api.authorization.SecurityDefinitionException;
import org.apache.deltaspike.security.api.authorization.annotation.SecurityBindingType;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/authorization/DefaultAccessDecisionVoterContext.java
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.api.authorization.AccessDecisionState;
import org.apache.deltaspike.security.api.authorization.SecurityViolation;
import org.apache.deltaspike.security.spi.authorization.EditableAccessDecisionVoterContext;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/authorization/DefaultSecurityStrategy.java
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.spi.authorization.SecurityStrategy;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/authorization/SecuredAnnotationAuthorizer.java
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.api.authorization.AccessDecisionState;
import org.apache.deltaspike.security.api.authorization.AccessDecisionVoter;
import org.apache.deltaspike.security.api.authorization.AccessDecisionVoterContext;
import org.apache.deltaspike.security.api.authorization.AccessDeniedException;
import org.apache.deltaspike.security.api.authorization.SecurityViolation;
import org.apache.deltaspike.security.api.authorization.annotation.Secured;
import org.apache.deltaspike.security.api.authorization.annotation.Secures;
import org.apache.deltaspike.security.spi.authorization.EditableAccessDecisionVoterContext;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/authorization/SecurityExtension.java
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.api.authorization.SecurityDefinitionException;
import org.apache.deltaspike.security.api.authorization.annotation.Secures;
import org.apache.deltaspike.security.spi.authentication.Authenticator;
    public static void removeMetaDataStorage()
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/authorization/SecurityInterceptor.java
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.spi.authorization.SecurityStrategy;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/authorization/SecurityInterceptorBinding.java
package org.apache.deltaspike.security.impl.authorization;
import javax.interceptor.InterceptorBinding;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/authorization/SecurityInterceptorBindingLiteral.java
package org.apache.deltaspike.security.impl.authorization;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/authorization/SecurityMetaDataStorage.java
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.api.authorization.SecurityDefinitionException;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/authorization/SecurityUtils.java
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.api.authorization.annotation.SecurityBindingType;
abstract class SecurityUtils
 b/deltaspike/modules/security/impl/src/test/java/org/apache/deltaspike/test/security/impl/authentication/Inquiry.java
package org.apache.deltaspike.test.security.impl.authentication;
interface Inquiry
    String getInquiryId();
 b/deltaspike/modules/security/impl/src/test/java/org/apache/deltaspike/test/security/impl/authentication/InquiryStorage.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.security.impl.authentication;

public interface InquiryStorage
{
    boolean addInquiry(Inquiry inquiry);
}
 b/deltaspike/modules/security/impl/src/test/java/org/apache/deltaspike/test/security/impl/authentication/Shop.java
package org.apache.deltaspike.test.security.impl.authentication;
import javax.inject.Inject;
/**
 *
 */
public class Shop
    @Inject
    private InquiryStorage inquiryStorage;
    public String sendInquiry(Inquiry inquiry)
        if (this.inquiryStorage.addInquiry(inquiry))
        {
            return inquiry.getInquiryId();
            //TODO e.g. send notification in case of inquiries of premium users,...
        }

        return null;
 b/deltaspike/modules/security/impl/src/test/java/org/apache/deltaspike/test/security/impl/authorization/secured/SecuredBean1.java
package org.apache.deltaspike.test.security.impl.authorization.secured;
import org.apache.deltaspike.security.api.authorization.annotation.Secured;
 b/deltaspike/modules/security/impl/src/test/java/org/apache/deltaspike/test/security/impl/authorization/secured/SecuredBean2.java
package org.apache.deltaspike.test.security.impl.authorization.secured;
 b/deltaspike/modules/security/impl/src/test/java/org/apache/deltaspike/test/security/impl/authorization/secured/SecuredBean3.java
package org.apache.deltaspike.test.security.impl.authorization.secured;
import org.apache.deltaspike.security.api.authorization.annotation.Secured;
 b/deltaspike/modules/security/impl/src/test/java/org/apache/deltaspike/test/security/impl/authorization/secured/SecuredBeanWithStereotype.java
package org.apache.deltaspike.test.security.impl.authorization.secured;
import org.apache.deltaspike.security.api.authorization.annotation.Secured;
                "<interceptors>" 
                    "<class>org.apache.deltaspike.security.impl.authorization.SecurityInterceptor</class>" 
                "</interceptors>" 
}
public class AccessDeniedException extends SecurityException
import org.apache.deltaspike.security.api.authorization.AccessDeniedException;
import org.apache.deltaspike.security.api.authorization.SecurityViolation;
import javax.enterprise.inject.Typed;
import java.util.HashSet;
@Typed()
    private Annotation bindingAnnotation;
    private Map<Method, Object> bindingSecurityBindingMembers = new HashMap<Method, Object>();
    private AnnotatedMethod<?> boundAuthorizerMethod;
    private Bean<?> boundAuthorizerBean;
    private InjectableMethod<?> boundAuthorizerMethodProxy;
    Authorizer(Annotation bindingAnnotation, AnnotatedMethod<?> boundAuthorizerMethod, BeanManager beanManager)
        this.bindingAnnotation = bindingAnnotation;
        this.boundAuthorizerMethod = boundAuthorizerMethod;
            for (Method method : bindingAnnotation.annotationType().getDeclaredMethods())
                bindingSecurityBindingMembers.put(method, method.invoke(bindingAnnotation));
    void authorize(final InvocationContext ic)
        if (boundAuthorizerBean == null)
        final CreationalContext<?> creationalContext = beanManager.createCreationalContext(boundAuthorizerBean);
        Object reference = beanManager.getReference(boundAuthorizerBean,
            boundAuthorizerMethod.getJavaMember().getDeclaringClass(), creationalContext);
        Object result = boundAuthorizerMethodProxy.invoke(reference, creationalContext, new ParameterValueRedefiner() {
            Set<SecurityViolation> violations = new HashSet<SecurityViolation>();
            violations.add(new SecurityViolation()
            {
                private static final long serialVersionUID = 2358753444038521129L;

                @Override
                public String getReason()
                {
                    return "Authorization check failed";
                }
            });

            throw new AccessDeniedException(violations);
        if (boundAuthorizerBean == null)
            Method method = boundAuthorizerMethod.getJavaMember();
                boundAuthorizerBean = beans.iterator().next();
            boundAuthorizerMethodProxy = new InjectableMethod(boundAuthorizerMethod, boundAuthorizerBean, beanManager);
    boolean matchesBinding(Annotation annotation)
        if (!annotation.annotationType().equals(bindingAnnotation.annotationType()))
            if (!bindingSecurityBindingMembers.containsKey(method))
                if (!bindingSecurityBindingMembers.get(method).equals(value))
    Method getBoundAuthorizerMethod()
        return boundAuthorizerMethod.getJavaMember();
@SuppressWarnings("UnusedDeclaration")
@SuppressWarnings("UnusedDeclaration")
    @SuppressWarnings("UnusedDeclaration")
     * @param annotatedMethod
    private void registerAuthorizer(AnnotatedMethod<?> annotatedMethod, BeanManager beanManager)
        if (!annotatedMethod.getJavaMember().getReturnType().equals(Boolean.class) &&
                !annotatedMethod.getJavaMember().getReturnType().equals(Boolean.TYPE))
                    annotatedMethod.getJavaMember().getDeclaringClass().getName()  "." 
                    annotatedMethod.getJavaMember().getName()  "] - does not return a boolean.");
        for (Annotation annotation : annotatedMethod.getAnnotations())
                            annotatedMethod.getJavaMember().getDeclaringClass().getName()  "." 
                            annotatedMethod.getJavaMember().getName()  "] - declares multiple security binding types");
        Authorizer authorizer = new Authorizer(binding, annotatedMethod, beanManager);
                            sb.append(authorizer.getBoundAuthorizerMethod().getDeclaringClass().getName());
                            sb.append(authorizer.getBoundAuthorizerMethod().getName());
                                    sb.append(a.getBoundAuthorizerMethod().getDeclaringClass().getName());
                                    sb.append(a.getBoundAuthorizerMethod().getName());
     * This will shutdown the underlying CDI container and stop all contexts.
@SuppressWarnings("UnusedDeclaration")
@SuppressWarnings("UnusedDeclaration")
    public BeanManager getBeanManager()
@SuppressWarnings("UnusedDeclaration")
import org.apache.webbeans.config.WebBeansContext;


            if (beanManager == null)
            {
                // this happens if the OpenEJB injection didnt work
                beanManager = WebBeansContext.getInstance().getBeanManagerImpl();
            }
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.apache.deltaspike.core.api.metadata.builder.InjectableMethod;
import org.apache.deltaspike.security.api.authorization.AccessDeniedException;
import org.apache.deltaspike.security.api.authorization.SecurityDefinitionException;
import org.apache.deltaspike.security.api.authorization.SecurityViolation;
import org.apache.deltaspike.security.api.authorization.annotation.SecurityBindingType;

/**
 * Responsible for authorizing method invocations.
 * 
 * @author Shane Bryzak
 * @author <a href="mailto:lincolnbaxter@gmail.com">Lincoln Baxter, III</a>
 */
        Object result = boundAuthorizerMethodProxy.invoke(reference, creationalContext, 
                    new SecurityParameterValueRedefiner(creationalContext, ic));
}
}
}
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
    public static <T> Class<T> getRawType(Type type)
import org.apache.deltaspike.core.util.ReflectionUtils;
        return ReflectionUtils.<T> cast(delegate.create(ReflectionUtils
        delegate.destroy(instance, ReflectionUtils
                .<CreationalContext<Object>> cast(creationalContext));
import static org.apache.deltaspike.core.util.ReflectionUtils.getRawType;
                .readFromType(type).types(type.getBaseType(), Object.class)
public class MessageBundleLiteral extends AnnotationLiteral<MessageBundle> implements MessageBundle
import org.apache.deltaspike.core.impl.util.ArraysUtils;
 *
 * @see ImmutableBeanWrapper
     *
     * @param beanClass       The Bean class, may not be null
     * @param name            The bean name
     * @param qualifiers      The bean's qualifiers, if null, a singleton set of
     *                        {@link javax.enterprise.inject.Default} is used
     * @param scope           The bean's scope, if null, the default scope of
     *                        {@link Dependent} is used
     * @param stereotypes     The bean's stereotypes, if null, an empty set is used
     * @param types           The bean's types, if null, the beanClass and {@link Object}
     *                        will be used
     * @param alternative     True if the bean is an alternative
     * @param nullable        True if the bean is nullable
     * @param injectionPoints the bean's injection points, if null an empty set is used
     * @throws IllegalArgumentException if the beanClass is null
    public AbstractImmutableBean(Class<?> beanClass,
                                 String name,
                                 Set<Annotation> qualifiers,
                                 Class<? extends Annotation> scope,
                                 Set<Class<? extends Annotation>> stereotypes,
                                 Set<Type> types,
                                 boolean alternative,
                                 boolean nullable,
                                 Set<InjectionPoint> injectionPoints,
                                 String toString)


            this.qualifiers = Collections.<Annotation>singleton(new DefaultLiteral());

            //X TODO re-visit after the logging discussion
            //LOG.finest("No qualifers provided for bean class "  beanClass  ", using singleton set of @Default");


            //X TODO re-visit after the logging discussion
            //LOG.finest("No scope provided for bean class "  beanClass  ", using @Dependent");

            this.stereotypes = new HashSet<Class<? extends Annotation>>(stereotypes);

            this.types = ArraysUtils.<Type>asSet(Object.class, beanClass);

            //X TODO re-visit after the logging discussion
            /*
            LOG.finest("No types provided for bean class "  beanClass
            */



            this.toString = "Custom Bean with bean class "  beanClass  " and qualifiers "  qualifiers;
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/message/ImmutableBeanWrapper.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.core.impl.message;

import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Set;

import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.spi.Bean;

import org.apache.deltaspike.core.util.ReflectionUtils;

/**
 * <p>
 * This bean-wrapper allows you to build a general purpose bean (likely a
 * producer method), and register it for a narrowed type (or qualifiers). For
 * example, you could create a producer method which uses an a String ID to
 * located an object (the object can have any class):
 * </p>
 * <p/>
 * <p/>
 * <pre>
 * &#064;Produces
 * // Use some synthetic scope to prevent this from interfering with other
 * // resolutions
 * &#064;MyProducer
 * Object produce(InjectionPoint ip)
 * {
 *     String id = ip.getAnnotated().getAnnotation(Id.class).value();
 *     // Lookup and return the object for the id
 * }
 * </pre>
 * <p/>
 * <p>
 * The wrapped bean <em>must</em> return an object which can be cast to the
 * type <code>T</code>, otherwise a {@link ClassCastException} will be thrown at
 * runtime when the bean is created.
 * </p>
 * <p/>
 * <p>
 * You can then register a narrowing bean for each type you need:
 * </p>
 * <p/>
 * <p/>
 * <pre>
 * event.addBean(new NarrowingBeanBuilder&lt;T&gt;(delegateBean).readFromType(type)
 *         .create());
 * </pre>
 * <p/>
 * <p>
 * {@link ImmutableBeanWrapper} will use the annotations on
 * <code>defininingType</code> to discover the qualifiers, types, scope,
 * stereotypes of the bean, as well as determine it's name (if any) and whether
 * it is an alternative.
 * </p>
 * <p/>
 * <p>
 * The attributes are immutable, and collections are defensively copied on
 * instantiation. It uses the defaults from the specification for properties if
 * not specified.
 * </p>
 *
 * @see NarrowingBeanBuilder
 */
class ImmutableBeanWrapper<T> extends AbstractImmutableBean<T>
{
    private final Bean<T> wrapped;

    /**
     * Instantiate a new {@link ImmutableBeanWrapper}.
     *
     * @param bean        the bean to wrapped the lifecycle to
     * @param name        the name of the bean
     * @param qualifiers  the qualifiers of the bean
     * @param scope       the scope of the bean
     * @param stereotypes the bean's stereotypes
     * @param types       the types of the bean
     * @param alternative whether the bean is an alternative
     */
    public ImmutableBeanWrapper(Bean<T> bean,
                                String name,
                                Set<Annotation> qualifiers,
                                Class<? extends Annotation> scope,
                                Set<Class<? extends Annotation>> stereotypes,
                                Set<Type> types,
                                boolean alternative,
                                boolean nullable,
                                String toString)
    {
        super(bean.getBeanClass(), name, qualifiers, scope, stereotypes,
            types, alternative, nullable, bean.getInjectionPoints(), toString);

        this.wrapped = bean;
    }

    @Override
    public T create(CreationalContext<T> creationalContext)
    {
        return ReflectionUtils.cast(wrapped.create(creationalContext));
    }

    @Override
    public void destroy(T instance, CreationalContext<T> creationalContext)
    {
        wrapped.destroy(instance, creationalContext);
    }
}
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
    private final Collection<AnnotatedType<?>> messageBundleTypes = new HashSet<AnnotatedType<?>>();
    private Boolean isActivated = null;

    @SuppressWarnings("UnusedDeclaration")
    protected void init(@Observes BeforeBeanDiscovery afterBeanDiscovery)
        initActivation();
    @SuppressWarnings("UnusedDeclaration")
    protected void detectInterfaces(@Observes ProcessAnnotatedType<?> event)
        if (!this.isActivated)
        {
            return;
        }

    @SuppressWarnings("UnusedDeclaration")
    protected void detectProducers(@Observes ProcessProducerMethod<Object, TypedMessageBundleProducer> event)
        if (!this.isActivated)
        {
            return;
        }

    //X TODO re-visit it
    @SuppressWarnings("UnusedDeclaration")
    protected void detectProducersInverted(@Observes ProcessProducerMethod<TypedMessageBundleProducer, Object> event)
        if (!this.isActivated)
        {
            return;
        }

    protected void captureProducers(AnnotatedMethod<?> method, Bean<?> bean)
    @SuppressWarnings("UnusedDeclaration")
    protected void installBeans(@Observes AfterBeanDiscovery event, BeanManager beanManager)
                                                       AnnotatedType<T> type, BeanManager beanManager)
    @SuppressWarnings("UnusedDeclaration")
    protected void cleanup(@Observes AfterDeploymentValidation event)
    protected void initActivation()
    {
        if (isActivated == null)
        {
            isActivated = ClassDeactivationUtils.isActivated(getClass());
        }
    }
import org.apache.deltaspike.core.api.message.Message;

    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable

                result = String.format(message.value(), args);
                result = MessageFormat.format(message.value(), args);
        return result;
import static org.apache.deltaspike.core.impl.util.ArraysUtils.asSet;
//X TODO update javadoc
    private final Bean<T> delegate;

     *
     * @param delegate    the delegate bean
     * @param beanManager current bean-manager
    NarrowingBeanBuilder(Bean<Object> delegate, BeanManager beanManager)
        this.delegate = (Bean<T>)delegate;
     *
     * @param type the type to read

     *
     *
     * @param types the type closure to use
     *
     * @param types the type closure to use
     *
     * @param type additional type to use
     *
     * @param types the additional types to use
     *
     * @param types the additional types to use
     *
     *
     * @param qualifiers the qualifiers to use
     *
     * @param qualifiers the qualifiers to use
     *
     * @param qualifier the additional qualifier to use
     *
     * @param qualifiers the additional qualifiers to use
     *
     * @param qualifiers the additional qualifiers to use
     *
     *
     * @param name the name of the bean to use or <code>null</code> if the bean
     *             should have no name
     *
     *
     * @param scope the scope to use
     *
     *
     * @param alternative <code>true</code> if the created bean should be an
     *                    alternative, otherwise <code>false</code>
     *
     *
     * @param stereotypes the stereotypes to use
     *
    public ImmutableBeanWrapper<T> create()
        return new ImmutableBeanWrapper<T>(delegate, name, qualifiers, scope,
     *
     *
     * @param toString the string to use
     *
     *
     * @param nullable <code>true</code> if the created bean should be nullable,
     *                 otherwise <code>false</code>
     *
     *
     * @param passivationCapable <code>true</code> if the created bean should be passivation
     *                           capable, otherwise <code>false</code>
     *
     *
     * @param id the id to use
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/message/ProxyUtils.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.core.impl.message;

import org.apache.deltaspike.core.util.ClassUtils;

import javax.enterprise.inject.Typed;
import java.lang.reflect.Proxy;

/**
 * A factory class to produce message bundle implementations.
 */
@Typed()
abstract class ProxyUtils
{
    private ProxyUtils()
    {
        // prevent instantiation
    }

    /**
     * @param type the bundle type class
     * @param <T>  the bundle type
     * @return the bundle
     */
    static <T> T createMessageBundleProxy(Class<T> type)
    {
        return type.cast(Proxy.newProxyInstance(
            ClassUtils.getClassLoader(null), new Class<?>[]{type}, new MessageBundleInvocationHandler()));
    }
}
import static org.apache.deltaspike.core.impl.message.ProxyUtils.createMessageBundleProxy;
    @SuppressWarnings("UnusedDeclaration")
        return createMessageBundleProxy(getRawType(injectionPoint.getType()));
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/util/ArraysUtils.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.core.impl.util;

import javax.enterprise.inject.Typed;
import java.util.HashSet;
import java.util.Set;

/**
 * A collection of utilities for working with Arrays that goes beyond that in
 * the JDK.
 */
@Typed()
public abstract class ArraysUtils
{
    private ArraysUtils()
    {
        // prevent instantiation
    }

    /**
     * Create a set from an array. If the array contains duplicate objects, the
     * last object in the array will be placed in resultant set.
     * 
     * @param <T>
     *            the type of the objects in the set
     * @param array
     *            the array from which to create the set
     * @return the created sets
     */
    public static <T> Set<T> asSet(T... array)
    {
        Set<T> result = new HashSet<T>();
        for (T a : array)
        {
            result.add(a);
        }
        return result;
    }
}
public interface BirdMessages
{
    @Message("Spotted %s jays")
    String numberOfJaysSpotted(int number);
public class Jay
{
    @Inject
    @MessageBundle
    private BirdMessages messages;
    String getMessage()
    {
        return messages.numberOfJaysSpotted(8);
    }
     * @param toString        the string which should be returned by #{@link #toString()}
            //noinspection unchecked
     * @param nullable    true if the bean is nullable
     * @param toString    the string which should be returned by #{@link #toString()}
import java.util.Collections;
 * A collection of utilities for working with Arrays
     *
     * @param <T>   the type of the objects in the set
     * @param array the array from which to create the set
        Collections.addAll(result, array);
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/message/LocaleResolver.java
package org.apache.deltaspike.core.api.message;
import java.io.Serializable;
import java.util.Locale;

/**
 * Implementations have to provide the current locale
 */
public interface LocaleResolver extends Serializable
    /**
     * @return the current locale
     */
    Locale getLocale();
}
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/message/MessageResolver.java
package org.apache.deltaspike.core.api.message;
import java.io.Serializable;
/**
 * Implementations have to resolve the text stored for a given key in the message-source they are aware of
 */
public interface MessageResolver extends Serializable
    String MISSING_RESOURCE_MARKER = "???";

    /**
     * @param messageDescriptor the message key (or in-lined text) of the current message
     * @return the final but not interpolated message text
     */
    String getMessage(String messageDescriptor);
import org.apache.deltaspike.core.util.PropertyFileUtils;
        try
            Enumeration<URL> propertyFileUrls = PropertyFileUtils.resolvePropertyFiles(PROPERTY_FILE_NAME);
import org.apache.deltaspike.core.util.PropertyFileUtils;

        properties = PropertyFileUtils.loadProperties(propertyFileUrl);
    protected void installMessageBundleProducerBeans(@Observes AfterBeanDiscovery event, BeanManager beanManager)
            event.addBean(createMessageBundleBean(bundleProducerBean, type, beanManager));
                                                       AnnotatedType<T> annotatedType,
                                                       BeanManager beanManager)
                .readFromType(annotatedType)
                //X TODO re-visit type.getBaseType() in combination with #addQualifier
                .types(annotatedType.getJavaClass(), Object.class)
                .create();
import org.apache.deltaspike.core.api.literal.MessageContextConfigLiteral;
import org.apache.deltaspike.core.api.message.LocaleResolver;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import org.apache.deltaspike.core.api.message.MessageResolver;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.util.ClassUtils;
import java.util.Locale;

        //X TODO discuss use-cases for a deeper lookup and qualifier support
        MessageContextConfig messageContextConfig =
            method.getDeclaringClass().getAnnotation(MessageContextConfig.class);

        if (messageContextConfig == null)
            messageContextConfig = new MessageContextConfigLiteral();

        String messageTemplate;

        if (!MessageResolver.class.equals(messageContextConfig.messageResolver()))
        {
            Class<? extends MessageResolver> messageResolverClass =
                    ClassUtils.tryToLoadClassForName(messageContextConfig.messageResolver().getName());

            MessageResolver messageResolver = BeanProvider.getContextualReference(messageResolverClass);

            messageTemplate = messageResolver.getMessage(message.value());
        }
        else 
        {
            Class<? extends LocaleResolver> localeResolverClass =
                    ClassUtils.tryToLoadClassForName(messageContextConfig.localeResolver().getName());

            Locale resolvedLocale = Locale.getDefault();

            if (!LocaleResolver.class.equals(localeResolverClass))
            {
                LocaleResolver localeResolver = BeanProvider.getContextualReference(localeResolverClass);

                resolvedLocale = localeResolver.getLocale();
            }

            String messageBundleName = method.getDeclaringClass().getName();
            messageTemplate = new DefaultMessageResolver(messageBundleName, resolvedLocale).getMessage(message.value());
        }

        Class<? extends MessageInterpolator> messageInterpolatorClass =
                ClassUtils.tryToLoadClassForName(messageContextConfig.messageInterpolator().getName());

        String result = messageTemplate;

        if (!MessageInterpolator.class.equals(messageInterpolatorClass))
        {
            MessageInterpolator messageInterpolator = BeanProvider.getContextualReference(messageInterpolatorClass);
            result = messageInterpolator.interpolate(messageTemplate, args);
        }

    private TestMessages messages;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/message/SimpleMessage.java
public interface SimpleMessage
    @Message("Welcome to DeltaSpike")
    String welcomeToDeltaSpike();
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/annotation/ConfigProperty.java
package org.apache.deltaspike.core.api.config.annotation;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exclude/annotation/Exclude.java
package org.apache.deltaspike.core.api.exclude.annotation;
 * {@link org.apache.deltaspike.core.api.exclude.annotation.Exclude#onExpression()}
import org.apache.deltaspike.core.api.message.annotation.MessageBundle;
import org.apache.deltaspike.core.api.message.annotation.MessageContextConfig;
 * Literal for {@link org.apache.deltaspike.core.api.message.annotation.MessageContextConfig}
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/message/annotation/Message.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.core.api.message.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Target(METHOD)
@Retention(RUNTIME)
@Documented
public @interface Message
{
    /**
     * The default format string of this message.
     *
     * @return the format string
     */
    String value();
}
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/message/annotation/MessageBundle.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.core.api.message.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Target({ TYPE, METHOD, PARAMETER, FIELD })
@Retention(RUNTIME)
@Documented
public @interface MessageBundle
{
}
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/message/annotation/MessageContextConfig.java
package org.apache.deltaspike.core.api.message.annotation;

import org.apache.deltaspike.core.api.message.LocaleResolver;
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import org.apache.deltaspike.core.api.message.MessageResolver;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
 * Adds support for {@link org.apache.deltaspike.core.api.config.annotation.ConfigProperty}
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
 * {@link org.apache.deltaspike.core.api.exclude.annotation.Exclude} annotations.</p>
 * <p>Further details see {@link org.apache.deltaspike.core.api.exclude.annotation.Exclude}</p>
import org.apache.deltaspike.core.api.message.annotation.MessageBundle;
import org.apache.deltaspike.core.api.message.annotation.Message;
import org.apache.deltaspike.core.api.message.annotation.MessageContextConfig;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.message.annotation.Message;
import org.apache.deltaspike.core.api.message.annotation.Message;
import org.apache.deltaspike.core.api.message.annotation.MessageBundle;
import org.apache.deltaspike.core.api.message.annotation.MessageBundle;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/message/Message.java
package org.apache.deltaspike.core.api.message;
/**
 * Basic interface for all message-types
 */
public interface Message
     * @return the message key (or inline-text) of the current message
    String getMessageTemplate();

    /**
     * @return all named and numbered arguments
     */
    Object[] getArguments();

    /**
     * @param arguments 1-n new arguments for the current message
     * @return the current instance
     */
    Message addArgument(Object... arguments);
     * @param messageTemplate the message key (or in-lined text) of the current message
    String getMessage(String messageTemplate);
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/message/annotation/MessageTemplate.java
public @interface MessageTemplate
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/message/DefaultLocaleResolver.java
package org.apache.deltaspike.core.impl.message;
import org.apache.deltaspike.core.api.message.LocaleResolver;
import javax.enterprise.inject.Typed;
import java.io.Serializable;
import java.util.Locale;

/**
 * {@inheritDoc}
 */
@Typed()
class DefaultLocaleResolver implements LocaleResolver, Serializable
    private static final long serialVersionUID = 2075618472090834156L;

    @Override
    public Locale getLocale()
    {
        return Locale.getDefault();
    }
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/message/DefaultMessageInterpolator.java
package org.apache.deltaspike.core.impl.message;
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import javax.enterprise.inject.Typed;
import java.io.Serializable;
/**
 * {@inheritDoc}
 */
@Typed()
class DefaultMessageInterpolator implements MessageInterpolator, Serializable
    private static final long serialVersionUID = -8854087197813424812L;

    @Override
    public String interpolate(String messageTemplate, Object... arguments)
    {
        return messageTemplate;
    }
    public String getMessage(String messageTemplate)
        if (this.messageBundle != null && messageTemplate != null &&
            messageTemplate.startsWith("{") && messageTemplate.endsWith("}"))
                return this.messageBundle.getString(messageTemplate.substring(1, messageTemplate.length() - 1));
                return MISSING_RESOURCE_MARKER  messageTemplate  MISSING_RESOURCE_MARKER;
        return messageTemplate;
import java.lang.reflect.Method;
import org.apache.deltaspike.core.api.message.Message;
import org.apache.deltaspike.core.api.message.MessageContext;
import org.apache.deltaspike.core.api.message.annotation.MessageTemplate;

            validateMessageBundle(type.getJavaClass());

    private void validateMessageBundle(Class<?> currentClass)
    {
        for (Method currentMethod : currentClass.getDeclaredMethods())
        {
            if (!currentMethod.isAnnotationPresent(MessageTemplate.class))
            {
                continue;
            }
            
            if (String.class.isAssignableFrom(currentMethod.getReturnType()))
            {
                continue;
            }

            if (Message.class.isAssignableFrom(currentMethod.getReturnType()))
            {
                validateMessageContextAwareMethod(currentMethod);
            }
            else
            {
                throw new IllegalStateException(
                        currentMethod.getReturnType().getName()  " isn't supported. Details: " 
                        currentMethod.getDeclaringClass().getName()  "#"  currentMethod.getName() 
                        " only "  String.class.getName()  " or "  Message.class.getName());
            }
        }
    }

    private void validateMessageContextAwareMethod(Method currentMethod)
    {
        for (Class currentParameterType : currentMethod.getParameterTypes())
        {
            if (MessageContext.class.isAssignableFrom(currentParameterType))
            {
                return;
            }
        }

        throw new IllegalStateException("No "  MessageContext.class.getName()  " parameter found at: " 
                currentMethod.getDeclaringClass().getName()  "#"  currentMethod.getName() 
                ". That is required for return-type "  Message.class.getName());
    }

import org.apache.deltaspike.core.api.message.MessageContext;
import org.apache.deltaspike.core.api.message.annotation.MessageContextConfig;
import org.apache.deltaspike.core.api.message.annotation.MessageTemplate;
import java.util.ArrayList;
import java.util.List;
        final MessageTemplate messageTemplate = method.getAnnotation(MessageTemplate.class);
        if (messageTemplate == null)
            // nothing to do... TODO discuss it
        MessageContext messageContext = null;
        List<Object> arguments = null;

        if (args != null && args.length > 0)
            arguments = new ArrayList<Object>(args.length);
            for (Object arg : args)
                if (MessageContext.class.isAssignableFrom(arg.getClass()))
                {
                    messageContext = (MessageContext)arg;
                    continue;
                }
                arguments.add(arg);
            }
        }

        if (messageContext == null)
        {
            //X TODO discuss use-cases for a deeper lookup and qualifier support
            MessageContextConfig messageContextConfig =
                method.getDeclaringClass().getAnnotation(MessageContextConfig.class);

            if (messageContextConfig == null)
            {
                messageContextConfig = new MessageContextConfigLiteral();
            String resolvedMessageTemplate;

            if (!MessageResolver.class.equals(messageContextConfig.messageResolver()))
            {
                Class<? extends MessageResolver> messageResolverClass =
                        ClassUtils.tryToLoadClassForName(messageContextConfig.messageResolver().getName());

                MessageResolver messageResolver = BeanProvider.getContextualReference(messageResolverClass);

                resolvedMessageTemplate = messageResolver.getMessage(messageTemplate.value());
            }
            else
            {
                Class<? extends LocaleResolver> localeResolverClass =
                        ClassUtils.tryToLoadClassForName(messageContextConfig.localeResolver().getName());

                Locale resolvedLocale = Locale.getDefault();

                if (!LocaleResolver.class.equals(localeResolverClass))
                {
                    LocaleResolver localeResolver = BeanProvider.getContextualReference(localeResolverClass);

                    resolvedLocale = localeResolver.getLocale();
                }

                String messageBundleName = method.getDeclaringClass().getName();
                resolvedMessageTemplate = new DefaultMessageResolver(messageBundleName, resolvedLocale)
                    .getMessage(messageTemplate.value());
            }

            Class<? extends MessageInterpolator> messageInterpolatorClass =
                    ClassUtils.tryToLoadClassForName(messageContextConfig.messageInterpolator().getName());

            String result = resolvedMessageTemplate;

            if (!MessageInterpolator.class.equals(messageInterpolatorClass))
            {
                MessageInterpolator messageInterpolator = BeanProvider.getContextualReference(messageInterpolatorClass);
                result = messageInterpolator.interpolate(resolvedMessageTemplate, args);
            }

            return result;
        else
            if (String.class.isAssignableFrom(method.getReturnType()))
            {
                return messageContext.message().text(messageTemplate.value()).argument(arguments.toArray()).toText();
            }
            return messageContext.message().text(messageTemplate.value()).argument(arguments.toArray()).create();
        }
import org.apache.deltaspike.core.api.message.Message;
import org.apache.deltaspike.core.api.message.MessageContext;
import org.apache.deltaspike.core.api.message.annotation.MessageTemplate;
    @MessageTemplate("Welcome to DeltaSpike")

    @MessageTemplate("Welcome to %s")
    Message welcomeTo(MessageContext messageContext, String name);
    @Nonbinding

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
    int ordinal() default 0;
// CHECKSTYLE:OFF
// CHECKSTYLE:ON
     * @param stack           Information about the current exception and cause chain.
     * @throws IllegalArgumentException if stack is null
    public CaughtException(final ExceptionStack stack, final boolean beforeTraversal, final boolean handled)
        if (stack == null)
            throw new IllegalArgumentException("null is not valid for stack");
        this.exception = (T) stack.getCurrent();
        this.exceptionStack = stack;
    /**
     * Internal only
     */
    public boolean isUnmute()
    /**
     * Internal only
     */
    public ExceptionHandlingFlow getFlow()
    /**
     * Internal only.
     *
     * @return
     */
    public Throwable getThrowNewException()
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@SuppressWarnings("CdiManagedBeanInconsistencyInspection")
        // CHECKSTYLE:OFF
        // CHECKSTYLE:ON
        this.causes = this.createThrowableCollection(exceptionStackItems);
        }
        else
    private Collection<ExceptionStackItem> createExceptionStackFrom(Collection<Throwable> throwables)
    private Collection<Throwable> createThrowableCollection(final Collection<ExceptionStackItem> exceptionStackItems)
        // allow current
        final Deque<Throwable> returningCollection = new ArrayDeque<Throwable>(exceptionStackItems.size()  1);
        return Collections.unmodifiableCollection(this.createThrowableCollection(this.remaining));
    /**
     * Internal only.
     *
     * @param elements new stack.
     */
    public void setCauseElements(Collection<Throwable> elements)
        this.exceptionStackItems = new ArrayDeque<ExceptionStackItem>(this.createExceptionStackFrom(elements));
        this.init();
    }

    /**
     * Internal only.
     */
    public void skipCause()
    {
    private final Throwable throwable;
    private final StackTraceElement[] stackTraceElements;
    /**
     * Internal only.
     *
     * @param handled new value
     */
    public void setHandled(boolean handled)
     * Flag indicating this handler should be invoked during the before traversal.
     */
    boolean isBefore();

    /**
     * Basic {@link Object#equals(Object)} but must use all of the get methods from this interface to
     * maintain compatibility.
import javax.enterprise.inject.spi.BeanManager;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Collection;
import java.util.Set;

 * Injectable storage to support programmatic registration and lookup of {@link HandlerMethod} instances.

    /**
     * Obtains the applicable handlers for the given type or super type of the given type to order the handlers.
     *
     * @param exceptionClass    Type of exception to narrow handler list
     * @param bm                active BeanManager
     * @param handlerQualifiers additional handlerQualifiers to limit handlers
     * @param isBefore          traversal limiter
     * @return An order collection of handlers for the given type.
     */
    Collection<HandlerMethod<? extends Throwable>> getHandlersForException(Type exceptionClass, BeanManager bm,
                                                                           Set<Annotation> handlerQualifiers,
                                                                           boolean isBefore);
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
    int ordinal() default 0; //TODO discuss Precedence
 * Comparator to sort exception handlers according qualifier
 * ({@link org.apache.deltaspike.core.api.exception.control.BeforeHandles} first), ordinal
@SuppressWarnings({ "MethodWithMoreThanThreeNegations" })
    @Override
import org.apache.deltaspike.core.impl.exception.control.extension.CatchExtension;
    // CHECKSTYLE:OFF
    // CHECKSTYLE:ON
    public void executeHandlers(@Observes @Any ExceptionToCatch eventException, final BeanManager bm) throws Throwable
        final HandlerMethodStorage handlerMethodStorage = CatchExtension.createStorage();

        inbound_cause:
                                break;
                            default:
                                throw new IllegalStateException("Unexpected enum type "  breadthFirstEvent.getFlow());
                                bm, eventException.getQualifiers(), false);
                                break;
                            default:
                                throw new IllegalStateException("Unexpected enum type "  depthFirstEvent.getFlow());
        }
        finally
     * Sole Constructor.
     *
     * @param method found handler
     * @param bm     active BeanManager
     * @throws IllegalArgumentException if method is null, has no params or first param is not annotated with
     *                                  {@link Handles} or {@link BeforeHandles}
     */
    public HandlerMethodImpl(final AnnotatedMethod<?> method, final BeanManager bm)
    {
        if (!HandlerMethodImpl.isHandler(method))
        {
            throw new IllegalArgumentException(MessageFormat.format("{0} is not a valid handler", method));
        }

        this.beanManager = bm;

        final Set<Annotation> tmpQualifiers = new HashSet<Annotation>();

        this.handler = method;
        this.javaMethod = method.getJavaMember();

        this.handlerParameter = findHandlerParameter(method);

        if (!this.handlerParameter.isAnnotationPresent(Handles.class)
                && !this.handlerParameter.isAnnotationPresent(BeforeHandles.class))
        {
            throw new IllegalArgumentException("Method is not annotated with @Handles or @BeforeHandles");
        }

        this.before = this.handlerParameter.getAnnotation(BeforeHandles.class) != null;
        this.ordinal = this.handlerParameter.getAnnotation(Handles.class).ordinal();
        tmpQualifiers.addAll(BeanUtils.getQualifiers(bm, this.handlerParameter.getAnnotations()));

        if (tmpQualifiers.isEmpty())
        {
            tmpQualifiers.add(new AnyLiteral());
        }

        this.qualifiers = tmpQualifiers;
        this.beanClass = method.getJavaMember().getDeclaringClass();
        this.exceptionType = ((ParameterizedType) this.handlerParameter.getBaseType()).getActualTypeArguments()[0];
        this.injectionPoints = new HashSet<InjectionPoint>(method.getParameters().size() - 1);

        for (AnnotatedParameter<?> param : method.getParameters())
        {
            if (!param.equals(this.handlerParameter))
            {
                this.injectionPoints.add(new ImmutableInjectionPoint(param, bm, this.getBean(bm), false, false));
            }
        }
    }

    /**
    @Override
    @Override
    @Override
        }
        finally
    private <X> InjectableMethod<X> createInjectableMethod(AnnotatedMethod<X> handlerMethod,
                                                           Bean<?> bean, BeanManager manager)
    /**
     * {@inheritDoc}
     */
    @Override
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/exception/control/HandlerMethodStorage.java
package org.apache.deltaspike.core.impl.exception.control;

import org.apache.deltaspike.core.api.exception.control.HandlerMethod;
 * Injectable storage to support programmatic registration and lookup of
 * {@link org.apache.deltaspike.core.api.exception.control.HandlerMethod} instances.
    private final CaughtException<?> event;
    private final BeanManager bm;
    private final Bean<?> declaringBean;
    private final HandlerMethodImpl<?> handlerMethod;
    @Override
        }
        finally
import org.apache.deltaspike.core.impl.exception.control.HandlerMethodStorage;
import org.apache.deltaspike.core.impl.exception.control.HandlerMethodStorageImpl;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
@SuppressWarnings({ "unchecked", "CdiManagedBeanInconsistencyInspection" })
public class CatchExtension implements Extension, Deactivatable
    private Logger log = Logger.getLogger(CatchExtension.class.toString());
        CatchExtension.allHandlers = new HashMap<Type, Collection<HandlerMethod<? extends Throwable>>>();
     * @throws TypeNotPresentException if any of the actual type arguments refers to a non-existent type declaration
     *                                 when trying to obtain the actual type arguments from a {@link ParameterizedType}
     *                                 if any of the actual type parameters refer to a parameterized type that cannot
     *                                 be instantiated for any reason when trying to obtain the actual type arguments
     *                                 from a {@link ParameterizedType}
        if (!ClassDeactivationUtils.isActivated(CatchExtension.class))
        {
            return;
        }

                    final Class<? extends Throwable> exceptionType = (Class<? extends Throwable>) ((ParameterizedType)
                            param.getBaseType()).getActualTypeArguments()[0];
        if (!ClassDeactivationUtils.isActivated(CatchExtension.class))
        {
            return;
        }

        for (Map.Entry<? super Type, Collection<HandlerMethod<? extends Throwable>>> entry : allHandlers.entrySet())
                    }
                    catch (InjectionException e)
    public static HandlerMethodStorage createStorage()
        return new HandlerMethodStorageImpl(Collections.unmodifiableMap(CatchExtension.allHandlers));
    private <T extends Throwable> void registerHandlerMethod(HandlerMethod<T> handlerMethod)
@Target(ElementType.PARAMETER)
        return this.markedHandled;
    }

    public boolean isBeforeTraversal()
    {
        return beforeTraversal;
@SuppressWarnings({"MethodWithMoreThanThreeNegations"})
        if (!isBefore)
            inbound_cause:

        if (this.before)
        {
            this.ordinal = this.handlerParameter.getAnnotation(BeforeHandles.class).ordinal();
        }
        else
        {
            this.ordinal = this.handlerParameter.getAnnotation(Handles.class).ordinal();
        }

                    if (handler.isBefore() && isBefore)
                    {
                        if (handler.getQualifiers().contains(new AnyLiteral()))
                        {
                            returningHandlers.add(handler);
                        }
                        else
                        {
                            if (!handlerQualifiers.isEmpty() && this.containsAny(handler.getQualifiers(),
                                    handlerQualifiers))
                            {
                                returningHandlers.add(handler);
                            }
                        }
                    }
                    else if (!handler.isBefore() && !isBefore)
     * <p>Get the Contextual Reference for the given bean
     *
     * @param type the type of the bean in question
     * @param bean bean-definition for the contextual-reference
     * @param <T> target type
     * @return the resolved Contextual Reference
     */
    public static <T> T getContextualReference(Class<T> type, Bean<T> bean)
    {
        return getContextualReference(type, getBeanManager(), bean);
    }

    private static <T> T getContextualReference(Class<T> type, BeanManager beanManager, Bean<?> bean)
    {
        //noinspection unchecked
        return getContextualReference(type, beanManager, new HashSet<Bean<?>>((Collection) Arrays.asList(bean)));
    }

    /**

        Set<Bean<T>> beans = getBeanDefinitions(type, optional, includeDefaultScopedBeans, beanManager);

        List<T> result = new ArrayList<T>(beans.size());

        for (Bean<?> bean : beans)
        {
            //noinspection unchecked
            result.add(getContextualReference(type, beanManager, bean));
        }
        return result;
    }

    /**
     * <p>Get a set of {@link Bean} definitions by it's type independent of the qualifier.
     *
     * @param type the type of the bean in question
     * @param optional if <code>true</code> it will return an empty set if no bean could be found or created.
     *                 Otherwise it will throw an {@code IllegalStateException}
     * @param includeDefaultScopedBeans specifies if dependent scoped beans should be included in the in the result
     * @param <T> target type
     * @return the resolved set of {@link Bean} definitions or an empty-set if optional is true
     */
    public static <T> Set<Bean<T>> getBeanDefinitions(Class<T> type,
                                                      boolean optional,
                                                      boolean includeDefaultScopedBeans)
    {
        BeanManager beanManager = getBeanManager();
        
        return getBeanDefinitions(type, optional, includeDefaultScopedBeans, beanManager);
    }
    
    private static <T> Set<Bean<T>> getBeanDefinitions(Class<T> type,
                                                       boolean optional,
                                                       boolean includeDefaultScopedBeans,
                                                       BeanManager beanManager)
    {
                return Collections.emptySet();
        
        Set<Bean<T>> result = new HashSet<Bean<T>>();
        
            result.add((Bean<T>) bean);
        
    
@SuppressWarnings({ "unchecked", "CdiManagedBeanInconsistencyInspection" })
//X TODO discuss an interface to avoid internal methods in the api
    public ExceptionHandlingFlow getCurrentExceptionHandlingFlow()
    private static final long serialVersionUID = -6069790756478700680L;

            e = e.getCause();
        while (e != null);
    boolean isBeforeHandler();
    @Override
@SuppressWarnings({ "MethodWithMoreThanThreeNegations" })
                    lhs.isBeforeHandler());
import org.apache.deltaspike.core.api.provider.BeanProvider;
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
@SuppressWarnings("UnusedDeclaration")
public class ExceptionHandlerDispatch
    private static final Logger LOG = Logger.getLogger(ExceptionHandlerDispatch.class.getName());
     * @param exceptionEvent exception to be invoked
     * @param beanManager             active bean manager
    @SuppressWarnings({ "unchecked", "MethodWithMultipleLoops", "ThrowableResultOfMethodCallIgnored" })
    public void executeHandlers(@Observes @Any ExceptionToCatch exceptionEvent,
                                final BeanManager beanManager) throws Throwable
        LOG.entering(ExceptionHandlerDispatch.class.getName(), "executeHandlers", exceptionEvent.getException());
        CreationalContext<Object> creationalContext = null;
        final HandlerMethodStorage handlerMethodStorage =
            BeanProvider.getContextualReference(HandlerMethodStorage.class);
            creationalContext = beanManager.createCreationalContext(null);
            final ExceptionStack stack = new ExceptionStack(exceptionEvent.getException());
            beanManager.fireEvent(stack); // Allow for modifying the exception stack
        inbound_cause: //indentation needed by the current checkstyle rules
                                beanManager, exceptionEvent.getQualifiers(), true));
                        LOG.fine(String.format("Notifying handler %s", handler));
                                exceptionEvent.isHandled());

                        LOG.fine(String.format("Handler %s returned status %s", handler,
                                breadthFirstEvent.getCurrentExceptionHandlingFlow().name()));
                        switch (breadthFirstEvent.getCurrentExceptionHandlingFlow())
                                exceptionEvent.setHandled(true);
                                exceptionEvent.setHandled(true);
                                exceptionEvent.setHandled(true);
                                throwException = exceptionEvent.getException();
                                throw new IllegalStateException(
                                    "Unexpected enum type "  breadthFirstEvent.getCurrentExceptionHandlingFlow());
                                beanManager, exceptionEvent.getQualifiers(), false);
                        LOG.fine(String.format("Notifying handler %s", handler));
                                exceptionEvent.isHandled());
                        LOG.fine(String.format("Handler %s returned status %s", handler,
                                depthFirstEvent.getCurrentExceptionHandlingFlow().name()));
                        switch (depthFirstEvent.getCurrentExceptionHandlingFlow())
                                exceptionEvent.setHandled(true);
                                exceptionEvent.setHandled(true);
                                exceptionEvent.setHandled(true);
                                throwException = exceptionEvent.getException();
                                throw new IllegalStateException(
                                    "Unexpected enum type "  depthFirstEvent.getCurrentExceptionHandlingFlow());
                stack.skipCause();
            if (!exceptionEvent.isHandled() && throwException == null)
                LOG.warning(String.format("No handlers found for exception %s", exceptionEvent.getException()));
                throw exceptionEvent.getException();
            if (creationalContext != null)
                creationalContext.release();
            LOG.exiting(ExceptionHandlerDispatch.class.getName(), "executeHandlers", exceptionEvent.getException());
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import javax.enterprise.inject.Typed;
@Typed()
    private final Class beanClass;
    private Set<InjectionPoint> injectionPoints;
        //validation is done by the extension
    public Bean<?> getBean()
            initBean();
    private synchronized void initBean()
    {
        if (this.bean != null)
        {
            return;
        }

        @SuppressWarnings("unchecked")
        Set<Bean<?>> beans = BeanProvider.getBeanDefinitions(this.beanClass, false, true);

        if (beans.size() > 1)
        {
            //TODO improve exception
            throw new IllegalStateException(beans.size()  " types found - base type: "  this.beanClass.getName());
        }
        this.bean = beans.iterator().next();
    }

            ctx = getBeanManager().createCreationalContext(null);
            @SuppressWarnings("unchecked")
            Object handlerInstance = BeanProvider.getContextualReference(this.beanClass);
            InjectableMethod<?> im = createInjectableMethod(this.handler, this.getBean());
            im.invoke(handlerInstance, ctx, new OutboundParameterValueRedefiner(event, this));
    private <X> InjectableMethod<X> createInjectableMethod(AnnotatedMethod<X> handlerMethod, Bean<?> bean)
        return new InjectableMethod<X>(handlerMethod, bean, getBeanManager());
    public boolean isBeforeHandler()
        if (this.injectionPoints == null)
        {
            this.injectionPoints = new HashSet<InjectionPoint>(handler.getParameters().size() - 1);

            for (AnnotatedParameter<?> param : handler.getParameters())
            {
                if (!param.equals(this.handlerParameter))
                {
                    this.injectionPoints.add(
                        new ImmutableInjectionPoint(param, getBeanManager(), getBean(), false, false));
                }
            }

        }
    private BeanManager getBeanManager()
    {
        if (this.beanManager == null)
        {
            this.beanManager = BeanManagerProvider.getInstance().getBeanManager();
        }
        return this.beanManager;
    }

        //noinspection SimplifiableIfStatement
//X TODO move it to the spi package - otherwise there is no need for an interface
import javax.enterprise.inject.Typed;
@Typed()
class HandlerMethodStorageImpl implements HandlerMethodStorage
    HandlerMethodStorageImpl(Map<? super Type, Collection<HandlerMethod<? extends Throwable>>> allHandlers)
                    if (handler.isBeforeHandler() && isBefore)
                    else if (!handler.isBeforeHandler() && !isBefore)
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
class OutboundParameterValueRedefiner implements ParameterValueRedefiner
     * @param handlerMethod Handler method this redefiner is for
    OutboundParameterValueRedefiner(final CaughtException<?> event, final HandlerMethodImpl<?> handlerMethod)
        this.declaringBean = handlerMethod.getBean();
        this.handlerMethod = handlerMethod;
        CreationalContext<?> ctx = BeanManagerProvider.getInstance().getBeanManager()
            .createCreationalContext(this.declaringBean);
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import javax.enterprise.inject.spi.ProcessAnnotatedType;
    private static final Logger LOG = Logger.getLogger(CatchExtension.class.getName());
    //this map is application scoped by the def. of the cdi spec.
    //if it needs to be static a classloader key is needed  a cleanup in a BeforeShutdown observer
    private Map<? super Type, Collection<HandlerMethod<? extends Throwable>>> allHandlers
        = new HashMap<Type, Collection<HandlerMethod<? extends Throwable>>>();
    private Boolean isActivated = null;

    @SuppressWarnings("UnusedDeclaration")
    protected void init(@Observes BeforeBeanDiscovery afterBeanDiscovery)
        initActivation();
     * @param processAnnotatedType current annotated type-event
     * @param beanManager  Activated Bean Manager
     *                                 when trying to obtain the actual type arguments from a
     *                                 {@link java.lang.reflect.ParameterizedType}
     *                                 from a {@link java.lang.reflect.ParameterizedType}
    @SuppressWarnings("UnusedDeclaration")
    public <T> void findHandlers(@Observes final ProcessAnnotatedType processAnnotatedType,
                                 final BeanManager beanManager)
        if (!this.isActivated)
        if (processAnnotatedType.getAnnotatedType().getJavaClass().isAnnotationPresent(ExceptionHandler.class))
            final Set<AnnotatedMethod<? super T>> methods = processAnnotatedType.getAnnotatedType().getMethods();
                        //TODO discuss unified handling of definition errors
                        throw new IllegalStateException(
                            String.format("Handler method %s must not throw exceptions", method.getJavaMember()));
                    //beanManager won't be stored in the instance -> no issue with wls12c
                    registerHandlerMethod(new HandlerMethodImpl(method, beanManager));
     * @param afterDeploymentValidation Lifecycle event
     * @param beanManager  BeanManager instance
    @SuppressWarnings("UnusedDeclaration")
    public void verifyInjectionPoints(/*@Observes X TODO fails with OWB -> reactivate as soon as we have a workaround*/
                                      final AfterDeploymentValidation afterDeploymentValidation,
                                      final BeanManager beanManager)
        if (!this.isActivated)
                        beanManager.validate(ip);
                        afterDeploymentValidation.addDeploymentProblem(e);
    public Map<? super Type, Collection<HandlerMethod<? extends Throwable>>> getAllExceptionHandlers()
        return Collections.unmodifiableMap(allHandlers);
        LOG.fine(String.format("Adding handler %s to known handlers", handlerMethod));

        if (allHandlers.containsKey(handlerMethod.getExceptionType()))
            allHandlers.get(handlerMethod.getExceptionType()).add(handlerMethod);
            allHandlers.put(handlerMethod.getExceptionType(),
                new HashSet<HandlerMethod<? extends Throwable>>(Arrays.asList(handlerMethod)));
        }
    }

    public void initActivation()
    {
        if (isActivated == null)
        {
            isActivated = ClassDeactivationUtils.isActivated(getClass());
import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
    private boolean abortCalled = false;
    private boolean proceedCalled = false;

    public boolean isAbortCalled()
    {
        return abortCalled;
    }

    public boolean isProceedCalled()
    {
        return proceedCalled;
    }
import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
    private boolean abortCalled = false;
    private boolean proceedCalled = false;

    protected AbortingDepthHandler()
    {
    }

    public boolean isAbortCalled()
    {
        return abortCalled;
    }

    public boolean isProceedCalled()
    {
        return proceedCalled;
    }
import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
    private boolean exAscCalled = false;
    private boolean iaeAscCalled = false;
    private boolean npeDescCalled = false;
        exAscCalled = true;
        iaeAscCalled = true;
        npeDescCalled = true;

    public boolean isExAscCalled()
    {
        return exAscCalled;
    }

    public boolean isIaeAscCalled()
    {
        return iaeAscCalled;
    }

    public boolean isNpeDescCalled()
    {
        return npeDescCalled;
    }
import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
    private int breadthFirstNpeCalled = 0;
    private int breadthFirstNpeLowerPrecedenceCalled = 0;
    private int depthFirstNpeCalled = 0;
    private int depthFirstNpeHigherPrecedenceCalled = 0;
    public void npeInboundHandler(@BeforeHandles CaughtException<NullPointerException> event)
        breadthFirstNpeCalled;
        breadthFirstNpeLowerPrecedenceCalled;
        depthFirstNpeCalled;
        depthFirstNpeHigherPrecedenceCalled;

    public int getBreadthFirstNpeCalled()
    {
        return breadthFirstNpeCalled;
    }

    public int getBreadthFirstNpeLowerPrecedenceCalled()
    {
        return breadthFirstNpeLowerPrecedenceCalled;
    }

    public int getDepthFirstNpeCalled()
    {
        return depthFirstNpeCalled;
    }

    public int getDepthFirstNpeHigherPrecedenceCalled()
    {
        return depthFirstNpeHigherPrecedenceCalled;
    }
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
    private boolean outboundHandlerCalled = false;
    private int outboundHandlerTimesCalled = 0;
    private boolean protectedHandlerCalled = false;
    private int inboundHandlerTimesCalled = 0;
    private boolean beanmanagerInjected = false;
    private boolean locationDifferBeanmanagerInjected = false;
        outboundHandlerCalled = true;
        outboundHandlerTimesCalled;
        inboundHandlerTimesCalled;
            beanmanagerInjected = true;
        protectedHandlerCalled = true;
            locationDifferBeanmanagerInjected = true;

    public boolean isOutboundHandlerCalled()
    {
        return outboundHandlerCalled;
    }

    public int getOutboundHandlerTimesCalled()
    {
        return outboundHandlerTimesCalled;
    }

    public boolean isProtectedHandlerCalled()
    {
        return protectedHandlerCalled;
    }

    public void setOutboundHandlerTimesCalled(int outboundHandlerTimesCalled)
    {
        this.outboundHandlerTimesCalled = outboundHandlerTimesCalled;
    }

    public void setInboundHandlerTimesCalled(int inboundHandlerTimesCalled)
    {
        this.inboundHandlerTimesCalled = inboundHandlerTimesCalled;
    }

    public int getInboundHandlerTimesCalled()
    {
        return inboundHandlerTimesCalled;
    }

    public boolean isBeanmanagerInjected()
    {
        return beanmanagerInjected;
    }

    public boolean isLocationDifferBeanmanagerInjected()
    {
        return locationDifferBeanmanagerInjected;
    }
import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
    private int depthFirstNumberCalled = 0;
    private int breadthFirstNumberCalled = 0;
        depthFirstNumberCalled;
        breadthFirstNumberCalled;

    public int getDepthFirstNumberCalled()
    {
        return depthFirstNumberCalled;
    }

    public int getBreadthFirstNumberCalled()
    {
        return breadthFirstNumberCalled;
    }
import org.apache.deltaspike.core.api.provider.BeanProvider;
    protected HandlerMethodStorage createHandlerMethodStorage()
        //X TODO change it back to parameter injection after fixing the test-setup for ExcludeIntegrationTest
        CatchExtension catchExtension = BeanProvider.getContextualReference(CatchExtension.class);
import java.net.URI;
            final JavaArchive foundJar = ShrinkWrap.createFromZipFile(JavaArchive.class, new File(URI.create(jarUrlPath)));

            if (excludeIfPackageExists != null)
            {
                for (String excludePackage : excludeIfPackageExists)
                {
                    if (foundJar.contains(excludePackage.replaceAll("\\.", "\\/"))) {
                        return null;
                    }
                }
            }
            if (includeIfPackageExists != null)
            {
                for (String includePackage : includeIfPackageExists)
                {
                    if (foundJar.contains(includePackage.replaceAll("\\.", "\\/")))
                    {
                        return foundJar;
                    }
                }
            }
            return null; // couldn't find any jar
import java.net.URI;
            final JavaArchive foundJar = ShrinkWrap.createFromZipFile(JavaArchive.class, new File(URI.create(jarUrlPath)));

            if (excludeIfPackageExists != null)
            {
                for (String excludePackage : excludeIfPackageExists)
                {
                    if (foundJar.contains(excludePackage.replaceAll("\\.", "\\/"))) {
                        return null;
                    }
                }
            }
            if (includeIfPackageExists != null)
            {
                for (String includePackage : includeIfPackageExists)
                {
                    if (foundJar.contains(includePackage.replaceAll("\\.", "\\/")))
                    {
                        return foundJar;
                    }
                }
            }
            return null; // couldn't find any jar
import org.apache.deltaspike.core.impl.exception.control.extension.ExceptionControlExtension;
        ExceptionControlExtension exceptionControlExtension =
                BeanProvider.getContextualReference(ExceptionControlExtension.class);

        return new HandlerMethodStorageImpl(exceptionControlExtension.getAllExceptionHandlers());
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/exception/control/extension/ExceptionControlExtension.java
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.Decorator;
import javax.enterprise.inject.spi.Interceptor;
import javax.enterprise.inject.spi.ProcessBean;
public class ExceptionControlExtension implements Extension, Deactivatable
    private static final Logger LOG = Logger.getLogger(ExceptionControlExtension.class.getName());
     * @param processBean current {@link AnnotatedType}
    public <T> void findHandlers(@Observes final ProcessBean<?> processBean, final BeanManager beanManager)
        if (processBean.getBean() instanceof Interceptor || processBean.getBean() instanceof Decorator ||
                !(processBean.getAnnotated() instanceof AnnotatedType))
            return;
        }

        AnnotatedType annotatedType = (AnnotatedType)processBean.getAnnotated();

        if (annotatedType.getJavaClass().isAnnotationPresent(ExceptionHandler.class))
        {
            final Set<AnnotatedMethod<? super T>> methods = annotatedType.getMethods();
                        processBean.addDefinitionError(new IllegalArgumentException(
                            String.format("Handler method %s must not throw exceptions", method.getJavaMember())));
    void notify(ExceptionEvent<T> event);
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/exception/control/ExceptionEventImpl.java
package org.apache.deltaspike.core.impl.exception.control;

import org.apache.deltaspike.core.api.exception.control.ExceptionHandlingFlow;
import org.apache.deltaspike.core.api.exception.control.ExceptionStack;
import org.apache.deltaspike.core.spi.exception.control.IntrospectiveExceptionEvent;
@SuppressWarnings({"unchecked", "CdiManagedBeanInconsistencyInspection"})
public class ExceptionEventImpl<T extends Throwable> implements IntrospectiveExceptionEvent<T>
    public ExceptionEventImpl(final ExceptionStack stack, final boolean beforeTraversal, final boolean handled)
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
     * @param beanManager    active bean manager
    @SuppressWarnings({"unchecked", "MethodWithMultipleLoops", "ThrowableResultOfMethodCallIgnored"})
                BeanProvider.getContextualReference(HandlerMethodStorage.class);
            inbound_cause:
            //indentation needed by the current checkstyle rules
                        final ExceptionEventImpl breadthFirstEvent = new ExceptionEventImpl(stack, true,
                                        "Unexpected enum type "  breadthFirstEvent.getCurrentExceptionHandlingFlow());
                        final ExceptionEventImpl depthFirstEvent = new ExceptionEventImpl(stack, false,
                                        "Unexpected enum type "  depthFirstEvent.getCurrentExceptionHandlingFlow());
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    public void notify(final ExceptionEvent<T> event)
                            new ImmutableInjectionPoint(param, getBeanManager(), getBean(), false, false));
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
 * Redefiner allowing to inject a non contextual instance of {@link ExceptionEventImpl} into the first parameter. This
    private final ExceptionEvent<?> event;
     * @param event         instance of ExceptionEventImpl to inject.
    OutboundParameterValueRedefiner(final ExceptionEvent<?> event, final HandlerMethodImpl<?> handlerMethod)
                .createCreationalContext(this.declaringBean);
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    public void abortHandler(@BeforeHandles ExceptionEvent<Exception> event)
    public void proceedHandler(@Handles ExceptionEvent<NullPointerException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    public void abortHandler(@Handles ExceptionEvent<Exception> event)
    public void proceedHandler(@Handles ExceptionEvent<Throwable> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    public void exHandler(@Handles ExceptionEvent<Exception> event)
    public void npeHandler(@Handles ExceptionEvent<IllegalArgumentException> event)
    public void npeDescHandler(@BeforeHandles ExceptionEvent<NullPointerException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    public void npeInboundHandler(@BeforeHandles ExceptionEvent<NullPointerException> event)
            @BeforeHandles(ordinal = -50) ExceptionEvent<NullPointerException> event)
    public void npeOutboundHandler(@Handles ExceptionEvent<NullPointerException> event)
    public void npeHigherPrecedenceOutboundHandler(@Handles(ordinal = -10) ExceptionEvent<NullPointerException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    public void rethrow(@Handles ExceptionEvent<NullPointerException> event)
            @BeforeHandles ExceptionEvent<IllegalArgumentException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    public void rethrow(@Handles ExceptionEvent<NullPointerException> event)
            @BeforeHandles ExceptionEvent<IllegalArgumentException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    void handleException(int firstParam, @Handles ExceptionEvent<Exception> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    public void basicHandler(@Handles ExceptionEvent<Exception> event)
    public void basicInboundHandler(@BeforeHandles ExceptionEvent<Exception> event)
    public void extraInjections(@Handles ExceptionEvent<IllegalArgumentException> event, BeanManager bm)
    void protectedHandler(@Handles ExceptionEvent<IllegalStateException> event)
    private void handlerLocationInjections(BeanManager bm, @Handles ExceptionEvent<SQLException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    public void catchDescException(@BeforeHandles ExceptionEvent<Exception> event)
    public void catchFrameworkDescException(@BeforeHandles(ordinal = -50) ExceptionEvent<Exception> event)
    public void catchRuntime(@Handles ExceptionEvent<RuntimeException> event)
            @BeforeHandles(ordinal = 10) ExceptionEvent<Throwable> event)
            @BeforeHandles(ordinal = 20) ExceptionEvent<Throwable> event)
            @Handles(ordinal = 10) ExceptionEvent<Throwable> event)
            @Handles(ordinal = 20) ExceptionEvent<Throwable> event)
    public void catchIAE(@Handles ExceptionEvent<IllegalArgumentException> event)
    public void qualifiedHandler(@Handles @CatchQualifier ExceptionEvent<Exception> event)
    public void arqHandler(@Handles @Arquillian ExceptionEvent<Throwable> event)
    public void arqTestingHandler(@Handles @Arquillian @CatchQualifier ExceptionEvent<Throwable> event)
                                                     @Handles ExceptionEvent<SQLException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    public void throwsAnException(@Handles ExceptionEvent<Throwable> evt) throws Exception
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    public void unMuteHandlerAsc(@Handles ExceptionEvent<Exception> event)
    public void unMuteHandlerDesc(@BeforeHandles ExceptionEvent<Exception> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
    public void handleException1BF(@BeforeHandles ExceptionEvent<Exceptions.Exception1> event)
    public void handleException2BF(@BeforeHandles ExceptionEvent<Exceptions.Exception2> event)
    public void handleException3DF(@Handles ExceptionEvent<Exceptions.Exception3> event)
    public void handleException3BF(@BeforeHandles ExceptionEvent<Exceptions.Exception3> event)
    public void handleException3SuperclassBF(@BeforeHandles ExceptionEvent<Exceptions.Exception3Super> event)
    public void handleException3SuperclassDF(@Handles ExceptionEvent<Exceptions.Exception3Super> event)
    public void handleException2DF(@Handles ExceptionEvent<Exceptions.Exception2> event)
    public void handleException1DF(@Handles ExceptionEvent<Exceptions.Exception1> event)
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/exception/control/DefaultExceptionEvent.java
@SuppressWarnings({ "unchecked", "CdiManagedBeanInconsistencyInspection" })
public class DefaultExceptionEvent<T extends Throwable> implements IntrospectiveExceptionEvent<T>
    public DefaultExceptionEvent(final ExceptionStack stack, final boolean beforeTraversal, final boolean handled)
    @SuppressWarnings({ "unchecked", "MethodWithMultipleLoops", "ThrowableResultOfMethodCallIgnored" })
        inbound_cause:
                final List<HandlerMethod<?>> callbackExceptionEvent = new ArrayList<HandlerMethod<?>>(
                for (HandlerMethod<?> handler : callbackExceptionEvent)
                        final DefaultExceptionEvent callbackEvent = new DefaultExceptionEvent(stack, true,
                        handler.notify(callbackEvent);
                                callbackEvent.getCurrentExceptionHandlingFlow().name()));
                        if (!callbackEvent.isUnmute())
                        switch (callbackEvent.getCurrentExceptionHandlingFlow())
                                throwException = callbackEvent.getThrowNewException();
                                        "Unexpected enum type "  callbackEvent.getCurrentExceptionHandlingFlow());
                final List<HandlerMethod<? extends Throwable>> handlerMethods =
                Collections.reverse(handlerMethods);
                for (HandlerMethod<?> handler : handlerMethods)
                        final DefaultExceptionEvent depthFirstEvent = new DefaultExceptionEvent(stack, false,
 * Redefiner allowing to inject a non contextual instance of {@link DefaultExceptionEvent} into the first parameter.
 * This class is immutable.
     * @param event         instance of DefaultExceptionEvent to inject.
     * {@link org.apache.deltaspike.security.api.authentication.event.LoggedInEvent}
     * - raised when authentication is successful
     * {@link org.apache.deltaspike.security.api.authentication.event.LoginFailedEvent}
     * - raised when authentication fails
     * {@link org.apache.deltaspike.security.api.authentication.event.AlreadyLoggedInEvent}
     * - raised if the user is already authenticated
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/event/AlreadyLoggedInEvent.java
package org.apache.deltaspike.security.api.authentication.event;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/event/LoggedInEvent.java
package org.apache.deltaspike.security.api.authentication.event;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/event/LoginFailedEvent.java
package org.apache.deltaspike.security.api.authentication.event;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/event/PostAuthenticateEvent.java
package org.apache.deltaspike.security.api.authentication.event;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/event/PostLoggedOutEvent.java
package org.apache.deltaspike.security.api.authentication.event;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/event/PreAuthenticateEvent.java
package org.apache.deltaspike.security.api.authentication.event;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authentication/event/PreLoggedOutEvent.java
package org.apache.deltaspike.security.api.authentication.event;
import org.apache.deltaspike.security.api.authentication.event.AlreadyLoggedInEvent;
import org.apache.deltaspike.security.api.authentication.event.LoggedInEvent;
import org.apache.deltaspike.security.api.authentication.event.LoginFailedEvent;
import org.apache.deltaspike.security.api.authentication.event.PostAuthenticateEvent;
import org.apache.deltaspike.security.api.authentication.event.PostLoggedOutEvent;
import org.apache.deltaspike.security.api.authentication.event.PreAuthenticateEvent;
import org.apache.deltaspike.security.api.authentication.event.PreLoggedOutEvent;
import org.apache.deltaspike.security.api.authentication.event.LoginFailedEvent;
import org.apache.deltaspike.security.api.authentication.event.PostAuthenticateEvent;
import org.apache.deltaspike.security.api.authentication.event.LoginFailedEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;

 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exception/control/event/ExceptionEvent.java
package org.apache.deltaspike.core.api.exception.control.event;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exception/control/event/ExceptionStackEvent.java
package org.apache.deltaspike.core.api.exception.control.event;

import org.apache.deltaspike.core.api.exception.control.ExceptionStackItem;
public class ExceptionStackEvent implements Serializable
    public ExceptionStackEvent(final Throwable exception)
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exception/control/event/ExceptionToCatchEvent.java
package org.apache.deltaspike.core.api.exception.control.event;
public class ExceptionToCatchEvent implements Serializable
    public ExceptionToCatchEvent(Throwable exception, Annotation... qualifiers)
    public ExceptionToCatchEvent(Throwable exception)
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionStackEvent;
     * @param stackEvent           Information about the current exception and cause chain.
     * @throws IllegalArgumentException if stackEvent is null
    public DefaultExceptionEvent(final ExceptionStackEvent stackEvent, final boolean beforeTraversal,
                                 final boolean handled)
        if (stackEvent == null)
            throw new IllegalArgumentException("null is not valid for stackEvent");
        this.exception = (T) stackEvent.getCurrent();
    public ExceptionStackEvent getExceptionStack() {
import org.apache.deltaspike.core.api.exception.control.event.ExceptionStackEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
 * Observer of {@link org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent} events and
 * handler dispatcher. All handlers are invoked from this class.  This class is immutable.
     * @param exceptionEventEvent exception to be invoked
    public void executeHandlers(@Observes @Any ExceptionToCatchEvent exceptionEventEvent,
        LOG.entering(ExceptionHandlerDispatch.class.getName(), "executeHandlers", exceptionEventEvent.getException());
            final ExceptionStackEvent stack = new ExceptionStackEvent(exceptionEventEvent.getException());
                                beanManager, exceptionEventEvent.getQualifiers(), true));
                                exceptionEventEvent.isHandled());
                                exceptionEventEvent.setHandled(true);
                                exceptionEventEvent.setHandled(true);
                                exceptionEventEvent.setHandled(true);
                                throwException = exceptionEventEvent.getException();
                                beanManager, exceptionEventEvent.getQualifiers(), false);
                                exceptionEventEvent.isHandled());
                                exceptionEventEvent.setHandled(true);
                                exceptionEventEvent.setHandled(true);
                                exceptionEventEvent.setHandled(true);
                                throwException = exceptionEventEvent.getException();
            if (!exceptionEventEvent.isHandled() && throwException == null)
                LOG.warning(String.format("No handlers found for exception %s", exceptionEventEvent.getException()));
                throw exceptionEventEvent.getException();
            LOG.exiting(ExceptionHandlerDispatch.class.getName(), "executeHandlers",
                    exceptionEventEvent.getException());
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;

 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exception/control/event/ExceptionEvent.java
package org.apache.deltaspike.core.api.exception.control.event;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exception/control/event/ExceptionStackEvent.java
package org.apache.deltaspike.core.api.exception.control.event;

import org.apache.deltaspike.core.api.exception.control.ExceptionStackItem;
public class ExceptionStackEvent implements Serializable
    public ExceptionStackEvent(final Throwable exception)
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exception/control/event/ExceptionToCatchEvent.java
package org.apache.deltaspike.core.api.exception.control.event;
public class ExceptionToCatchEvent implements Serializable
    public ExceptionToCatchEvent(Throwable exception, Annotation... qualifiers)
    public ExceptionToCatchEvent(Throwable exception)
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionStackEvent;
     * @param stackEvent           Information about the current exception and cause chain.
     * @throws IllegalArgumentException if stackEvent is null
    public DefaultExceptionEvent(final ExceptionStackEvent stackEvent, final boolean beforeTraversal,
                                 final boolean handled)
        if (stackEvent == null)
            throw new IllegalArgumentException("null is not valid for stackEvent");
        this.exception = (T) stackEvent.getCurrent();
    public ExceptionStackEvent getExceptionStack() {
import org.apache.deltaspike.core.api.exception.control.event.ExceptionStackEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
 * Observer of {@link org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent} events and
 * handler dispatcher. All handlers are invoked from this class.  This class is immutable.
     * @param exceptionEventEvent exception to be invoked
    public void executeHandlers(@Observes @Any ExceptionToCatchEvent exceptionEventEvent,
        LOG.entering(ExceptionHandlerDispatch.class.getName(), "executeHandlers", exceptionEventEvent.getException());
            final ExceptionStackEvent stack = new ExceptionStackEvent(exceptionEventEvent.getException());
                                beanManager, exceptionEventEvent.getQualifiers(), true));
                                exceptionEventEvent.isHandled());
                                exceptionEventEvent.setHandled(true);
                                exceptionEventEvent.setHandled(true);
                                exceptionEventEvent.setHandled(true);
                                throwException = exceptionEventEvent.getException();
                                beanManager, exceptionEventEvent.getQualifiers(), false);
                                exceptionEventEvent.isHandled());
                                exceptionEventEvent.setHandled(true);
                                exceptionEventEvent.setHandled(true);
                                exceptionEventEvent.setHandled(true);
                                throwException = exceptionEventEvent.getException();
            if (!exceptionEventEvent.isHandled() && throwException == null)
                LOG.warning(String.format("No handlers found for exception %s", exceptionEventEvent.getException()));
                throw exceptionEventEvent.getException();
            LOG.exiting(ExceptionHandlerDispatch.class.getName(), "executeHandlers",
                    exceptionEventEvent.getException());
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
        String value;
        for (ConfigSource configSource : appConfigSources)
            value = configSource.getPropertyValue(key);

            if (value != null)
                        new Object[]{value, key, configSource.getConfigName()});
                return value;
                    new Object[]{key, configSource.getConfigName()});
        List<String> result = new ArrayList<String>();
        String value;
        for (ConfigSource configSource : appConfigSources)
            value = configSource.getPropertyValue(key);

            if (value != null && !result.contains(value))
                result.add(value);
        return result;
        ClassLoader currentClassLoader = ClassUtils.getClassLoader(null);
        ConfigSource[] appConfigSources = configSources.get(currentClassLoader);
            configSources.put(currentClassLoader, appConfigSources);
        for (ConfigSourceProvider configSourceProvider : configSourceProviderServiceLoader)
            appConfigSources.addAll(configSourceProvider.getConfigSources());
@SuppressWarnings("UnusedDeclaration")
    /**
     * Name/key of the property
     * @return name of the property
     */
    /**
     * Custom converter
     * @return custom converter or default marker
     */
    /**
     * Per default all properties are validated during the bootstrapping process of the CDI container.
     * If it can't be resolved, the bootstrapping will fail.
     *
     * Set it to true if the property will be set dynamically e.g. during the bootstrapping process and
     * it will be stored in a dynamic data-store like data-base.
     *
     * @return true if the property has to be available from the very beginning, false otherwise
     */
/**
 * Basic converter interface
 *
 * @param <S> source type which should be converted
 * @param <T> target type
 */

/**
 * Exception which provides the source- and target-type as payload
 */
    private static final long serialVersionUID = -1399119195483111935L;

/**
 * Special converter-interface which allows to provide payload for the conversion process via a custom annotation
 * @param <S> source type which should be converted
 * @param <T> target type
 * @param <M> meta-data type (custom annotation)
 */
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exception/control/annotation/BeforeHandles.java
package org.apache.deltaspike.core.api.exception.control.annotation;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exception/control/annotation/ExceptionHandler.java
package org.apache.deltaspike.core.api.exception.control.annotation;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exception/control/annotation/Handles.java
package org.apache.deltaspike.core.api.exception.control.annotation;
/**
 * Marker annotation for a message-bundle interface which provides type-safe messages
 * (methods annotated with {@link MessageTemplate}).
 *
 * Can be combined with {@link MessageContextConfig} to customize the message-resolution and processing
 */
/**
 * Allows to customize the message-resolution and processing in combination with {@link MessageBundle}
 */
    /**
     * {@link MessageResolver} which should be used for resolving the message-template (= basic text)
     * @return class of the {@link MessageResolver}-bean or the default marker
     */
    /**
     * {@link MessageInterpolator} which should be used for replacing the placeholders in the resolved text
     * @return class of the {@link MessageInterpolator}-bean or the default marker
     */
    /**
     * {@link LocaleResolver} which should be used for providing the locale for resolving
     * the message-template (= basic text)
     * @return class of the {@link LocaleResolver}-bean or the default marker
     */
/**
 * Provides the message(-template) for type-safe messages
 */
/**
 * Factory which allows to customize the creation of {@link Converter} instances
 */
//TODO replace it with the SecurityService of OWB
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/config/injectable/extension/ConfigPropertyExtension.java
package org.apache.deltaspike.core.impl.config.injectable.extension;
import org.apache.deltaspike.core.impl.config.injectable.ConfigPropertyBean;
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/config/injectable/extension/InjectionTargetEntry.java
package org.apache.deltaspike.core.impl.config.injectable.extension;
 * ({@link org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles} first), ordinal
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/exclude/extension/ExcludeExtension.java
package org.apache.deltaspike.core.impl.exclude.extension;
import org.apache.deltaspike.core.impl.exclude.GlobalAlternative;
//TODO move to extension package
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
    @SuppressWarnings("UnusedDeclaration")
    @SuppressWarnings("UnusedDeclaration")
    public SecurityDefinitionException(Throwable cause)
 * Applied to an {@link java.lang.annotation.Annotation} to declare it as a security parameter binding; to use business
 * method invocation values as {@link Secures} method arguments.
//TODO move to extension package
import org.apache.deltaspike.core.impl.exclude.CustomProjectStageBeanFilter;
    private Boolean isCustomProjectStageBeanFilterActivated = null;
        if (this.isCustomProjectStageBeanFilterActivated)
        {
            vetoCustomProjectStageBeans(processAnnotatedType);
        }

    protected void vetoCustomProjectStageBeans(ProcessAnnotatedType<Object> processAnnotatedType)
    {
        //currently there is a veto for all project-stage implementations,
        //but we still need @Typed() for the provided implementations in case of the deactivation of this behaviour
        if (ProjectStage.class.isAssignableFrom(processAnnotatedType.getAnnotatedType().getJavaClass()))
        {
            processAnnotatedType.veto();
        }
    }

            isActivated =
                ClassDeactivationUtils.isActivated(getClass());

            isGlobalAlternativeActivated =
                ClassDeactivationUtils.isActivated(GlobalAlternative.class);

            isCustomProjectStageBeanFilterActivated =
                ClassDeactivationUtils.isActivated(CustomProjectStageBeanFilter.class);
import org.apache.deltaspike.core.util.metadata.builder.ImmutableInjectionPoint;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/AnnotatedCallableImpl.java
package org.apache.deltaspike.core.util.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/AnnotatedConstructorImpl.java
package org.apache.deltaspike.core.util.metadata.builder;
 * {@link org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder}
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/AnnotatedFieldImpl.java
package org.apache.deltaspike.core.util.metadata.builder;
 * {@link org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder}.
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/AnnotatedImpl.java
package org.apache.deltaspike.core.util.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/AnnotatedMemberImpl.java
package org.apache.deltaspike.core.util.metadata.builder;
 * {@link org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder}.
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/AnnotatedMethodImpl.java
package org.apache.deltaspike.core.util.metadata.builder;
 * {@link org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder}.
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/AnnotatedParameterImpl.java
package org.apache.deltaspike.core.util.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/AnnotatedTypeBuilder.java
package org.apache.deltaspike.core.util.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/AnnotatedTypeImpl.java
package org.apache.deltaspike.core.util.metadata.builder;
 * {@link org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder}.
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/AnnotationBuilder.java
package org.apache.deltaspike.core.util.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/AnnotationStore.java
package org.apache.deltaspike.core.util.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/ImmutableInjectionPoint.java
package org.apache.deltaspike.core.util.metadata.builder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/InjectableMethod.java
package org.apache.deltaspike.core.util.metadata.builder;
import org.apache.deltaspike.core.util.metadata.builder.ParameterValueRedefiner.ParameterValue;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/metadata/builder/ParameterValueRedefiner.java
package org.apache.deltaspike.core.util.metadata.builder;
import org.apache.deltaspike.core.util.metadata.builder.ImmutableInjectionPoint;
import org.apache.deltaspike.core.util.metadata.builder.InjectableMethod;
import org.apache.deltaspike.core.util.metadata.builder.ParameterValueRedefiner;
import org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.core.util.metadata.builder.InjectableMethod;
import org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder;
}
import org.apache.deltaspike.core.util.metadata.builder.ParameterValueRedefiner;
// this class is intentionally made package scope
class AnnotationBuilder
import org.apache.deltaspike.core.util.securitymanaged.SetAccessiblePrivilegedAction;

            AccessController.doPrivileged(new SetAccessiblePrivilegedAction(method));
import org.apache.deltaspike.core.util.securitymanaged.SetAccessiblePrivilegedAction;
import java.security.AccessController;
            AccessController.doPrivileged(new SetAccessiblePrivilegedAction(field));
            AccessController.doPrivileged(new SetAccessiblePrivilegedAction(method));
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/securitymanaged/SetAccessiblePrivilegedAction.java
package org.apache.deltaspike.core.util.securitymanaged;

import org.apache.deltaspike.core.util.ClassUtils;

            = new WeakHashMap<ClassLoader, Map<String, Annotation>>();
     *
     * @param <T>             current type
            if (Proxy.isProxyClass(args[0].getClass()))
            {
                if (Proxy.getInvocationHandler(args[0]) instanceof AnnotationInstanceProvider)
                {
                    return equals(Proxy.getInvocationHandler(args[0]));
                }
            }
     * with minor changes.
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.Collections;
    private static final Class[] EMPTY_CLASS_ARRAY = new Class[0];
    private final Class<? extends Annotation> annotationClass;
    private final Map<String, ?> memberValues;
    private AnnotationInstanceProvider(Class<? extends Annotation> annotationClass, Map<String, ?> memberValues)
        this.memberValues = memberValues;
    /**
     * Creates an annotation instance for the given annotation class
     *
     * @param annotationClass type of the target annotation
     * @param values          A non-null map of the member values, keys being the name of the members
     * @param <T>             current type
     * @return annotation instance for the given type
     */
    @SuppressWarnings("unchecked")
    public static <T extends Annotation> T of(Class<T> annotationClass, Map<String, ?> values)
    {
        if (values == null)
        {
            throw new IllegalArgumentException("Map of values must not be null");
        }

        String key = annotationClass.getName()  "_"  values.hashCode();

        Map<String, Annotation> cache = getAnnotationCache();

        Annotation annotation = cache.get(key);

        if (annotation == null)
        {
            annotation = initAnnotation(key, annotationClass, cache, values);
        }

        return (T) annotation;
    }
    @SuppressWarnings("unchecked")
        return (T) of(annotationClass, Collections.EMPTY_MAP);
                                                                                 Map<String, Annotation> cache,
                                                                                 Map<String, ?> values)
                    new AnnotationInstanceProvider(annotationClass, values));
        else
        {
            if (this.memberValues.containsKey(method.getName()))
            {
                return this.memberValues.get(method.getName());
            }
            else // Default cause, probably won't ever happen, unless annotations get actual methods
            {
                return method.getDefaultValue();
            }
        }
            if (annotationClass.isInstance(o))
            {
                for (Map.Entry<String, ?> entry : this.memberValues.entrySet())
                {
                    try
                    {
                        Object oValue = annotationClass.getMethod(entry.getKey(), EMPTY_CLASS_ARRAY)
                                .invoke(o, EMPTY_OBJECT_ARRAY);
                        if (oValue != null && entry.getValue() != null)
                        {
                            if (!oValue.equals(entry.getValue()))
                            {
                                return false;
                            }
                        }
                        else // This may not actually ever happen, unless null is a default for a member
                        {
                            return false;
                        }
                    }
                    catch (IllegalAccessException e)
                    {
                        throw new RuntimeException(e);
                    }
                    catch (InvocationTargetException e)
                    {
                        throw new RuntimeException(e);
                    }
                    catch (NoSuchMethodException e)
                    {
                        throw new RuntimeException(e);
                    }
                }
                return true;
            }
        return memberValues.equals(that.memberValues);
        int result = 0;
        Class<? extends Annotation> type = annotationClass;
        for (Method m : type.getDeclaredMethods())
        {
            try
            {
                Object value = this.invoke(this, m, EMPTY_OBJECT_ARRAY);
                if (value == null)
                {
                    throw new IllegalStateException(String.format("Annotation method %s returned null", m));
                }
                result = hashMember(m.getName(), value);
            }
            catch (RuntimeException ex)
            {
                throw ex;
            }
            catch (Exception ex)
            {
                throw new RuntimeException(ex);
            }
        }
        return result;
    }

    //besides modularity, this has the advantage of autoboxing primitives:

    /**
     * Helper method for generating a hash code for a member of an annotation.
     *
     * @param name  the name of the member
     * @param value the value of the member
     * @return a hash code for this member
     */
    private int hashMember(String name, Object value)
    {
        int part1 = name.hashCode() * 127;
        if (value.getClass().isArray())
        {
            return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value);
        }
        if (value instanceof Annotation)
        {
            return part1 ^ hashCode((Annotation) value);
        }
        return part1 ^ value.hashCode();
    }

    /**
     * Helper method for generating a hash code for an array.
     *
     * @param componentType the component type of the array
     * @param o             the array
     * @return a hash code for the specified array
     */
    private static int arrayMemberHash(Class<?> componentType, Object o)
    {
        if (componentType.equals(Byte.TYPE))
        {
            return Arrays.hashCode((byte[]) o);
        }
        if (componentType.equals(Short.TYPE))
        {
            return Arrays.hashCode((short[]) o);
        }
        if (componentType.equals(Integer.TYPE))
        {
            return Arrays.hashCode((int[]) o);
        }
        if (componentType.equals(Character.TYPE))
        {
            return Arrays.hashCode((char[]) o);
        }
        if (componentType.equals(Long.TYPE))
        {
            return Arrays.hashCode((long[]) o);
        }
        if (componentType.equals(Float.TYPE))
        {
            return Arrays.hashCode((float[]) o);
        }
        if (componentType.equals(Double.TYPE))
        {
            return Arrays.hashCode((double[]) o);
        }
        if (componentType.equals(Boolean.TYPE))
        {
            return Arrays.hashCode((boolean[]) o);
        }
        return Arrays.hashCode((Object[]) o);
    }

    /**
     * <p>Generate a hash code for the given annotation using the algorithm
     * presented in the {@link Annotation#hashCode()} API docs.</p>
     *
     * @param a the Annotation for a hash code calculation is desired, not
     *          {@code null}
     * @return the calculated hash code
     * @throws RuntimeException      if an {@code Exception} is encountered during
     *                               annotation member access
     * @throws IllegalStateException if an annotation method invocation returns
     *                               {@code null}
     */
    private int hashCode(Annotation a)
    {
        int result = 0;
        Class<? extends Annotation> type = a.annotationType();
        for (Method m : type.getDeclaredMethods())
        {
            try
            {
                Object value = m.invoke(a);
                if (value == null)
                {
                    throw new IllegalStateException(String.format("Annotation method %s returned null", m));
                }
                result = hashMember(m.getName(), value);
            }
            catch (RuntimeException ex)
            {
                throw ex;
            }
            catch (Exception ex)
            {
                throw new RuntimeException(ex);
            }
        }
        return result;
        = new WeakHashMap<ClassLoader, Map<String, Annotation>>();
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/literal/RequestScopedLiteral.java
public class RequestScopedLiteral extends AnnotationLiteral<RequestScoped> implements RequestScoped
            return (T) initAnnotation(key, annotationClass, values);
            return (Annotation) Proxy.newProxyInstance(annotationClass.getClassLoader(),
        return (T) initAnnotation(key, annotationClass, values);
        return (Annotation) Proxy.newProxyInstance(annotationClass.getClassLoader(),
            new Class[]{annotationClass},
            new AnnotationInstanceProvider(annotationClass, values));
            if (String.class.isAssignableFrom(this.beanType))
            {
                return (T)configuredValue;
            }
            
        return (T)annotationMap.get(anType);
        return wrapped.create(creationalContext);
import org.apache.deltaspike.core.api.projectstage.TestStage;
import org.apache.deltaspike.core.util.ProjectStageProducer;
import javax.annotation.PostConstruct;
    private boolean isTestProjectStage;

    @PostConstruct
    protected void init()
    {
        this.isTestProjectStage = TestStage.class.isAssignableFrom(
            ProjectStageProducer.getInstance().getProjectStage().getClass());
    }

        //TODO add support for entity managers injected as argument/s


                cleanupTransactionBeanStorage();
                    cleanupTransactionBeanStorage();
    private void cleanupTransactionBeanStorage()
    {
        // and now we close all open transaction-scopes and reset the storage
        TransactionBeanStorage.getStorage().endAllTransactionScopes();
        TransactionBeanStorage.resetStorage();
    }

        if (this.isTestProjectStage)
        {
            this.beanManager.fireEvent(new PersistenceStrategyCleanupTestEvent());
        }

import org.apache.deltaspike.core.api.projectstage.TestStage;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import org.apache.deltaspike.core.util.ProjectStageProducer;
import org.apache.deltaspike.jpa.impl.transaction.TransactionBeanStorageCleanupTestEvent;

    private boolean isTestProjectStage;

        this.isTestProjectStage = TestStage.class.isAssignableFrom(
            ProjectStageProducer.getInstance().getProjectStage().getClass());
        TransactionBeanStorage currentBeanStorage = currentStorage.get();

        if (currentBeanStorage != null)
        {
            currentBeanStorage.close();

            currentStorage.set(null);
            currentStorage.remove();
        }
    }

    private void close()
    {
        if (this.isTestProjectStage)
        {
            BeanManagerProvider.getInstance().getBeanManager().fireEvent(new TransactionBeanStorageCleanupTestEvent());
        }
 * <p>A &#064;TransactionScoped contextual instance will be unique for a given
 * Marker interface for a plugable strategy for {@link org.apache.deltaspike.jpa.api.Transactional}.
 * This interceptor itself doesn't contain any functionality.
 * Instead the 'real' work is done inside a pluggable
 * {@link PersistenceStrategy}.

import org.apache.deltaspike.core.api.literal.AnyLiteral;
import javax.enterprise.inject.spi.Bean;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
 * <p>Default implementation of our plugable PersistenceStrategy.
 *
 *
 *
    private static final long serialVersionUID = -1432802805095533499L;
    @Inject
    private TransactionBeanStorage transactionBeanStorage;
    @Inject
    private PersistenceStrategyHelper persistenceHelper;

        Transactional transactionalAnnotation = persistenceHelper.extractTransactionalAnnotation(invocationContext);
        // all the configured qualifier keys
        Set<Class<? extends Annotation>> emQualifiers = persistenceHelper.resolveEntityManagerQualifiers(
                    transactionalAnnotation, invocationContext.getTarget().getClass());
        List<EntityManager> ems = new ArrayList<EntityManager>();
        boolean isOutermostInterceptor = transactionBeanStorage.isEmpty();
        if (isOutermostInterceptor)
            // a new Context needs to get started
            transactionBeanStorage.startTransactionScope();
        // the 'layer' of the transactional invocation, aka the refCounter
        int transactionLayer = transactionBeanStorage.incrementRefCounter();


        for (Class<? extends Annotation> emQualifier : emQualifiers)
            EntityManager entityManager = resolveEntityManagerForQualifier(emQualifier);

            transactionBeanStorage.storeUsedEntityManager(emQualifier, entityManager);

            ems.add(entityManager);
            for (EntityManager entityManager : ems)
            {
                EntityTransaction transaction = entityManager.getTransaction();

                if (!transaction.isActive())
                {
                    transaction.begin();
                }
            }

            if (isOutermostInterceptor)
                HashMap<Class, EntityManager> emsEntries = transactionBeanStorage.getUsedEntityManagers();
                for (Map.Entry<Class, EntityManager> emsEntry: emsEntries.entrySet())
                    EntityManager em = emsEntry.getValue();
                    EntityTransaction transaction = em.getTransaction();
                    if (transaction != null && transaction.isActive())
                        try
                            transaction.rollback();
                        }
                        catch (Exception eRollback)
                        {
                            if (LOGGER.isLoggable(Level.SEVERE))
                                LOGGER.log(Level.SEVERE,
                                        "Got additional Exception while subsequently " 
                                                "rolling back other SQL transactions", eRollback);
                // drop all EntityManagers from the ThreadLocal
                transactionBeanStorage.cleanUsedEntityManagers();

            // commit all open transactions in the outermost interceptor!
            // this is a 'JTA for poor men' only, and will not guaranty
            // commit stability over various databases!
            if (isOutermostInterceptor)
                // only commit all transactions if we didn't rollback
                // them already
                if (firstException == null)
                    HashMap<Class, EntityManager> emsEntries = transactionBeanStorage.getUsedEntityManagers();
                    for (EntityManager em: emsEntries.values())
                        EntityTransaction transaction = em.getTransaction();
                                    em.flush();
                    for (EntityManager em : emsEntries.values())
                        EntityTransaction transaction = em.getTransaction();
                                    transaction.commit();

                    // and now we close the open transaction scope
                    transactionBeanStorage.endTransactionScope();

            transactionBeanStorage.decrementRefCounter();
    private EntityManager resolveEntityManagerForQualifier(Class<? extends Annotation> emQualifier)
        Bean<EntityManager> entityManagerBean = resolveEntityManagerBean(emQualifier);
        if (entityManagerBean == null)
            return null;
        return (EntityManager) beanManager.getReference(entityManagerBean, EntityManager.class,
                beanManager.createCreationalContext(entityManagerBean));
     * @param e
     * @return the wrapped or unwrapped Exception

    protected Bean<EntityManager> resolveEntityManagerBean(Class<? extends Annotation> qualifierClass)
    {
        Set<Bean<?>> entityManagerBeans = beanManager.getBeans(EntityManager.class, new AnyLiteral());
        if (entityManagerBeans == null)
            entityManagerBeans = new HashSet<Bean<?>>();
        for (Bean<?> currentEntityManagerBean : entityManagerBeans)
            Set<Annotation> foundQualifierAnnotations = currentEntityManagerBean.getQualifiers();

            for (Annotation currentQualifierAnnotation : foundQualifierAnnotations)
                if (currentQualifierAnnotation.annotationType().equals(qualifierClass))
                    return (Bean<EntityManager>) currentEntityManagerBean;
        return null;
import javax.annotation.PreDestroy;
import javax.enterprise.context.RequestScoped;
import javax.persistence.EntityManager;
import java.lang.annotation.Annotation;
import java.util.Stack;
import java.util.concurrent.atomic.AtomicInteger;
 * <p>This class stores information about
 *
@RequestScoped
    private static class TransactionContextInfo
        /**
         * This is the actual bean storage.
         * The structure is:
         * <ol>
         *     <li>transactioKey identifies the 'database qualifier'</li>
         *     <li>transactionKey -> Stack: we need the Stack because of REQUIRES_NEW, etc</li>
         *     <li>top Element in the Stack -> Context beans for the transactionKey</li>
         * </ol>
         *
         */
        private Map<Contextual, TransactionBeanEntry> contextualInstances =
                new HashMap<Contextual, TransactionBeanEntry>();

        /** key=qualifier name, value= EntityManager */
        private HashMap<Class, EntityManager> ems = new HashMap<Class, EntityManager>();

        /**
         * counts the 'depth' of the interceptor invocation.
         */
        private AtomicInteger refCounter = new AtomicInteger(0);
     * If we hit a layer with REQUIRES_NEW, then create a new TransactionContextInfo
     * and push the old one on top of this stack.
    private Stack<TransactionContextInfo> oldTci = new Stack<TransactionContextInfo>();
     * The TransactionContextInfo which is on top of the stack.
     */
    private TransactionContextInfo currentTci = null;

    /**
     * Increment the ref counter and return the old value.
     * Must only be called if the bean storage is not {@link #isEmpty()}.
     * @return the the previous values of the refCounters. If 0 then we are 'outermost'
    public int incrementRefCounter()
        return currentTci.refCounter.incrementAndGet() - 1;
     * Decrement the reference counter and return the layer.
     * @return the layer number. 0 represents the outermost interceptor for the qualifier
    public int decrementRefCounter()
        if (currentTci == null)
            return 0;
        return currentTci.refCounter.decrementAndGet();
    }

    /**
     * @return <code>true</code> if we are the outermost interceptor over all qualifiers
     *         and the TransactionBeanStorage is yet empty.
     */
    public boolean isEmpty()
    {
        return currentTci == null;
    }

    /**
     * Start a new TransactionScope
     * @return the
     */
    public void startTransactionScope()
    {
        // first store away any previous TransactionContextInfo
        if (currentTci != null)
            oldTci.push(currentTci);
        }
        currentTci = new TransactionContextInfo();

        if (LOGGER.isLoggable(Level.FINER))
        {
            LOGGER.finer( "starting TransactionScope");
     * End the TransactionScope with the given qualifier.
     * This will subsequently destroy all beans which are stored
     * in the context.
     *
     * This method only gets used if we leave a transaction with REQUIRES_NEW.
     * In all other cases we use {@link #endAllTransactionScopes()}.
    public void endTransactionScope()
            LOGGER.finer("ending TransactionScope");
        destroyBeans(currentTci.contextualInstances);

        if (oldTci.size() > 0)
            currentTci = oldTci.pop();
        else
        {
            currentTci = null;
        }
    public EntityManager storeUsedEntityManager(Class<? extends Annotation> emQualifier, EntityManager entityManager)
    {
        return currentTci.ems.put(emQualifier, entityManager);
    }

    public HashMap<Class,EntityManager> getUsedEntityManagers()
    {
        return currentTci.ems;
    }

    public void cleanUsedEntityManagers()
    {
        currentTci.ems.clear();
    }

    public Map<Contextual, TransactionBeanEntry> getActiveTransactionContext()
        if (currentTci == null)
        {
            return null;
        }

        return currentTci.contextualInstances;
    }

    /**
     * At the end of the request we will destroy all beans still
     * stored in the context.
     */
    @PreDestroy
    public void requestEnded()
    {
        endAllTransactionScopes();
    }

    private void endAllTransactionScopes()
    {
        while (!isEmpty())
        {
            endTransactionScope();
        }

import org.apache.deltaspike.core.api.provider.BeanProvider;
 * CDI Context for managing &#064;{@link org.apache.deltaspike.jpa.api.TransactionScoped} contextual instances.
    // Attention! this is not a normal instance but a PROXY
    // thus it resolves the correct contextual instance every time
    // it will lazily initialized at runtime after the container
    // got started.
    private TransactionBeanStorage beanStorage;


        Map<Contextual, TransactionBeanEntry> transactionBeanEntryMap = getBeanStorage().getActiveTransactionContext();
        if (transactionBeanEntryMap == null)
            throw new ContextNotActiveException("Not accessed within a transactional method - use @" 
                    Transactional.class.getName());
        TransactionBeanEntry transactionBeanEntry = transactionBeanEntryMap.get(component);
        Map<Contextual, TransactionBeanEntry> transactionBeanEntryMap = getBeanStorage().getActiveTransactionContext();
        if (transactionBeanEntryMap == null)
        TransactionBeanEntry transactionBeanEntry = transactionBeanEntryMap.get(component);
        if (transactionBeanEntry != null)
            return (T) transactionBeanEntry.getContextualInstance();
        transactionBeanEntryMap.put(component, transactionBeanEntry);
        try
        {
            return getBeanStorage().getActiveTransactionContext() != null;
        }
        catch (ContextNotActiveException e)
        {
            return false;
        }

    private TransactionBeanStorage getBeanStorage()
    {
        if (beanStorage == null)
        {
            synchronized (this)
            {
                beanStorage = BeanProvider.getContextualReference(TransactionBeanStorage.class);
            }
        }
        return beanStorage;
    }

 b/deltaspike/modules/jpa/impl/src/main/java/org/apache/deltaspike/jpa/impl/transaction/ResourceLocalPersistenceStrategy.java
public class ResourceLocalPersistenceStrategy implements PersistenceStrategy
    private static final Logger LOGGER = Logger.getLogger(ResourceLocalPersistenceStrategy.class.getName());
        Class<? extends Annotation>[] qualifierClasses = null;
        if (transactionalAnnotation != null)
        {
            qualifierClasses = transactionalAnnotation.qualifier();
        }

        if (qualifierClasses == null || qualifierClasses.length == 1 && Any.class.equals(qualifierClasses[0]) )
import java.util.Collections;
        Set<Class<? extends Annotation>> emQualifiers = new HashSet<Class<? extends Annotation>>();
            Collections.addAll(emQualifiers, qualifierClasses);
        @SuppressWarnings("UnusedDeclaration")
                // drop all EntityManagers from the request-context cache
                // and now we close the open transaction scope
                transactionBeanStorage.endTransactionScope();
        //TODO integrate with the exception-handler provided by ds-core
            endTransactionScope();
        if (!isEmpty())
        {
            LOGGER.warning("the current TransactionContextInfo isn't empty. a fallback cleanup will be performed.");
        }
        for (TransactionBeanEntry beanEntry : activeBeans.values())
            beanEntry.getBean().destroy(beanEntry.getContextualInstance(), beanEntry.getCreationalContext());
    @SuppressWarnings("UnusedDeclaration")
    protected void recordConfigPropertyAwareInjectionPoint(@Observes ProcessInjectionTarget<?> event)
import org.apache.deltaspike.core.impl.exclude.InternalUntypedBean;
import javax.enterprise.inject.Typed;
import javax.inject.Named;
    private Boolean isInternalUntypedBeanFilterActivated = null;
        if (this.isInternalUntypedBeanFilterActivated)
        {
            vetoInternalUntypedBeans(processAnnotatedType);
        }
        
    protected void vetoInternalUntypedBeans(ProcessAnnotatedType<Object> processAnnotatedType)
    {
        Class<?> beanClass = processAnnotatedType.getAnnotatedType().getJavaClass();
        Typed typed = beanClass.getAnnotation(Typed.class);

        if (typed != null && typed.value().length == 0 && !beanClass.isAnnotationPresent(Named.class) &&
            beanClass.getName().startsWith("org.apache.deltaspike."))
        {
            processAnnotatedType.veto();
        }
    }

            
            isInternalUntypedBeanFilterActivated =
                ClassDeactivationUtils.isActivated(InternalUntypedBean.class);
import javax.enterprise.inject.Typed;
@Typed()
 *  SomeEntity retVal = TransactionHelper.getInstance().executeTransactional( new Callable<Integer>() {
 *    private @Inject EntityManager em;
 *    public SomeEntity call() throws Exception {
 *      return em.find(entityId, SomeEntity.class);
 *    }
 *  } );
        return "org.apache.deltaspike.test.jpa.datasource.DummyJdbcDriver";
        return "jdbc:dummy:mem:test";
@Deprecated
//X TODO remove - not needed anymore
import java.util.HashMap;
    /**
     * The BeanManagers picked up via Extension loading
     */
    private volatile Map<ClassLoader, BeanManager> loadTimeBms = new HashMap<ClassLoader, BeanManager>();

    /**
     * The final BeanManagers.
     * After the container did finally boot, we first try to resolve them from JNDI,
     * and only if we don't find any BM there we take the ones picked up at startup.
     */
    private volatile Map<ClassLoader, BeanManager> finalBms = new ConcurrentHashMap<ClassLoader, BeanManager>();
    /**
     * It basically doesn't matter which of the system events we use,
     * but basically we use the {@link AfterBeanDiscovery} event since it allows to use the
     * {@link BeanManagerProvider} for all events which occur after the {@link AfterBeanDiscovery} event.
     *
     * @param afterBeanDiscovery event which we don't actually use ;)
     * @param beanManager        the BeanManager we store and make available.
     */
    public void setBeanManager(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
    {
        BeanManagerProvider bmpFirst = setBeanManagerProvider(this);

        ClassLoader cl = ClassUtils.getClassLoader(null);
        bmpFirst.loadTimeBms.put(cl, beanManager);
    }

        BeanManager result = bmp.finalBms.get(classLoader);
            synchronized (this)
            {
                result = bmp.finalBms.get(classLoader);
                if (result == null)
                {
                    // first we look for a BeanManager from JNDI
                    result = resolveBeanManagerViaJndi();
                    if (result == null)
                    {
                        // if none found, we take the one we got from the Extension loading
                        result = bmp.loadTimeBms.get(classLoader);
                    }
                    if (result == null)
                    {
                        throw new IllegalStateException("Unable to find BeanManager. " 
                                "Please ensure that you configured the CDI implementation of your choice properly.");
                    }

                    // finally store the resolved BeanManager in the result cache
                    bmp.finalBms.put(classLoader, result);
                }
            }
        ClassLoader classLoader = ClassUtils.getClassLoader(null);
        bmp.finalBms.remove(classLoader);
        bmp.loadTimeBms.remove(classLoader);


        //X TODO this might not be enough as there might be
        //X ClassLoaders used during Weld startup which are not the TCCL...
            // this location is specified in JSR-299 and must be
            // supported in all certified EE environments
            //workaround didn't work -> return null
    @Deprecated
@Deprecated
//X TODO remove - not needed anymore
import javax.enterprise.inject.spi.AfterDeploymentValidation;
    /**
     * By cleaning the final BeanManager map after the Deployment got Validated,
     * we prevent premature loading of information from JNDI in cases where the
     * container might not be fully setup yet.
     *
     * This might happen if someone uses the BeanManagerProvider during Extension
     * startup.
     */
    public void cleanFinalBeanManagerMap(@Observes AfterDeploymentValidation adv)
    {
        bmp.finalBms.clear();
    }
 *
 * <p><b>Attention:</b> This method is intended for being used in user code at runtime.
 * If this method gets used during Container boot (in an Extension), non-portable
 * behaviour results. During bootstrapping an Extension shall &#064;Inject BeanManager to get
 * access to the underlying BeanManager (see e.g. {@link #cleanFinalBeanManagerMap(AfterDeploymentValidation)} ).
 * This is the only way to guarantee to get the right
 * BeanManager in more complex Container scenarios.</p>
 * <p>This class contains utility methods to resolve contextual references
 * in situations where no injection is available because the
 * current class is not managed by the CDI Container. This can happen
 * in e.g. a JPA-2.0 EntityListener, a ServletFilter, a Spring managed
 * Bean, etc.</p>
 *
 * <p><b>Attention:</b> This method is intended for being used in user code at runtime.
 * If this method gets used during Container boot (in an Extension), non-portable
 * behaviour results. The CDI specification only allows injection of the
 * BeanManager during CDI-Container boot time.</>
    private static BeanManagerProvider bmpSingleton = null;
     * This data container is used for storing the BeanManager for each
     * WebApplication. This is needed in EAR or other multi-webapp scenarios
     * if the DeltaSpike classes (jars) are provided in a shared ClassLoader.
    private static class BeanManagerInfo
    {
        /**
         * The BeanManager picked up via Extension loading
         */
        private BeanManager loadTimeBm = null;

        /**
         * The final BeanManagers.
         * After the container did finally boot, we first try to resolve them from JNDI,
         * and only if we don't find any BM there we take the ones picked up at startup.
         */
        private BeanManager finalBm = null;

        /**
         * Whether the CDI Application has finally booted.
         * Please note that this is only a nearby value
         * as there is no reliable event for this status in EE6.
         */
        private boolean booted = false;
    }
     * <p>The BeanManagerInfo for the current ClassLoader.</p>
     * <p><b>Attention:</b> This instance must only be used through the {@link #bmpSingleton} singleton!</p>
    private volatile Map<ClassLoader, BeanManagerInfo> bmInfos = new ConcurrentHashMap<ClassLoader, BeanManagerInfo>();


        return bmpSingleton != null;
        if (bmpSingleton == null)
        if (bmpSingleton == null)
        return bmpSingleton;
        setBeanManagerProvider(this);
        BeanManagerInfo bmi = getBeanManagerInfo(cl);
        bmi.loadTimeBm =  beanManager;
    /**
     * Get or create the BeanManagerInfo for the given ClassLoader
     */
    private BeanManagerInfo getBeanManagerInfo(ClassLoader cl)
    {
        BeanManagerInfo bmi = bmpSingleton.bmInfos.get(cl);
        if (bmi == null)
        {
            synchronized (this)
            {
                bmi = bmpSingleton.bmInfos.get(cl);
                if (bmi == null)
                {
                    bmi = new BeanManagerInfo();
                    bmpSingleton.bmInfos.put(cl, bmi);
                }
            }
        }

        return bmi;
    }
        BeanManagerInfo bmi = getBeanManagerInfo(classLoader);

        BeanManager result = bmi.finalBm;
                result = bmi.finalBm;
                        result = bmi.loadTimeBm;
                    bmi.finalBm = result;
        for (BeanManagerInfo bmi : bmpSingleton.bmInfos.values())
        {
            bmi.finalBm = null;
            bmi.booted = true;
        }
        bmpSingleton.bmInfos.remove(classLoader);
     * @return current {@link BeanManager} which is provided via JNDI
        if (bmpSingleton == null)
            bmpSingleton = beanManagerProvider;
        return bmpSingleton;
import java.util.logging.Logger;
    private static Logger logger = Logger.getLogger(BeanManagerProvider.class.getName());


        // warn the user if he tries to use the BeanManager before container starupt
        if (!bmi.booted)
        {
            logger.warning("When using the BeanManager to retrieve Beans before the Container is started," 
                    " non-portable behaviour results!");
        }

            Bean<ContextControl> ctxCtrlBean = (Bean<ContextControl>) getBeanManager().resolve(beans);
            CreationalContext<ContextControl> ctxCtrlCreationalContext = getBeanManager().createCreationalContext(ctxCtrlBean);
        return weldContainer.getBeanManager();
        weld = new Weld();
        weldContainer = weld.initialize();
        weld.shutdown();

            CreationalContext<ContextControl> ctxCtrlCreationalContext =
                    getBeanManager().createCreationalContext(ctxCtrlBean);

        if (applicationScopeStarted)
        applicationScopeStarted = true;
        if (Boolean.FALSE.equals(resetSuccessful) /*|| TODO detect weld 2.x*/)
                applicationScopeStarted = false;
                Field field = applicationContext.getClass().getSuperclass().getDeclaredField("beanStore");
                beanStoreHolder = (org.jboss.weld.bootstrap.api.Singleton)field.get(applicationContext);
                resetSuccessful = false;
                resetSuccessful = false;
            applicationScopeStarted = false;
            resetSuccessful = true;
        if (singletonScopeStarted)
        singletonScopeStarted = true;
        singletonScopeStarted = false;
        if (sessionMap == null)
            sessionMap = new HashMap<String, Object>();
        sessionContext.associate(sessionMap);
        sessionContext.activate();
        if (sessionContext.isActive())
            sessionContext.invalidate();
            sessionContext.deactivate();
            sessionContext.dissociate(sessionMap);
            sessionMap = null;
        conversationContext.associate(new MutableBoundRequest(requestMap, sessionMap));
        conversationContext.activate(cid);
            conversationContext.invalidate();
            conversationContext.deactivate();
            conversationContext.dissociate(new MutableBoundRequest(requestMap, sessionMap));
        if (requestMap == null)
            requestMap = new HashMap<String, Object>();
        requestContext.associate(requestMap);
        requestContext.activate();
        if (requestContext.isActive())
            requestContext.invalidate();
            requestContext.deactivate();
            requestContext.dissociate(requestMap);
            requestMap = null;
        if (contextController != null)
            return contextController;
        contextController = new ContextController();
        return tryToInjectFields(contextController);
        return stackTraceElements.clone();
        return throwable;
        exceptionStackItems = new ArrayDeque<ExceptionStackItem>();
            exceptionStackItems.addFirst(new ExceptionStackItem(e));
                    exceptionStackItems.addFirst(new ExceptionStackItem(sqlException));
        initialStackSize = exceptionStackItems.size();
        causes = createThrowableCollection(exceptionStackItems);
        init();
        root = exceptionStackItems.size() == initialStackSize;
        if (!exceptionStackItems.isEmpty())
            current = exceptionStackItems.removeFirst().getThrowable();
            remaining = Collections.unmodifiableCollection(exceptionStackItems);
            remaining = Collections.emptyList();
            current = null;
        last = remaining.isEmpty();
        next = (last) ? null : exceptionStackItems.peekFirst().getThrowable();
        return Collections.unmodifiableCollection(causes);
        return last;
        return next;
        return Collections.unmodifiableCollection(createThrowableCollection(remaining));
        return root;
        return current;
        exceptionStackItems = new ArrayDeque<ExceptionStackItem>(createExceptionStackFrom(elements));
        init();
        init();
        qualifiers = Collections.emptySet();
        return exception;
        return handled;
        return Collections.unmodifiableSet(qualifiers);
        return messageResolver;
        return messageInterpolator;
        return localeResolver;
        value = "";
        String projectStageClassName = getClass().getSimpleName();
        types = new HashMap<Type, Class<?>>();
            if (memberValues.containsKey(method.getName()))
                return memberValues.get(method.getName());
        Method[] methods = annotationClass.getDeclaredMethods();
                for (Map.Entry<String, ?> entry : memberValues.entrySet())
                Object value = invoke(this, m, EMPTY_OBJECT_ARRAY);
        parameters = getAnnotatedParameters(this, parameterTypes, genericTypes, parameterAnnotations,
            typeClosure = Collections.singleton(overridenType);
        javaMember = member;
        typeAnnotations = new AnnotationBuilder();
        constructors = new HashMap<Constructor<?>, AnnotationBuilder>();
        constructorParameters = new HashMap<Constructor<?>, Map<Integer, AnnotationBuilder>>();
        constructorParameterTypes = new HashMap<Constructor<?>, Map<Integer, Type>>();
        fields = new HashMap<Field, AnnotationBuilder>();
        fieldTypes = new HashMap<Field, Type>();
        methods = new HashMap<Method, AnnotationBuilder>();
        methodParameters = new HashMap<Method, Map<Integer, AnnotationBuilder>>();
        methodParameterTypes = new HashMap<Method, Map<Integer, Type>>();
            javaClass = type.getJavaClass();
            javaClass = type;
        javaClass = clazz;
        constructors = new HashSet<AnnotatedConstructor<X>>();
        methods = new HashSet<AnnotatedMethod<? super X>>();
        fields = new HashSet<AnnotatedField<? super X>>();
        annotationMap = new HashMap<Class<? extends Annotation>, Annotation>();
        annotationSet = new HashSet<Annotation>();
        annotationMap = emptyMap();
        annotationSet = emptySet();
        annotated = field;
        member = field.getJavaMember();
        type = field.getJavaMember().getGenericType();
        annotated = field;
        member = field.getJavaMember();
        qualifiers = BeanUtils.getQualifiers(beanManager, field.getAnnotations());
        type = field.getJavaMember().getGenericType();
        annotated = parameter;
        member = parameter.getDeclaringCallable().getJavaMember();
        type = parameter.getBaseType();
        annotated = parameter;
        member = parameter.getDeclaringCallable().getJavaMember();
        qualifiers = BeanUtils.getQualifiers(beanManager, parameter.getAnnotations());
        type = parameter.getBaseType();
        color = cat.color;
        ordinal = defaultOrdinal;
        configSources.add(new SystemPropertyConfigSource());
        configSources.add(new EnvironmentPropertyConfigSource());
        configSources.add(new LocalJndiConfigSource());
                configSources.add(new PropertyFileConfigSource(propertyFileUrl));
        return configSources;
        qualifiers = new HashSet<Annotation>();
            qualifiers.add(customQualifier);
            qualifiers.add(configProperty);
        beanType = (Class<?>) targetType;
        types = new HashSet<Type>();
        types.add(beanType);
        return types;
        return qualifiers;
        return beanType;
            converter = converterFactory.create(String.class, (Class<?>) beanType,
                    customQualifier != null ? customQualifier.annotationType() : null);
            if (String.class.isAssignableFrom(beanType))
        if (customQualifier != null && converter instanceof MetaDataAwareConverter)
            return (T) ((MetaDataAwareConverter) converter).convert(configuredValue, customQualifier);
        if (!isActivated)
                injectionTargets.add(
        if (!isActivated)
        for (InjectionTargetEntry injectionTargetEntry : injectionTargets)
        if (isActivated == null)
            isActivated = ClassDeactivationUtils.isActivated(getClass());
        result = converterMapping.get(new ConverterKey(sourceType, targetType, metaDataType));
        return converterMapping.get(new ConverterKey(sourceType, targetType, null));
        converterMapping.put(new ConverterKey(sourceType, targetType, metaDataType), converter);
        exception = (T) stackEvent.getCurrent();
        markedHandled = handled;
        flow = ExceptionHandlingFlow.HANDLED_AND_CONTINUE;
        return exception;
        flow = ExceptionHandlingFlow.ABORT;
        flow = ExceptionHandlingFlow.THROW_ORIGINAL;
        flow = ExceptionHandlingFlow.HANDLED;
        flow = ExceptionHandlingFlow.HANDLED_AND_CONTINUE;
        flow = ExceptionHandlingFlow.SKIP_CAUSE;
        unmute = true;
        return unmute;
        return flow;
        return markedHandled;
        throwNewException = t;
        flow = ExceptionHandlingFlow.THROW;
        return throwNewException;
            final int returnValue = comparePrecedence(lhs.getOrdinal(), rhs.getOrdinal(),
        handler = method;
        javaMethod = method.getJavaMember();
        handlerParameter = findHandlerParameter(method);
        if (!handlerParameter.isAnnotationPresent(Handles.class)
                && !handlerParameter.isAnnotationPresent(BeforeHandles.class))
        before = handlerParameter.getAnnotation(BeforeHandles.class) != null;
        if (before)
            ordinal = handlerParameter.getAnnotation(BeforeHandles.class).ordinal();
            ordinal = handlerParameter.getAnnotation(Handles.class).ordinal();
        tmpQualifiers.addAll(BeanUtils.getQualifiers(bm, handlerParameter.getAnnotations()));
        qualifiers = tmpQualifiers;
        beanClass = method.getJavaMember().getDeclaringClass();
        exceptionType = ((ParameterizedType) handlerParameter.getBaseType()).getActualTypeArguments()[0];
        if (bean == null)
        return bean;
        if (bean != null)
        Set<Bean<?>> beans = BeanProvider.getBeanDefinitions(beanClass, false, true);
            throw new IllegalStateException(beans.size()  " types found - base type: "  beanClass.getName());
        bean = beans.iterator().next();
        return Collections.unmodifiableSet(qualifiers);
        return exceptionType;
            Object handlerInstance = BeanProvider.getContextualReference(beanClass);
            InjectableMethod<?> im = createInjectableMethod(handler, getBean());
        return before;
        return ordinal;
        return handlerParameter;
        if (injectionPoints == null)
            injectionPoints = new HashSet<InjectionPoint>(handler.getParameters().size() - 1);
                if (!param.equals(handlerParameter))
                    injectionPoints.add(
        return new HashSet<InjectionPoint>(injectionPoints);
        if (beanManager == null)
            beanManager = BeanManagerProvider.getInstance().getBeanManager();
        return beanManager;
        return new StringBuilder("Qualifiers: ").append(qualifiers).append(" ")
                .append("Handles Type: ").append(exceptionType).append(" ")
                .append("Before: ").append(before).append(" ")
                .append("Precedence: ").append(ordinal).append(" ")
                .append(handler.toString()).toString();
        if (allHandlers.containsKey(handlerMethod.getExceptionType()))
            allHandlers.get(handlerMethod.getExceptionType()).add(handlerMethod);
            allHandlers.put(handlerMethod.getExceptionType(),
            if (allHandlers.get(hierarchyType) != null)
                for (HandlerMethod<?> handler : allHandlers.get(hierarchyType))
                            if (!handlerQualifiers.isEmpty() && containsAny(handler.getQualifiers(),
                            if (!handlerQualifiers.isEmpty() && containsAny(handler.getQualifiers(),
        declaringBean = handlerMethod.getBean();
                .createCreationalContext(declaringBean);
            if (value.getPosition() == handlerMethod.getHandlerParameter().getPosition())
        if (!isActivated)
        if (!isActivated)
        if (isGlobalAlternativeActivated)
        if (isCustomProjectStageBeanFilterActivated)
        if (!isActivated)
        if (arguments == null)
            arguments = new ArrayList<Object>();
        arguments.add(argument);
        return messageTemplate;
        return arguments.toArray();
        return toString(new DefaultMessageContext(messageContextConfig));
        Collections.addAll(argumentList, arguments);
        if (messageTemplate == null)
        return new DefaultMessage(messageContext.config(), messageTemplate,
                argumentList.toArray(new Object[argumentList.size()]));
        messageTemplate = null;
        argumentList = new ArrayList<Object>();
        MessageResolver messageResolver = messageContext.config().getMessageResolver();
        MessageInterpolator messageInterpolator = messageContext.config().getMessageInterpolator();
        messageInterpolator = messageContextConfigTemplate.getMessageInterpolator();
        messageResolver = messageContextConfigTemplate.getMessageResolver();
        localeResolver = messageContextConfigTemplate.getLocaleResolver();
                return new DefaultMessageContext(newMessageContextConfig);
        messageInterpolator = new DefaultMessageInterpolator();
        messageResolver = null;
        localeResolver = new DefaultLocaleResolver();
        return messageInterpolator;
        return messageResolver;
        return localeResolver;
        if (messageInterpolator != null)
            configInfo.append("   MessageInterpolator class: ").append(messageInterpolator.getClass());
        if (messageResolver != null)
            configInfo.append("   MessageResolver class: ").append(messageResolver.getClass());
        if (localeResolver != null)
            configInfo.append("   LocaleResolver class: ").append(localeResolver.getClass());
        messageBundle = resolvedBundle;
        if (messageBundle != null && messageTemplate != null &&
                return messageBundle.getString(messageTemplate.substring(1, messageTemplate.length() - 1));
        wrapped = bean;
        if (!isActivated)
        if (!isActivated)
        if (!isActivated)
            bundleProducerBean = (Bean<Object>) bean;
        messageBundleTypes.clear();
        types = new HashSet<Type>(type.getTypeClosure());
        qualifiers = new HashSet<Annotation>();
        stereotypes = new HashSet<Class<? extends Annotation>>();
                qualifiers.add(annotation);
                stereotypes.add(annotation.annotationType());
            qualifiers.add(new DefaultLiteral());
        qualifiers.add(new AnyLiteral());
        alternative = type.isAnnotationPresent(Alternative.class);
        types.add(type);
        qualifiers.add(qualifier);
        return messageContextConfig.use();
        inverseProperty2 = inverseProperty;
        return persistenceStrategy.execute(invocationContext);
        nestedTransactionBean.executeInTransaction();
            nestedTransactionBean.executeInTransaction();
            nestedTransactionBean.executeInTransaction();
        nestedTransactionBean.executeInTransaction();
        nestedTransactionBean.executeInTransaction();
        nestedTransactionBean.executeInTransaction();
        nestedTransactionBean.executeInTransaction();
        nestedTransactionBean.executeInTransaction();
        nestedTransactionBean.executeInTransaction();
        nestedTransactionBean.executeInTransaction();
        nestedTransactionBean.executeInTransaction();
        testEntityTransactionHolder.setTestEntityTransaction(
                (TestEntityTransaction) entityManager.getTransaction());
        return user != null;
        return user;
                    throw new UnexpectedCredentialException("active user: "  user.getId() 
                            " provided credentials: "  loginCredential.getUserId());
        return isLoggedIn() && loginCredential.getUserId() != null &&
                !loginCredential.getUserId().equals(user.getId());
                user = activeAuthenticator.getUser();
            beanManager.fireEvent(new PreLoggedOutEvent(user));
            PostLoggedOutEvent postLoggedOutEvent = new PostLoggedOutEvent(user);
        user = null;
        return state;
        if (securityViolations == null)
        return Collections.unmodifiableList(securityViolations);
        return (T) source;
        return Collections.unmodifiableMap(metaData);
        return (T) metaData.get(key);
            securityViolations = new ArrayList<SecurityViolation>(); //lazy init
        state = accessDecisionVoterState;
        metaData.clear();
        if (securityViolations == null)
        securityViolations.add(securityViolation);
        if (!isActivated)
        if (!isActivated)
        if (!isActivated)
        return securityStrategy.execute(invocationContext);
        authorizers.add(authorizer);
        securedTypes.add(annotatedType);
        securedTypes = null;
                for (Authorizer authorizer : authorizers)
        Map<Method, Set<Authorizer>> resultForClass = methodAuthorizers.get(targetClass);
        Map<Method, Set<Authorizer>> resultForClass = methodAuthorizers.get(targetClass);
            methodAuthorizers.put(targetClass, new HashMap<Method, Set<Authorizer>>());
        Map<Method, Set<Authorizer>> result = methodAuthorizers.get(targetClass);
        Map<Method, Set<Authorizer>> authorizerMapping = methodAuthorizers.get(targetClass);
            methodAuthorizers.put(targetClass, authorizerMapping);
        Map<Method, Set<Authorizer>> resultForClass = methodAuthorizers.get(targetClass);
        credential = null;
        userId = null;
        return "LoginCredential["  (userId != null ? userId : "unknown" )  "]";
        observedException = loginFailedEvent.getLoginException();
        id = UUID.randomUUID().toString();
        return id;
        return question;
        return id.hashCode();
        return obj instanceof NewProductInquiry && id.equals(((NewProductInquiry) obj).id);
        if (inquiryStorage.addInquiry(inquiry))
        loginCredential.setUserId(userName);
        loginCredential.setCredential(new Credential<String>()
        {
        identity.login();
        identity.logout();
        return shop.sendInquiry(new NewProductInquiry(customText));
    MOE, LARRY, CURLY, JOE, SHEMP
    {
 * &#064;Exclude
 * &#064;Exclude(ifProjectStage=Production.class)
 * &#064;Exclude(exceptIfProjectStage=UnitTest.class)
 * &#064;Exclude(onExpression="myProperty==myValue")
 * &#064;Exclude(onExpression="[my custom expression syntax]", interpretedBy=CustomExpressionInterpreter.class)
 * &#064;Exclude
 * &#064;Exclude(ifProjectStage = ProjectStage.Development.class)
 * &#064;Exclude(exceptIfProjectStage = ProjectStage.Development.class)
 * &#064;Exclude(onExpression="myProperty==myValue")
 * &#064;Exclude(onExpression="[my custom expression syntax]", interpretedBy=CustomExpressionInterpreter.class)
     *     &#064;Override
     * @param markerFile finding this marker file will trigger creating the JavaArchive.
     * @param urlPath to check
     * @param callable which will get executed in a &#064;Transactional block
     * @param activeBeans to destroy
     * @param markerFile finding this marker file will trigger creating the JavaArchive.
     * @param urlPath to check
     * Handles &#064;Secured beans
     * @param markerFile finding this marker file will trigger creating the JavaArchive.
     * @param urlPath to check
                append("stackTraceElements: ").append(Arrays.toString(stackTraceElements)).
     * @return class of the interpreter which should be used (default leads to a simple config-property interpreter)
     * Check to see if this event has been unmuted and therefore called again.
 *        // do some production stuff...
                              Type overriddenType)
        super(declaringType, field, field.getType(), annotations, field.getGenericType(), overriddenType);
    protected AnnotatedImpl(Class<?> type, AnnotationStore annotations, Type genericType, Type overriddenType)
        if (overriddenType == null)
            this.type = overriddenType;
            typeClosure = Collections.singleton(overriddenType);
                                  AnnotationStore annotations, Type genericType, Type overriddenType)
        super(memberType, annotations, genericType, overriddenType);
        Map<Constructor<?>, Map<Integer, AnnotationStore>> constructorParameterAnnotations =
        Map<Method, Map<Integer, AnnotationStore>> methodParameterAnnotations =
            methodParameterAnnotations.put(parameters.getKey(), parameterAnnotations);
            constructorParameterAnnotations.put(parameters.getKey(), parameterAnnotations);
                methodParameterAnnotations, constructorAnnotations, constructorParameterAnnotations, fieldTypes,
 * <code>definingType</code> to discover the qualifiers, types, scope,
 * <p>Usage:
 * <pre>
 *     CdiContainer container = CdiContainerLoader.getCdiContainer();
 *     container.boot();
 *     ...
 * </pre>
 * </p>
 * <p>CdiContainerLoader internally uses the {@link java.util.ServiceLoader}
 * to automatically detect the container implementation which should be used.
 * </p>

    /**
     * @return the {@link CdiContainer} implementation available on the classpath
     * @throws IllegalStateException if none or multiple CdiContainer implementations
     *         are found on the classpath.
     */
 * access to the underlying BeanManager (see e.g. {@link #cleanupFinalBeanManagers} ).
    private static BeanManagerProvider bmpSingleton = null;

        BeanManagerInfo bmi = getBeanManagerInfo(ClassUtils.getClassLoader(null));
        BeanManagerInfo bmi = getBeanManagerInfo(ClassUtils.getClassLoader(null));
        // warn the user if he tries to use the BeanManager before container startup


                    // store the resolved BeanManager in the result cache until #cleanupFinalBeanManagers gets called
                    // -> afterwards the next call of #getBeanManager will trigger the final lookup
    public void cleanupFinalBeanManagers(@Observes AfterDeploymentValidation adv)

            /*possible issue with >weld< based servers:
            if #getBeanManager gets called in a custom AfterDeploymentValidation observer >after< this observer,
            the wrong bean-manager might get stored (not deterministic due to the unspecified order of observers).
            finally a bean-manager for a single bda will be stored and returned (which isn't the bm exposed via jndi).*/
    private BeanManager resolveBeanManagerViaJndi()
     * Get or create the BeanManagerInfo for the given ClassLoader
     */
    private BeanManagerInfo getBeanManagerInfo(ClassLoader cl)
    {
        BeanManagerInfo bmi = bmpSingleton.bmInfos.get(cl);

        if (bmi == null)
        {
            synchronized (this)
            {
                bmi = bmpSingleton.bmInfos.get(cl);
                if (bmi == null)
                {
                    bmi = new BeanManagerInfo();
                    bmpSingleton.bmInfos.put(cl, bmi);
                }
            }
        }

        return bmi;
    }

    /**
 * <p>Marker interface for all type-safe framework configs.</p>
 *
 * <p>All DeltaSpike Configuration objects implement this interface
 * so they can be found more easily. There is no other
 * functionality implied with this interface.</p>
 *
 * <p>DeltaSpike uses a <i>Typesafe Configuration</i> approach.
 * Instead of writing a properties file or XML, you just implement
 * one of the configuration interfaces which will then be picked up as
 * CDI bean. If there is already a default configuration for
 * some functionality in DeltaSpike, you can use &#064;Specializes or
 * &#064;Alternative to change those.</p>
    private static Logger LOG = Logger.getLogger(BeanManagerProvider.class.getName());
            LOG.warning("When using the BeanManager to retrieve Beans before the Container is started," 
    private static final Logger  LOG = Logger.getLogger(BeanManagerProvider.class.getName());
import java.util.concurrent.Executor;

    /*
     * This method was introduced by Java7's java.sql.Driver and breaks backwards compatibility.
     */
    public int getNetworkTimeout() throws SQLException
    {
        return 0;
    }
    
    /*
     * This method was introduced by Java7's java.sql.Driver and breaks backwards compatibility.
     */
    public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException
    {
        // not implemented
    }

    /*
     * This method was introduced by Java7's java.sql.Driver and breaks backwards compatibility.
     */
    public void abort(Executor executor) throws SQLException
    {
        // not implemented
    }
    
    /*
     * This method was introduced by Java7's java.sql.Driver and breaks backwards compatibility.
     */
    public String getSchema() throws SQLException
    {
        return null;
    }

    /*
     * This method was introduced by Java7's java.sql.Driver and breaks backwards compatibility.
     */
    public void setSchema(String schema) throws SQLException
    {
        // not implemented
    }
import java.sql.SQLFeatureNotSupportedException;
import java.util.logging.Logger;

    /*
     * This method was introduced by Java7's java.sql.Driver and breaks backwards compatibility.
     */
    public Logger getParentLogger() throws SQLFeatureNotSupportedException
    {
        return null;
    }
/**
 * <p>This Qualifier allows to use the DeltaSpike configuration mechanism
 * via simple injection.</p>
 *
 * A small Example:
 * <pre>
 *   &#064;Inject &#064;ConfigProperty(name=&quot;database&quot;)
 *   private String configuredDatabase;
 * </pre>
 *
 * @see org.apache.deltaspike.core.api.config.ConfigResolver
 */
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/config/injectable/extension/ConfigInjectionTargetEntry.java
class ConfigInjectionTargetEntry
    ConfigInjectionTargetEntry(Type type, ConfigProperty configProperty, Annotation optionalCustomQualifier)
        ConfigInjectionTargetEntry that = (ConfigInjectionTargetEntry) o;
    private Set<ConfigInjectionTargetEntry> injectionTargets = new HashSet<ConfigInjectionTargetEntry>();
            Annotation qualifier = null;
            ConfigProperty configProperty = injectionPoint.getAnnotated().getAnnotation(ConfigProperty.class);
                // scan for meta-annotation
                injectionTargets.add(new ConfigInjectionTargetEntry(injectionPoint.getType(),
                        configProperty, qualifier));
        for (ConfigInjectionTargetEntry injectionTargetEntry : injectionTargets)
            event.addBean(new ConfigPropertyBean<Object>(injectionTargetEntry.getType(),
                    injectionTargetEntry.getConfigProperty(), injectionTargetEntry.getCustomQualifier()));
     * and use the one with the highest priority. If no configured value has been found that
     * way we will use the defaultValue.
     *
     * @param key the property key.
     * @param defaultValue will be used if no configured value for the key could be found.
     * @return the configured property value from the {@link ConfigSource} with the highest ordinal or
     *         the defaultValue if there is no value explicitly configured.
     */
    public static String getPropertyValue(String key, String defaultValue)
    {
        String configuredValue = getPropertyValue(key);
        if (configuredValue == null)
        {
            LOG.log(Level.FINE, "no configured value found for key {1}, using default value {2}.",
                    new Object[]{key, defaultValue});

            configuredValue = defaultValue;
        }
        return configuredValue;
    }

    /**
     * Resolve the property value by going through the list of configured {@link ConfigSource}s
     * This constant is a workaround for the java restriction that Annotation values
     * cannot be set to null. Do not use this String in your configuration...
     */
    String NULL = "org.apache.deltaspike.NullValueMarker";

    /**
     * <b>Optional</b> default value.
     * @return the default value which should be used if no config value could be found
     */
    @Nonbinding
    String defaultValue() default NULL;

    /**
     * <p>Per default all properties are validated during the bootstrapping process of the CDI container.
     * If it can't be resolved, the bootstrapping will fail.</p>
     * <p>Set it to true if the property will be set dynamically e.g. during the bootstrapping process and
     * it will be stored in a dynamic data-store like data-base.</p>
     *
     * <p>This flag has no effect if a {@link #defaultValue()} is set!</p>
        String configuredValue;
        String defaultValue = configProperty.defaultValue();
        if (ConfigProperty.NULL.equals(defaultValue))
        {
            // no special defaultValue has been configured
            configuredValue = ConfigResolver.getPropertyValue(configProperty.name());
        }
        else
        {
            configuredValue = ConfigResolver.getPropertyValue(configProperty.name(), defaultValue);
        }
                if (configProperty.eager() && ConfigProperty.NULL.equals(configProperty.defaultValue()) &&
                        ConfigResolver.getPropertyValue(configProperty.name()) == null)
    @ConfigProperty(name = "configProperty1", defaultValue = "myDefaultValue")
    private String stringProperty3Filled;

    @Inject
    @ConfigProperty(name = "nonexistingProperty", defaultValue = "myDefaultValue")
    private String stringProperty3Defaulted;

    @Inject
    @ConfigProperty(name = "nonexistingProperty", defaultValue = "42")
    private Integer intProperty4Defaulted;



    @Inject

    public String getProperty3Defaulted()
    {
        return stringProperty3Defaulted;
    }

    public String getProperty3Filled()
    {
        return stringProperty3Filled;
    }

    public int getProperty4Defaulted()
    {
        return intProperty4Defaulted;
    }
    @Nonbinding
    @Deprecated
    private Boolean isActivated = Boolean.FALSE;
    //X TODO private Boolean isActivated = null;
import javax.enterprise.inject.Stereotype;
import javax.enterprise.inject.Stereotype;
@Deprecated
@Deprecated
    final static String PROPERTY_NAME = "configProperty2";

    public SettingsBean(@ConfigProperty(name= PROPERTY_NAME) Long property2)
import javax.enterprise.inject.Stereotype;
@Deprecated
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/config/ConfigPropertyProducer.java
package org.apache.deltaspike.core.impl.config;
    public SettingsBean(@ConfigProperty(name = "property2") Long property2)
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/spi/config/BaseConfigPropertyProducer.java
package org.apache.deltaspike.core.spi.config;
import org.apache.deltaspike.core.api.config.ConfigResolver;
public abstract class BaseConfigPropertyProducer
import org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer;
import org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer;
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/config/DefaultConfigPropertyProducer.java
public class DefaultConfigPropertyProducer extends BaseConfigPropertyProducer
    @Produces
    @Dependent
    @ConfigProperty(name = "ignored") // we actually don't need the name
    public Boolean produceBooleanConfiguration(InjectionPoint injectionPoint)
    {
        String configuredValue = getStringPropertyValue(injectionPoint);
        if (configuredValue == null)
        {
            return null;
        }

        //X TODO do we like to support more than just "true" ?
        return Boolean.parseBoolean(configuredValue);
    }

    @Produces
    @Dependent
    @ConfigProperty(name = "ignored") // we actually don't need the name
    public Float produceFloatConfiguration(InjectionPoint injectionPoint)
    {
        String configuredValue = getStringPropertyValue(injectionPoint);
        if (configuredValue == null)
        {
            return null;
        }

        //X TODO think about something like @NumberFormat(...)
        return Float.parseFloat(configuredValue);
    }

        Boolean isTrue = "TRUE".equalsIgnoreCase(configuredValue);
        isTrue |= "1".equalsIgnoreCase(configuredValue);
        isTrue |= "YES".equalsIgnoreCase(configuredValue);
        isTrue |= "Y".equalsIgnoreCase(configuredValue);
        isTrue |= "JA".equalsIgnoreCase(configuredValue);
        isTrue |= "J".equalsIgnoreCase(configuredValue);
        isTrue |= "OUI".equalsIgnoreCase(configuredValue);

        return isTrue;
    @Inject
    @ConfigProperty(name = "configProperty1")
    private Boolean booleanPropertyNull;

    @Inject
    @ConfigProperty(name = "configProperty1", defaultValue = "false")
    private Boolean booleanPropertyFalse;

    @Inject
    @ConfigProperty(name = "configPropertyTrue1")
    private Boolean booleanPropertyTrue1;

    @Inject
    @ConfigProperty(name = "configPropertyTrue2")
    private Boolean booleanPropertyTrue2;

    @Inject
    @ConfigProperty(name = "configPropertyTrue3")
    private Boolean booleanPropertyTrue3;

    @Inject
    @ConfigProperty(name = "configPropertyTrue4")
    private Boolean booleanPropertyTrue4;

    @Inject
    @ConfigProperty(name = "configPropertyTrue5")
    private Boolean booleanPropertyTrue5;

    @Inject
    @ConfigProperty(name = "configPropertyTrue6")
    private Boolean booleanPropertyTrue6;

    @Inject
    @ConfigProperty(name = "configPropertyTrue7")
    private Boolean booleanPropertyTrue7;

    @Inject
    @ConfigProperty(name = "configPropertyTrue8")
    private Boolean booleanPropertyTrue8;




    public Boolean getBooleanPropertyNull()
    {
        return booleanPropertyNull;
    }

    public boolean getBooleanPropertyFalse()
    {
        return booleanPropertyFalse;
    }

    public Boolean getBooleanPropertyTrue1()
    {
        return booleanPropertyTrue1;
    }

    public Boolean getBooleanPropertyTrue2()
    {
        return booleanPropertyTrue2;
    }

    public Boolean getBooleanPropertyTrue3()
    {
        return booleanPropertyTrue3;
    }

    public Boolean getBooleanPropertyTrue4()
    {
        return booleanPropertyTrue4;
    }

    public Boolean getBooleanPropertyTrue5()
    {
        return booleanPropertyTrue5;
    }

    public Boolean getBooleanPropertyTrue6()
    {
        return booleanPropertyTrue6;
    }

    public Boolean getBooleanPropertyTrue7()
    {
        return booleanPropertyTrue7;
    }

    public Boolean getBooleanPropertyTrue8()
    {
        return booleanPropertyTrue8;
    }
 * TODO allow a custom implementation without a dependency to core-impl
//X TODO allow a custom implementation without a dependency to core-impl
@SuppressWarnings("UnusedDeclaration")
        //X TODO integrate with the HandledHandler of DeltaSpike
        //X TODO integrate with the HandledHandler of DeltaSpike

        //X TODO integrate with the HandledHandler of DeltaSpike
     * @param injectionPoint current injection point
        ConfigProperty configProperty = getAnnotation(injectionPoint, ConfigProperty.class);

     * @param injectionPoint current injection point
     * @param targetType target type
     * @param <T> type
     * @return annotation instance extracted from the injection point which matches the given type
    protected <T extends Annotation> T getAnnotation(InjectionPoint injectionPoint, Class<T> targetType)
        Annotated annotated = injectionPoint.getAnnotated();
        T result = annotated.getAnnotation(targetType);

        if (result == null)
                result = annotation.annotationType().getAnnotation(targetType);
                if (result != null)
        return result;
        LOG.info("configured inverse-value #2: "  settingsBean.getInverseProperty());
    private Long inverseProperty;

    public SettingsBean(@Property2 Long property2)
    @Inject
    protected void init(@Property2WithInverseSupport(inverseConvert = true) Long inverseProperty)
    {
        this.inverseProperty = inverseProperty;
    }
    public Long getInverseProperty()
    {
        return inverseProperty;
    }
    //X TODO fix it (broken since c0e020943ca7d4eeba1e8810cf1b55dcbab422a4)
import org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer;


                getAnnotation(injectionPoint, CustomConfigAnnotationWithMetaData.class);


                getAnnotation(injectionPoint, CustomConfigAnnotationWithMetaData.class);


import org.apache.deltaspike.core.util.BeanUtils;
        return BeanUtils.extractAnnotation(injectionPoint.getAnnotated(), targetType);
import javax.enterprise.inject.spi.Annotated;
     * @param annotated element to search in
     * @param targetType target type to search for
     * @param <T> type of the Annotation which get searched
     * @return annotation instance extracted from the annotated member
     */
    public static <T extends Annotation> T extractAnnotation(Annotated annotated, Class<T> targetType)
    {
        T result = annotated.getAnnotation(targetType);

        if (result == null)
        {
            for (Annotation annotation : annotated.getAnnotations())
            {
                result = annotation.annotationType().getAnnotation(targetType);

                if (result != null)
                {
                    break;
                }
            }
        }

        return result;
    }


    /**
 * <p>A small usage Example:
 * </p>
 *
 * <h2>Providing own Converters and Type injection</h2>
 * <p>DeltaSpikes own configuration system only natively only supports Strings.
 * If you like to apply own Converters or extract other types from those Strings,
 * you can simply do this by providing an own Qualifier and a simple
 * CDI producer method for it.</p>
 *
 * <p>First we write a simple Qualifier:
 * <pre>
 * &#064;Target({ PARAMETER, FIELD, METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
 * &#064;Retention(RUNTIME)
 * &#064;Qualifier
 * public @interface NumberConfig
 * {
 *     &#064;Nonbinding
 *     boolean name(); // the name of the configuration-key to lookup the value
 *
 *     &#064;Nonbinding
 *     boolean pattern(); // the pattern for NumberFormatter
 * }
 * </pre>
 * </p>
 *
 * <p>The producer method implementation is pretty easy as well:
 * <pre>
 * &#064;ApplicationScoped
 * public class NumberConfigProducer extends BaseConfigPropertyProducer
 * {
 *     &#064;Produces
 *     &#064;Dependent
 *     &#064;NumberConfig
 *     public Float produceNumberConfig(InjectionPoint injectionPoint)
 *     {
 *         String configuredValue = getStringPropertyValue(injectionPoint);
 *
 *         if (configuredValue == null || configuredValue.length() == 0)
 *         {
 *             return null; // or 0.f depending on what you need
 *         }
 *
 *         NumberConfig metaData = getAnnotation(injectionPoint, NumberConfig.class);
 *         DecimalFormat df = new DecimalFormat(metaData.pattern());
 *         return df.parse(configuredValue).floatValue();
 *     }
 * }
 * </pre>
 * </p>
 * @see org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer
 * <p>Resolve the configuration via their well defined ordinals.</p>
 *
 * <p>You can provide your own lookup paths by implementing
 * and registering additional {@link ConfigSource} or
 * {@link ConfigSourceProvider} implementations.</p>
        List<ConfigSource> appConfigSources = ServiceUtils.loadServiceImplementations(ConfigSource.class);
 * {@link ConfigSourceProvider} or via the
 * {@link java.util.ServiceLoader} mechanism. In the later case
 * it must get registered via creating a
 * <i>META-INF/services/org.apache.deltaspike.core.spi.config.ConfigSource</i>
 * file and adding the fully qualified class name of your ConfigSource
 * implementation into it. </p>
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.util.logging.Logger;
    private static final Logger LOG = Logger.getLogger(AbstractImmutableBean.class.getName());

            LOG.finest("No qualifers provided for bean class "  beanClass  ", using singleton set of @Default");
            LOG.finest("No scope provided for bean class "  beanClass  ", using @Dependent");
 * <p>See the sample in {@link org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer}
 * for how to implement own configuration injection.</p>
 * <p>This contains the fundamental parts for implementing own
 * ConfigProperty producers.</p>
 * <h2>Providing own Converters and Type injection</h2>
 * <p>DeltaSpikes own configuration system only natively only supports Strings.
 * If you like to apply own Converters or extract other types from those Strings,
 * you can simply do this by providing an own Qualifier and a simple
 * CDI producer method for it.</p>
 *
 * <p>First we write a simple Qualifier:
 * <pre>
 * &#064;Target({ PARAMETER, FIELD, METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
 * &#064;Retention(RUNTIME)
 * &#064;ConfigProperty(named="unused") // the name
 * &#064;Qualifier
 * public @interface NumberConfig
 * {
 *     &#064;Nonbinding
 *     boolean name(); // the name of the configuration-key to lookup the value
 *
 *     @Nonbinding
 *     String defaultValue() default ConfigProperty.NULL;
 *
 *     &#064;Nonbinding
 *     boolean pattern(); // the pattern for NumberFormatter
 * }
 * </pre>
 * </p>
 *
 * <p>The producer method implementation is pretty easy as well:
 * <pre>
 * &#064;ApplicationScoped
 * public class NumberConfigProducer extends BaseConfigPropertyProducer
 * {
 *     &#064;Produces
 *     &#064;Dependent
 *     &#064;NumberConfig
 *     public Float produceNumberConfig(InjectionPoint injectionPoint)
 *     {
 *         // resolve the annotation
 *         NumberConfig metaData = getAnnotation(injectionPoint, NumberConfig.class);

 *         // get the configured value from the underlying configuration system
 *         String configuredValue = getPropertyValue(metaData.name(), metaData.defaultValue());
 *         if (configuredValue == null)
 *         {
 *             return null;
 *         }
 *
 *         // format according to the given pattern
 *         DecimalFormat df = new DecimalFormat(metaData.pattern(), new DecimalFormatSymbols(Locale.US));
 *         return df.parse(configuredValue).floatValue(); *
 *     }
 * }
 * </pre>
 * </p>

     * <p>Inspects the given InjectionPoint and search for a {@link ConfigProperty}
     * annotation or an Annotation with a {@link ConfigProperty} meta-Annotation.
     * The name and defaultValue information will be used to resolve the
     * configured value.</p>
     *
        configuredValue = getPropertyValue(configProperty.name(), defaultValue);

        return configuredValue;
    }

    /**
     * @param propertyName the name of the property key
     * @param defaultValue the default value to return if no configured property is found or
     *                     {@link ConfigProperty#NULL} if no default value should be returned.
     * @return the configured value or the defaultValue according to the NULL logic.
     */
    protected String getPropertyValue(String propertyName, String defaultValue)
    {
        String configuredValue;
            configuredValue = ConfigResolver.getPropertyValue(propertyName);
            configuredValue = ConfigResolver.getPropertyValue(propertyName, defaultValue);
        try
        {
            return Integer.parseInt(configuredValue);
        }
        catch (NumberFormatException nfe)
        {
            ConfigProperty configProperty = getAnnotation(injectionPoint, ConfigProperty.class);
            throw new RuntimeException("Error while converting Integer property '"  configProperty.name() 
                    "' value: "  configuredValue  " happening in bean "  injectionPoint.getBean() , nfe);
        }

        try
        {
            return Long.parseLong(configuredValue);
        }
        catch (NumberFormatException nfe)
        {
            ConfigProperty configProperty = getAnnotation(injectionPoint, ConfigProperty.class);
            throw new RuntimeException("Error while converting Long property '"  configProperty.name() 
                    "' value: "  configuredValue  " happening in bean "  injectionPoint.getBean() , nfe);
        }
        try
        {
            return Float.parseFloat(configuredValue);
        }
        catch (NumberFormatException nfe)
        {
            ConfigProperty configProperty = getAnnotation(injectionPoint, ConfigProperty.class);
            throw new RuntimeException("Error while converting Float property '"  configProperty.name() 
                    "' value: "  configuredValue  " happening in bean "  injectionPoint.getBean() , nfe);
        }

 * <p>Marker annotation for a message-bundle interface which provides type-safe messages
 * (methods annotated with {@link MessageTemplate}).</p>
 * <p>This annotation must only be used on interfaces.
 * If this annotation gets used on a concrete class, a deployment error results!</p>
 *
 * <p>Can be combined with {@link MessageContextConfig} to customize the
 * message-resolution and processing.</p>
@Target({ TYPE })
 * Allows to customize the message-resolution and processing
 * in combination with {@link MessageBundle}.
 * <p>Provides the message(-template) for type-safe messages</p>
 *
 * <p>This only works on interfaces which are annotated with
 * {@link MessageBundle}.</p>
/**
 * Extension for handling {@link MessageBundle}s.
 *
 * @see MessageBundle
 * @see MessageTemplate
 */
    protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
    protected void detectInterfaces(@Observes ProcessAnnotatedType<?> processAnnotatedType)
        AnnotatedType<?> type = processAnnotatedType.getAnnotatedType();
        // sanity check: annotated class must be an Interface
        if (!currentClass.isInterface())
        {
            throw new IllegalStateException("@MessageBundle must only be used on Interfaces, but got used on class " 
                    currentClass.getName());
        }

    /**
     * Part of a workaround for very old CDI containers. The spec originally had a
     * mismatch in the generic parameters of ProcessProducerMethod between the JavaDoc
     * and the spec PDF.
     *
     * According to the Java EE 6 javadoc (the authority according to the powers
     * that be), this is the correct order of type parameters.
     *
     * @see #detectProducersInverted(javax.enterprise.inject.spi.ProcessProducerMethod)
     */
    /**
     * Part of a workaround for very old CDI containers. The spec originally had a
     * mismatch in the generic parameters of ProcessProducerMethod between the JavaDoc
     * and the spec PDF.
     *
     * According to the old JSR-299 spec wording, this is the correct order of type parameters.
     * This is now fixed in the spec as of today, but old containers might still fire it!
     *
     * @see #detectProducersInverted(javax.enterprise.inject.spi.ProcessProducerMethod)
     */
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
    private List<String> deploymentErrors = new ArrayList<String>();

            if (validateMessageBundle(type.getJavaClass()))
            {
                messageBundleTypes.add(type);
            }
    /**
     * @return <code>true</code> if all is well
     */
    private boolean validateMessageBundle(Class<?> currentClass)
        boolean ok = true;

            deploymentErrors.add("@MessageBundle must only be used on Interfaces, but got used on class " 
            return false;
                ok |= validateMessageContextAwareMethod(currentMethod);
                deploymentErrors.add(currentMethod.getReturnType().getName()  " isn't supported. Details: " 
                ok = false;

        return ok;
    private boolean validateMessageContextAwareMethod(Method currentMethod)
                return true;
        deploymentErrors.add("No "  MessageContext.class.getName()  " parameter found at: " 
        return false;
    protected void installMessageBundleProducerBeans(@Observes AfterBeanDiscovery abd, BeanManager beanManager)
        if (!deploymentErrors.isEmpty())
        {
            abd.addDefinitionError(new IllegalArgumentException("The following MessageBundle problems where found: " 
                    Arrays.toString(deploymentErrors.toArray())));
        }

            abd.addBean(createMessageBundleBean(bundleProducerBean, type, beanManager));
    protected void cleanup(@Observes AfterDeploymentValidation afterDeploymentValidation)
            return;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/ArraysUtils.java
package org.apache.deltaspike.core.util;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/builder/AbstractImmutableBean.java
package org.apache.deltaspike.core.util.builder;
import org.apache.deltaspike.core.util.ArraysUtils;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/builder/ImmutableBeanWrapper.java
package org.apache.deltaspike.core.util.builder;
 * @see WrappingBeanBuilder
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/builder/WrappingBeanBuilder.java
package org.apache.deltaspike.core.util.builder;
import org.apache.deltaspike.core.util.ArraysUtils;
public class WrappingBeanBuilder<T>
     * Instantiate a new {@link WrappingBeanBuilder}.
    public WrappingBeanBuilder(Bean<Object> delegate, BeanManager beanManager)
    public WrappingBeanBuilder<T> readFromType(AnnotatedType<T> type)
    public WrappingBeanBuilder<T> types(Set<Type> types)
    public WrappingBeanBuilder<T> types(Type... types)
        this.types = ArraysUtils.asSet(types);
    public WrappingBeanBuilder<T> addType(Type type)
    public WrappingBeanBuilder<T> addTypes(Type... types)
        this.types.addAll(ArraysUtils.asSet(types));
    public WrappingBeanBuilder<T> addTypes(Collection<Type> types)
    public WrappingBeanBuilder<T> qualifiers(Set<Annotation> qualifiers)
    public WrappingBeanBuilder<T> qualifiers(Annotation... qualifiers)
        this.qualifiers = ArraysUtils.asSet(qualifiers);
    public WrappingBeanBuilder<T> addQualifier(Annotation qualifier)
    public WrappingBeanBuilder<T> addQualifiers(Annotation... qualifiers)
        this.qualifiers.addAll(ArraysUtils.asSet(qualifiers));
    public WrappingBeanBuilder<T> addQualifiers(
    public WrappingBeanBuilder<T> name(String name)
    public WrappingBeanBuilder<T> scope(Class<? extends Annotation> scope)
    public WrappingBeanBuilder<T> alternative(boolean alternative)
    public WrappingBeanBuilder<T> stereotypes(
    public WrappingBeanBuilder<T> toString(String toString)
    public WrappingBeanBuilder<T> nullable(boolean nullable)
    public WrappingBeanBuilder<T> passivationCapable(boolean passivationCapable)
    public WrappingBeanBuilder<T> id(String id)
import org.apache.deltaspike.core.util.builder.WrappingBeanBuilder;
        return new WrappingBeanBuilder<T>(delegate, beanManager)
/**
 * <p>A WrappingBeanBuilder helps creating Beans which internally
 * just wrap another existing Bean. The Types, Qualifiers
 * and other attributes of the resulting Bean can be modified.</p>
 *
 * <p>The {@link Bean#create(javax.enterprise.context.spi.CreationalContext)}
 * and {@link Bean#destroy(Object, javax.enterprise.context.spi.CreationalContext)}
 * methods will get delegated to the underlying wrapped Bean.</p>
 *
 * @param <T> the type of the Bean
 */
        if (isPassivationCapable())
        {
            return new ImmutablePassivationCapableBeanWrapper<T>(delegate,
                    name, qualifiers, scope, stereotypes, types, alternative,
                    nullable, toString, id);
        }
        else
        {
            return new ImmutableBeanWrapper<T>(delegate, name, qualifiers, scope,
                    stereotypes, types, alternative, nullable, toString);
        }
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/bean/AbstractImmutableBean.java
package org.apache.deltaspike.core.util.bean;
public abstract class AbstractImmutableBean<T> implements Bean<T>
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/bean/ImmutableBeanWrapper.java
package org.apache.deltaspike.core.util.bean;
 * producer method), and register it for a narrowed type (or qualifiers).
 * You can easily create instances of this class with the
 * {@link WrappingBeanBuilder}.
 *
 * <p>For example, you could create a producer method which uses an a
 * String ID tolocated an object (the object can have any class):</p>
 * <p>The wrapped bean <em>must</em> return an object which can be cast to the
 * <p>You can then register a narrowing bean for each type you need:
 * <p>{@link ImmutableBeanWrapper} will use the annotations on
 * <p>The attributes are immutable, and collections are defensively copied on
 * @see org.apache.deltaspike.core.util.bean.WrappingBeanBuilder
public class ImmutableBeanWrapper<T> extends AbstractImmutableBean<T>
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/bean/ImmutablePassivationCapableBeanWrapper.java
package org.apache.deltaspike.core.util.bean;
 * <p>PassivationCapable version of an ImmutableBeanWrapper.
 *  You can easily create instances of this class with the
 * {@link WrappingBeanBuilder}.</p>
 * @see WrappingBeanBuilder
    /**
     * Instantiate a new {@link ImmutableBeanWrapper} for a  {@link PassivationCapable} Bean.
     *
     * @param bean        the bean to wrapped the lifecycle to
     * @param name        the name of the bean
     * @param qualifiers  the qualifiers of the bean
     * @param scope       the scope of the bean
     * @param stereotypes the bean's stereotypes
     * @param types       the types of the bean
     * @param alternative whether the bean is an alternative
     * @param nullable    true if the bean is nullable
     * @param toString    the string which should be returned by #{@link #toString()}
     * @param id          the passivationId which gets returned by {@link #getId()}
     */
    public ImmutablePassivationCapableBeanWrapper(Bean<T> bean,
        super(bean, name, qualifiers, scope, stereotypes, types, alternative, nullable, toString);
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/bean/WrappingBeanBuilder.java
package org.apache.deltaspike.core.util.bean;
import org.apache.deltaspike.core.util.bean.WrappingBeanBuilder;
        if (arguments == null || arguments.length == 0)
        {
            return messageTemplate;
        }

        return String.format(messageTemplate, arguments);

import java.lang.reflect.Proxy;
import org.apache.deltaspike.core.util.ClassUtils;


    private <T> T createMessageBundleProxy(Class<T> type)
    {
        return type.cast(Proxy.newProxyInstance(ClassUtils.getClassLoader(null),
                new Class<?>[]{type}, new MessageBundleInvocationHandler()));
    }

    @MessageTemplate("Welcome to %s")
    String simpleText(String name);
import org.apache.deltaspike.core.api.config.DeltaSpikeConfig;

 * <p>Provides the current {@link java.util.Locale}.</p>
 * <p>DeltaSpike provides a default implementation which
 * returns the current system Locale.</p>
 * <p>An application can provide an own implementation as
 * &#064;Alternative with a
 * &#064;{@link org.apache.deltaspike.core.api.config.annotation.DefaultConfiguration}
 * annotation. This could e.g. examine a JSF View or the Locale
 * of any currently logged in User.</p>
public interface LocaleResolver extends Serializable, DeltaSpikeConfig
}
import java.util.Locale;
public interface MessageContext extends Serializable
    /**
     * @return the current locale or <code>null</code> if
     *         the one from the {@link LocaleResolver} should be taken.
     */
    Locale getLocale();

import org.apache.deltaspike.core.api.config.DeltaSpikeConfig;

 * <p>Implementations are responsible to replace placeholders
 * in a message with the final value.</p>
 *
 * <p>An application can provide an own implementation as
 * &#064;Alternative with a
 * &#064;{@link org.apache.deltaspike.core.api.config.annotation.DefaultConfiguration}
 * annotation.</p>
public interface MessageInterpolator extends Serializable, DeltaSpikeConfig
import org.apache.deltaspike.core.api.config.annotation.DefaultConfiguration;
import javax.enterprise.context.Dependent;
 * Provide the default implementation for picking up the Locale
 * for messages.
@Dependent
@DefaultConfiguration
public class DefaultLocaleResolver implements LocaleResolver, Serializable
        //X TODO: this logic is odd. It's completely out of the standard flow
        //X TODO: handling is different based on where the interpolator gets configured :(
            if (result == null || result.equals(oldTemplate) || result.equals(baseMessage.getMessageTemplate()))
    private MessageInterpolator messageInterpolator = null;
    private MessageResolver messageResolver = null;
    private LocaleResolver localeResolver = null;
import org.apache.deltaspike.core.api.config.annotation.DefaultConfiguration;
import javax.enterprise.context.Dependent;
@Dependent
@DefaultConfiguration
public class DefaultMessageInterpolator implements MessageInterpolator, Serializable
import org.apache.deltaspike.core.api.config.annotation.DefaultConfiguration;
import org.apache.deltaspike.core.api.literal.DefaultConfigurationLiteral;
    private MessageInterpolator interpolator;
    private LocaleResolver localeResolver;
            MessageInterpolator messageInterpolator;
                messageInterpolator = BeanProvider.getContextualReference(messageInterpolatorClass);
            else
            {
                messageInterpolator = getDefaultMessageInterpolator();
            }

            result = messageInterpolator.interpolate(resolvedMessageTemplate, args);

    private MessageInterpolator getDefaultMessageInterpolator()
    {
        if (interpolator == null)
        {
            initDefaultConfig();
        }
        return interpolator;
    }

    private LocaleResolver getDefaultLocaleResolver()
    {
        if (localeResolver == null)
        {
            initDefaultConfig();
        }
        return localeResolver;
    }

    /**
     * Lazily initialize {@link #interpolator} and {@link #localeResolver}.
     */
    private synchronized void initDefaultConfig()
    {
        if (interpolator == null)
        {
            DefaultConfiguration defaultConfiguration = new DefaultConfigurationLiteral();
            interpolator = BeanProvider.getContextualReference(MessageInterpolator.class, defaultConfiguration);
            localeResolver = BeanProvider.getContextualReference(LocaleResolver.class, defaultConfiguration);
        }
    }
public interface MessageContext extends LocaleResolver
import java.util.Locale;
 *
 * <p>A simple implementation which uses the
 * {@link String#format(java.util.Locale, String, Object...)}
 * will be used by default.</p>
     * @param locale to use for the formatting
    String interpolate(Locale locale, String messageText, Object[] arguments);
import java.util.Locale;
    private Locale locale; //X TODO this might not always get properly initialized atm!
        this.locale = messageContext.getLocale();
        Locale l = locale != null ? locale : Locale.getDefault();
        return messageInterpolator.interpolate(l, getEscapedTemplate(messageTemplate), arguments);
import java.util.Locale;
    public String interpolate(Locale locale, String messageTemplate, Object... arguments)
        return String.format(locale, messageTemplate, arguments);
    private MessageInterpolator defaultInterpolator;
    private LocaleResolver defaultLocaleResolver;
            LocaleResolver localeResolver = getDefaultLocaleResolver(); //X TODO implement lookup chain
            result = messageInterpolator.interpolate(localeResolver.getLocale(), resolvedMessageTemplate, args);
        if (defaultInterpolator == null)
        return defaultInterpolator;
        if (defaultLocaleResolver == null)
        return defaultLocaleResolver;
     * Lazily initialize {@link #defaultInterpolator} and {@link #defaultLocaleResolver}.
        if (defaultInterpolator == null)
            defaultInterpolator = BeanProvider.getContextualReference(MessageInterpolator.class, defaultConfiguration);
            defaultLocaleResolver = BeanProvider.getContextualReference(LocaleResolver.class, defaultConfiguration);
    String welcomeWithStringVariable(String name);

    @MessageTemplate("Welcome to %f")
    String welcomeWithFloatVariable(Float value);
 * Base interface for all interceptor strategies which allow to provide
 * custom implementations for DeltaSpike interceptors.
}
     * @param locale to use for the formatting
    String interpolate(String messageText, Object[] arguments, Locale locale);
    public String interpolate(String messageTemplate, Object[] arguments, Locale locale)
        return messageInterpolator.interpolate(getEscapedTemplate(messageTemplate), arguments, l);
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

            result = messageInterpolator.interpolate(resolvedMessageTemplate, args, localeResolver.getLocale());
        if (this.lifecycle == null)
        {
            initLifecycle();
        }
        initLifecycle();

    private void initLifecycle()
    {
        lifecycle = WebBeansContext.getInstance().getService(ContainerLifecycle.class);
    }
        Locale l = messageContext.getLocale();
import org.apache.deltaspike.core.api.config.annotation.DefaultConfiguration;
import javax.inject.Inject;
    @Inject
    @DefaultConfiguration
    private LocaleResolver localeResolver;

    @Inject
    @DefaultConfiguration
    private MessageInterpolator messageInterpolator;

    protected MessageContext createDefaultMessageContext(Instance<MessageResolver> customMessageResolver)
        messageContextConfig.change().messageInterpolator(messageInterpolator);
        messageContextConfig.change().localeResolver(localeResolver);
import java.util.Locale;
 * Implementations have to resolve the text stored for a given key in the message-source they are aware of.
 * Implementations should always be &#064;Dependent scoped!

    /**
     * Initialize the MessageResolver with the message bundle and Locale
     * which should be used
     */
    void initialize(String messageBundleName, Locale locale);
import org.apache.deltaspike.core.api.config.annotation.DefaultConfiguration;
import javax.enterprise.context.Dependent;
@Dependent
@DefaultConfiguration
    private ResourceBundle messageBundle;
    public void initialize(String messageBundleName, Locale locale)
                MessageResolver messageResolver = new DefaultMessageResolver();
                messageResolver.initialize(messageBundleName, resolvedLocale);
                resolvedMessageTemplate = messageResolver.getMessage(messageTemplate.value());
    @Inject
    @DefaultConfiguration
    private MessageResolver messageResolver;

    protected MessageContext createDefaultMessageContext()
        messageContextConfig.change().messageResolver(messageResolver);
     * which should be used.
     * TODO review! It might be better to pass a whole configuration
    private Config config = null;
        config = new DefaultMessageContextConfig();
import org.apache.deltaspike.core.api.message.annotation.MessageContextConfig;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.util.ClassUtils;
    DefaultMessageContextConfig(MessageContextConfig messageContextConfig)
    {
        if (!MessageResolver.class.equals(messageContextConfig.messageResolver()))
        {
            Class<? extends MessageResolver> messageResolverClass =
                    ClassUtils.tryToLoadClassForName(messageContextConfig.messageResolver().getName());

            messageResolver = BeanProvider.getContextualReference(messageResolverClass);
        }

        if (!MessageInterpolator.class.equals(messageContextConfig.messageInterpolator()))
        {
            Class<? extends MessageInterpolator> messageInterpolatorClass =
                    ClassUtils.tryToLoadClassForName(messageContextConfig.messageInterpolator().getName());

            messageInterpolator = BeanProvider.getContextualReference(messageInterpolatorClass);
        }

        if (!LocaleResolver.class.equals(messageContextConfig.localeResolver()))
        {
            Class<? extends LocaleResolver> localeResolverClass =
                    ClassUtils.tryToLoadClassForName(messageContextConfig.localeResolver().getName());

            localeResolver = BeanProvider.getContextualReference(localeResolverClass);
        }
    }


    /**
     * Don't use this directly!
     * @see #getDefaultMessageContext()
     */
    private MessageContext defaultMessageContext = null;
        MessageContext messageContext = resolveMessageContextFromArguments(args);
        List<Object> arguments = resolveMessageArguments(args);
            if (messageContextConfig != null)
                messageContext = applyMessageContextConfig(messageContextConfig, method.getDeclaringClass().getName());
                messageContext = getDefaultMessageContext();
            }
        }
        if (String.class.isAssignableFrom(method.getReturnType()))
        {
            return messageContext.message().text(messageTemplate.value()).argument(arguments.toArray()).toText();
        }

        return messageContext.message().text(messageTemplate.value()).argument(arguments.toArray()).create();

    }

    private MessageContext applyMessageContextConfig(MessageContextConfig messageContextConfigLiteral,
                                                     String messageBundleName)
    {
        MessageContext.Config config = new DefaultMessageContextConfig(messageContextConfigLiteral);

        if (MessageResolver.class.equals(messageContextConfigLiteral.messageResolver()))
        {
            MessageResolver messageResolver = new DefaultMessageResolver();

            messageResolver.initialize(messageBundleName, config.getLocaleResolver().getLocale());
            config.change().messageResolver(messageResolver);
        }

        return config.use().create();
    }

    private List<Object> resolveMessageArguments(Object[] args)
    {
        List<Object> arguments = new ArrayList<Object>();
        if (args != null && args.length > 0)
        {
            for (int i = 0; i < args.length; i)
            {
                if (i == 0 && MessageContext.class.isAssignableFrom(args[0].getClass()))
                    continue;
                arguments.add(args[i]);
        return arguments;
    private MessageContext resolveMessageContextFromArguments(Object[] args)
        if (args != null && args.length > 0 &&
            MessageContext.class.isAssignableFrom(args[0].getClass()))
        {
            return (MessageContext) args[0];
        }

        return null;
    }

    private MessageContext getDefaultMessageContext()
    {
        if (defaultMessageContext == null)
        return defaultMessageContext;
     * Lazily initialize {@link #defaultMessageContext}.
        if (defaultMessageContext == null)
            defaultMessageContext = BeanProvider.getContextualReference(MessageContext.class);
    @Typed(MessageContext.class) // needed for _not_ serving as LocaleResolver!
 * &#064;Alternative. This could e.g. examine a JSF View or the Locale
 * &#064;Alternative.</p>
import org.apache.deltaspike.core.api.literal.AnyLiteral;
            messageResolver = BeanProvider.getContextualReference(messageResolverClass, new AnyLiteral());
            messageInterpolator = BeanProvider.getContextualReference(messageInterpolatorClass, new AnyLiteral());
            localeResolver = BeanProvider.getContextualReference(localeResolverClass, new AnyLiteral());
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
import org.apache.deltaspike.core.api.literal.AnyLiteral;
            defaultMessageContext = BeanProvider.getContextualReference(MessageContext.class, new AnyLiteral());
    protected void vetoBeans(@Observes ProcessAnnotatedType processAnnotatedType, BeanManager beanManager)
        Exclude exclude = (Exclude) processAnnotatedType.getAnnotatedType().getJavaClass().getAnnotation(Exclude.class);
    protected void vetoCustomProjectStageBeans(ProcessAnnotatedType processAnnotatedType)
    private void activateGlobalAlternativesWeld(ProcessAnnotatedType processAnnotatedType,
    private void activateGlobalAlternativesOwb(ProcessAnnotatedType processAnnotatedType,
    private boolean evalExcludeWithoutCondition(ProcessAnnotatedType processAnnotatedType, Exclude exclude)
    private boolean evalExcludeInProjectStage(ProcessAnnotatedType processAnnotatedType, Exclude exclude,
    private boolean evalExcludeNotInProjectStage(ProcessAnnotatedType processAnnotatedType, Exclude exclude,
    private void evalExcludeWithExpression(ProcessAnnotatedType processAnnotatedType, Exclude exclude)
    private void veto(ProcessAnnotatedType processAnnotatedType, String vetoType)
    protected void detectInterfaces(@Observes ProcessAnnotatedType processAnnotatedType)
     * <b>Booting the CdiTestContainer will scan the whole classpath
     * The container might throw a DeploymentException or similar on startup.</b>
     *
     * <p><b>Note:</b> booting the container does <i>not</i> automatically
     * start all CDI Contexts! Depending on the underlying CDI container you
     * might need to invoke {@link #getContextControl()} and execute
     * {@link ContextControl#startContext(Class)} or
     * {@link ContextControl#startContexts()}</p>
     * This method can be used for programmatically adding {@link ConfigSource}s.
     * It is not needed for normal 'usage' by end users, but only for Extension Developers!
     *
     * @see PropertyConfigSource if you like to register user config sources for property files
     *
     * @param configSourcesToAdd the ConfigSources to add
     */
    public static synchronized void addConfigSources(List<ConfigSource> configSourcesToAdd)
    {
        // we first pickup all pre-configured ConfigSources...
        getConfigSources();

        // and now we can easily add our own
        ClassLoader currentClassLoader = ClassUtils.getClassLoader(null);
        ConfigSource[] configuredConfigSources = configSources.get(currentClassLoader);

        List<ConfigSource> allConfigSources = Arrays.asList(configuredConfigSources);
        allConfigSources.addAll(configSourcesToAdd);

        // finally put all the configSources back into the map
        configSources.put(currentClassLoader, sortDescending(allConfigSources));
    }

    /**
        EnvironmentPropertyConfigSourceProvider epcsp = new EnvironmentPropertyConfigSourceProvider(PROPERTY_FILE_NAME);
        configSources.addAll(epcsp.getConfigSources());
        List<ConfigSource> allConfigSources = new ArrayList<ConfigSource>();
        allConfigSources.addAll(Arrays.asList(configuredConfigSources));
        Class<? extends PropertyConfigSource> pcsClass = pat.getAnnotatedType().getJavaClass();
        if (pcsClass.isAnnotation() ||
            pcsClass.isInterface()  ||
            pcsClass.isSynthetic()  ||
            pcsClass.isArray()      ||
            pcsClass.isEnum()         )
        {
            // we only like to add real classes
            return;
        }

        configSourcesClasses.add(pcsClass);
     * Obtains the precedence of the handler, relative to other handlers for the same type.
        if (o == null || !HandlerMethod.class.isAssignableFrom(o.getClass()))
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/message/FixedEnglishLocalResolver.java
public class FixedEnglishLocalResolver implements LocaleResolver
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/message/FixedGermanLocaleResolver.java
class FixedGermanLocaleResolver implements LocaleResolver
public interface MessageContext extends LocaleResolver, Serializable
     * @return the current message interpolator
    MessageInterpolator getMessageInterpolator();

    /**
     * @return the current message resolver
     */
    MessageResolver getMessageResolver();

    /**
     * @return the current locale resolver
     */
    LocaleResolver getLocaleResolver();

    /**
     * @param messageInterpolator a new message interpolator
     * @return the instance of the current message context builder
     */
    MessageContext setMessageInterpolator(MessageInterpolator messageInterpolator);

    /**
     * @param messageResolver a new message resolver
     * @return the instance of the current message context builder
     */
    MessageContext setMessageResolver(MessageResolver messageResolver);

    /**
     * @param localeResolver a new locale resolver
     * @return the instance of the current message context builder
     */
    MessageContext setLocaleResolver(LocaleResolver localeResolver);

    private MessageContext messageContext;
    DefaultMessage(MessageContext messageContext,
        this.messageContext = messageContext;
        return toString(new DefaultMessageContext(messageContext));
        this.messageContext = new UnmodifiableMessageContext(messageContext);
        return new DefaultMessage(messageContext, messageTemplate,
        MessageResolver messageResolver = messageContext.getMessageResolver();
        MessageInterpolator messageInterpolator = messageContext.getMessageInterpolator();
import org.apache.deltaspike.core.api.literal.AnyLiteral;
import org.apache.deltaspike.core.api.message.LocaleResolver;
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import org.apache.deltaspike.core.api.message.MessageResolver;
import org.apache.deltaspike.core.api.message.annotation.MessageContextConfig;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.util.ClassUtils;
    private MessageInterpolator messageInterpolator = null;
    private MessageResolver messageResolver = null;
    private LocaleResolver localeResolver = null;
    DefaultMessageContext(MessageContext otherMessageContext)
        setMessageInterpolator(otherMessageContext.getMessageInterpolator());
        setLocaleResolver(otherMessageContext.getLocaleResolver());
        setMessageResolver(otherMessageContext.getMessageResolver()) ;
    DefaultMessageContext(MessageContextConfig messageContextConfig)
    {
        if (!MessageResolver.class.equals(messageContextConfig.messageResolver()))
        {
            Class<? extends MessageResolver> messageResolverClass =
                    ClassUtils.tryToLoadClassForName(messageContextConfig.messageResolver().getName());

            messageResolver = BeanProvider.getContextualReference(messageResolverClass, new AnyLiteral());
        }

        if (!MessageInterpolator.class.equals(messageContextConfig.messageInterpolator()))
        {
            Class<? extends MessageInterpolator> messageInterpolatorClass =
                    ClassUtils.tryToLoadClassForName(messageContextConfig.messageInterpolator().getName());

            messageInterpolator = BeanProvider.getContextualReference(messageInterpolatorClass, new AnyLiteral());
        }

        if (!LocaleResolver.class.equals(messageContextConfig.localeResolver()))
        {
            Class<? extends LocaleResolver> localeResolverClass =
                    ClassUtils.tryToLoadClassForName(messageContextConfig.localeResolver().getName());

            localeResolver = BeanProvider.getContextualReference(localeResolverClass, new AnyLiteral());
        }
    }


        if (getLocaleResolver() == null)
        {
            return null;
        }

        return getLocaleResolver().getLocale();
    public LocaleResolver getLocaleResolver()
    {
        return localeResolver;
    }

    public MessageContext setLocaleResolver(LocaleResolver localeResolver)
    {
        this.localeResolver = localeResolver;
        return this;
    }

    public MessageInterpolator getMessageInterpolator()
    {
        return messageInterpolator;
    }

    public MessageContext setMessageInterpolator(MessageInterpolator messageInterpolator)
    {
        this.messageInterpolator = messageInterpolator;
        return this;
    }

    public MessageResolver getMessageResolver()
    {
        return messageResolver;
    }

    public MessageContext setMessageResolver(MessageResolver messageResolver)
    {
        this.messageResolver = messageResolver;
        return this;
    }

/*
    * generated
    */
        if (!localeResolver.equals(that.localeResolver))
        {
            return false;
        }
        if (messageInterpolator != null
                ? !messageInterpolator.equals(that.messageInterpolator) : that.messageInterpolator != null)
        {
            return false;
        }
        if (messageResolver != null ? !messageResolver.equals(that.messageResolver) : that.messageResolver != null)
        int result = messageInterpolator != null ? messageInterpolator.hashCode() : 0;
        result = 31 * result  (messageResolver != null ? messageResolver.hashCode() : 0);
        result = 31 * result  localeResolver.hashCode();
        return result;
        MessageContext messageContext = new DefaultMessageContext(messageContextConfigLiteral);
            messageResolver.initialize(messageBundleName, messageContext.getLocaleResolver().getLocale());
            messageContext.setMessageResolver(messageResolver);
        return messageContext;
        MessageContext messageContext = new DefaultMessageContext();
        messageContext.setMessageInterpolator(messageInterpolator);
        messageContext.setLocaleResolver(localeResolver);
        messageContext.setMessageResolver(messageResolver);
        return messageContext;
import org.apache.deltaspike.core.api.message.LocaleResolver;
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import org.apache.deltaspike.core.api.message.MessageResolver;
    public LocaleResolver getLocaleResolver()
        return messageContext.getLocaleResolver();
    @Override
    public MessageInterpolator getMessageInterpolator()
    {
        return messageContext.getMessageInterpolator();
    }

    @Override
    public MessageResolver getMessageResolver()
    {
        return messageContext.getMessageResolver();
    }
    public MessageContext setLocaleResolver(LocaleResolver localeResolver)
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public MessageContext setMessageInterpolator(MessageInterpolator messageInterpolator)
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public MessageContext setMessageResolver(MessageResolver messageResolver)
    {
        throw new UnsupportedOperationException();
    }

    @Override
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
     * @param messageBundleName a name of the message bundle which should be used
     * @return the instance of the current message context builder
     */
    Message bundle(String messageBundleName);

    /**
     * @param messageTemplate message key (or inline-text) for the current message
     * @return the current instance of the message builder to allow a fluent api
     */
    Message template(String messageTemplate);

    /**
     * @param arguments numbered and/or named argument(s) for the current message
     * @return the current instance of the message builder to allow a fluent api
     */
    Message argument(Object... arguments);

    /**
     * @return the configured message bundle name
     */
    String getBundle();

    /**
    String getTemplate();

 * Central context for handling dynamic messages.
 * Instances of this type are mutable but also {@link Cloneable}.
 * If you need a new instance, then use {@link Object#clone()}
public interface MessageContext extends LocaleResolver, Serializable, Cloneable
     * Clones the current MessageContext
    MessageContext clone();

    /**
     * @return message based on the current context modifiable via a fluent api
     */
    Message message();

    /**
     * @param messageInterpolator a new message interpolator to be set
     * @return the instance of the current message context builder
     */
    MessageContext messageInterpolator(MessageInterpolator messageInterpolator);

    /**
     * @param messageResolver a new message resolver to be set
     * @return the instance of the current message context builder
     */
    MessageContext messageResolver(MessageResolver messageResolver);

    /**
     * @param localeResolver a new locale resolver to be set
     * @return the instance of the current message context builder
     */
    MessageContext localeResolver(LocaleResolver localeResolver);
     * @param bundleName the name of the messageBundle to use or <code>null</code> if none should be used
     * @param locale the Locale to use for the resolving or <code>null</code> if the default should be used
     *         or <code>null</code> if an error happened or the resource could not be resolved.
    String getMessage(String bundleName, Locale locale, String messageTemplate);
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import org.apache.deltaspike.core.api.message.MessageResolver;
import java.util.Collections;
import java.util.Locale;

import static org.apache.deltaspike.core.api.message.MessageResolver.MISSING_RESOURCE_MARKER;
    protected String messageBundleName = null;
    DefaultMessage(MessageContext messageContext)
    {
        reset();

        this.messageContext = messageContext;
    }

                   String messageBundleName,
        reset();

        this.messageBundleName = messageBundleName;

        Collections.addAll(this.arguments, arguments);
    }

    protected void reset()
    {
        messageBundleName = null;
        messageTemplate = null;
        arguments = new ArrayList<Object>();
    public Message bundle(String messageBundleName)
        this.messageBundleName = messageBundleName;
    @Override
    public Message argument(Object... arguments)
        Collections.addAll(this.arguments, arguments);
        return this;
    public Message template(String messageTemplate)
    {
        this.messageTemplate = messageTemplate;
        return this;
    }

    @Override
    public String getBundle()
    {
        return messageBundleName;
    }

    @Override
    public String getTemplate()

        // the string construction happens in 3 phases

        // first we need the Locale which should get used
        Locale locale = messageContext.getLocale();

        // we then try to pickup the message via the MessageResolver
        String template = getTemplate();
        String ret = template;
        MessageResolver messageResolver = messageContext.getMessageResolver();
        if (messageResolver != null)
        {
            String resolvedTemplate = messageResolver.getMessage(getBundle(), locale, template);
            if (resolvedTemplate == null)
            {
                // this means an error happened during message resolving
                resolvedTemplate = markAsUnresolved(template);
            }
            ret = resolvedTemplate;
            template = resolvedTemplate;
        }

        // last step is to interpolate the message
        MessageInterpolator messageInterpolator = messageContext.getMessageInterpolator();
        if (messageInterpolator != null)
        {
            ret = messageInterpolator.interpolate(template, getArguments(), locale);
        }

        return ret;
    }

    private String markAsUnresolved(String template)
    {
        if (messageTemplate.startsWith("{") && messageTemplate.endsWith("}"))
        {
            template = messageTemplate.substring(1, messageTemplate.length() - 1);
        }

        StringBuffer sb = new StringBuffer(MISSING_RESOURCE_MARKER  template  MISSING_RESOURCE_MARKER);
        if (getArguments() != null && getArguments().length > 0)
        {
            sb.append(" ").append(Arrays.toString(getArguments()));
        }

        return sb.toString();
                .template(getTemplate())
                .toString();
    /**
     * Attention, the {@link #messageContext} is deliberately not part of the equation!
     */
        if (!getTemplate().equals(that.getTemplate()))

    /**
     * Attention, the {@link #messageContext} is deliberately not part of the equation!
     */
        int result = getTemplate().hashCode();
class DefaultMessageBuilder
        this.messageContext = messageContext;
        return new DefaultMessage(messageContext, null, messageTemplate,
        String messageTemplate = baseMessage.getTemplate();
        if (result == null || isKey(baseMessage.getTemplate()) || isKeyWithoutMarkers(result, baseMessage))
            String oldTemplate = extractTemplate(baseMessage.getTemplate());
            if (result == null || result.equals(oldTemplate) || result.equals(baseMessage.getTemplate()))
        return (!result.contains(" ") && result.endsWith(baseMessage.getTemplate()));
        return null; //X messageResolver.getMessage(baseMessage.getTemplate());
import org.apache.deltaspike.core.api.message.Message;
        messageInterpolator(otherMessageContext.getMessageInterpolator());
        localeResolver(otherMessageContext.getLocaleResolver());
        messageResolver(otherMessageContext.getMessageResolver()) ;
    public MessageContext clone()
        return new DefaultMessageContext(this);
    }

    @Override
    public Message message()
    {
        return new DefaultMessage(this);
            return Locale.getDefault();
    public MessageContext localeResolver(LocaleResolver localeResolver)
    public MessageContext messageInterpolator(MessageInterpolator messageInterpolator)
    public MessageContext messageResolver(MessageResolver messageResolver)
    public String getMessage(String bundleName, Locale locale, String messageTemplate)
        // we can use {{ as escaping for now
        if (messageTemplate.startsWith("{{"))
            // in which case we just cut of the first '{'
            return messageTemplate.substring(1);
        }

        if (messageTemplate.startsWith("{") && messageTemplate.endsWith("}"))
        {
            String resourceKey = messageTemplate.substring(1, messageTemplate.length() - 1);
            if (bundleName == null)
            {
                // using {} without a bundle is always an error
                return null;
            }

                ResourceBundle messageBundle = PropertyFileUtils.getResourceBundle(bundleName, locale);

                return messageBundle.getString(resourceKey);
                return null;

import org.apache.deltaspike.core.api.message.LocaleResolver;
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import org.apache.deltaspike.core.util.ClassUtils;
            messageContext = getDefaultMessageContext().clone();

                applyMessageContextConfig(messageContext, messageContextConfig);
        String messageBundleName = method.getDeclaringClass().getName();
            return messageContext.message().bundle(messageBundleName).template(messageTemplate.value())
                    .argument(arguments.toArray()).toString();
        return messageContext.message().bundle(messageBundleName).template(messageTemplate.value())
                .argument(arguments.toArray());
    private void applyMessageContextConfig(MessageContext messageContext, MessageContextConfig messageContextConfig)
        if (!MessageResolver.class.equals(messageContextConfig.messageResolver()))
            Class<? extends MessageResolver> messageResolverClass =
                    ClassUtils.tryToLoadClassForName(messageContextConfig.messageResolver().getName());
            messageContext.messageResolver(
                    BeanProvider.getContextualReference(messageResolverClass, new AnyLiteral()));
        if (!MessageInterpolator.class.equals(messageContextConfig.messageInterpolator()))
        {
            Class<? extends MessageInterpolator> messageInterpolatorClass =
                    ClassUtils.tryToLoadClassForName(messageContextConfig.messageInterpolator().getName());

            messageContext.messageInterpolator(
                    BeanProvider.getContextualReference(messageInterpolatorClass, new AnyLiteral()));
        }

        if (!LocaleResolver.class.equals(messageContextConfig.localeResolver()))
        {
            Class<? extends LocaleResolver> localeResolverClass =
                    ClassUtils.tryToLoadClassForName(messageContextConfig.localeResolver().getName());

            messageContext.localeResolver(
                    BeanProvider.getContextualReference(localeResolverClass, new AnyLiteral()));
        }
        return BeanProvider.getContextualReference(MessageContext.class);
        messageContext.messageInterpolator(messageInterpolator);
        messageContext.localeResolver(localeResolver);
        messageContext.messageResolver(messageResolver);
@Qualifier
@Target({ TYPE, METHOD, PARAMETER, FIELD })
@Retention(RUNTIME)
@Documented
     * @param messageBundleName a name of the message bundle which should be used
     * @return the instance of the current message context builder
     */
    MessageContext bundle(String messageBundleName);

    /**
     * @return the configured message bundle name
     */
    String getBundle();


    /**
     * @param messageContext messageContext which should be used
    String getMessage(MessageContext messageContext, String messageTemplate);
        // first try to pickup the message via the MessageResolver
            String resolvedTemplate = messageResolver.getMessage(messageContext, template);
            Locale locale = messageContext.getLocale();

    private String messageBundleName = null;

    public MessageContext bundle(String messageBundleName)
    {
        this.messageBundleName = messageBundleName;
        return this;
    }

    @Override
    public String getBundle()
    {
        return messageBundleName;
    }

    @Override
import org.apache.deltaspike.core.api.message.MessageContext;
    public String getMessage(MessageContext messageContext, String messageTemplate)

            String bundleName = messageContext.getBundle();

                Locale locale = messageContext.getLocale();
            return messageContext.bundle(messageBundleName).message().template(messageTemplate.value())
        return messageContext.bundle(messageBundleName).message().template(messageTemplate.value())
        String messageTemplateValue;
        if (messageTemplate != null)
        {
            messageTemplateValue = messageTemplate.value();
        }
        else
        {
            messageTemplateValue = "{"  method.getName()  "}";
        }
            return messageContext.bundle(messageBundleName).message().template(messageTemplateValue)
        return messageContext.bundle(messageBundleName).message().template(messageTemplateValue)
import org.apache.deltaspike.core.api.message.MessageSource;
    private final Class<? extends MessageSource>[] messageSource;
        this(MessageResolver.class, MessageInterpolator.class, LocaleResolver.class, MessageSource.class);
                                       Class<? extends LocaleResolver> localeResolver,
                                       Class<? extends MessageSource>... messageSource)
        this.messageSource = messageSource;
    }

    @Override
    public Class<? extends MessageSource>[] messageSource()
    {
        return this.messageSource;
import java.util.List;
     * Allows to add a message-source instance which can be used by a {@link MessageResolver}
     * @param messageSource message-source to add
    MessageContext messageSource(MessageSource messageSource);
     * Allows to add a message-source class which needs to provide a default constructor.
     * The message-source can be used by a {@link MessageResolver}
     * @param messageSourceClass class of a message-source to add
     * @return the instance of the current message context builder
    MessageContext messageSource(Class<? extends MessageSource> messageSourceClass);
    /**
     * @return list of registered message-sources
     */
    List<MessageSource> getMessageSources();
import org.apache.deltaspike.core.api.message.MessageSource;
     * Optional custom message-source.
     * @return classes of the message-sources
     */
    Class<? extends MessageSource>[] messageSource() default MessageSource.class;

    /**
import org.apache.deltaspike.core.api.message.MessageSource;
import org.apache.deltaspike.core.util.ClassUtils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
    private List<MessageSource> messageSources = new ArrayList<MessageSource>();
        messageResolver(otherMessageContext.getMessageResolver());
        this.messageSources.addAll(otherMessageContext.getMessageSources());
    public Message message()
        return new DefaultMessage(this);
    }

    @Override
    public MessageContext messageSource(MessageSource messageSource)
    {
        this.messageSources.add(messageSource);
    public MessageContext messageSource(Class<? extends MessageSource> messageSourceClass)
        //prevent adding the interface itself - TODO discuss it
        if (MessageSource.class.equals(messageSourceClass))
        {
            return this;
        }
        return messageSource(ClassUtils.tryToInstantiateClass(messageSourceClass));
    @Override
    @Override
    public List<MessageSource> getMessageSources()
    {
        return Collections.unmodifiableList(this.messageSources);
    }

    @Override
    @Override
    @Override
    @Override
    @Override
import org.apache.deltaspike.core.api.message.MessageSource;
import java.util.Iterator;
import java.util.List;
@SuppressWarnings("UnusedDeclaration")
            List<MessageSource> messageSources = messageContext.getMessageSources();
            if (messageSources == null || messageSources.isEmpty())
            Iterator<MessageSource> messageSourceIterator = messageSources.iterator();
            MessageSource currentMessageSource;
            while (messageSourceIterator.hasNext())
                currentMessageSource = messageSourceIterator.next();

                try
                {
                    Locale locale = messageContext.getLocale();
                    ResourceBundle messageBundle = PropertyFileUtils
                        .getResourceBundle(currentMessageSource.getKey(), locale);

                    return messageBundle.getString(resourceKey);
                }
                catch (MissingResourceException e)
                {
                    if (!messageSourceIterator.hasNext())
                    {
                        return null;
                    }
                }
import org.apache.deltaspike.core.api.message.MessageSource;
        messageContext.messageSource(createDefaultMessageSource(method.getDeclaringClass()));
            return messageContext.message().template(messageTemplateValue).argument(arguments.toArray()).toString();
        return messageContext.message().template(messageTemplateValue).argument(arguments.toArray());
        
        Class<? extends MessageSource>[] messageSources = messageContextConfig.messageSource();

        for (Class<? extends MessageSource> currentMessageSource : messageSources)
        {
            messageContext.messageSource(currentMessageSource);
        }

    /**
     * the fully qualified class name is the name of the bundle
     * @param messageBundleClass message-bundle class
     * @return message source for the given message-bundle class
     */
    private MessageSource createDefaultMessageSource(final Class<?> messageBundleClass)
    {
        final String className = messageBundleClass.getName();
        return new MessageSource()
        {
            @Override
            public String getKey()
            {
                return className;
            }
        };
    }
        if (template == null)
        {
            return "";
        }

        Message other = (Message) o;
        if (getTemplate() == null && other.getTemplate() != null)
        {
            return false;
        }

        if (getTemplate() != null && !getTemplate().equals(other.getTemplate()))
        if (arguments != null
                ? !Arrays.equals(arguments.toArray(), other.getArguments())
                : other.getArguments() != null)
    private final String[] messageSource;
        this(MessageResolver.class, MessageInterpolator.class, LocaleResolver.class, new String[0]);
                                       String[] messageSource)
    public String[] messageSource()
    MessageContext messageSource(String... messageSource);
    List<String> getMessageSources();
    String[] messageSource() default { };
import java.util.Arrays;
    private List<String> messageSources = new ArrayList<String>();
    public MessageContext messageSource(String... messageSource)
        // add on first position
        this.messageSources.addAll(0, Arrays.asList(messageSource));
    public List<String> getMessageSources()
            List<String> messageSources = messageContext.getMessageSources();
            Iterator<String> messageSourceIterator = messageSources.iterator();
            String currentMessageSource;
                    ResourceBundle messageBundle = PropertyFileUtils.getResourceBundle(currentMessageSource, locale);
        String messageBundleName = method.getDeclaringClass().getName();
            return messageContext.messageSource(messageBundleName).message().template(messageTemplateValue)
                    .argument(arguments.toArray()).toString();
        return messageContext.messageSource(messageBundleName).message().template(messageTemplateValue)
                .argument(arguments.toArray());

        String[] messageSources = messageContextConfig.messageSource();
        messageContext.messageSource(messageSources);
    messageSource = "customMinimalMessage")
        List<String> newMessageSources = new ArrayList<String>();

        for (String currentMessageSource : messageSource)
        {
            //don't insert message-sources twice
            if (!this.messageSources.contains(currentMessageSource))
            {
                newMessageSources.add(currentMessageSource);
            }
        }
        this.messageSources.addAll(0, newMessageSources);
    /**
     * Renders the Message to a String, using the {@link MessageContext}
     * which created the Message.
     */
    String toString();

    /**
     * Renders the Message to a String, using an
     * arbitrary {@link MessageContext}.
     */
    String toString(MessageContext messageContext);
    @Override
import java.io.Serializable;

public interface Message extends Serializable
    Message argument(Serializable... arguments);
    String interpolate(String messageText, Serializable[] arguments, Locale locale);
import java.io.Serializable;
    protected List<Serializable> arguments = new ArrayList<Serializable>();
        arguments = new ArrayList<Serializable>();
    public Message argument(Serializable... arguments)
    public Serializable[] getArguments()
        return arguments.toArray(new Serializable[arguments.size()]);
    public String interpolate(String messageTemplate, Serializable[] arguments, Locale locale)
import java.io.Serializable;
import org.apache.deltaspike.core.api.message.Message;
        List<Serializable> arguments = resolveMessageArguments(args);
        Message message =  messageContext
                .messageSource(messageBundleName).message()
                .template(messageTemplateValue)
                .argument(arguments.toArray(new Serializable[arguments.size()]));

            return message.toString();
        return message;
    private List<Serializable> resolveMessageArguments(Object[] args)
        List<Serializable> arguments = new ArrayList<Serializable>();
                Object arg = args[i];

                if (arg instanceof Serializable)
                {
                    arguments.add((Serializable) arg);
                }
                else
                {
                    // for non-serializable objects we perform an immediate toString() instead
                    arguments.add(arg.toString());
                }
 * <p>Marker annotation for a message-bundle interface which provides type-safe messages.
 * Each method on such an interface will form a type-safe message. The message lookup key
 * (resource bundle key) can either be defined by annotating those methods
 * with &#064;{@link MessageTemplate}) or by convention. if no &#064;{@link MessageTemplate}
 * annotation is used on a method, it's name will be used as resource key.</p>
 * <p>The {@link java.util.ResourceBundle} or other resource lookup source is
 * determined by the {@link org.apache.deltaspike.core.api.message.MessageResolver}
 * in conjunction with
 * {@link org.apache.deltaspike.core.api.message.MessageContext#messageSource(String...)}.
 * The fully qualified class name of the interface annotated with
 * &#064;MessageBundle will automatically be registered as additional <code>messageSource</code>!</p>
 *
     * <p>Additional message-source.</p>
     *
     * <p>A message-source is a lookup hint for the {@link MessageResolver}.
     * For the default MessageResolver this is the name of the
     * {@link java.util.ResourceBundle}.</p>
     *
     * <p>Example: For using 2 additional ResourceBundles for the lookup,
     * you can use the MessageContextConfig like that:
     * <pre>
     *  &#064;MessageBundle
     *  &#064;MessageContextConfig(messageSource = {"mycomp.ErrorMessages","mycomp.BusinessMessages"})
     *  public interface MyCompanyMessages {...
     * </pre>.</p>
 * <p>Provides the message(-template) for type-safe messages.</p>
 *
 * <p>Depending on the {@link org.apache.deltaspike.core.api.message.MessageResolver}
 * this message-template value might be used as key to lookup internationalized values
 * from a {@link java.util.ResourceBundle}.</p>
 *
 * <p>A MessageTemplate value which starts and ends with bracelets '{', '}' will
 * be interpreted as key for resolving from a ResourceBundle or any other lookup mechanism
 * determined by the {@link org.apache.deltaspike.core.api.message.MessageResolver}.
 * A small example:
 * <pre>
 * &#064;MessageTemplate("{welcome_to}")
 * </pre>
 * This will lookup a <code>welcome_to = Hello to Aruba</code> from the configured
 * resource bundle.
 * </p>
 *
 *
 * <p>MessageTemplate values without '{', '}' bracelets will be directly used
 * without resource lookup</p>
 * <p>Basic interface for all messages.</p>
 *
 * <p>A <code>Message</code> is not a simple String but all the
 * information needed to create those Strings for multiple situations.
 * The situation ist determined by the used {@link MessageContext}.</p>
 * <p>Marker annotation for a message-bundle interface which provides type-safe messages.</p>
 * <h3>Type-safe Messages</h3>
 * <p>Each method on an interface annotated with <code>&#064;MessageBundle</code>
 * will form a type-safe message. The message lookup key
 * (resource bundle key) can either be defined by annotating those methods
 * with &#064;{@link MessageTemplate}) or by convention. if no &#064;{@link MessageTemplate}
 * annotation is used on a method, the case sensitive method-name name
 * will be used as resource key.</p>
 *
 * <h3>Message Parameters</h3>
 * <p>The parameters of the declared methods will be automatically passed
 * as message parameters to the {@link org.apache.deltaspike.core.api.message.MessageResolver}.
 * Please note that all passed parameters should be {@link java.io.Serializable}.
 * If a parameter is not Serializable, we will instead store the <code>toString()</code>
 * of the passed parameter.</p>
 *
 *
 * <h3>Message Sources</h3>
 * <p>The {@link java.util.ResourceBundle} or other resource lookup source which might be used is
 * &#064;MessageBundle will automatically be registered as additional
 * <code>messageSource</code> for those messages.</p>
 *
 * <p><code>&#064;MessageBundle</code> can be combined with {@link MessageContextConfig}
 * to further customize the message-resolution and processing process.</p>
 *
 * <p>Debug hint: Set a breakpoint in <code>MessageBundleInvocationHandler#invoke</code>.
 * This will get called for every message bundle invocation.</p>
            if (annotation.annotationType().equals(Named.class))
            {
                // it's important to scan for Named first
                // as it's also a qualifier!
                name = Named.class.cast(annotation).value();
            }
            else if (beanManager.isQualifier(annotation.annotationType()))
public class DefaultMessage implements Message
    private String messageTemplate;
    private List<Serializable> arguments = new ArrayList<Serializable>();
    public DefaultMessage(MessageContext messageContext)
        StringBuilder sb = new StringBuilder(MISSING_RESOURCE_MARKER  template  MISSING_RESOURCE_MARKER);
    public DefaultMessageContext()
    public DefaultMessageContext(MessageContext otherMessageContext)
        messageSources.addAll(otherMessageContext.getMessageSources());
            if (!messageSources.contains(currentMessageSource))
        messageSources.addAll(0, newMessageSources);
        return Collections.unmodifiableList(messageSources);
public class DefaultMessageResolver implements MessageResolver
public class TypedMessageBundleProducer implements Serializable
        return messageSource;
 *     &#064;Nonbinding
    private String sessionId;

    public MockHttpSession(String sessionId)
    {
        this.sessionId = sessionId;
    }
        return sessionId;
    @Override
    public boolean equals(Object o)
    {
        if (this == o)
        {
            return true;
        }

        if (o == null || getClass() != o.getClass())
        {
            return false;
        }

        MockHttpSession that = (MockHttpSession) o;

        if (sessionId != null ? !sessionId.equals(that.sessionId) : that.sessionId != null)
        {
            return false;
        }

        return true;
    }

    @Override
    public int hashCode()
    {
        return sessionId != null ? sessionId.hashCode() : 0;
    }
    private static MockServletContext instance = new MockServletContext();



    private MockServletContext()
    {
        // this class is only accessible via getInstance
    }

    public static synchronized MockServletContext getInstance()
    {
        return instance;
    }



            session = new MockHttpSession("mockSession1");
            servletContext = MockServletContext.getInstance();
    @SuppressWarnings("CloneDoesntDeclareCloneNotSupportedException")
import java.io.Serializable;
        WrappingBeanBuilder<T> beanBuilder = new WrappingBeanBuilder<T>(delegate, beanManager)
                .readFromType(annotatedType);
        //X TODO re-visit type.getBaseType() in combination with #addQualifier
        beanBuilder.types(annotatedType.getJavaClass(), Object.class, Serializable.class);

        return beanBuilder.create();
    public void collectUserConfigSources(@Observes ProcessAnnotatedType<? extends PropertyConfigSource> pat)
import javax.servlet.ServletContextEvent;
    public static ServletContextEvent getServletContextEvent()
    {
        return new ServletContextEvent(getInstance());
    }

        contextFactory.initSingletonContext(OwbHelper.getMockServletContextEvent());
        contextFactory.initApplicationContext(OwbHelper.getMockServletContextEvent());
        contextFactory.initSessionContext(OwbHelper.getMockSession());
        contextFactory.initApplicationContext(OwbHelper.getMockServletContextEvent());
        contextFactory.initSessionContext(OwbHelper.getMockSession());
            contextFactory.destroySingletonContext(OwbHelper.getMockServletContextEvent());
            contextFactory.destroyApplicationContext(OwbHelper.getMockServletContextEvent());
            contextFactory.destroySessionContext(OwbHelper.getMockSession());
@SuppressWarnings("UnusedDeclaration")
        if (System.getSecurityManager() != null)
            return AccessController.doPrivileged(new GetClassLoaderAction(o));
        }
        else
        {
            return getClassLoaderInternal(o);
        }
    }

    static class GetClassLoaderAction implements PrivilegedAction<ClassLoader>
    {
        private Object object;
        GetClassLoaderAction(Object object)
        {
            this.object = object;
        }

        @Override
        public ClassLoader run()
        {
            try
                return getClassLoaderInternal(object);
            }
            catch (Exception e)
            {
                return null;
    }

    private static ClassLoader getClassLoaderInternal(Object o)
    {
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
                new String[]{"org.apache.deltaspike.core", "org.apache.deltaspike.test.category"},
                excludedPackagesOrFiles);
        //X TODO remove this workaround - lightguard.jp We don't need the work around, we have to have the META-INF/beans.xml for all containers
        //boolean isOwbAvailable = ClassUtils.tryToLoadClassForName("org.apache.webbeans.spi.ContainerLifecycle") != null;
        //if (isOwbAvailable)
        //{
        //}
        //else
        //{
        //    excludedFiles = new String[]{"META-INF.apache-deltaspike.properties", "META-INF.beans.xml"};
        //}
    private final Map<Type, Collection<HandlerMethod<? extends Throwable>>> allHandlers;
    HandlerMethodStorageImpl(Map<Type, Collection<HandlerMethod<? extends Throwable>>> allHandlers)
                    new HashSet<HandlerMethod<? extends Throwable>>(Collections.singleton(handlerMethod)));
    private Map<Type, Collection<HandlerMethod<? extends Throwable>>> allHandlers
        for (Map.Entry<Type, Collection<HandlerMethod<? extends Throwable>>> entry : allHandlers.entrySet())
    public Map<Type, Collection<HandlerMethod<? extends Throwable>>> getAllExceptionHandlers()
     * Clear all ConfigSources for the current ClassLoader
     */
    public static synchronized void freeConfigSources()
    {
        configSources.remove(ClassUtils.getClassLoader(null));
    }

    /**
import javax.enterprise.inject.spi.BeforeShutdown;
     * This method triggers freeing of the ConfigSources.
     */
    @SuppressWarnings("UnusedDeclaration")
    public void freeConfigSources(@Observes BeforeShutdown bs)
    {
        ConfigResolver.freeConfigSources();
    }

    /**
        List<ConfigSource> appConfigSources =
                sortAscending(new ArrayList<ConfigSource>(Arrays.asList(getConfigSources())));
 * <p>Example 1:
 *   &#064;Inject &#064;ConfigProperty(name=&quot;locationId&quot;)
 *   private String locationId;
 * <p>Example 2 (the type-safe alternative):
 *
 * <pre>
 *   &#064;Target({ FIELD, METHOD })
 *   &#064;Retention(RUNTIME)
 *   &#064;ConfigProperty(name = "locationId")
 *   &#064;Qualifier
 *   public &#064;interface Location
 *   {
 *   }
 * </pre>
 * </p>
 *
 * Depending on the producer it's possible to use a String or a custom type like an enum at the injection point.
 * <p/>
 * With a String:
 * <pre>
 *   &#064;Location
 *   private String locationId;
 * </pre>
 *
 * With a custom type:
 * <pre>
 *   &#064;Inject
 *   &#064;Location
 *   private LocationId locationId;
 * </pre>
 * <p>In any case a custom producer is needed.
 * {@link org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer} can be used as an base for custom
 * producers.
 * Producer for the configured String:
 * <pre>
 *   &#064;ApplicationScoped
 *   public class CustomConfigPropertyProducer extends BaseConfigPropertyProducer
 *   {
 *     &#064;Produces
 *     &#064;Dependent
 *     &#064;Location
 *     public String produceLocationId(InjectionPoint injectionPoint)
 *     {
 *       String configuredValue = getStringPropertyValue(injectionPoint);
 *
 *       if (configuredValue == null)
 *       {
 *         return "LOCATION_X";
 *       }
 *       return configuredValue;
 *     }
 *   }
 * </pre>
 *
 * Producer for a custom type:
 * <pre>
 *   &#064;ApplicationScoped
 *   public class CustomConfigPropertyProducer extends BaseConfigPropertyProducer
 *   {
 *     &#064;Produces
 *     &#064;Dependent
 *     &#064;Location
 *     public LocationId produceLocationId(InjectionPoint injectionPoint)
 *     {
 *       String configuredValue = getStringPropertyValue(injectionPoint);
 *
 *       if (configuredValue == null)
 *       {
 *         return LocationId.LOCATION_X;
 *       }
 *       return LocationId.valueOf(configuredValue.trim().toUpperCase());
 *     }
 *   }
 * </pre>
 b/deltaspike/examples/jse-examples/src/main/java/org/apache/deltaspike/example/config/ConfigExample.java
public class ConfigExample
    private static final Logger LOG = Logger.getLogger(ConfigExample.class.getName());
    private ConfigExample()
        LOG.info("configured location (custom config): "  settingsBean.getLocationId().name());
        

    @Produces
    @Dependent
    @Location
    public LocationId produceLocationId(InjectionPoint injectionPoint)
    {
        String configuredValue = getStringPropertyValue(injectionPoint);

        /*
        //alternative to @ConfigProperty#defaultValue
        if (configuredValue == null)
        {
            return LocationId.LOCATION_X;
        }
        */
        return LocationId.valueOf(configuredValue.trim().toUpperCase());
    }
    @Inject
    @Location
    private LocationId locationId;


    public LocationId getLocationId()
    {
        return locationId;
    }
 *   //alternative to null check in the producer:
 *   //&#064;ConfigProperty(name = "locationId", defaultValue = "LOCATION_X")
 *       //null check isn't needed, if {@link #defaultValue} is used
            LOG.log(Level.FINE, "no configured value found for key {0}, using default value {1}.",
import java.util.logging.Level;
import java.util.logging.Logger;
    private static final Logger LOG = Logger.getLogger(EnvironmentPropertyConfigSourceProvider.class.getName());

                LOG.log(Level.INFO,
                        "Custom config found by DeltaSpike. Name: ''{0}'', URL: ''{1}''",
                        new Object[] {propertyFileName, propertyFileUrl});
 * and registering additional {@link ConfigSource} or {@link PropertyConfigSource} or
 * and registering additional {@link PropertyFileConfig} or
 * {@link ConfigSource} or {@link ConfigSourceProvider} implementations.</p>
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/PropertyFileConfig.java
public interface PropertyFileConfig extends DeltaSpikeConfig
    String getFilePath();
import org.apache.deltaspike.core.api.config.PropertyFileConfig;
 * This extension handles {@link org.apache.deltaspike.core.api.config.PropertyFileConfig}s
    private static final String CANNOT_CREATE_CONFIG_SOURCE_FOR_CUSTOM_PROPERTY_FILE_CONFIG =
        "Cannot create ConfigSource for custom property-file config ";

    private List<Class<? extends PropertyFileConfig>> configSourcesClasses
        = new ArrayList<Class<?  extends PropertyFileConfig>>();
    public void collectUserConfigSources(@Observes ProcessAnnotatedType<? extends PropertyFileConfig> pat)
        Class<? extends PropertyFileConfig> pcsClass = pat.getAnnotatedType().getJavaClass();
        for (Class<? extends PropertyFileConfig> propertyFileConfigClass : configSourcesClasses)
            configSources.addAll(createPropertyConfigSource(propertyFileConfigClass));
     * @return create an instance of the given {@link PropertyFileConfig} and return all it's ConfigSources.
    private List<ConfigSource> createPropertyConfigSource(Class<? extends PropertyFileConfig> propertyFileConfigClass)
            PropertyFileConfig propertyFileConfig = propertyFileConfigClass.newInstance();
                = new EnvironmentPropertyConfigSourceProvider(propertyFileConfig.getFilePath());
            throw new RuntimeException(CANNOT_CREATE_CONFIG_SOURCE_FOR_CUSTOM_PROPERTY_FILE_CONFIG 
                propertyFileConfigClass.getName(), e);
            throw new RuntimeException(CANNOT_CREATE_CONFIG_SOURCE_FOR_CUSTOM_PROPERTY_FILE_CONFIG 
                    propertyFileConfigClass.getName(), e);
class EnvironmentPropertyConfigSourceProvider implements ConfigSourceProvider
    EnvironmentPropertyConfigSourceProvider(String propertyFileName)
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/config/propertyconfigsource/MyCustomPropertyFileConfig.java
import org.apache.deltaspike.core.api.config.PropertyFileConfig;
public class MyCustomPropertyFileConfig implements PropertyFileConfig
    public String getFilePath()
 b/deltaspike/examples/jse-examples/src/main/java/org/apache/deltaspike/example/config/CustomPropertyFileConfig.java
import org.apache.deltaspike.core.api.config.PropertyFileConfig;
public class CustomPropertyFileConfig implements PropertyFileConfig
    public String getFilePath()
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/interpreter/BasePropertyExpressionInterpreter.java
public abstract class BasePropertyExpressionInterpreter implements ExpressionInterpreter<String, Boolean>
 * Operations supported by {@link BasePropertyExpressionInterpreter}
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/bean/BaseImmutableBean.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.core.util.bean;

import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;

import javax.enterprise.context.Dependent;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.InjectionPoint;

import org.apache.deltaspike.core.api.literal.DefaultLiteral;
import org.apache.deltaspike.core.util.ArraysUtils;

/**
 * <p>
 * A base class for implementing {@link Bean}. The attributes are immutable, and
 * collections are defensively copied on instantiation. It uses the defaults
 * from the specification for properties if not specified.
 * </p>
 * <p/>
 * <p>
 * This class does not provide any bean lifecycle operations
 * </p>
 *
 * @see ImmutableBeanWrapper
 */
public abstract class BaseImmutableBean<T> implements Bean<T>
{
    private static final Logger LOG = Logger.getLogger(BaseImmutableBean.class.getName());

    private final Class<?> beanClass;
    private final String name;
    private final Set<Annotation> qualifiers;
    private final Class<? extends Annotation> scope;
    private final Set<Class<? extends Annotation>> stereotypes;
    private final Set<Type> types;
    private final boolean alternative;
    private final boolean nullable;
    private final Set<InjectionPoint> injectionPoints;
    private final String toString;

    /**
     * Create a new, immutable bean. All arguments passed as collections are
     * defensively copied.
     *
     * @param beanClass       The Bean class, may not be null
     * @param name            The bean name
     * @param qualifiers      The bean's qualifiers, if null, a singleton set of
     *                        {@link javax.enterprise.inject.Default} is used
     * @param scope           The bean's scope, if null, the default scope of
     *                        {@link Dependent} is used
     * @param stereotypes     The bean's stereotypes, if null, an empty set is used
     * @param types           The bean's types, if null, the beanClass and {@link Object}
     *                        will be used
     * @param alternative     True if the bean is an alternative
     * @param nullable        True if the bean is nullable
     * @param injectionPoints the bean's injection points, if null an empty set is used
     * @param toString        the string which should be returned by #{@link #toString()}
     * @throws IllegalArgumentException if the beanClass is null
     */
    public BaseImmutableBean(Class<?> beanClass,
                             String name,
                             Set<Annotation> qualifiers,
                             Class<? extends Annotation> scope,
                             Set<Class<? extends Annotation>> stereotypes,
                             Set<Type> types,
                             boolean alternative,
                             boolean nullable,
                             Set<InjectionPoint> injectionPoints,
                             String toString)
    {
        if (beanClass == null)
        {
            throw new IllegalArgumentException("beanClass cannot be null");
        }

        this.beanClass = beanClass;
        this.name = name;

        if (qualifiers == null)
        {
            this.qualifiers = Collections.<Annotation>singleton(new DefaultLiteral());

            LOG.finest("No qualifers provided for bean class "  beanClass  ", using singleton set of @Default");
        }
        else
        {
            this.qualifiers = new HashSet<Annotation>(qualifiers);
        }

        if (scope == null)
        {
            this.scope = Dependent.class;

            LOG.finest("No scope provided for bean class "  beanClass  ", using @Dependent");
        }
        else
        {
            this.scope = scope;
        }

        if (stereotypes == null)
        {
            this.stereotypes = Collections.emptySet();
        }
        else
        {
            this.stereotypes = new HashSet<Class<? extends Annotation>>(stereotypes);
        }

        if (types == null)
        {
            //noinspection unchecked
            this.types = ArraysUtils.<Type>asSet(Object.class, beanClass);

            LOG.finest("No types provided for bean class "  beanClass
                     ", using [java.lang.Object.class, "  beanClass.getName()
                     ".class]");
        }
        else
        {
            this.types = new HashSet<Type>(types);
        }

        if (injectionPoints == null)
        {
            this.injectionPoints = Collections.emptySet();
        }
        else
        {
            this.injectionPoints = new HashSet<InjectionPoint>(injectionPoints);
        }

        this.alternative = alternative;
        this.nullable = nullable;

        if (toString != null)
        {
            this.toString = toString;
        }
        else
        {
            this.toString = "Custom Bean with bean class "  beanClass  " and qualifiers "  qualifiers;
        }
    }

    @Override
    public Class<?> getBeanClass()
    {
        return beanClass;
    }

    @Override
    public Set<InjectionPoint> getInjectionPoints()
    {
        return injectionPoints;
    }

    @Override
    public String getName()
    {
        return name;
    }

    @Override
    public Set<Annotation> getQualifiers()
    {
        return Collections.unmodifiableSet(qualifiers);
    }

    @Override
    public Class<? extends Annotation> getScope()
    {
        return scope;
    }

    @Override
    public Set<Class<? extends Annotation>> getStereotypes()
    {
        return Collections.unmodifiableSet(stereotypes);
    }

    @Override
    public Set<Type> getTypes()
    {
        return Collections.unmodifiableSet(types);
    }

    @Override
    public boolean isAlternative()
    {
        return alternative;
    }

    @Override
    public boolean isNullable()
    {
        return nullable;
    }

    @Override
    public String toString()
    {
        return toString;
    }
}
public class ImmutableBeanWrapper<T> extends BaseImmutableBean<T>
import org.apache.deltaspike.core.api.interpreter.BasePropertyExpressionInterpreter;
public class PropertyExpressionInterpreter extends BasePropertyExpressionInterpreter
     * name will get picked up and registered as
     * {@link org.apache.deltaspike.core.spi.config.ConfigSource}s.
     * @return the full file name (including path) of the property files to pick up.
    String getPropertyFileName();
                = new EnvironmentPropertyConfigSourceProvider(propertyFileConfig.getPropertyFileName());
    public String getPropertyFileName()
    public String getPropertyFileName()
 *   // alternative to null check in the producer:
 *   // &#064;ConfigProperty(name = "locationId", defaultValue = "LOCATION_X")
 *         return null;
 *         return null;
import org.apache.deltaspike.core.api.projectstage.ProjectStage;
import org.apache.deltaspike.core.util.ProjectStageProducer;
import java.util.logging.Level;
import java.util.logging.Logger;
    private static final Logger LOG = Logger.getLogger(BeanProvider.class.getName());

    private static final boolean LOG_DEPENDENT_WARNINGS;
    static {
        ProjectStage ps = ProjectStageProducer.getInstance().getProjectStage();
        LOG_DEPENDENT_WARNINGS = ps.equals(ProjectStage.Development) || ps.equals(ProjectStage.UnitTest);
    }

        logWarningIfDependent(bean);

     * Log a warning if the produced creational instance is of
     * Scope &#064;Dependent as we cannot properly cleanup
     * the contextual instance afterwards.
     */
    private static void logWarningIfDependent(Bean<?> bean)
    {
        if (LOG_DEPENDENT_WARNINGS && bean.getScope().equals(Dependent.class))
        {
            LOG.log(Level.WARNING, "BeanProvider shall not be used to create @Dependent scoped beans. "
                     "Bean: "  bean.toString());
        }
    }

    /**
        Object mockSession = null;
        if (isServletApiAvailable())
        {
            mockSession = OwbHelper.getMockSession();
        }
        Object mockServletContextEvent = null;
        if (isServletApiAvailable())
        {
            mockServletContextEvent = OwbHelper.getMockServletContextEvent();
        }

        contextFactory.initSingletonContext(mockServletContextEvent);
        contextFactory.initApplicationContext(mockServletContextEvent);
        contextFactory.initSessionContext(mockSession);
    private static boolean isServletApiAvailable()
    {
        try
        {
            Class servletClass = Class.forName("javax.servlet.http.HttpSession");
            return servletClass != null;
        }
        catch (ClassNotFoundException e)
        {
            return false;
        }
    }


        Object mockServletContextEvent = null;
        if (isServletApiAvailable())
        {
            mockServletContextEvent = OwbHelper.getMockServletContextEvent();
        }
        contextFactory.initApplicationContext(mockServletContextEvent);
        Object mockSession = null;
        if (isServletApiAvailable())
        {
            mockSession = OwbHelper.getMockSession();
        }
        contextFactory.initSessionContext(mockSession);
            Object mockServletContextEvent = null;
            if (isServletApiAvailable())
            {
                mockServletContextEvent = OwbHelper.getMockServletContextEvent();
            }
            contextFactory.destroySingletonContext(mockServletContextEvent);
            Object mockServletContextEvent = null;
            if (isServletApiAvailable())
            {
                mockServletContextEvent = OwbHelper.getMockServletContextEvent();
            }
            contextFactory.destroyApplicationContext(mockServletContextEvent);
            Object mockSession = null;
            if (isServletApiAvailable())
            {
                mockSession = OwbHelper.getMockSession();
            }
            contextFactory.destroySessionContext(mockSession);
        return new MockHttpSession("mockSession1");
        return new ServletContextEvent(MockServletContext.getInstance());

import org.apache.deltaspike.core.api.literal.DefaultLiteral;
import org.apache.deltaspike.core.util.ArraysUtils;

import javax.enterprise.context.Dependent;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.InjectionPoint;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.spi.Bean;
 * <p/>
                types, alternative, nullable, bean.getInjectionPoints(), toString);
 * You can easily create instances of this class with the
    private final String id;
import org.apache.deltaspike.core.api.literal.AnyLiteral;
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
import org.apache.deltaspike.core.util.ArraysUtils;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
 * <p/>
        this.delegate = (Bean<T>) delegate;
 * <p/>
                                method, position, getJavaClass()));
                constructorParameters.get(constructor).get(position) != null)
                            constructor.getJavaMember(), new HashMap<Integer, AnnotationBuilder>());
                            constructor.getJavaMember()).put(p.getPosition(), new AnnotationBuilder());
        return (T) annotationMap.get(anType);
import org.apache.deltaspike.core.util.BeanUtils;
import java.lang.annotation.Annotation;
import java.lang.reflect.Member;
import java.lang.reflect.Type;
import java.util.HashSet;
import java.util.Set;
     * @param isTransient   <code>true</code> if the injection point is transient
     * @param isTransient   <code>true</code> if the injection point is transient
     * @param isTransient   <code>true</code> if the injection point is transient
     * @param isTransient   <code>true</code> if the injection point is transient
import org.apache.deltaspike.core.util.metadata.builder.ParameterValueRedefiner.ParameterValue;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
                throw (RuntimeException) e.getCause();
import javax.inject.Singleton;
        Context context = contextFactory.getStandardContext(Singleton.class);
        Context context = contextFactory.getStandardContext(ApplicationScoped.class);
        Context context = contextFactory.getStandardContext(SessionScoped.class);
        Context context = contextFactory.getStandardContext(RequestScoped.class);
        Context context = contextFactory.getStandardContext(ConversationScoped.class);
import java.util.Map;


    /**
     *
     * @return name
     */
    String getName();

    // Attributes

    /**
     * Set attribute with given name and value. Operation will overwrite any previous value.
     * Null value will remove attribute.
     *
     * @param name  of attribute
     * @param value to be set
     */
    void setAttribute(String name, String value);

    /**
     * Set attribute with given name and values. Operation will overwrite any previous values.
     * Null value or empty array will remove attribute.
     *
     * @param name   of attribute
     * @param values to be set
     */
    void setAttribute(String name, String[] values);

    /**
     * Remove attribute with given name
     *
     * @param name of attribute
     */
    void removeAttribute(String name);

    /**
     * @param name of attribute
     * @return attribute values or null if attribute with given name doesn't exist. If given attribute has many values
     *         method will return first one
     */
    String getAttribute(String name);

    /**
     * @param name of attribute
     * @return attribute values or null if attribute with given name doesn't exist
     */
    String[] getAttributeValues(String name);

    /**
     * @return map of attribute names and their values
     */
    Map<String, String[]> getAttributes();

public interface Group extends IdentityType
    /**
     * Group name is unique identifier in specific group tree branch. For example
     * group with id "/acme/departments/marketing" will have name "marketing" and
     * parent group of id "/acme/departments"
     *
     * @return name
     */
    String getName();
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/idm/IdentityType.java
public interface IdentityType
    String getKey();

public interface Role extends IdentityType
    String getName();

public interface User extends IdentityType
    String getId();

    
    /**
     * Tests if the currently authenticated user has permission to perform the specified operation on
     * the specified resource.  This method should be preferred over the overloaded hasPermission() method
     * if a reference to the resource in question is already available.  
     * 
     * @param resource The resource for which the permission is required
     * @param operation The operation that the user wishes to perform on the resource
     * @return true if the current user has the permission.
     */
    boolean hasPermission(Object resource, String operation);
    
    /**
     * As above, however this method should be used when a reference to the resource is not available, or
     * is expensive to retrieve, for example looking up an entity from a relational database.
     * 
     * @param resourceClass The class of the resource
     * @param identifier The identifier of the resource, for example may be a primary key value if an entity
     * @param operation The operation that the user wishes to perform on the resource
     * @return true if the current user has the permission.
     */
    boolean hasPermission(Class<?> resourceClass, Serializable identifier, String operation);
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/credential/LoginCredentials.java
public interface LoginCredentials
import java.util.Date;
    
    void addToGroup(IdentityType identityType, Group group);
    
    void removeFromGroup(IdentityType identityType, Group group);
    Collection<IdentityType> getGroupMembers(Group group);   
    Collection<Role> getRoles(IdentityType identityType, Group group);
    boolean hasRole(Role role, IdentityType identityType, Group group);
    
    void grantRole(Role role, IdentityType identityType, Group group);
    
    void revokeRole(Role role, IdentityType identityType, Group group);
    // Password Management
    
    boolean validatePassword(String password);

    void updatePassword(String password);
    
    // User / Role / Group enablement / expiry

    void setEnabled(IdentityType identityType, boolean enabled);    

    void setExpirationDate(IdentityType identityType, Date expirationDate);    
import java.util.Date;
    
    boolean isEnabled();
    Date getExpirationDate();

    Date getCreationDate();   
    RoleQuery setOwner(IdentityType owner);
    void setLastName(String lastName);
import org.apache.deltaspike.security.api.User;

    private AuthenticationStatus status = AuthenticationStatus.FAILURE;
    private User user;
    
    protected void setUser(User user)
    {
        this.user = user;
    }
    
    public User getUser()
    {
        return user;
    }
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/credential/DefaultLoginCredentials.java
import org.apache.deltaspike.security.api.credential.LoginCredentials;
 * The default LoginCredentials implementation.  This implementation allows for a
@Named("loginCredentials")
public class DefaultLoginCredentials implements LoginCredentials
    
    public String getPassword()
    {        
        return credential != null && credential.getValue() instanceof String ? (String) credential.getValue() : null;
    }

    /**
     * Convenience method that allows a plain text password credential to be set
     */
    public void setPassword(final String password)
    {
        this.credential = new Credential<String>() {
            @Override
            public String getValue()
            {
                return password;
            }
        };
    }
<<<<<<< HEAD
=======
import org.apache.deltaspike.security.api.User;
>>>>>>> added missing files
<<<<<<< HEAD
=======
import org.apache.deltaspike.security.api.credential.LoginCredential;
>>>>>>> added missing files
<<<<<<< HEAD
=======
    private LoginCredential loginCredential;
>>>>>>> added missing files
import org.apache.deltaspike.security.api.idm.User;

import org.apache.deltaspike.security.api.idm.User;
import org.apache.deltaspike.security.api.idm.User;
    private Range() 
    {
    private Range(int offset, int limit) 
    {
    int getPage() 
    {
    public int getOffset() 
    {
    public int getLimit() 
    {
    public Range of(int offset, int limit) 
    {
    public Range next() 
    {
import java.util.Collection;


 * Manages user, role and group permissions. 
    /**
     * 
     * @return A new PermissionQuery
     */
    PermissionQuery createPermissionQuery();
    
    /**
     * 
     * @param permission
     */
    void grantPermission(Permission permission);
    
    /**
     * 
     * @param permission
     */
    void grantPermissions(Collection<Permission> permission);
    
    /**
     * 
     * @param permission
     */
    void revokePermission(Permission permission);
    
    /**
     * 
     * @param permissions
     */
    void revokePermissions(Collection<Permission> permissions);
import org.apache.deltaspike.security.api.idm.User;

import org.apache.deltaspike.security.api.idm.User;
    // User
    User createUser(String name);
    void removeUser(User user);
    User getUser(String name);
    // Group
    Group createGroup(String name, Group parent);
    void removeGroup(Group group);
    Group getGroup(String name);
    // Role
    Role createRole(String name);
    void removeRole(Role role);
    Role getRole(String role);
    // Memberships
    Membership createMembership(Role role, User user, Group group);
    void removeMembership(Role role, User user, Group group);
    Membership getMembership(Role role, User user, Group group);
    // Queries
    List<User> executeQuery(UserQuery query, Range range);
    List<Group> executeQuery(GroupQuery query, Range range);
 
    List<Role> executeQuery(RoleQuery query, Range range);
    List<Membership> executeQuery(MembershipQuery query, Range range);
    // Attributes
    // User
    void setAttribute(User user, String name, String[] values);
    void removeAttribute(User user, String name);
    String[] getAttributeValues(User user, String name);
    Map<String, String[]> getAttributes(User user);
    void setAttribute(Group group, String name, String[] values);
    void removeAttribute(Group group, String name);
    String[] getAttributeValues(Group group, String name);
    Map<String, String[]> getAttributes(Group group);
    void setAttribute(Role role, String name, String[] values);
    void removeAttribute(Role role, String name);
    String[] getAttributeValues(Role role, String name);
    Map<String, String[]> getAttributes(Role role);
import java.util.Collection;
import org.apache.deltaspike.security.api.permission.PermissionQuery;
    List<Permission> getPermissions(PermissionQuery query);
    boolean grantPermissions(Collection<Permission> permissions);
    boolean revokePermissions(Collection<Permission> permissions);
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/permission/annotations/ACLIdentifier.java
package org.apache.deltaspike.security.api.permission.annotations;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
 * Marks the field of an @ACLStore annotated entity bean as containing the identifier value for the
 * resource.
 *
@Target({ METHOD, FIELD })
public @interface ACLIdentifier

 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/permission/annotations/ACLPermission.java
package org.apache.deltaspike.security.api.permission.annotations;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
 * Marker annotation.  Denotes the field of an @ACLStore annotated entity bean as containing the 
 * granted ACL permissions.
 *
@Target({ METHOD, FIELD })
public @interface ACLPermission

 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/permission/annotations/ACLRecipient.java
package org.apache.deltaspike.security.api.permission.annotations;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
 * Marks the field of an @ACLStore annotated entity bean as containing the recipient of the ACL permissions
 *
@Target({ METHOD, FIELD })
public @interface ACLRecipient

 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/permission/annotations/ACLResourceClass.java
package org.apache.deltaspike.security.api.permission.annotations;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
 * Marker annotation.  Denotes the field of an @ACLStore annotated entity bean as containing the 
 * fully qualified class name of the resource being secured
 *
@Target({ METHOD, FIELD })
public @interface ACLResourceClass

 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/permission/annotations/ACLStore.java
package org.apache.deltaspike.security.api.permission.annotations;
<<<<<<< HEAD
=======
>>>>>>> added ACL permission storage annotations, copied reflections utils from Solder (to be merged with DS core later), minor fixes
<<<<<<< HEAD
=======
import org.apache.deltaspike.security.api.credential.LoginCredentials;
import org.apache.deltaspike.security.api.idm.User;
>>>>>>> added ACL permission storage annotations, copied reflections utils from Solder (to be merged with DS core later), minor fixes
<<<<<<< HEAD
=======
    private LoginCredentials loginCredential;
>>>>>>> added ACL permission storage annotations, copied reflections utils from Solder (to be merged with DS core later), minor fixes
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import org.apache.deltaspike.security.api.permission.annotations.ACLStore;
@ApplicationScoped
    private Class<?> generalPermissionStore = null;
    private Map<Class<?>, Class<?>> permissionStoreMap = new HashMap<Class<?>, Class<?>>();
    
    @Inject 
    private Instance<EntityManager> entityManagerInstance;
            final BeanManager beanManager) 
    {
        EntityManager em = entityManagerInstance.get();
        
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import javax.persistence.Query;
import org.apache.deltaspike.security.api.permission.annotations.ACLIdentifier;
import org.apache.deltaspike.security.api.permission.annotations.ACLPermission;
import org.apache.deltaspike.security.api.permission.annotations.ACLRecipient;
import org.apache.deltaspike.security.api.permission.annotations.ACLResourceClass;
import org.apache.deltaspike.security.impl.util.properties.Property;
import org.apache.deltaspike.security.impl.util.properties.query.AnnotatedPropertyCriteria;
import org.apache.deltaspike.security.impl.util.properties.query.PropertyQueries;
    private StoreMetadata generalStore = null;
    private Map<Class<?>, StoreMetadata> storeMap = new HashMap<Class<?>, StoreMetadata>();
    private Instance<EntityManager> entityManagerInstance;    
        if (event.getAnnotatedType().isAnnotationPresent(Entity.class)) 
        {
                    if (generalStore == null)
                        generalStore = new StoreMetadata(type.getJavaClass());
                                "conflicting bean classes: "  generalStore.getStoreClass().getName()  " and " 
                    if (storeMap.containsKey(store.value()))
                                storeMap.get(store.value()).getStoreClass().getName()  " and "  
                                type.getJavaClass().getName());
                        storeMap.put(store.value(), new StoreMetadata(type.getJavaClass()));
            }                
        Map<StoreMetadata, Set<Object>> resourceMetadata = new HashMap<StoreMetadata, Set<Object>>();                
                
        if (query.getResources() != null)
        {            
            for (Object resource : query.getResources()) 
            {
                Class<?> resourceClass = resource.getClass();
                StoreMetadata meta = (storeMap.containsKey(resourceClass)) ? storeMap.get(resourceClass) : generalStore;
                
                if (!resourceMetadata.containsKey(meta))
                {
                    resourceMetadata.put(meta, new HashSet<Object>());
                }
                resourceMetadata.get(meta).add(resource);
            }
        }
        else if (query.getResource() != null)
        {
            Class<?> resourceClass = query.getResource().getClass();
            StoreMetadata meta = (storeMap.containsKey(resourceClass)) ? storeMap.get(resourceClass) : generalStore;
            
            if (!resourceMetadata.containsKey(meta))
            {
                resourceMetadata.put(meta, new HashSet<Object>());
            }
            resourceMetadata.get(meta).add(query.getResource());
        }
                
        if (resourceMetadata.isEmpty())
        {
            // No resources specified in query - we need to query every known permission store and retrieve
            // all permissions for the specified query parameters
            
            for (StoreMetadata meta : storeMap.values())
            {
                Query permissionQuery = buildPermissionQuery(meta, query, em);
                
            }
        }
        else
        {
            List<Permission> results = new ArrayList<Permission>();
            
            // Iterate through each permission store and execute a separate query
            for (StoreMetadata meta : resourceMetadata.keySet())
            {
                Query permissionQuery = buildPermissionQuery(meta, query, em);
            }
        }
                
    
    private Query buildPermissionQuery(StoreMetadata meta, PermissionQuery query, EntityManager em)
    {                
        StringBuilder queryText = new StringBuilder();
        queryText.append("SELECT P FROM ");
        queryText.append(meta.getStoreClass().getName());
        queryText.append(" P WHERE ");
        
        if (query.getRecipient() != null)
        {
            queryText.append(meta.getAclRecipient().getName());
            queryText.append(" = :RECIPIENT");            
        }
        
        Query q = em.createQuery(queryText.toString())
                .setParameter("RECIPIENT", query.getRecipient().getKey());
        
        // TODO apply the range if specified
        
        return q;
    }
    
    private class StoreMetadata
    {
        private Class<?> storeClass;
        private Property<String> aclIdentifier;
        private Property<?> aclPermission;
        private Property<String> aclRecipient;
        private Property<String> aclResourceClass;
        
        public StoreMetadata(Class<?> storeClass)
        {
            this.storeClass = storeClass;
            validateStore();             
        }
        
        private void validateStore()
        {
            aclIdentifier = PropertyQueries.<String>createQuery(storeClass)
                    .addCriteria(new AnnotatedPropertyCriteria(ACLIdentifier.class))
                    .getFirstResult();
            
            if (aclIdentifier == null)
            {
                throw new SecurityConfigurationException("Permission storage class "  storeClass.getName()  
                        " must have a field annotated @ACLIdentifier");
            }
            
            aclPermission = PropertyQueries.createQuery(storeClass)
                    .addCriteria(new AnnotatedPropertyCriteria(ACLPermission.class))
                    .getFirstResult();
            
            if (aclPermission == null)
            {
                throw new SecurityConfigurationException("Permission storage class "  storeClass.getName()  
                        " must have a field annotated @ACLPermission");
            }
            
            aclRecipient = PropertyQueries.<String>createQuery(storeClass)
                    .addCriteria(new AnnotatedPropertyCriteria(ACLRecipient.class))
                    .getFirstResult();
            
            if (aclRecipient == null)
            {
                throw new SecurityConfigurationException("Permission storage class "  storeClass.getName()  
                        " must have a field annotated @ACLRecipient");
            }
            
            aclResourceClass = PropertyQueries.<String>createQuery(storeClass)
                    .addCriteria(new AnnotatedPropertyCriteria(ACLResourceClass.class))
                    .getFirstResult();
        }
        
        public Class<?> getStoreClass()
        {
            return storeClass;
        }
        
        public Property<String> getAclIdentifier()
        {
            return aclIdentifier;
        }
        
        public Property<?> getAclPermission()
        {
            return aclPermission;
        }
        
        public Property<String> getAclRecipient()
        {
            return aclRecipient;
        }
        
        public Property<String> getAclResourceClass()
        {
            return aclResourceClass;
        }
    }    
    public Class<V> getJavaClass() 
    {
    public void setValue(Object instance, V value) 
    {
    public Class<?> getDeclaringClass() 
    {
    public boolean isReadOnly() 
    {
    public void setAccessible() 
    {
    public String toString() 
    {
    public int hashCode() 
    {
    public boolean equals(Object obj) 
    {
    Method getAnnotatedElement();
                throw new IllegalArgumentException(
                        "Invalid accessor method, must have return value if starts with 'get'. Method: "  method);
                throw new IllegalArgumentException(
                        "Invalid accessor method, must have zero arguments if starts with 'get'. Method: "  method);
                throw new IllegalArgumentException(
                        "Invalid accessor method, must not have return value if starts with 'set'. Method: "  method);
                throw new IllegalArgumentException(
                        "Invalid accessor method, must have one argument if starts with 'set'. Method: "  method);
                throw new IllegalArgumentException(
                        "Invalid accessor method, must return boolean primitive if starts with 'is'. Method: "  
                         method);
            throw new IllegalArgumentException(
                    "Invalid accessor method, must start with 'get', 'set' or 'is'.  "  "Method: "  method);
        if (propertyNameInAccessorMethod.length() == 0 || 
                !Character.isUpperCase(propertyNameInAccessorMethod.charAt(0))) 
    public V getValue(Object instance) 
    {
        if (getterMethod == null) 
        {
            throw new UnsupportedOperationException("Property "  
                this.setterMethod.getDeclaringClass()  "."  propertyName  
                " cannot be read, as there is no getter method.");
        if (setterMethod == null) 
        {
            throw new UnsupportedOperationException("Property "  
                this.getterMethod.getDeclaringClass()  "."  propertyName  
                " is read only, as there is no setter method.");
                    if (Introspector.decapitalize(
                            methodName.substring(BOOLEAN_GETTER_METHOD_PREFIX_LENGTH)).equals(name)) 
            } 
            else 
            throw new IllegalArgumentException("Cannot make a property of "  
                member  " - it is neither a method or a field");
public class AnnotatedPropertyCriteria implements PropertyCriteria 
{
    public AnnotatedPropertyCriteria(Class<? extends Annotation> annotationClass) 
    {
    public boolean fieldMatches(Field f) 
    {
    public boolean methodMatches(Method m) 
    {
public class NamedPropertyCriteria implements PropertyCriteria 
{
    public NamedPropertyCriteria(String... propertyNames) 
    {
    public boolean fieldMatches(Field f) 
    {
        for (String propertyName : propertyNames) 
        {
            if (propertyName.equals(f.getName())) 
            {
                return true;
            }
    public boolean methodMatches(Method m) 
    {
        for (String propertyName : propertyNames) 
        {
                    Introspector.decapitalize(m.getName().substring(3)).equals(propertyName)) 
            {
                return true;
            }
public interface PropertyCriteria 
{
public class PropertyQueries 
{
    private PropertyQueries() 
    {
    public static <V> PropertyQuery<V> createQuery(Class<?> targetClass) 
    {
            throw new RuntimeException(
                    "Expected one property match, but the criteria did not match any properties on "  
                    targetClass.getName());
            throw new RuntimeException("Expected one property match, but the criteria matched "  results.size()  
                    " properties on "  targetClass.getName());
            throw new RuntimeException(
                 "Expected one property match, but the criteria did not match any properties on "  
                 targetClass.getName());
            throw new RuntimeException("Expected one property match, but the criteria matched "  
                 results.size()  " properties on "  targetClass.getName());
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
public class HierarchyDiscovery 
{
    public HierarchyDiscovery(Type type) 
    {
    protected void add(Class<?> clazz, Type type) 
    {
    public Set<Type> getTypeClosure() 
    {
        if (types == null) 
        {
    private void init() 
    {
        try 
        {
        } 
        catch (StackOverflowError e) 
        {
    public Type getResolvedType() 
    {
        if (type instanceof Class<?>) 
        {
    private void discoverTypes(Type type) 
    {
        if (type != null) 
        {
            if (type instanceof Class<?>) 
            {
            } 
            else 
            {
                if (type instanceof ParameterizedType) 
                {
                    if (rawType instanceof Class<?>) 
                    {
    private Type resolveType(Class<?> clazz) 
    {
        if (clazz.getTypeParameters().length > 0) 
        {
            ParameterizedType parameterizedType = new ParameterizedTypeImpl(
                    clazz, actualTypeParameters, clazz.getDeclaringClass());
        } 
        else 
        {
    private void discoverFromClass(Class<?> clazz) 
    {
        for (Type c : clazz.getGenericInterfaces()) 
        {
    private Type resolveType(Type beanType, Type beanType2, Type type) 
    {
        if (type instanceof ParameterizedType) 
        {
            if (beanType instanceof ParameterizedType) 
            {
            if (beanType instanceof Class<?>) 
            {
        if (type instanceof TypeVariable<?>) 
        {
            if (beanType instanceof ParameterizedType) 
            {
            if (beanType instanceof Class<?>) 
            {
    private Type resolveParameterizedType(ParameterizedType beanType, ParameterizedType parameterizedType) 
    {
        for (int i = 0; i < actualTypes.length; i) 
        {
    private Type resolveTypeParameter(ParameterizedType type, Type beanType, TypeVariable<?> typeVariable) 
    {
        for (int i = 0; i < typeVariables.length; i) 
        {
            if (typeVariables[i].equals(typeVariable) && !actualTypes[i].equals(typeVariable)) 
            {
        if (!(resolvedGenericSuperType instanceof TypeVariable<?>)) 
        {
        if (beanType instanceof ParameterizedType) 
        {
            for (Type interfaceType : ((Class<?>) ((ParameterizedType) beanType).getRawType()).getGenericInterfaces()) 
            {
                if (!(resolvedType instanceof TypeVariable<?>)) 
                {
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
public class ParameterizedTypeImpl implements ParameterizedType 
{
    public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type ownerType) 
    {
    public Type[] getActualTypeArguments() 
    {
    public Type getOwnerType() 
    {
    public Type getRawType() 
    {
    public int hashCode() 
    {
        return Arrays.hashCode(actualTypeArguments) ^ (ownerType == null ? 0 : 
            ownerType.hashCode()) ^ (rawType == null ? 0 : rawType.hashCode());
    public boolean equals(Object obj) 
    {
        if (this == obj) 
        {
        } 
        else if (obj instanceof ParameterizedType) 
        {
            return (ownerType == null ? thatOwnerType == null : 
                ownerType.equals(thatOwnerType)) && (rawType == null ? thatRawType == null : 
                    rawType.equals(thatRawType)) && Arrays.equals(actualTypeArguments, that.getActualTypeArguments());
        } 
        else 
        {
    public String toString() 
    {
        if (actualTypeArguments.length > 0) 
        {
            for (Type actualType : actualTypeArguments) 
            {
    
    private Reflections() 
    {
    }    
            if (annotatedField.getDeclaringType().getJavaClass().equals(
                    field.getDeclaringClass()) && annotatedField.getJavaMember().getName().equals(field.getName())) 
    public static Set<Annotation> getAnnotationsWithMetaAnnotation(
            Set<Annotation> annotations, Class<? extends Annotation> metaAnnotationType) 
        try 
        {
            throw new ClassNotFoundException("Could not load class "  name  
                    " with the context class loader "  Thread.currentThread().getContextClassLoader().toString()  
                    " or any of the additional ClassLoaders: "  Arrays.toString(loaders));
            throw new ClassNotFoundException("Could not load class "  name  
                    " using Class.forName or using any of the additional ClassLoaders: "  
                    Arrays.toString(loaders));
        StringBuilder message = new StringBuilder(
                String.format("Exception invoking method [%s] on object [%s], using arguments [", 
                        method.getName(), obj));
    public static <T> T invokeMethod(boolean setAccessible, Method method, 
            Class<T> expectedReturnType, Object instance, Object... args) 
            ExceptionInInitializerError e2 = new ExceptionInInitializerError(
                    buildInvokeMethodErrorMessage(method, instance, args));
            ExceptionInInitializerError e2 = new ExceptionInInitializerError(
                    buildSetFieldValueErrorMessage(field, instance, value));
            ExceptionInInitializerError e2 = new ExceptionInInitializerError(
                    buildGetFieldValueErrorMessage(field, instance));
    public static boolean isAssignableFrom(Class<?> rawType1, Type[] actualTypeArguments1, 
            Class<?> rawType2, Type[] actualTypeArguments2) 
        return Types.boxedClass(rawType1).isAssignableFrom(Types.boxedClass(rawType2)) && 
                isAssignableFrom(actualTypeArguments1, actualTypeArguments2);
    public static boolean matches(Class<?> rawType1, Type[] actualTypeArguments1, 
            Class<?> rawType2, Type[] actualTypeArguments2) 
        return Types.boxedClass(rawType1).equals(Types.boxedClass(rawType2)) && 
                isAssignableFrom(actualTypeArguments1, actualTypeArguments2);
                if (isAssignableFrom((Class<?>) parameterizedType1.getRawType(), 
                        parameterizedType1.getActualTypeArguments(), type2)) 
        if (type2 instanceof WildcardType) 
        {
                if (matches((Class<?>) parameterizedType1.getRawType(), 
                        parameterizedType1.getActualTypeArguments(), type2)) 
     * Check the assignability of a set of <b>flattened</b> types. This
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
public class SetAccessiblePriviligedAction implements PrivilegedAction<Void> 
{
    public SetAccessiblePriviligedAction(AccessibleObject member) 
    {
    public Void run() 
    {
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
    private Types() 
    { 
        
    }
    
    /**
     * Gets the boxed type of a class
     *
     * @param type The type
     * @return The boxed type
     */
    public static Type boxedType(Type type)
    {
        if (type instanceof Class<?>)
        {
            return boxedClass((Class<?>) type);
        }
        else
        {
            return type;
        }
    }
    public static Class<?> boxedClass(Class<?> type)
    {
        if (!type.isPrimitive())
        {
            return type;
        }
        else if (type.equals(Boolean.TYPE))
        {
            return Boolean.class;
        }
        else if (type.equals(Character.TYPE))
        {
            return Character.class;
        }
        else if (type.equals(Byte.TYPE))
        {
            return Byte.class;
        }
        else if (type.equals(Short.TYPE))
        {
            return Short.class;
        }
        else if (type.equals(Integer.TYPE))
        {
            return Integer.class;
        }
        else if (type.equals(Long.TYPE))
        {
            return Long.class;
        }
        else if (type.equals(Float.TYPE))
        {
            return Float.class;
        }
        else if (type.equals(Double.TYPE))
        {
            return Double.class;
        }
        else if (type.equals(Void.TYPE))
        {
            return Void.class;
        }
        else
        {
            // Vagaries of if/else statement, can't be reached ;-)
            return type;
        }
    }
{       
    private InMemoryUserStorage() { }    
    
import org.apache.deltaspike.security.api.credential.LoginCredentials;
    private LoginCredentials loginCredential;
@Target({ TYPE, METHOD })
    public boolean doSecuredCheck(@MockParamBinding MockObject obj, InvocationContext invocationContext) 
        throws Exception
@Target({ TYPE, METHOD })
    private ArchiveUtils() { }
    
        if (includeIfPackageExists == null) 
        {
        try 
        {
            for (ZipEntry jarEntry = jar.getNextEntry(); jarEntry != null; jarEntry = jar.getNextEntry()) 
            {
                if (jarEntry.isDirectory()) 
                {
                    if (excludeIfPackageExists(entryName, excludeIfPackageExists)) 
                    {
                    if (ret == null && includeIfPackageExists(entryName, includeIfPackageExists)) 
                    {
                if (entryName.endsWith(".class")) 
                {
                else 
                {
        finally 
        {
            try 
            {
            catch (IOException ignored) 
            {
            throws IOException 
    {
        if (!archiveBasePath.exists()) 
        {
        if (includeIfPackageExists == null) 
        {
        for (File archiveEntry : collectArchiveEntries(archiveBasePath) ) 
        {
            if (excludeIfPackageExists(entryName, excludeIfPackageExists)) 
            {
            if (ret == null && includeIfPackageExists(entryName, includeIfPackageExists)) 
            {
            if (entryName.endsWith(".class")) 
            {
            else 
            {
        if (archiveBasePath.isDirectory()) 
        {
            for (File file : files) 
            {
                if (file.isDirectory()) 
                {
                else 
                {
    private static boolean excludeIfPackageExists(String jarEntryName, String[] excludeOnPackages) 
    {
        if (excludeOnPackages != null) 
        {
            for (String excludeOnPackage : excludeOnPackages) 
            {
                if (packageName.startsWith(excludeOnPackage))
                {
    private static boolean includeIfPackageExists(String jarEntryName, String[] includeOnPackages) 
    {
        if (includeOnPackages == null ) 
        {
        for (String includeOnPackage : includeOnPackages) 
        {
            if (packageName.startsWith(includeOnPackage)) 
            {
    private static String isJarUrl(String urlPath) 
    {
        if (urlPath.endsWith("!/") && jarColon > 0) 
        {
    private static String ensureCorrectUrlFormat(String url) 
    {
        if(!url.startsWith("file:/")) 
        {
    private static String pathToClassName(String pathName) 
    {
import org.apache.deltaspike.security.api.credential.LoginCredentials;
import org.apache.deltaspike.security.impl.idm.SimpleUser;
    private LoginCredentials credentials;
        if ("shane".equals(credentials.getUserId()) &&
                "password".equals(credentials.getCredential().getValue()))
            setUser(new SimpleUser("shane"));
import java.io.Serializable;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

import org.apache.deltaspike.security.api.permission.annotations.ACLStore;

@ACLStore
@Entity
public class ObjectPermission implements Serializable 
{
    private static final long serialVersionUID = 2386489292457994509L;
    
    @Id @GeneratedValue
    private Long id;
    
    public Long getId()
    {
        return id;
    }
    
    public void setId(Long id)
    {
        this.id = id;
    }
    Class<?> value() default GENERAL.class;
    
    // Dummy class to enable the entity bean for general storage of ACL permissions
    static final class GENERAL 
    { }
import org.apache.deltaspike.security.impl.extension.SecurityExtension;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/extension/SecurityExtension.java
package org.apache.deltaspike.security.impl.extension;
import org.apache.deltaspike.security.impl.authorization.Authorizer;
import org.apache.deltaspike.security.impl.authorization.SecurityInterceptorBinding;
import org.apache.deltaspike.security.impl.authorization.SecurityInterceptorBindingLiteral;
import org.apache.deltaspike.security.impl.authorization.SecurityMetaDataStorage;
import org.apache.deltaspike.security.impl.authorization.SecurityUtils;
import org.apache.deltaspike.security.impl.util.SecurityUtils;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/extension/Authorizer.java
package org.apache.deltaspike.security.impl.extension;
import org.apache.deltaspike.security.impl.authorization.SecurityParameterValueRedefiner;
import org.apache.deltaspike.security.impl.util.SecurityUtils;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/extension/DefaultSecurityStrategy.java
package org.apache.deltaspike.security.impl.extension;
import org.apache.deltaspike.security.impl.util.SecurityUtils;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/extension/SecurityInterceptor.java
package org.apache.deltaspike.security.impl.extension;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/extension/SecurityInterceptorBinding.java
package org.apache.deltaspike.security.impl.extension;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/extension/SecurityInterceptorBindingLiteral.java
package org.apache.deltaspike.security.impl.extension;

 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/extension/SecurityMetaDataStorage.java
package org.apache.deltaspike.security.impl.extension;
import org.apache.deltaspike.security.impl.util.SecurityUtils;
 b/deltaspike/modules/security/impl/src/main/java/org/apache/deltaspike/security/impl/util/SecurityUtils.java
package org.apache.deltaspike.security.impl.util;
public abstract class SecurityUtils
    public static boolean isMetaAnnotatedWithSecurityBindingType(Annotation annotation)
    public static Annotation resolveSecurityBindingType(Annotation annotation)
    public static List<Annotation> getAllAnnotations(Annotation[] annotations)
    private InMemoryUserStorage() 
    { }    
    private boolean value;
    public MockObject(boolean value)
    {
        this.value = value;
    }
    public boolean isValue()
    {
        return value;
    }
    public void setValue(boolean value)
    {
        this.value = value;
    }
@Target({ PARAMETER })
    private ArchiveUtils() 
    { }
    
    private ShrinkWrapArchiveUtil()
    { }
    
                    "<class>org.apache.deltaspike.security.impl.extension.SecurityInterceptor</class>" 
        if (classLoader == null) 
        {
        try 
        {
            while (foundFiles.hasMoreElements()) 
            {
                JavaArchive archive = createArchive(foundFile, markerFile, includeIfPackageExists, 
                        excludeIfPackageExists);
                if (archive != null) 
                {
        catch (IOException ioe) 
        {
        throws IOException 
    {
            final JavaArchive foundJar = ShrinkWrap.createFromZipFile(JavaArchive.class, 
                    new File(URI.create(jarUrlPath)));
                    if (foundJar.contains(excludePackage.replaceAll("\\.", "\\/"))) 
                    {
                    String className = pathToClassName(
                            entryName.substring(0, entryName.length() - (".class".length())));
        throws IOException 
                String className = pathToClassName(entryName.substring(0, entryName.length() - (".class".length())));
        if (!url.startsWith("file:/")) 
import org.apache.deltaspike.security.api.idm.SimpleUser;
import org.apache.deltaspike.security.api.permission.annotations.ACLIdentifier;
import org.apache.deltaspike.security.api.permission.annotations.ACLPermission;
import org.apache.deltaspike.security.api.permission.annotations.ACLRecipient;
    @ACLIdentifier
    private Long identifier;
    
    @ACLRecipient
    private String recipient;
    
    @ACLPermission
    private String permission;
    
    
    public Long getIdentifier()
    {
        return identifier;
    }
    
    public void setIdentifier(Long identifier)
    {
        this.identifier = identifier;
    }
    
    public String getRecipient()
    {
        return recipient;
    }
    
    public void setRecipient(String recipient)
    {
        this.recipient = recipient;
    }
    
    public String getPermission()
    {
        return permission;
    }
    
    public void setPermission(String permission)
    {
        this.permission = permission;
    }
import org.apache.deltaspike.security.api.permission.annotations.ACLIdentifier;
import org.apache.deltaspike.security.api.permission.annotations.ACLPermission;
import org.apache.deltaspike.security.api.permission.annotations.ACLRecipient;
    @ACLIdentifier
    private String identifier;
    
    @ACLRecipient
    private String recipient;
    
    @ACLPermission
    private String permission;
    
    
    public String getIdentifier()
    {
        return identifier;
    }
    
    public void setIdentifier(String identifier)
    {
        this.identifier = identifier;
    }
    
    public String getRecipient()
    {
        return recipient;
    }
    
    public void setRecipient(String recipient)
    {
        this.recipient = recipient;
    }
    
    public String getPermission()
    {
        return permission;
    }
    
    public void setPermission(String permission)
    {
        this.permission = permission;
    }
    
    public String toString()
    {
        return String.format("%d: %s %s", id, firstName, lastName);
    }
 * 
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/idm/AbstractIdentityType.java
package org.apache.deltaspike.security.api.idm;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/idm/SimpleGroup.java
package org.apache.deltaspike.security.api.idm;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/idm/SimpleRole.java
package org.apache.deltaspike.security.api.idm;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/idm/SimpleUser.java
package org.apache.deltaspike.security.api.idm;
import org.apache.deltaspike.security.spi.permission.PermissionStore;
    private PermissionStore permissionStore;
    
    public PermissionQuery(PermissionStore permissionStore)
    {
        this.permissionStore = permissionStore;
    }
    
    public PermissionQuery setResource(Object resource)
        return this;
    public PermissionQuery setResources(Set<Object> resources)
        return this;
    public PermissionQuery setRange(Range range)
        return this;
    public PermissionQuery setRecipient(IdentityType recipient)
        return this;
        return permissionStore.getPermissions(this);
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import org.apache.deltaspike.security.spi.permission.PermissionStore;
@ApplicationScoped
    @Inject
    PermissionStore permissionStore;
        PermissionQuery q = new PermissionQuery(permissionStore);
        return q;
import org.apache.deltaspike.security.impl.permission.JPAPermissionStoreConfig.StoreMetadata;
public class JPAPermissionStore implements PermissionStore
{   
    @Inject 
    private JPAPermissionStoreConfig config;
                StoreMetadata meta = (config.getStores().containsKey(resourceClass)) ? 
                        config.getStores().get(resourceClass) : config.getGeneralStore();
            StoreMetadata meta = (config.getStores().containsKey(resourceClass)) ? 
                    config.getStores().get(resourceClass) : config.getGeneralStore();
            for (StoreMetadata meta : config.getStores().values())
        Map<String,Object> paramValues = new HashMap<String,Object>();
        
        if (query.getResource() != null)
        {
            queryText.append(meta.getAclIdentifier().getName());
            queryText.append(" = :IDENTIFIER");
            // TODO determine the identifier value
            paramValues.put("IDENTIFIER", null);
        }
        else if (query.getResources() != null)
        {
            
        }
        
            queryText.append(" = :RECIPIENT");      
            paramValues.put("RECIPIENT", query.getRecipient().getKey());
        Query q = em.createQuery(queryText.toString());
        
        for (String param : paramValues.keySet())
        {
            q.setParameter(param, paramValues.get(param));
        }            
     
import javax.enterprise.context.SessionScoped;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
import javax.inject.Named;

                EntityTransaction transaction = getTransaction(entityManager);
                    EntityTransaction transaction = getTransaction(em);
                        EntityTransaction transaction = getTransaction(em);
                        EntityTransaction transaction = getTransaction(em);
    /**
     * @param entityManager current entity-manager
     * @return per default the {@link EntityTransaction} of the given {@link EntityManager}.
     * A subclass can also return an adapter e.g. for an UserTransaction
     */
    protected EntityTransaction getTransaction(EntityManager entityManager)
    {
        return entityManager.getTransaction();
    }

            if (System.getSecurityManager() != null)
            {
                AccessController.doPrivileged(new SetAccessiblePrivilegedAction(method));
            }
            else
            {
                method.setAccessible(true);
            }

            if (System.getSecurityManager() != null)
            {
                AccessController.doPrivileged(new SetAccessiblePrivilegedAction(field));
            }
            else
            {
                field.setAccessible(true);
            }

            if (System.getSecurityManager() != null)
            {
                AccessController.doPrivileged(new SetAccessiblePrivilegedAction(method));
            }
            else
            {
                method.setAccessible(true);
            }
 * It's only useful if {@link System#getSecurityManager()} returns a {@link SecurityManager}.
    public static RuntimeException throwAsRuntimeException(Throwable throwable)
        return null; //not needed due to the helper trick, but it's easier for using it
            for (Class<? extends Annotation> emQualifier : emQualifiers)
                EntityManager entityManager = resolveEntityManagerForQualifier(emQualifier);

                transactionBeanStorage.storeUsedEntityManager(emQualifier, entityManager);

                ems.add(entityManager);


                //don't move it before EntityTransaction#begin() and invoke it in any case
                prepareEntityManager(entityManager);
    protected void prepareEntityManager(EntityManager entityManager)
    {
        //override if needed
    }


                    boolean rollbackOnly = false;

                                    if (!rollbackOnly && transaction.getRollbackOnly())
                                    {
                                        //don't set commitFailed to true directly
                                        //(the order of the entity-managers isn't deterministic -> tests would break)
                                        rollbackOnly = true;
                                    }
                    if (rollbackOnly)
                    {
                        commitFailed = true;
                    }
                                if (commitFailed || transaction.getRollbackOnly() /*last chance to check it (again)*/)
                                    transaction.rollback();
                                    transaction.commit();
            if (commitFailed && firstException != null /*null if just #getRollbackOnly is true*/)
import org.apache.deltaspike.jpa.impl.transaction.context.EntityManagerEntry;
import org.apache.deltaspike.jpa.impl.transaction.context.JtaEntityManagerEntry;
import java.lang.annotation.Annotation;
    protected static final String USER_TRANSACTION_JNDI_NAME = "java:comp/UserTransaction";

    @Override
    protected EntityManagerEntry createEntityManagerEntry(
        EntityManager entityManager, Class<? extends Annotation> qualifier)
    {
        return new JtaEntityManagerEntry(entityManager, qualifier);
    }
    protected EntityTransaction getTransaction(EntityManagerEntry entityManagerEntry)
        return new UserTransactionAdapter(entityManagerEntry.getEntityManager());
     * @param entityManagerEntry entry of the current entity-manager
    protected void beforeProceed(EntityManagerEntry entityManagerEntry)
        entityManagerEntry.getEntityManager().joinTransaction();
import org.apache.deltaspike.jpa.impl.transaction.context.EntityManagerEntry;

                EntityManagerEntry entityManagerEntry = createEntityManagerEntry(entityManager, emQualifier);
                transactionBeanStorage.storeUsedEntityManager(entityManagerEntry);
                EntityTransaction transaction = getTransaction(entityManagerEntry);
                beforeProceed(entityManagerEntry);
                Set<EntityManagerEntry> entityManagerEntryList =
                    transactionBeanStorage.getUsedEntityManagerEntries();

                for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
                    EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
                    Set<EntityManagerEntry> entityManagerEntryList =
                        transactionBeanStorage.getUsedEntityManagerEntries();
                    for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
                        EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
                                    currentEntityManagerEntry.getEntityManager().flush();
                    for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
                        EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
                onCloseTransactionScope();
    protected EntityManagerEntry createEntityManagerEntry(
        EntityManager entityManager, Class<? extends Annotation> qualifier)
    {
        return new EntityManagerEntry(entityManager, qualifier);
    }

     *
     * @param entityManagerEntry entry of the current entity-manager
    protected EntityTransaction getTransaction(EntityManagerEntry entityManagerEntry)
        return entityManagerEntry.getEntityManager().getTransaction();
    protected void beforeProceed(EntityManagerEntry entityManagerEntry)
    protected void onCloseTransactionScope()
    {
        //override if needed
    }

import java.util.HashSet;
import java.util.Set;
        private Set<EntityManagerEntry> ems = new HashSet<EntityManagerEntry>();
    public void storeUsedEntityManager(EntityManagerEntry entityManagerEntry)
        currentTci.ems.add(entityManagerEntry);
    public Set<EntityManagerEntry> getUsedEntityManagerEntries()
 * transaction controlled by {@link Transactional}. The context will get started when the outermost
 *          if (em.isOpen()) //this check is optional -not needed if #close doesn't get called by the transactional bean
 *          {
 *              em.close();
 *          }
 *      }
 *  }
 * </pre>
 * </p>
 * or
 * <p>
 * <pre>
 *  &#064;Dependent
 *  public class EntityManagerProducer
 *  {
 *      private &#064;PersistenceUnit(unitName = "test") EntityManagerFactory entityManagerFactory;
 *
 *      public &#064;Produces &#064;TransactionScoped EntityManager createEntityManager()
 *      {
 *          return entityManagerFactory.createEntityManager();
 *      }
 *
 *      public void closeEntityManager(&#064;Disposes EntityManager em)
 *      {
 *          if (em.isOpen()) //this check is optional -not needed if #close doesn't get called by the transactional bean
 *          {
 *              em.close();
 *          }
 * <p>
 * Furthermore, it's possible to use different persistence-units with (simple) qualifiers
 * (for the producer- and dispose-methods and therefore also at the injection-points).
 * </p>
 *
 * <p>
 * It's also possible to use &#064;Transactional and &#064;TransactionScoped in an application-server.
 * Therefore it's only needed to configure one of the {@link org.apache.deltaspike.jpa.spi.PersistenceStrategy}s which
 * support JTA.
 * </p>
 * <p/>
 * Further details can be found at {@link TransactionScoped} which is an optional scope which can be used together with
 * &#064;Transactional.
 * This implementation uses a different approach for the auto-detection which can be used for environments
 * (or producer-constellations) which allow a mixed usage of JTA and RESOURCE_LOCAL.
 * (Within a transactional call it isn't possible to mix different transaction-types.)
 *
 * @see EnvironmentAwarePersistenceStrategy
 * persistent-unit-transaction-type 'RESOURCE_LOCAL' only).</p>
     * Needed because the {@link EntityManager} might get created outside of the {@link UserTransaction}
     * (e.g. depending on the implementation of the producer).
     * needs to be called for every {@link EntityManager}.
 * It requires additional logic in the producer for the {@link EntityManager} to create the {@link EntityManager}
 * for the correct persistence-unit. In case of a project-stage based logic
 * {@link org.apache.deltaspike.core.api.exclude.annotation.Exclude} can be used to switch between different
 * producer-beans.
 * {@link org.apache.deltaspike.core.api.exclude.annotation.Exclude} at the custom
 * {@link org.apache.deltaspike.jpa.spi.PersistenceStrategy}
 * Therefore it's only needed to configure one of the {@link org.apache.deltaspike.jpa.spi.TransactionStrategy}s which
 b/deltaspike/modules/jpa/api/src/main/java/org/apache/deltaspike/jpa/spi/TransactionStrategy.java
public interface TransactionStrategy extends InterceptorStrategy
 b/deltaspike/modules/jpa/impl/src/main/java/org/apache/deltaspike/jpa/impl/transaction/AdvancedEnvironmentAwareTransactionStrategy.java
 * This alternative {@link org.apache.deltaspike.jpa.spi.TransactionStrategy} uses auto-detection and
 * @see EnvironmentAwareTransactionStrategy
public class AdvancedEnvironmentAwareTransactionStrategy extends EnvironmentAwareTransactionStrategy
        Logger.getLogger(AdvancedEnvironmentAwareTransactionStrategy.class.getName());
                    "you could also use the default strategy "  ResourceLocalTransactionStrategy.class.getName());
 b/deltaspike/modules/jpa/impl/src/main/java/org/apache/deltaspike/jpa/impl/transaction/BeanManagedUserTransactionTransactionStrategy.java
 * <p>{@link org.apache.deltaspike.jpa.spi.TransactionStrategy} for using JTA (bean-managed-)transactions
 * The basic features are identical to the {@link ResourceLocalTransactionStrategy} (for
public class BeanManagedUserTransactionTransactionStrategy extends ResourceLocalTransactionStrategy
     * Can't be in {@link BeanManagedUserTransactionTransactionStrategy.UserTransactionAdapter#begin()}
     * because {@link ResourceLocalTransactionStrategy} needs to do
     * and {@link BeanManagedUserTransactionTransactionStrategy.UserTransactionAdapter#isActive()}
     * {@link BeanManagedUserTransactionTransactionStrategy.UserTransactionAdapter#begin()}
                //2nd check (already done by #isActive triggered by ResourceLocalTransactionStrategy directly before)
 b/deltaspike/modules/jpa/impl/src/main/java/org/apache/deltaspike/jpa/impl/transaction/EnvironmentAwareTransactionStrategy.java
 * This alternative {@link org.apache.deltaspike.jpa.spi.TransactionStrategy} uses a simple auto-detection
 * {@link BeanManagedUserTransactionTransactionStrategy}
 * {@link org.apache.deltaspike.jpa.spi.TransactionStrategy}
public class EnvironmentAwareTransactionStrategy extends BeanManagedUserTransactionTransactionStrategy
        Logger.getLogger(EnvironmentAwareTransactionStrategy.class.getName());
 b/deltaspike/modules/jpa/impl/src/main/java/org/apache/deltaspike/jpa/impl/transaction/ResourceLocalTransactionStrategy.java
import org.apache.deltaspike.jpa.spi.TransactionStrategy;
 * <p>Default implementation of our plugable TransactionStrategy.
 * <p>If you like to implement your own TransactionStrategy, then use the
public class ResourceLocalTransactionStrategy implements TransactionStrategy
    private static final Logger LOGGER = Logger.getLogger(ResourceLocalTransactionStrategy.class.getName());
    private TransactionStrategyHelper transactionHelper;
        Transactional transactionalAnnotation = transactionHelper.extractTransactionalAnnotation(invocationContext);
        Set<Class<? extends Annotation>> emQualifiers = transactionHelper.resolveEntityManagerQualifiers(
 b/deltaspike/modules/jpa/impl/src/main/java/org/apache/deltaspike/jpa/impl/transaction/TransactionStrategyHelper.java
 * {@link org.apache.deltaspike.jpa.spi.TransactionStrategy}.
public class TransactionStrategyHelper implements Serializable
import org.apache.deltaspike.jpa.spi.TransactionStrategy;
 * {@link org.apache.deltaspike.jpa.spi.TransactionStrategy}.
    private TransactionStrategy transactionStrategy;
     * A {@link org.apache.deltaspike.jpa.spi.TransactionStrategy} is allowed to begin the transaction lazily but
        return transactionStrategy.execute(invocationContext);
import org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder;
 * @see SimpleEnvironmentAwareTransactionStrategy
public class AdvancedEnvironmentAwareTransactionStrategy extends SimpleEnvironmentAwareTransactionStrategy
 b/deltaspike/modules/jpa/impl/src/main/java/org/apache/deltaspike/jpa/impl/transaction/SimpleEnvironmentAwareTransactionStrategy.java
public class SimpleEnvironmentAwareTransactionStrategy extends BeanManagedUserTransactionTransactionStrategy
        Logger.getLogger(SimpleEnvironmentAwareTransactionStrategy.class.getName());
 b/deltaspike/modules/jpa/impl/src/main/java/org/apache/deltaspike/jpa/impl/transaction/EnvironmentAwareTransactionStrategy.java
public class EnvironmentAwareTransactionStrategy extends SimpleEnvironmentAwareTransactionStrategy
        Logger.getLogger(EnvironmentAwareTransactionStrategy.class.getName());
    private boolean isActivated = true;
    private Boolean isActivated = true;
    protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
        isActivated = ClassDeactivationUtils.isActivated(getClass());
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
    private Boolean isActivated = true;
    private Boolean isGlobalAlternativeActivated = true;
    private Boolean isCustomProjectStageBeanFilterActivated = true;

    @SuppressWarnings("UnusedDeclaration")
    protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
    {
        isActivated =
                ClassDeactivationUtils.isActivated(getClass());

        isGlobalAlternativeActivated =
                ClassDeactivationUtils.isActivated(GlobalAlternative.class);

        isCustomProjectStageBeanFilterActivated =
                ClassDeactivationUtils.isActivated(CustomProjectStageBeanFilter.class);
    }
    private Boolean isActivated = true;
        isActivated = ClassDeactivationUtils.isActivated(getClass());
    private Boolean isActivated = true;
    protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
        isActivated = ClassDeactivationUtils.isActivated(getClass());
    protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
    {
        isActivated = ClassDeactivationUtils.isActivated(getClass());
    }

 b/deltaspike/modules/jpa/impl/src/main/java/org/apache/deltaspike/jpa/impl/transaction/BeanManagedUserTransactionStrategy.java
import org.apache.deltaspike.jpa.impl.transaction.context.JtaAwareEntityManagerEntry;
public class BeanManagedUserTransactionStrategy extends ResourceLocalTransactionStrategy
        return new JtaAwareEntityManagerEntry(entityManager, qualifier);
     * Can't be in {@link BeanManagedUserTransactionStrategy.UserTransactionAdapter#begin()}
     * and {@link BeanManagedUserTransactionStrategy.UserTransactionAdapter#isActive()}
     * {@link BeanManagedUserTransactionStrategy.UserTransactionAdapter#begin()}
import org.apache.deltaspike.jpa.impl.transaction.context.JtaAwareEntityManagerEntry;
        return new JtaAwareEntityManagerEntry(entityManager, qualifier, isTransactionTypeJta);
import org.apache.deltaspike.jpa.impl.transaction.context.JtaAwareEntityManagerEntry;
 * {@link BeanManagedUserTransactionStrategy}
public class SimpleEnvironmentAwareTransactionStrategy extends BeanManagedUserTransactionStrategy
            return new JtaAwareEntityManagerEntry(entityManager, qualifier, false);
        if (((JtaAwareEntityManagerEntry)entityManagerEntry).isTransactionTypeJta())
        if (((JtaAwareEntityManagerEntry)entityManagerEntry).isTransactionTypeJta())
 b/deltaspike/modules/jpa/impl/src/main/java/org/apache/deltaspike/jpa/impl/transaction/context/JtaAwareEntityManagerEntry.java
public class JtaAwareEntityManagerEntry extends EntityManagerEntry
    public JtaAwareEntityManagerEntry(EntityManager entityManager, Class<? extends Annotation> qualifier)
    public JtaAwareEntityManagerEntry(
import java.util.logging.Level;
import java.util.logging.Logger;
    private static final Logger LOGGER = Logger.getLogger(BeanManagedUserTransactionStrategy.class.getName());

        applyTransactionTimeout(); //needs to be done before UserTransaction#begin - TODO move this call
    protected void applyTransactionTimeout()
    {
        Integer transactionTimeout = getDefaultTransactionTimeoutInSeconds();

        if (transactionTimeout == null)
        {
            //the default configured for the container will be used
            return;
        }

        try
        {
            UserTransaction userTransaction = resolveUserTransaction();
            userTransaction.setTransactionTimeout(transactionTimeout);
        }
        catch (SystemException e)
        {
            LOGGER.log(Level.WARNING, "UserTransaction#setTransactionTimeout failed", e);
        }
    }

    protected Integer getDefaultTransactionTimeoutInSeconds()
    {
        //override it and provide a custom value - if needed - TODO discuss a type-safe module-config for DELTASPIKE-256
        return null;
    }

    protected UserTransaction resolveUserTransaction()
    {
        return JndiUtils.lookup(USER_TRANSACTION_JNDI_NAME, UserTransaction.class);
    }

            this.userTransaction = resolveUserTransaction();
        if (isTransactionTypeJta)
        {
            applyTransactionTimeout(); //needs to be done before UserTransaction#begin - TODO move this call
        }
 b/deltaspike/modules/jpa/api/src/main/java/org/apache/deltaspike/jpa/api/transaction/TransactionHelper.java
package org.apache.deltaspike.jpa.api.transaction;
 b/deltaspike/modules/jpa/api/src/main/java/org/apache/deltaspike/jpa/api/transaction/TransactionScoped.java
package org.apache.deltaspike.jpa.api.transaction;
 * Therefore it's only needed to configure one of the
 * {@link org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy}s which support JTA.
 b/deltaspike/modules/jpa/api/src/main/java/org/apache/deltaspike/jpa/api/transaction/Transactional.java
package org.apache.deltaspike.jpa.api.transaction;
 b/deltaspike/modules/jpa/api/src/main/java/org/apache/deltaspike/jpa/spi/transaction/TransactionStrategy.java
package org.apache.deltaspike.jpa.spi.transaction;
 * Marker interface for a plugable strategy for {@link org.apache.deltaspike.jpa.api.transaction.Transactional}.
 * <p>{@link org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy} for using JTA (bean-managed-)transactions
 * This alternative {@link org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy} uses auto-detection and
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy;
 * This alternative {@link org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy} uses a simple auto-detection
 * {@link org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy}
import org.apache.deltaspike.jpa.api.transaction.Transactional;
 * {@link org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy}.
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy;
 * {@link org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy}.
     * A {@link org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy}
     * is allowed to begin the transaction lazily but it has to support nested interceptor calls.
 * &#064;{@link org.apache.deltaspike.jpa.api.transaction.TransactionScoped}
import org.apache.deltaspike.jpa.api.transaction.TransactionScoped;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
 * CDI Context for managing &#064;{@link org.apache.deltaspike.jpa.api.transaction.TransactionScoped}
 * contextual instances.
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.TransactionScoped;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import javax.persistence.EntityTransaction;
 * <p>This alternative {@link org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy} uses auto-detection and
 * can be used for different (parallel) persistence-units which use different transaction-types or
 * if different environments (dev., prod.,...) should use different transaction-types.</p>
 * <p>This implementation can be used for environments which allow a mixed usage of JTA and RESOURCE_LOCAL.
 * (Within a transactional call it isn't possible to mix different transaction-types.)</p>
 * <p>Optional:<br/>
 * E.g. in case of a project-stage based logic
 * {@link org.apache.deltaspike.core.api.exclude.annotation.Exclude} can be used to switch between different
 * producer-beans.</p>
 *
 * <p>It's a better alternative than extending
 * {@link BeanManagedUserTransactionStrategy}
 * (which would lead to an impl. dependency) only for using
 * {@link org.apache.deltaspike.core.api.exclude.annotation.Exclude} at the custom
 * {@link org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy}
 * (or doing a custom veto-extension).</p>
public class EnvironmentAwareTransactionStrategy extends BeanManagedUserTransactionStrategy
    /**
     * {@inheritDoc}
     */
    @Override
    protected void beforeProceed(EntityManagerEntry entityManagerEntry)
    {
        //cast without check is valid, because the entry was created by this class - see #createEntityManagerEntry
        if (((JtaAwareEntityManagerEntry)entityManagerEntry).isTransactionTypeJta())
        {
            super.beforeProceed(entityManagerEntry);
        }
    }

    @Override
    protected EntityTransaction getTransaction(EntityManagerEntry entityManagerEntry)
    {
        if (((JtaAwareEntityManagerEntry)entityManagerEntry).isTransactionTypeJta())
        {
            return super.getTransaction(entityManagerEntry);
        }

        return entityManagerEntry.getEntityManager().getTransaction();
    }

                beanStoreHolder.set(ProxyUtils.createProxy(BeanStore.class, new BeanStoreFilter(beanStore)));
import org.apache.deltaspike.core.impl.util.ProxyUtils;
import java.io.Serializable;
import static org.apache.deltaspike.core.util.ReflectionUtils.getRawType;
        return ProxyUtils.createProxy(getRawType(injectionPoint.getType()), new MessageBundleInvocationHandler());
         *     <li>transactionKey identifies the 'database qualifier'</li>
                beanStoreHolder.set(new BeanStore()
                {
                    @Override
                    public <T> ContextualInstance<T> get(String id)
                    {
                        return beanStore.get(id);
                    }

                    @Override
                    public boolean contains(String id)
                    {
                        return beanStore.contains(id);
                    }

                    @Override
                    public void clear()
                    {
                        //do nothing
                    }

                    @Override
                    public Iterator<String> iterator()
                    {
                        return beanStore.iterator();
                    }

                    @Override
                    public <T> void put(String id, ContextualInstance<T> contextualInstance)
                    {
                        beanStore.put(id, contextualInstance);
                    }
                });
import static org.apache.deltaspike.core.util.ReflectionUtils.getRawType;

import java.io.Serializable;
import java.lang.reflect.Proxy;
import org.apache.deltaspike.core.util.ClassUtils;
        return createMessageBundleProxy(getRawType(injectionPoint.getType()));
    }

    private <T> T createMessageBundleProxy(Class<T> type)
    {
        return type.cast(Proxy.newProxyInstance(ClassUtils.getClassLoader(null),
                new Class<?>[]{type}, new MessageBundleInvocationHandler()));
        return new UserTransactionAdapter();
        public UserTransactionAdapter()
        return super.createEntityManagerEntry(entityManager, qualifier);
        return new EntityManagerEntry(entityManager, qualifier);
        if (this.isJtaModeDetected.get())
        if (this.isJtaModeDetected.get())
            isTransactionTypeJta = isInJtaTransaction();
        if (isInJtaTransaction())
        if (isInJtaTransaction())

    private static boolean isInJtaTransaction()
    {
        return Boolean.TRUE.equals(isJtaModeDetected.get());
    }
    //TODO DELTASPIKE-259 - use the annotation itself  calculate a key for #hashCode and #equals
 * (Within a transactional call it isn't possible to mix different transaction-types.)<b/>
 *
 * E.g.: in an application-server this class allows to use a persistence-unit with
 * transaction-type="RESOURCE_LOCAL"  non-jta-data-source
 * in parallel to a persistence-unit with
 * transaction-type="JTA"  jta-data-source</p>
//TODO depending on further discussions about an own JTA module, BeanManagedUserTransactionStrategy
//could be the default (via @Specializes) in the ds-jta module.
//Depending on further discussions this class can be merged with BeanManagedUserTransactionStrategy or
//we keep BeanManagedUserTransactionStrategy separated as a small tweak for applications which only use JTA transactions
//or as a base implementation for a custom EnvironmentAwareTransactionStrategy.
import org.jboss.weld.context.AbstractSharedContext;
        // Welds ApplicationContext is always active
            if (applicationContext instanceof AbstractSharedContext)
                ((AbstractSharedContext) applicationContext).getBeanStore().clear();
        if (lifecycle == null)
            return null;
        lifecycle = WebBeansContext.currentInstance().getService(ContainerLifecycle.class);

        Object mockServletContextEvent = null;
        if (OpenWebBeansContextControl.isServletApiAvailable())
        {
            mockServletContextEvent = OwbHelper.getMockServletContextEvent();
        }

        lifecycle.startApplication(mockServletContextEvent);
            Object mockServletContextEvent = null;
            if (OpenWebBeansContextControl.isServletApiAvailable())
            {
                mockServletContextEvent = OwbHelper.getMockServletContextEvent();
            }

            lifecycle.stopApplication(mockServletContextEvent);
        lifecycle = null;
import org.apache.webbeans.spi.ContextsService;
        ContextsService contextsService = getContextsService();
        startSingletonScope();
        startApplicationScope();
        startSessionScope();
        startRequestScope();
        startConversationScope();
    static boolean isServletApiAvailable()
    private void startSingletonScope()
        ContextsService contextsService = getContextsService();
        Object mockServletContext = null;
            mockServletContext = OwbHelper.getMockServletContext();
        contextsService.startContext(Singleton.class, mockServletContext);
    }

    private void startApplicationScope()
    {
        ContextsService contextsService = getContextsService();
        Object mockServletContext = null;
        if (isServletApiAvailable())
        {
            mockServletContext = OwbHelper.getMockServletContext();
        }
        contextsService.startContext(ApplicationScoped.class, mockServletContext);
        ContextsService contextsService = getContextsService();
        contextsService.startContext(SessionScoped.class, mockSession);
        ContextsService contextsService = getContextsService();
        contextsService.startContext(RequestScoped.class, null);
        ContextsService contextsService = getContextsService();
        contextsService.startContext(ConversationScoped.class, null);
        ContextsService contextsService = getContextsService();
        Object mockServletContext = null;
        if (isServletApiAvailable())
            mockServletContext = OwbHelper.getMockServletContext();
        contextsService.endContext(Singleton.class, mockServletContext);
        ContextsService contextsService = getContextsService();
        Object mockServletContext = null;
        if (isServletApiAvailable())
            mockServletContext = OwbHelper.getMockServletContext();
        contextsService.endContext(ApplicationScoped.class, mockServletContext);
        ContextsService contextsService = getContextsService();
        Object mockSession = null;
        if (isServletApiAvailable())
            mockSession = OwbHelper.getMockSession();
        contextsService.endContext(SessionScoped.class, mockSession);
        ContextsService contextsService = getContextsService();
        contextsService.endContext(RequestScoped.class, null);
        ContextsService contextsService = getContextsService();
        contextsService.endContext(ConversationScoped.class, null);
    private ContextsService getContextsService()
        WebBeansContext webBeansContext = WebBeansContext.currentInstance();
        return webBeansContext.getContextsService();
    public static Object getMockServletContext()
    {
        return MockServletContext.getInstance();
    }


    public static boolean isServletApiAvailable()
    {
        try
        {
            Class servletClass = Class.forName("javax.servlet.http.HttpSession");
            return servletClass != null;
        }
        catch (ClassNotFoundException e)
        {
            return false;
        }
    }

    private static CdiContainer cdiContainer = null;

    public static synchronized CdiContainer getCdiContainer()
        if (cdiContainer == null)
        {
            // there is no dependency to any cdi implementation, we do all dynamically
            ServiceLoader<CdiContainer> cdiContainerLoader = ServiceLoader.load(CdiContainer.class);
            Iterator<CdiContainer> cdiIt = cdiContainerLoader.iterator();
            if (cdiIt.hasNext())
            {
                cdiContainer = cdiIt.next();
            }
            else
            {
                throw new IllegalStateException("Could not find an implementation of "  CdiContainer.class.getName() 
                    " available in the classpath!");
            }
            if (cdiIt.hasNext())
            {
                String foundContainers = getContainerDetails();
                throw new IllegalStateException("Too many implementations of "  CdiContainer.class.getName() 
                    " found in the classpath! Details: "  foundContainers);
            }
        return cdiContainer;
    private Bean<ContextControl> ctxCtrlBean = null;
    private CreationalContext<ContextControl> ctxCtrlCreationalContext = null;
        if (weldContainer == null)
        {
            return null;
        }

    public synchronized void boot()
    public synchronized  void shutdown()
        if (ctxCtrl != null)
        {
            ctxCtrlBean.destroy(ctxCtrl, ctxCtrlCreationalContext);
        }

        weld = null;
        ctxCtrl = null;
        ctxCtrlBean = null;
        ctxCtrlCreationalContext = null;

    public synchronized ContextControl getContextControl()
            ctxCtrlBean = (Bean<ContextControl>) getBeanManager().resolve(beans);
            ctxCtrlCreationalContext = getBeanManager().createCreationalContext(ctxCtrlBean);

        ctxCtrl = null;
        ctxCtrlBean = null;
        ctxCtrlCreationalContext = null;
        beanManager = null;
    Authorizer(Annotation bindingAnnotation, AnnotatedMethod<?> boundAuthorizerMethod)
    void authorize(final InvocationContext ic, BeanManager beanManager)
            lazyInitTargetBean(beanManager);
    private synchronized void lazyInitTargetBean(BeanManager beanManager)
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
    @Inject
    private BeanManager beanManager;

            authorizer.authorize(invocationContext, this.beanManager);
        Authorizer authorizer = new Authorizer(binding, annotatedMethod);
 * @deprecated we shall rather introduce an own QualifierMap or a ComparableQualifier which checks Nonbinding
            boundAuthorizerBean = beanManager.resolve(beans);

            if (boundAuthorizerBean == null)
                    registerAuthorizer(m);
    private void registerAuthorizer(AnnotatedMethod<?> annotatedMethod)
    public <X> void processAnnotatedType(@Observes ProcessAnnotatedType<X> event)
    @SuppressWarnings({ "unchecked" })
    @Inject
    private SecurityExtension securityExtension;

        SecurityMetaDataStorage metaDataStorage = securityExtension.getMetaDataStorage();
    private SecurityMetaDataStorage securityMetaDataStorage;
        securityMetaDataStorage = new SecurityMetaDataStorage();
    public SecurityMetaDataStorage getMetaDataStorage()
    private static Boolean isOwbDetected = false;
    private boolean isActivated = true;
    private boolean isGlobalAlternativeActivated = true;
    private boolean isCustomProjectStageBeanFilterActivated = true;

        isOwbDetected = isOpenWebBeans();
    private boolean isOpenWebBeans()
        IllegalStateException runtimeException = new IllegalStateException();

        for (StackTraceElement element : runtimeException.getStackTrace())
            if (element.toString().contains("org.apache.webbeans."))
                return true;

        return false;
        protected boolean isTransactionAllowedToRollback() throws SystemException
            //if the following gets changed, it needs to be tested with different constellations
            //(normal exception, timeout,...) as well as servers
            return  this.userTransaction.getStatus() != Status.STATUS_COMMITTED &&
                    this.userTransaction.getStatus() != Status.STATUS_NO_TRANSACTION &&
                    this.userTransaction.getStatus() != Status.STATUS_UNKNOWN;
        protected boolean isTransactionReadyToCommit() throws SystemException
    public void verifyInjectionPoints(@Observes final AfterDeploymentValidation afterDeploymentValidation,
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/context/ContextualInstanceInfo.java
import java.io.Serializable;
public class ContextualInstanceInfo<T> implements Serializable
    private T contextualInstance;
     * {@link javax.enterprise.context.spi.Contextual#destroy(Object, javax.enterprise.context.spi.CreationalContext)}
    private CreationalContext<T> creationalContext;

    public ContextualInstanceInfo(CreationalContext<T> creationalContext, T contextualInstance)
    /**
     * @return the CreationalContext of the bean
     */
    public CreationalContext<T> getCreationalContext()
        return creationalContext;
    /**
     * @return the contextual instance itself
     */
    public T getContextualInstance()


import javax.enterprise.context.ContextNotActiveException;
    protected AbstractContext(Class<? extends Annotation> scope)
    protected abstract ContextualStorage getContextualStorage();
    public <T> T get(Contextual<T> bean)
        checkActive();

        if (getContextualStorage() == null)
        {
            return null;
        }

        Map<Contextual<?>, ContextualInstanceInfo<?>> contextMap = getContextualStorage().getStorage();
        ContextualInstanceInfo<?> contextualInstanceInfo = contextMap.get(bean);
        if (contextualInstanceInfo == null)
        {
            return null;
        }

        return (T) contextualInstanceInfo.getContextualInstance();
    public <T> T get(Contextual<T> bean, CreationalContext<T> creationalContext)
        checkActive();

        ContextualStorage storage = getContextualStorage();

        Map<Contextual<?>, ContextualInstanceInfo<?>> contextMap = storage.getStorage();
        ContextualInstanceInfo<?> contextualInstanceInfo = contextMap.get(bean);

        T instance = null;

        if (contextualInstanceInfo != null)
        {
            instance =  (T) contextualInstanceInfo.getContextualInstance();
        }

        if (instance != null)
        {
            return instance;
        }

        return storage.createContextualInstance(bean, creationalContext);
        ContextualInstanceInfo<?> contextualInstanceInfo = getContextualStorage().getStorage().get(bean);
        Map<Contextual<?>, ContextualInstanceInfo<?>> storage = getContextualStorage().getStorage();
    protected void checkActive()
    {
        if (!isActive())
        {
            throw new ContextNotActiveException("CDI context with scope annotation @"
                 scope.getName()  " is not active with respect to the current thread");
        }
    }


     * @param creationalContext the CreationalContext of the bean
     */
    public void setCreationalContext(CreationalContext<T> creationalContext)
    {
        this.creationalContext = creationalContext;
    }

    /**
    /**
     * @param contextualInstance the contextual instance itself
     */
    public void setContextualInstance(T contextualInstance)
    {
        this.contextualInstance = contextualInstance;
    }
import javax.enterprise.context.spi.CreationalContext;
    /**
     * @param beanManager is needed for serialisation
     * @param concurrent whether the ContextualStorage might get accessed concurrently by different threads
     */
    /**
     * @return the underlying storage map.
     */
     * Whether the ContextualStorage might get accessed concurrently by different threads
     */
    public boolean isConcurrent()
    {
        return concurrent;
    }

    /**
    /**
     *
     * @param bean
     * @param creationalContext
     * @param <T>
     * @return
     */
    public <T> T createContextualInstance(Contextual<T> bean, CreationalContext<T> creationalContext)
    {
        if (isConcurrent())
        {
            // locked approach
            ContextualInstanceInfo<T> instanceInfo = new ContextualInstanceInfo<T>();

            ConcurrentHashMap<Contextual<?>, ContextualInstanceInfo<?>> concurrentMap
                = (ConcurrentHashMap<Contextual<?>, ContextualInstanceInfo<?>>) contextualInstances;

            ContextualInstanceInfo<T> oldInstanceInfo
                = (ContextualInstanceInfo<T>) concurrentMap.putIfAbsent(bean, instanceInfo);

            if (oldInstanceInfo != null)
            {
                instanceInfo = oldInstanceInfo;
            }
            synchronized (instanceInfo)
            {
                T instance = instanceInfo.getContextualInstance();
                if (instance == null)
                {
                    instance = bean.create(creationalContext);
                    instanceInfo.setContextualInstance(instance);
                    instanceInfo.setCreationalContext(creationalContext);
                }

                return instance;
            }

        }
        else
        {
            // simply create the contextual instance
            ContextualInstanceInfo<T> instanceInfo = new ContextualInstanceInfo<T>();
            instanceInfo.setCreationalContext(creationalContext);
            instanceInfo.setContextualInstance(bean.create(creationalContext));

            contextualInstances.put(bean, instanceInfo);

            return instanceInfo.getContextualInstance();
        }
    }
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.PassivationCapable;
 * An implementing Context needs to implement the missing methods from the
 * {@link Context} interface and {@link #getContextualStorage(boolean)}.
     * Whether the Context is for a passivating scope.
    private boolean isPassivatingScope;
    protected AbstractContext(BeanManager beanManager)
        isPassivatingScope = beanManager.isPassivatingScope(getScope());
     * @parm createIfNotExist whether a ContextualStorage shall get created if it doesn't yet exist.
    protected abstract ContextualStorage getContextualStorage(boolean createIfNotExist);
        ContextualStorage storage = getContextualStorage(false);
        if (storage == null)
        Map<Contextual<?>, ContextualInstanceInfo<?>> contextMap = storage.getStorage();
        if (isPassivatingScope)
        {
            if (!(bean instanceof PassivationCapable))
            {
                throw new IllegalStateException(bean.toString() 
                        " doesn't implement "  PassivationCapable.class.getName());
            }
        }

        ContextualStorage storage = getContextualStorage(true);
        ContextualStorage storage = getContextualStorage(false);
        if (storage == null)
        {
            return false;
        }
        ContextualInstanceInfo<?> contextualInstanceInfo = storage.getStorage().get(bean);
     * destroys all the Contextual Instances in the Storage returned by
     * {@link #getContextualStorage(boolean)}.
    public void destroyAllActive()
        ContextualStorage storage = getContextualStorage(false);
        if (storage == null)
        {
            return;
        }

        Map<Contextual<?>, ContextualInstanceInfo<?>> contextMap = storage.getStorage();
        for (Map.Entry<Contextual<?>, ContextualInstanceInfo<?>> entry : contextMap.entrySet())
                 getScope().getName()  " is not active with respect to the current thread");
import javax.enterprise.inject.spi.BeanManager;
    public MockViewScopedContext(BeanManager beanManager)
    {
        super(beanManager);
    }

import org.apache.deltaspike.core.util.context.AbstractContext;
import org.apache.deltaspike.core.util.context.ContextualStorage;
public class ViewScopedContext extends AbstractContext implements SystemEventListener
    private static final String CONTEXTUAL_MAP_NAME = "deltaspike.contextualInstanceMap";
    private BeanManager beanManager;

    public ViewScopedContext(BeanManager beanManager)
        super(beanManager);
        this.beanManager = beanManager;
    @Override
    protected ContextualStorage getContextualStorage(boolean createIfNotExists)
    {
        Map<String, Object> viewMap = getViewMap();
        ContextualStorage storage = (ContextualStorage) viewMap.get(CONTEXTUAL_MAP_NAME);

        if (storage == null && createIfNotExists)
        {
            storage = new ContextualStorage(beanManager, false);
            viewMap.put(CONTEXTUAL_MAP_NAME, storage);
        }

        return storage;
    }

    @Override
    public <T> T get(Contextual<T> bean)
    {
        subscribeToJsf();

        return super.get(bean);
    }


    public <T> T get(Contextual<T> bean, CreationalContext<T> creationalContext)
        subscribeToJsf();
        return super.get(bean, creationalContext);
    private void subscribeToJsf()
        if (!isJsfSubscribed)
            FacesContext.getCurrentInstance().getApplication().subscribeToEvent(PreDestroyViewMapEvent.class, this);

            isJsfSubscribed = true;

            destroyAllActive();
import javax.enterprise.inject.spi.BeanManager;
    public void registerViewContext(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
            afterBeanDiscovery.addContext(new MockViewScopedContext(beanManager));
            afterBeanDiscovery.addContext(new ViewScopedContext(beanManager));
        afterBeanDiscovery.addContext(new ViewScopedContext(beanManager));
    /**
     * javax.faces.bean.ViewScoped is no CDI Scope.
     * We need to add it programmatically to CDI.
     */
    /**
     * Register and start the ViewScopedContext.
     */
/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements. See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership. The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License. You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied. See the License for the
* specific language governing permissions and limitations
* under the License.
*/
/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements. See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership. The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License. You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied. See the License for the
* specific language governing permissions and limitations
* under the License.
*/
        excludedFiles = new String[]{"META-INF.apache-deltaspike.properties"};
import org.apache.deltaspike.test.utils.ShrinkWrapArchiveUtil;
import org.apache.deltaspike.test.utils.ShrinkWrapArchiveUtil;

    private ArchiveUtils()
    {
        // private ct
    }

import org.apache.deltaspike.test.utils.ShrinkWrapArchiveUtil;
    {
        // private ct
    }
 b/deltaspike/test-utils/src/main/java/org/apache/deltaspike/test/utils/ShrinkWrapArchiveUtil.java
package org.apache.deltaspike.test.utils;



    {
        // private ct for utility class
    }

        if (classLoader == null)
        try
            while (foundFiles.hasMoreElements())
                JavaArchive archive
                    = createArchive(foundFile, markerFile, includeIfPackageExists, excludeIfPackageExists);
                if (archive != null)
        catch (IOException ioe)
        throws IOException
            JavaArchive foundJar = ShrinkWrap.createFromZipFile(JavaArchive.class, new File(URI.create(jarUrlPath)));
                    if (foundJar.contains(excludePackage.replaceAll("\\.", "\\/")))
        throws IOException
        if (includeIfPackageExists == null)
        try
            for (ZipEntry jarEntry = jar.getNextEntry(); jarEntry != null; jarEntry = jar.getNextEntry())
                if (jarEntry.isDirectory())
                    if (excludeIfPackageExists(entryName, excludeIfPackageExists))
                    if (ret == null && includeIfPackageExists(entryName, includeIfPackageExists))
                if (entryName.endsWith(".class"))
                    String className
                        = pathToClassName(entryName.substring(0, entryName.length() - (".class".length())));
                else
        finally
            try
            catch (IOException ignored)
        throws IOException
        if (!archiveBasePath.exists())
        if (includeIfPackageExists == null)
        for (File archiveEntry : collectArchiveEntries(archiveBasePath) )
            if (excludeIfPackageExists(entryName, excludeIfPackageExists))
            if (ret == null && includeIfPackageExists(entryName, includeIfPackageExists))
            if (entryName.endsWith(".class"))
                String className
                    = pathToClassName(entryName.substring(0, entryName.length() - (".class".length())));
            else
        if (archiveBasePath.isDirectory())
            for (File file : files)
                if (file.isDirectory())
                else
    private static boolean excludeIfPackageExists(String jarEntryName, String[] excludeOnPackages)
        if (excludeOnPackages != null)
            for (String excludeOnPackage : excludeOnPackages)
    private static boolean includeIfPackageExists(String jarEntryName, String[] includeOnPackages)
        if (includeOnPackages == null )
        for (String includeOnPackage : includeOnPackages)
            if (packageName.startsWith(includeOnPackage))
    private static String isJarUrl(String urlPath)
        if (urlPath.endsWith("!/") && jarColon > 0)
    private static String ensureCorrectUrlFormat(String url)
        if (!url.startsWith("file:/"))
    private static String pathToClassName(String pathName)


import javax.enterprise.inject.spi.BeanManager;
     * @param beanManager The BeanManager to use
    void notify(ExceptionEvent<T> event, BeanManager beanManager);
import org.apache.deltaspike.core.api.exception.control.HandlerMethod;
                        handler.notify(callbackEvent, beanManager);
                        handler.notify(depthFirstEvent, beanManager);
import org.apache.deltaspike.core.api.exception.control.HandlerMethod;
import org.apache.deltaspike.core.util.metadata.builder.ImmutableInjectionPoint;
import org.apache.deltaspike.core.util.metadata.builder.InjectableMethod;
    private final Class declaringBeanClass;
    private final Bean<?> declaringBean;
    public HandlerMethodImpl(final Bean<?> handlerDeclaringBean, final AnnotatedMethod<?> method, final BeanManager bm)
        declaringBean = handlerDeclaringBean;
        declaringBeanClass = method.getJavaMember().getDeclaringClass();
    public Bean<?> getDeclaringBean()
        return declaringBean;
    public void notify(final ExceptionEvent<T> event, BeanManager beanManager)
            ctx = beanManager.createCreationalContext(null);
            Object handlerInstance = BeanProvider.getContextualReference(declaringBeanClass);
            InjectableMethod<?> im = createInjectableMethod(handler, getDeclaringBean(), beanManager);
    private <X> InjectableMethod<X> createInjectableMethod(AnnotatedMethod<X> handlerMethod, Bean<?> bean,
                                                           BeanManager bm)
        return new InjectableMethod<X>(handlerMethod, bean, bm);
    /**
     * Obtain all the injection points for the handler
     *
     * @param bm a BeanManager to use to obtain the beans
     */
    public Set<InjectionPoint> getInjectionPoints(final BeanManager bm)
                            new ImmutableInjectionPoint(param, bm, getDeclaringBean(), false, false));
        int result = declaringBeanClass.hashCode();
import org.apache.deltaspike.core.util.metadata.builder.ParameterValueRedefiner;
        declaringBean = handlerMethod.getDeclaringBean();
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
                    registerHandlerMethod(new HandlerMethodImpl(processBean.getBean(), method, beanManager));
     * @param bm  BeanManager instance
                                      final BeanManager bm)
                for (InjectionPoint ip : ((HandlerMethodImpl<? extends Throwable>) handler).getInjectionPoints(bm))
                        bm.validate(ip);
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.deltaspike.test.category.WebProfileCategory;
import org.jboss.arquillian.ajocado.framework.GrapheneSelenium;
import org.jboss.shrinkwrap.api.ShrinkWrap;
        // we also need quite some internal Arquillian classes on the client side
        JavaArchive grapheneJar = ShrinkWrap
                .create(JavaArchive.class, "graphene.jar")
                .addPackage(GrapheneSelenium.class.getPackage())
                .addPackage(WebProfileCategory.class.getPackage());
        JavaArchive[] coreArchives = ShrinkWrapArchiveUtil.getArchives(null,
                 "META-INF/beans.xml",
                 new String[]{"org.apache.deltaspike.core", "org.apache.deltaspike.jsf"}, excludedFiles);

        List<JavaArchive> archives = new ArrayList<JavaArchive>(Arrays.asList(coreArchives));
        archives.add(grapheneJar);
        return archives.toArray(new JavaArchive[archives.size()]);
        // this JAR has NO beans.xml to prevent class scanning!
    private boolean passivatingScope;
        passivatingScope = beanManager.isPassivatingScope(getScope());
    /**
     * @return whether the served scope is a passivating scope
     */
    public boolean isPassivatingScope()
    {
        return passivatingScope;
    }
        Map<Object, ContextualInstanceInfo<?>> contextMap = storage.getStorage();
        ContextualInstanceInfo<?> contextualInstanceInfo = contextMap.get(storage.getBeanKey(bean));
        if (passivatingScope)
        Map<Object, ContextualInstanceInfo<?>> contextMap = storage.getStorage();
        ContextualInstanceInfo<?> contextualInstanceInfo = contextMap.get(storage.getBeanKey(bean));
        ContextualInstanceInfo<?> contextualInstanceInfo = storage.getStorage().get(storage.getBeanKey(bean));
        Map<Object, ContextualInstanceInfo<?>> contextMap = storage.getStorage();
        for (Map.Entry<Object, ContextualInstanceInfo<?>> entry : contextMap.entrySet())
            Contextual bean = storage.getBean(entry.getKey());

    private Map<Object, ContextualInstanceInfo<?>> contextualInstances;
    private boolean passivationCapable;

     * @param passivationCapable whether the storage is for passivation capable Scopes
    public ContextualStorage(BeanManager beanManager, boolean concurrent, boolean passivationCapable)
        this.passivationCapable = passivationCapable;
            contextualInstances = new ConcurrentHashMap<Object, ContextualInstanceInfo<?>>();
            contextualInstances = new HashMap<Object, ContextualInstanceInfo<?>>();
    public Map<Object, ContextualInstanceInfo<?>> getStorage()
        Object beanKey = getBeanKey(bean);
            ConcurrentHashMap<Object, ContextualInstanceInfo<?>> concurrentMap
                = (ConcurrentHashMap<Object, ContextualInstanceInfo<?>>) contextualInstances;
                = (ContextualInstanceInfo<T>) concurrentMap.putIfAbsent(beanKey, instanceInfo);
            contextualInstances.put(beanKey, instanceInfo);

    /**
     * If the context is a passivating scope then we return
     * the passivationId of the Bean. Otherwise we use
     * the Bean directly.
     * @return the key to use in the context map
     */
    public <T> Object getBeanKey(Contextual<T> bean)
    {
        if (passivationCapable)
        {
            // if the
            return ((PassivationCapable) bean).getId();
        }

        return bean;
    }

    /**
     * Restores the Bean from it's beanKey.
     * @see #getBeanKey(javax.enterprise.context.spi.Contextual)
     */
    public Contextual<?> getBean(Object beanKey)
    {
        if (passivationCapable)
        {
            return beanManager.getPassivationCapableBean((String) beanKey);
        }
        else
        {
            return (Contextual<?>) beanKey;
        }
    }
 * Non passivating scoped test context
            storage = new ContextualStorage(beanManager, concurrent, isPassivatingScope());
            storage = new ContextualStorage(beanManager, false, isPassivatingScope());
 b/deltaspike/modules/jsf/impl/src/test/java/org/apache/deltaspike/test/jsf/impl/util/ArchiveUtils.java
package org.apache.deltaspike.test.jsf.impl.util;
                .create(JavaArchive.class, "deltaspikeUtils.jar")
                .addClass(ArchiveUtils.class)
                .addPackages(true, "org.jboss.arquillian.graphene")
                .addPackages(true, "org.jboss.arquillian.ajocado")
        JavaArchive[] coreArchives = ShrinkWrapArchiveUtil.getArchives(null
                , "META-INF/beans.xml"
                , new String[]{ "org.apache.deltaspike.core"
                              , "org.apache.deltaspike.jsf" }
                , excludedFiles);
                .addPackages(true, "org.openqa.selenium")
    /**
     * Renders the Message to a String, using the {@link MessageContext}
     * which created the Message.
     * While resolving the message we will
     * first search for a messageTemplate with the given category by
     * just adding a dot '.' and the category String to the
     * {@link #getTemplate()}.
     * If no such a template exists we will fallback to the version
     * without the category String
     */
    String toString(String category);

    /**
     * Renders the Message to a String, using an
     * arbitrary {@link MessageContext}.
     * While resolving the message we will
     * first search for a messageTemplate with the given category by
     * just adding a dot '.' and the category String to the
     * {@link #getTemplate()}.
     * If no such a template exists we will fallback to the version
     * without the category String
     */
    String toString(MessageContext messageContext, String category);




        return toString((String) null);
    }

    @Override
    public String toString(String category)
    {
        return toString(messageContext, null);
    }

    @Override
    public String toString(MessageContext messageContext, String category)
    {
                .toString(category);
                continue;

            deploymentErrors.add(currentMethod.getReturnType().getName()  " isn't supported. Details: " 
                    currentMethod.getDeclaringClass().getName()  "#"  currentMethod.getName() 
                    " only "  String.class.getName()  " or "  Message.class.getName());
            ok = false;
     *
     * @param category the sub-category of the message, e.g. 'longText'. Can be <code>null</code>
    String getMessage(MessageContext messageContext, String messageTemplate, String category);
            String resolvedTemplate = messageResolver.getMessage(messageContext, template, category);

    public String getMessage(MessageContext messageContext, String messageTemplate, String category)
                    if (category != null && category.length() > 0)
                    {
                        try
                        {
                            return messageBundle.getString(resourceKey  "."  category);
                        }
                        catch (MissingResourceException e)
                        {
                            // we fallback on the version without the category
                            messageBundle.getString(resourceKey);
                        }
                    }

 * TODO This class should get moved to ShrinkWrap itself!
                javaArchive.addAsResource(archiveEntry, entryName.replace('\\', '/'));
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.deltaspike.test.category.WebProfileCategory;
import org.apache.deltaspike.test.core.api.context.DummyContext;
import org.apache.deltaspike.test.core.api.context.DummyScopeExtension;
import org.apache.deltaspike.test.core.api.context.DummyScoped;
import org.jboss.shrinkwrap.api.ShrinkWrap;
        // we also need quite some internal Arquillian classes on the client side
        // this JAR has NO beans.xml to prevent class scanning!
        JavaArchive extensionsJar = ShrinkWrap
                .create(JavaArchive.class, "testExtensions.jar")
                .addClass(ArchiveUtils.class)
                .addClass(DummyScopeExtension.class)
                .addClass(DummyScoped.class)
                .addClass(DummyContext.class)
                .addPackage(WebProfileCategory.class.getPackage());

        JavaArchive[] coreArchives = ShrinkWrapArchiveUtil.getArchives(null,

        List<JavaArchive> archives = new ArrayList<JavaArchive>(Arrays.asList(coreArchives));
        archives.add(extensionsJar);
        return archives.toArray(new JavaArchive[archives.size()]);
 * msg.addError().userNotLoggedIn(user);
    /**
     * @return the underlying Message which will automatically add a FacesMessage with SEVERITY_ERROR
     */

    /**
     * @return the underlying Message which will automatically add a FacesMessage with SEVERITY_FATAL
     */

    /**
     * @return the underlying Message which will automatically add a FacesMessage with SEVERITY_INFO
     */

    /**
     * @return the underlying Message which will automatically add a FacesMessage with SEVERITY_WARN
     */

    /**
     * @return the underlying Message implementation without adding any FacesMessage
     */
    T get();
public class MessageBundleInvocationHandler implements InvocationHandler, Serializable
import org.apache.deltaspike.core.util.ReflectionUtils;
        return createMessageBundleProxy(ReflectionUtils.getRawType(injectionPoint.getType()));
import java.io.Serializable;

public interface JsfMessage<T> extends Serializable
    String CATEGORY_DETAIL = "detail";
    String CATEGORY_SUMMARY = "summary";

    /**
     * If the JsfMessage is used in a UIComponent we allow to set the clientId
     * @param clientId
     */
    JsfMessage<T> forClientId(String clientId);


import javax.faces.application.FacesMessage;

import java.lang.reflect.Proxy;

import org.apache.deltaspike.core.api.message.annotation.MessageBundle;
import org.apache.deltaspike.core.util.ClassUtils;
 * The complexity of setting the FacesMessage is
 * done in the {@link JsfMessageBundleInvocationHandler}.
    private String clientId = null;
    private Class<T> type;

    /**
     * The Message type
     * @param type
     * @param clientId
     */
    public DefaultJsfMessage(Class<T> type, String clientId)
    {
        this.type = type;
        this.clientId = clientId;

        if (! type.isInterface() || type.getAnnotation(MessageBundle.class) == null)
        {
            throw new IllegalArgumentException("JsfMessage must only be used for interfaces " 
                "annotated with @MessageBundle!");
        }
    }

    @Override
    public JsfMessage<T> forClientId(String clientId)
    {
        return new DefaultJsfMessage<T>(type, clientId);
    }

        return getMessage(FacesMessage.SEVERITY_ERROR);
        return getMessage(FacesMessage.SEVERITY_FATAL);
        return getMessage(FacesMessage.SEVERITY_INFO);
        return getMessage(FacesMessage.SEVERITY_WARN);
        return getMessage(null);

    private T getMessage(FacesMessage.Severity severity)
    {
        return type.cast(Proxy.newProxyInstance(ClassUtils.getClassLoader(null),
                new Class<?>[]{type}, new JsfMessageBundleInvocationHandler(severity, clientId)));
    }

import javax.faces.component.UIComponent;
     * @param uiComponent
     */
    JsfMessage<T> forComponent(UIComponent uiComponent);

    /**
import javax.faces.component.UIComponent;
    public JsfMessage<T> forComponent(UIComponent uiComponent)
    {
        return forClientId(uiComponent.getClientId());
    }

    @Override
    public JsfMessage createJsfMessage(InjectionPoint injectionPoint)
    private JsfMessage createJsfMessageFor(InjectionPoint injectionPoint, Class<Object> rawType)
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

        if (! (injectionPoint.getType() instanceof ParameterizedType))
        {
            throw new IllegalArgumentException("JsfMessage must be used as generic type");
        }
        ParameterizedType paramType = (ParameterizedType) injectionPoint.getType();
        Type[] actualTypes = paramType.getActualTypeArguments();
        if (actualTypes.length != 1)
        {
            throw new IllegalArgumentException("JsfMessage must have the MessageBundle as generic type parameter");
        }

        return createJsfMessageFor(injectionPoint, actualTypes[0]);
    private JsfMessage createJsfMessageFor(InjectionPoint injectionPoint, Type rawType)
        return new DefaultJsfMessage((Class) rawType, null);
 b/deltaspike/modules/jsf/impl/src/test/java/org/apache/deltaspike/test/jsf/impl/scope/view/beans/ViewScopedBackingBean.java
public class ViewScopedBackingBean implements Serializable
 * A {@link org.apache.deltaspike.core.api.message.LocaleResolver} which
 * evaluates the {@link UIViewRoot} as well as the default locale configured for JSF as a fallback.
            Locale result = null;
                result = viewRoot.getLocale();
            }

            if (result == null)
            {
                result = facesContext.getApplication().getDefaultLocale();
            }

            if (result != null)
            {
                return result;
        // return the default Locale, if no Locale was found
            Locale locale = messageContext.getLocale();

                            return messageBundle.getString(resourceKey);
    private String locale = "en";


    public String getLocale()
    {
        return locale;
    }

    public void setLocale(String locale)
    {
        this.locale = locale;
    }
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/api/message/JsfMessage.java
package org.apache.deltaspike.jsf.api.message;
import org.apache.deltaspike.jsf.api.message.JsfMessage;
import org.apache.deltaspike.jsf.api.message.JsfMessage;
import org.apache.deltaspike.jsf.api.message.JsfMessage;
import org.apache.deltaspike.jsf.api.message.JsfMessage;
        /*X TODO Java-EE5 support needs to be discussed
        */
    private volatile Bean<?> boundAuthorizerBean;
    private volatile InjectableMethod<?> boundAuthorizerMethodProxy;
import java.io.Serializable;
import java.util.Arrays;
public final class Annotateds
    private static final char SEPARATOR = ';';

    private Annotateds()
    {
        // this is a utility class with statics only
    }
    private static class AnnotatedCallableComparator<T>
        implements Comparator<AnnotatedCallable<? super T>>, Serializable
    private static class AnnotatedMethodComparator<T>
        implements Comparator<AnnotatedMethod<? super T>>, Serializable
    private static class AnnotatedConstructorComparator<T>
        implements Comparator<AnnotatedConstructor<? super T>>, Serializable
    private static class AnnotatedFieldComparator<T>
        implements Comparator<AnnotatedField<? super T>>, Serializable
    private static class AnnotationComparator implements Comparator<Annotation>, Serializable
     * @param clazz        The java class type
                builder.append(SEPARATOR);
                builder.append(SEPARATOR);
                builder.append(SEPARATOR);
            methods.addAll(Arrays.asList(declaredMethods));
import org.apache.deltaspike.core.api.config.view.metadata.annotation.DefaultCallback;

    @DefaultCallback
import org.apache.deltaspike.core.api.config.view.metadata.annotation.DefaultCallback;
import org.apache.deltaspike.core.api.config.view.metadata.annotation.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.CallbackDescriptor;
import org.apache.deltaspike.core.spi.config.view.ConfigPreProcessor;
import org.apache.deltaspike.core.spi.config.view.ViewConfigNode;
import org.apache.deltaspike.security.api.authorization.SecurityViolation;
import java.lang.annotation.Annotation;
import java.util.Set;

@ViewMetaData(preProcessor = Secured.SecuredConfigPreProcessor.class)

    class SecuredConfigPreProcessor implements ConfigPreProcessor<Secured>
    {
        @Override
        public Secured beforeAddToConfig(Secured metaData, ViewConfigNode viewConfigNode)
        {
            viewConfigNode.registerCallbackDescriptors(Secured.class,
                    new SecuredDescriptor(metaData.value(), DefaultCallback.class));
            return metaData; //no change needed
        }
    }

    //can be used from outside to get a typed result
    static class SecuredDescriptor extends CallbackDescriptor<Set<SecurityViolation>>
    {
        public SecuredDescriptor(Class[] beanClasses, Class<? extends Annotation> callbackMarker)
        {
            super(beanClasses, callbackMarker);
        }
    }

    boolean isActivated()
    {
        return isActivated;
    }

    boolean isTransformed()
    {
        return transformed;
    }

    ViewConfigResolver getViewConfigResolver()
    {
        return viewConfigResolver;
    }
     * just adding a dot '_' and the category String to the
     * just adding a dot '_' and the category String to the
 * <p>We support the general notion of multiple 'windows'
 * represented by an own {@link WindowContext} slice. All those
 * {@link WindowContext} slices will be held in the users servlet
 * <p>Every WindowContext is uniquely identified via a
 * 'windowId'. Each Thread is associated with at most
 * one single windowId at a time. The {@link WindowContext}
 * is the interface which allows resolving the current <i>windowId</i>
 * associated with this very Thread.</p>
public interface WindowContext
     * @return the <i>windowId</i> associated with the very Thread or <code>null</code>.
    String getCurrentWindowId();

    /**
     * Set the current windowId as the currently active for the very Thread.
     * If no WindowContext exists with the very windowId we will create a new one.
     * @param windowId
     */
    void activateWindowContext(String windowId);

    /**
     * close the WindowContext with the currently activated windowId for the very Thread.
     * @return <code>true</code> if any did exist, <code>false</code> otherwise
     */
    boolean closeCurrentWindowContext();


    /**
     * Close all WindowContexts which are managed by the WindowContextManager.
     * This is necessary when the session gets closed down.
     * @return
     */
    void closeAllWindowContexts();

                            return messageBundle.getString(resourceKey  "_"  category);
            if (message instanceof Message)
            {
                return message;
            }

     * @return the old value or <code>null</code> if no previous value did exist
    Object setAttribute(String name, Object value);
    void destroy();
        destroyAllActive(storage);
    }

    /**
     * destroys all the Contextual Instances in the Storage returned by
     * {@link #getContextualStorage(boolean)}.
     */
    public void destroyAllActive(ContextualStorage storage)
    {
import org.apache.deltaspike.core.api.config.view.View;
import org.apache.deltaspike.jsf.api.literal.PageBeanLiteral;
    protected void buildViewConfigMetaDataTree(@Observes ProcessAnnotatedType pat)
        if (ViewConfig.class.isAssignableFrom(pat.getAnnotatedType().getJavaClass()))
        {
            addPageDefinition(pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations());
            pat.veto();
        }
        else
        {
            addIndirectlyInheritedMetaData(
                pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations());
        }
    }

    public void addIndirectlyInheritedMetaData(Class configClass)
    {
        addIndirectlyInheritedMetaData(
            configClass, new HashSet<Annotation>(Arrays.asList(configClass.getAnnotations())));
    }

    protected void addIndirectlyInheritedMetaData(Class configClass, Set<Annotation> annotations)
    {
        for (Annotation annotation : annotations)
        {
            if (annotation.annotationType().equals(View.class))
            {
                for (Class<? extends ViewConfig> viewConfigRef : ((View) annotation).config())
                {
                    ViewConfigNode viewConfigNode = findNode(viewConfigRef);

                    if (viewConfigNode == null)
                    {
                        addPageDefinition(viewConfigRef);
                        viewConfigNode = findNode(viewConfigRef);

                        if (viewConfigNode == null)
                        {
                            throw new IllegalStateException("No node created for: "  viewConfigRef);
                        }
                    }

                    viewConfigNode.getInheritedMetaData().add(new PageBeanLiteral(configClass, null));
                }
                break;
            }

        }
                            viewConfigClass.getName()  " and "  this.rootViewConfigNode.getSource().getName());
                    ViewConfigRoot viewConfigRoot = (ViewConfigRoot) annotation;
                        .getConstructor(new Class[]{
                            ViewConfigNode.class, ConfigNodeConverter.class, ViewConfigInheritanceStrategy.class});
import org.apache.deltaspike.core.api.config.view.View;
@View(config = SimplePageConfig.class)
        Map<String, Class<? extends ViewConfig>> foundViewIds = new HashMap<String, Class<? extends ViewConfig>>();

                if (foundViewIds.containsKey(currentViewConfigDescriptor.getViewId()))
                {
                    throw new IllegalStateException(currentViewConfigDescriptor.getViewId()  " is configured twice. " 
                        "That isn't allowed - see: "  currentConfigDescriptor.getConfigClass().getName()  " and " 
                        foundViewIds.get(currentViewConfigDescriptor.getViewId()).getName());
                }
                else
                {
                    foundViewIds.put(
                        currentViewConfigDescriptor.getViewId(), currentViewConfigDescriptor.getViewConfig());
                }

                if (this.defaultErrorView == null)
                else if (DefaultErrorView.class.isAssignableFrom(currentViewConfigDescriptor.getViewConfig()))
                {
                    throw new IllegalStateException("It isn't allowed to configure multiple default-error-views. " 
                        "Found default-error-views: "  this.defaultErrorView.getViewConfig()  " and " 
                        currentViewConfigDescriptor.getViewConfig().getName());
                }
        if (DefaultErrorView.class.equals(viewDefinitionClass))
        {
            return getDefaultErrorViewConfigDescriptor();
        }
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
import org.apache.deltaspike.core.api.config.view.ViewConfig;
    /**
     * Optional inline error-view if it is required to show an error-page
     * which is different from the default error page.
     * @return type-safe view-config of the page which should be used as error-view
     */
    @Nonbinding
    Class<? extends ViewConfig> errorView() default DefaultErrorView.class;

    /**
     * Make sure that the Context is really active.
     * @throws ContextNotActiveException if there is no active
     *         Context for the current Thread.
     */
        // we replace the old windowBeanHolder beans with a new storage Map
        // an afterwards destroy the old Beans without having to care about any syncs.
        Map<String, ContextualStorage> oldWindowContextStorages = windowBeanHolder.forceNewStorage();
        for (ContextualStorage contextualStorage : oldWindowContextStorages.values())
 * This holder will store the window Ids and it's beans for the current
    /**
     * key: the windowId for the browser tab or window
     * value: the {@link ContextualStorage} which holds all the
     * {@link javax.enterprise.inject.spi.Bean}s.
     */
     * @param beanManager we need the CDI {@link BeanManager} for serialisation.
     * @param windowId the windowId for the current browser tab or window.
    /**
     *
     * This method will replace the storageMap and with
     * a new empty one.
     * This method can be used to properly destroy the WindowBeanHolder beans
     * without having to sync heavily. Any
     * {@link javax.enterprise.inject.spi.Bean#destroy(Object, javax.enterprise.context.spi.CreationalContext)}
     * should be performed on the returned old storage map.
     * @return the old storageMap.
     */
    public Map<String, ContextualStorage> forceNewStorage()
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/util/context/DummyBean.java
package org.apache.deltaspike.test.core.api.util.context;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/util/context/DummyContext.java
package org.apache.deltaspike.test.core.api.util.context;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/util/context/DummyScopeExtension.java
package org.apache.deltaspike.test.core.api.util.context;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/util/context/DummyScoped.java
package org.apache.deltaspike.test.core.api.util.context;
import org.apache.deltaspike.test.core.api.util.context.DummyContext;
import org.apache.deltaspike.test.core.api.util.context.DummyScopeExtension;
import org.apache.deltaspike.test.core.api.util.context.DummyScoped;
    
    @Secures
    @CustomSecurityBinding
    public boolean doSecuredCheck(@MockParamBinding MockObject2 obj)
    {
    	return obj.isValue();
    }
import javax.enterprise.inject.spi.AnnotatedParameter;
    private Set<AuthorizationParameter> authorizationParameters = new HashSet<AuthorizationParameter>();
        
        for (AnnotatedParameter<?> annotatedParameter : boundAuthorizerMethod.getParameters())
        {
            Set<Annotation> securityParameterBindings = null;
            for (Annotation annotation : annotatedParameter.getAnnotations())
            {
                if (SecurityUtils.isMetaAnnotatedWithSecurityParameterBinding(annotation))
                {
                    if (securityParameterBindings == null)
                    {
                        securityParameterBindings = new HashSet<Annotation>();
                    }
                    securityParameterBindings.add(annotation);
                }
            }
            if (securityParameterBindings != null)
            {
                AuthorizationParameter authorizationParameter
                    = new AuthorizationParameter(annotatedParameter.getBaseType(), securityParameterBindings);
                authorizationParameters.add(authorizationParameter);
            }
        }
    boolean matchesBindings(Annotation annotation, Set<AuthorizationParameter> parameterBindings)
        for (AuthorizationParameter authorizationParameter : authorizationParameters)
        {
            boolean found = false;
            for (AuthorizationParameter parameterBinding : parameterBindings)
            {
                if (parameterBinding.matches(authorizationParameter))
                {
                    found = true;
                }
            }
            if (!found)
            {
                return false;
            }
        }
import java.util.Collections;
                        //TODO
                        if (auth.matchesBindings(annotation, Collections.<AuthorizationParameter> emptySet())) 
//                    if (!found) 
//                    {
//                        event.addDefinitionError(new SecurityDefinitionException("Secured type " 
//                                type.getJavaClass().getName() 
//                                " has no matching authorizer method for security binding @" 
//                                annotation.annotationType().getName()));
//                    }
            Set<AuthorizationParameter> parameterBindings = new HashSet<AuthorizationParameter>();
            Class<?>[] parameterTypes = targetMethod.getParameterTypes();
            Annotation[][] parameterAnnotations = targetMethod.getParameterAnnotations();
            for (int i = 0; i < parameterTypes.length; i)
            {
                Set<Annotation> securityBindings = null;
                for (final Annotation parameterAnnotation : parameterAnnotations[i])
                {
                    if (SecurityUtils.isMetaAnnotatedWithSecurityParameterBinding(parameterAnnotation))
                    {
                        if (securityBindings == null)
                        {
                            securityBindings = new HashSet<Annotation>();
                        }
                        securityBindings.add(parameterAnnotation);
                    }
                }
                if (securityBindings != null)
                {
                    parameterBindings.add(new AuthorizationParameter(parameterTypes[i], securityBindings));
                }
            }
            
                    if (authorizer.matchesBindings(binding, parameterBindings))
                                if (a.matchesBindings(binding, parameterBindings))
import org.apache.deltaspike.security.api.authorization.annotation.SecurityParameterBinding;
    public static boolean isMetaAnnotatedWithSecurityParameterBinding(Annotation annotation)
    {
        if (annotation.annotationType().isAnnotationPresent(SecurityParameterBinding.class))
        {
            return true;
        }

        List<Annotation> result = getAllAnnotations(annotation.annotationType().getAnnotations());

        for (Annotation foundAnnotation : result)
        {
            if (SecurityParameterBinding.class.isAssignableFrom(foundAnnotation.annotationType()))
            {
                return true;
            }
        }
        return false;
    }

        
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.enterprise.inject.spi.AnnotatedParameter;
                getMetaDataStorage().addSecuredType(type);
                        getMetaDataStorage().addSecuredMethod(m);
        metaDataStorage.registerSecuredMethods();
        for (final AnnotatedMethod<?> method : metaDataStorage.getSecuredMethods())
            // Here we simply want to validate that each method that is annotated with
            Class<?> targetClass = method.getDeclaringType().getJavaClass();
            Method targetMethod = method.getJavaMember();
            for (final Annotation annotation : SecurityUtils.getSecurityBindingTypes(targetClass, targetMethod)) 
                Set<AuthorizationParameter> authorizationParameters = new HashSet<AuthorizationParameter>();
                for (AnnotatedParameter<?> parameter : (List<AnnotatedParameter<?>>) (List<?>) method.getParameters())
                    Set<Annotation> securityParameterBindings = null;
                    for (Annotation a : parameter.getAnnotations())
                        if (SecurityUtils.isMetaAnnotatedWithSecurityParameterBinding(a))
                            if (securityParameterBindings == null)
                            {
                                securityParameterBindings = new HashSet<Annotation>();
                            }
                            securityParameterBindings.add(a);
                    if (securityParameterBindings != null)
                    {
                        AuthorizationParameter authorizationParameter
                            = new AuthorizationParameter(parameter.getBaseType(), securityParameterBindings);
                        authorizationParameters.add(authorizationParameter);
                    }
                }
                // Validate the authorizer
                for (Authorizer auth : metaDataStorage.getAuthorizers())
                {
                    if (auth.matchesBindings(annotation, authorizationParameters)) 
                    {
                        found = true;
                        break;
                    }
                }
                if (!found) 
                {
                    event.addDefinitionError(new SecurityDefinitionException("Secured type " 
                            method.getDeclaringType().getJavaClass().getName() 
                            " has no matching authorizer method for security binding @" 
                            annotation.annotationType().getName()));
            for (final Annotation annotation : method.getAnnotations()) 
                if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
                    metaDataStorage.registerSecuredMethod(targetClass, targetMethod);
                    break;
        metaDataStorage.resetSecuredMethods();
import javax.enterprise.inject.spi.AnnotatedMethod;
import javax.enterprise.inject.spi.AnnotatedType;

     * Contains all known secured methods.
    private Set<AnnotatedMethod<?>> securedMethods = new HashSet<AnnotatedMethod<?>>();
        for (AnnotatedMethod<?> securedMethod : annotatedType.getMethods())
        {
            addSecuredMethod(securedMethod);
        }
    void addSecuredMethod(AnnotatedMethod<?> annotatedMethod)
        securedMethods.add(annotatedMethod);
    Set<AnnotatedMethod<?>> getSecuredMethods()
        return securedMethods;
    }

    void resetSecuredMethods()
    {
        securedMethods = null;
    void registerSecuredMethods()
    {
        for (AnnotatedMethod<?> method : securedMethods)
        {
            registerSecuredMethod(method.getDeclaringType().getJavaClass(), method.getJavaMember());
        }
    }

    synchronized <T> void registerSecuredMethod(Class<T> targetClass, Method targetMethod)
            for (Annotation binding : SecurityUtils.getSecurityBindingTypes(targetClass, targetMethod))
import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.Set;
    public static Set<Annotation> getSecurityBindingTypes(Class<?> targetClass, Method targetMethod)
    {
        Set<Annotation> securityBindingTypes = new HashSet<Annotation>();
        Class<?> cls = targetClass;
        while (!cls.equals(Object.class))
        {
            for (final Annotation annotation : cls.getAnnotations())
            {
                if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
                {
                    securityBindingTypes.add(annotation);
                }
            }
            cls = cls.getSuperclass();
        }

        for (final Annotation annotation : targetMethod.getAnnotations())
        {
            if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
            {
                securityBindingTypes.add(annotation);
            }
        }
        return securityBindingTypes;
    }

    public boolean getResult(@MockParamBinding MockObject mockObject)
    public boolean getResult(@MockParamBinding MockObject2 mockObject)
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/jmx/DynamicMBeanWrapper.java
package org.apache.deltaspike.core.impl.jmx;
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/jmx/MBeanExtension.java
package org.apache.deltaspike.core.impl.jmx;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import javax.enterprise.inject.spi.*;
public class MBeanExtension implements Extension, Deactivatable
    private Boolean isActivated = true;

    protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
        isActivated = ClassDeactivationUtils.isActivated(getClass());
    }

    protected void processBean(@Observes final ProcessManagedBean<?> bean, final BeanManager bm) throws Exception
    {
        if (!isActivated)
        {
            return;
        }

    protected void shutdown(@Observes final BeforeShutdown shutdown) throws Exception
        if (!isActivated)
        {
            return;
        }

import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.TYPE;

@Target({ CONSTRUCTOR, FIELD, METHOD, PARAMETER, TYPE })
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Retention(RUNTIME)
@Target(TYPE)
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Retention(RUNTIME)
@Target(METHOD)
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Retention(RUNTIME)
@Target(METHOD)
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Target(TYPE)
@Retention(RUNTIME)

    @Target(TYPE)
    @Retention(RUNTIME)
    static @interface List
    {
        NotificationInfo[] value();
    }
        final NotificationInfo.List notifications = annotatedMBean.getAnnotation(NotificationInfo.List.class);
import org.apache.deltaspike.core.api.config.ConfigResolver;
        final String description =
            getDescription(annotatedMBean.getAnnotation(Description.class), annotatedMBean.getName());
            notificationInfos.add(getNotificationInfo(notification, annotatedMBean.getName()));
        if (notifications != null)
            for (NotificationInfo notificationInfo : notifications.value())
                notificationInfos.add(getNotificationInfo(notificationInfo, annotatedMBean.getName()));
        for (Method method : annotatedMBean.getMethods())
            final int modifiers = method.getModifiers();
            if (method.getDeclaringClass().equals(Object.class)
            if (method.getAnnotation(ManagedAttribute.class) != null)
                final String methodName = method.getName();
                if (isAccessor(method))
                    LOGGER.warning("ignoring attribute "  method.getName()  " for "  annotatedMBean.getName());
                    getters.put(attrName, method);
                    setters.put(attrName, method);
            else if (method.getAnnotation(ManagedOperation.class) != null)
                operations.put(method.getName(), method);
                String operationDescr = getDescription(method.getAnnotation(Description.class),
                    annotatedMBean.getName()  "#"  method.getName());
                operationInfos.add(new MBeanOperationInfo(operationDescr, method));
        for (Map.Entry<String, Method> methodEntry : getters.entrySet())
            final String key = methodEntry.getKey();
            final Method method = methodEntry.getValue();
            String attrDescr = getDescription(method.getAnnotation(Description.class),
                method.getDeclaringClass().getName()  "#"  method.getName());
                attributeInfos.add(new MBeanAttributeInfo(key, attrDescr, method, setters.get(key)));
                LOGGER.log(Level.WARNING, "can't manage "  key  " for "  method.getName(), ex);
    private MBeanNotificationInfo getNotificationInfo(final NotificationInfo n, String sourceInfo)
                n.notificationClass().getName(), getDescription(n.description(), sourceInfo),
    private String getDescription(final Description description, String defaultDescription)
        if (description == null)
            return defaultDescription;

        String descriptionValue = description.value().trim();

        if (descriptionValue.startsWith("{") && descriptionValue.endsWith("}"))
        {

            if (description.annotationType().getEnclosingMethod() != null)
            {
                defaultDescription = description.annotationType().getEnclosingMethod().getName();
            }
            else if (description.annotationType().getEnclosingClass() != null)
            {
                defaultDescription = description.annotationType().getEnclosingClass().getName();
            }
            return ConfigResolver.getPropertyValue(
                descriptionValue.substring(1, descriptionValue.length() - 1), defaultDescription);
        }
        return description.value();
        if (description == null || "".equals(description.value()))
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/jmx/annotation/JmxDescription.java
@Target({ FIELD, METHOD, TYPE })
public @interface JmxDescription
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/jmx/annotation/JmxManaged.java
import static java.lang.annotation.ElementType.FIELD;
@Target({ FIELD, METHOD })
public @interface JmxManaged
    JmxDescription description() default @JmxDescription("");
import org.apache.deltaspike.core.api.jmx.annotation.JmxDescription;
import org.apache.deltaspike.core.api.jmx.annotation.JmxManaged;
import java.lang.reflect.Field;
    private final Map<String, FieldInfo> fields = new HashMap<String, FieldInfo>();
            getDescription(annotatedMBean.getAnnotation(JmxDescription.class), annotatedMBean.getName());
                    || Modifier.isAbstract(modifiers)
                    || Modifier.isStatic(modifiers)
                    || method.getAnnotation(JmxManaged.class) == null)
            operations.put(method.getName(), method);
            String operationDescr = getDescription(method.getAnnotation(JmxDescription.class),
                annotatedMBean.getName()  "#"  method.getName());
            operationInfos.add(new MBeanOperationInfo(operationDescr, method));
        Class<?> clazz = annotatedMBean;
        while (!Object.class.equals(clazz) && clazz != null) {
            for (Field field : clazz.getDeclaredFields()) {
                final JmxManaged annotation = field.getAnnotation(JmxManaged.class);
                if (annotation != null) {
                    field.setAccessible(true);
                    final String name = field.getName();
                    final String fieldDescription = getDescription(field.getAnnotation(JmxDescription.class),
                            annotatedMBean.getClass()  "#"  name);
                    final Class<?> type = field.getType();
                    final String javaMtdName;
                    if (name.length() > 1) {
                        javaMtdName = Character.toUpperCase(name.charAt(0))  name.substring(1);
                    } else {
                        javaMtdName = ""  Character.toUpperCase(name.charAt(0));
                    }

                    Method setter = null;
                    Method getter = null;
                    try {
                        getter = clazz.getMethod("get"  javaMtdName);
                    } catch (NoSuchMethodException e1) {
                        try { // since we handle it ourself we treat it as a normal getter
                            getter = clazz.getMethod("is"  javaMtdName);
                        } catch (NoSuchMethodException e2) {
                            // ignored
                        }
                    }
                    try {
                        setter = clazz.getMethod("set"  javaMtdName, field.getType());
                    } catch (NoSuchMethodException e) {
                        // ignored
                    }

                    attributeInfos.add(new MBeanAttributeInfo(name, type.getName(),
                            fieldDescription, getter != null, setter != null, false));

                    fields.put(name, new FieldInfo(field, getter, setter));
                }
            clazz = clazz.getSuperclass();
    private String getDescription(final JmxDescription description, String defaultDescription)
        if (fields.containsKey(attribute))
                return fields.get(attribute).get(instance());
        if (fields.containsKey(attribute.getName()))
                fields.get(attribute.getName()).set(instance(), attribute.getValue());
            } finally
    String description() default "";
    String description() default "";
    String description() default "";
import org.apache.deltaspike.core.api.jmx.annotation.MBean;
            getDescription(annotatedMBean.getAnnotation(MBean.class).description(), annotatedMBean.getName());
            final JmxManaged annotation = method.getAnnotation(JmxManaged.class);
                    || annotation == null)
            String operationDescr = getDescription(annotation.description(),
                    final String fieldDescription = getDescription(annotation.description(),
    private String getDescription(final String description, String defaultDescription)
        if (description.isEmpty())
        String descriptionValue = description.trim();
        return description;
    public DynamicMBeanWrapper(final Class<?> annotatedMBean,
                               final boolean normalScope,
                               final Annotation[] qualifiers,
                               final MBean mBeanAnnotation)
            getDescription(mBeanAnnotation.description(), annotatedMBean.getName());
        while (!Object.class.equals(clazz) && clazz != null)
        {
            for (Field field : clazz.getDeclaredFields())
            {
                if (annotation != null)
                {
                    if (name.length() > 1)
                    {
                    }
                    else
                    {
                    try
                    {
                    }
                    catch (NoSuchMethodException e1)
                    {
                        try
                        { // since we handle it ourself we treat it as a normal getter
                        }
                        catch (NoSuchMethodException e2)
                        {
                    try
                    {
                    }
                    catch (NoSuchMethodException e)
                    {
    private MBeanNotificationInfo getNotificationInfo(final NotificationInfo notificationInfo, String sourceInfo)
        return new MBeanNotificationInfo(
            notificationInfo.types(),
            notificationInfo.notificationClass().getName(),
            getDescription(notificationInfo.description(), sourceInfo),
            new ImmutableDescriptor(notificationInfo.descriptorFields()));
            }
            finally
public class FieldInfo
{
        if (getter == null)
        {
        if (setter == null)
        {
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import javax.enterprise.inject.spi.BeforeShutdown;
import javax.enterprise.inject.spi.Extension;
import javax.enterprise.inject.spi.ProcessManagedBean;
        MBean mBeanAnnotation = bean.getAnnotated().getAnnotation(MBean.class);
        if (mBeanAnnotation != null)
            registerObject(bean, mBeanAnnotation, bm);
    private void registerObject(final ProcessManagedBean<?> bean,
                                final MBean mBeanAnnotation,
                                final BeanManager bm) throws Exception
        String on = mBeanAnnotation.objectName();
        boolean normalScoped = isNormalScope(bean.getAnnotated().getAnnotations(), bm);
        Annotation[] qualifiers = qualifiers(bean.getAnnotatedBeanClass(), bm);
        mBeanServer().registerMBean(
            new DynamicMBeanWrapper(clazz, normalScoped, qualifiers, mBeanAnnotation), objectName);

        objectNames.add(objectName);
        LOGGER.info("Registered MBean "  objectName.getCanonicalName());
    // TODO we have to check the origin of this issue
    private boolean isNormalScope(final Set<Annotation> annotations, final BeanManager bm)
import org.apache.deltaspike.core.api.jmx.JmxBroadcaster;
import javax.management.Notification;
import javax.management.NotificationBroadcasterSupport;
public class DynamicMBeanWrapper extends NotificationBroadcasterSupport implements DynamicMBean, JmxBroadcaster
                    fields.put(name, new FieldInfo(getter, setter));

    @Override
    public void send(final Notification notification)
    {
        sendNotification(notification);
    }
    public FieldInfo(final Method get, final Method set)
import org.apache.deltaspike.core.util.BeanUtils;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
    private final Map<Class<?>, DynamicMBeanWrapper> wrappers = new ConcurrentHashMap<Class<?>, DynamicMBeanWrapper>();


        final boolean normalScoped = isNormalScope(bean.getAnnotated().getAnnotations(), bm);
        final Annotation[] qualifiers = qualifiers(bean.getAnnotatedBeanClass(), bm);
        final DynamicMBeanWrapper mbean = new DynamicMBeanWrapper(clazz, normalScoped, qualifiers, mBeanAnnotation);
        mBeanServer().registerMBean(mbean, objectName);
        wrappers.put(clazz, mbean);


        mBeanServer().registerMBean(mbean, objectName);
        final Set<Annotation> qualifiers = BeanUtils.getQualifiers(bm, annotatedBeanClass.getAnnotations());
    public DynamicMBeanWrapper getWrapperFor(final Class<?> clazz)
    {
        return wrappers.get(clazz);
    }

            String operationDescr = getDescription(annotation.description(), method.getName());
                    final String fieldName = field.getName();
                    final String fieldDescription = getDescription(annotation.description(), fieldName);
                    final String methodName;
                    if (fieldName.length() > 1)
                        methodName = Character.toUpperCase(fieldName.charAt(0))  fieldName.substring(1);
                        methodName = ""  Character.toUpperCase(fieldName.charAt(0));
                        getter = clazz.getMethod("get"  methodName);
                        {
                            getter = clazz.getMethod("is"  methodName);
                        setter = clazz.getMethod("set"  methodName, field.getType());
                    attributeInfos.add(new MBeanAttributeInfo(
                        fieldName, type.getName(), fieldDescription, getter != null, setter != null, false));
                    fields.put(fieldName, new FieldInfo(getter, setter));
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/jmx/AttributeAccessor.java
public class AttributeAccessor
    public AttributeAccessor(final Method get, final Method set)
import javax.enterprise.context.Dependent;
    @Dependent
    private final Map<String, AttributeAccessor> fields = new HashMap<String, AttributeAccessor>();
                    fields.put(fieldName, new AttributeAccessor(getter, setter));
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
    public JmxBroadcaster jmxBroadcaster(final InjectionPoint ip)
        final JmxBroadcaster broadcaster = extension.getBroadcasterFor(declaringClass);
        if (broadcaster == null)
        return broadcaster;
import org.apache.deltaspike.core.api.jmx.JmxBroadcaster;
    public JmxBroadcaster getBroadcasterFor(final Class<?> clazz)
import org.apache.deltaspike.core.api.jmx.annotation.MBean;
            //TODO discuss validation during bootstrapping
            throw new IllegalStateException("Invalid injection of "  JmxBroadcaster.class.getName() 
                    " in "  declaringClass.getName()  " detected. It is required to annotate the class with @" 
                    MBean.class.getName());
    JmxBroadcaster getBroadcasterFor(final Class<?> clazz)
    String category() default "org.apache.deltaspike";
    String name() default "";

        String objectNameValue = mBeanAnnotation.objectName();
        if (objectNameValue.isEmpty())
            String name = mBeanAnnotation.name();

            if (name.isEmpty())
            {
                name = clazz.getName();
            }

            objectNameValue = mBeanAnnotation.category()  ":type=MBeans,name="  name;
        final ObjectName objectName = new ObjectName(objectNameValue);
    String category() default "{org.apache.deltaspike.mbean.category}";
import org.apache.deltaspike.core.api.config.ConfigResolver;
            String category = mBeanAnnotation.category().trim();

            if (category.startsWith("{") && category.endsWith("}"))
            {
                category = ConfigResolver.getPropertyValue(
                    category.substring(1, category.length() - 1), "org.apache.deltaspike");
            }

            objectNameValue = category  ":type=MBeans,name="  name;
/**
 * Interface used to send JMX message from "CDI MBeans".
 * It can only be used from CDI MBeans and should get injected
 * in other beans.
 */
    /**
     * @param notification the notification to send from the current MBean.
     */
/**
 * This annotation can be used either on a field or a method.
 *
 * Used on a method it describes a JMX operation with an optional description.
 *
 * Used on a field it describes a JMX attribute. This attribute is readable
 * if a getter on this field is available and writable is a setter is found.
 */
    /**
     * @return the description either of the operation or the attribute exported through JMX.
     */
/**
 * This annotation marks a CDI managed bean as exported through JMX.
 */
    /**
     * @return the category to use if no objectName was specified. Default is "org.apache.deltaspike"
     * and can be overriden either directly by the value or by a key used to resolve a value using
     * {@see org.apache.deltaspike.core.api.config.ConfigResolver}. It is a key if the value is
     * between bracket. Default key is "org.apache.deltaspike.mbean.category".
     */

    /**
     * @return the name of the bean used if no objectName was specified.
     * It is used with category value to create the MBean {@see javax.management.ObjectName}
     * using the following pattern: &lt;category&gt;:type=MBeans,name=&lt;name&gt;
     */
    /**
     * @return the direct object name used to export the decorated bean.
     */

    /**
     * @return the description used to describe the JMX bean.
     */
/**
 * Just a helper class mapping a JMX attribute.
 * It make the link between the attribute and its accessors validating
 * operations (read/write) are possible.
 */
/**
 * This class is the MBean implementation of a CDI bean.
 * It basically delegates to a CDI instance.
 */
    /**
     * The constructor is the builder for the MBean. All the MBean parsing logic is done here.
     *
     * @param annotatedMBean the class of the CDI managed bean
     * @param normalScope is the CDI bean @Dependent or not
     * @param qualifiers qualfiers of the CDI bean (used to retrieve it)
     */
                               final Annotation[] qualifiers)
            getDescription(annotatedMBean.getAnnotation(MBean.class).description(), annotatedMBean.getName());
        final DynamicMBeanWrapper mbean = new DynamicMBeanWrapper(clazz, normalScoped, qualifiers);
import org.apache.deltaspike.core.api.literal.AnyLiteral;

        // Make sure both handlers are handling the same type, and also have the same qualifiers, if both of those are
        // true, then precedence comes into play
        if (lhs.getExceptionType().equals(rhs.getExceptionType()) && lhs.getQualifiers().equals(rhs.getQualifiers()))
            final int precedenceReturnValue = comparePrecedence(lhs.getOrdinal(), rhs.getOrdinal(),

            // We really shouldn't be running into this case where everything is the same up until now,
            // but just in case, return both so both handlers are run.
            if (precedenceReturnValue == 0)
            // Precedence is different
            return precedenceReturnValue;
            // Different qualifiers
            if (lhs.getExceptionType().equals(rhs.getExceptionType())
                    && !lhs.getQualifiers().equals(rhs.getQualifiers()))
            {
                if (lhs.getQualifiers().contains(new AnyLiteral()))
                {
                    return -1; // Make sure @Any is first, as it's less specific
                }
                return 1;
            }
    private int comparePrecedence(final int lhs, final int rhs, final boolean isLhsBefore)
        if (!isLhsBefore)
    public Method getJavaMethod()
    {
        return handler.getJavaMember();
    }

        return "{Qualifiers: "  qualifiers  ", "  "Handles Type: "  exceptionType  ", "  "Before: " 
                before  ", "  "Precedence: "  ordinal  ", Method: "  handler.getJavaMember().getName()  "}";
                            if (!handlerQualifiers.isEmpty() && handlerQualifiers.equals(handler.getQualifiers()))
                            if (!handlerQualifiers.isEmpty() && handlerQualifiers.equals(handler.getQualifiers()))
    public void npeHandlerNoDefQualifier(@Handles ExceptionEvent<NullPointerException> event)
    {

    }

    public void npeHandlerDefQualifier(@Handles @CatchQualifier ExceptionEvent<NullPointerException> event)
    {

    }

import org.apache.deltaspike.security.api.authorization.annotation.SecuredReturn;
    private Object result;
    public SecurityParameterValueRedefiner(CreationalContext<?> creationalContext,
                                           InvocationContext invocation,
                                           Object result)
        this.invocation = invocation;
        this.result = result;
            else if (value.getInjectionPoint().getAnnotated().isAnnotationPresent(SecuredReturn.class))
            {
                return result;
            }
import org.apache.deltaspike.security.api.authorization.annotation.SecuredReturn;
    private Class<?> securedReturnType;
    private volatile AnnotatedMethod<?> boundAuthorizerMethod;
            Class<?> securedReturnType = null;
                if (annotation.annotationType().equals(SecuredReturn.class))
                {
                    securedReturnType
                        = boundAuthorizerMethod.getJavaMember().getParameterTypes()[annotatedParameter.getPosition()];
                }
            if (securityParameterBindings != null && securedReturnType != null)
            {
                StringBuilder errorMessage = new StringBuilder();
                errorMessage.append("@SecurityParameterBinding annotations must not occure ");
                errorMessage.append("at the same parameter with @Result annotation, but parameter ");
                errorMessage.append(annotatedParameter.getPosition()).append(" of method ");
                errorMessage.append(boundAuthorizerMethod.getJavaMember()).append(" is annotated with @Result and ");
                boolean first = true;
                for (Annotation securityParameterBinding : securityParameterBindings)
                {
                    if (first)
                    {
                        first = false;
                    }
                    else
                    {
                        errorMessage.append(" and ");
                    }
                    errorMessage.append(securityParameterBinding);
                }
                if (securityParameterBindings.size() == 1)
                {
                    errorMessage.append(", which is a @SecurityParameterBinding annotation");
                }
                else
                {
                    errorMessage.append(", which are @SecurityParameterBinding annotations");
                }
                throw new SecurityDefinitionException(errorMessage.toString());
            }
            else if (securityParameterBindings != null)
            else if (securedReturnType != null)
            {
                if (this.securedReturnType != null
                    && !this.securedReturnType.equals(securedReturnType))
                {
                    throw new SecurityDefinitionException("More than one parameter of "
                                                           boundAuthorizerMethod.getJavaMember()
                                                           " is annotated with @Result");
                }
                this.securedReturnType = securedReturnType;
            }
    boolean isBeforeMethodInvocationAuthorizer()
    {
        return securedReturnType == null;
    }

    boolean isAfterMethodInvocationAuthorizer()
    {
        return securedReturnType != null;
    }

    void authorize(final InvocationContext ic, final Object returnValue, BeanManager beanManager)
                    new SecurityParameterValueRedefiner(creationalContext, ic, returnValue));
    boolean matchesBindings(Annotation annotation, Set<AuthorizationParameter> parameterBindings, Class<?> returnType)
        if (!matches(returnType))
        {
            return false;
        }

    private boolean matches(Class<?> returnType)
    {
        if (securedReturnType == null)
        {
            return true;
        }
        if (securedReturnType.isAssignableFrom(returnType))
        {
            return true;
        }
        if (securedReturnType.equals(Void.class) && returnType.equals(Void.TYPE))
        {
            return true;
        }
        return false;
    }

            if (authorizer.isBeforeMethodInvocationAuthorizer())
            {
                authorizer.authorize(invocationContext, null, this.beanManager);
            }
        Object result = invocationContext.proceed();

        for (Authorizer authorizer : metaDataStorage.getAuthorizers(invocationContext.getTarget().getClass(), method))
        {
            if (authorizer.isAfterMethodInvocationAuthorizer())
            {
                authorizer.authorize(invocationContext, result, this.beanManager);
            }
        }
        
        return result;
                    if (auth.matchesBindings(annotation, authorizationParameters, targetMethod.getReturnType())) 
                    if (authorizer.matchesBindings(binding, parameterBindings, targetMethod.getReturnType()))
                                if (a.matchesBindings(binding, parameterBindings, targetMethod.getReturnType()))
import org.apache.deltaspike.security.api.authorization.annotation.SecuredReturn;
    
    @Secures
    @CustomSecurityBinding
    public boolean doSecuredCheckAfterMethodInvocation(@SecuredReturn MockObject obj)
    {
    	return obj.isValue();
    }

    @Secures
    @CustomSecurityBinding
    public boolean doSecuredCheckAfterMethodInvocationWithVoidMethod(@SecuredReturn Void result) {
        return false;
    }

    public MockObject getResult(boolean value) {
    	return new MockObject(value);
    }
    
    @CustomSecurityBinding
    public void securityCheckAfterMethodInvocation(MethodInvocationParameter parameter) {
        parameter.setMethodInvoked(true);
    }
    
    @CustomSecurityBinding
    public Void securityCheckAfterMethodInvocationWithVoidResult(MethodInvocationParameter parameter) {
        parameter.setMethodInvoked(true);
        return null;
    }
        H handlerInstance = (H) ((PartialBeanMethodHandler)((ProxyObject) instance).getHandler()).getHandlerInstance();
        this.handlerInjectionTarget.preDestroy(handlerInstance);
        //injectionTarget.dispose(handlerInstance); //currently producers aren't supported
@CustomInterceptor //for uc003
public class PartialBeanHandler implements InvocationHandler, /*just needed for testing interceptors: */TestInterceptorAware
    private boolean intercepted;
        return this.value  "-"  this.testBean.getValue()  "-"  this.intercepted;
    }

    public void setIntercepted(boolean intercepted)
    {
        this.intercepted = intercepted;
    private String value;

import javax.enterprise.context.NormalScope;
import java.util.Set;
    public <X> void findInvocationHandlerBindings(@Observes ProcessAnnotatedType<X> pat, BeanManager beanManager)
            validateInvocationHandler(
                    beanClass, bindingAnnotationClass, pat.getAnnotatedType().getAnnotations(), beanManager);
    protected <X> void validateInvocationHandler(Class<X> beanClass,
                                                 Class<? extends Annotation> bindingAnnotationClass,
                                                 Set<Annotation> annotations,
                                                 BeanManager beanManager)

        for (Annotation annotation : annotations)
        {
            if (beanManager.isNormalScope(annotation.annotationType()))
            {
                return;
            }
        }

        //at least we have to restrict dependent-scoped beans (we wouldn't be able to destroy such handlers properly).
        this.definitionError = new IllegalStateException(beanClass.getName()  " needs to be normal-scoped. " 
            "(= Scopes annotated with @"  NormalScope.class.getName()  ")");
import org.apache.deltaspike.core.api.provider.BeanProvider;
    private final Class<H> handlerClass;
        this.handlerClass = handlerClass;
            H handlerInstance = BeanProvider.getContextualReference(this.handlerClass);
import javax.enterprise.context.RequestScoped;
@RequestScoped
public abstract class CallbackDescriptor
    protected List<CallbackEntry> callbacks = new ArrayList<CallbackEntry>();
    protected Class<? extends Annotation> callbackType;
    protected static class CallbackEntry

        public List<Method> getCallbackMethods()
        {
            return callbackMethods;
        }

        public Class getTargetBeanClass()
        {
            return targetBeanClass;
        }
    /**
     * Callbacks which are configured for the entry and bound to the given meta-data type.
     * @param metaDataType type of the meta-data (e.g. PageBean.class)
     * @return descriptor for the callback or null if there is no callback-method
     */
    CallbackDescriptor getCallbackDescriptor(Class<? extends Annotation> metaDataType);
     * @return descriptor for the callback null if there is no callback-method
    /**
     * Callbacks which are configured for the entry and bound to the given meta-data type.
     * @param metaDataType type of the meta-data (e.g. PageBean.class)
     * @param executorType type of the executor which allows to get a typed result (e.g. Secured.SecuredDescriptor)
     * @return descriptor for the callback which also allows to invoke it or null if there is no callback-method
     */
    <T extends ExecutableCallbackDescriptor> T getExecutableCallbackDescriptor(Class<? extends Annotation> metaDataType,
                                                                               Class<? extends T> executorType);
     * @param executorType type of the executor which allows to get a typed result (e.g. Secured.SecuredDescriptor)
    <T extends ExecutableCallbackDescriptor> T getExecutableCallbackDescriptor(Class<? extends Annotation> metaDataType,
                                                                               Class<? extends Annotation> callbackType,
                                                                               Class<? extends T> executorType);
import org.apache.deltaspike.core.api.config.view.metadata.SimpleCallbackDescriptor;
        private class ViewControllerDescriptor extends SimpleCallbackDescriptor<Void>
            protected ViewControllerDescriptor(Class beanClass, Class<? extends Annotation> callbackType)
                super(beanClass, callbackType);
import org.apache.deltaspike.core.api.config.view.metadata.ExecutableCallbackDescriptor;
    public CallbackDescriptor getCallbackDescriptor(Class<? extends Annotation> metaDataType)
        return getCallbackDescriptor(metaDataType, DefaultCallback.class);
    public CallbackDescriptor getCallbackDescriptor(Class<? extends Annotation> metaDataType,
                                                    Class<? extends Annotation> callbackType)
    {
        return findCallbackDescriptor(metaDataType, callbackType);
    }

    @Override
    public <T extends ExecutableCallbackDescriptor> T getExecutableCallbackDescriptor(
            Class<? extends Annotation> metaDataType,
            Class<? extends T> executorType)
    {
        return getExecutableCallbackDescriptor(metaDataType, DefaultCallback.class, executorType);
    }

    @Override
    public <T extends ExecutableCallbackDescriptor> T getExecutableCallbackDescriptor(
            Class<? extends Annotation> metaDataType,
            Class<? extends Annotation> callbackType,
            Class<? extends T> executorType)
    {
        return findCallbackDescriptor(metaDataType, callbackType);
    }

    private <T extends CallbackDescriptor> T findCallbackDescriptor(Class<? extends Annotation> metaDataType,
                                                                    Class<? extends Annotation> callbackType)
import org.apache.deltaspike.core.api.config.view.metadata.ExecutableCallbackDescriptor;
import org.apache.deltaspike.security.api.authorization.AccessDecisionVoterContext;
import java.util.List;
            viewConfigNode.registerCallbackDescriptors(Secured.class, new SecuredDescriptor(metaData.value()));
    static class SecuredDescriptor extends ExecutableCallbackDescriptor<Set<SecurityViolation>>
        public SecuredDescriptor(Class<? extends AccessDecisionVoter>[] accessDecisionVoterBeanClasses)
            super(accessDecisionVoterBeanClasses, DefaultCallback.class);
        }

        public List<Set<SecurityViolation>> execute(AccessDecisionVoterContext accessDecisionVoterContext)
        {
            return super.execute(accessDecisionVoterContext);
import org.apache.deltaspike.core.api.config.view.metadata.ViewConfigResolver;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.jsf.api.navigation.PageParameterContext;

import javax.faces.context.ExternalContext;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

    public static Set<RequestParameter> getViewConfigPageParameters()
    {
        ExternalContext externalContext = FacesContext.getCurrentInstance().getExternalContext();

        Set<RequestParameter> result = new HashSet<RequestParameter>();

        if (externalContext == null || //detection of early config for different mojarra versions
                externalContext.getRequestParameterValuesMap() == null || externalContext.getRequest() == null)
        {
            return result;
        }

        PageParameterContext pageParameterContext = BeanProvider.getContextualReference(PageParameterContext.class);

        for (Map.Entry<String, String> entry : pageParameterContext.getPageParameters().entrySet())
        {
            //TODO add multi-value support
            result.add(new RequestParameter(entry.getKey(), new String[]{entry.getValue()}));
        }

        return result;
    }

    /**
     * Adds the current request-parameters to the given url
     *
     * @param externalContext current external-context
     * @param url             current url
     * @param encodeValues    flag which indicates if parameter values should be encoded or not
     * @return url with request-parameters
     */
    public static String addPageParameters(ExternalContext externalContext, String url, boolean encodeValues)
    {
        StringBuilder finalUrl = new StringBuilder(url);
        boolean existingParameters = url.contains("?");

        for (RequestParameter requestParam : getViewConfigPageParameters())
        {
            String key = requestParam.getKey();

            for (String parameterValue : requestParam.getValues())
            {
                if (!url.contains(key  "="  parameterValue) &&
                        !url.contains(key  "="  encodeURLParameterValue(parameterValue, externalContext)))
                {
                    if (!existingParameters)
                    {
                        finalUrl.append("?");
                        existingParameters = true;
                    }
                    else
                    {
                        finalUrl.append("&");
                    }
                    finalUrl.append(key);
                    finalUrl.append("=");

                    if (encodeValues)
                    {
                        finalUrl.append(JsfUtils.encodeURLParameterValue(parameterValue, externalContext));
                    }
                    else
                    {
                        finalUrl.append(parameterValue);
                    }
                }
            }
        }
        return finalUrl.toString();
    }

    /**
     * Encodes the given value using URLEncoder.encode() with the charset returned
     * from ExternalContext.getResponseCharacterEncoding().
     * This is exactly how the ExternalContext impl encodes URL parameter values.
     *
     * @param value           value which should be encoded
     * @param externalContext current external-context
     * @return encoded value
     */
    public static String encodeURLParameterValue(String value, ExternalContext externalContext)
    {
        // copied from MyFaces ServletExternalContextImpl.encodeURL()
        try
        {
            return URLEncoder.encode(value, externalContext.getResponseCharacterEncoding());
        }
        catch (UnsupportedEncodingException e)
        {
            throw new UnsupportedOperationException("Encoding type="
                     externalContext.getResponseCharacterEncoding()  " not supported", e);
        }
    }

    public static ViewConfigResolver getViewConfigResolver()
    {
        return BeanProvider.getContextualReference(ViewConfigResolver.class);
    }
import java.util.HashSet;
        this.metaData = new HashSet<Annotation>(metaData); //might be read-only (from Annotated#getAnnotations)
    String name() default ".";
            if (name == null /*null used as marker value for dyn. added instances*/ || ".".equals(name) /*default*/)

    @Override
    public String toString()
    {
        return this.viewId;
    }
import org.apache.deltaspike.core.api.config.view.metadata.ConfigDescriptor;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
        ConfigDescriptor configDescriptor = this.viewConfigResolver.getViewConfigDescriptor(viewId);

        //topmost nodes get checked first
        Stack<ConfigDescriptor> configDescriptorStack = new Stack<ConfigDescriptor>();

        if (configDescriptor != null)
        {
            configDescriptorStack.push(configDescriptor);
        }

        List<String> parentPathList = new ArrayList<String>();
        createPathList(viewId, parentPathList);

        List<ConfigDescriptor> folderConfigDescriptors = this.viewConfigResolver.getConfigDescriptors();

        for (String path : parentPathList)
        {
            for (ConfigDescriptor pathDescriptor : folderConfigDescriptors)
            {
                if (path.equals(pathDescriptor.toString()))
                {
                    configDescriptorStack.push(pathDescriptor);
                    break;
                }
            }
        }

        for (ConfigDescriptor currentConfigDescriptor : configDescriptorStack)
        {
            SecurityUtils.invokeVoters(this.accessDecisionVoterContext, currentConfigDescriptor);
        }
    }

    private void createPathList(String currentPath, List<String> pathList)
    {
        if (!currentPath.contains("/"))
        {
            return;
        }

        String parentFolder = currentPath.substring(0, currentPath.lastIndexOf("/"));
        pathList.add(parentFolder  "/");
        createPathList(parentFolder, pathList);
import org.apache.deltaspike.core.api.config.view.metadata.ConfigDescriptor;
                                    ConfigDescriptor viewConfigDescriptor)
//don't use @Aggregated(true) - we need to support different error-pages (per folder/page)
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

    public static JavaArchive[] getDeltaSpikeSecurityArchive()
        String[] excludedFiles;
        excludedFiles = new String[]{"META-INF.apache-deltaspike.properties"};


        return ShrinkWrapArchiveUtil.getArchives(null,
                "META-INF/beans.xml",
                new String[]{"org.apache.deltaspike.security"}, excludedFiles);
        //Attention: helper which allows to use a trick to throw
        // a catched checked exception without a wrapping exception
    void notify(ExceptionEvent<T> event, BeanManager beanManager) throws Exception;
import java.lang.reflect.InvocationTargetException;
        throws InvocationTargetException, IllegalAccessException, IllegalArgumentException
import java.lang.reflect.InvocationTargetException;
        throws InvocationTargetException, IllegalAccessException, IllegalArgumentException
        throws InvocationTargetException, IllegalAccessException, IllegalArgumentException
    public void notify(final ExceptionEvent<T> event, BeanManager beanManager) throws Exception
import org.apache.deltaspike.core.util.ExceptionUtils;
        throws InvocationTargetException, IllegalAccessException, IllegalArgumentException
        Object result = null;
        try
        {
            result = boundAuthorizerMethodProxy.invoke(reference, creationalContext,
                        new SecurityParameterValueRedefiner(creationalContext, ic, returnValue));
        }
        catch (InvocationTargetException e)
        {
            //see DELTASPIKE-299
            ExceptionUtils.throwAsRuntimeException(e.getCause());
        }
        if (Boolean.FALSE.equals(result))
                                     Object... args) throws IllegalAccessException, IllegalArgumentException
        catch (InvocationTargetException e)
        {
            //re-visit DELTASPIKE-299 before changing this part
            ExceptionUtils.throwAsRuntimeException(e.getCause());
            //won't happen
            return null;
        }
        throws IllegalAccessException, IllegalArgumentException
        throws IllegalAccessException, IllegalArgumentException
                    " with "  qualifierConfiguredBean.annotationType().getName(), e);
        throws IllegalAccessException, IllegalArgumentException
        Object result = boundAuthorizerMethodProxy.invoke(reference, creationalContext,
                new SecurityParameterValueRedefiner(creationalContext, ic, returnValue));
    ConfigDescriptor getConfigDescriptor(String path);
    private Map<String, ConfigDescriptor> folderPathToViewDefinitionEntryMapping;

        initCaches();
    public ConfigDescriptor getConfigDescriptor(String path)
    {
        if (path == null)
        {
            return null;
        }

        ConfigDescriptor result = this.folderPathToViewDefinitionEntryMapping.get(path);

        if (result == null)
        {
            result = getViewConfigDescriptor(path); //TODO re-visit it
        }

        return result;
    }

    @Override
        return this.viewIdToViewDefinitionEntryMapping.get(viewId);

    protected void initCaches()
    {
        //folders
        Map<String, ConfigDescriptor> folderPathMapping = new HashMap<String, ConfigDescriptor>();
        for (ConfigDescriptor configDescriptor : this.folderDefinitionToViewDefinitionEntryMapping.values())
        {
            if (folderPathMapping.containsKey(configDescriptor.toString()))
            {
                throw new IllegalStateException("Duplicated config for the same folder configured. See: " 
                    folderPathMapping.get(
                            configDescriptor.toString()).getConfigClass().getName() 
                    " and "  configDescriptor.getConfigClass().getName());
            }
            folderPathMapping.put(configDescriptor.toString(), configDescriptor);
        }
        this.folderPathToViewDefinitionEntryMapping = Collections.unmodifiableMap(folderPathMapping);

        //pages
        for (ViewConfigDescriptor viewConfigDescriptor : this.viewDefinitionToViewDefinitionEntryMapping.values())
        {
            if (viewIdToViewDefinitionEntryMapping.containsKey(viewConfigDescriptor.getViewId()))
            {
                throw new IllegalStateException("Duplicated config for the same page configured. See: " 
                    viewIdToViewDefinitionEntryMapping.get(
                            viewConfigDescriptor.getViewId()).getConfigClass().getName() 
                    " and "  viewConfigDescriptor.getConfigClass().getName());
            }
            this.viewIdToViewDefinitionEntryMapping.put(viewConfigDescriptor.getViewId(), viewConfigDescriptor);
        }
    }
        ConfigDescriptor pathDescriptor;
            pathDescriptor = this.viewConfigResolver.getConfigDescriptor(path);

            if (pathDescriptor != null)
                configDescriptorStack.push(pathDescriptor);

        if (isBeforeHandler() != that.isBeforeHandler())
        {
            return false;
        }
            //current bean is annotated with @Alternative and of the same type as the configured bean
            if (isAlternativeBeanImplementation && alternativeBeanClass.equals(currentBean))
            //current bean is annotated with @Alternative and of the same type as the configured bean
            if (isAlternativeBeanImplementation && alternativeBeanClass.equals(currentBean))
import java.util.concurrent.ConcurrentMap;
    private final Map<Object, ContextualInstanceInfo<?>> contextualInstances;
    private final BeanManager beanManager;
    private final boolean concurrent;
    private final boolean passivationCapable;
            ConcurrentMap<Object, ContextualInstanceInfo<?>> concurrentMap
 * A skeleton containing the most important parts of a custom CDI Context.
    private final boolean passivatingScope;
     * @param createIfNotExist whether a ContextualStorage shall get created if it doesn't yet exist.
            @SuppressWarnings("unchecked")
            final T instance =  (T) contextualInstanceInfo.getContextualInstance();
            if (instance != null)
            {
                return instance;
            }
     * Restores the Bean from its beanKey.
     * @return whether the ContextualStorage might get accessed concurrently by different threads.
     * @return <code>true</code> if the bean was destroyed, <code>false</code> if there was no such bean.
     * destroys all the Contextual Instances in the specified ContextualStorage.
     * <p><b>Attention:</b> This will also return instances for beans which where an Alternative
     * exists for! The &#064;Alternative resolving is only done via {@link BeanManager#resolve(java.util.Set)}
     * which we cannot use in this case!</p>
     * <p><b>Attention:</b> please see the notes on manually resolving &#064;Dependent bean
     * in {@link #getContextualReference(Class, boolean, java.lang.annotation.Annotation...)}!</p>
     * <p><b>Attention:</b> This will also return instances for beans which where an Alternative
     * exists for! The &#064;Alternative resolving is only done via {@link BeanManager#resolve(java.util.Set)}
     * which we cannot use in this case!</p>
    private static Boolean isWeldDetected = false;
        isWeldDetected = isWeld();
            if (isWeldDetected)
    private boolean isWeld()
            if (element.toString().contains("org.jboss.weld"))
        TransactionBeanStorage transactionBeanStorage = TransactionBeanStorage.getInstance();

        TransactionBeanStorage.close();
    private static ThreadLocal<TransactionBeanStorage> transactionBeanStorage =
        new ThreadLocal<TransactionBeanStorage>();

    private TransactionBeanStorage()
    {
    }

    public static TransactionBeanStorage getInstance()
    {
        TransactionBeanStorage result = transactionBeanStorage.get();

        if (result == null)
        {
            result = new TransactionBeanStorage();
            transactionBeanStorage.set(result);
        }

        return result;
    }

    public static void close()
    {
        TransactionBeanStorage currentStorage = transactionBeanStorage.get();

        if (currentStorage != null)
        {
            currentStorage.endAllTransactionScopes();
            transactionBeanStorage.set(null);
            transactionBeanStorage.remove();
        }
    }

    public static boolean isOpen()
    {
        return transactionBeanStorage.get() != null;
    }

        Map<Contextual, TransactionBeanEntry> transactionBeanEntryMap =
                TransactionBeanStorage.getInstance().getActiveTransactionContext();
            TransactionBeanStorage.close();

        Map<Contextual, TransactionBeanEntry> transactionBeanEntryMap =
            TransactionBeanStorage.getInstance().getActiveTransactionContext();
            TransactionBeanStorage.close();

            return TransactionBeanStorage.isOpen() &&
                   TransactionBeanStorage.getInstance().getActiveTransactionContext() != null;
        return this.handlerInstance.invoke(target, method, arguments);
 * BeanManager during CDI-Container boot time.</p>
     * <p>Get a Contextual Reference by its type and qualifiers.
     * live in the well-defined lifecycle of their injection point (the bean they got
     * <p>Get a Contextual Reference by its EL Name.
     * <p>Get a Contextual Reference by its EL Name.
     * <p>Get a Contextual Reference by its EL Name.
     * Get the Contextual Reference for the given bean.
     * <p>Get a list of Contextual References by type independent of the qualifier
     * <p><b>Attention:</b> This will also return instances of beans for which an Alternative
     * exists! The &#064;Alternative resolving is only done via {@link BeanManager#resolve(java.util.Set)}
     * <p>Get a list of Contextual References by type independent of the qualifier.
     * <p><b>Attention:</b> This will also return instances of beans for which an Alternative
     * exists! The &#064;Alternative resolving is only done via {@link BeanManager#resolve(java.util.Set)}
     * @param includeDefaultScopedBeans specifies if dependent scoped beans should be included in the result
     * Get a set of {@link Bean} definitions by type independent of the qualifier.
     * @param optional if <code>true</code> it will return an empty set if no bean could be found.
     * @param includeDefaultScopedBeans specifies if dependent scoped beans should be included in the result
     * Allows to perform dependency injection for instances which aren't managed by CDI.
     * The resulting instance isn't managed by CDI; only fields annotated with @Inject get initialized.
import org.apache.deltaspike.security.spi.authorization.EditableAccessDecisionVoterContext;
import java.util.logging.Logger;
    private Boolean securityModuleActivated;
        if (this.securityModuleActivated == null)
        {
            lazyInit();
        }
        if (!this.securityModuleActivated)
        {
            return;
        }


    private synchronized void lazyInit()
    {
        this.securityModuleActivated =
            BeanProvider.getContextualReference(EditableAccessDecisionVoterContext.class, true) != null;

        if (!this.securityModuleActivated)
        {
            Logger.getLogger(getClass().getName()) //it's the only case for which a logger is needed in this class
                    .info("security-module-impl isn't used -> "  getClass().getName() 
                            "#checkSecuredView gets deactivated");
        }
    }
import org.apache.deltaspike.security.spi.authorization.EditableAccessDecisionVoterContext;
import java.util.logging.Logger;
    private Boolean securityModuleActivated;

        if (this.securityModuleActivated == null)
        {
            lazyInit();
        }
        if (!this.securityModuleActivated)
        {
            return result;
        }


    private synchronized void lazyInit()
    {
        this.securityModuleActivated =
            BeanProvider.getContextualReference(EditableAccessDecisionVoterContext.class, true) != null;

        if (!this.securityModuleActivated)
        {
            Logger.getLogger(getClass().getName()) //it's the only case for which a logger is needed in this class
                    .info("security-module-impl isn't used -> "  getClass().getName()  " gets deactivated");
        }
    }
import org.apache.deltaspike.core.api.provider.BeanProvider;
        EditableAccessDecisionVoterContext accessDecisionVoterContext =
                BeanProvider.getContextualReference(EditableAccessDecisionVoterContext.class, false);

            SecurityUtils.invokeVoters(accessDecisionVoterContext, currentConfigDescriptor);
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/api/config/view/NavigationParameter.java
public @interface NavigationParameter
        @Nonbinding NavigationParameter[] value();
import org.apache.deltaspike.jsf.api.config.view.NavigationParameter;
            NavigationParameter navigationParameter = viewConfigClass.getAnnotation(NavigationParameter.class);
            if (navigationParameter != null)
                addConfiguredPageParameter(navigationParameter);
                NavigationParameter.List pageParameterList =
                        viewConfigClass.getAnnotation(NavigationParameter.List.class);
                    for (NavigationParameter currentNavigationParameter : pageParameterList.value())
                        addConfiguredPageParameter(currentNavigationParameter);
    private void addConfiguredPageParameter(NavigationParameter viewParameter)
import org.apache.deltaspike.jsf.api.config.view.NavigationParameter;
    @NavigationParameter(key = "param1", value = "staticMarker")
    @NavigationParameter.List({
            @NavigationParameter(key = "param1", value = "staticMarker1"),
            @NavigationParameter(key = "param2", value = "staticMarker2")
import org.apache.deltaspike.jsf.api.config.view.NavigationParameter;
    @NavigationParameter(key = "param1", value = "#{pageBean003.nextValue}")
import org.apache.deltaspike.jsf.api.config.view.NavigationParameter;
    @NavigationParameter(key = "param1", value = "staticValue2")
    @NavigationParameter.List({
            @NavigationParameter(key = "param1", value = "staticValue2"),
            @NavigationParameter(key = "param2", value = "#{pageBean005.currentValue}")
 * {@link org.apache.deltaspike.jsf.api.navigation.NavigationParameterContext}.
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/api/navigation/NavigationParameterContext.java
public interface NavigationParameterContext
 b/deltaspike/modules/jsf/impl/src/main/java/org/apache/deltaspike/jsf/impl/navigation/DefaultNavigationParameterContext.java
import org.apache.deltaspike.jsf.api.navigation.NavigationParameterContext;
public class DefaultNavigationParameterContext implements NavigationParameterContext
    protected DefaultNavigationParameterContext()
import org.apache.deltaspike.jsf.api.navigation.NavigationParameterContext;
    private NavigationParameterContext navigationParameterContext;
        if (this.navigationParameterContext != null)
        this.navigationParameterContext.addPageParameter(viewParameter.key(), viewParameter.value());
            this.navigationParameterContext =
                    BeanProvider.getContextualReference(NavigationParameterContext.class);
import org.apache.deltaspike.jsf.api.navigation.NavigationParameterContext;
        NavigationParameterContext navigationParameterContext =
                BeanProvider.getContextualReference(NavigationParameterContext.class);
        for (Map.Entry<String, String> entry : navigationParameterContext.getPageParameters().entrySet())
import org.apache.deltaspike.jsf.api.navigation.NavigationParameterContext;
    private NavigationParameterContext navigationParameterContext;
            this.navigationParameterContext.addPageParameter("cv", this.currentValue);
    Class<? extends ViewConfig>[] value() default ViewRef.Manual.class;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/ViewRef.java
public @interface ViewRef
import org.apache.deltaspike.core.api.config.view.ViewRef;
            if (annotation.annotationType().equals(ViewRef.class))
                for (Class<? extends ViewConfig> viewConfigRef : ((ViewRef) annotation).config())
import org.apache.deltaspike.core.api.config.view.ViewRef;
@ViewRef(config = SimplePageConfig.class)
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/api/config/view/View.java
import org.apache.deltaspike.jsf.api.literal.ViewLiteral;
import static org.apache.deltaspike.jsf.api.config.view.View.Extension.XHTML;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.FORWARD;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.EXCLUDE;
@ViewMetaData(preProcessor = View.ViewConfigPreProcessor.class)
public @interface View
    static class ViewConfigPreProcessor implements ConfigPreProcessor<View>
        public View beforeAddToConfig(View view, ViewConfigNode viewConfigNode)
            String basePath = view.basePath();
            String name = view.name();
            String extension = view.extension();
            View.NavigationMode navigation = view.navigation();
            View.ViewParameterMode viewParams = view.viewParams();
            if (("".equals(basePath) || basePath == null) && isView(source) /*only calc the path for real pages*/)
            if (("".equals(name) || name == null) && isView(source) /*only calc the path for real pages*/)
            if (View.Extension.DEFAULT.equals(extension) || extension == null)
            if (View.NavigationMode.DEFAULT.equals(navigation) || navigation == null)
            if (View.ViewParameterMode.DEFAULT.equals(viewParams) || viewParams == null)
                return new ViewLiteral(basePath, name, extension, navigation, viewParams);
            return view;
        //e.g. @View(navigation = REDIRECT) specified for a whole folder
        private boolean isView(Class source)
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/api/literal/ViewLiteral.java
import org.apache.deltaspike.jsf.api.config.view.View;
 * Literal for {@link org.apache.deltaspike.jsf.api.config.view.View}
public class ViewLiteral extends AnnotationLiteral<View> implements View
    public ViewLiteral(boolean virtual)
    public ViewLiteral(String basePath,
        ViewLiteral that = (ViewLiteral) o;
import org.apache.deltaspike.jsf.api.config.view.View;
            View viewAnnotation = findMetaDataByType(mergedMetaData, View.class);
            String viewId = viewAnnotation.basePath()  viewAnnotation.name()  "."  viewAnnotation.extension();
import org.apache.deltaspike.jsf.api.config.view.View;
import org.apache.deltaspike.jsf.api.literal.ViewLiteral;
            //e.g. @View is optional for users, but required from other parts of DeltaSpike -> ensure that it's in place
            if (annotation.annotationType().equals(View.class))
        currentNode.getMetaData().add(new ViewLiteral(true));
import org.apache.deltaspike.jsf.api.config.view.View;
                    View.NavigationMode navigationMode = entry.getMetaData(View.class).iterator().next().navigation();
                            View.NavigationMode.REDIRECT.equals(navigationMode),
import org.apache.deltaspike.jsf.api.config.view.View;
                View viewMetaData = entry.getMetaData(View.class).iterator().next();
                includeParameters = View.ViewParameterMode.INCLUDE
                        .equals(viewMetaData.viewParams());
                        View.NavigationMode.REDIRECT.equals(viewMetaData.navigation()),
import org.apache.deltaspike.jsf.api.config.view.View;
                        if (loadedClass.getAnnotation(View.class) == null &&
                                loadedClass.getSuperclass().getAnnotation(View.class) != null)
        View viewMetaData = entry.getMetaData(View.class).iterator().next();
        boolean performRedirect = View.NavigationMode.REDIRECT.equals(viewMetaData.navigation());
        boolean includeViewParameters = View.ViewParameterMode.INCLUDE.equals(viewMetaData.viewParams());
import org.apache.deltaspike.jsf.api.config.view.View;
            if (errorViewDescriptor != null && View.NavigationMode.REDIRECT ==
                    errorViewDescriptor.getMetaData(View.class).iterator().next().navigation() /*always available*/)
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.FORWARD;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.REDIRECT;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.INCLUDE;
@View(navigation = REDIRECT)
    @View(viewParams = INCLUDE)
    @View(navigation = FORWARD)
import org.apache.deltaspike.jsf.api.config.view.View;
    @View(name = "index")
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.FORWARD;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.REDIRECT;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.INCLUDE;
@View(navigation = REDIRECT)
    @View(viewParams = INCLUDE)
    @View(navigation = FORWARD)
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.REDIRECT;
@View(navigation = REDIRECT)
        return ViewConfigForIncludeViewParams.class;
 b/deltaspike/modules/jsf/impl/src/test/java/org/apache/deltaspike/test/jsf/impl/config/view/navigation/parameter/uc007/ViewConfigForIncludeViewParams.java
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.INCLUDE;
@View(viewParams = INCLUDE)
public class ViewConfigForIncludeViewParams implements ViewConfig
import org.apache.deltaspike.jsf.api.config.view.View;
@View
class SimplePageConfig002 implements ViewConfig
import org.apache.deltaspike.jsf.api.config.view.View;
    @View
    class Home implements ViewConfig
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.Extension.JSP;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.FORWARD;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.REDIRECT;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.INCLUDE;
    @View(name = "home", extension = JSP) class Index implements ViewConfig
    @View(navigation = REDIRECT, viewParams = INCLUDE)
            @View
            class Index implements ViewConfig
        @View(navigation = FORWARD)
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.FORWARD;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.REDIRECT;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.INCLUDE;
@View(navigation = REDIRECT)
        @View(viewParams = INCLUDE)
            @View
            class Index implements Statistics
        @View
        class Index implements Admin
        @View(navigation = FORWARD)
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.Extension.FACES;
import static org.apache.deltaspike.jsf.api.config.view.View.Extension.JSF;
import static org.apache.deltaspike.jsf.api.config.view.View.Extension.XHTML;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.FORWARD;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.REDIRECT;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.INCLUDE;
@View(navigation = REDIRECT, extension = JSF)
        @View(viewParams = INCLUDE, extension = FACES)
            @View
            class Index implements Statistics
        @View(extension = XHTML) class Index implements Admin
        @View(navigation = FORWARD) class Home implements Admin
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/api/config/view/controller/ViewControllerBean.java
@ViewMetaData(preProcessor = ViewControllerBean.ViewControllerBeanConfigPreProcessor.class)
public @interface ViewControllerBean
    public class ViewControllerBeanConfigPreProcessor implements ConfigPreProcessor<ViewControllerBean>
        public ViewControllerBean beforeAddToConfig(ViewControllerBean metaData, ViewConfigNode viewConfigNode)
                    ViewControllerBean.class, new ViewControllerDescriptor(metaData.value(), InitView.class));
                    ViewControllerBean.class, new ViewControllerDescriptor(metaData.value(), PrePageAction.class));
                    ViewControllerBean.class, new ViewControllerDescriptor(metaData.value(), PreRenderView.class));
                    ViewControllerBean.class, new ViewControllerDescriptor(metaData.value(), PostRenderView.class));
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/api/literal/ViewControllerBeanLiteral.java
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerBean;
 * Literal for {@link org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerBean}
public class ViewControllerBeanLiteral extends AnnotationLiteral<ViewControllerBean> implements ViewControllerBean
    public ViewControllerBeanLiteral(Class value, String name)
import org.apache.deltaspike.jsf.api.literal.ViewControllerBeanLiteral;
                    viewConfigNode.getInheritedMetaData().add(new ViewControllerBeanLiteral(configClass, null));
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerBean;
@ViewControllerBean(PageBean001.class)
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerBean;
@ViewControllerBean(value = PageBean002.class, name = "pageBean" /*TODO*/) //e.g. in case of producers with different @Named(...)
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerBean;
@ViewControllerBean(PageBean004.class)
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/api/config/view/controller/PreViewAction.java
public @interface PreViewAction
                    ViewControllerBean.class, new ViewControllerDescriptor(metaData.value(), PreViewAction.class));
import org.apache.deltaspike.jsf.api.config.view.controller.PreViewAction;
    @PreViewAction
    private static String testName;
     *
     * @param classLoader            to use
     * @param markerFile             finding this marker file will trigger creating the JavaArchive.
                    LOG.info("Test "  getTestName()
                             " Adding Java ClassPath URL as JavaArchive "  foundFile.toExternalForm());
    public static String getTestName()
    {
        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        String testName = "unknown";
        for (StackTraceElement ste : stackTraceElements)
        {
            if (ste.getClassName().contains("Test"))
            {
                testName = ste.getClassName();
                break;
            }
        }

        return testName;
    }
import java.util.logging.Logger;
    private static final Logger LOG = Logger.getLogger(OpenWebBeansContainerControl.class.getName());


            BeanManager beanManager = getBeanManager();

            if (beanManager == null)
            {
                LOG.warning("If the CDI-container was started by the environment, you can't use this helper." 
                        "Instead you can resolve ContextControl manually " 
                        "(e.g. via BeanProvider.getContextualReference(ContextControl.class) ). " 
                        "If the container wasn't started already, you have to use CdiContainer#boot before.");

                return null;
            }

            ctxCtrlBean = (Bean<ContextControl>) beanManager.resolve(beans);
import java.util.logging.Logger;
    private static final Logger LOG = Logger.getLogger(WeldContainerControl.class.getName());

            BeanManager beanManager = getBeanManager();

            if (beanManager == null)
            {
                LOG.warning("If the CDI-container was started by the environment, you can't use this helper." 
                        "Instead you can resolve ContextControl manually " 
                        "(e.g. via BeanProvider.getContextualReference(ContextControl.class) ). " 
                        "If the container wasn't started already, you have to use CdiContainer#boot before.");

                return null;
            }
            ctxCtrlBean = (Bean<ContextControl>) beanManager.resolve(beans);
@Retention(value = RetentionPolicy.RUNTIME)
 * <p>Built in support for injecting EntityManagerFactories into own beans.
 * The injection point must use the Qualifier {@link PersistenceUnitName}
 * to express the desired persistence unit name.</p>
 *
 * <p>The EntityManagerFactory for the given persistence unit will be produced
 * as &#064;Dependent scoped. It can be used to easily implement own
 * EntityManagerProviders as shown in the following example which provides
 * a producer according to the entitymanager-per-request design pattern:</p>
 * <pre>
 * &#064;ApplicationScoped
 * public class SampleEntityManagerProducer {
 *   &#064;Inject
 *   &#064;PersistenceUnitName("testPersistenceUnit")
 *   private EntityManagerFactory emf;
 *
 *   &#064;Produces
 *   &#064;RequestScoped
 *   public EntityManager createEntityManager() {
 *     return emf.createEntityManager();
 *   }
 *
 *   public void closeEm(&#064;Disposes EntityManager em) {
 *     em.close();
 *   }
 * }
 *  </pre>
    @PersistenceUnitName("any") // the value is nonbinding, thus 'any' is just a dummy parameter here
 b/deltaspike/modules/jpa/api/src/main/java/org/apache/deltaspike/jpa/api/entitymanager/PersistenceUnitName.java
package org.apache.deltaspike.jpa.api.entitymanager;
 b/deltaspike/modules/jpa/api/src/main/java/org/apache/deltaspike/jpa/spi/entitymanager/PersistenceConfigurationProvider.java
package org.apache.deltaspike.jpa.spi.entitymanager;
 * which gets produced with a given {@link org.apache.deltaspike.jpa.api.entitymanager.PersistenceUnitName}.
import org.apache.deltaspike.jpa.spi.entitymanager.PersistenceConfigurationProvider;
import org.apache.deltaspike.jpa.api.entitymanager.PersistenceUnitName;
    @Inject
    private PersistenceConfigurationProvider persistenceConfigurationProvider;
import org.apache.deltaspike.jpa.spi.entitymanager.PersistenceConfigurationProvider;
import org.apache.deltaspike.jpa.api.entitymanager.PersistenceUnitName;

import javax.annotation.ManagedBean;
import java.util.HashMap;
import java.util.Map;
import org.apache.openejb.OpenEjbContainer;
@ManagedBean // we need this annotation to force OpenEJB to pickup this class
            openEjbContainer = EJBContainer.createEJBContainer(getConfiguration());
    protected Map<?,?> getConfiguration()
    {
        Map<String, String> config = new HashMap<String, String>();

        config.put(OpenEjbContainer.Provider.OPENEJB_ADDITIONNAL_CALLERS_KEY, "");

        return config;
    }

import org.apache.deltaspike.jpa.api.entitymanager.PersistenceUnitName;
import org.apache.deltaspike.test.jpa.api.shared.TestEntityManager;

    public TestEntityManager /*needed by weld - see DS-315*/ createEntityManager()
        return (TestEntityManager)emf.createEntityManager();
    public void closeEm(@Disposes @SampleDb TestEntityManager em)
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import javax.enterprise.context.Dependent;
import java.util.Set;
    private CreationalContext<?> creationalContextOfDependentHandler;
            H handlerInstance = createHandlerInstance();
    private H createHandlerInstance()
    {
        Set<Bean<H>> handlerBeans = BeanProvider.getBeanDefinitions(this.handlerClass, false, true);

        if (handlerBeans.size() != 1)
        {
            throw new IllegalStateException(handlerBeans.size()  " beans found for "  this.handlerClass);
        }

        Bean<H> handlerBean = handlerBeans.iterator().next();

        BeanManager beanManager = BeanManagerProvider.getInstance().getBeanManager();
        CreationalContext<?> creationalContextOfHandler = beanManager.createCreationalContext(handlerBean);

        H handlerInstance = (H)beanManager.getReference(handlerBean, this.handlerClass, creationalContextOfHandler);

        if (handlerBean.getScope().equals(Dependent.class))
        {
            this.creationalContextOfDependentHandler = creationalContextOfHandler;
        }
        return handlerInstance;
    }

        if (this.creationalContextOfDependentHandler != null)
        {
            this.creationalContextOfDependentHandler.release();
        }

import javax.enterprise.context.Dependent;
@Dependent //normal-scopes are possible as well
    public <M> JsfMessage<M> createJsfMessage(InjectionPoint injectionPoint)
        if (!(injectionPoint.getType() instanceof ParameterizedType))
        try
        {
            @SuppressWarnings("unchecked")
            Class<M> type = (Class<M>) actualTypes[0];
            return createJsfMessageFor(injectionPoint, type);
        }
        catch (ClassCastException e)
        {
            throw new IllegalArgumentException("Incorrect class found when trying to convert to parameterized type",e);
        }
    private <M> JsfMessage<M> createJsfMessageFor(InjectionPoint injectionPoint, Class<M> rawType)
        // X TODO check if the JsfMessage should get injected into a UIComponent and use #getClientId()
        return new DefaultJsfMessage<M>(rawType, null);
import java.lang.annotation.Annotation;
     * will be started. Or the {@link javax.enterprise.inject.Default} {@link javax.persistence.EntityManager}
     * will be used, if no qualifier and no {@link javax.persistence.EntityManager} was found (in the annotated class)
     * (see DELTASPIKE-320).
     *
     * This qualifier can also be used for integrating other frameworks,
     * which follow a different style (see DELTASPIKE-319) as well as the usage of
     * {@link javax.persistence.EntityManager}s with qualifiers in a called method (of a different bean)
     * which isn't {@link Transactional} itself.
     *
    private static final long serialVersionUID = -6272327391611428125L;

        //see DELTASPIKE-320
        if (emQualifiers.isEmpty())
        {
            emQualifiers.add(Default.class);
        }
        if (arguments != null)
        {
            Collections.addAll(this.arguments, arguments);
        }
import java.util.Collection;
    
    /**
     * Argument array.  Similar to argument except it is meant to handle an array being passed in via a chain.
     * 
     * @param arguments
     *            the arguments
     * @return the message
     */
    Message argumentArray(Serializable[] arguments);
    
    /**
     * Argument.  Similar to the other argument methods, exception it handles collections.
     * 
     * @param arguments
     *            the arguments
     * @return the message
     */
    Message argument(Collection<Serializable> arguments);
import java.util.Collection;

    @Override
    public Message argumentArray(Serializable[] arguments)
    {
        if (arguments != null)
        {
            return argument(Arrays.asList(arguments)); 
        }
        return this;
    }

    @Override
    public Message argument(Collection<Serializable> arguments)
    {
        if (arguments != null)
        {
            this.arguments.addAll(arguments); 
        }
        return this;
    }
        final MBeanServer server = mBeanServer();
        if (server.isRegistered(objectName)
                && "true".equals(ConfigResolver.getPropertyValue("deltaspike.mbean.auto-unregister", "true")))
        {
            server.unregisterMBean(objectName);
        }
        server.registerMBean(mbean, objectName);
import java.util.HashMap;
import javax.enterprise.inject.Typed;

import org.apache.deltaspike.core.util.ClassUtils;
    public static Map<String, String> getAllProperties()
    {
        List<ConfigSource> appConfigSources =
                sortAscending(new ArrayList<ConfigSource>(Arrays.asList(getConfigSources())));
        Map<String, String> result = new HashMap<String, String>();

        for (ConfigSource configSource : appConfigSources)
        {
            result.putAll(configSource.getProperties());
        }

        return Collections.unmodifiableMap(result);
    }


import java.util.Map;

     * Return properties contained in this config source.
     * @return Properties available in this config source.
     */
    Map<String, String> getProperties();

    /**


 * which uses {@link System#getenv()}
class EnvironmentPropertyConfigSource extends MapConfigSource
        super(System.getenv());
    
import java.util.HashMap;
import java.util.Map;
import org.apache.deltaspike.core.impl.util.JndiUtils;

            return JndiUtils.lookup(getJndiKey(key), String.class);
    private String getJndiKey(String key)
    {
        if (key.startsWith("java:comp/env"))
        {
            return key;
        }
        return BASE_NAME  key;
    }

    @Override
    public Map<String, String> getProperties()
    {
        Map<String, String> result = new HashMap<String, String>();
        result.putAll(JndiUtils.list(BASE_NAME, String.class));
        result.putAll(JndiUtils.list("java:comp/env", String.class));
        return result;
    }


import org.apache.deltaspike.core.util.PropertyFileUtils;
class PropertyFileConfigSource extends PropertiesConfigSource
        super(PropertyFileUtils.loadProperties(propertyFileUrl));
 * which uses {@link System#getProperties()}
class SystemPropertyConfigSource extends PropertiesConfigSource
        super(System.getProperties());
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.naming.Name;
import javax.naming.NameClassPair;
import javax.naming.NameParser;
import javax.naming.NamingEnumeration;

import org.apache.deltaspike.core.util.ClassUtils;
    public static <T> T lookup(Name name, Class<? extends T> targetType)
            return verifyLookupResult(initialContext.lookup(name), name.toString(), targetType);

    /**
     * Resolves an instance for the given name.
     *
     * @param name       current name
     * @param targetType target type
     * @param <T>        type
     * @return the found instance, null otherwise
     */
    public static <T> T lookup(String name, Class<? extends T> targetType)
    {
        try
        {
            return verifyLookupResult(initialContext.lookup(name), name, targetType);
        }
        catch (NamingException e)
        {
            throw new IllegalStateException("Could not get "  name  " from JNDI", e);
        }
    }

    /**
     * Does a checks on given instance looked up previously from JNDI.
     *
     * @param name       current name
     * @param targetType target type
     * @param <T>        type
     * @return the found instance, null otherwise
     */
    @SuppressWarnings("unchecked")
    private static <T> T verifyLookupResult(Object result, String name, Class<? extends T> targetType)
    {
        if (result != null)
        {
            if (targetType.isAssignableFrom(result.getClass()))
            {
                // we have a value and the type fits
                return (T) result;
            }
            else if (result instanceof String) //but the target type != String
            {
                // lookedUp might be a class name
                try
                {
                    Class<?> classOfResult = ClassUtils.loadClassForName((String) result);
                    if (targetType.isAssignableFrom(classOfResult))
                    {
                        try
                        {
                            return (T) classOfResult.newInstance();
                        }
                        catch (Exception e)
                        {
                            // could not create instance
                            LOG.log(Level.SEVERE, "Class "  classOfResult  " from JNDI lookup for name "
                                     name  " could not be instantiated", e);
                        }
                    }
                    else
                    {
                        // lookedUpClass does not extend/implement expectedClass
                        LOG.log(Level.SEVERE, "JNDI lookup for key "  name
                                 " returned class "  classOfResult.getName()
                                 " which does not implement/extend the expected class"
                                 targetType.getName());
                    }
                }
                catch (ClassNotFoundException cnfe)
                {
                    // could not find class
                    LOG.log(Level.SEVERE, "Could not find Class "  result
                             " from JNDI lookup for name "  name, cnfe);
                }
            }
            else
            {
                // we have a value, but the value does not fit
                LOG.log(Level.SEVERE, "JNDI lookup for key "  name  " should return a value of "
                         targetType  ", but returned "  result);
            }
        }

        return null;
    }

    /**
     * Resolves an instances for the given naming context.
     *
     * @param name       context name
     * @param targetType target type
     * @param <T>        type
     * @return the found instances, null otherwise
     */
    public static <T> Map<String, T> list(String name, Class<T> type)
    {
        try
        {
            Map<String, T> result = new HashMap<String, T>();
            NameParser nameParser = initialContext.getNameParser(name);
            NamingEnumeration<NameClassPair> enumeration = initialContext.list(name);
            while (enumeration.hasMoreElements())
            {
                NameClassPair binding = enumeration.nextElement();
                Name bindingName = nameParser.parse(name).add(binding.getName());
                result.put(binding.getName(), lookup(bindingName, type));
            }
            return result;
        }
        catch (NamingException e)
        {
            throw new IllegalStateException("Could not list "  name  " from JNDI", e);
        }
    }
 * Required for view-configs which represent a (logical) page and optional for the rest (e.g. folder-configs).
/**
 * Basic descriptor for a given class and callback-type.
 * It finds and caches the method/s of the given class which are annotated with the given callback-type.
 */
 * Base descriptor for all type-safe view-configs which represents the
 * config-class and meta-data, callbacks,... provided by/bound to this class.
     * @param executorType type of the executor which allows to get a typed result (e.g. Secured.Descriptor)
     * @param executorType type of the executor which allows to get a typed result (e.g. Secured.Descriptor)
 * Specialized {@link CallbackDescriptor}
 * which provides {@link #execute} only for concrete descriptors, but doesn't expose it (-> can't get used by accident).
 * {@link ExecutableCallbackDescriptor} for simple callback-methods without (supported) parameters,
 * which exposes #execute without parameters.
 *
 * Descriptor which represents a concrete view (/page).
 *
 * A {@link ConfigDescriptor} can be bound to any config-class (without required base-type).
 * That's needed e.g. for folder-configs. Whereas {@link ViewConfigDescriptor}s only represent config-classes which
 * inherit from {@link ViewConfig} which is required for all page-configs.
 *
 * This annotation can be used to mark annotations as aggregated meta-data.
 * Core just provides this annotation, but the concrete behaviour is defined by a concrete ConfigNodeConverter.
 * E.g. DefaultConfigNodeConverter uses the result stored in ViewConfigNode#getInheritedMetaData to replace
 * default- (/ null-) values of "higher" levels with custom values of "lower" levels,
 * if #value is 'true'.
@Target({ ANNOTATION_TYPE }) //TODO re-visit and discuss method-level (for annotation-attributes)
 * A ConfigDescriptor can contain CallbackDescriptors in general as well as ExecutableCallbackDescriptors.
 * An ExecutableCallbackDescriptor can reference one or multiple callback-method/s. If there is only one callback type,
 * it's possible to annotate it with @DefaultCallback.
 * That allows to handle it in an easier fashion
 * (= without providing a special marker (-annotation) for the target method).
 *
 * If there are multiple callback types, it's needed to use custom annotations as marker for the target method.
 * (e.g. see @Secured vs. @ViewControllerBean)
 *
 * ViewConfigDescriptor viewConfigDescriptor = viewConfigResolver.getViewConfigDescriptor(PageConfig.class);
 * viewConfigDescriptor.getExecutableCallbackDescriptor(
 *   Secured.class, Secured.Descriptor.class).execute(accessDecisionVoterContext);
 * is short for
 * viewConfigDescriptor.getExecutableCallbackDescriptor(
 *   Secured.class, DefaultCallback.class, Secured.Descriptor.class).execute(accessDecisionVoterContext);
 *
 * whereas e.g.
 * viewConfigDescriptor.getExecutableCallbackDescriptor(
 *   ViewControllerBean.class, PreRenderView.class, ViewControllerBean.ViewControllerDescriptor.class).execute();
 * or just
 * viewConfigDescriptor.getExecutableCallbackDescriptor(
 * ViewControllerBean.class, PreRenderView.class, SimpleCallbackDescriptor.class).execute();
 *
 * are needed to call only @PreRenderView callbacks
 * (and not the others like @InitView which are also bound to @ViewControllerBean)
@ViewMetaData(preProcessor = ViewControllerBean.AnnotationPreProcessor.class)
    class AnnotationPreProcessor implements ConfigPreProcessor<ViewControllerBean>
                    ViewControllerBean.class, new Descriptor(metaData.value(), InitView.class));
                    ViewControllerBean.class, new Descriptor(metaData.value(), PreViewAction.class));
                    ViewControllerBean.class, new Descriptor(metaData.value(), PreRenderView.class));
                    ViewControllerBean.class, new Descriptor(metaData.value(), PostRenderView.class));
    }
    //not needed outside
    static class Descriptor extends SimpleCallbackDescriptor<Void>
    {
        protected Descriptor(Class beanClass, Class<? extends Annotation> callbackType)
            super(beanClass, callbackType);
import java.io.Serializable;
public interface NavigationParameterContext extends Serializable
        for (Annotation inheritedAnnotation : inheritedMetaData)
            ViewMetaData viewMetaData = inheritedAnnotation.annotationType().getAnnotation(ViewMetaData.class);
            Aggregated aggregated = inheritedAnnotation.annotationType().getAnnotation(Aggregated.class);
                mergedResult.add(inheritedAnnotation);
                Annotation currentNodeMetaData = findInResult(nodeViewMetaData, inheritedAnnotation);
                if (currentNodeMetaData == null)
                    Annotation mergedMetaData = findInResult(mergedResult, inheritedAnnotation);
                        mergedResult.add(inheritedAnnotation);
                        Annotation mergedAnnotation = mergeAnnotationInstance(mergedMetaData, inheritedAnnotation);
                    Annotation mergedAnnotation = mergeAnnotationInstance(currentNodeMetaData, inheritedAnnotation);
    private static final long serialVersionUID = 6027959542775130265L;

        Secured.Descriptor securedDescriptor = viewConfigDescriptor
                .getExecutableCallbackDescriptor(Secured.class, Secured.Descriptor.class);
@ViewMetaData(preProcessor = Secured.AnnotationPreProcessor.class)
    class AnnotationPreProcessor implements ConfigPreProcessor<Secured>
            viewConfigNode.registerCallbackDescriptors(Secured.class, new Descriptor(metaData.value()));
    static class Descriptor extends ExecutableCallbackDescriptor<Set<SecurityViolation>>
        public Descriptor(Class<? extends AccessDecisionVoter>[] accessDecisionVoterBeanClasses)
                .passivationCapable(true)
        /*
        injectionTarget.dispose(handlerInstance); //currently producers aren't supported
        }
        */
            if (configSource.isScannable())
            {
                result.putAll(configSource.getProperties());
            }
    
    /**
     * Determines if this config source should be scanned for its list of properties.
     * 
     * Generally, slow ConfigSources should return false here. 
     * 
     * @return true if this ConfigSource should be scanned for its list of properties, 
     * false if it should not be scanned.
     */
    boolean isScannable(); 

    @Override
    public boolean isScannable()
    {
        return true;
    }
    @Override
    public boolean isScannable()
    {
        return true;
    }

    @Override
    public boolean isScannable()
    {
        return true;
    }
 b/deltaspike/modules/partial-bean/api/src/main/java/org/apache/deltaspike/partialbean/api/annotation/PartialBeanBinding.java
package org.apache.deltaspike.partialbean.api.annotation;
public @interface PartialBeanBinding
 b/deltaspike/modules/partial-bean/impl/src/main/java/org/apache/deltaspike/partialbean/impl/PartialBeanBindingExtension.java
package org.apache.deltaspike.partialbean.impl;
import org.apache.deltaspike.partialbean.api.annotation.PartialBeanBinding;
public class PartialBeanBindingExtension implements Extension, Deactivatable
    private static final Logger LOG = Logger.getLogger(PartialBeanBindingExtension.class.getName());
                LOG.warning("@"  PartialBeanBinding.class.getName() 
                        PartialBeanBinding.class.getName()  "."));
            if (annotation.annotationType().isAnnotationPresent(PartialBeanBinding.class))
 b/deltaspike/modules/partial-bean/impl/src/main/java/org/apache/deltaspike/partialbean/impl/PartialBeanLifecycle.java
package org.apache.deltaspike.partialbean.impl;
 b/deltaspike/modules/partial-bean/impl/src/main/java/org/apache/deltaspike/partialbean/impl/PartialBeanMethodHandler.java
package org.apache.deltaspike.partialbean.impl;
 b/deltaspike/modules/partial-bean/impl/src/test/java/org/apache/deltaspike/test/core/api/partialbean/shared/CustomInterceptor.java
package org.apache.deltaspike.test.core.api.partialbean.shared;
 b/deltaspike/modules/partial-bean/impl/src/test/java/org/apache/deltaspike/test/core/api/partialbean/shared/CustomInterceptorImpl.java
package org.apache.deltaspike.test.core.api.partialbean.shared;
 b/deltaspike/modules/partial-bean/impl/src/test/java/org/apache/deltaspike/test/core/api/partialbean/uc001/PartialBean.java
package org.apache.deltaspike.test.core.api.partialbean.uc001;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
@TestPartialBeanBinding
 b/deltaspike/modules/partial-bean/impl/src/test/java/org/apache/deltaspike/test/core/api/partialbean/uc002/PartialBean.java
package org.apache.deltaspike.test.core.api.partialbean.uc002;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestBean;
@TestPartialBeanBinding
 b/deltaspike/modules/partial-bean/impl/src/test/java/org/apache/deltaspike/test/core/api/partialbean/uc003/PartialBean.java
package org.apache.deltaspike.test.core.api.partialbean.uc003;
import org.apache.deltaspike.test.core.api.partialbean.shared.CustomInterceptor;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestInterceptorAware;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestBean;
@TestPartialBeanBinding
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/api/config/view/controller/ViewControllerRef.java
@ViewMetaData(preProcessor = ViewControllerRef.AnnotationPreProcessor.class)
public @interface ViewControllerRef
     * Currently not implemented
     *
     *
    class AnnotationPreProcessor implements ConfigPreProcessor<ViewControllerRef>
        public ViewControllerRef beforeAddToConfig(ViewControllerRef metaData, ViewConfigNode viewConfigNode)
                    ViewControllerRef.class, new Descriptor(metaData.value(), InitView.class));
                    ViewControllerRef.class, new Descriptor(metaData.value(), PreViewAction.class));
                    ViewControllerRef.class, new Descriptor(metaData.value(), PreRenderView.class));
                    ViewControllerRef.class, new Descriptor(metaData.value(), PostRenderView.class));
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/api/literal/ViewControllerRefLiteral.java
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerRef;
 * Literal for {@link org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerRef}
public class ViewControllerRefLiteral extends AnnotationLiteral<ViewControllerRef> implements ViewControllerRef
    public ViewControllerRefLiteral(Class value, String name)
import org.apache.deltaspike.jsf.api.literal.ViewControllerRefLiteral;
                    viewConfigNode.getInheritedMetaData().add(new ViewControllerRefLiteral(configClass, null));
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerRef;
@ViewControllerRef(PageBean001.class)
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerRef;
@ViewControllerRef(value = PageBean002.class, name = "pageBean" /*TODO*/) //e.g. in case of producers with different @Named(...)
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerRef;
@ViewControllerRef(PageBean004.class)
//TODO introduce something like @InlineViewMetaData to replace the current implementation of
// ViewConfigExtension #addIndirectlyInheritedMetaData
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/navigation/NavigationParameter.java
package org.apache.deltaspike.core.api.config.view.navigation;
 * {@link org.apache.deltaspike.core.api.config.view.navigation.NavigationParameterContext}.
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/navigation/NavigationParameterContext.java
package org.apache.deltaspike.core.api.config.view.navigation;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/navigation/ViewNavigationHandler.java
package org.apache.deltaspike.core.api.config.view.navigation;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/navigation/event/PreViewConfigNavigateEvent.java
package org.apache.deltaspike.core.api.config.view.navigation.event;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameterContext;
import org.apache.deltaspike.core.api.config.view.navigation.ViewNavigationHandler;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameter;
import org.apache.deltaspike.core.api.config.view.navigation.event.PreViewConfigNavigateEvent;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameterContext;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameterContext;
import org.apache.deltaspike.core.api.config.view.navigation.ViewNavigationHandler;
import org.apache.deltaspike.core.api.config.view.navigation.event.PreViewConfigNavigateEvent;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameter;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameter;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameterContext;
import java.io.Serializable;
public class PageBean004 implements Serializable
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameter;
import org.apache.deltaspike.core.api.config.view.navigation.ViewNavigationHandler;
 b/deltaspike/modules/jsf/impl/src/main/java/org/apache/deltaspike/jsf/impl/config/view/navigation/DefaultNavigationParameterContext.java
package org.apache.deltaspike.jsf.impl.config.view.navigation;
 b/deltaspike/modules/jsf/impl/src/main/java/org/apache/deltaspike/jsf/impl/config/view/navigation/DefaultViewNavigationHandler.java
package org.apache.deltaspike.jsf.impl.config.view.navigation;
 b/deltaspike/modules/jsf/impl/src/main/java/org/apache/deltaspike/jsf/impl/config/view/navigation/NavigationCaseMapWrapper.java
package org.apache.deltaspike.jsf.impl.config.view.navigation;
public class NavigationCaseMapWrapper implements Map<String, Set<NavigationCase>>
 b/deltaspike/modules/jsf/impl/src/main/java/org/apache/deltaspike/jsf/impl/config/view/navigation/ViewConfigAwareNavigationHandler.java
package org.apache.deltaspike.jsf.impl.config.view.navigation;
public class ViewConfigAwareNavigationHandler extends NavigationHandler
import org.apache.deltaspike.jsf.impl.config.view.navigation.NavigationCaseMapWrapper;
import org.apache.deltaspike.jsf.impl.config.view.navigation.ViewConfigAwareNavigationHandler;
import org.apache.deltaspike.core.api.config.view.metadata.ViewConfigResolver;
import org.apache.deltaspike.jsf.impl.config.view.DefaultErrorViewAwareExceptionHandlerWrapper;
import javax.faces.context.ExceptionHandler;
    private boolean defaultErrorViewExceptionHandlerActivated;

    @Override
    public ExceptionHandler getExceptionHandler()
    {
        lazyInit();

        ExceptionHandler exceptionHandler = this.wrappedFacesContext.getExceptionHandler();

        if (this.defaultErrorViewExceptionHandlerActivated)
        {
            exceptionHandler = new DefaultErrorViewAwareExceptionHandlerWrapper(exceptionHandler);
        }
        return exceptionHandler;
    }


            ViewConfigResolver viewConfigResolver = BeanProvider.getContextualReference(ViewConfigResolver.class);

            //deactivate it, if there is no default-error-view available
            this.defaultErrorViewExceptionHandlerActivated =
                    viewConfigResolver.getDefaultErrorViewConfigDescriptor() != null &&
                            ClassDeactivationUtils.isActivated(DefaultErrorViewAwareExceptionHandlerWrapper.class);
public interface ConfigDescriptor<CT /*config type*/>
    Class<? extends CT> getConfigClass();
public interface ViewConfigDescriptor extends ConfigDescriptor<ViewConfig>
    ConfigDescriptor<?> getConfigDescriptor(String path);
    ConfigDescriptor<?> getConfigDescriptor(Class configClass);
    List<ConfigDescriptor<?>> getConfigDescriptors();
abstract class AbstractPathConfigDescriptor<CT> implements ConfigDescriptor<CT>
    private final Class<? extends CT> source;
    AbstractPathConfigDescriptor(Class<? extends CT> configClass,
    public Class<? extends CT> getConfigClass()
class DefaultFolderConfigDescriptor extends AbstractPathConfigDescriptor<Object>
                        currentViewConfigDescriptor.getViewId(), currentViewConfigDescriptor.getConfigClass());
                    if (DefaultErrorView.class.isAssignableFrom(currentViewConfigDescriptor.getConfigClass()))
                else if (DefaultErrorView.class.isAssignableFrom(currentViewConfigDescriptor.getConfigClass()))
                        "Found default-error-views: "  this.defaultErrorView.getConfigClass()  " and " 
                        currentViewConfigDescriptor.getConfigClass().getName());
                if (!viewConfigs.containsKey(currentViewConfigDescriptor.getConfigClass()))
                    viewConfigs.put(currentViewConfigDescriptor.getConfigClass(), currentViewConfigDescriptor);
    public ConfigDescriptor<?> getConfigDescriptor(String path)
    public ConfigDescriptor<?> getConfigDescriptor(Class configClass)
    public List<ConfigDescriptor<?>> getConfigDescriptors()
        ConfigDescriptor<?>[] result = this.folderDefinitionToViewDefinitionEntryMapping.values()
                .toArray(new ConfigDescriptor<?>[this.folderDefinitionToViewDefinitionEntryMapping.size()]);
        return new ArrayList<ConfigDescriptor<?>>(Arrays.asList(result));
class DefaultViewPathConfigDescriptor
        extends AbstractPathConfigDescriptor<ViewConfig>
        implements ViewConfigDescriptor
                    //in case of false it has been added already
                        addConfiguredViewParameters(entry.getConfigClass());
        if (navigateEvent.getToView().equals(viewConfigDescriptor.getConfigClass()))
                    oldViewConfigDescriptor.getConfigClass(), newViewConfigDescriptor.getConfigClass());
                errorView = errorViewDescriptor.getConfigClass();
                                    ConfigDescriptor<?> viewConfigDescriptor)
                errorView = errorPageDescriptor.getConfigClass();

    /**
     * Returns the string representation of the resource represented by #getConfigClass
     * @return relative path to the folder or page
     */
    String getPath();
     * The default implementation returns the same as ConfigDescriptor#getPath.
     * For the default implementation (and default integration with JSF) it's in place to provide a straightforward API.
     * However, e.g. an integration for a different view technology can use it e.g. for a logical id.

    @Override
    public String toString()
    {
        return getPath();
    }
    public String getPath()
    public String getPath()
    public String getViewId()
    private Map<String, ViewConfigDescriptor> viewPathToViewDefinitionEntryMapping;


        return this.viewPathToViewDefinitionEntryMapping.get(viewId);
        ConfigDescriptor<?>[] folderResult = this.folderDefinitionToViewDefinitionEntryMapping.values()
        ConfigDescriptor<?>[] viewResult = this.viewDefinitionToViewDefinitionEntryMapping.values()
                .toArray(new ConfigDescriptor<?>[this.viewDefinitionToViewDefinitionEntryMapping.size()]);

        List<ConfigDescriptor<?>> result = new ArrayList<ConfigDescriptor<?>>();
        result.addAll(Arrays.asList(folderResult));
        result.addAll(Arrays.asList(viewResult));
        return result;
        for (ConfigDescriptor folderConfigDescriptor : this.folderDefinitionToViewDefinitionEntryMapping.values())
            if (folderPathMapping.containsKey(folderConfigDescriptor.toString()))
                            folderConfigDescriptor.toString()).getConfigClass().getName() 
                    " and "  folderConfigDescriptor.getConfigClass().getName());
            folderPathMapping.put(folderConfigDescriptor.getPath(), folderConfigDescriptor);
        Map<String, ViewConfigDescriptor> viewPathMapping = new HashMap<String, ViewConfigDescriptor>();
        for (ViewConfigDescriptor pageConfigDescriptor : this.viewDefinitionToViewDefinitionEntryMapping.values())
            if (viewPathMapping.containsKey(pageConfigDescriptor.getViewId()))
                        viewPathMapping.get(
                            pageConfigDescriptor.getViewId()).getConfigClass().getName() 
                    " and "  pageConfigDescriptor.getConfigClass().getName());
            viewPathMapping.put(pageConfigDescriptor.getPath(), pageConfigDescriptor);
        this.viewPathToViewDefinitionEntryMapping = Collections.unmodifiableMap(viewPathMapping);
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/ConfigProperty.java
package org.apache.deltaspike.core.api.config;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
 * {@link org.apache.deltaspike.core.api.config.ConfigProperty}
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/metadata/Aggregated.java
package org.apache.deltaspike.core.api.config.view.metadata;
     * with {@link ViewMetaData}
     * with {@link ViewMetaData}
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/metadata/DefaultCallback.java
package org.apache.deltaspike.core.api.config.view.metadata;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/metadata/ViewMetaData.java
package org.apache.deltaspike.core.api.config.view.metadata;
import org.apache.deltaspike.core.api.config.view.metadata.Aggregated;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
 * (see {@link org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData#preProcessor()} )
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.DefaultCallback;
import org.apache.deltaspike.core.api.config.view.metadata.Aggregated;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.DefaultCallback;
import org.apache.deltaspike.core.api.config.view.metadata.DefaultCallback;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exception/control/BeforeHandles.java
package org.apache.deltaspike.core.api.exception.control;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exception/control/ExceptionHandler.java
package org.apache.deltaspike.core.api.exception.control;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exception/control/Handles.java
package org.apache.deltaspike.core.api.exception.control;
 * ({@link org.apache.deltaspike.core.api.exception.control.BeforeHandles} first), ordinal
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/exclude/Exclude.java
package org.apache.deltaspike.core.api.exclude;
 * {@link org.apache.deltaspike.core.api.exclude.Exclude#onExpression()}
import org.apache.deltaspike.core.api.exclude.Exclude;
 * {@link org.apache.deltaspike.core.api.exclude.Exclude} annotations.</p>
 * <p>Further details see {@link org.apache.deltaspike.core.api.exclude.Exclude}</p>
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
 * {@link org.apache.deltaspike.core.api.exclude.Exclude} can be used to switch between different
 * {@link org.apache.deltaspike.core.api.exclude.Exclude} at the custom
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/jmx/JmxManaged.java
package org.apache.deltaspike.core.api.jmx;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/jmx/MBean.java
package org.apache.deltaspike.core.api.jmx;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/jmx/NotificationInfo.java
package org.apache.deltaspike.core.api.jmx;
import org.apache.deltaspike.core.api.jmx.MBean;
import org.apache.deltaspike.core.api.jmx.JmxManaged;
import org.apache.deltaspike.core.api.jmx.MBean;
import org.apache.deltaspike.core.api.jmx.NotificationInfo;
import org.apache.deltaspike.core.api.jmx.MBean;
import org.apache.deltaspike.core.api.jmx.JmxManaged;
import org.apache.deltaspike.core.api.jmx.MBean;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
 * Literal for {@link org.apache.deltaspike.core.api.message.MessageContextConfig}
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/message/MessageBundle.java
package org.apache.deltaspike.core.api.message;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/message/MessageContextConfig.java
package org.apache.deltaspike.core.api.message;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/message/MessageTemplate.java
package org.apache.deltaspike.core.api.message;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
import org.apache.deltaspike.core.api.message.MessageTemplate;
 * {@link org.apache.deltaspike.core.api.message.MessageBundle}</p>
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
 b/deltaspike/modules/partial-bean/api/src/main/java/org/apache/deltaspike/partialbean/api/PartialBeanBinding.java
package org.apache.deltaspike.partialbean.api;
import org.apache.deltaspike.partialbean.api.PartialBeanBinding;
import org.apache.deltaspike.security.api.authorization.Secured;
 * {@link Secured}.<p/>
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/Secured.java
package org.apache.deltaspike.security.api.authorization;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/SecuredReturn.java
package org.apache.deltaspike.security.api.authorization;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/Secures.java
package org.apache.deltaspike.security.api.authorization;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/SecurityBindingType.java
package org.apache.deltaspike.security.api.authorization;
 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/SecurityParameterBinding.java
package org.apache.deltaspike.security.api.authorization;
 * {@link org.apache.deltaspike.security.api.authorization.Secured}
import org.apache.deltaspike.security.api.authorization.Secured;
import org.apache.deltaspike.security.api.authorization.Secures;
    @Secures
    @Secured({ })
import org.apache.deltaspike.security.api.authorization.SecuredReturn;
import org.apache.deltaspike.security.api.authorization.SecurityParameterBinding;
import org.apache.deltaspike.security.api.authorization.SecurityBindingType;
import org.apache.deltaspike.security.api.authorization.SecuredReturn;
import org.apache.deltaspike.security.api.authorization.Secures;
                if (m.isAnnotationPresent(Secures.class))
import org.apache.deltaspike.security.api.authorization.SecurityBindingType;
import org.apache.deltaspike.security.api.authorization.SecurityParameterBinding;
import org.apache.deltaspike.security.api.authorization.Secured;
import org.apache.deltaspike.security.api.authorization.Secured;
import org.apache.deltaspike.security.api.authorization.Secured;
import org.apache.deltaspike.security.api.authorization.Secures;
import org.apache.deltaspike.security.api.authorization.SecurityBindingType;
import org.apache.deltaspike.security.api.authorization.SecuredReturn;
import org.apache.deltaspike.security.api.authorization.Secures;
import org.apache.deltaspike.security.api.authorization.SecurityBindingType;
import org.apache.deltaspike.security.api.authorization.SecurityParameterBinding;
import org.apache.deltaspike.core.api.config.view.controller.literal.ViewControllerRefLiteral;
import org.apache.deltaspike.core.api.config.view.metadata.InlineViewMetaData;
import org.apache.deltaspike.core.spi.config.view.InlineMetaDataTransformer;
import org.apache.deltaspike.core.spi.config.view.TargetViewConfigProvider;
import org.apache.deltaspike.core.api.config.view.controller.ViewControllerRef;

import javax.inject.Named;
@InlineViewMetaData(
        targetViewConfigProvider = ViewRef.ViewRefTargetViewConfigProvider.class,
        inlineMetaDataTransformer = ViewRef.ViewRefInlineMetaDataTransformer.class)

    class ViewRefTargetViewConfigProvider implements TargetViewConfigProvider<ViewRef>
    {
        @Override
        public Class<? extends ViewConfig>[] getTarget(ViewRef inlineMetaData)
        {
            return inlineMetaData.config();
        }
    }

    class ViewRefInlineMetaDataTransformer implements InlineMetaDataTransformer<ViewRef, ViewControllerRef>
    {
        @Override
        public ViewControllerRef convertToViewMetaData(ViewRef inlineMetaData, Class<?> sourceClass)
        {
            String beanName = null;

            Named named = sourceClass.getAnnotation(Named.class);

            if (named != null)
            {
                beanName = named.value();
            }

            return new ViewControllerRefLiteral(sourceClass, beanName);
        }
    }
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/controller/InitView.java
package org.apache.deltaspike.core.api.config.view.controller;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/controller/PostRenderView.java
package org.apache.deltaspike.core.api.config.view.controller;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/controller/PreRenderView.java
package org.apache.deltaspike.core.api.config.view.controller;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/controller/PreViewAction.java
package org.apache.deltaspike.core.api.config.view.controller;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/controller/ViewControllerRef.java
package org.apache.deltaspike.core.api.config.view.controller;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/controller/literal/ViewControllerRefLiteral.java
package org.apache.deltaspike.core.api.config.view.controller.literal;
import org.apache.deltaspike.core.api.config.view.controller.ViewControllerRef;
 * Literal for {@link org.apache.deltaspike.core.api.config.view.controller.ViewControllerRef}
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/config/view/metadata/InlineViewMetaData.java
package org.apache.deltaspike.core.api.config.view.metadata;

import org.apache.deltaspike.core.spi.config.view.InlineMetaDataTransformer;
import org.apache.deltaspike.core.spi.config.view.TargetViewConfigProvider;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
@Target({ ANNOTATION_TYPE })

public @interface InlineViewMetaData
    Class<? extends TargetViewConfigProvider> targetViewConfigProvider();

    Class<? extends InlineMetaDataTransformer> inlineMetaDataTransformer() default InlineMetaDataTransformer.class;
import org.apache.deltaspike.core.api.config.view.metadata.InlineViewMetaData;
import org.apache.deltaspike.core.spi.config.view.InlineMetaDataTransformer;
import org.apache.deltaspike.core.spi.config.view.TargetViewConfigProvider;
import org.apache.deltaspike.core.util.ClassUtils;
            InlineViewMetaData inlineViewMetaData = annotation.annotationType().getAnnotation(InlineViewMetaData.class);
            if (inlineViewMetaData != null)
                Class<? extends TargetViewConfigProvider> targetViewConfigProviderClass =
                        inlineViewMetaData.targetViewConfigProvider();
                TargetViewConfigProvider targetViewConfigProvider =
                        ClassUtils.tryToInstantiateClass(targetViewConfigProviderClass);

                for (Class<? extends ViewConfig> viewConfigRef : targetViewConfigProvider.getTarget(annotation))
                    Class<? extends InlineMetaDataTransformer> inlineNodeTransformerClass =
                            inlineViewMetaData.inlineMetaDataTransformer();

                    if (!InlineMetaDataTransformer.class.equals(inlineNodeTransformerClass))
                    {
                        InlineMetaDataTransformer inlineMetaDataTransformer =
                                ClassUtils.tryToInstantiateClass(inlineNodeTransformerClass);

                        viewConfigNode.getInheritedMetaData().add(
                                inlineMetaDataTransformer.convertToViewMetaData(annotation, configClass));
                    }
                    else //no custom transformer registered -> add the annotation itself
                    {
                        viewConfigNode.getInheritedMetaData().add(annotation);
                    }
import org.apache.deltaspike.core.api.config.view.controller.PreRenderView;
import org.apache.deltaspike.core.api.config.view.controller.ViewControllerRef;
import org.apache.deltaspike.core.api.config.view.controller.PostRenderView;
import org.apache.deltaspike.core.api.config.view.controller.ViewControllerRef;
import org.apache.deltaspike.core.api.config.view.controller.InitView;
import org.apache.deltaspike.core.api.config.view.controller.PreViewAction;
import org.apache.deltaspike.core.api.config.view.controller.PreRenderView;
import org.apache.deltaspike.core.api.config.view.controller.PreRenderView;
import org.apache.deltaspike.core.api.config.view.controller.ViewControllerRef;
import org.apache.deltaspike.core.util.ClassUtils;
import java.lang.reflect.Proxy;
//The usage of reflection and the indirection for MethodHandler is needed to avoid the hard dependency to javassist.
//Some users don't like to have it as a required dependency,
// but they would like to use interfaces for partial beans and don't need abstract classes as partial beans.

//We use these indirections as >intermediate< approach. That way no classpath-scanner can cause issues.
    private final boolean isInterfaceMode;
            this.isInterfaceMode = true;
            this.partialBeanProxyClass = partialBeanClass;
            this.isInterfaceMode = false;
            try
            {
                Object proxyFactory = ClassUtils.tryToInstantiateClassForName("javassist.util.proxy.ProxyFactory");

                Method setSuperclassMethod = proxyFactory.getClass().getDeclaredMethod("setSuperclass", Class.class);
                setSuperclassMethod.invoke(proxyFactory, partialBeanClass);

                Method createClassMethod = proxyFactory.getClass().getDeclaredMethod("createClass");

                this.partialBeanProxyClass =
                        ((Class<?>) createClassMethod.invoke(proxyFactory)).asSubclass(partialBeanClass);
            }
            catch (Exception e)
            {
                throw ExceptionUtils.throwAsRuntimeException(e);
            }
        /*TODO re-visit the need of MethodFilter - we would need an indirection for it as with MethodHandler
         */
            T instance = createPartialBeanProxyInstance(handlerInstance);
    private T createPartialBeanProxyInstance(H handlerInstance) throws Exception
    {
        T instance;

        if (this.isInterfaceMode)
        {
            instance = (T) Proxy.newProxyInstance(
                    ClassUtils.getClassLoader(this), new Class[]{this.partialBeanProxyClass}, handlerInstance);
        }
        else //partial-bean is an interface
        {
            instance = this.partialBeanProxyClass.newInstance();

            Class methodHandlerClass = ClassUtils.tryToLoadClassForName("javassist.util.proxy.MethodHandler");
            Method setHandlerMethod = ClassUtils.tryToLoadClassForName("javassist.util.proxy.ProxyObject")
                    .getDeclaredMethod("setHandler", methodHandlerClass);


            MethodHandlerProxy methodHandlerProxy = new MethodHandlerProxy();
            methodHandlerProxy.setPartialBeanMethodHandler(new PartialBeanMethodHandler<H>(handlerInstance));

            Object methodHandler = Proxy.newProxyInstance(
                    ClassUtils.getClassLoader(this), new Class[]{methodHandlerClass}, methodHandlerProxy);

            setHandlerMethod.invoke(instance, methodHandler);
        }
        return instance;
    }

/**
 * At runtime it will be called from {@link MethodHandlerProxy} as instance of javassist.util.proxy.MethodHandler
 */
class PartialBeanMethodHandler<T extends InvocationHandler>
    //Signature given by javassist.util.proxy.MethodHandler#invoke
    private PartialBeanAbstractMethodHandler partialBeanMethodHandler;
    void setPartialBeanMethodHandler(PartialBeanAbstractMethodHandler partialBeanMethodHandler)
 b/deltaspike/modules/partial-bean/impl/src/main/java/org/apache/deltaspike/partialbean/impl/PartialBeanAbstractMethodHandler.java
 * Handler used for partial-beans which are abstract-classes.
class PartialBeanAbstractMethodHandler<T extends InvocationHandler>
    PartialBeanAbstractMethodHandler(T handlerInstance)
            methodHandlerProxy.setPartialBeanMethodHandler(new PartialBeanAbstractMethodHandler<H>(handlerInstance));
        H handlerInstance = (H) ((PartialBeanAbstractMethodHandler)((ProxyObject) instance)
          .getHandler()).getHandlerInstance();
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.util.ClassUtils;
    /**
     * Allows to add a custom inline path-builder
     * (a custom default implementation can be configured globally via the config mechanism provided by DeltaSpike)
     * @return path builder which allows to customize the naming conventions for the folder-name
     */
    Class<? extends NameBuilder> folderNameBuilder() default DefaultFolderNameBuilder.class;

            /*
             * file name
             */
            NameBuilder folderNameBuilder = getFolderNameBuilder(folder);
            String name = folderNameBuilder.build(folder, viewConfigNode);
            if (folderNameBuilder.isDefaultValueReplaced())
                return new FolderLiteral(name, folder.folderNameBuilder());

        private NameBuilder getFolderNameBuilder(Folder folder)
        {
            NameBuilder folderNameBuilder;
            if (DefaultFolderNameBuilder.class.equals(folder.folderNameBuilder()))
            {
                String customDefaultFolderNameBuilderClassName =
                        ConfigResolver.getPropertyValue(DefaultFolderNameBuilder.class.getName(), null);

                if (customDefaultFolderNameBuilderClassName != null)
                {
                    folderNameBuilder =
                        (NameBuilder) ClassUtils.tryToInstantiateClassForName(customDefaultFolderNameBuilderClassName);
                }
                else
                {
                    folderNameBuilder = new DefaultFolderNameBuilder();
                }
            }
            else
            {
                folderNameBuilder = ClassUtils.tryToInstantiateClass(folder.folderNameBuilder());
            }
            return folderNameBuilder;
        }
    }

    //TODO discuss if we use a central interface in the spi package
    //advantage: can be reused
    //disadvantage: a wrong builder can get assigned more easily, show usages will list more
    interface NameBuilder
    {
        String build(Folder folder, ViewConfigNode viewConfigNode);

        boolean isDefaultValueReplaced();
    }

    class DefaultFolderNameBuilder implements NameBuilder
    {
        private boolean defaultValueReplaced = false;

        @Override
        public String build(Folder folder, ViewConfigNode viewConfigNode)
        {
            String name = folder.name();

            if (name == null /*null used as marker value for dyn. added instances*/ || ".".equals(name) /*default*/)
            {
                this.defaultValueReplaced = true;
                name = NamingConventionUtils.toPath(viewConfigNode);
            }

            if (name != null && name.startsWith("."))
            {
                name = NamingConventionUtils.toPath(viewConfigNode.getParent())  name.substring(1);

                this.defaultValueReplaced = true;
            }

            if (name != null && name.contains("//"))
            {
                name = name.replace("//", "/");

                this.defaultValueReplaced = true;
            }

            return name;
        }

        public boolean isDefaultValueReplaced()
        {
            return defaultValueReplaced;
        }
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.util.ClassUtils;
     * Allows to add a custom inline path-builder
     * (a custom default implementation can be configured globally via the config mechanism provided by DeltaSpike)
     * @return path builder which allows to customize the naming conventions for the base-path
     */
    Class<? extends NameBuilder> basePathBuilder() default DefaultBasePathBuilder.class;

    /**
     * Allows to add a custom inline path-builder
     * (a custom default implementation can be configured globally via the config mechanism provided by DeltaSpike)
     * @return path builder which allows to customize the naming conventions for the file-name
     */
    Class<? extends NameBuilder> fileNameBuilder() default DefaultFileNameBuilder.class;

    /**
     * Allows to add a custom inline path-builder
     * (a custom default implementation can be configured globally via the config mechanism provided by DeltaSpike)
     * @return path builder which allows to customize the naming conventions for the file-extension
     */
    Class<? extends NameBuilder> extensionBuilder() default DefaultExtensionBuilder.class;

    /**
    interface Extension
    enum NavigationMode
    enum ViewParameterMode
            /*
             * base path
             */
            NameBuilder basePathBuilder = getBasePathBuilder(view);
            String basePath = basePathBuilder.build(view, viewConfigNode);

            if (basePathBuilder.isDefaultValueReplaced())
            /*
             * file name
             */
            NameBuilder fileNameBuilder = getFileNameBuilder(view);
            String name = fileNameBuilder.build(view, viewConfigNode);

            if (fileNameBuilder.isDefaultValueReplaced())
            /*
             * extension
             */
            NameBuilder extensionBuilder = getExtensionBuilder(view);
            String extension = extensionBuilder.build(view, viewConfigNode);

            if (extensionBuilder.isDefaultValueReplaced())
            /*
             * navigation
             */
                return new ViewLiteral(basePath, name, extension, navigation, viewParams,
                        view.basePathBuilder(), view.fileNameBuilder(), view.extensionBuilder());
        private NameBuilder getBasePathBuilder(View view)
        {
            NameBuilder basePathBuilder;
            if (DefaultBasePathBuilder.class.equals(view.basePathBuilder()))
            {
                String customDefaultBasePathBuilderClassName =
                        ConfigResolver.getPropertyValue(DefaultBasePathBuilder.class.getName(), null);

                if (customDefaultBasePathBuilderClassName != null)
                {
                    basePathBuilder =
                        (NameBuilder)ClassUtils.tryToInstantiateClassForName(customDefaultBasePathBuilderClassName);
                }
                else
                {
                    basePathBuilder = new DefaultBasePathBuilder();
                }
            }
            else
            {
                basePathBuilder = ClassUtils.tryToInstantiateClass(view.basePathBuilder());
            }
            return basePathBuilder;
        }

        private NameBuilder getFileNameBuilder(View view)
        {
            NameBuilder fileNameBuilder;
            if (DefaultFileNameBuilder.class.equals(view.fileNameBuilder()))
            {
                String customDefaultFileNameBuilderClassName =
                        ConfigResolver.getPropertyValue(DefaultFileNameBuilder.class.getName(), null);

                if (customDefaultFileNameBuilderClassName != null)
                {
                    fileNameBuilder =
                        (NameBuilder)ClassUtils.tryToInstantiateClassForName(customDefaultFileNameBuilderClassName);
                }
                else
                {
                    fileNameBuilder = new DefaultFileNameBuilder();
                }
            }
            else
            {
                fileNameBuilder = ClassUtils.tryToInstantiateClass(view.fileNameBuilder());
            }
            return fileNameBuilder;
        }

        private NameBuilder getExtensionBuilder(View view)
        {
            NameBuilder extensionBuilder;
            if (DefaultExtensionBuilder.class.equals(view.extensionBuilder()))
            {
                String customDefaultExtensionBuilderClassName =
                        ConfigResolver.getPropertyValue(DefaultExtensionBuilder.class.getName(), null);

                if (customDefaultExtensionBuilderClassName != null)
                {
                    extensionBuilder =
                        (NameBuilder)ClassUtils.tryToInstantiateClassForName(customDefaultExtensionBuilderClassName);
                }
                else
                {
                    extensionBuilder = new DefaultExtensionBuilder();
                }
            }
            else
            {
                extensionBuilder = ClassUtils.tryToInstantiateClass(view.extensionBuilder());
            }
            return extensionBuilder;
        }

        private static boolean isView(Class source)

    //TODO discuss if we use a central interface in the spi package
    //advantage: can be reused
    //disadvantage: a wrong builder can get assigned more easily, show usages will list more
    interface NameBuilder
    {
        String build(View view, ViewConfigNode viewConfigNode);

        boolean isDefaultValueReplaced();
    }

    abstract class AbstractNameBuilder implements NameBuilder
    {
        protected boolean defaultValueReplaced = false;

        public boolean isDefaultValueReplaced()
        {
            return defaultValueReplaced;
        }
    }

    class DefaultBasePathBuilder extends AbstractNameBuilder
    {
        @Override
        public String build(View view, ViewConfigNode viewConfigNode)
        {
            String basePath = view.basePath();
            Class source = viewConfigNode.getSource();

            if (("".equals(basePath) || basePath == null) &&
                    ViewConfigPreProcessor.isView(source) /*only calc the path for real pages*/)
            {
                this.defaultValueReplaced = true;

                basePath = NamingConventionUtils.toPath(viewConfigNode.getParent());
            }

            if (basePath != null && basePath.startsWith("."))
            {
                basePath = NamingConventionUtils.toPath(viewConfigNode.getParent())  basePath.substring(1);

                this.defaultValueReplaced = true;
            }

            if (basePath != null && basePath.contains("//"))
            {
                basePath = basePath.replace("//", "/");

                this.defaultValueReplaced = true;
            }

            return basePath;
        }
    }

    class DefaultFileNameBuilder extends AbstractNameBuilder
    {
        @Override
        public String build(View view, ViewConfigNode viewConfigNode)
        {
            String name = view.name();
            Class source = viewConfigNode.getSource();

            if (("".equals(name) || name == null) &&
                    ViewConfigPreProcessor.isView(source) /*only calc the path for real pages*/)
            {
                this.defaultValueReplaced = true;
                String className = viewConfigNode.getSource().getSimpleName();
                name = className.substring(0, 1).toLowerCase()  className.substring(1);
            }

            return name;
        }
    }

    class DefaultExtensionBuilder extends AbstractNameBuilder
    {
        @Override
        public String build(View view, ViewConfigNode viewConfigNode)
        {
            String extension = view.extension();

            if (View.Extension.DEFAULT.equals(extension) || extension == null)
            {
                defaultValueReplaced = true;
                extension = XHTML;
            }

            return extension;
        }
    }
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.util.ClassUtils;
    private final Class<? extends NameBuilder> folderNameBuilder;

        final String customDefaultFolderNameBuilderClassName =
                ConfigResolver.getPropertyValue(Folder.DefaultFolderNameBuilder.class.getName(), null);

        if (customDefaultFolderNameBuilderClassName != null)
        {
            this.folderNameBuilder = ClassUtils.tryToLoadClassForName(customDefaultFolderNameBuilderClassName);
        }
        else
        {
            this.folderNameBuilder = DefaultFolderNameBuilder.class;
        }
    public FolderLiteral(String name, Class<? extends NameBuilder> folderNameBuilder)
        this.folderNameBuilder = folderNameBuilder;
    @Override
    public Class<? extends NameBuilder> folderNameBuilder()
    {
        return this.folderNameBuilder;
    }

        if (!(o instanceof FolderLiteral))
        {
            return false;
        }
        if (!folderNameBuilder.equals(that.folderNameBuilder))
        {
            return false;
        }
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result  folderNameBuilder.hashCode();
        return result;
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.util.ClassUtils;
    private final Class<? extends NameBuilder> basePathBuilder;
    private final Class<? extends NameBuilder> fileNameBuilder;
    private final Class<? extends NameBuilder> extensionBuilder;


        final String customDefaultBasePathBuilderClassName =
                ConfigResolver.getPropertyValue(DefaultBasePathBuilder.class.getName(), null);

        if (customDefaultBasePathBuilderClassName != null)
        {
            this.basePathBuilder = ClassUtils.tryToLoadClassForName(customDefaultBasePathBuilderClassName);
        }
        else
        {
            this.basePathBuilder = DefaultBasePathBuilder.class;
        }


        final String customDefaultFileNameBuilderClassName =
                ConfigResolver.getPropertyValue(DefaultFileNameBuilder.class.getName(), null);

        if (customDefaultFileNameBuilderClassName != null)
        {
            this.fileNameBuilder = ClassUtils.tryToLoadClassForName(customDefaultFileNameBuilderClassName);
        }
        else
        {
            this.fileNameBuilder = DefaultFileNameBuilder.class;
        }


        final String customDefaultExtensionBuilderClassName =
                ConfigResolver.getPropertyValue(DefaultExtensionBuilder.class.getName(), null);

        if (customDefaultExtensionBuilderClassName != null)
        {
            this.extensionBuilder = ClassUtils.tryToLoadClassForName(customDefaultExtensionBuilderClassName);
        }
        else
        {
            this.extensionBuilder = DefaultExtensionBuilder.class;
        }
                       ViewParameterMode viewParams,
                       Class<? extends NameBuilder> basePathBuilder,
                       Class<? extends NameBuilder> fileNameBuilder,
                       Class<? extends NameBuilder> extensionBuilder)
        this.basePathBuilder = basePathBuilder;
        this.fileNameBuilder = fileNameBuilder;
        this.extensionBuilder = extensionBuilder;
    @Override
    public Class<? extends NameBuilder> basePathBuilder()
    {
        return this.basePathBuilder;
    }

    @Override
    public Class<? extends NameBuilder> fileNameBuilder()
    {
        return this.fileNameBuilder;
    }

    @Override
    public Class<? extends NameBuilder> extensionBuilder()
    {
        return this.extensionBuilder;
    }

        if (!(o instanceof ViewLiteral))
        {
            return false;
        }
        if (!basePathBuilder.equals(that.basePathBuilder))
        {
            return false;
        }
        if (!extensionBuilder.equals(that.extensionBuilder))
        {
            return false;
        }
        if (!fileNameBuilder.equals(that.fileNameBuilder))
        {
            return false;
        }
        result = 31 * result  basePathBuilder.hashCode();
        result = 31 * result  fileNameBuilder.hashCode();
        result = 31 * result  extensionBuilder.hashCode();
import org.apache.deltaspike.jsf.api.config.view.Folder;

import java.lang.annotation.Annotation;
        Folder folderMetaData = null;
        for (Annotation nodeMetaData : node.getMetaData())
        {
            if (Folder.class.isAssignableFrom(nodeMetaData.annotationType()))
            {
                folderMetaData = (Folder)nodeMetaData;
            }
        }


        String folderName = null;

        if (folderMetaData != null)
        {
            folderName = folderMetaData.name();
        }

        if (folderName == null)
        {
            folderName = node.getSource().getSimpleName();
            folderName = "./"  folderName.substring(0, 1).toLowerCase()  folderName.substring(1)  "/";
        }

        //@Folder found and no relative path
        if (folderMetaData != null && !folderName.startsWith("."))
        {
            return folderName;
        }
        return toPath(node.getParent())  folderName.substring(1);
     * @param type target type
 * Context to handle &#064;{@link WindowScoped} beans.
import javax.enterprise.context.RequestScoped;

@RequestScoped
import org.apache.deltaspike.jsf.api.config.view.Folder;
        Class beanClass = pat.getAnnotatedType().getJavaClass();
        if (ViewConfig.class.isAssignableFrom(beanClass))
            if (beanClass.isAnnotationPresent(Folder.class))
            {
                addPageDefinition(pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations());
                pat.veto();
            }
            else
            {
                addIndirectlyInheritedMetaData(
                        pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations());
            }
            addConfigClass(pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations());
            if (ViewConfigUtils.isFolderConfig(beanClass) && beanClass.isAnnotationPresent(Folder.class))
                addConfigClass(pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations());
        addConfigClass(viewConfigClass, new HashSet<Annotation>(Arrays.asList(viewConfigClass.getAnnotations())));
    public void addFolderDefinition(Class configClass)
    {
        if (ViewConfigUtils.isFolderConfig(configClass))
        {
            addConfigClass(configClass, new HashSet<Annotation>(Arrays.asList(configClass.getAnnotations())));
        }
        else
        {
            throw new IllegalArgumentException(configClass != null ? configClass.getName() : "null" 
                " is an invalid config for folders");
        }
    }

    protected void addConfigClass(Class viewConfigClass, Set<Annotation> viewConfigAnnotations)
import org.apache.deltaspike.core.api.config.view.ViewConfig;
import org.apache.deltaspike.jsf.api.config.view.Folder;
        return configClass != null && (
                (ViewConfig.class.isAssignableFrom(configClass) &&
                        Modifier.isAbstract(configClass.getModifiers()) ||
                        Modifier.isInterface(configClass.getModifiers())
                ) ||
                configClass.isAnnotationPresent(Folder.class));
        //empty (intentionally)
        //empty (intentionally)
        PreViewConfigNavigateEvent navigateEvent;

            navigateEvent = new PreViewConfigNavigateEvent(
        else
        {
            navigateEvent = new PreViewConfigNavigateEvent(null, newViewConfigDescriptor.getConfigClass());
        }

        this.beanManager.fireEvent(navigateEvent);
        return navigateEvent;
    private List<String> checkedViewIds = new ArrayList<String>();
        this.checkedViewIds.add(viewId);

        return viewId != null && !this.checkedViewIds.contains(viewId);
import org.apache.deltaspike.core.api.config.view.ViewRef;
            navigateEvent = new PreViewConfigNavigateEvent(
                    ViewRef.Manual.class, newViewConfigDescriptor.getConfigClass());
import org.apache.deltaspike.core.util.ExceptionUtils;
            throw ExceptionUtils.throwAsRuntimeException(e);
            throw ExceptionUtils.throwAsRuntimeException(e);
     * @param type       target type
        Map<String, T> result = new HashMap<String, T>();

            LOG.log(Level.SEVERE, "InitialContext#list failed!", e);
        return result;
 * HTTP Session. We use standard SessionScoped bean to not need
            throw new IllegalStateException("Could not get "  name  " from JNDI", e);
            throw new IllegalStateException("Could not get "  name  " from JNDI", e);
     * @param name context name
     * @param type target type
     * @param <T>  type
 * Context to handle &#064;{@link WindowScoped} beans.
 * HTTP Session. We use standard SessionScoped bean to not need
import javax.enterprise.context.RequestScoped;

@RequestScoped
import org.apache.deltaspike.core.util.ExceptionUtils;
            throw ExceptionUtils.throwAsRuntimeException(e);
            throw ExceptionUtils.throwAsRuntimeException(e);
     * @param name       context name
     * @param type       target type
     * @param <T>        type

        return getContextualReference(beanManager, type, optional, qualifiers);
    }

    /**
     * {@link #getContextualReference(Class, Annotation...)} which returns <code>null</code> if the
     * 'optional' parameter is set to <code>true</code>.
     * This method is intended for usage where the BeanManger is known, e.g. in Extensions.
     *
     * @param beanManager the BeanManager to use
     * @param type the type of the bean in question
     * @param optional if <code>true</code> it will return <code>null</code> if no bean could be found or created.
     *                 Otherwise it will throw an {@code IllegalStateException}
     * @param qualifiers additional qualifiers which further distinct the resolved bean
     * @param <T> target type
     * @return the resolved Contextual Reference
     * @see #getContextualReference(Class, Annotation...)
     */
    public static <T> T getContextualReference(BeanManager beanManager,
                                               Class<T> type,
                                               boolean optional,
                                               Annotation... qualifiers)
    {
     * This is necessary when the session gets closed down or the application closes.
import javax.enterprise.inject.spi.AfterDeploymentValidation;
import javax.enterprise.inject.spi.Extension;

import org.apache.deltaspike.core.api.provider.BeanProvider;
public class DeltaSpikeContextExtension implements Extension
    private WindowContextImpl windowContext;
        windowContext = new WindowContextImpl(beanManager);

    /**
     * We can only initialize our contexts in AfterDeploymentValidation because
     * getBeans must not be invoked earlier than this phase to reduce randomness
     * caused by Beans no being fully registered yet.
     */
    public void initializeDeltaSpikeContexts(@Observes AfterDeploymentValidation adv, BeanManager beanManager)
    {
        WindowBeanHolder windowBeanHolder
            = BeanProvider.getContextualReference(beanManager, WindowBeanHolder.class, false);

        WindowIdHolder windowIdHolder
            = BeanProvider.getContextualReference(beanManager, WindowIdHolder.class, false);

        windowContext.initWindowContext(windowBeanHolder, windowIdHolder);
    }

    public WindowContextImpl getWindowContext()
    {
        return windowContext;
    }
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/scope/window/WindowContextImpl.java
import javax.enterprise.inject.Typed;
@Typed()
public class WindowContextImpl extends AbstractContext implements WindowContext
    public WindowContextImpl(BeanManager beanManager)

    void initWindowContext(WindowBeanHolder windowBeanHolder, WindowIdHolder windowIdHolder)
    {
        this.windowBeanHolder = windowBeanHolder;
        this.windowIdHolder = windowIdHolder;
    }
 * Simple class which just provides a &#064;RequestScoped windowId.
 * This assures that there is maximum one single windowId associated
 * with a single Thread or Request. We use &#064;RequestScoped because
 * this also works in async-supported Servlets without having to
 * take care about moving info between ThreadLocals.
 * 'windowId' inside the current Session.
 * Each Thread is associated with at most
    void activateWindow(String windowId);
     * close the WindowContext with the given windowId.
    boolean closeWindow(String windowId);
     * Destroys all the Contextual Instances in the specified ContextualStorage.
     * This is a static method to allow various holder objects to cleanup
     * properly in &#064;PreDestroy.
    public static void destroyAllActive(ContextualStorage storage)
import javax.annotation.PreDestroy;
import org.apache.deltaspike.core.util.context.AbstractContext;
    //X TODO review usage

    @PreDestroy
    public void destroyBeans()
    {
        // we replace the old windowBeanHolder beans with a new storage Map
        // an afterwards destroy the old Beans without having to care about any syncs.
        Map<String, ContextualStorage> oldWindowContextStorages = forceNewStorage();

        for (ContextualStorage contextualStorage : oldWindowContextStorages.values())
        {
            AbstractContext.destroyAllActive(contextualStorage);
        }

    }
     * Holds the currently active windowId of each Request

    /**
     * Contains the stored WindowScoped contextual instances.
     */
    /**
     * needed for serialisation and passivationId
     */
    /**
     * We need to pass the session scoped windowbean holder and the
     * requestscoped windowIdHolder in a later phase because
     * getBeans is only allowed from AfterDeploymentValidation onwards.
     */
    void initWindowContext(WindowBeanHolder windowBeanHolder, WindowIdHolder windowIdHolder)
    {
        this.windowBeanHolder = windowBeanHolder;
        this.windowIdHolder = windowIdHolder;
    }


    public void activateWindow(String windowId)
    public boolean closeWindow(String windowId)
        ContextualStorage windowStorage = windowBeanHolder.getContextualStorage(beanManager, windowId);
        if (windowStorage == null)
    /**
     * This method properly destroys all current &#064;WindowScoped beans
     * of the active session and also prepares the storage for new beans.
     * It will automatically get called when the session context closes
     * but can also get invoked manually, e.g. if a user likes to get rid
     * of all it's &#064;WindowScoped beans.
     */
 * CDI Context to handle &#064;{@link WindowScoped} beans.
 * This also implements the interface to control the id of
 * the currently active 'window' (e.g. a web browser tab).
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/spi/scope/window/ClientWindowConfig.java
package org.apache.deltaspike.jsf.spi.scope.window;
        LAZY,

        /**
         * If you set this mode, you also need to provide an own {@link ClientWindow} implementation.
         */
        CUSTOM
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/spi/scope/window/DefaultClientWindowConfig.java
package org.apache.deltaspike.jsf.spi.scope.window;
 * <p>Default implementation of {@link ClientWindowConfig}.
 * By default it will use the internal <code>windowhandler.html</code></p>
 *
 * <p>You can &#064;Specializes this class to tweak the configuration or
 * provide a completely new implementation as &#064;Alternative.</p>
        //X TODO add ClientWindow handling


    private Map<String, ContextualStorage> storageMap = new ConcurrentHashMap<String, ContextualStorage>();
    public Map<String, ContextualStorage> getStorageMap()
    {
        return storageMap;
    }

import org.apache.deltaspike.core.spi.scope.window.WindowContext;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
    private ClientWindow clientWindow;
    private WindowContext windowContext;

        lazyInit();

        // ClientWindow handling
        String windowId = clientWindow.getWindowId(facesContext);
        if (windowId != null)
        {
            windowContext.activateWindow(windowId);
        }

        if (initialized == null)
                beforeAfterJsfRequestBroadcaster =

                clientWindow =
                        BeanProvider.getContextualReference(ClientWindow.class, true);

                windowContext =
                        BeanProvider.getContextualReference(WindowContext.class, true);
            initialized = true;
import javax.faces.FacesException;
import javax.faces.context.ExternalContext;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.OutputStream;
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
    private static final String WINDOW_ID_COOKIE_PREFIX = "dsWindowId-";
    private static final String DELTASPIKE_REQUEST_TOKEN = "dsRid";

    private static final String UNINITIALIZED_WINDOW_ID_VALUE = "uninitializedWindowId";
    private static final String WINDOW_ID_REPLACE_PATTERN = "$$windowIdValue$$";
    private static final String NOSCRIPT_URL_REPLACE_PATTERN = "$$noscriptUrl$$";

    /**
     * Use this parameter to force a 'direct' request from the clients without any windowId detection
     * We keep this name for backward compat with CODI.
     */
    private static final String NOSCRIPT_PARAMETER = "mfDirect";

    /**
     * This windowId will be used for all requests with disabled windowId feature
     */
    private static final String DEFAULT_WINDOW_ID = "default";

            // if this request should not get any window detection then we are done
            return DEFAULT_WINDOW_ID;
            // for POST we read the windowId from the WindowIdHolderComponent in our ViewRoot
        ExternalContext externalContext = facesContext.getExternalContext();

        // and now for the GET request stuff
        if (isNoscriptRequest(externalContext))
        {
            // the client has JavaScript disabled
            clientWindowConfig.setJavaScriptEnabled(false);

            return DEFAULT_WINDOW_ID;
        }

        String windowId = getVerifiedWindowIdFromCookie(externalContext);
        if (windowId == null)
        {
            // GET request without windowId - send windowhandlerfilter.html to get the windowId
            sendWindowHandlerHtml(externalContext, null);
            facesContext.responseComplete();
        }

        // we have a valid windowId - set it and continue with the request
    private boolean isNoscriptRequest(ExternalContext externalContext)
    {
        String noscript = externalContext.getRequestParameterMap().get(NOSCRIPT_PARAMETER);

        return (noscript != null && "true".equals(noscript));
    }


    private void sendWindowHandlerHtml(ExternalContext externalContext, String windowId)
    {
        HttpServletResponse httpResponse = (HttpServletResponse) externalContext.getResponse();

        try
        {
            httpResponse.setStatus(HttpServletResponse.SC_OK);
            httpResponse.setContentType("text/html");

            String windowHandlerHtml = clientWindowConfig.getClientWindowHtml();

            if (windowId == null)
            {
                windowId = UNINITIALIZED_WINDOW_ID_VALUE;
            }

            // set the windowId value in the javascript code
            windowHandlerHtml = windowHandlerHtml.replace(WINDOW_ID_REPLACE_PATTERN, windowId);

            // set the noscript-URL for users with no JavaScript
            windowHandlerHtml =
                    windowHandlerHtml.replace(NOSCRIPT_URL_REPLACE_PATTERN, getNoscriptUrl(externalContext));

            OutputStream os = httpResponse.getOutputStream();
            try
            {
                os.write(windowHandlerHtml.getBytes());
            }
            finally
            {
                os.close();
            }
        }
        catch (IOException ioe)
        {
            throw new FacesException(ioe);
        }
    }

    private String getNoscriptUrl(ExternalContext externalContext)
    {
        String url = externalContext.getRequestPathInfo();
        if (url == null)
        {
            url = "";
        }

        // only use the very last part of the url
        int lastSlash = url.lastIndexOf('/');
        if (lastSlash != -1)
        {
            url = url.substring(lastSlash  1);
        }

        // add request parameter
        url = JsfUtils.addPageParameters(externalContext, url, true);

        // add noscript parameter
        if (url.contains("?"))
        {
            url = url  "&";
        }
        else
        {
            url = url  "?";
        }
        url = url  NOSCRIPT_PARAMETER  "=true";

        // NOTE that the url could contain data for an XSS attack
        // like e.g. ?"></a><a href%3D"http://hacker.org/attack.html?a
        // DO NOT REMOVE THE FOLLOWING LINES!
        url = url.replace("\"", "");
        url = url.replace("\'", "");

        return url;
    }

    private String getVerifiedWindowIdFromCookie(ExternalContext externalContext)
    {
        String cookieName = WINDOW_ID_COOKIE_PREFIX  getRequestToken(externalContext);
        Cookie cookie = (Cookie) externalContext.getRequestCookieMap().get(cookieName);

        if (cookie != null)
        {
            // manually blast the cookie away, otherwise it pollutes the
            // cookie storage in some browsers. E.g. Firefox doesn't
            // cleanup properly, even if the max-age is reached.
            cookie.setMaxAge(0);

            return cookie.getValue();
        }

        return null;
    }

    private String getRequestToken(ExternalContext externalContext)
    {
        String requestToken = externalContext.getRequestParameterMap().get(DELTASPIKE_REQUEST_TOKEN);
        if (requestToken != null)
        {
            return requestToken;
        }

        return "";
    }

import org.apache.deltaspike.core.api.config.view.controller.InitView;
import org.apache.deltaspike.core.api.config.view.controller.PostRenderView;
import org.apache.deltaspike.core.api.config.view.controller.PreRenderView;
import org.apache.deltaspike.core.api.config.view.metadata.ViewConfigDescriptor;
import org.apache.deltaspike.core.api.config.view.metadata.ViewConfigResolver;
import org.apache.deltaspike.jsf.impl.util.ViewControllerUtils;
import javax.enterprise.context.ContextNotActiveException;
import javax.faces.component.UIViewRoot;
    private ViewConfigResolver viewConfigResolver;

        if (this.viewConfigResolver == null)
        {
            lazyInit();
        }

        processInitView(phaseEvent);

        processPreRenderView(facesContext);
        if (this.viewConfigResolver == null)
            lazyInit();
        }

        processInitView(phaseEvent);

        if (PhaseId.RENDER_RESPONSE.equals(phaseEvent.getPhaseId()))
        {
            onAfterRenderResponse(phaseEvent.getFacesContext());
    private void onAfterRenderResponse(FacesContext facesContext)
        processPostRenderView(facesContext);
        this.viewConfigResolver = BeanProvider.getContextualReference(ViewConfigResolver.class);


    private void processInitView(PhaseEvent event)
    {
        if (event.getPhaseId().equals(PhaseId.RESTORE_VIEW) && !isRedirectRequest(event.getFacesContext()))
        {
            return;
        }

        //TODO check if we have to restrict the other callbacks as well
        //leads to a call of @BeforePhase but not the corresponding @AfterPhase call of the corresponding callbacks

        //TODO don't call the callbacks in case of an initial redirct
        //was:
        /*
        if(Boolean.TRUE.equals(event.getFacesContext().getExternalContext().getRequestMap()
                .get(WindowContextManagerObserver.INITIAL_REDIRECT_PERFORMED_KEY)))
        {
            return;
        }
        */

        FacesContext facesContext = event.getFacesContext();
        if (facesContext.getViewRoot() != null && facesContext.getViewRoot().getViewId() != null)
        {
            processInitView(event.getFacesContext().getViewRoot().getViewId());
        }
    }

    private void processInitView(String viewId)
    {
        try
        {
            WindowMetaData windowMetaData = BeanProvider.getContextualReference(WindowMetaData.class);

            //view already initialized in this or any prev. request
            if (viewId.equals(windowMetaData.getInitializedViewId()))
            {
                return;
            }

            //override the view-id if we have a new view
            windowMetaData.setInitializedViewId(viewId);

            ViewConfigDescriptor viewDefinitionEntry = this.viewConfigResolver.getViewConfigDescriptor(viewId);

            if (viewDefinitionEntry == null)
            {
                return;
            }

            ViewControllerUtils.executeViewControllerCallback(viewDefinitionEntry, InitView.class);
        }
        catch (ContextNotActiveException e)
        {
            return; //TODO discuss how we handle it
        }
    }

    private void processPreRenderView(FacesContext facesContext)
    {
        UIViewRoot uiViewRoot = facesContext.getViewRoot();

        if (uiViewRoot != null)
        {
            ViewConfigDescriptor viewDefinitionEntry =
                    this.viewConfigResolver.getViewConfigDescriptor(uiViewRoot.getViewId());

            ViewControllerUtils.executeViewControllerCallback(viewDefinitionEntry, PreRenderView.class);
        }
    }

    private void processPostRenderView(FacesContext facesContext)
    {
        UIViewRoot uiViewRoot = facesContext.getViewRoot();

        if (uiViewRoot != null)
        {
            ViewConfigDescriptor viewDefinitionEntry =
                    this.viewConfigResolver.getViewConfigDescriptor(uiViewRoot.getViewId());

            ViewControllerUtils.executeViewControllerCallback(viewDefinitionEntry, PostRenderView.class);
        }
    }

    private boolean isRedirectRequest(FacesContext facesContext)
    {
        return facesContext.getResponseComplete();
    }
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
    private final boolean addViewConfigsAsNavigationCase;

        this.addViewConfigsAsNavigationCase = this.activated && isAddViewConfigsAsNavigationCaseActivated();
        if (!this.addViewConfigsAsNavigationCase)

    private boolean isAddViewConfigsAsNavigationCaseActivated()
    {
        JsfModuleConfig config = BeanProvider.getContextualReference(JsfModuleConfig.class);

        return config.isUseViewConfigsAsNavigationCasesEnabled();
    }
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
                    errorViewDescriptor.getMetaData(View.class).iterator().next().navigation() /*always available*/ &&
                    BeanProvider.getContextualReference(JsfModuleConfig.class)
                            .isAlwaysUseNavigationHandlerOnSecurityViolation())
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
        if (PhaseId.RESTORE_VIEW.equals(phaseEvent.getPhaseId()))
        {
            onAfterRestoreView(phaseEvent.getFacesContext());

        }
        else if (PhaseId.RENDER_RESPONSE.equals(phaseEvent.getPhaseId()))
    private void onAfterRestoreView(FacesContext facesContext)
    {
        JsfUtils.tryToRestoreMessages(facesContext);
    }

            //TODO discuss how we handle it
import org.apache.deltaspike.jsf.impl.message.FacesMessageEntry;
import java.util.List;
    /**
     * used per default instead of Flash#setKeepMessages,
     * because there are less issues in view of multi-window support esp. before jsf v2.2 and
     * a custom window-handler might have special requirements.
     */
    private List<FacesMessageEntry> facesMessageEntryList;


    public void setFacesMessageEntryList(List<FacesMessageEntry> facesMessageEntryList)
    {
        this.facesMessageEntryList = facesMessageEntryList;
    }

    public List<FacesMessageEntry> getFacesMessageEntryList()
    {
        return facesMessageEntryList;
    }
import org.apache.deltaspike.jsf.impl.message.FacesMessageEntry;
import javax.faces.application.FacesMessage;
import javax.faces.context.ExternalContext;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
    private ExternalContext wrappedExternalContext;

        if (ClassDeactivationUtils.isActivated(DeltaSpikeExternalContextWrapper.class))
        {
            this.wrappedExternalContext =
                    new DeltaSpikeExternalContextWrapper(wrappedFacesContext.getExternalContext());
        }
        else
        {
            this.wrappedExternalContext = wrappedFacesContext.getExternalContext();
        }

    /**
     * Adds the {@link FacesMessage} also to a request scoped list to allow to preserve them later on
     * (in case of redirects)
     *
     * {@inheritDoc}
     */
    @Override
    public void addMessage(String componentId, FacesMessage facesMessage)
    {
        this.wrappedFacesContext.addMessage(componentId, facesMessage);

        //don't store it directly in the window context - it would trigger a too early restore (in some cases)
        Map<String, Object> requestMap = getExternalContext().getRequestMap();

        @SuppressWarnings({ "unchecked" })
        List<FacesMessageEntry> facesMessageEntryList =
                (List<FacesMessageEntry>)requestMap.get(FacesMessageEntry.class.getName());

        if (facesMessageEntryList == null)
        {
            facesMessageEntryList = new CopyOnWriteArrayList<FacesMessageEntry>();
            requestMap.put(FacesMessageEntry.class.getName(), facesMessageEntryList);
        }

        facesMessageEntryList.add(new FacesMessageEntry(componentId, facesMessage));
    }

    @Override
    public ExternalContext getExternalContext()
    {
        return this.wrappedExternalContext;
    }

import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
import org.apache.deltaspike.jsf.impl.listener.phase.WindowMetaData;
import org.apache.deltaspike.jsf.impl.message.FacesMessageEntry;
import javax.enterprise.context.ContextNotActiveException;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

    public static void saveFacesMessages(ExternalContext externalContext)
    {
        JsfModuleConfig jsfModuleConfig = BeanProvider.getContextualReference(JsfModuleConfig.class);

        if (!jsfModuleConfig.isAlwaysKeepMessages())
        {
            return;
        }

        try
        {
            WindowMetaData windowMetaData = BeanProvider.getContextualReference(WindowMetaData.class);

            Map<String, Object> requestMap = externalContext.getRequestMap();

            @SuppressWarnings({ "unchecked" })
            List<FacesMessageEntry> facesMessageEntryList =
                    (List<FacesMessageEntry>)requestMap.get(FacesMessageEntry.class.getName());

            if (facesMessageEntryList == null)
            {
                facesMessageEntryList = new CopyOnWriteArrayList<FacesMessageEntry>();
            }
            windowMetaData.setFacesMessageEntryList(facesMessageEntryList);
        }
        catch (ContextNotActiveException e)
        {
            //TODO log it in case of project-stage development
            //we can't handle it correctly -> delegate to the jsf-api (which has some restrictions esp. before v2.2)
            FacesContext.getCurrentInstance().getExternalContext().getFlash().setKeepMessages(true);
        }
    }

    public static void tryToRestoreMessages(FacesContext facesContext)
    {
        JsfModuleConfig jsfModuleConfig = BeanProvider.getContextualReference(JsfModuleConfig.class);

        if (!jsfModuleConfig.isAlwaysKeepMessages())
        {
            return;
        }

        try
        {
            WindowMetaData windowMetaData = BeanProvider.getContextualReference(WindowMetaData.class);

            @SuppressWarnings({ "unchecked" })
            List<FacesMessageEntry> facesMessageEntryList = windowMetaData.getFacesMessageEntryList();

            if (facesMessageEntryList != null)
            {
                for (FacesMessageEntry facesMessageEntry : facesMessageEntryList)
                {
                    facesContext.addMessage(facesMessageEntry.getComponentId(), facesMessageEntry.getFacesMessage());
                }
                facesMessageEntryList.clear();
            }
        }
        catch (ContextNotActiveException e)
        {
            //TODO discuss how we handle it
        }
    }
 b/deltaspike/modules/jsf/impl/src/main/java/org/apache/deltaspike/jsf/impl/component/window/WindowIdHolderComponent.java
package org.apache.deltaspike.jsf.impl.component.window;
import javax.faces.component.FacesComponent;
@FacesComponent(WindowIdHolderComponent.COMPONENT_TYPE)
    public static final String COMPONENT_TYPE = "org.apache.deltaspike.WindowIdHolder";

import java.util.Map;
import java.util.Random;

    /**
     * Value which can be used as "window-id" by external clients which aren't aware of windows.
     * It deactivates e.g. the redirect for the initial request.
     */
    public static final String AUTOMATED_ENTRY_POINT_PARAMETER_KEY = "automatedEntryPoint";

    /**
     * The parameter for the windowId for GET requests
     */
    public static final String DELTASPIKE_WINDOW_ID_PARAM = "windowId";

    /**
     * The parameter for the windowId for POST requests
     */
    public static final String DELTASPIKE_WINDOW_ID_POST_PARAM = "dsPostWindowId";




        boolean newWindowIdRequested = false;
        if (AUTOMATED_ENTRY_POINT_PARAMETER_KEY.equals(windowId))
        {
            // this is a marker for generating a new windowId
            windowId = generateNewWindowId();
            newWindowIdRequested = true;
        }

        if (windowId == null || newWindowIdRequested)
            sendWindowHandlerHtml(externalContext, windowId);
     * Create a unique windowId
     * @return
     */
    private String generateNewWindowId()
    {
        //X TODO proper mechanism
        return ""  (new Random()).nextInt() % 10000;
    }

    /**
        Map<String, String> requestParams = facesContext.getExternalContext().getRequestParameterMap();
        String windowId = requestParams.get(DELTASPIKE_WINDOW_ID_POST_PARAM);
        return windowId;
        @ResourceDependency(library = "deltaspike", name = "windowhandler.js", target = "head"),
        if (!FacesContext.getCurrentInstance().getResponseComplete())
        {
            this.wrapped.execute(facesContext);
        }
        return "page2?faces-redirect=true";
import org.apache.deltaspike.core.api.config.DeltaSpikeConfig;

public class JsfModuleConfig implements DeltaSpikeConfig
    private static final long serialVersionUID = -487295181899986237L;

        //TODO @Matches(pattern = "*.xml")
        //TODO @Matches(pattern = "*.pdf")
    //TODO @Matches(pattern = "*.zip")
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import javax.enterprise.inject.Stereotype;
                inheritedAnnotations.addAll(addViewMetaData(currentClass));

        //add meta-data inherited via stereotypes on the node itself
        inheritedAnnotations.addAll(addViewMetaData(viewConfigNode.getSource()));

    private List<Annotation> addViewMetaData(Class currentClass)
    {
        List<Annotation> result = new ArrayList<Annotation>();

        for (Annotation annotation : currentClass.getAnnotations())
        {
            Class<? extends Annotation> annotationClass = annotation.annotationType();

            if (annotationClass.getName().startsWith("java"))
            {
                continue;
            }

            if (annotationClass.isAnnotationPresent(ViewMetaData.class))
            {
                result.add(annotation);
            }
            else if (annotationClass.isAnnotationPresent(Stereotype.class))
            {
                for (Annotation inheritedViaStereotype : annotationClass.getAnnotations())
                {
                    if (inheritedViaStereotype.annotationType().isAnnotationPresent(ViewMetaData.class))
                    {
                        result.add(inheritedViaStereotype);
                    }
                }
            }
        }
        return result;
    }

import java.net.URL;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
    private static Boolean isWeld1Detected = false;
    protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery, BeanManager beanManager)
        isWeld1Detected = isWeld1(beanManager);
        if (isGlobalAlternativeActivated && isWeld1Detected)
            activateGlobalAlternativesWeld1(processAnnotatedType, beanManager);
    private void activateGlobalAlternativesWeld1(ProcessAnnotatedType processAnnotatedType,
                                                 BeanManager beanManager)
    private boolean isWeld1(BeanManager beanManager)
        if (beanManager.getClass().getName().startsWith("org.apache"))
            return false;
        }

        if (beanManager.getClass().getName().startsWith("org.jboss.weld"))
        {
            String version = getJarVersion(beanManager.getClass());

            if (version != null && version.startsWith("1."))

    private static String getJarVersion(Class targetClass)
    {
        String manifestFileLocation = getManifestFileLocationOfClass(targetClass);

        try
        {
            return new Manifest(new URL(manifestFileLocation).openStream())
                    //weld doesn't use IMPLEMENTATION_VERSION
                    .getMainAttributes().getValue(Attributes.Name.SPECIFICATION_VERSION);
        }
        catch (Exception e)
        {
            return null;
        }
    }

    private static String getManifestFileLocationOfClass(Class targetClass)
    {
        String manifestFileLocation;

        try
        {
            manifestFileLocation = getManifestLocation(targetClass);
        }
        catch (Exception e)
        {
            //in this case we have a proxy
            manifestFileLocation = getManifestLocation(targetClass.getSuperclass());
        }
        return manifestFileLocation;
    }

    private static String getManifestLocation(Class targetClass)
    {
        String classFilePath = targetClass.getCanonicalName().replace('.', '/')  ".class";
        String manifestFilePath = "/META-INF/MANIFEST.MF";

        String classLocation = targetClass.getResource(targetClass.getSimpleName()  ".class").toString();
        return classLocation.substring(0, classLocation.indexOf(classFilePath) - 1)  manifestFilePath;
    }
import javax.enterprise.context.Dependent;
import javax.inject.Inject;
@Dependent
@Typed(MessageContext.class)

    @Inject

    @Inject

    @Inject

import javax.enterprise.context.Dependent;
import javax.inject.Inject;
@Dependent
    @Inject
    private MessageContext baseMessageContext = null;

            messageContext = baseMessageContext.clone();
import javax.enterprise.context.Dependent;
    @Dependent
    Object produceTypedMessageBundle(InjectionPoint injectionPoint, MessageBundleInvocationHandler handler)
        return createMessageBundleProxy(ReflectionUtils.getRawType(injectionPoint.getType()), handler);
    private <T> T createMessageBundleProxy(Class<T> type, MessageBundleInvocationHandler handler)
                new Class<?>[]{type}, handler));

    Class<? extends ConfigDescriptorValidator>[] configDescriptorValidators()
        default { };
import org.apache.deltaspike.core.spi.config.view.ConfigDescriptorValidator;
                                     ViewConfigInheritanceStrategy inheritanceStrategy,
                                     List<ConfigDescriptorValidator> configDescriptorValidators)
            for (ConfigDescriptorValidator validator : configDescriptorValidators)
            {
                if (!validator.isValid(currentConfigDescriptor))
                {
                    throw new IllegalStateException(currentConfigDescriptor.getConfigClass().getName()  " is invalid");
                }
            }

import org.apache.deltaspike.core.spi.config.view.ConfigDescriptorValidator;
import java.util.ArrayList;
            List<ConfigDescriptorValidator> configDescriptorValidators = new ArrayList<ConfigDescriptorValidator>();
                    configDescriptorValidators = createCustomConfigDescriptorValidators(viewConfigRoot);
                    this.viewConfigResolver = createCustomViewConfigResolver(
                            viewConfigRoot, configNodeConverter, inheritanceStrategy, configDescriptorValidators);
                        this.rootViewConfigNode, configNodeConverter, inheritanceStrategy, configDescriptorValidators);
                                                              ViewConfigInheritanceStrategy inheritanceStrategy,
                                                              List<ConfigDescriptorValidator> validators)
                            ViewConfigNode.class,
                            ConfigNodeConverter.class,
                            ViewConfigInheritanceStrategy.class,
                            List.class});
                        .newInstance(this.rootViewConfigNode, configNodeConverter, inheritanceStrategy, validators);
                throw ExceptionUtils.throwAsRuntimeException(e);
                throw ExceptionUtils.throwAsRuntimeException(e);
                throw ExceptionUtils.throwAsRuntimeException(e);
    private List<ConfigDescriptorValidator> createCustomConfigDescriptorValidators(ViewConfigRoot viewConfigRoot)
    {
        List<ConfigDescriptorValidator> result = new ArrayList<ConfigDescriptorValidator>();

        for (Class<? extends ConfigDescriptorValidator> validatorClass : viewConfigRoot.configDescriptorValidators())
        {
            try
            {
                ConfigDescriptorValidator validator = validatorClass.newInstance();
                result.add(validator);
            }
            catch (Exception e)
            {
                throw ExceptionUtils.throwAsRuntimeException(e);
            }
        }

        return result;
    }

import org.apache.deltaspike.core.spi.config.view.ConfigDescriptorValidator;
import java.util.ArrayList;
                new FolderConfigNode(
                    null, null, new HashSet<Annotation>()), null, null, new ArrayList<ConfigDescriptorValidator>());
                if (i == 0 && arg != null && MessageContext.class.isAssignableFrom(arg.getClass()))
                if (arg == null)
                {
                    arguments.add("'null'");
                }
                else if (arg instanceof Serializable)
        if (args != null && args.length > 0 &&  args[0] != null &&
        if (bmpSingleton == null)
        {
            // this happens if there has been a failure at startup
            return;
        }

/**
 * This Proxy InvocationHandler implements the handling for all our
 * {@link org.apache.deltaspike.core.api.message.MessageBundle}s.
 */
import org.apache.deltaspike.core.impl.message.MessageBundleInvocationHandler;
    private final String clientId;
    private final Class<T> type;
    private final MessageBundleInvocationHandler invocationHandler;
    public DefaultJsfMessage(Class<T> type, String clientId, MessageBundleInvocationHandler invocationHandler)
        this.invocationHandler = invocationHandler;
        return new DefaultJsfMessage<T>(type, clientId, invocationHandler);
                new Class<?>[]{type}, new JsfMessageBundleInvocationHandler(severity, clientId, invocationHandler)));
import javax.enterprise.inject.Typed;
import java.lang.reflect.InvocationHandler;
@Typed()
public class JsfMessageBundleInvocationHandler implements InvocationHandler
    private final FacesMessage.Severity severity;
    private final String clientId;
    private final MessageBundleInvocationHandler invocationHandler;
    public JsfMessageBundleInvocationHandler(FacesMessage.Severity severity, String clientId,
                                             MessageBundleInvocationHandler invocationHandler)
        this.invocationHandler = invocationHandler;
        Object message = invocationHandler.invoke(proxy, method, args);
import org.apache.deltaspike.core.impl.message.MessageBundleInvocationHandler;
    public <M> JsfMessage<M> createJsfMessage(InjectionPoint injectionPoint,
                                              MessageBundleInvocationHandler invocationHandler)
            return createJsfMessageFor(injectionPoint, type, invocationHandler);
    private <M> JsfMessage<M> createJsfMessageFor(InjectionPoint injectionPoint, Class<M> rawType,
                                                  MessageBundleInvocationHandler invocationHandler)
        return new DefaultJsfMessage<M>(rawType, null, invocationHandler);
import java.util.Map;
     * <p>Booting the CdiTestContainer will scan the whole classpath
     * The container might throw a DeploymentException or similar on startup.</p>

    /**
     * <p>Like {@link #boot()} but allows to pass in a configuration Map
     * for the container.</p>
     * <p>Please note that the configuration is container implementation dependent!</p>
     *
     * @param properties
     */
    void boot(Map<?,?> properties);
        boot(null);
    }

    @Override
    public synchronized void boot(Map<?, ?> properties)
    {
            openEjbContainer = EJBContainer.createEJBContainer(properties);
import java.util.Map;
    public void boot(Map<?, ?> properties)
    {
        // we do not yet support any configuration.
        boot();
    }

    @Override
import java.util.Map;
    public void boot(Map<?, ?> properties)
    {
        // no configuration yet. Perform default boot

        boot();
    }

    @Override
import org.apache.deltaspike.cdise.api.CdiContainer;
import org.apache.deltaspike.cdise.api.ContextControl;
import org.apache.openejb.OpenEjbContainer;
import org.apache.openejb.core.LocalInitialContext;
import org.apache.openejb.core.LocalInitialContextFactory;
import org.apache.webbeans.config.WebBeansContext;

import javax.naming.Context;
import javax.naming.InitialContext;
import java.util.Properties;
 * OpenEJB specific implementation of {@link org.apache.deltaspike.cdise.api.CdiContainer}.
    // global container config
    private static final Properties PROPERTIES = new Properties();

    static
    {
        // global properties
        PROPERTIES.setProperty(Context.INITIAL_CONTEXT_FACTORY, LocalInitialContextFactory.class.getName());
        PROPERTIES.setProperty(LocalInitialContext.ON_CLOSE, LocalInitialContext.Close.DESTROY.name());
        try
        {
            OpenEjbContainerControl.class.getClassLoader().loadClass("org.apache.openejb.server.ServiceManager");
            PROPERTIES.setProperty(OpenEjbContainer.OPENEJB_EMBEDDED_REMOTABLE, "true");
        }
        catch (final Exception e)
        {
            // ignored
        }
    }


    private Context context = null;
        if (context == null)
            final Properties p = new Properties();
            p.putAll(PROPERTIES);
            if (properties != null) // override with user config
            {
                p.putAll(properties);
            }
                context = new InitialContext(p);
            catch (final NamingException e)
                throw new RuntimeException(e);
            beanManager = WebBeansContext.currentInstance().getBeanManagerImpl();
        if (context != null)
            try
            {
                context.close();
            }
            catch (final NamingException e)
            {
                // no-op
            }
            context = null;
import java.util.HashMap;
import java.util.Map;
    private static final String GLOBAL_ALTERNATIVES = "globalAlternatives.";
    private static final Logger LOG = Logger.getLogger(ExcludeExtension.class.getName());
    /**
     * Contains the globalAlternatives which should get used
     * KEY=Interface class name
     * VALUE=Implementation class name
     */
    private Map<String, String> globalAlternatives = new HashMap<String, String>();


        isGlobalAlternativeActivated =
                ClassDeactivationUtils.isActivated(GlobalAlternative.class);
        if (isGlobalAlternativeActivated)
        {
            Map<String, String> allProperties = ConfigResolver.getAllProperties();
            for (Map.Entry<String, String> property : allProperties.entrySet())
            {
                if (property.getKey().startsWith(GLOBAL_ALTERNATIVES))
                {
                    String interfaceName = property.getKey().substring(GLOBAL_ALTERNATIVES.length());
                    String implementation = property.getValue();
                    if (LOG.isLoggable(Level.FINE))
                    {
                        LOG.fine("Enabling global alternative for interface "  interfaceName  ": "  implementation);
                    }

                    globalAlternatives.put(interfaceName, implementation);
                }
            }

            if (globalAlternatives.isEmpty())
            {
                isGlobalAlternativeActivated = false;
            }
        }
        if (isGlobalAlternativeActivated)
            activateGlobalAlternatives(processAnnotatedType, beanManager);
    private void activateGlobalAlternatives(ProcessAnnotatedType processAnnotatedType,
                                            BeanManager beanManager)
            configuredBeanName = globalAlternatives.get(currentType.getName());
            // this is expected if there is no entry in JNDI for the requested name or type
        return false;
                try
                {
                    NameClassPair binding = enumeration.nextElement();
                    Name bindingName = nameParser.parse(name).add(binding.getName());                
                    result.put(binding.getName(), lookup(bindingName, type));
                }
                catch (NamingException e)
                {
                    if (LOG.isLoggable(Level.FINEST))
                    {
                        // this is expected if there is no entry in JNDI for the requested name or type
                        // so finest level is ok, if devs want to see it they can enable this logger level.
                        LOG.log(Level.FINEST, "InitialContext#list failed!", e);
                    }
                }
            // this is fine at this point, since the individual lines will be caught currently.
            LOG.log(Level.WARNING,"Problem reading the name of the JNDI location "  name
                 " or failuring listing pairs.",e);
import org.apache.deltaspike.core.api.projectstage.ProjectStage;
import org.apache.deltaspike.core.util.ProjectStageProducer;
    private static volatile ProjectStage projectStage = null;

     * <p>Search for the configured value in all {@link ConfigSource}s and take the
     * current {@link org.apache.deltaspike.core.api.projectstage.ProjectStage}
     * into account.</p>
     *
     * <p>It first will search if there is a configured value of the given key prefixed
     * with the current ProjectStage (e.g. 'myproject.myconfig.Production') and if this didn't
     * find anything it will lookup the given key without any prefix.</p>
     *
     * <p><b>Attention</b> This method must only be used after all ConfigSources
     * got registered and it also must not be used to determine the ProjectStage itself.</p>
     * @param key
     * @param defaultValue
     * @return the configured value or if non found the defaultValue
     *
     */
    public static String getProjectStageAwarePropertyValue(String key, String defaultValue)
    {
        ProjectStage ps = getProjectStage();

        String value = getPropertyValue(key  '.'  ps, defaultValue);
        if (value == null)
        {
            value = getPropertyValue(key, defaultValue);
        }

        return value;
    }

    /**
    private static ProjectStage getProjectStage()
    {
        if (projectStage == null)
        {
            synchronized (ConfigResolver.class)
            {
                projectStage = ProjectStageProducer.getInstance().getProjectStage();
            }
        }

        return projectStage;
    }

 * <p>Please note that there can only be one ProjectStage per EAR.</p>
     * @return the configured value or if non found the defaultValue
     *
     */
    public static String getProjectStageAwarePropertyValue(String key)
    {
        ProjectStage ps = getProjectStage();

        String value = getPropertyValue(key  '.'  ps);
        if (value == null)
        {
            value = getPropertyValue(key);
        }

        return value;
    }
    /**
     * {@link #getProjectStageAwarePropertyValue(String)} which returns the defaultValue
     * if the property is <code>null</code> or empty.
     * @param key
        String value = getProjectStageAwarePropertyValue(key);
        if (value == null || value.length() == 0)
        {
            value = defaultValue;
        }

        return value;
    }

    /**
     * <p>Search for the configured value in all {@link ConfigSource}s and take the
     * current {@link org.apache.deltaspike.core.api.projectstage.ProjectStage}
     * and the value configured for the given property into account.</p>
     *
     * <p>The first step is to resolve the value of the given property. This will
     * take the current ProjectStage into account. E.g. given the property is 'dbvendor'
     * and the ProjectStage is 'UnitTest', the first lookup is
     * <ul><li>'dbvendor.UnitTest'</li></ul>.
     * If this value is not found then we will do a 2nd lookup for
     * <ul><li>'dbvendor'</li></ul></p>
     *
     * <p>If a value was found for the given property (e.g. dbvendor = 'mysql'
     * then we will use this value to lookup in the following order until we
     * found a non-null value. If there was no value found for the property
     * we will only do the keyProjectStage and key lookup.
     * In the following sample 'dataSource' is used as key parameter:
     *
     * <ul>
     *      <li>'datasource.mysql.UnitTest'</li>
     *      <li>'datasource.mysql'</li>
     *      <li>'datasource.UnitTest'</li>
     *      <li>'datasource'</li>
     * </ul>
     * </p>
     *
     *
     * <p><b>Attention</b> This method must only be used after all ConfigSources
     * got registered and it also must not be used to determine the ProjectStage itself.</p>
     * @param key
     * @param property the property to look up first
     * @return the configured value or if non found the defaultValue
     *
     */
    public static String getPropertyAwarePropertyValue(String key, String property)
    {
        String propertyValue = getProjectStageAwarePropertyValue(property);

        String value = null;

        if (propertyValue != null && propertyValue.length() > 0)
        {
            value = getProjectStageAwarePropertyValue(key  '.'  propertyValue);
        }

            value = getProjectStageAwarePropertyValue(key);
        }

        return value;
    }

    /*
     * <p><b>Attention</b> This method must only be used after all ConfigSources
     * got registered and it also must not be used to determine the ProjectStage itself.</p>
     * @param key
     * @param property the property to look up first
     * @param defaultValue
     * @return the configured value or if non found the defaultValue
     *
    */
    public static String getPropertyAwarePropertyValue(String key, String property, String defaultValue)
    {
        String value = getPropertyAwarePropertyValue(key, property);

        if (value == null || value.length() == 0)
        {
            value = defaultValue;
            validateInvocationHandler(beanClass, bindingAnnotationClass);
            Bean partialBean = createPartialBean(
                    partialBeanEntry.getKey(), partialBeanEntry.getValue(), afterBeanDiscovery, beanManager);
                                            AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
            afterBeanDiscovery.addDefinitionError(new IllegalStateException("A class which implements " 
                    InvocationHandler.class.getName()  " and is annotated with @" 
                    bindingAnnotationClass.getName()  " is needed as a handler for " 
                    beanClass.getName()  ". See the documentation about @" 
                    PartialBeanBinding.class.getName()  "."));

        PartialBeanLifecycle beanLifecycle =
                new PartialBeanLifecycle(beanClass, invocationHandlerClass, afterBeanDiscovery, beanManager);

        if (!beanLifecycle.isValid())
        {
            return null;
        }

                .beanLifecycle(beanLifecycle);
                                                 Class<? extends Annotation> bindingAnnotationClass)
import javax.enterprise.inject.spi.AfterBeanDiscovery;
    private final boolean valid;

    PartialBeanLifecycle(Class<T> partialBeanClass, Class<H> handlerClass,
                         AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
                if (proxyFactory == null)
                {
                    afterBeanDiscovery.addDefinitionError(new IllegalStateException(
                        "For using abstract classes as partial beans," 
                                "it's needed to add the lib 'javassist' to the classpath."));
                    partialBeanProxyClass = null;
                    this.valid = false;
                    return;
                }
        this.valid = true;

    boolean isValid()
    {
        return valid;
    }
public class ServletEventBridgeFilter extends EventEmitter implements Filter
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
public class ServletEventBridgeListener extends EventEmitter implements ServletContextListener, HttpSessionListener
    public void contextInitialized(ServletContextEvent sce)
    {
        fireEvent(sce.getServletContext(), WebLiteral.INSTANCE, InitializedLiteral.INSTANCE);
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce)
    {
        fireEvent(sce.getServletContext(), WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
    }

    @Override
 b/deltaspike/modules/servlet/impl/src/test/java/org/apache/deltaspike/test/servlet/impl/event/request/RequestResponseEventsObserver.java
package org.apache.deltaspike.test.servlet.impl.event.request;
 * Application scoped observer which listens for {@link HttpServletRequest} and {@link HttpServletResponse} events on
 * the CDI event bus.
 * 
public class RequestResponseEventsObserver
        // store the request/response in a holder to access it later
        RequestResponseHolder.bind(request, response);

            // fire @Initialized events
            fireEvent(request, WebLiteral.INSTANCE, InitializedLiteral.INSTANCE);
            fireEvent(response, WebLiteral.INSTANCE, InitializedLiteral.INSTANCE);

            try
            {
                chain.doFilter(request, response);
            }
            finally
            {
                // fire @Destroyed events
                fireEvent(request, WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
                fireEvent(response, WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
            }


        // release in an outer finally block to ensure the ThreadLocal is cleaned correctly
            RequestResponseHolder.release();
        ServletContextHolder.bind(sce.getServletContext());
        try
        {
            fireEvent(sce.getServletContext(), WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
        }
        finally
        {
            ServletContextHolder.release();
        }
import javax.servlet.ServletContext;
 * <li>{@link ServletContext}</li>
    public ServletContext getServletContext()
    {
        return ServletContextHolder.get();
    }

    @Produces
    @Web
 b/deltaspike/modules/servlet/impl/src/main/java/org/apache/deltaspike/servlet/impl/event/EventBridgeContextListener.java
package org.apache.deltaspike.servlet.impl.event;
 * This class listens for servlet context events and forwards them to the CDI event bus.
public class EventBridgeContextListener extends EventEmitter implements ServletContextListener
        fireEvent(sce.getServletContext(), WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
 b/deltaspike/modules/servlet/impl/src/main/java/org/apache/deltaspike/servlet/impl/event/EventBridgeFilter.java
package org.apache.deltaspike.servlet.impl.event;
 * This filter sends events to the CDI event bus when requests and responses get created and destroyed.
 * 
public class EventBridgeFilter extends EventEmitter implements Filter
        // fire @Initialized events
        fireEvent(request, WebLiteral.INSTANCE, InitializedLiteral.INSTANCE);
        fireEvent(response, WebLiteral.INSTANCE, InitializedLiteral.INSTANCE);

            chain.doFilter(request, response);
            // fire @Destroyed events
            fireEvent(request, WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
            fireEvent(response, WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
 b/deltaspike/modules/servlet/impl/src/main/java/org/apache/deltaspike/servlet/impl/event/EventBridgeSessionListener.java
package org.apache.deltaspike.servlet.impl.event;
 * This class listens for HTTP session events and forwards them to the CDI event bus.
public class EventBridgeSessionListener extends EventEmitter implements HttpSessionListener
 b/deltaspike/modules/servlet/impl/src/main/java/org/apache/deltaspike/servlet/impl/event/EventEmitter.java
package org.apache.deltaspike.servlet.impl.event;
 b/deltaspike/modules/servlet/impl/src/main/java/org/apache/deltaspike/servlet/impl/produce/RequestResponse.java
package org.apache.deltaspike.servlet.impl.produce;
 b/deltaspike/modules/servlet/impl/src/main/java/org/apache/deltaspike/servlet/impl/produce/RequestResponseHolder.java
package org.apache.deltaspike.servlet.impl.produce;
 b/deltaspike/modules/servlet/impl/src/main/java/org/apache/deltaspike/servlet/impl/produce/RequestResponseHolderFilter.java
package org.apache.deltaspike.servlet.impl.produce;
 * This filter stores the current request and response in the {@link RequestResponseHolder}.
 * 
public class RequestResponseHolderFilter implements Filter
            chain.doFilter(request, response);
 b/deltaspike/modules/servlet/impl/src/main/java/org/apache/deltaspike/servlet/impl/produce/ServletContextHolder.java
package org.apache.deltaspike.servlet.impl.produce;
 b/deltaspike/modules/servlet/impl/src/main/java/org/apache/deltaspike/servlet/impl/produce/ServletObjectProducer.java
package org.apache.deltaspike.servlet.impl.produce;
        fireEvent(sce.getServletContext(), InitializedLiteral.INSTANCE);
        fireEvent(sce.getServletContext(), DestroyedLiteral.INSTANCE);
        fireEvent(request, InitializedLiteral.INSTANCE);
        fireEvent(response, InitializedLiteral.INSTANCE);
            fireEvent(request, DestroyedLiteral.INSTANCE);
            fireEvent(response, DestroyedLiteral.INSTANCE);
        fireEvent(se.getSession(), InitializedLiteral.INSTANCE);
        fireEvent(se.getSession(), DestroyedLiteral.INSTANCE);
    public void contextInitialized(@Observes @Initialized ServletContext context)
    public void contextDestroyed(@Observes @Destroyed ServletContext context)
    public void requestInitialized(@Observes @Initialized HttpServletRequest request)
    public void responseInitialized(@Observes @Initialized HttpServletResponse response)
    public void requestDestroyed(@Observes @Destroyed HttpServletRequest request)
    public void responseDestroyed(@Observes @Destroyed HttpServletResponse response)
    public void sessionInitialized(@Observes @Initialized HttpSession session)
    public void sessionDestroyed(@Observes @Destroyed HttpSession session)
/**
 * A factory for creating CDI Aware/Enabled ConstraintValidators.
 * 
 * @author John.D.Ament
 */
        resolvedInst = BeanProvider.getContextualReference(validatorClass,true);
        String value = getPropertyValue(key);
        return fallbackToDefaultIfEmpty(key, value, defaultValue);
        return fallbackToDefaultIfEmpty(key, value, defaultValue);
        return fallbackToDefaultIfEmpty(key, value, defaultValue);
    private static String fallbackToDefaultIfEmpty(String key, String value, String defaultValue)
    {
        if (value == null || value.length() == 0)
        {
            LOG.log(Level.FINE, "no configured value found for key {0}, using default value {1}.",
                    new Object[]{key, defaultValue});

            return defaultValue;
        }

        return value;
    }


            configuredValue = ConfigResolver.getProjectStageAwarePropertyValue(propertyName);
            configuredValue = ConfigResolver.getProjectStageAwarePropertyValue(propertyName, defaultValue);
        return ConfigResolver.getProjectStageAwarePropertyValue(key);
import javax.enterprise.inject.spi.BeanManager;
    private volatile BeanManager beanManager;
        getBeanManager().fireEvent(event, qualifier);
    }

    protected BeanManager getBeanManager()
    {
        if (beanManager == null)
        {
            synchronized (this)
            {
                if (beanManager == null)
                {
                    beanManager = BeanManagerProvider.getInstance().getBeanManager();
                }
            }
        }

        return beanManager;
import org.apache.deltaspike.core.util.ClassUtils;

        ClassLoader classLoader = ClassUtils.getClassLoader(null);
        ClassLoader classLoader = ClassUtils.getClassLoader(null);
        ClassLoader classLoader = ClassUtils.getClassLoader(null);
import org.apache.deltaspike.core.spi.config.ConfigFilter;
    /**
     * The content of this map will hold the List of ConfigFilters
     * for each WebApp/EAR, etc (thus the ClassLoader).
     */
    private static Map<ClassLoader, List<ConfigFilter>> configFilters
        = new ConcurrentHashMap<ClassLoader, List<ConfigFilter>>();

     * Add a {@link ConfigFilter} to the ConfigResolver.
     * This will only affect the current WebApp
     * (or more precisely the current ClassLoader and it's children).
     * @param configFilter
     */
    public static void addConfigFilter(ConfigFilter configFilter)
    {

        List<ConfigFilter> currentConfigFilters = getConfigFilters();
        currentConfigFilters.add(configFilter);
    }

    /**
     * @return the {@link ConfigFilter}s for the current application.
     */
    public static List<ConfigFilter> getConfigFilters()
    {
        ClassLoader cl = ClassUtils.getClassLoader(null);
        List<ConfigFilter> currentConfigFilters = configFilters.get(cl);
        if (currentConfigFilters == null)
        {
            currentConfigFilters = new ArrayList<ConfigFilter>();
            configFilters.put(cl, currentConfigFilters);
        }

        return currentConfigFilters;
    }

    /**
                        new Object[]{filterConfigValueForLog(key, value), key, configSource.getConfigName()});
                return filterConfigValue(key, value);
            if (value != null)
                value = filterConfigValue(key, value);
                if (!result.contains(value))
                {
                    result.add(value);
                }
    private static String filterConfigValue(String key, String value)
    {
        List<ConfigFilter> currentConfigFilters = getConfigFilters();

        String filteredValue = value;

        for (ConfigFilter filter : currentConfigFilters)
        {
            filteredValue = filter.filterValue(key, filteredValue);
        }
        return filteredValue;
    }

    private static String filterConfigValueForLog(String key, String value)
    {
        List<ConfigFilter> currentConfigFilters = getConfigFilters();

        String logValue = value;

        for (ConfigFilter filter : currentConfigFilters)
        {
            logValue = filter.filterValueForLog(key, logValue);
        }
        return logValue;
    }

    /**
     * @return the ResourceBundle for the current default Locale
     */
    /**
     * This uses the correct ThreadContextClassLoader if deployed in an Container.
     * @return the ResourceBundle for the current Locale
     */
        return ResourceBundle.getBundle(bundleName, locale, ClassUtils.getClassLoader(null));
}
import javax.inject.Inject;
    @Inject
    private ExceptionControlExtension exceptionControlExtension;

        // nothing to do
        // nothing to do
        // nothing to do
 * package org.apache.deltaspike.test.core.api.projectstage;
 * public class TestProjectStages implements ProjectStageHolder {
 * <p>For activating those ProjectStages, you have to register this ProjectStageHolder class
 * META-INF/services/org.apache.deltaspike.core.api.projectstage.ProjectStageHolder
 * org.apache.deltaspike.test.core.api.projectstage.TestProjectStages
 b/deltaspike/modules/bean-validation/impl/src/main/java/org/apache/deltaspike/beanValidation/impl/CDIAwareConstraintValidatorFactory.java
package org.apache.deltaspike.beanValidation.impl;
 b/deltaspike/modules/bean-validation/impl/src/test/java/org/apache/deltaspike/beanValidation/test/ArchiveUtils.java
package org.apache.deltaspike.beanValidation.test;
 b/deltaspike/modules/bean-validation/impl/src/test/java/org/apache/deltaspike/beanValidation/test/ArrayChecker.java
package org.apache.deltaspike.beanValidation.test;
 b/deltaspike/modules/bean-validation/impl/src/test/java/org/apache/deltaspike/beanValidation/test/ArraySize.java
package org.apache.deltaspike.beanValidation.test;
 b/deltaspike/modules/bean-validation/impl/src/test/java/org/apache/deltaspike/beanValidation/test/BasicPojo.java
package org.apache.deltaspike.beanValidation.test;
 b/deltaspike/modules/bean-validation/impl/src/test/java/org/apache/deltaspike/beanValidation/test/InjectableConstraintValidator.java
package org.apache.deltaspike.beanValidation.test;
 * Qualifier for events which are fired when servlet objects are destroyed.
 * Qualifier for events which are fired when servlet objects are created.
 * Common qualifier used for injection of servlet objects.
 * Annotation literal for {@link Destroyed}.
 * Annotation literal for {@link Initialized}.
 * Annotation literal for {@link Web}.
        while (nodeClass != null)
            treePath.add(0, nodeClass);
            nodeClass = nodeClass.getEnclosingClass();
import org.apache.deltaspike.core.api.config.ConfigResolver;
                String customPreProcessorClassName = ConfigResolver.getPropertyValue(preProcessorClass.getName(), null);

                if (customPreProcessorClassName != null)
                {
                    Class<? extends ConfigPreProcessor> customPreProcessorClass =
                            ClassUtils.tryToLoadClassForName(customPreProcessorClassName, ConfigPreProcessor.class);

                    if (customPreProcessorClass != null)
                    {
                        preProcessorClass = customPreProcessorClass;
                    }
                    else
                    {
                        throw new IllegalStateException(customPreProcessorClassName  " is configured to replace " 
                            preProcessorClass.getName()  ", but it wasn't possible to load it.");
                    }
                }
 * 

 * @param <V> the type of the properties value
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
        if (method.getDeclaringClass().equals(Object.class))
        {
            // this sometimes gets invoked directly by the container
            // there is no perfect solution for those methods,
            // so we try to use the best info we have atm.

            if ("hashCode".equals(method.getName()))
            {
                return proxy.getClass().hashCode();
            }

            if ("toString".equals(method.getName()))
            {
                return proxy.getClass().toString();
            }

            if ("equals".equals(method.getName()))
            {
                return proxy.getClass().equals(args[0].getClass());
            }

            return null;
        }

    public static <T> DependentProvider<T> getDependent(Class<T> type, Annotation... qualifiers)
    {
        BeanManager beanManager = getBeanManager();
        Set<Bean<?>> beans = beanManager.getBeans(type, qualifiers);
        Bean<?> bean = beanManager.resolve(beans);
        return createDependentProvider(beanManager, type, (Bean<T>) bean);
    }

    public static <T> DependentProvider<T> getDependent(String name)
    {
        BeanManager beanManager = getBeanManager();
        Set<Bean<?>> beans = beanManager.getBeans(name);
        Bean<?> bean = beanManager.resolve(beans);
        Class beanClass = bean.getBeanClass();

        return createDependentProvider(beanManager, (Class<T>) beanClass, (Bean<T>) bean);
    }

    private static <T> DependentProvider<T> createDependentProvider(BeanManager beanManager, Class<T> type,
                                                                    Bean<T> bean)
    {
        CreationalContext<T> cc = beanManager.createCreationalContext(bean);
        T instance = (T) beanManager.getReference(bean, type, cc);

        return new DependentProvider<T>(bean, cc, instance);
    }

            if (!isParentBeanManagerBooted())
            {
                LOG.warning("When using the BeanManager to retrieve Beans before the Container is started," 
                        " non-portable behaviour results!");

                // reset the flag to only issue the warning once.
                // this is a workaround for some containers which mess up EAR handling.
                bmi.booted = true;
            }
            synchronized (bmi)
     * startup. This should generally avoided but instead you should just use
     * an injected BeanManager in your Extension and propagate the BeanManager
     * via setters.
     *
     * In EARs with multiple webapps you might get different Extensions per WAR.
     * This depends on the container you use. By resetting <i>all</i> known
     * BeanManagerInfos we try to

    /**
     * @return whether a BeanManagerInfo for a parent classloader is available and has the booted flag set.
     */
    private boolean isParentBeanManagerBooted()
    {
        ClassLoader classLoader = ClassUtils.getClassLoader(null);
        BeanManagerInfo parentBmi = getParentBeanManagerInfo(classLoader);

        return parentBmi != null && parentBmi.booted;
    }

    /**
     * This method recurses into the parent ClassLoaders and will check if a
     * BeanManagerInfo for it exists.
     * @return the BeanManagerInfo of the parent ClassLoader hierarchy if any exists,
     *         or <code>null</code> if there is no {@link BeanManagerInfo} for the ClassLoaders in the hierarchy.
     */
    private BeanManagerInfo getParentBeanManagerInfo(ClassLoader classLoader)
    {
        ClassLoader parentClassLoader = classLoader.getParent();
        if (parentClassLoader.equals(ClassLoader.getSystemClassLoader()))
        {
            return null;
        }

        BeanManagerInfo bmi = getBeanManagerInfo(parentClassLoader);
        if (bmi == null)
        {
            bmi = getParentBeanManagerInfo(parentClassLoader);
        }

        return bmi;
    }


    private <T> Bean<T> createMessageBundleBean(Bean<Object> delegate,
                                                AnnotatedType<T> annotatedType,
                                                BeanManager beanManager)
        beanBuilder.passivationCapable(true);
        beanBuilder.id("MessageBundleBean#"  annotatedType.getJavaClass().getName());
import javax.enterprise.inject.spi.PassivationCapable;
import java.io.IOException;
import java.io.NotSerializableException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
 *
 * Instances of this class are Serializable if the wrapped contextual instance
 * is Serializable.
public class DependentProvider<T> implements Provider<T>, Serializable
    private static final long serialVersionUID = 23423413412001L;

    private transient Bean<T> bean;

    private void writeObject(ObjectOutputStream out) throws IOException
    {
        if (!(bean instanceof PassivationCapable))
        {
            throw new NotSerializableException("Bean is not PassivationCapable: "  bean.toString());
        }
        String passivationId = ((PassivationCapable) bean).getId();
        if (passivationId == null)
        {
            throw new NotSerializableException(bean.toString());
        }

        out.writeLong(serialVersionUID);
        out.writeObject(passivationId);
        out.writeObject(instance);
        out.writeObject(creationalContext);
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
    {
        long oldSerialId = in.readLong();
        if (oldSerialId != serialVersionUID)
        {
            throw new NotSerializableException(getClass().getName()  " serialVersion does not match");
        }
        String passivationId = (String) in.readObject();
        bean = (Bean<T>) BeanManagerProvider.getInstance().getBeanManager().getPassivationCapableBean(passivationId);
        instance = (T) in.readObject();
        creationalContext = (CreationalContext<T>) in.readObject();
    }

 b/deltaspike/test-utils/src/main/java/org/apache/deltaspike/test/utils/Serializer.java
package org.apache.deltaspike.test.utils;
import javax.enterprise.inject.Typed;
@Typed
    public JsfMessage createJsfMessage(InjectionPoint injectionPoint,
                                       MessageBundleInvocationHandler invocationHandler)
            Class<?> type = (Class<?>) actualTypes[0];
                .addPackages(true, "org.apache.deltaspike.test.category")
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class EventBridgeContextListener extends EventEmitter implements ServletContextListener, Deactivatable
    private final boolean activated;

    public EventBridgeContextListener()
    {
        this.activated = ClassDeactivationUtils.isActivated(getClass());
    }

        if (activated)
        {
            fireEvent(sce.getServletContext(), InitializedLiteral.INSTANCE);
        }
        if (activated)
        {
            fireEvent(sce.getServletContext(), DestroyedLiteral.INSTANCE);
        }
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class EventBridgeFilter extends EventEmitter implements Filter, Deactivatable
    private final boolean activated;

    public EventBridgeFilter()
    {
        this.activated = ClassDeactivationUtils.isActivated(getClass());
    }

        if (activated)
        {
            fireEvent(request, InitializedLiteral.INSTANCE);
            fireEvent(response, InitializedLiteral.INSTANCE);
        }
            if (activated)
            {
                fireEvent(request, DestroyedLiteral.INSTANCE);
                fireEvent(response, DestroyedLiteral.INSTANCE);
            }
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class EventBridgeSessionListener extends EventEmitter implements HttpSessionListener, Deactivatable
    private final boolean activated;

    public EventBridgeSessionListener()
    {
        this.activated = ClassDeactivationUtils.isActivated(getClass());
    }

        if (activated)
        {
            fireEvent(se.getSession(), InitializedLiteral.INSTANCE);
        }
        if (activated)
        {
            fireEvent(se.getSession(), DestroyedLiteral.INSTANCE);
        }
    public <M> JsfMessage<M> createJsfMessage(InjectionPoint injectionPoint,
            Class<M> type = (Class<M>) actualTypes[0];
 * Only necessary if there is more than one persistence unit.
 * <pre>
 *    &#064;Inject
 *    &#064;Override
 * </pre>
public class EventBridgeContextListener extends EventEmitter implements ServletContextListener
        if (isActivated())
        if (isActivated())
public class EventBridgeFilter extends EventEmitter implements Filter
        if (isActivated())
            if (isActivated())
public class EventBridgeSessionListener extends EventEmitter implements HttpSessionListener
        if (isActivated())
        if (isActivated())
import javax.enterprise.inject.spi.BeanManager;

import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
abstract class EventEmitter implements Deactivatable

    private final boolean activated;

    public EventEmitter()
    {
        this.activated = ClassDeactivationUtils.isActivated(getClass());
    }

    protected boolean isActivated()
    {
        return activated;
    }

import java.util.Set;
import javax.enterprise.context.Dependent;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.data.impl.util.bean.BeanDestroyable;
    private BeanManager beanManager;
            DelegateQueryHandler delegate = selectDelegate(context);
    private DelegateQueryHandler selectDelegate(CdiQueryInvocationContext context)
        Set<Bean<DelegateQueryHandler>> beans = BeanProvider
                .getBeanDefinitions(DelegateQueryHandler.class, true, true);
        for (Bean<DelegateQueryHandler> bean : beans)
            if (contains(bean.getBeanClass(), context.getMethod()))
                if (bean.getScope().equals(Dependent.class))
                {
                    CreationalContext<DelegateQueryHandler> cc = beanManager.createCreationalContext(bean);
                    DelegateQueryHandler instance = (DelegateQueryHandler) beanManager.getReference(
                            bean, DelegateQueryHandler.class, cc);
                    context.addDestroyable(new BeanDestroyable<DelegateQueryHandler>(bean, instance, cc));
                    return instance;
                }
                return (DelegateQueryHandler) BeanProvider.getContextualReference(bean.getBeanClass());
    private boolean contains(Class<?> obj, Method method)
    private Method extract(Class<?> obj, Method method)
            return obj != null ? obj.getMethod(name, method.getParameterTypes()) : null;
        Method extract = extract(target.getClass(), method);
import static org.apache.deltaspike.data.impl.meta.MethodType.ANNOTATED;
import static org.apache.deltaspike.data.impl.meta.MethodType.DELEGATE;
import static org.apache.deltaspike.data.impl.meta.MethodType.PARSE;

import java.util.HashMap;
import java.util.Map;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.api.provider.DependentProvider;
import org.apache.deltaspike.data.impl.handler.CdiQueryInvocationContext;
import org.apache.deltaspike.data.impl.meta.MethodType;
import org.apache.deltaspike.data.impl.meta.RepositoryMethod;
import org.apache.deltaspike.data.impl.util.bean.DependentProviderDestroyable;
    private static final Map<MethodType, QueryInvocationLiteral> LITERALS =
            new HashMap<MethodType, QueryInvocationLiteral>()
            {
                {
                    put(ANNOTATED, new QueryInvocationLiteral(ANNOTATED));
                    put(DELEGATE, new QueryInvocationLiteral(DELEGATE));
                    put(PARSE, new QueryInvocationLiteral(PARSE));
                }
            };
    public QueryBuilder build(RepositoryMethod method, CdiQueryInvocationContext context)
        DependentProvider<QueryBuilder> builder = BeanProvider.getDependent(
                QueryBuilder.class, LITERALS.get(method.getMethodType()));
        context.addDestroyable(new DependentProviderDestroyable(builder));
            return new WrappedQueryBuilder(builder.get());
        return builder.get();
        context.get().cleanup();
import org.apache.deltaspike.data.impl.util.bean.Destroyable;
    private final List<Destroyable> cleanup;
        this.cleanup = new LinkedList<Destroyable>();
    public void addDestroyable(Destroyable destroyable)
    {
        cleanup.add(destroyable);
    }

    public void cleanup()
    {
        for (Destroyable destroy : cleanup)
        {
            destroy.destroy();
        }
        cleanup.clear();
    }

import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.api.provider.DependentProvider;
            DependentProvider<? extends EntityManagerResolver> resolver =
                    lookupResolver(repository.getEntityManagerResolverClass());
            EntityManager result = resolver.get().resolveEntityManager();
            resolver.destroy();
    private DependentProvider<? extends EntityManagerResolver> lookupResolver(
        DependentProvider<? extends EntityManagerResolver> resolver = BeanProvider.getDependent(resolverClass);
        return resolver;
            QueryBuilder builder = queryBuilder.build(repoMethod, queryContext);
        EntityManager result = null;
            result = resolver.get().resolveEntityManager();
        else
        {
            result = entityManager.get();
        }
        if (repository.hasEntityManagerFlushMode())
        {
            result.setFlushMode(repository.getEntityManagerFlushMode());
        }
        return result;
    public boolean hasEntityManagerFlushMode()
    {
        return entityManagerFlushMode != null;
    }

        CdiQueryInvocationContext ctx = context.get();
        if (ctx != null)
        {
            ctx.cleanup();
        }
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
            result = entityManager.select(new DefaultLiteral()).get();
 b/deltaspike/modules/data/impl/src/test/java/org/apache/deltaspike/data/test/service/SimpleRepositoryWithEntityManagerResolver.java
@EntityManagerConfig(entityManagerResolver = SimplisticEntityManagerResolver.class)
public abstract class SimpleRepositoryWithEntityManagerResolver extends AbstractEntityRepository<Simple, Long>
                break;
        if (".".equals(folderName))
        {
            folderName = null; //default value -> fallback to the default naming
        }

                    filterInheritedFolderMetaData(mergedMetaData), node.getCallbackDescriptors());

    private List<Annotation> filterInheritedFolderMetaData(List<Annotation> mergedMetaData)
    {
        List<Annotation> result = new ArrayList<Annotation>();

        for (Annotation metaData : mergedMetaData)
        {
            if (!Folder.class.equals(metaData.annotationType()))
            {
                result.add(metaData);
            }
        }

        return result;
    }
                RepositoryComponentsFactory.instance().add(repoClass, beanManager);
    public EntityManager lookupFor(final RepositoryComponent repository)
            final Class<? extends EntityManagerResolver> emrc = repository.getEntityManagerResolverClass();
            if (!repository.isEntityManagerResolverIsNormalScope())
            {
                final DependentProvider<? extends EntityManagerResolver> resolver = lookupResolver(emrc);
                result = resolver.get().resolveEntityManager();
                resolver.destroy();
            }
            else
            {
                result = BeanProvider.getContextualReference(emrc).resolveEntityManager();
            }
        return BeanProvider.getDependent(resolverClass);
import java.lang.annotation.Annotation;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
    private final boolean entityManagerResolverIsNormalScope;
    public RepositoryComponent(Class<?> repoClass, RepositoryEntity entityClass, BeanManager beanManager)

        if (entityManagerResolver != null && beanManager != null)
        {
            final Set<Bean<?>> beans = beanManager.getBeans(entityManagerResolver);
            final Class<? extends Annotation> scope = beanManager.resolve(beans).getScope();
            entityManagerResolverIsNormalScope = beanManager.isNormalScope(scope);
        }
        else
        {
            entityManagerResolverIsNormalScope = false;
        }

    public boolean isEntityManagerResolverIsNormalScope()
    {
        return entityManagerResolverIsNormalScope;
    }

import org.apache.deltaspike.data.impl.RepositoryDefinitionException;
import org.apache.deltaspike.data.impl.meta.extractor.AnnotationMetadataExtractor;
import org.apache.deltaspike.data.impl.meta.extractor.MetadataExtractor;
import org.apache.deltaspike.data.impl.meta.extractor.TypeMetadataExtractor;

import javax.enterprise.inject.spi.BeanManager;
     *
    public void add(Class<?> repoClass, BeanManager bm)
        RepositoryComponent repo = new RepositoryComponent(repoClass, entityClass, bm);
    /**
     * This method will properly destroy the &#064;Dependent scoped instance.
     * It will have no effect if the bean is NormalScoped as those have their
     * own lifecycle which we must not disrupt.
     */
        if (!BeanManagerProvider.getInstance().getBeanManager().isNormalScope(bean.getScope()))
        {
            bean.destroy(instance, creationalContext);
        }

    /**
     * Per default converters get wrapped to restore them properly during a postback (significant without overhead).
     * @return true if converters should be handled as std. CDI beans, false otherwise
     */
    public boolean isContainerManagedConvertersEnabled()
    {
        return true;
    }

    /**
     * Per default validators get wrapped to restore them properly during a postback (significant without overhead).
     * @return true if validators should be handled as std. CDI beans, false otherwise
     */
    public boolean isContainerManagedValidatorsEnabled()
    {
        return true;
    }
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
import org.apache.deltaspike.jsf.impl.injection.InjectionAwareApplicationWrapper;
import javax.faces.application.Application;
    private JsfModuleConfig jsfModuleConfig;

    public Application getApplication()
    {
        if (this.jsfModuleConfig == null)
        {
            this.jsfModuleConfig = BeanProvider.getContextualReference(JsfModuleConfig.class);
        }

        return new InjectionAwareApplicationWrapper(this.wrappedFacesContext.getApplication(), this.jsfModuleConfig);
    }

    @Override
            Set<Bean<?>> beans = beanManager.getBeans(ContextControl.class);
 b/deltaspike/modules/jsf/api/src/main/java/org/apache/deltaspike/jsf/api/literal/ViewScopedLiteral.java
package org.apache.deltaspike.jsf.api.literal;
import javax.enterprise.util.AnnotationLiteral;
public class ViewScopedLiteral extends AnnotationLiteral<ViewScoped> implements ViewScoped
    private static final long serialVersionUID = -6260027440277811767L;
import javax.enterprise.inject.Typed;
@Typed()
        return BeanProvider.getContextualReference(converterClass);
        return BeanProvider.getContextualReference(validatorClass);
import javax.enterprise.inject.Typed;
@Typed()
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import javax.enterprise.context.Dependent;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import java.io.Serializable;
import java.util.Set;
        return getContextualReference(BeanManagerProvider.getInstance().getBeanManager(), converterClass);
        return getContextualReference(BeanManagerProvider.getInstance().getBeanManager(), validatorClass);
    }

    private static <T> T getContextualReference(BeanManager beanManager, Class<T> type)
    {
        Set<Bean<?>> beans = beanManager.getBeans(type);

        if (beans == null || beans.isEmpty())
        {
            return null;
        }

        Bean<?> bean = beanManager.resolve(beans);

        CreationalContext<?> creationalContext = beanManager.createCreationalContext(bean);

        @SuppressWarnings({ "unchecked", "UnnecessaryLocalVariable" })
        T result = (T) beanManager.getReference(bean, type, creationalContext);

        if (bean.getScope().equals(Dependent.class))
        {
            AbstractBeanStorage beanStorage;

            if (Serializable.class.isAssignableFrom(bean.getBeanClass()))
            {
                beanStorage = BeanProvider.getContextualReference(ViewDependentBeanStorage.class);
            }
            else
            {
                beanStorage = BeanProvider.getContextualReference(RequestDependentBeanStorage.class);
            }

            //noinspection unchecked
            beanStorage.add(new DependentBeanEntry(result, bean, creationalContext));
        }

        return result;
 b/deltaspike/modules/jsf/impl/src/main/java/org/apache/deltaspike/jsf/impl/injection/RequestDependentBeanStorage.java
package org.apache.deltaspike.jsf.impl.injection;
import javax.enterprise.context.RequestScoped;
@RequestScoped
public class RequestDependentBeanStorage extends AbstractBeanStorage
 b/deltaspike/modules/jsf/impl/src/main/java/org/apache/deltaspike/jsf/impl/injection/ViewDependentBeanStorage.java
package org.apache.deltaspike.jsf.impl.injection;
import java.io.Serializable;
@ViewScoped
public class ViewDependentBeanStorage extends AbstractBeanStorage implements Serializable
    private static final long serialVersionUID = 4500399024267716556L;
            AbstractBeanStorage beanStorage = BeanProvider.getContextualReference(RequestDependentBeanStorage.class);
//TODO merge with AbstractBeanStorage if ViewDependentBeanStorage isn't needed (see MYFACES-3805)
            AbstractBeanStorage beanStorage = BeanProvider.getContextualReference(RequestDependentBeanStorage.class);
//TODO merge with AbstractBeanStorage if ViewDependentBeanStorage isn't needed (see MYFACES-3805)
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.jpa.api.transaction.TransactionConfig;
    private transient TransactionConfig transactionConfig;

        if (this.transactionConfig == null)
        {
            lazyInit();
        }

        return transactionConfig.getUserTransactionTimeoutInSeconds();
    }

    protected synchronized void lazyInit()
    {
        if (this.transactionConfig != null)
        {
            return;
        }

        this.transactionConfig = BeanProvider.getContextualReference(TransactionConfig.class, true);

        if (this.transactionConfig == null)
        {
            this.transactionConfig = createDefaultTransactionConfig();
        }
    }

    protected TransactionConfig createDefaultTransactionConfig()
    {
        return new TransactionConfig()
        {
            private static final long serialVersionUID = -3915439087580270117L;

            @Override
            public Integer getUserTransactionTimeoutInSeconds()
            {
                return null;
            }
        };
    /**
     * @return ordinal for invocation-order - higher ordinals first
     */
    int ordinal() default 1000; //aligned with value in BaseConfigSource
import java.util.Collections;
import java.util.Comparator;

        //higher ordinals first
        sortDescending(this.phaseListeners);
    }

    private static void sortDescending(List<PhaseListener> phaseListeners)
    {
        Collections.sort(phaseListeners, new Comparator<PhaseListener>()
        {
            @Override
            public int compare(PhaseListener phaseListener1, PhaseListener phaseListener2)
            {
                return (phaseListener1.getClass().getAnnotation(JsfPhaseListener.class).ordinal() >
                        phaseListener2.getClass().getAnnotation(JsfPhaseListener.class).ordinal()) ? -1 : 1;
            }
        });
import org.apache.deltaspike.core.util.ClassUtils;
import javax.faces.context.FacesContext;
    public static final String CLIENT_WINDOW_CONFIG_KEY = "javax.faces.CLIENT_WINDOW_MODE";
    public static final String CLIENT_WINDOW_CLASS_NAME = "javax.faces.lifecycle.ClientWindow";


    public boolean isDelegatedWindowHandlingEnabled()
    {
        if (ClassUtils.tryToLoadClassForName(CLIENT_WINDOW_CLASS_NAME) == null)
        {
            return false;
        }

        String configuredWindowHandling = FacesContext.getCurrentInstance().getExternalContext()
                                .getInitParameter(CLIENT_WINDOW_CONFIG_KEY);

        return !(configuredWindowHandling == null || "none".equalsIgnoreCase(configuredWindowHandling.trim()));
    }
         * Delegates to the default window-handling of JSF 2.2 (if configured)
         */
        DELEGATED,

        /**
import javax.annotation.PostConstruct;
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
    private static final long serialVersionUID = -708423418378550210L;

    private JsfModuleConfig jsfModuleConfig;

    @Inject
    private boolean useDelegatedWindowHandling;

    @PostConstruct
    protected void init()
    {
        this.useDelegatedWindowHandling = this.jsfModuleConfig.isDelegatedWindowHandlingEnabled();
    }
            if (this.useDelegatedWindowHandling)
            {
                return ClientWindowRenderMode.DELEGATED;
            }
        if (this.useDelegatedWindowHandling)
        {
            return ClientWindowRenderMode.DELEGATED;
        }

import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.ExceptionUtils;
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
    private final boolean jsfVersionWithClientWindowDetected;

        this.jsfVersionWithClientWindowDetected =
                ClassUtils.tryToLoadClassForName(JsfModuleConfig.CLIENT_WINDOW_CLASS_NAME) != null;

        if (this.jsfVersionWithClientWindowDetected)
        {
            Class<? extends Lifecycle> lifecycleWrapperClass = ClassUtils.tryToLoadClassForName(
                    "org.apache.deltaspike.jsf.impl.listener.request.JsfClientWindowAwareLifecycleWrapper");
            try
            {
                return lifecycleWrapperClass.getConstructor(new Class[] { Lifecycle.class })
                        .newInstance(new DeltaSpikeLifecycleWrapper(result));
            }
            catch (Exception e)
            {
                throw ExceptionUtils.throwAsRuntimeException(e);
            }
        }
    Lifecycle getWrapped()
    {
        return wrapped;
    }

        //can happen due to the window-handling of deltaspike
        if (facesContext.getResponseComplete())
        {
            return;
        }

    public static final String JSF_WINDOW_ID_POST_PARAM = "javax.faces.ClientWindow";
        ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(facesContext);
        if (ClientWindowRenderMode.NONE.equals(clientWindowRenderMode))
        if (ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))
        {
            return ClientWindowAdapter.getWindowIdFromJsf(facesContext);
        }


        if (windowId == null)
        {
            windowId = requestParams.get(JSF_WINDOW_ID_POST_PARAM);
        }
    <X> void processAnnotatedType(@Observes ProcessAnnotatedType<X> event)
                RepositoryComponentsFactory.instance().add(repoClass);
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
    private volatile Boolean entityManagerResolverIsNormalScope;

    public RepositoryComponent(Class<?> repoClass, RepositoryEntity entityClass)
    }

    //don't trigger this lookup during ProcessAnnotatedType
    private void lazyInit()
    {
        if (entityManagerResolverIsNormalScope == null)
        {
            init(BeanManagerProvider.getInstance().getBeanManager());
        }
    }

    private synchronized void init(BeanManager beanManager)
    {
        if (entityManagerResolverIsNormalScope != null)
        {
            return;
        }
        lazyInit();
        lazyInit();
    public void add(Class<?> repoClass)
        RepositoryComponent repo = new RepositoryComponent(repoClass, entityClass);
import java.lang.annotation.Annotation;
import java.util.Iterator;
import java.util.Set;
                Folder result = new FolderLiteral(name, folder.folderNameBuilder());
                updateNodeMetaData(viewConfigNode, result);
                return result;
        private void updateNodeMetaData(ViewConfigNode viewConfigNode, Folder folder)
        {
            Set<Annotation> metaData = viewConfigNode.getMetaData();

            Iterator<? extends Annotation> metaDataIterator = metaData.iterator();

            while (metaDataIterator.hasNext())
            {
                if (Folder.class.equals(metaDataIterator.next().annotationType()))
                {
                    metaDataIterator.remove();
                    break;
                }
            }
            metaData.add(folder);
        }


                this.defaultValueReplaced = true;
            if (name != null && !name.startsWith(".") && !name.startsWith("/"))
            {
                name = NamingConventionUtils.toPath(viewConfigNode.getParent())  name;

                this.defaultValueReplaced = true;
            }

            if (name != null && !name.endsWith("/"))
            {
                name = name  "/";

                this.defaultValueReplaced = true;
            }

import java.lang.annotation.Annotation;
import java.util.Iterator;
import java.util.Set;
                View result = new ViewLiteral(basePath, name, extension, navigation, viewParams,
                updateNodeMetaData(viewConfigNode, result);
                return result;
        private void updateNodeMetaData(ViewConfigNode viewConfigNode, View view)
        {
            Set<Annotation> metaData = viewConfigNode.getMetaData();

            Iterator<? extends Annotation> metaDataIterator = metaData.iterator();

            while (metaDataIterator.hasNext())
            {
                if (View.class.equals(metaDataIterator.next().annotationType()))
                {
                    metaDataIterator.remove();
                    break;
                }
            }
            metaData.add(view);
        }

            if (basePath != null && !basePath.startsWith(".") && !basePath.startsWith("/"))
            {
                basePath = NamingConventionUtils.toPath(viewConfigNode.getParent())  basePath;

                this.defaultValueReplaced = true;
            }

            if (basePath != null && !basePath.endsWith("/"))
            {
                basePath = basePath  "/";

                this.defaultValueReplaced = true;
            }


        @View(basePath = "w1b")
        class Step7 implements ViewConfig
        {
        }

        @View(basePath = "w2b")
        class Step7 implements ViewConfig
        {
        }

        @View(basePath = "/")
        class Step2 implements ViewConfig
        {
        }

        @View(basePath = "/")
        class Step2 implements ViewConfig
        {
        }

        @View(basePath = "w11b")
        class Step7 implements ViewConfig
        {
        }

        @View(basePath = "w12b")
        class Step7 implements ViewConfig
        {
        }

        @View(basePath = "w13b")
        class Step7 implements ViewConfig
        {
        }
        String className = viewConfigClass.getName();
        if (!className.contains("."))
        {
            if (className.contains("$"))
            {
                className = className.substring(0, className.indexOf("$"));
            }

            throw new IllegalStateException("Please move the class '"  className  "' to a package!");
        }

 b/deltaspike/modules/security/api/src/main/java/org/apache/deltaspike/security/api/authorization/SimpleSecurityViolation.java
 * Implementation which just returns the given reason
class SimpleSecurityViolation implements SecurityViolation
    private static final long serialVersionUID = -5017812464381395966L;
    private final String reason;

    SimpleSecurityViolation(String reason)
import org.apache.deltaspike.core.api.config.PropertyLoader;
 * Default implementation of the PersistenceConfigurationProvider.
 *
        Properties unitProperties = PropertyLoader.getProperties("persistence-"  persistenceUnitName);
        if (unitProperties == null)
        {
            unitProperties = new Properties();
        }
import org.apache.deltaspike.data.api.QueryResult;
import org.apache.deltaspike.data.api.mapping.QueryInOutMapper;
    @SuppressWarnings("unchecked")
    public Object executeQuery(CdiQueryInvocationContext context)
    {
        Object result = execute(context);
        if (!isUnmappableResult(result) && context.hasQueryInOutMapper())
        {
            QueryInOutMapper<Object> mapper = (QueryInOutMapper<Object>)
                    context.getQueryInOutMapper();
            if (result instanceof List)
            {
                return mapper.mapResultList((List<Object>) result);
            }
            return mapper.mapResult(result);
        }
        return result;
    }

    protected abstract Object execute(CdiQueryInvocationContext ctx);
    private boolean isUnmappableResult(Object result)
    {
        return result instanceof QueryResult ||
                result instanceof Query;
    }

        return ((Query) builder.executeQuery(context)).getResultList();
        return (T) ((Query) builder.executeQuery(context)).getSingleResult();
            Long result = (Long) ((Query) builder.executeQuery(context)).getSingleResult();
import org.apache.deltaspike.data.api.mapping.QueryInOutMapper;
    public void init()
    {
        if (hasQueryInOutMapper())
        {
            QueryInOutMapper<?> mapper = getQueryInOutMapper();
            params.applyMapper(mapper);
            for (int i = 0; i < args.length; i)
            {
                if (mapper.mapsParameter(args[i]))
                {
                    args[i] = mapper.mapParameter(args[i]);
                }
            }
        }
    }

    public boolean hasQueryInOutMapper()
    {
        return repoMethod.hasQueryInOutMapper();
    }

    public QueryInOutMapper<?> getQueryInOutMapper()
    {
        return repoMethod.getQueryInOutMapperInstance(this);
    }

            Object result = builder.executeQuery(queryContext);
        queryContext.init();
import java.lang.annotation.Annotation;
import java.util.Set;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;

import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.api.provider.DependentProvider;
import org.apache.deltaspike.data.api.mapping.MappingConfig;
import org.apache.deltaspike.data.api.mapping.QueryInOutMapper;
import org.apache.deltaspike.data.impl.handler.CdiQueryInvocationContext;
import org.apache.deltaspike.data.impl.util.bean.DependentProviderDestroyable;
    private final Class<? extends QueryInOutMapper> mapper;

    private volatile Boolean queryInOutMapperIsNormalScope;
        this.mapper = extractMapper(method, repo);
    public QueryInOutMapper<?> getQueryInOutMapperInstance(CdiQueryInvocationContext context)
    {
        if (!hasQueryInOutMapper())
        {
            return null;
        }
        QueryInOutMapper<?> result = null;
        lazyInit();
        if (!queryInOutMapperIsNormalScope)
        {
            final DependentProvider<? extends QueryInOutMapper> mappedProvider = BeanProvider.getDependent(mapper);
            result = mappedProvider.get();
            context.addDestroyable(new DependentProviderDestroyable(mappedProvider));
        }
        else
        {
            result = BeanProvider.getContextualReference(mapper);
        }
        return result;
    }

    private Class<? extends QueryInOutMapper> extractMapper(Method queryMethod, RepositoryComponent repoComponent)
    {
        if (queryMethod.isAnnotationPresent(MappingConfig.class))
        {
            return queryMethod.getAnnotation(MappingConfig.class).value();
        }
        if (repoComponent.getRepositoryClass().isAnnotationPresent(MappingConfig.class))
        {
            return repoComponent.getRepositoryClass().getAnnotation(MappingConfig.class).value();
        }
        return null;
    }

    //don't trigger this lookup during ProcessAnnotatedType
    private void lazyInit()
    {
        if (queryInOutMapperIsNormalScope == null)
        {
            init(BeanManagerProvider.getInstance().getBeanManager());
        }
    }

    private synchronized void init(BeanManager beanManager)
    {
        if (queryInOutMapperIsNormalScope != null)
        {
            return;
        }

        if (queryInOutMapperIsNormalScope != null && beanManager != null)
        {
            final Set<Bean<?>> beans = beanManager.getBeans(mapper);
            final Class<? extends Annotation> scope = beanManager.resolve(beans).getScope();
            queryInOutMapperIsNormalScope = beanManager.isNormalScope(scope);
        }
        else
        {
            queryInOutMapperIsNormalScope = false;
        }
    }

    public boolean hasQueryInOutMapper()
    {
        return mapper != null;
    }

        query.setParameter(index, queryValue());
        query.setParameter(name, queryValue());
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.deltaspike.data.api.mapping.QueryInOutMapper;

    private static final Logger LOG = Logger.getLogger(Parameter.class.getName());
    protected Object mappedValue = null;

    public void applyMapper(QueryInOutMapper<?> mapper)
    {
        if (mapper.mapsParameter(value))
        {
            mappedValue = mapper.mapParameter(value);
            LOG.log(Level.FINE, "Converting param {0} to {1}", new Object[] { value, mappedValue });
        }
    }

    protected Object queryValue()
    {
        return mappedValue != null ? mappedValue : value;
    }

import org.apache.deltaspike.data.api.mapping.QueryInOutMapper;
    public void applyMapper(QueryInOutMapper<?> mapper)
    {
        for (Parameter param : parameterList)
        {
            param.applyMapper(mapper);
        }
    }

    @Override
    public String toString()
    {
        return "Simple [id="  id  ", name="  name  ", camelCase="  camelCase  ", enabled="  enabled
                 ", counter="  counter  ", temporal="  temporal  ", embedded="  embedded  "]";
    }

    private Long teeSetId;
    private Long holeId;
    private Long teeSetId;
    private Long holeId;
    /**
     * These config keys will get used to detect the ProjectStage.
     * We iterate through them until we find the first non-empty value.
     */
    public static final String[] CONFIG_SETTING_KEYS =
            {
                    "org.apache.deltaspike.ProjectStage",
                    "javax.faces.PROJECT_STAGE",
                    "faces.PROJECT_STAGE"
            };


        for (String configLocation : CONFIG_SETTING_KEYS)
            String stageName = ConfigResolver.getPropertyValue(configLocation);

            if (stageName != null && !stageName.isEmpty())
            {
                return ProjectStage.valueOf(stageName);
            }

    {
        //TODO discuss it
        "org.apache.deltaspike.ProjectStage",
        "javax.faces.PROJECT_STAGE",
        "faces.PROJECT_STAGE"
    };
    /**
     * Defines how a single result query is fetched. Defaults to the JPA way with
     * Exceptions thrown on non-single result queries.
     */
    SingleResultType singleResult() default SingleResultType.JPA;

     * Fetch a single result entity. Returns {@code null} if no result is found.
     *
     * @return                  Entity retrieved by the query, or {@code null} if no result.
     */
    E getOptionalResult();

    /**
     * Fetch a single result entity. Returns {@code null} if no result is found. If the
     * query finds multiple results, it simply returns the first one found.
     *
     * @return                  First Entity retrieved by the query, or {@code null} if no result.
     */
    E getAnyResult();

    /**
    String methodPrefix() default "";
     * Executes the query which has a single result. Returns {@code null}
     * if there is no result.
     * @return Entity matching the search query, or {@code null} if there is none.
     */
    R getOptionalResult();

    /**
     * Executes the query and returns a single result. If there are
     * multiple results, the first received is returned.
     * @return Entity matching the search query.
     */
    R getAnyResult();

    /**
import org.apache.deltaspike.data.impl.meta.MethodPrefix;
    public static final QueryRoot UNKNOWN_ROOT = new QueryRoot("null-object", new MethodPrefix("", null));
    private final MethodPrefix methodPrefix;
    protected QueryRoot(String entityName, MethodPrefix methodPrefix)
        this.methodPrefix = methodPrefix;
    public static QueryRoot create(String method, RepositoryComponent repo, MethodPrefix prefix)
        QueryRoot root = new QueryRoot(repo.getEntityName(), prefix);
        return !methodPrefix.getPrefix().equals(orderByParts[0]);
        return methodPrefix.removePrefix(queryPart);
import javax.persistence.NoResultException;
    public T getOptionalResult()
    {
        try
        {
            return getSingleResult();
        }
        catch (NoResultException e)
        {
            return null;
        }
    }

    @Override
    public T getAnyResult()
    {
        List<T> queryResult = getResultList();
        return queryResult.size() > 0 ? queryResult.get(0) : null;
    }

    @Override
import org.apache.deltaspike.data.impl.handler.CdiQueryInvocationContext;

    Object executeQuery(Query query, CdiQueryInvocationContext context);
import javax.persistence.NoResultException;
import org.apache.deltaspike.data.api.SingleResultType;
import org.apache.deltaspike.data.impl.handler.CdiQueryInvocationContext;
        public Object executeQuery(Query query, CdiQueryInvocationContext context)
        public Object executeQuery(Query query, CdiQueryInvocationContext context)
        public Object executeQuery(Query query, CdiQueryInvocationContext context)
            SingleResultType style = context.getSingleResultStyle();
            switch (style)
            {
                case JPA:
                    return query.getSingleResult();
                case OPTIONAL:
                    try
                    {
                        return query.getSingleResult();
                    }
                    catch (NoResultException e)
                    {
                        return null;
                    }
                default:
                    List<Object> queryResult = query.getResultList();
                    return queryResult.size() > 0 ? queryResult.get(0) : null;
            }
        public Object executeQuery(Query query, CdiQueryInvocationContext context)
import javax.persistence.NoResultException;
    public R getOptionalResult()
    {
        try
        {
            return getSingleResult();
        }
        catch (NoResultException e)
        {
            return null;
        }
    }

    @Override
    public R getAnyResult()
    {
        List<R> queryResult = getResultList();
        return queryResult.size() > 0 ? queryResult.get(0) : null;
    }

    @Override
import org.apache.deltaspike.data.api.SingleResultType;
        return repoMethod.getQueryProcessor().executeQuery(jpaQuery, this);
    public SingleResultType getSingleResultStyle()
    {
        return repoMethod.getSingleResultStyle();
    }

import javax.persistence.PersistenceException;
import org.apache.deltaspike.data.api.QueryInvocationException;
        catch (PersistenceException e)
        {
            throw e;
        }
            log.log(Level.FINEST, "Query execution error", e);
    public String getCustomMethodPrefix()
    {
        return repoClass.getAnnotation(Repository.class).methodPrefix();
    }

import org.apache.deltaspike.data.api.SingleResultType;
    private final MethodPrefix methodPrefix;
        this.methodPrefix = new MethodPrefix(repo.getCustomMethodPrefix(), method.getName());
            return QueryRoot.create(method.getName(), repo, methodPrefix);
            QueryRoot.create(method.getName(), repo, methodPrefix);
    public SingleResultType getSingleResultStyle()
    {
        if (method.isAnnotationPresent(Query.class))
        {
            return method.getAnnotation(Query.class).singleResult();
        }
        return methodPrefix.getSingleResultStyle();
    }

    public Simple queryOptional(String name)
    {
        return criteria()
                .eq(Simple_.name, name)
                .getOptionalResult();
    }

    public Simple queryAny(String name)
    {
        return criteria()
                .eq(Simple_.name, name)
                .getAnyResult();
    }

import static javax.persistence.LockModeType.PESSIMISTIC_WRITE;
import static org.apache.deltaspike.data.api.SingleResultType.ANY;
import static org.apache.deltaspike.data.api.SingleResultType.OPTIONAL;

    @Query(named = Simple.BY_NAME_LIKE, singleResult = OPTIONAL)
    public abstract Simple findByNameOptional(String name);

    @Query(named = Simple.BY_NAME_LIKE, singleResult = ANY)
    public abstract Simple findByNameAny(String name);

    @Query(named = Simple.BY_ID, lock = PESSIMISTIC_WRITE)
    public abstract Simple findOptionalByName(String name);

    public abstract Simple findAnyByName(String name);

 b/deltaspike/modules/data/api/src/main/java/org/apache/deltaspike/data/api/QueryInvocationException.java
package org.apache.deltaspike.data.api;
import org.apache.deltaspike.data.spi.QueryInvocationContext;

    public QueryInvocationException(Throwable t, QueryInvocationContext context)
    public QueryInvocationException(String message, QueryInvocationContext context)
    private static String createMessage(QueryInvocationContext context)
        builder.append("Repository=").append(context.getRepositoryClass().getName()).append(",");
    private static String createMessage(QueryInvocationContext context, Throwable t)
    private static String createMessage(Class<?> repoClass, Method method, Throwable t)
        builder.append("Repository=").append(repoClass).append(",");
import java.lang.reflect.Method;

    /**
     * The type of the repository currently accessed.
     */
    Class<?> getRepositoryClass();

    /**
     * The repository method currently executed.
     */
    Method getMethod();

import javax.persistence.PersistenceException;
import org.apache.deltaspike.data.api.QueryInvocationException;
        catch (PersistenceException e)
        {
            throw e;
        }
            if (e.getCause() != null && e.getCause() instanceof PersistenceException)
            {
                throw (PersistenceException) e.getCause();
            }
            throw new QueryInvocationException(e, context);
    @Override
    public Class<?> getRepositoryClass()
    {
        return repoMethod.getRepository().getRepositoryClass();
    }

    @Override
import org.apache.deltaspike.core.api.literal.ViewControllerRefLiteral;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/literal/ViewControllerRefLiteral.java
package org.apache.deltaspike.core.api.literal;
import javax.annotation.Resource;
    @Resource
    private UserTransaction userTransaction;

        if (userTransaction != null)
        {
            return userTransaction;
        }

import org.apache.deltaspike.core.api.config.view.metadata.SkipMetaDataMerge;
    @SkipMetaDataMerge
import org.apache.deltaspike.core.api.config.view.metadata.SkipMetaDataMerge;
    @SkipMetaDataMerge
    @SkipMetaDataMerge
import org.apache.deltaspike.core.api.config.view.metadata.SkipMetaDataMerge;
                            inheritedValue.equals(defaultValue) ||
                            annotationMethod.isAnnotationPresent(SkipMetaDataMerge.class))
import java.lang.annotation.Annotation;
        accessDecisionVoterContext.addMetaData(ViewConfig.class.getName(), viewConfigDescriptor.getConfigClass());
        for (Annotation viewMetaData : viewConfigDescriptor.getMetaData())
        {
            if (!viewMetaData.annotationType().equals(Secured.class))
            {
                accessDecisionVoterContext.addMetaData(viewMetaData.annotationType().getName(), viewMetaData);
            }
        }

        boolean outermostTransactionAlreadyExisted = false;
                else if (isOutermostInterceptor)
                {
                    outermostTransactionAlreadyExisted = true;
                }
                if (!outermostTransactionAlreadyExisted)
                    // We only commit transactions we opened ourselfs.
                    // If the transaction got opened outside of our interceptor chain
                    // we must not handle it.
                    // This e.g. happens if a Stateless EJB invokes a Transactional CDI bean
                    // which uses the BeanManagedUserTransactionStrategy.

                    rollbackAllTransactions(entityManagerEntryList);
            // For Resource-local this is a 'JTA for poor men' only, and will not guaranty
            // In case of JTA we will just commit the UserTransaction.
                if (!outermostTransactionAlreadyExisted)
                    // We only commit transactions we opened ourselfs.
                    // If the transaction got opened outside of our interceptor chain
                    // we must not handle it.
                    // This e.g. happens if a Stateless EJB invokes a Transactional CDI bean
                    // which uses the BeanManagedUserTransactionStrategy.
                    if (firstException == null)
                        // only commit all transactions if we didn't rollback
                        // them already
                        Set<EntityManagerEntry> entityManagerEntryList =
                            transactionBeanStorage.getUsedEntityManagerEntries();
                        boolean rollbackOnly = false;
                        // but first try to flush all the transactions and write the updates to the database
                        for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
                        {
                            EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
                            if (transaction != null && transaction.isActive())
                            {
                                try
                                {
                                    if (!commitFailed)
                                        currentEntityManagerEntry.getEntityManager().flush();

                                        if (!rollbackOnly && transaction.getRollbackOnly())
                                        {
                                            // don't set commitFailed to true directly
                                            // (the order of the entity-managers isn't deterministic
                                            //  -> tests would break)
                                            rollbackOnly = true;
                                        }
                                catch (Exception e)
                                {
                                    firstException = e;
                                    commitFailed = true;
                                    break;
                                }
                        if (rollbackOnly)
                            commitFailed = true;
                        }

                        // and now either commit or rollback all transactions
                        for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
                        {
                            EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
                            if (transaction != null && transaction.isActive())
                                try
                                    // last chance to check it (again)
                                    if (commitFailed || transaction.getRollbackOnly())
                                    {
                                        transaction.rollback();
                                    }
                                    else
                                    {
                                        transaction.commit();
                                    }
                                catch (Exception e)
                                    firstException = e;
                                    commitFailed = true;
    private void rollbackAllTransactions(Set<EntityManagerEntry> entityManagerEntryList)
    {
        for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
        {
            EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
            if (transaction != null && transaction.isActive())
            {
                try
                {
                    transaction.rollback();
                }
                catch (Exception eRollback)
                {
                    if (LOGGER.isLoggable(Level.SEVERE))
                    {
                        LOGGER.log(Level.SEVERE,
                                "Got additional Exception while subsequently " 
                                "rolling back other SQL transactions", eRollback);
                    }
                }
            }
        }
    }

import org.apache.deltaspike.core.api.config.view.metadata.CallbackDescriptor;
import java.util.List;
import java.util.Map;
        getChildren().addAll(nodeToCopy.getChildren());

        for (Map.Entry<Class<? extends Annotation>, List<CallbackDescriptor>> callbackDescriptorEntry :
                nodeToCopy.getCallbackDescriptors().entrySet())
        {
            for (CallbackDescriptor callbackDescriptor : callbackDescriptorEntry.getValue())
            {
                registerCallbackDescriptors(callbackDescriptorEntry.getKey(), callbackDescriptor);
            }
        }
 b/deltaspike/modules/jsf/impl/src/main/java/org/apache/deltaspike/jsf/impl/listener/system/JsfSystemEventBroadcaster.java
public class JsfSystemEventBroadcaster implements SystemEventListener, Deactivatable
    public JsfSystemEventBroadcaster()
    protected List<Annotation> addViewMetaData(Class currentClass)
            addViewMetaData(annotation, result);
    protected void addViewMetaData(Annotation currentAnnotation, List<Annotation> metaDataList)
    {
        Class<? extends Annotation> annotationClass = currentAnnotation.annotationType();

        if (annotationClass.isAnnotationPresent(ViewMetaData.class))
        {
            metaDataList.add(currentAnnotation);
        }
        else if (annotationClass.isAnnotationPresent(Stereotype.class))
        {
            for (Annotation inheritedViaStereotype : annotationClass.getAnnotations())
            {
                if (inheritedViaStereotype.annotationType().isAnnotationPresent(ViewMetaData.class))
                {
                    metaDataList.add(inheritedViaStereotype);
                }
            }
        }
    }

    protected void addInterfaces(Set<Class> processedTypes, Stack<Class> classesToAnalyze, Class nextClass)
import java.lang.annotation.Annotation;


    /**
     * Signals a started scope
     * @param scopeClass annotation-class of the scope
     */
    void startScope(Class<? extends Annotation> scopeClass);

    /**
     * Signals a stopped scope
     * @param scopeClass annotation-class of the scope
     */
    void stopScope(Class<? extends Annotation> scopeClass);
public class EventBridgeContextListener extends EventBroadcaster implements ServletContextListener
public class EventBridgeFilter extends EventBroadcaster implements Filter
public class EventBridgeSessionListener extends EventBroadcaster implements HttpSessionListener
 b/deltaspike/modules/servlet/impl/src/main/java/org/apache/deltaspike/servlet/impl/event/EventBroadcaster.java
abstract class EventBroadcaster implements Deactivatable
    public EventBroadcaster()
import javax.faces.application.ConfigurableNavigationHandler;
import javax.faces.application.NavigationHandler;
import java.util.logging.Logger;
    private static final Logger LOG = Logger.getLogger(NavigationCaseMapWrapper.class.getName());

    private final NavigationHandler wrapped;
     * @param wrapped wrapped navigation-handler
    public NavigationCaseMapWrapper(Map<String, Set<NavigationCase>> navigationCases, NavigationHandler wrapped)
        this.wrapped = wrapped;
        Map<String, Set<NavigationCase>> result;

        if (this.wrapped instanceof ConfigurableNavigationHandler)
        {
            result = new DelegatingMap((ConfigurableNavigationHandler)this.wrapped);
        }
        else
        {
            LOG.warning("the wrapped navigation-handler doesn't extend " 
                ConfigurableNavigationHandler.class.getName() 
                    ". therefore std. navigation-rules might not work correctly with mojarra");
            result = new HashMap<String, Set<NavigationCase>>();
        }

    //currently not a complete handling, but enough to fix the issues with mojarra
    private class DelegatingMap extends HashMap<String, Set<NavigationCase>>
    {
        private static final long serialVersionUID = -955468874397821639L;
        private final ConfigurableNavigationHandler wrapped;

        private DelegatingMap(ConfigurableNavigationHandler wrapped)
        {
            this.wrapped = wrapped;
        }

        @Override
        public Set<NavigationCase> put(String key, Set<NavigationCase> value)
        {
            //delegate to the wrapped instance -> the innermost handler needs to receive it
            //(because mojarra uses ConfigurableNavigationHandler#getNavigationCases
            // to add cases for std. nav.rules from the outside)
            return this.wrapped.getNavigationCases().put(key, value);
        }

        @Override
        public Set<NavigationCase> get(Object key)
        {
            Set<NavigationCase> navigationCases = super.get(key);
            if (navigationCases == null)
            {
                navigationCases = new HashSet<NavigationCase>();
                put((String)key, navigationCases);
            }

            return new DelegatingSet(navigationCases, this.wrapped, (String)key);
        }
    }

    //currently not a complete handling, but enough to fix the issues with mojarra
    private class DelegatingSet extends HashSet<NavigationCase>
    {
        private static final long serialVersionUID = -7040572530963900394L;

        private final ConfigurableNavigationHandler wrapped;
        private String navigationCaseKey;

        private DelegatingSet(Collection<? extends NavigationCase> c,
                              ConfigurableNavigationHandler wrapped,
                              String navigationCaseKey)
        {
            super(c);
            this.wrapped = wrapped;
            this.navigationCaseKey = navigationCaseKey;
        }

        @Override
        public boolean add(NavigationCase navigationCase)
        {
            Set<NavigationCase> navigationCases = this.wrapped.getNavigationCases().get(this.navigationCaseKey);

            if (navigationCases == null)
            {
                navigationCases = new HashSet<NavigationCase>();
                this.wrapped.getNavigationCases().put(this.navigationCaseKey, navigationCases);
            }

            return navigationCases.add(navigationCase);
        }
    }
        return new NavigationCaseMapWrapper(result, this.wrapped);
            if (value == null)
            {
                return null;
            }

            Set<NavigationCase> result = new HashSet<NavigationCase>();

            //filter entries created by createViewConfigBasedNavigationCases
            for (NavigationCase navigationCase : value)
            {
                if (!(navigationCase.getFromOutcome() == null && navigationCase.getFromAction() == null))
                {
                    result.add(navigationCase);
                }
            }

            return this.wrapped.getNavigationCases().put(key, result);
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resoureloader/ExternalResource.java
package org.apache.deltaspike.core.api.resoureloader;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resoureloader/ExternalResourceLiteral.java
package org.apache.deltaspike.core.api.resoureloader;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resoureloader/XMLProperties.java
package org.apache.deltaspike.core.api.resoureloader;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/spi/resourceloader/ExternalResourceProvider.java
package org.apache.deltaspike.core.spi.resourceloader;
import org.apache.deltaspike.core.api.resoureloader.ExternalResource;
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/resourceloader/ClasspathResourceProvider.java
package org.apache.deltaspike.core.impl.resourceloader;
import org.apache.deltaspike.core.api.resoureloader.ExternalResource;
import org.apache.deltaspike.core.spi.resourceloader.ExternalResourceProvider;
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/resourceloader/ExternalResourceProducer.java
package org.apache.deltaspike.core.impl.resourceloader;
import org.apache.deltaspike.core.api.resoureloader.ExternalResource;
import org.apache.deltaspike.core.api.resoureloader.XMLProperties;
import org.apache.deltaspike.core.spi.resourceloader.ExternalResourceProvider;
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/resourceloader/ExternalResourceProviderComparator.java
package org.apache.deltaspike.core.impl.resourceloader;
import org.apache.deltaspike.core.spi.resourceloader.ExternalResourceProvider;
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/resourceloader/FileResourceProvider.java
package org.apache.deltaspike.core.impl.resourceloader;
import org.apache.deltaspike.core.api.resoureloader.ExternalResource;
import org.apache.deltaspike.core.spi.resourceloader.ExternalResourceProvider;
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/resourceloader/ResourceLoaderExtension.java
package org.apache.deltaspike.core.impl.resourceloader;
import org.apache.deltaspike.core.spi.activation.Deactivatable;

import java.util.logging.Logger;
    private static final Logger LOG = Logger.getLogger(ServiceUtils.class.getName());

        return loadServiceImplementations(serviceType, false);
    }

    public static <T> List<T> loadServiceImplementations(Class<T> serviceType,
                                                         boolean ignoreServicesWithMissingDependencies)
    {
            try
            {
                T service = servicesIterator.next();

                if (service instanceof Deactivatable &&
                        !ClassDeactivationUtils.isActivated((Class<? extends Deactivatable>) service.getClass()))
                {
                    LOG.info("deactivated service: "  service.getClass().getName());

                    continue;
                }
                result.add(service);
            }
            catch (Throwable t)
            {
                if (!ignoreServicesWithMissingDependencies)
                {
                    throw ExceptionUtils.throwAsRuntimeException(t);
                }
                else
                {
                    LOG.info("service filtered - caused by "  t.getMessage());
                }
            }
        public void jobToBeExecuted(JobExecutionContext jobExecutionContext)
            Scheduled scheduled = jobExecutionContext.getJobInstance().getClass().getAnnotation(Scheduled.class);
            if (!this.scopes.isEmpty())
                this.contextControl = BeanProvider.getContextualReference(ContextControl.class);

                for (Class<? extends Annotation> scopeAnnotation : this.scopes)
                {
                    contextControl.startContext(scopeAnnotation);
                }
            BeanProvider.injectFields(jobExecutionContext.getJobInstance());
    private static final Logger logger = Logger.getLogger(ClasspathResourceProvider.class.getName());
    private static final Logger logger = Logger.getLogger(ExternalResourceProducer.class.getName());
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/literal/ExternalResourceLiteral.java
package org.apache.deltaspike.core.api.literal;

import org.apache.deltaspike.core.api.resoureloader.ExternalResource;
    public static final String JOB_CLASS_CONFIG_KEY = "deltaspike.scheduler.job-class";
            String jobClassName = ConfigResolver.getPropertyValue(JOB_CLASS_CONFIG_KEY, "org.quartz.Job");
                new String[]{"org.apache.deltaspike.core",
                        "org.apache.deltaspike.test.category",
                        "org.apache.deltaspike.scheduler"},
                new String[]{"org.apache.deltaspike.core",
                        "org.apache.deltaspike.test.category",
                        "org.apache.deltaspike.partialbean"}, excludedFiles);
                new String[]{"org.apache.deltaspike.core",
                        "org.apache.deltaspike.test.category",
                        "org.apache.deltaspike.security"}, excludedFiles);
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
import org.apache.deltaspike.core.api.config.view.ViewRef;
        if (isInternal(viewConfigClass))
        {
            return;
        }

    private boolean isInternal(Class configClass)
    {
        return ViewConfig.class.equals(configClass) ||
                DefaultErrorView.class.equals(configClass) ||
                ViewRef.Manual.class.equals(configClass);
    }

    //allows to re-use it in a custom listener (if this one is deactivated e.g. to change the order)
            catch (Exception e)
                e.printStackTrace(); //for easier analysis (in combination with several servers)
    private String storage;
    private String location;
    public ExternalResourceLiteral(final String storage, final String location)
        this.storage = storage;
        this.location = location;
    public String location()
        return this.location;
    }

    @Override
    public String storage()
    {
        return this.storage;
    String storage();

    @Nonbinding
    String location() default "";
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/spi/literal/StorageTypeLiteral.java
package org.apache.deltaspike.core.spi.literal;
import org.apache.deltaspike.core.spi.resourceloader.StorageType;
import javax.enterprise.util.AnnotationLiteral;
public class StorageTypeLiteral extends AnnotationLiteral<StorageType> implements StorageType
    private String value;
    public StorageTypeLiteral(String value)
        this.value = value;
    }
    @Override
    public String value()
    {
        return this.value;
import java.util.Properties;
    InputStream readStream(final ExternalResource externalResource);
    Properties readProperties(final ExternalResource externalResource);
import org.apache.deltaspike.core.spi.resourceloader.StorageType;
@StorageType(StorageType.CLASSPATH)
public class ClasspathResourceProvider extends BaseResourceProvider
    public InputStream readStream(final ExternalResource externalResource)
            return readClassPath(externalResource.location());
import org.apache.deltaspike.core.spi.literal.StorageTypeLiteral;
import org.apache.deltaspike.core.spi.resourceloader.StorageType;
import java.lang.annotation.Annotation;
    private ExternalResourceProvider getProvider(String storageTypeName)
    {
        StorageType storageType = new StorageTypeLiteral(storageTypeName);
        ExternalResourceProvider provider = resourceProviders.select(storageType).get();
        return provider;
    }

    @ExternalResource(storage = "",location = "")
        ExternalResource externalResource = getAnnotation(injectionPoint);
        ExternalResourceProvider provider = getProvider(externalResource.storage());
        final InputStream is = provider.readStream(externalResource);
    @ExternalResource(storage = "",location = "")
        ExternalResource externalResource = getAnnotation(injectionPoint);
        ExternalResourceProvider provider = getProvider(externalResource.storage());
        final Properties properties = provider.readProperties(externalResource);
        return properties;
    public void closeInputStream(@Disposes @ExternalResource(storage = "",location = "") InputStream inputStream)
        for (Annotation annotation : injectionPoint.getQualifiers())
            if (annotation instanceof ExternalResource)
                return (ExternalResource)annotation;
import org.apache.deltaspike.core.spi.resourceloader.StorageType;
import java.util.logging.Level;
import java.util.logging.Logger;
@StorageType(StorageType.FILE)
public class FileResourceProvider extends BaseResourceProvider
    private static final Logger logger = Logger.getLogger(FileResourceProvider.class.getName());
                logger.log(Level.SEVERE, "Problem reading resource.", e);

    @Override
    public InputStream readStream(ExternalResource externalResource)
    {
        return readFile(externalResource.location());
    }
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
import org.apache.deltaspike.core.api.config.view.ViewRef;
        if (isInternal(viewConfigClass))
        {
            return;
        }

    private boolean isInternal(Class configClass)
    {
        return ViewConfig.class.equals(configClass) ||
                DefaultErrorView.class.equals(configClass) ||
                ViewRef.Manual.class.equals(configClass);
    }

                new String[]{"org.apache.deltaspike.core",
                        "org.apache.deltaspike.test.category",
                        "org.apache.deltaspike.partialbean"}, excludedFiles);
    public static final String JOB_CLASS_CONFIG_KEY = "deltaspike.scheduler.job-class";
            String jobClassName = ConfigResolver.getPropertyValue(JOB_CLASS_CONFIG_KEY, "org.quartz.Job");
                new String[]{"org.apache.deltaspike.core",
                        "org.apache.deltaspike.test.category",
                        "org.apache.deltaspike.security"}, excludedFiles);
import org.apache.deltaspike.core.api.resoureloader.ExternalResourceStorage;
    private Class<? extends ExternalResourceStorage> storage;
    public ExternalResourceLiteral(final Class<? extends ExternalResourceStorage> storage, final String location)
    public Class<? extends ExternalResourceStorage> storage()
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resoureloader/ClasspathStorage.java
/**
 * Represents storage found on the classpath
 */
public interface ClasspathStorage extends ExternalResourceStorage
    Class<? extends ExternalResourceStorage> storage();
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resoureloader/ExternalResourceStorage.java
/**
 * A marker interface for types of external resource storage.
 */
public interface ExternalResourceStorage
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resoureloader/FileSystemStorage.java
/**
 * A File System marker for external resources.
 */
public interface FileSystemStorage extends ExternalResourceStorage
import org.apache.deltaspike.core.api.resoureloader.ExternalResourceStorage;
    private Class<? extends ExternalResourceStorage> value;
    public StorageTypeLiteral(Class<? extends ExternalResourceStorage> value)
    public Class<? extends ExternalResourceStorage> value()
import org.apache.deltaspike.core.api.resoureloader.ExternalResourceStorage;

    Class<? extends ExternalResourceStorage> value();
    protected boolean isXml(String fileName)
        return fileName.endsWith(".xml");
        boolean isXml = this.isXml(name);
import org.apache.deltaspike.core.api.resoureloader.ClasspathStorage;
@StorageType(ClasspathStorage.class)
import org.apache.deltaspike.core.api.resoureloader.ExternalResourceStorage;
    private ExternalResourceProvider getProvider(Class<? extends ExternalResourceStorage> storageTypeClass)
        StorageType storageType = new StorageTypeLiteral(storageTypeClass);
    @ExternalResource(storage = ExternalResourceStorage.class,location = "")
    @ExternalResource(storage = ExternalResourceStorage.class,location = "")
    public void closeInputStream(@Disposes @ExternalResource(storage = ExternalResourceStorage.class,location = "")
                                 InputStream inputStream)
        System.out.println("processing injection point "  injectionPoint 
                " with qualifiers "  injectionPoint.getQualifiers());
import org.apache.deltaspike.core.api.resoureloader.FileSystemStorage;
@StorageType(FileSystemStorage.class)
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceStorage;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resourceloader/ClasspathStorage.java
package org.apache.deltaspike.core.api.resourceloader;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resourceloader/ExternalResource.java
package org.apache.deltaspike.core.api.resourceloader;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resourceloader/ExternalResourceStorage.java
package org.apache.deltaspike.core.api.resourceloader;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resourceloader/FileSystemStorage.java
package org.apache.deltaspike.core.api.resourceloader;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceStorage;
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceStorage;
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.ClasspathStorage;
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceStorage;
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.FileSystemStorage;
import java.util.logging.Level;
                if (logger.isLoggable(Level.FINE))
                {
                    logger.log(Level.FINE,"Unable to close input stream ",e);
                }
import java.util.ArrayList;
import java.util.List;

        InputStream result = null;
        URL firstURL = null;
                if (firstURL != null)
                {
                    throw new IllegalStateException("multiple files found for '"  name 
                        "' ("  firstURL.toExternalForm()  ", "  url.toExternalForm()  ")");
                }
                firstURL = url;
                result = is;
        return result;
                    if (result != null)
                    {
                        result.close();
                    }
                    is.close();
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import javax.enterprise.inject.spi.Extension;
                    try
                    finally
                    {
                        is.close();
                    }
import java.util.List;
    List<InputStream> readStreams(final ExternalResource externalResource);

import java.util.Collections;
import java.util.List;

    @Override
    public List<InputStream> readStreams(ExternalResource externalResource)
    {
        return Collections.singletonList(this.readStream(externalResource));
    }
import java.util.ArrayList;
import java.util.List;
            List<InputStream> matchedStreams = this.readClassPath(externalResource.location(),true);
            return matchedStreams.get(0);
    @Override
    public List<InputStream> readStreams(ExternalResource externalResource)
    {
        try
        {
            return readClassPath(externalResource.location(),false);
        }
        catch (IOException e)
        {
            throw new IllegalStateException("Error while trying to load resources from classpath ",e);
        }
    }

    /**
     * Reads all possibly matching classpath entries for the given name.
     *
     * If requireUnique is true, then validates that 1 element is present before returning
     *
     * @param name
     * @param requireUnique
     * @return
     * @throws IOException
     * @throws IllegalStateException
     */
    private List<InputStream> readClassPath(final String name, final boolean requireUnique)
        throws IllegalStateException,IOException
        List<URL> urlList = new ArrayList<URL>();
        List<InputStream> results = new ArrayList<InputStream>();
                results.add(is);
                urlList.add(url);
        if (requireUnique && results.size() != 1)
        {
            String msg = urlsToString(urlList,name);
            for (InputStream is : results)
            {
                try
                {
                    is.close();
                }
                catch (IOException e)
                {
                    if (logger.isLoggable(Level.FINE))
                    {
                        logger.log(Level.FINE,"Unable to close stream",e);
                    }
                }
            }
            throw new IllegalStateException(msg);
        }
        return results;
    }

    private String urlsToString(List<URL> urls, String name)
    {
        if (urls.size() == 0)
        {
            return String.format("No resources found for '%s'",name);
        }
        else
        {
            StringBuilder sb = new StringBuilder();
            sb.append(String.format("multiple resources found for '%s'",name));
            for (URL u : urls)
            {
                sb.append(" Match : ").append(u.toExternalForm());
            }
            return sb.toString();
        }
import java.util.List;
    public List<InputStream> getInputStreams(final InjectionPoint injectionPoint)
    {
        ExternalResource externalResource = getAnnotation(injectionPoint);
        ExternalResourceProvider provider = getProvider(externalResource.storage());
        return provider.readStreams(externalResource);
    }

    @Produces
    @ExternalResource(storage = ExternalResourceStorage.class,location = "")
import java.util.List;

    @Override
    public List<InputStream> getInputStreams()
    {
        throw new UnsupportedOperationException();
    }
import javax.enterprise.context.Dependent;
import java.util.List;
@Dependent
    @ExternalResource(storage = ClasspathStorage.class,location="META-INF/beans.xml")
    private List<InputStream> inputStreams;

    @Inject

    @Override
    public List<InputStream> getInputStreams() {
        return inputStreams;
    }
//TODO re-visit it (not needed, if we merge ExternalResourceStorage with ExternalResourceProvider - see DELTASPIKE-399)
//TODO re-visit it based on DELTASPIKE-472
    Class<? extends ExternalResourceStorage> storage() default ClasspathStorage.class;
    private static final long serialVersionUID = 1705986508118055892L;

    private static final long serialVersionUID = 9066640252429716441L;

    private static final long serialVersionUID = 6313493410718133308L;

     * @param beanManager we need the CDI {@link javax.enterprise.inject.spi.BeanManager} for serialisation.
     * @param createIfNotExist true if a new storage should get created (if it doesn't exist already), false otherwise
    public ContextualStorage getContextualStorage(BeanManager beanManager, String windowId, boolean createIfNotExist)
    {
        ContextualStorage contextualStorage = storageMap.get(windowId);
        if (contextualStorage == null && createIfNotExist)
        {
            contextualStorage = createContextualStorage(beanManager, windowId);
        }

        return contextualStorage;
    }

    private synchronized ContextualStorage createContextualStorage(BeanManager beanManager, String windowId)
            contextualStorage = new ContextualStorage(beanManager, true, true);
            storageMap.put(windowId, contextualStorage);
        ContextualStorage windowStorage = windowBeanHolder.getContextualStorage(beanManager, windowId, false);
        return windowStorage != null;
        return windowBeanHolder.getContextualStorage(beanManager, windowId, createIfNotExist);
import java.util.HashMap;

        ContextualInstanceInfo<?> contextualInstanceInfo = storage.getStorage().remove(storage.getBeanKey(bean));
        //drop all entries in the storage before starting with destroying the original entries
        Map<Object, ContextualInstanceInfo<?>> contextMap =
                new HashMap<Object, ContextualInstanceInfo<?>>(storage.getStorage());
        storage.getStorage().clear();

import java.io.Serializable;

public interface WindowContext extends Serializable
        return new InjectableWindowContext(deltaSpikeContextExtension.getWindowContext());
    public static Map<Object, ContextualInstanceInfo<?>> destroyAllActive(ContextualStorage storage)
        return contextMap;
    private static final long serialVersionUID = 6384932199958645324L;

 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/scope/DeltaSpikeContextExtension.java
package org.apache.deltaspike.core.impl.scope;
import org.apache.deltaspike.core.impl.scope.conversation.ConversationBeanHolder;
import org.apache.deltaspike.core.impl.scope.conversation.GroupedConversationContext;
import org.apache.deltaspike.core.impl.scope.window.WindowBeanHolder;
import org.apache.deltaspike.core.impl.scope.window.WindowContextImpl;
import org.apache.deltaspike.core.impl.scope.window.WindowIdHolder;
    private GroupedConversationContext conversationContext;

        conversationContext = new GroupedConversationContext(beanManager, windowContext);
        afterBeanDiscovery.addContext(conversationContext);
        WindowBeanHolder windowBeanHolder =
            BeanProvider.getContextualReference(beanManager, WindowBeanHolder.class, false);
        WindowIdHolder windowIdHolder =
            BeanProvider.getContextualReference(beanManager, WindowIdHolder.class, false);
        windowContext.init(windowBeanHolder, windowIdHolder);

        ConversationBeanHolder conversationBeanHolder =
            BeanProvider.getContextualReference(beanManager, ConversationBeanHolder.class, false);
        conversationContext.init(conversationBeanHolder);

    public GroupedConversationContext getConversationContext()
    {
        return conversationContext;
    }
import org.apache.deltaspike.core.impl.scope.DeltaSpikeContextExtension;
import org.apache.deltaspike.core.impl.scope.AbstractBeanHolder;
import javax.enterprise.context.SessionScoped;
public class WindowBeanHolder extends AbstractBeanHolder<String>
    public void init(WindowBeanHolder windowBeanHolder, WindowIdHolder windowIdHolder)
import org.apache.deltaspike.core.impl.scope.DeltaSpikeContextExtension;
 * {@link org.apache.deltaspike.core.impl.scope.DeltaSpikeContextExtension}.
import java.util.ArrayList;
import java.util.List;
 * {@link Context} interface and {@link #getContextualStorage(Contextual, boolean)}.
    protected abstract ContextualStorage getContextualStorage(Contextual<?> contextual, boolean createIfNotExist);

    protected List<ContextualStorage> getActiveContextualStorages()
    {
        List<ContextualStorage> result = new ArrayList<ContextualStorage>();
        result.add(getContextualStorage(null, false));
        return result;
    }
        ContextualStorage storage = getContextualStorage(bean, false);
        ContextualStorage storage = getContextualStorage(bean, true);
        ContextualStorage storage = getContextualStorage(bean, false);
     * {@link #getContextualStorage(Contextual, boolean)}.
        List<ContextualStorage> storages = getActiveContextualStorages();
        if (storages == null)
        for (ContextualStorage storage : storages)
        {
            destroyAllActive(storage);
        }
import java.util.ArrayList;
import java.util.List;
    protected ContextualStorage getContextualStorage(Contextual<?> contextual, boolean createIfNotExist)
        ConversationKey conversationKey = ConversationUtils.convertToConversationKey(contextual);
    protected List<ContextualStorage> getActiveContextualStorages()
    {
        List<ContextualStorage> result = new ArrayList<ContextualStorage>();
        result.addAll(this.conversationBeanHolder.getStorageMap().values());
        return result;
    }

    @Override
import javax.enterprise.context.spi.Contextual;
    protected ContextualStorage getContextualStorage(Contextual<?> contextual, boolean createIfNotExist)
import javax.enterprise.context.spi.Contextual;
    protected ContextualStorage getContextualStorage(Contextual<?> contextual, boolean createIfNotExists)
    protected ContextualStorage getContextualStorage(Contextual<?> contextual, boolean createIfNotExists)
        ContextualStorage windowStorage = windowBeanHolder.getStorageMap().remove(windowId);

        if (windowStorage != null)
        {
            AbstractContext.destroyAllActive(windowStorage);
        }

        return this.conversationBeanHolder.getContextualStorage(this.beanManager, conversationKey, createIfNotExist);
            if (windowId.equals(this.windowIdHolder.getWindowId()))
            {
                this.windowIdHolder.setWindowId(null);
            }
import javax.inject.Named;
    @Named("dsWindowContext")
 b/deltaspike/modules/jsf/impl/src/main/java/org/apache/deltaspike/jsf/impl/component/window/WindowIdHtmlRenderer.java
@FacesRenderer(componentFamily = WindowIdComponent.COMPONENT_FAMILY, rendererType = WindowIdComponent.COMPONENT_TYPE)
public class WindowIdHtmlRenderer extends Renderer
     * 'deltaspikeJsWindowId' will be used to:
import javax.enterprise.inject.spi.BeanManager;
    public GroupedConversation getGroupedConversation(InjectionPoint injectionPoint, BeanManager beanManager)
        ConversationKey conversationKey =
            ConversationUtils.convertToConversationKey(injectionPoint.getBean(), beanManager);
        ConversationKey conversationKey = ConversationUtils.convertToConversationKey(contextual, this.beanManager);
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.PassivationCapable;
        return convertToConversationKey(contextual, BeanManagerProvider.getInstance().getBeanManager());
    }

    public static ConversationKey convertToConversationKey(Contextual<?> contextual, BeanManager beanManager)
    {
            if (contextual instanceof PassivationCapable)
            {
                contextual = BeanManagerProvider.getInstance().getBeanManager()
                    .getPassivationCapableBean(((PassivationCapable) contextual).getId());
            }
            else
            {
                throw new IllegalArgumentException(
                        contextual.getClass().getName()  " is not of type "  Bean.class.getName());
            }
                contextual = beanManager.getPassivationCapableBean(((PassivationCapable) contextual).getId());
        destroyBean(bean, contextualInstanceInfo);
            destroyBean(bean, contextualInstanceInfo);
    public static void destroyBean(Contextual bean, ContextualInstanceInfo<?> contextualInstanceInfo)
    {
        bean.destroy(contextualInstanceInfo.getContextualInstance(), contextualInstanceInfo.getCreationalContext());
    }

import org.apache.deltaspike.core.api.scope.ConversationSubGroup;
import org.apache.deltaspike.core.util.context.ContextualInstanceInfo;
import java.util.Collections;
        ConversationSubGroup conversationSubGroup = conversationGroup.getAnnotation(ConversationSubGroup.class);
        Set<Class<?>> subGroups = null;

        if (conversationSubGroup != null)
        {
            conversationGroup = ConversationUtils.getDeclaredConversationGroup(conversationGroup);

            subGroups = new HashSet<Class<?>>(conversationSubGroup.subGroup().length);
            Collections.addAll(subGroups, conversationSubGroup.subGroup());
        }

                if (subGroups == null)
                {
                    AbstractContext.destroyAllActive(entry.getValue());
                    result.add(entry.getValue());
                    storageMap.remove(entry.getKey()); //ok due to ConcurrentHashMap
                }
                else
                {
                    tryToDestroySubGroup(subGroups, entry);

                    if (entry.getValue().getStorage().isEmpty())
                    {
                        storageMap.remove(entry.getKey()); //ok due to ConcurrentHashMap
                    }
                }
    private void tryToDestroySubGroup(Set<Class<?>> subGroups, Map.Entry<ConversationKey, ContextualStorage> entry)
    {
        ContextualStorage storage = entry.getValue();

        for (Map.Entry<Object, ContextualInstanceInfo<?>> storageEntry : storage.getStorage().entrySet())
        {
            for (Class<?> subGroup : subGroups)
            {
                Class classOfEntry = storageEntry.getValue().getContextualInstance().getClass();
                if (subGroup.equals(classOfEntry) ||
                    (subGroup.isInterface() && subGroup.isAssignableFrom(classOfEntry)))
                {
                    Contextual bean = storage.getBean(storageEntry.getKey());
                    AbstractContext.destroyBean(bean, storageEntry.getValue());
                    storage.getStorage().remove(storageEntry.getKey()); //ok due to ConcurrentHashMap
                    break;
                }
            }
        }
    }

import org.apache.deltaspike.core.api.scope.ConversationSubGroup;
                    contextual.getClass().getName()  " is not of type "  Bean.class.getName());

    public static Class<?> getDeclaredConversationGroup(Class<?> conversationGroup)
    {
        ConversationSubGroup conversationSubGroup = conversationGroup.getAnnotation(ConversationSubGroup.class);

        if (conversationSubGroup == null)
        {
            return conversationGroup;
        }

        Class<?> result = conversationSubGroup.of();

        if (!ConversationSubGroup.class.equals(result))
        {
            return result;
        }

        result = conversationGroup.getSuperclass();

        if ((result == null || Object.class.getName().equals(result.getName())) &&
                conversationGroup.getInterfaces().length == 1)
        {
            return conversationGroup.getInterfaces()[0];
        }

        if (result == null)
        {
            //TODO move validation to the bootstrapping process
            throw new IllegalStateException(conversationGroup.getName()  " hosts an invalid usage of @" 
                ConversationSubGroup.class.getName());
        }
        return result;
    }
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/scope/conversation/grouped/explicit/ExplicitlyGroupedBeanX.java
package org.apache.deltaspike.test.core.api.scope.conversation.grouped.explicit;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/scope/conversation/grouped/explicit/ExplicitlyGroupedBeanY.java
package org.apache.deltaspike.test.core.api.scope.conversation.grouped.explicit;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/scope/conversation/grouped/implicit/ImplicitlyGroupedBean.java
package org.apache.deltaspike.test.core.api.scope.conversation.grouped.implicit;
import java.util.Map;
public abstract class ClientWindow
    private static final String PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY =
            ClientWindow.class.getName()  ".ClientWindowRenderModeEnablement";
    public abstract String getWindowId(FacesContext facesContext);

    /**
     * <p>Components that permit per-use disabling
     * of the appending of the ClientWindow in generated URLs must call this method
     * first before rendering those URLs.  The caller must call
     * {@link #enableClientWindowRenderMode(javax.faces.context.FacesContext)}
     * from a <code>finally</code> block after rendering the URL.  If
     * {@link #CLIENT_WINDOW_MODE_PARAM_NAME} is "url" without the quotes, all generated
     * URLs that cause a GET request must append the ClientWindow by default.
     * This is specified as a static method because callsites need to access it
     * without having access to an actual {@code ClientWindow} instance.</p>
     *
     * @param context the {@link FacesContext} for this request.
     */
    public void disableClientWindowRenderMode(FacesContext context)
    {
        Map<Object, Object> attrMap = context.getAttributes();
        attrMap.put(PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY, Boolean.TRUE);
    }

    /**
     * <p>Components that permit per-use disabling
     * of the appending of the ClientWindow in generated URLs must call this method
     * first after rendering those URLs.  If
     * {@link #CLIENT_WINDOW_MODE_PARAM_NAME} is "url" without the quotes, all generated
     * URLs that cause a GET request must append the ClientWindow by default.
     * This is specified as a static method because callsites need to access it
     * without having access to an actual {@code ClientWindow} instance.</p>
     *
     * @param context the {@link FacesContext} for this request.
     */
    public void enableClientWindowRenderMode(FacesContext context)
    {
        Map<Object, Object> attrMap = context.getAttributes();
        attrMap.remove(PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY);
    }

    /**
     * <p>Methods that append the ClientWindow to generated
     * URLs must call this method to see if they are permitted to do so.  If
     * {@link #CLIENT_WINDOW_MODE_PARAM_NAME} is "url" without the quotes, all generated
     * URLs that cause a GET request must append the ClientWindow by default.
     * This is specified as a static method because callsites need to access it
     * without having access to an actual {@code ClientWindow} instance.</p>
     *
     * @param context the {@link FacesContext} for this request.
     */
    public boolean isClientWindowRenderModeEnabled(FacesContext context)
    {
        Map<Object, Object> attrMap = context.getAttributes();
        boolean result = !attrMap.containsKey(PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY);
        return result;
    }

    /**
     * <p>This method will be called whenever a URL
     * is generated by the runtime where client window related parameters need
     * to be inserted into the URL.  This guarantees custom {@code ClientWindow} implementations
     * that they will have the opportunity to insert any additional client window specific
     * information in any case where a URL is generated, such as the rendering
     * of hyperlinks.  The returned map must be immutable.  The default implementation of this method returns
     * the empty map.</p>

     * @param context the {@code FacesContext} for this request.
     * @return {@code null} or a map of parameters to insert into the URL query string.
     */
    public abstract Map<String, String> getQueryURLParameters(FacesContext context);
        URL,

import javax.faces.context.FacesContext;
import org.apache.deltaspike.jsf.impl.scope.window.ClientWindowHelper;
        this.wrapped.redirect(ClientWindowHelper.appendWindowId(FacesContext.getCurrentInstance(), url));
import java.util.HashMap;
public class DefaultClientWindow extends ClientWindow
    /**
     * GET request parameter
     */
    public static final String DELTASPIKE_WINDOW_ID_URL_PARAM = "dswid";

    private static final String NEW_WINDOW_ID = DefaultClientWindow.class.getName()  ".NEW_WINDOW_ID";
        if (ClientWindowRenderMode.URL.equals(clientWindowRenderMode))
        {
            ExternalContext externalContext = facesContext.getExternalContext();

            if (facesContext.getAttributes().containsKey(NEW_WINDOW_ID))
            {
                return (String) facesContext.getAttributes().get(NEW_WINDOW_ID);
            }
            else if (externalContext.getRequestParameterMap().containsKey(DELTASPIKE_WINDOW_ID_URL_PARAM))
            {
                return externalContext.getRequestParameterMap().get(DELTASPIKE_WINDOW_ID_URL_PARAM);
            }
            else
            {
                // store the new windowId as context attribute to prevent infinite loops
                // the #sendRedirect will append the windowId (from #getWindowId again) to the redirectUrl
                facesContext.getAttributes().put(NEW_WINDOW_ID, generateNewWindowId());
                ClientWindowHelper.handleInitialRedirect(facesContext);
                facesContext.responseComplete();
                return null;
            }
        }

        url = JsfUtils.addParameter(externalContext, url, false, NOSCRIPT_PARAMETER, "true");
    /**
     * {@inheritDoc}
     */
    @Override
    public void disableClientWindowRenderMode(FacesContext context)
    {
        ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(context);

        if (ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))
        {
            context.getExternalContext().getClientWindow().disableClientWindowRenderMode(context);
        }
        else if (ClientWindowRenderMode.URL.equals(clientWindowRenderMode))
        {
            super.disableClientWindowRenderMode(context);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void enableClientWindowRenderMode(FacesContext context)
    {
        ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(context);

        if (ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))
        {
            context.getExternalContext().getClientWindow().enableClientWindowRenderMode(context);
        }
        else if (ClientWindowRenderMode.URL.equals(clientWindowRenderMode))
        {
            super.enableClientWindowRenderMode(context);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isClientWindowRenderModeEnabled(FacesContext context)
    {
        ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(context);

        if (ClientWindowRenderMode.URL.equals(clientWindowRenderMode))
        {
            return super.isClientWindowRenderModeEnabled(context);
        }

        return false;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Map<String, String> getQueryURLParameters(FacesContext context)
    {
        ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(context);

        if (ClientWindowRenderMode.URL.equals(clientWindowRenderMode))
        {
            String windowId = getWindowId(context);
            if (windowId != null)
            {
                Map<String, String> params = new HashMap<String, String>();
                params.put(DELTASPIKE_WINDOW_ID_URL_PARAM, getWindowId(context));
                return params;
            }
        }

        return null;
    }
     * Adds the current page-parameters to the given url
     * Adds a paramter to the given url.
     *
     * @param externalContext   current external-context
     * @param url               current url
     * @param encodeValues      flag which indicates if parameter values should be encoded or not
     * @param name              the paramter name
     * @param value             the paramter value
     * @return url with appended parameter
     */
    public static String addParameter(ExternalContext externalContext, String url, boolean encodeValues,
            String name, String value)
    {
        // don't append if already available
        if (url.contains(name  "="  value)
                || url.contains(name  "="  encodeURLParameterValue(value, externalContext)))
        {
            return url;
        }

        StringBuilder finalUrl = new StringBuilder(url);

        if (url.contains("?"))
        {
            finalUrl.append("&");
        }
        else
        {
            finalUrl.append("?");
        }

        finalUrl.append(name);
        finalUrl.append("=");

        if (encodeValues)
        {
            finalUrl.append(JsfUtils.encodeURLParameterValue(value, externalContext));
        }
        else
        {
            finalUrl.append(value);
        }

        return finalUrl.toString();
    }

    /**
     * Adds the current request-parameters to the given url
     *
     * @param externalContext current external-context
     * @param url             current url
     * @param encodeValues    flag which indicates if parameter values should be encoded or not
     * @return url with request-parameters
     */
    public static String addRequestParameters(ExternalContext externalContext, String url, boolean encodeValues)
    {
        StringBuilder finalUrl = new StringBuilder(url);
        boolean existingParameters = url.contains("?");

        for (Map.Entry<String, String[]> entry : externalContext.getRequestParameterValuesMap().entrySet())
        {
            for (String value : entry.getValue())
            {
                if (!url.contains(entry.getKey()  "="  value) &&
                        !url.contains(entry.getKey()  "="  encodeURLParameterValue(value, externalContext)))
                {
                    if (!existingParameters)
                    {
                        finalUrl.append("?");
                        existingParameters = true;
                    }
                    else
                    {
                        finalUrl.append("&");
                    }

                    finalUrl.append(entry.getKey());
                    finalUrl.append("=");

                    if (encodeValues)
                    {
                        finalUrl.append(JsfUtils.encodeURLParameterValue(value, externalContext));
                    }
                    else
                    {
                        finalUrl.append(value);
                    }
                }
            }
        }

        return finalUrl.toString();
    }

    /**
import org.apache.deltaspike.jsf.impl.scope.window.ClientWindowHelper;
    public String getActionURL(FacesContext context, String viewId)
    {
        return ClientWindowHelper.appendWindowId(context, this.wrapped.getActionURL(context, viewId));
    }

    @Override
import org.apache.deltaspike.jsf.impl.util.ClientWindowHelper;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
    private final ClientWindow clientWindow;
    DeltaSpikeExternalContextWrapper(ExternalContext wrapped, ClientWindow clientWindow)
        this.clientWindow = clientWindow;

        String targetURL = ClientWindowHelper.appendWindowId(FacesContext.getCurrentInstance(),
                url, this.clientWindow);

        this.wrapped.redirect(targetURL);
    @Override
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
    private final ClientWindow clientWindow;

        this.clientWindow = BeanProvider.getContextualReference(ClientWindow.class, true);
        return new DeltaSpikeFacesContextWrapper(facesContext, clientWindow);
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
    private volatile Boolean initialized;

    DeltaSpikeFacesContextWrapper(FacesContext wrappedFacesContext, ClientWindow clientWindow)
                    new DeltaSpikeExternalContextWrapper(wrappedFacesContext.getExternalContext(), clientWindow);
        if (this.initialized == null)
        {
            init();
        }
    }

    private synchronized void init()
    {
        // switch into paranoia mode
        if (initialized == null)
            clientWindow = BeanProvider.getContextualReference(ClientWindow.class, true);
            windowContext = BeanProvider.getContextualReference(WindowContext.class, true);

            delegateWindowHandling =
                BeanProvider.getContextualReference(JsfModuleConfig.class).isDelegatedWindowHandlingEnabled();
import org.apache.deltaspike.jsf.impl.util.ClientWindowHelper;
            String windowId = (String) facesContext.getAttributes().get(NEW_WINDOW_ID);

            if (windowId == null)
                windowId = externalContext.getRequestParameterMap().get(DELTASPIKE_WINDOW_ID_URL_PARAM);

            if (windowId == null)

            return windowId;
 b/deltaspike/modules/jsf/impl/src/main/java/org/apache/deltaspike/jsf/impl/util/ClientWindowHelper.java
package org.apache.deltaspike.jsf.impl.util;
import javax.enterprise.inject.Typed;
@Typed()
public abstract class ClientWindowHelper
     * Appends the current windowId to the given url, if enabled via
     * @param clientWindow the {@link ClientWindow} to use
    public static String appendWindowId(FacesContext facesContext, String url, ClientWindow clientWindow)
        if (clientWindow != null && clientWindow.isClientWindowRenderModeEnabled(facesContext))
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.jsf.impl.util.ClientWindowHelper;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
    private final ClientWindow clientWindow;

        this.clientWindow = BeanProvider.getContextualReference(ClientWindow.class, true);
        String actionURL = this.wrapped.getActionURL(context, viewId);
        return ClientWindowHelper.appendWindowId(context, actionURL, clientWindow);
            if (storage != null)
            {
                destroyAllActive(storage);
            }
        FacesContext facesContext = FacesContext.getCurrentInstance();
        if (!ClientWindowHelper.isInitialRedirect(facesContext))
        {
            JsfUtils.saveFacesMessages(this.wrapped);
        }

        String targetURL = ClientWindowHelper.appendWindowId(facesContext, url, this.clientWindow);
            String windowId = (String) ClientWindowHelper.getInitialRedirectWindowId(facesContext);
                ClientWindowHelper.handleInitialRedirect(facesContext, generateNewWindowId());
    public static final String INITIAL_REDIRECT_WINDOW_ID = ClientWindowHelper.class.getName()
             ".INITIAL_REDIRECT_WINDOW_ID";

     * @param newWindowId the new windowId
    public static void handleInitialRedirect(FacesContext facesContext, String newWindowId)
        // store the new windowId as context attribute to prevent infinite loops
        // the #sendRedirect will append the windowId (from ClientWindow#getWindowId again) to the redirectUrl
        facesContext.getAttributes().put(INITIAL_REDIRECT_WINDOW_ID, newWindowId);

    public static boolean isInitialRedirect(FacesContext facesContext)
    {
        return facesContext.getAttributes().containsKey(INITIAL_REDIRECT_WINDOW_ID);
    }

    public static String getInitialRedirectWindowId(FacesContext facesContext)
    {
        return (String) facesContext.getAttributes().get(INITIAL_REDIRECT_WINDOW_ID);
    }

        // skip if we are in initialRedirect mode because
        // save messages via flash scope will fail because the JSF lifecycle isn't initialized
public interface ClientWindow
    String getWindowId(FacesContext facesContext);
     * Can be called to disable the window-id for an URL.
     * Don't forget to call {@link #enableClientWindowRenderMode(javax.faces.context.FacesContext)}
     * after rendering the markup for the current component, if {@link #isClientWindowRenderModeEnabled}
     * returned <code>true</code> before calling this method.
    void disableClientWindowRenderMode(FacesContext facesContext);
     * Can be used to reset window-id rendering for a specific component.
    void enableClientWindowRenderMode(FacesContext facesContext);
     * @return true if the window-id should be appended during the rendering-process, false otherwise
    boolean isClientWindowRenderModeEnabled(FacesContext facesContext);
     * @return meta-data for the current window which should get added to URLs, null otherwise
    Map<String, String> getQueryURLParameters(FacesContext facesContext);
import org.apache.deltaspike.core.spi.scope.window.WindowContext;
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindowConfig;

public class DefaultClientWindow implements ClientWindow
    private static final String PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY =
            ClientWindow.class.getName()  ".ClientWindowRenderModeEnablement";
    public void disableClientWindowRenderMode(FacesContext facesContext)
        ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(facesContext);
            facesContext.getExternalContext().getClientWindow().disableClientWindowRenderMode(facesContext);
            Map<Object, Object> attrMap = facesContext.getAttributes();
            attrMap.put(PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY, Boolean.TRUE);
    public void enableClientWindowRenderMode(FacesContext facesContext)
        ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(facesContext);
            facesContext.getExternalContext().getClientWindow().enableClientWindowRenderMode(facesContext);
            Map<Object, Object> attrMap = facesContext.getAttributes();
            attrMap.remove(PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY);
    public boolean isClientWindowRenderModeEnabled(FacesContext facesContext)
        ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(facesContext);
            Map<Object, Object> attrMap = facesContext.getAttributes();
            return  !attrMap.containsKey(PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY);
    public Map<String, String> getQueryURLParameters(FacesContext facesContext)
        ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(facesContext);
            String windowId = getWindowId(facesContext);
                params.put(DELTASPIKE_WINDOW_ID_URL_PARAM, getWindowId(facesContext));
public class InjectableWindowContext implements WindowContext
//keep it public for supporting #{dsWindowContext.getCurrentWindowId()} in addition to
//#{dsWindowContext.currentWindowId}
        if (ClientWindowRenderMode.LAZY.equals(clientWindowRenderMode))
        else if (ClientWindowRenderMode.LAZY.equals(clientWindowRenderMode))
        else if (ClientWindowRenderMode.LAZY.equals(clientWindowRenderMode))
        if (ClientWindowRenderMode.LAZY.equals(clientWindowRenderMode))
        if (ClientWindowRenderMode.LAZY.equals(clientWindowRenderMode))
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindowConfig;
    private volatile ClientWindowConfig clientWindowConfig;
        String mode = getClientWindowConfig().getClientWindowRenderMode(context).name();
        writer.write("window.deltaspikeWindowId='"  windowId  "';");
        writer.write("window.deltaspikeClientWindowRenderMode='"  mode  "';");
    
    private ClientWindowConfig getClientWindowConfig()
    {
        if (clientWindowConfig == null)
        {
            synchronized (this)
            {
                if (clientWindowConfig == null)
                {
                    clientWindowConfig = BeanProvider.getContextualReference(ClientWindowConfig.class);
                }
            }
        }

        return clientWindowConfig;
    }
import org.apache.deltaspike.core.util.StringUtils;
            if (StringUtils.isEmpty(windowId))
            if (StringUtils.isEmpty(windowId))
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindowConfig;
    /**
     * If the window-handling of JSF 2.2 is enabled,
     * {@link org.apache.deltaspike.jsf.spi.scope.window.ClientWindowConfig.ClientWindowRenderMode#DELEGATED}
     * will be returned. In all other cases <code>null</code> gets returned as application wide default value.
     * That leads to a default-handling per session (which includes logic for handling bots,...)
     * @return application-default for the window-mode
     */
    public ClientWindowConfig.ClientWindowRenderMode getDefaultWindowMode()
    {
        if (isDelegatedWindowHandlingEnabled())
        {
            return ClientWindowConfig.ClientWindowRenderMode.DELEGATED;
        }
        return null;
    }

    protected boolean isDelegatedWindowHandlingEnabled()
    private ClientWindowRenderMode defaultClientWindowRenderMode;
        this.defaultClientWindowRenderMode = this.jsfModuleConfig.getDefaultWindowMode();
            if (this.defaultClientWindowRenderMode != null)
                return this.defaultClientWindowRenderMode;
        if (this.defaultClientWindowRenderMode != null)
            return this.defaultClientWindowRenderMode;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindowConfig;
            delegateWindowHandling = ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(
                BeanProvider.getContextualReference(JsfModuleConfig.class).getDefaultWindowMode());
     * By default we use {@link ClientWindowRenderMode#LAZY} unless
     * we detect a bot. Use {@link org.apache.deltaspike.jsf.api.config.JsfModuleConfig#getDefaultWindowMode()}
     * to change this default behavior. Alternative:
                return this.defaultClientWindowRenderMode; //currently mainly needed for 'DELEGATED'
        return ClientWindowRenderMode.LAZY;
            String windowId = ClientWindowHelper.getInitialRedirectWindowId(facesContext);
        return true;
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
    private JsfModuleConfig jsfModuleConfig;

    @Inject
                if (this.jsfModuleConfig.isInitialRedirectEnabled())
                {
                    ClientWindowHelper.handleInitialRedirect(facesContext, generateNewWindowId());
                    facesContext.responseComplete();
                    return null;
                }
                else
                {
                    return generateNewWindowId();
                }
import javax.transaction.TransactionSynchronizationRegistry;
    protected static final String TRANSACTION_SYNC_REGISTRY_JNDI_NAME = "java:comp/TransactionSynchronizationRegistry";

            if (userTransaction == null)
            {
                // if there is a CMT EJB call active, then we do not set any timeout
                return;
            }

            if (userTransaction.getStatus() != Status.STATUS_ACTIVE)
            {
                userTransaction.setTransactionTimeout(transactionTimeout);
            }
        try
        {
            return JndiUtils.lookup(USER_TRANSACTION_JNDI_NAME, UserTransaction.class);
        }
        catch (Exception ne)
        {
            // do nothing it was just a try
            return null;
        }
    }

    protected TransactionSynchronizationRegistry resolveTransactionRegistry()
    {
        return JndiUtils.lookup(TRANSACTION_SYNC_REGISTRY_JNDI_NAME, TransactionSynchronizationRegistry.class);
        private TransactionSynchronizationRegistry transactionSynchronizationRegistry = null;

            if (this.userTransaction == null)
            {
                transactionSynchronizationRegistry = resolveTransactionRegistry();

                if (transactionSynchronizationRegistry.getTransactionStatus() != Status.STATUS_ACTIVE)
                {
                    throw new RuntimeException("invalid state/badly configured JTA datasource");
                }
            }

            if (this.userTransaction == null)
            {
                throw new IllegalStateException("cannot begin UserTransaction in CMT environment");
            }

            if (this.userTransaction == null)
            {
                throw new IllegalStateException("cannot commit UserTransaction in CMT environment");
            }


            if (this.userTransaction == null)
            {
                throw new IllegalStateException("cannot rollback UserTransaction in CMT environment");
            }

                if (this.userTransaction != null)
                {
                    this.userTransaction.setRollbackOnly();
                }
                else
                {
                    this.transactionSynchronizationRegistry.setRollbackOnly();
                }

                return this.getStatus() == Status.STATUS_MARKED_ROLLBACK;
                return this.getStatus() != Status.STATUS_NO_TRANSACTION &&
                        this.getStatus() != Status.STATUS_UNKNOWN; //TODO re-visit it
            return this.getStatus() != Status.STATUS_COMMITTED &&
                    this.getStatus() != Status.STATUS_NO_TRANSACTION &&
                    this.getStatus() != Status.STATUS_UNKNOWN;
            return this.getStatus() == Status.STATUS_ACTIVE ||
                    this.getStatus() == Status.STATUS_PREPARING ||
                    this.getStatus() == Status.STATUS_PREPARED;
        }

        protected int getStatus() throws SystemException
        {
            if (this.userTransaction != null)
            {
                return this.userTransaction.getStatus();
            }
            else
            {
                return this.transactionSynchronizationRegistry.getTransactionStatus();
            }
            if (userTransaction != null && userTransaction.getStatus() != Status.STATUS_ACTIVE)
        catch (Exception e)
        //needed for calls through an EJB with CMT
        private final TransactionSynchronizationRegistry transactionSynchronizationRegistry;
                this.transactionSynchronizationRegistry = resolveTransactionRegistry();
                if (this.transactionSynchronizationRegistry.getTransactionStatus() != Status.STATUS_ACTIVE)
                    throw new IllegalStateException(
                        "The CMT is not active. Please check the config of the Data-Source.");
            else
            {
                this.transactionSynchronizationRegistry = null;
            }
                throw new UnsupportedOperationException("A CMT is active. This operation is only supported with BMT.");
                throw new UnsupportedOperationException("A CMT is active. This operation is only supported with BMT.");
                throw new UnsupportedOperationException("A CMT is active. This operation is only supported with BMT.");
                return getTransactionStatus() == Status.STATUS_MARKED_ROLLBACK;
                return this.getTransactionStatus() != Status.STATUS_NO_TRANSACTION &&
                        this.getTransactionStatus() != Status.STATUS_UNKNOWN; //TODO re-visit it
            return this.getTransactionStatus() != Status.STATUS_COMMITTED &&
                    this.getTransactionStatus() != Status.STATUS_NO_TRANSACTION &&
                    this.getTransactionStatus() != Status.STATUS_UNKNOWN;
            return getTransactionStatus() == Status.STATUS_ACTIVE ||
                    getTransactionStatus() == Status.STATUS_PREPARING ||
                    getTransactionStatus() == Status.STATUS_PREPARED;
        protected int getTransactionStatus() throws SystemException
    private static final String WINDOW_ID_REQUEST_MAP_KEY =
            ClientWindow.class.getName()  ".WindowId";
        ExternalContext externalContext = facesContext.getExternalContext();
        Map<String, Object> requestMap = externalContext.getRequestMap();
        
        // try to lookup from cache
        String windowId = (String) requestMap.get(WINDOW_ID_REQUEST_MAP_KEY);
        if (windowId != null)
        {
            return windowId;
        }
        
            windowId = DEFAULT_WINDOW_ID;
        else if (ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))
            windowId = ClientWindowAdapter.getWindowIdFromJsf(facesContext);
        else if (ClientWindowRenderMode.LAZY.equals(clientWindowRenderMode))
            windowId = ClientWindowHelper.getInitialRedirectWindowId(facesContext);
                    windowId = null;
                    windowId = generateNewWindowId();
        else if (ClientWindowRenderMode.CLIENTWINDOW.equals(clientWindowRenderMode))
            if (facesContext.isPostback())
            {
                windowId = getPostBackWindowId(facesContext);
            }
            else if (isNoscriptRequest(externalContext))
            {
                // the client has JavaScript disabled
                clientWindowConfig.setJavaScriptEnabled(false);
                windowId = DEFAULT_WINDOW_ID;
            }
            else
            {
                windowId = getVerifiedWindowIdFromCookie(externalContext);
                boolean newWindowIdRequested = false;
                if (AUTOMATED_ENTRY_POINT_PARAMETER_KEY.equals(windowId))
                {
                    // this is a marker for generating a new windowId
                    windowId = generateNewWindowId();
                    newWindowIdRequested = true;
                }
                if (windowId == null || newWindowIdRequested)
                {
                    // GET request without windowId - send windowhandlerfilter.html to get the windowId
                    sendWindowHandlerHtml(externalContext, windowId);
                    facesContext.responseComplete();
                }
            }
        if (windowId != null)
        {
            requestMap.put(WINDOW_ID_REQUEST_MAP_KEY, windowId);
        }
        
import java.io.IOException;
import javax.faces.FacesException;
        // #sendRedirect will append the windowId (from ClientWindow#getWindowId again) to the redirectUrl
        String url = externalContext.getRequestScheme()
                 "://"  externalContext.getRequestServerName()
                 ":"  externalContext.getRequestServerPort()
                 externalContext.getRequestContextPath()
                 externalContext.getRequestServletPath();
 
        url = JsfUtils.addRequestParameters(externalContext, url, true);
        
        try
        {
            externalContext.redirect(url);
        }
        catch (IOException e)
        {
            throw new FacesException("Could not send initial redirect!", e);
        }
        if (externalContext.getRequestParameterValuesMap().isEmpty())
        {
            return url;
        }
        
        else
        {
            //don't refactor it - currently we need the lazy wrapping due to special jsf2 constellations
            getWrappedNavigationHandler().handleNavigation(context, fromAction, outcome);
        }

            throw new IllegalStateException("Cannot find an EntityManager qualified with ["  emQualifier.getName()
                     "]. Did you add a corresponding producer?");

        if (externalContext.getRequestPathInfo() != null)
        {
            url = externalContext.getRequestPathInfo();
        }
        
                String named = factory.extract(namedQuery);
        return factory.extract(query);
    public String extractFrom(Object query)
    public String extractFrom(Object query)
    public String extractFrom(Object query)
    String extractFrom(Object query);
    private final QueryStringExtractor[] extractors = new QueryStringExtractor[]
        new HibernateQueryStringExtractor(),
        new EclipseLinkEjbQueryStringExtractor(),
        new OpenJpaQueryStringExtractor()
    };

    public String extract(final Query query)
    {
        for (final QueryStringExtractor extractor : extractors)
            final String compare = extractor.getClass().getAnnotation(ProviderSpecific.class).value();
            final Object implQuery = toImplQuery(compare, query);
            if (implQuery != null)
                return extractor.extractFrom(implQuery);
    private static Object toImplQuery(final String clazzName, final Query query)
            try
            {
                // throw a persistence exception if not possible
                return query.unwrap(toClass);
            }
            catch (Exception e)
            {
                toClass.cast(query);
                return query;
            }
            return null;
            validateViewMetaData(view, viewConfigNode);

        protected void validateViewMetaData(View view, ViewConfigNode viewConfigNode)
        {
            String basePath = view.basePath();
            if (viewConfigNode.getSource().isInterface() && !"".equals(basePath) && basePath != null)
            {
                throw new IllegalStateException("Using @"  View.class.getName()  "#basePath isn't allowed on" 
                    " folder-nodes (= interfaces). Use @"  Folder.class.getName()  " for intended folder-nodes" 
                    " or a class instead of the interface for page-nodes.");
            }
        }

import org.apache.deltaspike.jsf.api.config.view.Folder;
    private static final Logger LOGGER = Logger.getLogger(ViewConfigPathValidator.class.getName());

                    if (configDescriptor instanceof DefaultFolderConfigDescriptor &&
                        !configDescriptor.getConfigClass().isAnnotationPresent(Folder.class))
                    {

                        LOGGER.fine(configDescriptor.getConfigClass().getName()  " looks like a marker interface" 
                            " only used for providing meta-data, because the path "  configDescriptor.getPath() 
                            " doesn't exist and the config-class isn't annotated with "  Folder.class.getName());

                        continue;
                    }

import org.apache.deltaspike.core.util.ProxyUtils;
        Class targetClass = ProxyUtils.getUnproxiedClass(invocationContext.getTarget().getClass()); //see DELTASPIKE-517

                    transactionalAnnotation, targetClass);
import org.apache.deltaspike.core.util.ProxyUtils;
            Class targetClass = ProxyUtils.getUnproxiedClass(context.getTarget().getClass()); //see DELTASPIKE-517

            transactionalAnnotation = extractTransactionalAnnotation(targetClass.getAnnotations());
import org.apache.deltaspike.core.util.ProxyUtils;
        Class targetClass = ProxyUtils.getUnproxiedClass(invocationContext.getTarget().getClass()); //see DELTASPIKE-517

        for (Authorizer authorizer : metaDataStorage.getAuthorizers(targetClass, method))
        for (Authorizer authorizer : metaDataStorage.getAuthorizers(targetClass, method))
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.lang.annotation.Annotation;
import javax.enterprise.inject.Default;
    /**
     * Defines the {@link javax.enterprise.Qualifier} which will be used to fire the
     * {@link org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent}
     * for unhandled JSF exceptions.
     * 
     * @return the {@link javax.enterprise.Qualifier}.
     */
    public Class<? extends Annotation> getExceptionQualifier()
    {
        return Default.class;
    }

import java.lang.annotation.Annotation;
    private final Annotation exceptionQualifier;
        this.exceptionQualifier = AnnotationInstanceProvider.of(
                BeanProvider.getContextualReference(JsfModuleConfig.class).getExceptionQualifier());
                    ExceptionToCatchEvent event = new ExceptionToCatchEvent(rootCause, exceptionQualifier);
import org.apache.deltaspike.jsf.impl.security.SecurityAwareViewHandler;
import javax.faces.context.FacesContext;
import javax.faces.event.PreDestroyViewMapEvent;
import javax.faces.event.SystemEvent;
    private final boolean preDestroyViewMapEventFilterMode;
    public InjectionAwareApplicationWrapper(
        Application wrapped, JsfModuleConfig jsfModuleConfig, boolean preDestroyViewMapEventFilterMode)
        this.preDestroyViewMapEventFilterMode = preDestroyViewMapEventFilterMode;
    public void publishEvent(FacesContext facesContext, Class<? extends SystemEvent> systemEventClass, Object source)
    {
        if (!PreDestroyViewMapEvent.class.isAssignableFrom(systemEventClass) ||
                isPreDestroyViewMapEventAllowed(facesContext))
        {
            super.publishEvent(facesContext, systemEventClass, source);
        }
    }

    private boolean isPreDestroyViewMapEventAllowed(FacesContext facesContext)
    {
        return !this.preDestroyViewMapEventFilterMode ||
                    !Boolean.TRUE.equals(facesContext.getExternalContext().getRequestMap().get(
                            SecurityAwareViewHandler.PRE_DESTROY_VIEW_MAP_EVENT_FILTER_ENABLED));
    }

    @Override

import org.apache.deltaspike.jsf.impl.security.SecurityAwareViewHandler;
    private boolean preDestroyViewMapEventFilterMode;

        if (this.initialized == null)
            this.jsfModuleConfig = BeanProvider.getContextualReference(JsfModuleConfig.class);


            this.preDestroyViewMapEventFilterMode = ClassDeactivationUtils.isActivated(SecurityAwareViewHandler.class);
            this.initialized = true;
        lazyInit();
        return new InjectionAwareApplicationWrapper(
            this.wrappedFacesContext.getApplication(), this.jsfModuleConfig, this.preDestroyViewMapEventFilterMode);
import java.util.HashMap;
import java.util.Map;
    public  static final String PRE_DESTROY_VIEW_MAP_EVENT_FILTER_ENABLED =
            SecurityAwareViewHandler.class.getName()  "#PRE_DESTROY_VIEW_MAP_EVENT_FILTER_ENABLED";

        Map<String, Object> viewMap = null;
        if (originalViewRoot != null)
        {
            Map<String, Object> originalViewMap = originalViewRoot.getViewMap(false);

            if (originalViewMap != null && !originalViewMap.isEmpty())
            {
                viewMap = new HashMap<String, Object>();
                viewMap.putAll(originalViewMap);
            }
        }

        //workaround for PreDestroyViewMapEvent which would be caused by the security check
        deactivatePreDestroyViewMapEvent(context);

            activatePreDestroyViewMapEvent(context);
                if (viewMap != null)
                {
                    originalViewRoot.getViewMap().putAll(viewMap);
                }

    private void deactivatePreDestroyViewMapEvent(FacesContext facesContext)
    {
        facesContext.getExternalContext().getRequestMap().put(PRE_DESTROY_VIEW_MAP_EVENT_FILTER_ENABLED, Boolean.TRUE);
    }

    private void activatePreDestroyViewMapEvent(FacesContext facesContext)
    {
        facesContext.getExternalContext().getRequestMap().put(PRE_DESTROY_VIEW_MAP_EVENT_FILTER_ENABLED, Boolean.FALSE);
    }
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/lifecycle/Destroyed.java
package org.apache.deltaspike.core.api.lifecycle;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/lifecycle/Initialized.java
package org.apache.deltaspike.core.api.lifecycle;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/literal/DestroyedLiteral.java
package org.apache.deltaspike.core.api.literal;
import org.apache.deltaspike.core.api.lifecycle.Destroyed;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/literal/InitializedLiteral.java
package org.apache.deltaspike.core.api.literal;
import org.apache.deltaspike.core.api.lifecycle.Initialized;
import org.apache.deltaspike.core.api.lifecycle.Initialized;
import org.apache.deltaspike.core.api.lifecycle.Initialized;

    private JsfRequestBroadcaster jsfRequestBroadcaster;
     * Broadcasts the {@link org.apache.deltaspike.core.api.lifecycle.Destroyed} event
            broadcastDestroyedJsfRequestEvent();
    private void broadcastDestroyedJsfRequestEvent()
        if (this.jsfRequestBroadcaster != null)
            this.jsfRequestBroadcaster.broadcastDestroyedJsfRequestEvent(this);
            if (ClassDeactivationUtils.isActivated(JsfRequestBroadcaster.class))
                this.jsfRequestBroadcaster =
                        BeanProvider.getContextualReference(JsfRequestBroadcaster.class, true);
    private JsfRequestBroadcaster jsfRequestBroadcaster;
     * {@link org.apache.deltaspike.core.api.lifecycle.Initialized} and
     * {@link org.apache.deltaspike.core.api.lifecycle.Destroyed}
        broadcastInitializedJsfRequestEvent(facesContext);
    private void broadcastInitializedJsfRequestEvent(FacesContext facesContext)
        if (this.jsfRequestBroadcaster != null)
            this.jsfRequestBroadcaster.broadcastInitializedJsfRequestEvent(facesContext);
        if (this.initialized == null)
            if (ClassDeactivationUtils.isActivated(JsfRequestBroadcaster.class))
                this.jsfRequestBroadcaster =
                        BeanProvider.getContextualReference(JsfRequestBroadcaster.class, true);
            this.initialized = true;
import org.apache.deltaspike.core.api.literal.DestroyedLiteral;
import org.apache.deltaspike.core.api.literal.InitializedLiteral;
import org.apache.deltaspike.core.api.literal.DestroyedLiteral;
import org.apache.deltaspike.core.api.literal.InitializedLiteral;
import org.apache.deltaspike.core.api.literal.DestroyedLiteral;
import org.apache.deltaspike.core.api.literal.InitializedLiteral;
import org.apache.deltaspike.core.api.lifecycle.Destroyed;
import org.apache.deltaspike.core.api.lifecycle.Initialized;
import org.apache.deltaspike.core.api.lifecycle.Destroyed;
import org.apache.deltaspike.core.api.lifecycle.Initialized;
import org.apache.deltaspike.core.api.lifecycle.Destroyed;
import org.apache.deltaspike.core.api.lifecycle.Initialized;
import java.beans.Introspector;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Set;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.spi.PassivationCapable;
import javax.inject.Named;
import org.apache.deltaspike.core.api.literal.AnyLiteral;
import org.apache.deltaspike.core.util.bean.ImmutableBeanWrapper;
import org.apache.deltaspike.core.util.bean.ImmutablePassivationCapableBeanWrapper;
    private Bean<Object> namedBundleProducerBean;
    private NamedTypedMessageBundle namedTypedMessageBundle = new NamedTypedMessageBundleLiteral();
    private boolean elSupportEnabled;
        elSupportEnabled = ClassDeactivationUtils.isActivated(NamedMessageBundleInvocationHandler.class);
        else if (method.isAnnotationPresent(NamedTypedMessageBundle.class))
        {
            namedBundleProducerBean = (Bean<Object>)bean;
        }

            if (this.elSupportEnabled)
            {
                Bean<?> namedBean = createNamedMessageBundleBean(namedBundleProducerBean, type, beanManager);
                if (namedBean.getName() != null)
                {
                    abd.addBean(namedBean);
                }
            }

        if (this.elSupportEnabled)
        {
            /*see namedBundleProducerBean - a producer without injection-point is needed*/
            beanBuilder.name(null);
        }
    private <T> Bean<T> createNamedMessageBundleBean(Bean<Object> delegate,
                                                     AnnotatedType<T> annotatedType,
                                                     BeanManager beanManager)
    {
        WrappingBeanBuilder<T> beanBuilder = new WrappingBeanBuilder<T>(delegate, beanManager) {
            @Override
            public ImmutableBeanWrapper<T> create()
            {
                final ImmutableBeanWrapper<T> result = super.create();

                String beanName = createBeanName(result.getTypes());

                Set<Annotation> qualifiers = new HashSet<Annotation>();
                qualifiers.add(new AnyLiteral());
                qualifiers.add(namedTypedMessageBundle);

                if (isPassivationCapable())
                {
                    return new ImmutablePassivationCapableBeanWrapper<T>(result,
                            beanName, qualifiers, result.getScope(),
                            result.getStereotypes(), result.getTypes(), result.isAlternative(),
                            result.isNullable(), result.toString(), ((PassivationCapable)result).getId()) {
                        @Override
                        public T create(CreationalContext<T> creationalContext)
                        {
                            MessageBundleContext.setBean(result);

                            try
                            {
                                return super.create(creationalContext);
                            }
                            finally
                            {
                                MessageBundleContext.reset();
                            }
                        }
                    };
                }
                else
                {
                    return new ImmutableBeanWrapper<T>(result,
                            beanName, qualifiers, result.getScope(),
                            result.getStereotypes(), result.getTypes(), result.isAlternative(),
                            result.isNullable(), result.toString()) {
                        @Override
                        public T create(CreationalContext<T> creationalContext)
                        {
                            MessageBundleContext.setBean(result);
                            try
                            {
                                return super.create(creationalContext);
                            }
                            finally
                            {
                                MessageBundleContext.reset();
                            }
                        }
                    };
                }
            }

            private String createBeanName(Set<Type> types)
            {
                for (Object type : types)
                {
                    if (type instanceof Class)
                    {
                        Named namedAnnotation = ((Class<?>) type).getAnnotation(Named.class);

                        if (namedAnnotation == null)
                        {
                            continue;
                        }

                        String result = namedAnnotation.value();
                        if (!"".equals(result))
                        {
                            return result;
                        }
                        return Introspector.decapitalize(((Class<?>) type).getSimpleName());
                    }
                }
                return null;
            }
        };
        beanBuilder.readFromType(annotatedType);

        //X TODO re-visit type.getBaseType() in combination with #addQualifier
        beanBuilder.types(annotatedType.getJavaClass(), Object.class, Serializable.class);
        beanBuilder.passivationCapable(true);
        beanBuilder.id("NamedMessageBundleBean#"  annotatedType.getJavaClass().getName());

        return beanBuilder.create();
    }


import javax.enterprise.inject.Typed;
@Typed(MessageBundleInvocationHandler.class)
    private static final long serialVersionUID = -8980912335543392357L;

import javax.enterprise.inject.spi.Bean;
    private static final String JAVA_PACKAGE = "java.";
    @Produces
    @Dependent
    @NamedTypedMessageBundle
    @SuppressWarnings("UnusedDeclaration")
    Object produceTypedMessageBundle(NamedMessageBundleInvocationHandler handler)
    {
        Bean currentMessageBundleContextBean = MessageBundleContext.getCurrentMessageBundleBean();
        Class<?> type = extractCustomType(currentMessageBundleContextBean);
        handler.setTargetType(type);
        return createMessageBundleProxy(type, handler);
    }

    private Class<?> extractCustomType(Bean currentMessageBundleBean)
    {
        for (Object type : currentMessageBundleBean.getTypes())
        {
            if (type instanceof Class && !((Class)type).getName().startsWith(JAVA_PACKAGE))
            {
                return (Class)type;
            }
        }
        throw new IllegalStateException("no custom type found for bean: "  currentMessageBundleBean.toString());
    }

@Named
    String text();
    private volatile Boolean initialized;
    
    private Annotation exceptionQualifier;
            init();
            
    
    private synchronized void init()
    {
        if (this.initialized == null)
        {
            this.exceptionQualifier = AnnotationInstanceProvider.of(
                    BeanProvider.getContextualReference(JsfModuleConfig.class).getExceptionQualifier());

            this.initialized = true;
        }
    }
            applicationContext.invalidate();

            //needed for weld < v1.1.9
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
    private static ThreadLocal<Boolean> preDestroyCalled = new ThreadLocal<Boolean>();

    @PostConstruct
    protected void onPostConstruct()
    {
        //reset it
        preDestroyCalled.remove();
        preDestroyCalled.set(false);
    }

    @PreDestroy
    protected void onPreDestroy()
    {
        preDestroyCalled.set(true);
    }

    public static boolean isPreDestroyCalled()
        return preDestroyCalled.get();
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
    private static ThreadLocal<Boolean> preDestroyCalled = new ThreadLocal<Boolean>();

    @PostConstruct
    protected void onPostConstruct()
    {
        //reset it
        preDestroyCalled.remove();
        preDestroyCalled.set(false);
    }

    @PreDestroy
    protected void onPreDestroy()
    {
        preDestroyCalled.set(true);
    }

    public static boolean isPreDestroyCalled()
        return preDestroyCalled.get();
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class DeltaSpikeContextExtension implements Extension, Deactivatable
    private Boolean isActivated = true;

    protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
    {
        isActivated = ClassDeactivationUtils.isActivated(getClass());
    }

        if (!isActivated)
        {
            return;
        }

        if (!isActivated)
        {
            return;
        }

import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class RepositoryExtension implements Extension, Deactivatable
    private Boolean isActivated = true;

        isActivated = ClassDeactivationUtils.isActivated(getClass());

        if (!isActivated)
        {
            return;
        }
        if (!isActivated)
        {
            return;
        }

        if (!isActivated)
        {
            return;
        }

import static org.apache.deltaspike.data.impl.util.ClassUtils.contains;
import static org.apache.deltaspike.data.impl.util.ClassUtils.extract;

    public Object getProxy()
    {
        return proxy;
    }

import org.apache.deltaspike.data.impl.meta.RequiresTransaction;
    @RequiresTransaction
    @RequiresTransaction
    @RequiresTransaction
    @RequiresTransaction
    @RequiresTransaction
    @RequiresTransaction
    @RequiresTransaction
import static org.apache.deltaspike.data.impl.util.ProxyUtils.extractFromProxy;

    @Inject
    private QueryRunner runner;

            Object result = runner.executeQuery(builder, queryContext);
import javax.persistence.LockModeType;
import org.apache.deltaspike.data.api.Modifying;
    public boolean requiresTransaction()
    {
        boolean hasLockMode = false;
        if (method.isAnnotationPresent(Query.class))
        {
            hasLockMode = !method.getAnnotation(Query.class).lock().equals(LockModeType.NONE);
        }
        return hasLockMode || method.isAnnotationPresent(Modifying.class);
    }

import static javax.persistence.LockModeType.PESSIMISTIC_READ;

import org.apache.deltaspike.data.api.Modifying;
import org.apache.deltaspike.data.api.Query;

    @Query(lock = PESSIMISTIC_READ)
    Simple findByName(String name);

    @Query(named = Simple.BY_NAME_LIKE)
    Simple findByNameNoLock(String name);

    @Modifying @Query("delete from Simple")
    int deleteAll();

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.enterprise.inject.Default;
import org.apache.deltaspike.core.api.literal.AnyLiteral;
import org.apache.deltaspike.core.util.ProxyUtils;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.impl.entitymanager.EntityManagerHolder;
import org.apache.deltaspike.jpa.impl.transaction.context.EntityManagerEntry;
import org.apache.deltaspike.jpa.impl.transaction.context.TransactionBeanStorage;
import org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy;
    @Inject
    private EntityManagerHolder emHolder;

    @Override
        Set<Class<? extends Annotation>> emQualifiers = emHolder.isSet() ?
                new HashSet<Class<? extends Annotation>>(Arrays.asList(Default.class)) :
                transactionHelper.resolveEntityManagerQualifiers(transactionalAnnotation, targetClass);
        if (emHolder.isSet())
        {
            return emHolder.get();
        }
            lazyInit();

    private void lazyInit()
    {
        if (this.initialized == null)
        {
            init();
        }
    }

import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessScopedBeanHistory;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessScopedBeanHolder;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessContext;
    private ViewAccessContext viewAccessScopedContext;
        viewAccessScopedContext = new ViewAccessContext(beanManager, windowContext);
        afterBeanDiscovery.addContext(viewAccessScopedContext);
        
        ViewAccessScopedBeanHolder viewAccessScopedBeanHolder =
            BeanProvider.getContextualReference(beanManager, ViewAccessScopedBeanHolder.class, false);
        ViewAccessScopedBeanHistory viewAccessScopedBeanHistory =
            BeanProvider.getContextualReference(beanManager, ViewAccessScopedBeanHistory.class, false);
        viewAccessScopedContext.init(viewAccessScopedBeanHolder, windowIdHolder, viewAccessScopedBeanHistory);
    
    public ViewAccessContext getViewAccessScopedContext()
    {
        return viewAccessScopedContext;
    }
import org.apache.deltaspike.core.impl.scope.DeltaSpikeContextExtension;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessContext;
    private DeltaSpikeContextExtension contextExtension;
        
        if (!facesContext.isPostback() && facesContext.getViewRoot() != null)
        {
            ViewAccessContext viewAccessContext = contextExtension.getViewAccessScopedContext();
            if (viewAccessContext != null)
            {
                viewAccessContext.onRenderingFinished(facesContext.getViewRoot().getViewId());
            }
        }
            contextExtension = BeanProvider.getContextualReference(DeltaSpikeContextExtension.class, true);
            
            viewAccessScopedBeanHistory.getAccessedBeans().clear();
                if (!viewAccessScopedBeanHistory.getAccessedBeans().contains((String) storageEntry.getKey()))
        if (facesContext.getViewRoot() != null)
import java.util.ArrayList;
import java.util.List;
            List<String> lastAccessedBeans = viewAccessScopedBeanHistory.getLastAccessedBeans();
            lastAccessedBeans.clear();
            
            // move used beans from this request to last request
            viewAccessScopedBeanHistory.setLastAccessedBeans(viewAccessScopedBeanHistory.getAccessedBeans());
            viewAccessScopedBeanHistory.setAccessedBeans(lastAccessedBeans);
        List<String> usedBeans = new ArrayList<String>();
        usedBeans.addAll(viewAccessScopedBeanHistory.getAccessedBeans());
        usedBeans.addAll(viewAccessScopedBeanHistory.getLastAccessedBeans());

                if (!usedBeans.contains((String) storageEntry.getKey()))
    private List<String> lastAccessedBeans;
        lastAccessedBeans = new ArrayList<String>();
    public List<String> getLastAccessedBeans()
    {
        return lastAccessedBeans;
    }

    public void setLastAccessedBeans(List<String> lastAccessedBeans)
    {
        this.lastAccessedBeans = lastAccessedBeans;
    }

        if (!facesContext.isPostback() && facesContext.getViewRoot() != null)
package org.apache.deltaspike.jsf.impl.listener.request;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.spi.scope.window.WindowContext;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
import javax.faces.context.FacesContext;
import javax.faces.event.PhaseListener;
import javax.faces.lifecycle.Lifecycle;
import org.apache.deltaspike.core.impl.scope.DeltaSpikeContextExtension;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessContext;
class DeltaSpikeLifecycleWrapper extends Lifecycle
    private final Lifecycle wrapped;
    private JsfRequestBroadcaster jsfRequestBroadcaster;
    private ClientWindow clientWindow;
    private WindowContext windowContext;
    private DeltaSpikeContextExtension contextExtension;

    private volatile Boolean initialized;

    DeltaSpikeLifecycleWrapper(Lifecycle wrapped)
        this.wrapped = wrapped;
    }

    Lifecycle getWrapped()
    {
        return wrapped;
    }

    @Override
    public void addPhaseListener(PhaseListener phaseListener)
    {
        this.wrapped.addPhaseListener(phaseListener);
     * Broadcasts
     * {@link org.apache.deltaspike.core.api.lifecycle.Initialized} and
     * {@link org.apache.deltaspike.core.api.lifecycle.Destroyed}
     * //TODO StartupEvent
    @Override
    public void execute(FacesContext facesContext)
        //can happen due to the window-handling of deltaspike
        if (facesContext.getResponseComplete())
        lazyInit();
        //TODO broadcastApplicationStartupBroadcaster();
        broadcastInitializedJsfRequestEvent(facesContext);
        // ClientWindow handling
        String windowId = clientWindow.getWindowId(facesContext);
        if (windowId != null)
            windowContext.activateWindow(windowId);
        if (!FacesContext.getCurrentInstance().getResponseComplete())
        {
            this.wrapped.execute(facesContext);
        }
    @Override
    public PhaseListener[] getPhaseListeners()
        return this.wrapped.getPhaseListeners();
    }

    @Override
    public void removePhaseListener(PhaseListener phaseListener)
    {
        this.wrapped.removePhaseListener(phaseListener);
     * Performs cleanup tasks after the rendering process
    @Override
    public void render(FacesContext facesContext)
        this.wrapped.render(facesContext);
        
        if (facesContext.getViewRoot() != null)
            ViewAccessContext viewAccessContext = contextExtension.getViewAccessScopedContext();
            if (viewAccessContext != null)
            {
                viewAccessContext.onRenderingFinished(facesContext.getViewRoot().getViewId());
            }
    private void broadcastInitializedJsfRequestEvent(FacesContext facesContext)
        if (this.jsfRequestBroadcaster != null)
            this.jsfRequestBroadcaster.broadcastInitializedJsfRequestEvent(facesContext);
    }
    private void lazyInit()
    {
        if (this.initialized == null)
        {
            init();
        }
    }

    private synchronized void init()
    {
        // switch into paranoia mode
        if (this.initialized == null)
        {
            if (ClassDeactivationUtils.isActivated(JsfRequestBroadcaster.class))
            {
                this.jsfRequestBroadcaster =
                        BeanProvider.getContextualReference(JsfRequestBroadcaster.class, true);
            }

            clientWindow = BeanProvider.getContextualReference(ClientWindow.class, true);
            windowContext = BeanProvider.getContextualReference(WindowContext.class, true);
            contextExtension = BeanProvider.getContextualReference(DeltaSpikeContextExtension.class, true);
            
            this.initialized = true;
        }
            viewAccessScopedBeanHistory.getAccessedBeans().clear();
                if (!viewAccessScopedBeanHistory.getAccessedBeans().contains((String) storageEntry.getKey()))
package org.apache.deltaspike.core.util;
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.spi.activation.ClassDeactivator;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import javax.enterprise.inject.Typed;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;
/**
 * Helper methods for {@link ClassDeactivator}
 */
@Typed()
public abstract class ClassDeactivationUtils
    private static final Logger LOG = Logger.getLogger(ClassDeactivationUtils.class.getName());
    /**
     * This Map holds the ClassLoader as first level to make it possible to have different configurations per 
     * WebApplication in an EAR or other Multi-ClassLoader scenario.
     * 
     * The Map then contains a List of {@link ClassDeactivator}s in order of their configured ordinal.
     */
    private static Map<ClassLoader, List<ClassDeactivator>> classDeactivatorMap
        = new ConcurrentHashMap<ClassLoader, List<ClassDeactivator>>();
    /**
     * Cache for the result. It won't contain many classes but it might be accessed frequently.
     * Valid entries are only true or false. If an entry isn't available or null, it gets calculated.
     */
    private static Map<Class<? extends Deactivatable>, Boolean> activationStatusCache
        = new ConcurrentHashMap<Class<? extends Deactivatable>, Boolean>();
    
    private ClassDeactivationUtils()
        // prevent instantiation
     * Evaluates if the given {@link Deactivatable} is active.
     *
     * @param targetClass {@link Deactivatable} under test.
     * @return <code>true</code> if it is active, <code>false</code> otherwise
    public static boolean isActivated(Class<? extends Deactivatable> targetClass)
        Boolean activatedClassCacheEntry = activationStatusCache.get(targetClass);

        if (activatedClassCacheEntry == null)
        {
            initDeactivatableCacheFor(targetClass);
            activatedClassCacheEntry = activationStatusCache.get(targetClass);
        }
        return activatedClassCacheEntry;
    }

    private static synchronized void initDeactivatableCacheFor(Class<? extends Deactivatable> targetClass)
    {
        Boolean activatedClassCacheEntry = activationStatusCache.get(targetClass);

        if (activatedClassCacheEntry != null) //double-check
        List<ClassDeactivator> classDeactivators = getClassDeactivators();
        Boolean isActivated = Boolean.TRUE;
        Class<? extends ClassDeactivator> deactivatedBy = null;
        LOG.fine("start evaluation if "  targetClass.getName()  " is de-/activated");

        // we get the classActivators ordered by it's ordinal
        // thus the last one which returns != null 'wins' ;)
        for (ClassDeactivator classDeactivator : classDeactivators)
            Boolean isLocallyActivated = classDeactivator.isActivated(targetClass);

            if (isLocallyActivated != null)
            {
                isActivated = isLocallyActivated;

                /*
                * Check and log the details across class-deactivators
                */
                if (!isActivated)
                {
                    deactivatedBy = classDeactivator.getClass();
                    LOG.fine("Deactivating class "  targetClass);
                }
                else if (deactivatedBy != null)
                {
                    LOG.fine("Reactivation of: "  targetClass.getName()  " by " 
                            classDeactivator.getClass().getName() 
                            " - original deactivated by: "  deactivatedBy.getName()  ".\n" 
                            "If that isn't the intended behaviour, you have to use a higher ordinal for " 
                            deactivatedBy.getName());
                }
            }
        cacheResult(targetClass, isActivated);
    private static void cacheResult(Class<? extends Deactivatable> targetClass, Boolean activated)
        activationStatusCache.put(targetClass, activated);
        LOG.info("class: "  targetClass.getName()  " activated="  activated);
     * @return the List of configured @{link ClassDeactivator}s for the current context ClassLoader.
    private static List<ClassDeactivator> getClassDeactivators()
        ClassLoader classLoader = ClassUtils.getClassLoader(null);
        List<ClassDeactivator> classDeactivators = classDeactivatorMap.get(classLoader);

        if (classDeactivators == null)
            return initConfiguredClassDeactivators(classLoader);
        }

        return classDeactivators;
    }

    //synchronized isn't needed - #initDeactivatableCacheFor is already synchronized
    private static List<ClassDeactivator> initConfiguredClassDeactivators(ClassLoader classLoader)
    {
        List<String> classDeactivatorClassNames = ConfigResolver.getAllPropertyValues(ClassDeactivator.class.getName());

        List<ClassDeactivator> classDeactivators = new ArrayList<ClassDeactivator>();

        for (String classDeactivatorClassName : classDeactivatorClassNames)
        {
            LOG.fine("processing ClassDeactivator: "  classDeactivatorClassName);

            try
                ClassDeactivator currentClassDeactivator =
                        (ClassDeactivator) ClassUtils.instantiateClassForName(classDeactivatorClassName);
                classDeactivators.add(currentClassDeactivator);
            }
            catch (Exception e)
            {
                LOG.warning(classDeactivatorClassName  " can't be instantiated");
                throw new IllegalStateException(e);
        classDeactivatorMap.put(classLoader, classDeactivators);
        return classDeactivators;
        if (facesContext.getViewRoot() != null)
        try
        {
            return super.get(bean);
        }
        finally
        {
            if (bean instanceof PassivationCapable)
            {
                PassivationCapable pc = (PassivationCapable) bean;
                viewAccessScopedBeanHistory.getAccessedBeans().add(pc.getId());
            }
        }
        try
        {
            return super.get(bean, creationalContext);
        }
        finally
        {
            if (bean instanceof PassivationCapable)
            {
                PassivationCapable pc = (PassivationCapable) bean;
                viewAccessScopedBeanHistory.getAccessedBeans().add(pc.getId());
            }
        }
        // destroy beans only if the view has been changed
        
        // clear history after each rendering process
        viewAccessScopedBeanHistory.getAccessedBeans().clear();
    private List<String> accessedBeans = new ArrayList<String>();
 b/deltaspike/examples/jsf-playground/src/main/java/org/apache/deltaspike/playground/PlaygroundClientWindowConfig.java
package org.apache.deltaspike.playground;
 b/deltaspike/examples/jsf-playground/src/main/java/org/apache/deltaspike/playground/PlaygroundJsfModuleConfig.java
package org.apache.deltaspike.playground;
import org.apache.deltaspike.playground.exception.Jsf;
 b/deltaspike/examples/jsf-playground/src/main/java/org/apache/deltaspike/playground/exception/Jsf.java
package org.apache.deltaspike.playground.exception;
        if (facesContext.getViewRoot() != null && facesContext.getViewRoot().getViewId() != null)
 b/deltaspike/modules/jsf/impl/src/test/java/org/apache/deltaspike/test/jsf/impl/scope/viewaccess/beans/ViewAccessScopedBeanX.java
package org.apache.deltaspike.test.jsf.impl.scope.viewaccess.beans;
import java.io.Serializable;
import org.apache.deltaspike.core.api.scope.ViewAccessScoped;
@ViewAccessScoped
public class ViewAccessScopedBeanX implements Serializable
    private String value;

    public String getValue()
        return value;
    }

    public void setValue(String value)
    {
        this.value = value;
 b/deltaspike/modules/jsf/impl/src/test/java/org/apache/deltaspike/test/jsf/impl/scope/viewaccess/beans/ViewAccessScopedBeanY.java
package org.apache.deltaspike.test.jsf.impl.scope.viewaccess.beans;
import java.io.Serializable;
import org.apache.deltaspike.core.api.scope.ViewAccessScoped;
@ViewAccessScoped
public class ViewAccessScopedBeanY implements Serializable
    private String value;

    public String getValue()
        return value;
    }

    public void setValue(String value)
    {
        this.value = value;
        viewAccessScopedContext.init(viewAccessScopedBeanHolder, viewAccessScopedBeanHistory);
    private static final String KEY = "VAS"; //TODO re-visit key (e.g. view-id instead of using one big storage)

    public void init(ViewAccessScopedBeanHolder viewAccessScopedBeanHolder,
        return this.viewAccessScopedBeanHolder.getContextualStorage(this.beanManager, KEY, createIfNotExist);
        ContextualStorage storage = viewAccessScopedBeanHolder.getContextualStorage(beanManager, KEY, false);
    public void onProcessingViewFinished(String view)
                viewAccessContext.onProcessingViewFinished(facesContext.getViewRoot().getViewId());
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.impl.scope.DeltaSpikeContextExtension;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessContext;
    private volatile Boolean initialized;
    
    private DeltaSpikeContextExtension contextExtension;
    
        lazyInit();
        
        if (context.getViewRoot() != null && context.getViewRoot().getViewId() != null)
        {
            ViewAccessContext viewAccessContext = contextExtension.getViewAccessScopedContext();
            if (viewAccessContext != null)
            {
                viewAccessContext.onProcessingViewFinished(context.getViewRoot().getViewId());
            }
        }
        
    
    private void lazyInit()
    {
        if (this.initialized == null)
        {
            init();
        }
    }

    private synchronized void init()
    {
        // switch into paranoia mode
        if (this.initialized == null)
        {
            contextExtension = BeanProvider.getContextualReference(DeltaSpikeContextExtension.class, true);
            
            this.initialized = true;
        }
    }
import org.apache.deltaspike.jsf.impl.scope.viewaccess.ViewAccessScopedAwareNavigationHandler;
        return new ViewAccessScopedAwareNavigationHandler(viewConfigAwareNavigationHandler);
    private final boolean vasnhActivated;
        this.vasnhActivated = ClassDeactivationUtils.isActivated(ViewAccessScopedAwareNavigationHandler.class);
        NavigationHandler navigationHandler = new ViewConfigAwareNavigationHandler(this.wrapped);
        if (vasnhActivated)
        {
            navigationHandler = new ViewAccessScopedAwareNavigationHandler(navigationHandler);
        }

        return navigationHandler;
        if (context.getViewRoot() != null)
        if (viewId != null)
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessBeanAccessHistory;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessBeanHolder;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessViewHistory;
        ViewAccessBeanHolder viewAccessBeanHolder =
            BeanProvider.getContextualReference(beanManager, ViewAccessBeanHolder.class, false);
        ViewAccessBeanAccessHistory viewAccessBeanAccessHistory =
            BeanProvider.getContextualReference(beanManager, ViewAccessBeanAccessHistory.class, false);
        ViewAccessViewHistory viewAccessViewHistory =
            BeanProvider.getContextualReference(beanManager, ViewAccessViewHistory.class, false);
        viewAccessScopedContext.init(viewAccessBeanHolder, viewAccessBeanAccessHistory, viewAccessViewHistory);
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/scope/viewaccess/ViewAccessBeanAccessHistory.java
import java.util.ArrayList;
import java.util.List;
import javax.enterprise.context.RequestScoped;
@RequestScoped
public class ViewAccessBeanAccessHistory
{    
    private final List<String> accessedBeans = new ArrayList<String>();

    public List<String> getAccessedBeans()
    {
        return accessedBeans;
    }
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/scope/viewaccess/ViewAccessBeanHolder.java
public class ViewAccessBeanHolder extends AbstractBeanHolder<String>
    private ViewAccessBeanHolder viewAccessBeanHolder;
    private ViewAccessBeanAccessHistory viewAccessBeanAccessHistory;
    private ViewAccessViewHistory viewAccessViewHistory;
    public void init(ViewAccessBeanHolder viewAccessBeanHolder,
            ViewAccessBeanAccessHistory viewAccessBeanAccessHistory,
            ViewAccessViewHistory viewAccessViewHistory)
        this.viewAccessBeanHolder = viewAccessBeanHolder;
        this.viewAccessBeanAccessHistory = viewAccessBeanAccessHistory;
        this.viewAccessViewHistory = viewAccessViewHistory;
                viewAccessBeanAccessHistory.getAccessedBeans().add(pc.getId());
                viewAccessBeanAccessHistory.getAccessedBeans().add(pc.getId());
        return this.viewAccessBeanHolder.getContextualStorage(this.beanManager, KEY, createIfNotExist);
        if (!view.equals(viewAccessViewHistory.getLastView()))
            viewAccessViewHistory.setLastView(view);
        viewAccessBeanAccessHistory.getAccessedBeans().clear();
        ContextualStorage storage = viewAccessBeanHolder.getContextualStorage(beanManager, KEY, false);
                if (!viewAccessBeanAccessHistory.getAccessedBeans().contains((String) storageEntry.getKey()))
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/scope/viewaccess/ViewAccessViewHistory.java
public class ViewAccessViewHistory implements Serializable
    private static final long serialVersionUID = 8917607910721148527L;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceProvider;
    private final Class<? extends ExternalResourceProvider> resourceProvider;
    private final String location;

    public ExternalResourceLiteral(Class<? extends ExternalResourceProvider> resourceProvider, String location)
        this.resourceProvider = resourceProvider;

    public Class<? extends ExternalResourceProvider> resourceProvider()
        return this.resourceProvider;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resourceloader/BaseResourceProvider.java
package org.apache.deltaspike.core.api.resourceloader;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resourceloader/ClasspathResourceProvider.java
package org.apache.deltaspike.core.api.resourceloader;
    Class<? extends ExternalResourceProvider> resourceProvider() default ClasspathResourceProvider.class;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resourceloader/ExternalResourceProducer.java
package org.apache.deltaspike.core.api.resourceloader;
import org.apache.deltaspike.core.api.provider.BeanProvider;
    @ExternalResource(resourceProvider = ExternalResourceProvider.class,location = "")
        ExternalResourceProvider provider = BeanProvider.getContextualReference(externalResource.resourceProvider());
    @ExternalResource(resourceProvider = ExternalResourceProvider.class,location = "")
        ExternalResourceProvider provider = BeanProvider.getContextualReference(externalResource.resourceProvider());
    @ExternalResource(resourceProvider = ExternalResourceProvider.class,location = "")
        ExternalResourceProvider provider = BeanProvider.getContextualReference(externalResource.resourceProvider());
    public void closeInputStream(@Disposes
                                 @ExternalResource(resourceProvider = ExternalResourceProvider.class, location = "")
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resourceloader/ExternalResourceProvider.java
package org.apache.deltaspike.core.api.resourceloader;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resourceloader/FileResourceProvider.java
package org.apache.deltaspike.core.api.resourceloader;
import org.apache.deltaspike.core.api.resourceloader.ClasspathResourceProvider;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceProducer;
import org.apache.deltaspike.core.api.resourceloader.FileResourceProvider;

 b/deltaspike/modules/servlet/api/src/main/java/org/apache/deltaspike/servlet/api/resourceloader/WebResourceProvider.java
package org.apache.deltaspike.servlet.api.resourceloader;
import org.apache.deltaspike.core.api.resourceloader.BaseResourceProvider;
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/resourceloader/ExternalResourceProducer.java
package org.apache.deltaspike.core.impl.resourceloader;
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceProvider;
public interface EntityManagerHolder
    void set(EntityManager entityManager);
    boolean isSet();
    EntityManager get();
    void dispose();
import org.apache.deltaspike.jpa.spi.entitymanager.ActiveEntityManagerHolder;
    private ActiveEntityManagerHolder activeEntityManagerHolder;
                activeEntityManagerHolder.set(context.getEntityManager());
                activeEntityManagerHolder.dispose();
 b/deltaspike/modules/jpa/api/src/main/java/org/apache/deltaspike/jpa/spi/entitymanager/ActiveEntityManagerHolder.java
package org.apache.deltaspike.jpa.spi.entitymanager;
/**
 * Optional holder which allows to customize the handling of the {@link EntityManager}.
 * Multiple Entity-Managers with different qualifiers aren't supported.
 * See the data-module for further details.
 */
public interface ActiveEntityManagerHolder
import org.apache.deltaspike.jpa.spi.entitymanager.ActiveEntityManagerHolder;

public class DefaultEntityManagerHolder implements ActiveEntityManagerHolder
import org.apache.deltaspike.jpa.spi.entitymanager.ActiveEntityManagerHolder;
    private ActiveEntityManagerHolder emHolder;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/spi/exception/control/event/IntrospectiveExceptionEvent.java
package org.apache.deltaspike.core.spi.exception.control.event;
 * Internal view into the ExceptionEvent. Methods on this interface are used by the ExceptionHandlerBroadcaster.
import org.apache.deltaspike.core.spi.exception.control.event.IntrospectiveExceptionEvent;
 b/deltaspike/core/impl/src/main/java/org/apache/deltaspike/core/impl/exception/control/ExceptionHandlerBroadcaster.java
public class ExceptionHandlerBroadcaster
    private static final Logger LOG = Logger.getLogger(ExceptionHandlerBroadcaster.class.getName());
        LOG.entering(
            ExceptionHandlerBroadcaster.class.getName(), "executeHandlers", exceptionEventEvent.getException());
            LOG.exiting(ExceptionHandlerBroadcaster.class.getName(), "executeHandlers",
    
    private volatile Boolean initialized;
    
    private ClientWindow clientWindow;
        lazyInit();
        
    
    private void lazyInit()
    {
        if (this.initialized == null)
        {
            init();
        }
    }

    private synchronized void init()
    {
        // switch into paranoia mode
        if (this.initialized == null)
        {
            this.clientWindow = BeanProvider.getContextualReference(ClientWindow.class, true);
            
            this.initialized = true;
        }
    }
    private volatile Boolean initialized;
    
    private ViewHandler securityAwareViewHandler;
    private ClientWindow clientWindow;
        lazyInit();
        
        lazyInit();
        
    
    private void lazyInit()
    {
        if (this.initialized == null)
        {
            init();
        }
    }

    private synchronized void init()
    {
        // switch into paranoia mode
        if (this.initialized == null)
        {
            if (ClassDeactivationUtils.isActivated(getClass()))
            {
                this.securityAwareViewHandler = createSecurityAwareViewHandler();
                //TODO add ViewHandler for handling the WindowContext
            }
            else
            {
                this.securityAwareViewHandler = null;
            }

            this.clientWindow = BeanProvider.getContextualReference(ClientWindow.class, true);
            
            this.initialized = true;
        }
    }
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/literal/InjectableResourceLiteral.java
import org.apache.deltaspike.core.api.resourceloader.InjectableResource;
import org.apache.deltaspike.core.api.resourceloader.InjectableResourceProvider;
public class InjectableResourceLiteral extends AnnotationLiteral<InjectableResource> implements InjectableResource
    private final Class<? extends InjectableResourceProvider> resourceProvider;
    public InjectableResourceLiteral(Class<? extends InjectableResourceProvider> resourceProvider, String location)
    public Class<? extends InjectableResourceProvider> resourceProvider()
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resourceloader/AbstractResourceProvider.java
 * An abstract InjectableResourceProvider implementation with some basic utility functionality.
public abstract class AbstractResourceProvider implements InjectableResourceProvider
    private static final Logger logger = Logger.getLogger(AbstractResourceProvider.class.getName());
    public Properties readProperties(InjectableResource injectableResource)
        final String name = injectableResource.location();
        final InputStream inputStream = this.readStream(injectableResource);
    public List<InputStream> readStreams(InjectableResource injectableResource)
        return Collections.singletonList(this.readStream(injectableResource));
public class ClasspathResourceProvider extends AbstractResourceProvider
    public InputStream readStream(final InjectableResource injectableResource)
            List<InputStream> matchedStreams = this.readClassPath(injectableResource.location(),true);
    public List<InputStream> readStreams(InjectableResource injectableResource)
            return readClassPath(injectableResource.location(),false);
public class FileResourceProvider extends AbstractResourceProvider
    public InputStream readStream(InjectableResource injectableResource)
        return readFile(injectableResource.location());
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resourceloader/InjectableResource.java
public @interface InjectableResource
    Class<? extends InjectableResourceProvider> resourceProvider() default ClasspathResourceProvider.class;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/api/resourceloader/InjectableResourceProvider.java
public interface InjectableResourceProvider
    InputStream readStream(final InjectableResource injectableResource);
    List<InputStream> readStreams(final InjectableResource injectableResource);
    Properties readProperties(final InjectableResource injectableResource);
        beforeBeanDiscovery.addAnnotatedType(this.createAnnotatedType(InjectableResourceProducer.class,beanManager));
import org.apache.deltaspike.core.api.resourceloader.AbstractResourceProvider;
import org.apache.deltaspike.core.api.resourceloader.InjectableResource;
public class WebResourceProvider extends AbstractResourceProvider
    public InputStream readStream(InjectableResource injectableResource)
        String path = injectableResource.location();
import org.apache.deltaspike.core.api.common.DeltaSpike;
    @DeltaSpike
import org.apache.deltaspike.core.api.common.DeltaSpike;
    @DeltaSpike
    @DeltaSpike
    @DeltaSpike
    @DeltaSpike
    @DeltaSpike
    @DeltaSpike
    @DeltaSpike
import org.apache.deltaspike.core.api.common.DeltaSpike;
    @DeltaSpike
    @DeltaSpike
    @DeltaSpike
    @DeltaSpike
    @DeltaSpike
    @DeltaSpike
 * Utility class which is used to bind the {@link ServletRequest} and {@link ServletResponse} to the current thread.
 * 
 * @param <Type>
 *            {@link ServletRequest} or {@link ServletResponse}
class RequestResponseHolder<Type>
    /**
     * Instance for storing the {@link ServletRequest}
     */
    static final RequestResponseHolder<ServletRequest> REQUEST = new RequestResponseHolder<ServletRequest>();

    /**
     * Instance for storing the {@link ServletResponse}
     */
    static final RequestResponseHolder<ServletResponse> RESPONSE = new RequestResponseHolder<ServletResponse>();

    private final ThreadLocal<Type> threadLocal = new ThreadLocal<Type>();
        // hide constructor
     * Binds the request or response to the current thread.
     * @param instance
     *            The request/response
     *             if there is already an instance bound to the thread
    void bind(Type instance)
        if (isBound())
        {
            throw new IllegalStateException("There is already an instance bound to this thread.");
        }
        threadLocal.set(instance);
    }

    /**
     * Returns <code>true</code> if there is already an instance bound to the thread
     */
    boolean isBound()
    {
        return threadLocal.get() != null;
    }

    /**
     * Release the instance bound to the current thread
     */
    void release()
    {
        threadLocal.remove();
    }

    /**
     * Retrieve the request/response bound to the current thread.
     * 
     * @return instance bound to the thread
     * @throws IllegalStateException
     *             if there is no instance bound to the thread
     */
    Type get()
    {
        Type instance = threadLocal.get();
        if (instance == null)
        return instance;
        RequestResponseHolder.REQUEST.bind(request);
        RequestResponseHolder.RESPONSE.bind(response);
            RequestResponseHolder.REQUEST.release();
            RequestResponseHolder.RESPONSE.release();
        return RequestResponseHolder.REQUEST.get();
        ServletRequest request = RequestResponseHolder.REQUEST.get();
        return RequestResponseHolder.RESPONSE.get();
        ServletResponse response = RequestResponseHolder.RESPONSE.get();
        ServletRequest request = RequestResponseHolder.REQUEST.get();
        /*
         * Typically the request is bound to the thread in RequestResponseHolderListener. But as this listener was added
         * after the initial release of the Servlet module, the filter will also do it if necessary.
         */
        final boolean alreadyBound = RequestResponseHolder.REQUEST.isBound();
        if (!alreadyBound)
        {
            RequestResponseHolder.REQUEST.bind(request);
        }


            RequestResponseHolder.RESPONSE.bind(response);
            try
            {
                chain.doFilter(request, response);
            }
            finally
            {
                RequestResponseHolder.RESPONSE.release();
            }

            if (!alreadyBound)
            {
                RequestResponseHolder.REQUEST.release();
            }
     * If #initialStateMarked (of the component) returns false, a fallback to full state-saving is possible.
     * Therefore it's required to save additional meta-data even with partial state-saving.
     * @return false to restrict additional meta-data required for a possible fallback, true otherwise
     */
    public boolean isFullStateSavingFallbackEnabled()
    {
        return true;
    }

    /**
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;

    private transient Boolean fullStateSavingFallbackEnabled;
    protected AbstractContextualReferenceWrapper()
    {
    }

    protected AbstractContextualReferenceWrapper(T wrapped, boolean fullStateSavingFallbackEnabled)
        this.fullStateSavingFallbackEnabled = fullStateSavingFallbackEnabled;
            Object[] result = new Object[2];

            if (this.fullStateSavingFallbackEnabled == null)
            {
                this.fullStateSavingFallbackEnabled =
                    BeanProvider.getContextualReference(JsfModuleConfig.class).isFullStateSavingFallbackEnabled();
            }
            if (this.fullStateSavingFallbackEnabled)
            {
                result[0] = this.getWrapped().getClass().getName();
            }
            result[1] = ((StateHolder)wrapped).saveState(context);
            return result;
        Object[] wrappedState = (Object[]) state;

        if (this.wrapped == null) //fallback for full state-saving
        {
            //TODO check for @FacesConverter/@FacesValidator
            //-> delegate to javax.faces.application.Application ( unwrap it - since it will be wrapped again)
            this.wrapped = (T)ClassUtils.tryToInstantiateClassForName((String)wrappedState[0]);
        }
            ((StateHolder) this.wrapped).restoreState(context, wrappedState[1]);
    public ConverterWrapper()
    }

    public ConverterWrapper(Converter wrapped, boolean fullStateSavingFallbackEnabled)
    {
        super(wrapped, fullStateSavingFallbackEnabled);
    private final boolean fullStateSavingFallbackEnabled;
        this.fullStateSavingFallbackEnabled = jsfModuleConfig.isFullStateSavingFallbackEnabled();
            return new ConverterWrapper(result, this.fullStateSavingFallbackEnabled);
            return new ValidatorWrapper(result, this.fullStateSavingFallbackEnabled);
    public ValidatorWrapper()
    }

    public ValidatorWrapper(Validator wrapped, boolean fullStateSavingFallbackEnabled)
    {
        super(wrapped, fullStateSavingFallbackEnabled);
        if (this.fullStateSavingFallbackEnabled == null)
        {
            this.fullStateSavingFallbackEnabled =
                BeanProvider.getContextualReference(JsfModuleConfig.class).isFullStateSavingFallbackEnabled();
        }

        if (this.fullStateSavingFallbackEnabled)
        {
            Object[] result = new Object[1];
            result[0] = this.getWrapped().getClass().getName();

            return result;
        }
            Class wrappedClass = ClassUtils.tryToLoadClassForName((String)wrappedState[0]);

            T resolvedInstance = resolveInstanceForClass(context, wrappedClass);

            //TODO re-visit logic for multiple (custom) wrappers
            if (resolvedInstance instanceof AbstractContextualReferenceWrapper)
            {
                resolvedInstance = ((AbstractContextualReferenceWrapper<T>)resolvedInstance).getWrapped();
            }
            this.wrapped = resolvedInstance;

        if (this.wrapped == null)
        {
            this.wrapped = (T)ClassUtils.tryToInstantiateClassForName((String)wrappedState[0]);
            BeanProvider.injectFields(this.wrapped);
        }


    protected abstract T resolveInstanceForClass(FacesContext facesContext, Class<?> wrappedClass);
import javax.faces.convert.FacesConverter;

    @Override
    protected Converter resolveInstanceForClass(FacesContext facesContext, Class<?> wrappedClass)
    {
        FacesConverter facesConverter = wrappedClass.getAnnotation(FacesConverter.class);

        if (facesConverter == null)
        {
            return null;
        }

        if (!"".equals(facesConverter.value()))
        {
            return facesContext.getApplication().createConverter(facesConverter.value());
        }

        return facesContext.getApplication().createConverter(facesConverter.forClass());
    }
import javax.faces.validator.FacesValidator;

    @Override
    protected Validator resolveInstanceForClass(FacesContext facesContext, Class<?> wrappedClass)
    {
        FacesValidator facesValidator = wrappedClass.getAnnotation(FacesValidator.class);

        if (facesValidator == null)
        {
            return null;
        }

        return facesContext.getApplication().createValidator(facesValidator.value());
    }
    boolean overrideOnStartup() default false; //'true' triggers a re-schedule if the job exists already

import java.util.List;
import java.util.logging.Logger;
    protected org.quartz.Scheduler scheduler;
            JobDetail jobDetail = this.scheduler.getJobDetail(jobKey);
            Trigger trigger;
            if (jobDetail == null)
            {
                jobDetail = JobBuilder.newJob(jobClass)
                        .withDescription(description)
                        .withIdentity(jobKey)
                        .build();

                trigger = TriggerBuilder.newTrigger()
                        .withSchedule(CronScheduleBuilder.cronSchedule(scheduled.cronExpression()))
                        .build();

                this.scheduler.scheduleJob(jobDetail, trigger);
            }
            else if (scheduled.overrideOnStartup())
            {
                List<? extends Trigger> existingTriggers = this.scheduler.getTriggersOfJob(jobKey);

                if (existingTriggers == null || existingTriggers.isEmpty())
                {
                    //TODO re-visit it
                    trigger = TriggerBuilder.newTrigger()
                            .withSchedule(CronScheduleBuilder.cronSchedule(scheduled.cronExpression()))
                            .build();

                    this.scheduler.scheduleJob(jobDetail, trigger);
                    return;
                }

                if (existingTriggers.size() > 1)
                {
                    throw new IllegalStateException("multiple triggers found for "  jobKey  " ('"  jobDetail  "')" 
                        ", but aren't supported by @"  Scheduled.class.getName()  "#overrideOnStartup");
                }

                trigger = existingTriggers.iterator().next();

                trigger = TriggerBuilder.newTrigger()
                        .withIdentity(trigger.getKey())
                        .withSchedule(CronScheduleBuilder.cronSchedule(scheduled.cronExpression()))
                        .build();

                this.scheduler.rescheduleJob(trigger.getKey(), trigger);
            }
            else
            {
                Logger.getLogger(QuartzScheduler.class.getName()).info(jobKey  " exists already and will be ignored.");
            }
import javax.el.ELException;
    @Override
    public Throwable getRootCause(Throwable throwable)
    {
        while ((ELException.class.isInstance(throwable) || FacesException.class.isInstance(throwable))
                && throwable.getCause() != null)
        {
            throwable = throwable.getCause();
        }

        return throwable;
    }

        if (creationalContext == null)
        {
            return null;
        }
        
        if (currentClass == null || currentClass.getSuperclass() == null)
        {
            return false;
        }

            if (!this.activated)
            {
                return ((ConfigurableNavigationHandler)this.wrapped).getNavigationCase(context, action, outcome);
            }

        if (!this.activated)
        {
            return result;
        }


    <S> S unwrap(Class<? extends S> schedulerClass);

    @Override
    public <S> S unwrap(Class<? extends S> schedulerClass)
    {
        if (schedulerClass.isAssignableFrom(this.scheduler.getClass()))
        {
            return (S)this.scheduler;
        }

        throw new IllegalArgumentException(schedulerClass.getName() 
            " isn't compatible with "  this.scheduler.getClass().getName());
    }

    @Override
    public <S> S unwrap(Class<? extends S> schedulerClass)
    {
        if (schedulerClass.isAssignableFrom(TestJobManager.getInstance().getClass()))
        {
            return (S)TestJobManager.getInstance();
        }

        throw new IllegalArgumentException(schedulerClass.getName() 
            " isn't compatible with "  TestJobManager.getInstance().getClass().getName());
    }
    public void add(DependentBeanEntry dependentBeanEntry)
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import org.apache.deltaspike.core.util.ProxyUtils;
        Class phaseListenerClass;
            phaseListenerClass = ProxyUtils.getUnproxiedClass(currentPhaseListener.getClass());

            if (phaseListenerClass.isAnnotationPresent(JsfPhaseListener.class))
                if (Deactivatable.class.isAssignableFrom(phaseListenerClass) &&
                    !ClassDeactivationUtils.isActivated(phaseListenerClass))
                {
                    continue;
                }
import java.lang.annotation.Annotation;
import org.apache.deltaspike.core.util.metadata.AnnotationInstanceProvider;
import org.apache.deltaspike.jsf.impl.exception.control.BridgeExceptionHandlerWrapper;
    private boolean bridgeExceptionHandlerActivated;
    private Annotation bridgeExceptionQualifier;

        if (this.bridgeExceptionHandlerActivated)
        {
            exceptionHandler = new BridgeExceptionHandlerWrapper(exceptionHandler, this.bridgeExceptionQualifier);
        }
        

            
            this.bridgeExceptionHandlerActivated =
                    ClassDeactivationUtils.isActivated(BridgeExceptionHandlerWrapper.class);
            
            this.bridgeExceptionQualifier = AnnotationInstanceProvider.of(jsfModuleConfig.getExceptionQualifier());
        // ignore if WindowContext isn't active - our ViewAccessViewHistory is WindowScoped
        if (!windowContext.isActive())
        {
            return;
        }
        
    public boolean isAllowPostRequestWithoutDoubleSubmitPrevention()
    {
        return true;
    }

import javax.interceptor.InterceptorBinding;
@InterceptorBinding
    @InterceptorBinding
    private static final long serialVersionUID = -436742087379474804L;

    private int currentValue = -2;
            this.navigationParameterContext.addPageParameter("cv", this.currentValue);
import org.jboss.shrinkwrap.api.asset.Asset;
import org.jboss.shrinkwrap.api.asset.StringAsset;

    public static Asset getBeansXml()
    {
        Asset beansXml = new StringAsset(
            "<beans>" 
                "<interceptors>" 
                    "<class>org.apache.deltaspike.jsf.impl.config.view.navigation.NavigationParameterInterceptor</class>" 
                    "<class>org.apache.deltaspike.jsf.impl.config.view.navigation.NavigationParameterListInterceptor</class>" 
                "</interceptors>" 
            "</beans>"
        );

        return beansXml;
    }
    public static final String DELTASPIKE_WINDOW_ID_POST_PARAM = "dspwid";
    private static final String DELTASPIKE_REQUEST_TOKEN = "dsrid";
import org.apache.deltaspike.core.api.projectstage.ProjectStage;
import org.apache.deltaspike.core.util.ProjectStageProducer;
                && ProjectStageProducer.getInstance().getProjectStage() == ProjectStage.Development)
                && LIBRARY.equals(libraryName)
                && libraryName.equals(LIBRARY)
                && LIBRARY.equals(libraryName)
import org.apache.deltaspike.core.util.ClassUtils;
    private final String version;
        version = ClassUtils.getJarVersion(this.getClass());
        if (resource != null && libraryName != null && LIBRARY.equals(libraryName))
            if (ProjectStageProducer.getInstance().getProjectStage() == ProjectStage.Development)
            {
                resource = wrapped.createResource(resourceName, LIBRARY_UNCOMPRESSED);
            }
            
            resource = new DeltaSpikeResource(resource, version);
import java.lang.reflect.InvocationTargetException;
import javax.faces.event.AbortProcessingException;
import javax.faces.event.PhaseId;
import javax.faces.event.SystemEvent;

    private final BeanManager beanManager;
    public BridgeExceptionHandlerWrapper(ExceptionHandler wrapped,
                                         BeanManager beanManager,
                                         Annotation exceptionQualifier)
        this.beanManager = beanManager;
        while ((ELException.class.isInstance(throwable) || FacesException.class.isInstance(throwable) ||
            InvocationTargetException.class.isInstance(throwable)) && throwable.getCause() != null)

    @Override
    public void processEvent(SystemEvent event) throws AbortProcessingException
    {
        //handle exceptions which occur in a phase-listener (beforePhase) for PhaseId.RENDER_RESPONSE
        //needed because #handle gets called too late in this case
        if (event instanceof ExceptionQueuedEvent)
        {
            ExceptionQueuedEvent exceptionQueuedEvent = (ExceptionQueuedEvent)event;
            FacesContext facesContext = exceptionQueuedEvent.getContext().getContext();

            if (facesContext.getCurrentPhaseId() == PhaseId.RENDER_RESPONSE &&
                exceptionQueuedEvent.getContext().inBeforePhase())
            {
                Throwable exception = getRootCause(exceptionQueuedEvent.getContext().getException());

                ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(exception);
                this.beanManager.fireEvent(exceptionToCatchEvent);

                if (exceptionToCatchEvent.isHandled())
                {
                    return;
                }
            }
        }
        super.processEvent(event);
    }
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import javax.enterprise.inject.spi.BeanManager;
    private BeanManager beanManager;

            exceptionHandler = new BridgeExceptionHandlerWrapper(
                exceptionHandler, this.beanManager, this.bridgeExceptionQualifier);
            this.beanManager = BeanManagerProvider.getInstance().getBeanManager();
            this.jsfModuleConfig = BeanProvider.getContextualReference(this.beanManager, JsfModuleConfig.class, false);
import org.apache.deltaspike.core.util.AnnotationUtils;
        return AnnotationUtils
            .extractAnnotationFromMethodOrClass(this.beanManager, context.getMethod(), Transactional.class);
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

    public static List<Class<?>> getProxyAndBaseTypes(Class<?> proxyClass)
    {
        List<Class<?>> result = new ArrayList<Class<?>>();
        result.add(proxyClass);
        if (isInterfaceProxy(proxyClass))
        {
            result.addAll(Arrays.asList(proxyClass.getInterfaces()));
        }
        else
        {
            result.add(proxyClass.getSuperclass());
        }
        return result;
    }

    public static boolean isInterfaceProxy(Class<?> proxyClass)
    {
        Class<?>[] interfaces = proxyClass.getInterfaces();
        return Proxy.class.equals(proxyClass.getSuperclass()) &&
                interfaces != null && interfaces.length > 0;
    }
import org.apache.deltaspike.core.util.ProxyUtils;
            List<Class<?>> candidates = ProxyUtils.getProxyAndBaseTypes(proxy.getClass());
        boolean clientWindowRenderModeEnabled = getClientWindow().isClientWindowRenderModeEnabled(context);
        try
        {
            getClientWindow().disableClientWindowRenderMode(context);

            super.encodeChildren(context, component);
        }
        finally
        {
            if (clientWindowRenderModeEnabled)
            if (clientWindowRenderModeEnabled)
            {
                getClientWindow().disableClientWindowRenderMode(context);
            }
    @RequestScoped
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
import javax.enterprise.inject.spi.BeanManager;
    @Inject
    private BeanManager beanManager;

                    AccessDeniedException accessDeniedException = new AccessDeniedException(violations);
                    ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(accessDeniedException);
                    this.beanManager.fireEvent(exceptionToCatchEvent);

                    if (!exceptionToCatchEvent.isHandled())
                    {
                        throw accessDeniedException;
                    }
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
import org.apache.deltaspike.core.api.config.view.ViewConfig;
import org.apache.deltaspike.core.api.config.view.navigation.event.PreViewConfigNavigateEvent;
import org.apache.deltaspike.test.jsf.impl.config.view.navigation.event.uc001.Pages.CustomErrorPage;
        if (navigateEvent.getToView().equals(CustomErrorPage.class))
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;

    class CustomErrorPage extends DefaultErrorView
    {

    }
import javax.enterprise.inject.Model;

import org.apache.deltaspike.jsf.api.config.view.View;
import org.apache.deltaspike.jsf.api.config.view.View.NavigationMode;
import org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode;
@View(navigation = NavigationMode.REDIRECT, viewParams = ViewParameterMode.INCLUDE)
import org.apache.deltaspike.jsf.api.config.view.View;
import org.apache.deltaspike.jsf.api.config.view.View.NavigationMode;
import org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode;
@View(navigation = NavigationMode.REDIRECT, viewParams = ViewParameterMode.INCLUDE)
    private String currentValue = "aValue";
    public String getCurrentValue()
import org.apache.deltaspike.jsf.api.config.view.View;
import org.apache.deltaspike.jsf.api.config.view.View.NavigationMode;
import org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode;
@View(navigation = NavigationMode.REDIRECT, viewParams = ViewParameterMode.INCLUDE)
 b/deltaspike/modules/jsf/impl/src/test/java/org/apache/deltaspike/test/jsf/impl/config/view/navigation/parameter/uc006/Pages.java
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
import org.apache.deltaspike.core.api.config.view.ViewConfig;
import org.apache.deltaspike.jsf.api.config.view.View;

public interface Pages extends ViewConfig
    public class CustomErrorPage extends DefaultErrorView implements Pages
    {
    }
import java.lang.reflect.Constructor;
    // @Override - forward compatibility to interceptors API 1.2
    public Constructor<?> getConstructor()
    {
        return null;
    }

        initialize();
import static org.apache.deltaspike.data.impl.util.QueryUtils.isNotEmpty;
import static org.apache.deltaspike.data.impl.util.QueryUtils.nullSafeValue;

        if (isNotEmpty(context.getQueryString()))
            return new StringBuilder()
                    .append("select count(")
                        .append(nullSafeValue(select, entityName))
                    .append(") ")
                    .append(from)
                    .append(nullSafeValue(where))
                    .toString();
    public static String nullSafeValue(String value)
    {
        return nullSafeValue(value, null);
    }

    public static String nullSafeValue(String value, String fallback)
    {
        return value != null ? value : (fallback != null ? fallback : "");
    }

    @Query("select s from Simple s")
    public abstract QueryResult<Simple> queryAll();

    private boolean optional;
        this.optional = false;
        this.qualifiers = Collections.emptySet();
        this.optional = false;

    public boolean isOptional()
    {
        return optional;
    }

    public void setOptional(boolean optional)
    {
        this.optional = optional;
    }
            if (!exceptionEventEvent.isHandled() && throwException == null && !exceptionEventEvent.isOptional())
                event.setOptional(true);
                exceptionToCatchEvent.setOptional(true);

            Typed typed = mockClass.getAnnotation(Typed.class);

            if (typed == null || typed.value().length == 0)
            {
                typed = beanClass.getAnnotation(Typed.class);
            }
                excludedPackagesOrFiles,
                "ds-core");
                null,
                "ds-core");
                null,
                "ds-core_and_jpa");
                , excludedFiles,
                "ds-core_and_jsf");
                new String[]{"org.apache.deltaspike.security"}, excludedFiles,
                "ds-security");
                        "org.apache.deltaspike.partialbean"}, excludedFiles,
                "ds-core_and_partial-bean");
                null,
                "ds-core_and_scheduler");
                        "org.apache.deltaspike.security"}, excludedFiles,
                "ds-core_and_security");
                        "org.apache.deltaspike.servlet"}, null,
                "ds-core_and_servlet");
import java.util.UUID;
                                            String[] excludeIfPackageExists,
                                            String archiveName)
                    = createArchive(foundFile, markerFile, includeIfPackageExists, excludeIfPackageExists, archiveName);
                                             String[] includeIfPackageExists,
                                             String[] excludeIfPackageExists,
                                             String archiveName)
            return addFileArchive(f, includeIfPackageExists, excludeIfPackageExists, archiveName);
                                              String[] excludeIfPackageExists,
                                              String archiveName)
        if (archiveName == null)
        {
            archiveName = UUID.randomUUID().toString();
        }

        JavaArchive javaArchive = ShrinkWrap.create(JavaArchive.class, archiveName  ".jar");
                    exceptionToCatchEvent.setOptional(true);
    private static final String DS_BASE_PACKAGE = "org.apache.deltaspike.";
        return packageName.startsWith(OWB_BASE_PACKAGE) || packageName.startsWith(WELD_BASE_PACKAGE) ||
            isDeltaSpikePackage(packageName);
    }

    protected boolean isDeltaSpikePackage(String packageName)
    {
        return packageName.startsWith(DS_BASE_PACKAGE);
import org.apache.deltaspike.core.util.metadata.AnnotationInstanceProvider;
import org.apache.myfaces.mc.test.core.annotation.TestConfig;
import javax.el.ExpressionFactory;
import java.util.HashMap;
import java.util.Map;
    private static final TestConfig DEFAULT_TEST_CONFIG_LITERAL = AnnotationInstanceProvider.of(TestConfig.class);
    protected MyFacesContainer mockedMyFacesTestContainer;
    protected Class testClass;
    protected Map<String, String> containerConfig = new HashMap<String, String>();
                TestConfig testConfig = testClass.getJavaClass().getAnnotation(TestConfig.class);

                if (testConfig == null || DEFAULT_TEST_CONFIG_LITERAL.webappResourcePath().equals(
                    testConfig.webappResourcePath()))
                {
                    return ConfigResolver.getPropertyValue("deltaspike.testcontrol.mf.test.webapp_resource_path", "");
                }
                return testConfig.webappResourcePath();

            @Override
            protected void setUpWebConfigParams()
            {
                servletContext.addInitParameter("org.apache.myfaces.config.annotation.LifecycleProvider",
                    "org.apache.myfaces.config.annotation.NoInjectionAnnotationLifecycleProvider");
                servletContext.addInitParameter("org.apache.myfaces.CHECKED_VIEWID_CACHE_ENABLED", "false");

                servletContext.addInitParameter(ExpressionFactory.class.getName(),
                    "org.apache.el.ExpressionFactoryImpl");

                super.setUpWebConfigParams();

                initContainerConfig();

                //add custom values (might replace the default values)
                for (Map.Entry<String, String> entry : containerConfig.entrySet())
                {
                    servletContext.addInitParameter(entry.getKey(), entry.getValue());
                }
            }
    protected void initContainerConfig()
    {
        containerConfig = new HashMap<String, String>();
        for (Map.Entry<String, String> entry : ConfigResolver.getAllProperties().entrySet())
        {
            if (entry.getKey().startsWith("org.apache.myfaces.") || entry.getKey().startsWith("javax.faces.") ||
                    entry.getKey().startsWith("facelets."))
            {
                containerConfig.put(entry.getKey(), entry.getValue());
            }
        }
    }

            ViewConfigResolver viewConfigResolver;

            try
            {
                viewConfigResolver = BeanProvider.getContextualReference(ViewConfigResolver.class);
            }
            catch (Exception e)
            {
                LOGGER.log(Level.WARNING, "Container issue detected -> can't validate view-configs.", e);
                return;
            }

        LOGGER.log(Level.SEVERE, "invalid view-config found", e);
import org.apache.deltaspike.testcontrol.impl.request.ManuallyHandledRequestEvent;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import javax.enterprise.event.Reception;
@ApplicationScoped

    public void onManuallyHandledRequest(
            @Observes(notifyObserver = Reception.IF_EXISTS) ManuallyHandledRequestEvent manuallyHandledRequestEvent)
    {
        switch (manuallyHandledRequestEvent.getManualAction())
        {
            case STARTED:
                startScope(RequestScoped.class);
                break;
            case STOPPED:
                stopScope(RequestScoped.class);
                break;
            default:
                throw new IllegalArgumentException("unsupported action: " 
                        manuallyHandledRequestEvent.getManualAction().name());
        }
    }
import org.apache.deltaspike.testcontrol.spi.ExternalContainer;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.context.ConversationScoped;
import javax.enterprise.context.SessionScoped;
import javax.inject.Singleton;

        if (isManualScopeHandling())
        {
            for (ExternalContainer externalContainer : CdiTestRunner.getActiveExternalContainers())
            {
                externalContainer.startScope(Singleton.class);
                externalContainer.startScope(ApplicationScoped.class);
                externalContainer.startScope(RequestScoped.class);
                externalContainer.startScope(SessionScoped.class);
                externalContainer.startScope(ConversationScoped.class);
            }
        }
        if (isManualScopeHandling())
        {
            for (ExternalContainer externalContainer : CdiTestRunner.getActiveExternalContainers())
            {
                externalContainer.stopScope(ConversationScoped.class);
                externalContainer.stopScope(SessionScoped.class);
                externalContainer.stopScope(RequestScoped.class);
                externalContainer.stopScope(ApplicationScoped.class);
                externalContainer.stopScope(Singleton.class);
            }
        }

            for (ExternalContainer externalContainer : CdiTestRunner.getActiveExternalContainers())
            {
                externalContainer.startScope(scopeClass);
            }
            for (ExternalContainer externalContainer : CdiTestRunner.getActiveExternalContainers())
            {
                externalContainer.stopScope(scopeClass);
            }
        return RequestScoped.class.equals(scopeClass) && isManualScopeHandling();
    }

    private boolean isManualScopeHandling()
    {
        return !Boolean.TRUE.equals(CdiTestRunner.isAutomaticScopeHandlingActive());
import javax.enterprise.inject.spi.BeanManager;
    boolean isMockedImplementationSupported(BeanManager beanManager, Annotated annotated);
import javax.enterprise.inject.spi.BeanManager;
import java.lang.annotation.Annotation;
import java.lang.reflect.Member;
import java.util.Set;
import java.util.logging.Logger;
    private static final Logger LOG = Logger.getLogger(DefaultMockFilter.class.getName());

    private static final String JAVA_BASE_PACKAGE = "java.";
    private static final String JAVAX_BASE_PACKAGE = "javax.";
    public boolean isMockedImplementationSupported(BeanManager beanManager, Annotated annotated)
        Class origin = null;

            origin = ((AnnotatedType)annotated).getJavaClass();
            if (isAnnotatedTypeWithInterceptorAnnotation(beanManager, annotated.getAnnotations(), origin.getName()))
            {
                return false;
            }
            Member member = ((AnnotatedMember)annotated).getJavaMember();
            origin = member.getDeclaringClass();
            if (isAnnotatedTypeWithInterceptorAnnotation(beanManager, annotated.getAnnotations(), member.toString()))
            {
                return false;
            }
        return origin != null && !isInternalPackage(origin.getPackage().getName());
    }

    protected boolean isAnnotatedTypeWithInterceptorAnnotation(BeanManager beanManager,
                                                               Set<Annotation> annotations,
                                                               String origin)
    {
        for (Annotation annotation : annotations)
        {
            if (isStandardAnnotation(annotation))
            {
                continue;
            }

            if (beanManager.isInterceptorBinding(annotation.annotationType()) ||
                    (beanManager.isStereotype(annotation.annotationType()) &&
                            isStereotypeWithInterceptor(annotation, beanManager)))
            {
                LOG.warning("Skip mocking intercepted bean "  origin);

                return true;
            }
        }
        return false;
    }

    protected boolean isStereotypeWithInterceptor(Annotation stereotypeAnnotation, BeanManager beanManager)
    {
        for (Annotation annotation : stereotypeAnnotation.annotationType().getAnnotations())
        {
            if (isStandardAnnotation(annotation))
            {
                continue;
            }

            if (beanManager.isInterceptorBinding(annotation.annotationType()) ||
                    isStereotypeWithInterceptor(annotation, beanManager))
            {
                return true;
            }
        }
        return false;
    }

    protected boolean isStandardAnnotation(Annotation annotation)
    {
        return annotation.annotationType().getName().startsWith(JAVA_BASE_PACKAGE) ||
                annotation.annotationType().getName().startsWith(JAVAX_BASE_PACKAGE);
            if (!mockFilter.isMockedImplementationSupported(beanManager, processInjectionTarget.getAnnotatedType()))
            if (!mockFilter.isMockedImplementationSupported(beanManager, processProducer.getAnnotatedMember()))
    private static final String EJB_BASE_PACKAGE = "javax.ejb.";
            if (isEjbOrAnnotatedTypeWithInterceptorAnnotation(
                beanManager, annotated.getAnnotations(), origin.getName()))
            if (isEjbOrAnnotatedTypeWithInterceptorAnnotation(
                beanManager, annotated.getAnnotations(), member.toString()))
    protected boolean isEjbOrAnnotatedTypeWithInterceptorAnnotation(BeanManager beanManager,
                                                                    Set<Annotation> annotations,
                                                                    String origin)
            if (annotation.annotationType().getName().startsWith(EJB_BASE_PACKAGE))
            {
                return true;
            }

                (beanManager.isStereotype(annotation.annotationType()) &&
                    isStereotypeWithInterceptor(annotation, beanManager)))
                isStereotypeWithInterceptor(annotation, beanManager))
            annotation.annotationType().getName().startsWith(JAVAX_BASE_PACKAGE);
    /**
     * Only evaluated on the first/outermost transactional bean/method in the chain
     * @return true to trigger #rollback for the current transaction(s), false otherwise
     */
    boolean readOnly() default false;
                        boolean rollbackOnly = isRollbackOnly(transactionalAnnotation);
                        if (!rollbackOnly)
                        {
                            // but first try to flush all the transactions and write the updates to the database
                            for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
                            {
                                EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
                                if (transaction != null && transaction.isActive())
                                {
                                    try
                                    {
                                        if (!commitFailed)
                                            currentEntityManagerEntry.getEntityManager().flush();

                                            if (!rollbackOnly && transaction.getRollbackOnly())
                                            {
                                                // don't set commitFailed to true directly
                                                // (the order of the entity-managers isn't deterministic
                                                //  -> tests would break)
                                                rollbackOnly = true;
                                            }
                                    catch (Exception e)
                                    {
                                        firstException = e;
                                        commitFailed = true;
                                        break;
                                    }
    //allows to use a custom tx-controller in a custom strategy
    protected boolean isRollbackOnly(Transactional transactionalAnnotation)
    {
        return transactionalAnnotation != null && transactionalAnnotation.readOnly();
    }

        BeanManager beanManager, Method targetMethod, Class targetClass, Class<T> targetAnnotationType)
            Class unproxiedTargetClass = ProxyUtils.getUnproxiedClass(targetClass);
            result = findAnnotation(beanManager, unproxiedTargetClass.getAnnotations(), targetAnnotationType);
        Class targetClass = context.getTarget() != null ? context.getTarget().getClass() :
            context.getMethod().getDeclaringClass();
            .extractAnnotationFromMethodOrClass(beanManager, context.getMethod(), targetClass, Transactional.class);
import java.lang.reflect.Modifier;
        Exclude exclude = extractExcludeAnnotation(processAnnotatedType.getAnnotatedType().getJavaClass());

        if (exclude == null)
    //only support the physical usage and inheritance if @Exclude comes from an abstract class
    //TODO re-visit the impact of java.lang.annotation.Inherited (for @Exclude) for the available use-cases
    protected Exclude extractExcludeAnnotation(Class<?> currentClass)
    {
        Exclude result = currentClass.getAnnotation(Exclude.class);

        if (result != null)
        {
            return result;
        }

        currentClass = currentClass.getSuperclass();

        while (!Object.class.equals(currentClass) && currentClass != null)
        {
            if (Modifier.isAbstract(currentClass.getModifiers()))
            {
                result = currentClass.getAnnotation(Exclude.class);
            }

            if (result != null)
            {
                return result;
            }

            currentClass = currentClass.getSuperclass();
        }
        return null;
    }

import org.apache.deltaspike.data.api.EntityManagerDelegate;
public interface ExtendedRepositoryInterface extends EntityRepository<Simple, Long>, EntityManagerDelegate<Simple>
import java.lang.reflect.Constructor;
import javax.inject.Inject;

import org.apache.deltaspike.data.spi.QueryInvocationContext;

/**
 * A base mapper to map from Dto to Entity and vice versa. This should be sufficient
 * for most mapping cases and simplify the implementation of a mapper.
 *
 * @param <Entity>      The Entity type.
 * @param <Dto>         The Dto type.
 */
    @Inject
    private QueryInvocationContext context;

    /**
     * Return the primary key of the Entity corresponding to the Dto. If this is a new
     * Entity, return {@code null}.
     * @param dto       The Dto to map to an Entity.
     * @return          The Entity primary key, or {@code null} for a new Entity.
     */
    protected abstract Object getPrimaryKey(Dto dto);


    /**
     * Map a Dto to an Entity. In case the Dto contains a valid primary key,
     * the Entity will be retrieved first and used as method parameter. Otherwise
     * Entity is a unmanaged new instance.
     *
     * @param entity    Either a managed Entity looked up by the primary key,
     *                  or a new Entity instance.
     * @param dto       The Dto to map.
     * @return          Mapped Entity.
     */
    protected abstract Entity toEntity(Entity entity, Dto dto);
        Dto dto = (Dto) parameter;
        Object primaryKey = getPrimaryKey(dto);
        if (primaryKey != null)
        {
            Entity entity = findEntity(primaryKey);
            return toEntity(entity, dto);
        }
        return toEntity(newEntity(), dto);
    }

    protected Entity newEntity()
    {
        try
        {
            Class<?> entityClass = context.getEntityClass();
            Constructor<?> constructor = entityClass.getDeclaredConstructor();
            constructor.setAccessible(true);
            return (Entity) constructor.newInstance();
        }
        catch (Exception e)
        {
            throw new RuntimeException("Failed instantiating new Entity", e);
        }
    }

    protected Entity findEntity(Object primaryKey)
    {
        return (Entity) context.getEntityManager().find(context.getEntityClass(), primaryKey);
    public void initMapper()
        queryContext.initMapper();
    protected Simple()
            Simple simple = new Simple(dto.getName());
import javax.inject.Named;
import java.beans.Introspector;
        return BeanProvider.getContextualReference(targetType, true);
    }

    protected Object getTargetObjectByName(String beanName)
    {
        return BeanProvider.getContextualReference(beanName, true);
        private final Class<?> targetBeanClass;
        private final String beanName;
            Named named = this.targetBeanClass.getAnnotation(Named.class);

            if (named != null && !"".equals(named.value()))
            {
                this.beanName = named.value();
            }
            else
            {
                //fallback to the default (which might exist) -> TODO check meta-data of Bean<T>
                this.beanName = Introspector.decapitalize(targetBeanClass.getSimpleName());
            }

        public Class<?> getTargetBeanClass()

        public String getBeanName()
        {
            return beanName;
        }
                    Class<?> targetBeanClass = callbackEntry.getTargetBeanClass();
                    Object bean = getTargetObject(targetBeanClass);

                    if (bean == null)
                    {
                        String beanName = callbackEntry.getBeanName();
                        bean = getTargetObjectByName(beanName);

                        if (bean == null)
                        {
                            throw new IllegalStateException("Can't find bean by type "  targetBeanClass 
                                " or by name: "  beanName);
                        }
                    }

import javax.persistence.TypedQuery;
     * Utility method to create a typed query.
     * @param qlString  Query string
     * @return          Typed query
     */
    protected abstract TypedQuery<E> typedQuery(String qlString);

    /**
    public TypedQuery<E> typedQuery(String qlString)
    {
        return entityManager().createQuery(qlString, entityClass());
    }

        return typedQuery(query)
import org.apache.deltaspike.core.util.metadata.AnnotationInstanceProvider;
    private static final Scheduled DEFAULT_SCHEDULED_LITERAL = AnnotationInstanceProvider.of(Scheduled.class);

            //can happen with manually registered job-instances (via #unwrap)
            if (scheduled == null)
            {
                scheduled = DEFAULT_SCHEDULED_LITERAL;
            }

    OWB11 ("org.apache.webbeans.container.BeanManagerImpl", "[1.1,1.2)"),
    OWB12 ("org.apache.webbeans.container.BeanManagerImpl", "[1.2,1.3)"),
    WELD11("org.jboss.weld.manager.BeanManagerImpl", "[1.1,1.2)"),
    WELD12("org.jboss.weld.manager.BeanManagerImpl", "[1.2,1.3)"),
    WELD20("org.jboss.weld.manager.BeanManagerImpl", "[2.0,2.1)");
    private final String versionRange;
    CdiImplementation(String implementationClassName, String versionRange)
        this.versionRange = versionRange;
    public String getVersionRange()
        return versionRange;
 b/deltaspike/modules/bean-validation/impl/src/main/java/org/apache/deltaspike/beanvalidation/impl/CDIAwareConstraintValidatorFactory.java
package org.apache.deltaspike.beanvalidation.impl;
 b/deltaspike/modules/bean-validation/impl/src/test/java/org/apache/deltaspike/beanvalidation/test/ArchiveUtils.java
package org.apache.deltaspike.beanvalidation.test;
 b/deltaspike/modules/bean-validation/impl/src/test/java/org/apache/deltaspike/beanvalidation/test/ArrayChecker.java
package org.apache.deltaspike.beanvalidation.test;
 b/deltaspike/modules/bean-validation/impl/src/test/java/org/apache/deltaspike/beanvalidation/test/ArraySize.java
package org.apache.deltaspike.beanvalidation.test;
 b/deltaspike/modules/bean-validation/impl/src/test/java/org/apache/deltaspike/beanvalidation/test/BasicPojo.java
package org.apache.deltaspike.beanvalidation.test;
 b/deltaspike/modules/bean-validation/impl/src/test/java/org/apache/deltaspike/beanvalidation/test/InjectableConstraintValidator.java
package org.apache.deltaspike.beanvalidation.test;
import org.apache.deltaspike.jsf.impl.navigation.NavigationHandlerAwareApplication;
    private volatile Boolean isNavigationAwareApplicationWrapperActivated;
            this.isNavigationAwareApplicationWrapperActivated =
                ClassDeactivationUtils.isActivated(NavigationHandlerAwareApplication.class);
        Application wrappedApplication = this.wrappedFacesContext.getApplication();
        if (this.isNavigationAwareApplicationWrapperActivated)
        {
            wrappedApplication = new NavigationHandlerAwareApplication(wrappedApplication);
        }
            wrappedApplication, this.jsfModuleConfig, this.preDestroyViewMapEventFilterMode);
import org.apache.deltaspike.core.spi.activation.Deactivatable;
public class NavigationHandlerAwareApplication extends ApplicationWrapper implements Deactivatable
    private static Boolean manualNavigationHandlerWrapperMode;
    private static Class navigationHandlerWrapperClass;
    public NavigationHandler getNavigationHandler()
        return wrapNavigationHandler(this.wrapped.getNavigationHandler());
    }

    private NavigationHandler wrapNavigationHandler(NavigationHandler handler)
    {
        NavigationHandler result = null;

        if (manualNavigationHandlerWrapperMode == null)
        {
            lazyInit();
        }
        if (!manualNavigationHandlerWrapperMode)
            result = wrapNavigationHandlerWithNewWrapper(handler);
        }
        if (result != null)
        {
            return result;
        return new DeltaSpikeNavigationHandler(handler);
    }

    private static synchronized void lazyInit()
    {
        if (manualNavigationHandlerWrapperMode != null)
        {
            return;
        }

        Class wrapperClass = ClassUtils
            .tryToLoadClassForName("javax.faces.application.ConfigurableNavigationHandlerWrapper");

        if (wrapperClass != null)
        {
            navigationHandlerWrapperClass =
                ClassUtils.tryToLoadClassForName(
                    "org.apache.deltaspike.jsf.impl.navigation.DeltaSpikeNavigationHandlerWrapper");
            manualNavigationHandlerWrapperMode = false;
        }
        else
        {
            manualNavigationHandlerWrapperMode = true;
        }
    }

    private NavigationHandler wrapNavigationHandlerWithNewWrapper(NavigationHandler handler)
    {
        if (ConfigurableNavigationHandler.class.isAssignableFrom(handler.getClass()))
        {
            try
            {
                Constructor deltaSpikeNavigationHandlerWrapperConstructor =
                    this.navigationHandlerWrapperClass.getConstructor(ConfigurableNavigationHandler.class);

                NavigationHandler navigationHandlerWrapper =
                    (NavigationHandler)deltaSpikeNavigationHandlerWrapperConstructor.newInstance(handler);
                return  navigationHandlerWrapper;
            }
            catch (Exception e)
            {
                throw ExceptionUtils.throwAsRuntimeException(e);
            }
        }

        return null;
            List<String> messageSources = getMessageSources(messageContext);

    protected List<String> getMessageSources(MessageContext messageContext)
    {
        return messageContext.getMessageSources();
    }
 b/deltaspike/modules/jsf/impl/src/main/java/org/apache/deltaspike/jsf/impl/message/JsfAwareLocaleResolver.java
import javax.enterprise.inject.Specializes;
@Specializes
public class JsfAwareLocaleResolver extends DefaultLocaleResolver
    private static final long serialVersionUID = -8776583393262804931L;

            }
            result = facesContext.getApplication().getDefaultLocale();

            if (result != null)
            {
                return result;
                boolean supportedLocaleConfigured = false;
                    supportedLocaleConfigured = true;

                if (!supportedLocaleConfigured)
                {
                    return result;
                }
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.PropertyFileUtils;
import org.apache.deltaspike.core.util.ProxyUtils;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.logging.Level;
    private static final Logger LOG = Logger.getLogger(QuartzScheduler.class.getName());
        SchedulerFactory schedulerFactory = null;
            Properties properties = new Properties();
            properties.put(StdSchedulerFactory.PROP_SCHED_JOB_FACTORY_CLASS, CdiAwareJobFactory.class.getName());

            try
            {
                ResourceBundle config = loadCustomQuartzConfig();

                Enumeration<String> keys = config.getKeys();
                String key;
                while (keys.hasMoreElements())
                {
                    key = keys.nextElement();
                    properties.put(key, config.getString(key));
                }
            }
            catch (Exception e1)
            {
                LOG.info("no custom quartz-config file found. falling back to the default config provided by quartz.");

                InputStream inputStream = null;
                try
                {
                    inputStream = ClassUtils.getClassLoader(null).getResourceAsStream("org/quartz/quartz.properties");
                    properties.load(inputStream);
                }
                catch (Exception e2)
                {
                    LOG.warning("failed to load quartz default-config");
                    schedulerFactory = new StdSchedulerFactory();
                }
                finally
                {
                    if (inputStream != null)
                    {
                        inputStream.close();
                    }
                }
            }
            if (schedulerFactory == null)
            {
                schedulerFactory = new StdSchedulerFactory(properties);
            }
        catch (Exception e)
            LOG.log(Level.WARNING, "fallback to default scheduler-factory", e);
    protected ResourceBundle loadCustomQuartzConfig()
    {
        String configFile =
            ConfigResolver.getPropertyValue("deltaspike.scheduler.quartz_config-file", "quartz.properties");
        return PropertyFileUtils.getResourceBundle(configFile);
    }

            Class<?> jobClass = ProxyUtils.getUnproxiedClass(jobExecutionContext.getJobInstance().getClass());
            Scheduled scheduled = jobClass.getAnnotation(Scheduled.class);
            boolean jobInstanceIsBean;

            try
            {
                jobInstanceIsBean =
                    Boolean.TRUE.equals(jobExecutionContext.getScheduler().getContext().get(jobClass.getName()));
            }
            catch (SchedulerException e)
            {
                jobInstanceIsBean = false;
            }

            if (!jobInstanceIsBean)
            {
                BeanProvider.injectFields(jobExecutionContext.getJobInstance());
            }
    private boolean called = false;

        called = true;
    }

    public boolean getCalled()
    {
        return called;

    private boolean called = false;

        called = true;
    }

    public boolean getCalled()
    {
        return called;
    
    private boolean called = false;

        called = true;
    
    @View(name = "home")
    @Folder(name = "wizard1") //valid usage
        class Step1 implements ViewConfig
        String url = externalContext.getRequestContextPath()
  
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class DeltaSpikeResourceHandler extends ResourceHandlerWrapper implements Deactivatable
    private final boolean activated;
        activated = ClassDeactivationUtils.isActivated(this.getClass());
        if (activated && resource != null && libraryName != null && LIBRARY.equals(libraryName))
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
            AccessDeniedException accessDeniedException = new AccessDeniedException(violations);
            ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(accessDeniedException);
            exceptionToCatchEvent.setOptional(true);
            beanManager.fireEvent(exceptionToCatchEvent);

            if (!exceptionToCatchEvent.isHandled())
            {
                throw accessDeniedException;
            }
            throw new AccessDeniedException(violations);
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
import org.apache.deltaspike.security.api.authorization.AccessDeniedException;
import java.util.Set;
        Set<Authorizer> authorizers = metaDataStorage.getAuthorizers(targetClass, method);

        Object result = null;

        if (invokeBeforeMethodInvocationAuthorizers(invocationContext, authorizers))
            result = invocationContext.proceed();

            invokeAfterMethodInvocationAuthorizers(invocationContext, authorizers, result);

    private boolean invokeBeforeMethodInvocationAuthorizers(InvocationContext invocationContext,
        Set<Authorizer> authorizers) throws IllegalAccessException
    {
        try
        {
            for (Authorizer authorizer : authorizers)
            {
                if (authorizer.isBeforeMethodInvocationAuthorizer())
                {
                    authorizer.authorize(invocationContext, null, this.beanManager);
                }
            }
        }
        catch (AccessDeniedException ade)
        {
            return handleAccessDeniedException(ade);
        }

        return true;
    }

    private boolean invokeAfterMethodInvocationAuthorizers(InvocationContext invocationContext,
        Set<Authorizer> authorizers, Object result) throws IllegalAccessException
    {
        try
        {
            for (Authorizer authorizer : authorizers)
            {
                if (authorizer.isAfterMethodInvocationAuthorizer())
                {
                    authorizer.authorize(invocationContext, result, this.beanManager);
                }
            }
        }
        catch (AccessDeniedException ade)
        {
            return handleAccessDeniedException(ade);
        }

        return true;
    }

    /**
     * <p>Fires a {@link org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent} for the given
     * {@link org.apache.deltaspike.security.api.authorization.AccessDeniedException}.</p>
     *
     * @param ade The previously thrown exception representing a authorization check failure.
     *
     * @return False if the processing should be aborted.
     *
     * @throws org.apache.deltaspike.security.api.authorization.AccessDeniedException
     * If the exception was not handled by the application.
     */
    private boolean handleAccessDeniedException(AccessDeniedException ade) throws AccessDeniedException
    {
        ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(ade);

        exceptionToCatchEvent.setOptional(true);

        beanManager.fireEvent(exceptionToCatchEvent);

        if (!exceptionToCatchEvent.isHandled())
        {
            throw ade;
        }

        return false;
    }
                    try
                        this.beanManager.fireEvent(exceptionToCatchEvent);
                    }
                    catch (AccessDeniedException e)
                    {
                        throw new SkipInternalProcessingException(accessDeniedException);
}
import org.apache.deltaspike.security.impl.authorization.SkipInternalProcessingException;
        invokeBeforeMethodInvocationAuthorizers(invocationContext, authorizers);
        Object result = invocationContext.proceed();
        invokeAfterMethodInvocationAuthorizers(invocationContext, authorizers, result);
    protected void invokeBeforeMethodInvocationAuthorizers(
        InvocationContext invocationContext, Set<Authorizer> authorizers) throws IllegalAccessException
        catch (SkipInternalProcessingException e)
            throw e.getAccessDeniedException();
        catch (AccessDeniedException e)
        {
            RuntimeException exceptionToThrow = handleAccessDeniedException(e);
            if (exceptionToThrow != null)
            {
                throw exceptionToThrow;
            }
        }
    protected void invokeAfterMethodInvocationAuthorizers(InvocationContext invocationContext,
        catch (AccessDeniedException e)
            RuntimeException exceptionToThrow = handleAccessDeniedException(e);
            if (exceptionToThrow != null)
            {
                throw exceptionToThrow;
            }
     * @param originalException exception thrown by an authorizer
     * @return the original exception if the default behavior was changed and the exception is unhandled
    protected RuntimeException handleAccessDeniedException(AccessDeniedException originalException)
        ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(originalException);
        this.beanManager.fireEvent(exceptionToCatchEvent);
        //the next step won't happen per default since ExceptionHandlerBroadcaster will throw the exception,
        //because BeforeAccessDeniedExceptionHandler calls #throwOriginal
        //but allows to suppress it via deactivating BeforeAccessDeniedExceptionHandler
        //(or a 2nd @BeforeHandles method which overrules the default behavior
        //(if needed)
            throw originalException;
        return null;
}
 *
    QuerySelection<E, Long> count(SingularAttribute<E, ?> attribute);

    /**
     * Create a query selection for the
     * {@link javax.persistence.criteria.CriteriaBuilder#countDistinct(javax.persistence.criteria.Expression)}
     * over an attribute.
     * @param attribute Attribute to use in the aggregate.
     * @return          {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     */
    QuerySelection<E, Long> countDistinct(SingularAttribute<E, ?> attribute);
            CriteriaQuery<?> query = createCriteriaQuery(builder);
            return (TypedQuery<R>) entityManager.createQuery(query);
    void applyProcessors(CriteriaQuery<?> query, CriteriaBuilder builder, From<C, C> from)
    private Selection<?>[] prepareSelections(CriteriaQuery<?> query, CriteriaBuilder builder, From<C, C> root)
    private CriteriaQuery<?> createCriteriaQuery(CriteriaBuilder builder)
    {
        if (resultClass.getName().startsWith("java.lang"))
        {
            return builder.createQuery();
        }
        else
        {
            return builder.createQuery(resultClass);
        }
    }

import org.apache.deltaspike.data.api.criteria.QuerySelection;
public class Count<P> implements QuerySelection<P, Long>
    private final SingularAttribute<P, ?> attribute;

    public Count(SingularAttribute<P, ?> attribute)
        this.attribute = attribute;
    public <R> Selection<Long> toSelection(CriteriaQuery<R> query, CriteriaBuilder builder, Path<? extends P> path)
        return builder.count(path.get(attribute));
import org.apache.deltaspike.data.impl.criteria.selection.numeric.CountDistinct;
    public QuerySelection<E, Long> count(SingularAttribute<E, ?> attribute)
        return new Count<E>(attribute);
    }

    @Override
    public QuerySelection<E, Long> countDistinct(SingularAttribute<E, ?> attribute)
    {
        return new CountDistinct<E>(attribute);
    public Long criteriaCount(String name)
    {
        return criteria()
                .select(Long.class, countDistinct(Simple_.name))
                .eq(Simple_.name, name)
                .getSingleResult();
    }

 * Base Repository interface. All methods are implemented by the CDI extension.
     * Persist (new entity) or merge the given entity. The distinction on calling either
     * method is done based on the primary key field being null or not.
     * If this results in wrong behavior for a specific case, consider using the
     * {@link org.apache.deltaspike.data.api.EntityManagerDelegate} which offers both
     * {@code persist} and {@code merge}.

    static boolean iaeHandlerCalled = false;


    public void handleInbound(@Handles ExceptionEvent<IllegalArgumentException> event)
    {
        iaeHandlerCalled = true;
    }

    public static boolean isIaeHandlerCalled()
    {
        return iaeHandlerCalled;
    }
     * @param beanManager         active bean manager
                ExceptionHandlerBroadcaster.class.getName(), "executeHandlers", exceptionEventEvent.getException());
            inbound_cause:
                                throw exceptionEventEvent.getException();
                                throw callbackEvent.getThrowNewException();
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.event.Observes;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.spi.BeanManager;

import org.apache.deltaspike.core.api.exception.control.HandlerMethod;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionStackEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
import org.apache.deltaspike.core.api.provider.BeanProvider;

 * Observer of {@link org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent} events and handler
 * dispatcher. All handlers are invoked from this class. This class is immutable.
     * 
     * @param exceptionEventEvent
     *            exception to be invoked
     * @param beanManager
     *            active bean manager
     * @throws Throwable
     *             If a handler requests the exception to be re-thrown.
            final BeanManager beanManager) throws Throwable
        // indentation with 8 for label needed by the current checkstyle rules
        inbound_cause:
    public static final String START_SCOPES_KEY = "deltaspike.scheduler.start_scopes_for_jobs";

            final String startScopes = ConfigResolver
                    .getPropertyValue(START_SCOPES_KEY, "true");
            if ("true".equalsIgnoreCase(startScopes))
            {
                this.scheduler.getListenerManager().addJobListener(new InjectionAwareJobListener());
            }
import org.apache.deltaspike.core.util.ProxyUtils;
import org.apache.deltaspike.jsf.impl.injection.proxy.ProxyMarker;

        if (result instanceof ProxyMarker || ProxyUtils.isProxiedClass(result.getClass()))
        {
            return result;
        }

        if (result instanceof ProxyMarker || ProxyUtils.isProxiedClass(result.getClass()))
        {
            return result;
        }
import java.lang.annotation.Annotation;
        @Observes ProcessAnnotatedType<X> pat, BeanManager beanManager)
        Bean<X> bean = new BeanBuilder<X>(beanManager).readFromType(pat.getAnnotatedType()).create();
        //veto normal converters/validators -> they will get excluded from the special handling later on
        if (!hasInjectionPoints(bean) && !hasNormalScopeAnnotation(bean, beanManager))
        {
            pat.veto();
            return;
        }

    protected <X> boolean hasInjectionPoints(Bean<X> bean)
    {
        return !bean.getInjectionPoints().isEmpty();
    }

    protected <X> boolean hasNormalScopeAnnotation(Bean<X> bean, BeanManager beanManager)
    {
        Class<? extends Annotation> scopeAnnotationClass = bean.getScope();
        return  scopeAnnotationClass != null && beanManager.isNormalScope(scopeAnnotationClass);
    }

    private static ThreadLocal<JobListenerContext> currentJobListenerContext = new ThreadLocal<JobListenerContext>();

            JobListenerContext jobListenerContext = new JobListenerContext();
            currentJobListenerContext.set(jobListenerContext);
            jobListenerContext.startContexts(scheduled);
            JobListenerContext jobListenerContext = currentJobListenerContext.get();
            if (jobListenerContext != null)
            {
                jobListenerContext.stopStartedScopes();
                currentJobListenerContext.set(null);
                currentJobListenerContext.remove();
            }
        }
    }

    private class JobListenerContext
    {
        private Stack<Class<? extends Annotation>> scopes = new Stack<Class<? extends Annotation>>();
        private ContextControl contextControl;

        public void startContexts(Scheduled scheduled)
        {
            Collections.addAll(this.scopes, scheduled.startScopes());

            if (!this.scopes.isEmpty())
            {
                this.contextControl = BeanProvider.getContextualReference(ContextControl.class);

                for (Class<? extends Annotation> scopeAnnotation : this.scopes)
                {
                    contextControl.startContext(scopeAnnotation);
                }
            }
        }

        private void stopStartedScopes()
        {

        if (annotationClass.isAnnotationPresent(Stereotype.class))
//ATTENTION: don't rename/move this class as long as we need the workaround in impl-ee6
//(further details are available at: DELTASPIKE-655 and DELTASPIKE-659)

//ATTENTION: don't rename/move this class as long as we need the workaround in impl-ee6
//(further details are available at: DELTASPIKE-655 and DELTASPIKE-659)

//ATTENTION: don't rename/move this class as long as we need the workaround in impl-ee6
//(further details are available at: DELTASPIKE-655 and DELTASPIKE-659)

 b/deltaspike/modules/partial-bean/impl/src/test/java/org/apache/deltaspike/test/core/api/partialbean/uc004/ApplicationScopedPartialBean.java
public abstract class ApplicationScopedPartialBean
 b/deltaspike/modules/partial-bean/impl/src/test/java/org/apache/deltaspike/test/core/api/partialbean/uc004/DependentScopedPartialBean.java
public abstract class DependentScopedPartialBean
import javax.enterprise.context.ApplicationScoped;
    protected void buildViewConfigMetaDataTree(@Observes final ProcessAnnotatedType pat)
        buildViewConfigMetaDataTreeFor(
            pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations(), new VetoCallback() {
                    @Override
                    public void veto()
                    {
                        pat.veto();
                    }
                });
    }

    protected void buildViewConfigMetaDataTreeFor(Class beanClass,
                                                  Set<Annotation> annotations,
                                                  VetoCallback vetoCallback)
    {
            addConfigClass(beanClass, annotations);
            vetoCallback.veto();
                addConfigClass(beanClass, annotations);
                vetoCallback.veto();
                addIndirectlyInheritedMetaData(beanClass, annotations);

                //needed for cdi 1.1 with bean-discovery-mode 'annotated'
                if (viewConfigClass.getAnnotation(ApplicationScoped.class) != null)
                {
                    Set<Class> manuallyDiscoveredViewConfigs = new HashSet<Class>();
                    findNestedClasses(viewConfigClass, manuallyDiscoveredViewConfigs);

                    for (Class foundClass : manuallyDiscoveredViewConfigs)
                    {
                        buildViewConfigMetaDataTreeFor(
                            foundClass,
                            new HashSet<Annotation>(Arrays.asList(foundClass.getAnnotations())),
                            new VetoCallback() {
                                @Override
                                public void veto()
                                {

                                }
                            });
                    }
                }
    private void findNestedClasses(Class viewConfigClass, Set<Class> nestedClasses)
    {
        for (Class nestedClass : viewConfigClass.getDeclaredClasses())
        {
            nestedClasses.add(nestedClass);
            findNestedClasses(nestedClass, nestedClasses);
        }
    }


    interface VetoCallback
    {
        void veto();
    }
        //don't use quartz.properties as default-value
            ConfigResolver.getPropertyValue("deltaspike.scheduler.quartz_config-file", "quartz");
    private AccessDeniedExceptionBroadcaster exceptionBroadcaster;
                    this.exceptionBroadcaster.broadcastAccessDeniedException(new AccessDeniedException(violations));
    private static final long serialVersionUID = 3585306529694592791L;

        ClassLoader currentClassLoader = ConfigResolver.class.getClassLoader();
        configSources.remove(ConfigResolver.class.getClassLoader());
        ClassLoader cl = ConfigResolver.class.getClassLoader();
        ClassLoader currentClassLoader = ConfigResolver.class.getClassLoader();
import org.apache.deltaspike.jsf.impl.message.JsfMessageResolver;
public class CustomMessageResolver extends JsfMessageResolver
    private static final long serialVersionUID = -7566133260553818285L;
import javax.faces.application.FacesMessage;
import java.util.ArrayList;
            List<FacesMessage> originalMessageList = new ArrayList<FacesMessage>(facesContext.getMessageList());
                for (FacesMessageEntry messageEntry : facesMessageEntryList)
                    if (isNewMessage(originalMessageList, messageEntry.getFacesMessage()))
                    {
                        facesContext.addMessage(messageEntry.getComponentId(), messageEntry.getFacesMessage());
                    }

    public static boolean isNewMessage(List<FacesMessage> facesMessages, FacesMessage messageToCheck)
    {
        for (FacesMessage facesMessage : facesMessages)
        {
            if ((facesMessage.getSummary() != null && facesMessage.getSummary().equals(messageToCheck.getSummary()) ||
                    facesMessage.getSummary() == null && messageToCheck.getSummary() == null) &&
                    (facesMessage.getDetail() != null && facesMessage.getDetail().equals(messageToCheck.getDetail()) ||
                        facesMessage.getDetail() == null && messageToCheck.getDetail() == null))
            {
                return false;
            }
        }
        return true;
    }
        if (parentClassLoader == null || parentClassLoader.equals(ClassLoader.getSystemClassLoader()))
import javax.inject.Inject;
import org.apache.deltaspike.core.api.common.DeltaSpike;
    @Inject
    @DeltaSpike
    private ServletContext servletContext;

        if (servletContext != null)
        {
            eventLog.add("ServletContext was injected");
        }
    private static final String SB_ADD_PARAMETER = "SB:"  JsfUtils.class  "#addParameter";
    
        StringBuilder finalUrl = SharedStringBuilder.get(SB_ADD_PARAMETER);
        finalUrl.append(url);
    private static final String CACHE_QUERY_URL_PARAMETERS =
            "CACHE:"  DefaultClientWindow.class  "#getQueryURLParameters";
    
            if (!facesContext.getAttributes().containsKey(CACHE_QUERY_URL_PARAMETERS))
                String windowId = getWindowId(facesContext);
                
                if (windowId == null)
                {
                    return null;
                }
                
                params.put(DELTASPIKE_WINDOW_ID_URL_PARAM, windowId);

                facesContext.getAttributes().put(CACHE_QUERY_URL_PARAMETERS, params);

            return (Map<String, String>) facesContext.getAttributes().get(CACHE_QUERY_URL_PARAMETERS);
     * It also allows to change the default handling.
        return originalException;

    /**
     * @return a new - dependent context control object.
     */
    ContextControl createContextControl();
import java.util.logging.Logger;
    private static final Logger LOG = Logger.getLogger(OpenEjbContainerControl.class.getName());


    @Override
    public ContextControl createContextControl()
    {
        BeanManager beanManager = getBeanManager();

        if (beanManager == null)
        {
            LOG.warning("If the CDI-container was started by the environment, you can't use this helper." 
                    "Instead you can resolve ContextControl manually " 
                    "(e.g. via BeanProvider.getContextualReference(ContextControl.class) ). " 
                    "If the container wasn't started already, you have to use CdiContainer#boot before.");

            return null;
        }
        Set<Bean<?>> beans = beanManager.getBeans(ContextControl.class);
        Bean<ContextControl> depCtxCtrlBean = (Bean<ContextControl>) beanManager.resolve(beans);

        CreationalContext<ContextControl> depCtxCtrlCreationalContext = getBeanManager()
                .createCreationalContext(ctxCtrlBean);

        return (ContextControl)
                getBeanManager().getReference(depCtxCtrlBean, ContextControl.class, depCtxCtrlCreationalContext);
    }

    @Override
    public ContextControl createContextControl()
    {
        BeanManager beanManager = getBeanManager();

        if (beanManager == null)
        {
            LOG.warning("If the CDI-container was started by the environment, you can't use this helper." 
                    "Instead you can resolve ContextControl manually " 
                    "(e.g. via BeanProvider.getContextualReference(ContextControl.class) ). " 
                    "If the container wasn't started already, you have to use CdiContainer#boot before.");

            return null;
        }
        Set<Bean<?>> beans = beanManager.getBeans(ContextControl.class);
        Bean<ContextControl> depCtxCtrlBean = (Bean<ContextControl>) beanManager.resolve(beans);

        CreationalContext<ContextControl> depCtxCtrlCreationalContext = getBeanManager()
                .createCreationalContext(ctxCtrlBean);

        return (ContextControl)
                getBeanManager().getReference(depCtxCtrlBean, ContextControl.class, depCtxCtrlCreationalContext);
    }

    @Override
    public ContextControl createContextControl()
    {
        BeanManager beanManager = getBeanManager();

        if (beanManager == null)
        {
            LOG.warning("If the CDI-container was started by the environment, you can't use this helper." 
                    "Instead you can resolve ContextControl manually " 
                    "(e.g. via BeanProvider.getContextualReference(ContextControl.class) ). " 
                    "If the container wasn't started already, you have to use CdiContainer#boot before.");

            return null;
        }
        Set<Bean<?>> beans = beanManager.getBeans(ContextControl.class);
        Bean<ContextControl> depCtxCtrlBean = (Bean<ContextControl>) beanManager.resolve(beans);

        CreationalContext<ContextControl> depCtxCtrlCreationalContext = getBeanManager()
                .createCreationalContext(ctxCtrlBean);

        return (ContextControl)
                getBeanManager().getReference(depCtxCtrlBean, ContextControl.class, depCtxCtrlCreationalContext);
    }
            BeanManager beanManager = getBeanManager();

            if (beanManager == null)
            {
                LOG.warning("If the CDI-container was started by the environment, you can't use this helper." 
                        "Instead you can resolve ContextControl manually " 
                        "(e.g. via BeanProvider.getContextualReference(ContextControl.class) ). " 
                        "If the container wasn't started already, you have to use CdiContainer#boot before.");

                return null;
            }
            Set<Bean<?>> beans = beanManager.getBeans(ContextControl.class);
            ctxCtrlBean = (Bean<ContextControl>) beanManager.resolve(beans);

            ctxCtrlCreationalContext = getBeanManager()
                    .createCreationalContext(ctxCtrlBean);

            Set<Bean<?>> beans = beanManager.getBeans(ContextControl.class);
            ctxCtrl.stopContexts();
            ctxCtrl.stopContexts();
            ctxCtrl.stopContexts();
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
            try
            {
                ctxCtrl.stopContexts();
            }
            catch (Exception e)
            {
                // contexts likely already stopped
            }
            try
            {
                ctxCtrl.stopContexts();
            }
            catch (Exception e)
            {
                // contexts likely already stopped
            }
            try
            {
                ctxCtrl.stopContexts();
                ctxCtrlBean.destroy(ctxCtrl, ctxCtrlCreationalContext);
            }
            catch (Exception e)
            {
                // contexts likely already stopped
            }
        try
        {
            weld.shutdown();
        }
        catch (Exception e)
        {
            // something caused weld to shutdown already.
        }
 * Base test for testing embedded servlet runtimes.
        if (context == null || context.getResponseComplete())
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
import org.apache.deltaspike.jsf.impl.util.SecurityUtils;
import org.apache.deltaspike.security.api.authorization.AccessDeniedException;
import org.apache.deltaspike.security.api.authorization.ErrorViewAwareAccessDeniedException;
                if (rootCause instanceof AccessDeniedException)
                    processAccessDeniedException(rootCause);
                    continue;
                }
                else
                {
                    ExceptionToCatchEvent event = new ExceptionToCatchEvent(rootCause, exceptionQualifier);
                    event.setOptional(true);

                    beanManager.fireEvent(event);

                    if (event.isHandled())
                    {
                        iterator.remove();
                    }
        return JsfUtils.getRootCause(throwable);
                if (exception instanceof AccessDeniedException)
                    processAccessDeniedException(exception);
                }
                else
                {
                    ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(exception);
                    exceptionToCatchEvent.setOptional(true);

                    this.beanManager.fireEvent(exceptionToCatchEvent);

                    if (exceptionToCatchEvent.isHandled())
                    {
                        return;
                    }

    private void processAccessDeniedException(Throwable throwable)
    {
        if (throwable instanceof ErrorViewAwareAccessDeniedException)
        {
            SecurityUtils.handleSecurityViolationWithoutNavigation((AccessDeniedException) throwable);
        }
        else
        {
            ErrorViewAwareAccessDeniedException securityException =
                new ErrorViewAwareAccessDeniedException(
                    ((AccessDeniedException)throwable).getViolations(), DefaultErrorView.class);
            SecurityUtils.handleSecurityViolationWithoutNavigation(securityException);
        }
    }
import org.apache.deltaspike.core.util.ExceptionUtils;
            broadcastAccessDeniedException(accessDeniedException);

    protected void broadcastAccessDeniedException(ErrorViewAwareAccessDeniedException accessDeniedException)
    {
        AccessDeniedExceptionBroadcaster exceptionBroadcaster =
            BeanProvider.getContextualReference(AccessDeniedExceptionBroadcaster.class);

        Throwable broadcastResult = exceptionBroadcaster.broadcastAccessDeniedException(accessDeniedException);

        if (broadcastResult != null)
        {
            throw ExceptionUtils.throwAsRuntimeException(broadcastResult);
        }
    }

import javax.el.ELException;
import javax.faces.FacesException;
import java.lang.reflect.InvocationTargetException;

    public static Throwable getRootCause(Throwable throwable)
    {
        while ((ELException.class.isInstance(throwable) || FacesException.class.isInstance(throwable) ||
                InvocationTargetException.class.isInstance(throwable)) && throwable.getCause() != null)
        {
            throwable = throwable.getCause();
        }

        return throwable;
    }

import org.apache.deltaspike.data.api.AbstractEntityRepository;
        if (isVetoed(event.getAnnotatedType()))
        {
            event.veto();
        }

        else if (isRepository(event.getAnnotatedType()))
    private <X> boolean isVetoed(AnnotatedType<X> annotated)
    {
        return annotated.getJavaClass().equals(AbstractEntityRepository.class);
    }

                    if (cl.getParent() != null)
                    {
                        bmpSingleton.bmInfos.put(cl.getParent(), bmi);
                    }
    <P extends Comparable<? super P>> Criteria<C, R> lt(SingularAttribute<? super C, P> att, P value);
    <P extends Comparable<? super P>> Criteria<C, R> gt(SingularAttribute<? super C, P> att, P value);
    public <P extends Comparable<? super P>> Criteria<C, R> lt(SingularAttribute<? super C, P> att, P value)
    public <P extends Comparable<? super P>> Criteria<C, R> gt(SingularAttribute<? super C, P> att, P value)
public class GreaterThan<E, V extends Comparable<? super V>> extends SingleValueBuilder<E, V>
        return Arrays.asList(builder.greaterThan(path.get(getAtt()), getValue()));
public class LessThan<E, V extends Comparable<? super V>> extends SingleValueBuilder<E, V>
        return Arrays.asList(builder.lessThan(path.get(getAtt()), getValue()));
import java.util.Date;
    public List<Simple> findByTimeBetween(Date from, Date to) {
        return criteria()
                 .gt(Simple_.temporal, from)
                 .lt(Simple_.temporal, to)
                 .getResultList();
    }

    <X> QuerySelection<E, X> attribute(SingularAttribute<? super E, X> attribute);
    <N extends Number> QuerySelection<E, N> abs(SingularAttribute<? super E, N> attribute);
    <N extends Number> QuerySelection<E, N> avg(SingularAttribute<? super E, N> attribute);
    QuerySelection<E, Long> count(SingularAttribute<? super E, ?> attribute);
    QuerySelection<E, Long> countDistinct(SingularAttribute<? super E, ?> attribute);
    <N extends Number> QuerySelection<E, N> max(SingularAttribute<? super E, N> attribute);
    <N extends Number> QuerySelection<E, N> min(SingularAttribute<? super E, N> attribute);
    <N extends Number> QuerySelection<E, N> neg(SingularAttribute<? super E, N> attribute);
    <N extends Number> QuerySelection<E, N> sum(SingularAttribute<? super E, N> attribute);
    QuerySelection<E, Integer> modulo(SingularAttribute<? super E, Integer> attribute, Integer modulo);
    QuerySelection<E, String> upper(SingularAttribute<? super E, String> attribute);
    QuerySelection<E, String> lower(SingularAttribute<? super E, String> attribute);
    QuerySelection<E, String> substring(SingularAttribute<? super E, String> attribute, int from);
    QuerySelection<E, String> substring(SingularAttribute<? super E, String> attribute, int from, int length);
    public AttributeQuerySelection(SingularAttribute<? super P, X> attribute)
    protected final SingularAttribute<? super P, X> attribute;
    public SingularAttributeSelection(SingularAttribute<? super P, X> attribute)
    public SingularAttribute<? super P, X> getAttribute()
    public Abs(SingularAttribute<? super P, X> attribute)
    public Avg(SingularAttribute<? super P, X> attribute)
    private final SingularAttribute<? super P, ?> attribute;
    public Count(SingularAttribute<? super P, ?> attribute)
    private final SingularAttribute<? super P, ?> attribute;
    public CountDistinct(SingularAttribute<? super P, ?> attribute)
    public Max(SingularAttribute<? super P, X> attribute)
    public Min(SingularAttribute<? super P, X> attribute)
    public Modulo(SingularAttribute<? super P, Integer> attribute, Integer modulo)
    public Neg(SingularAttribute<? super P, X> attribute)
    public Sum(SingularAttribute<? super P, X> attribute)
    public Lower(SingularAttribute<? super P, String> attribute)
    public SubstringFrom(SingularAttribute<? super P, String> attribute, int from)
    public SubstringFromTo(SingularAttribute<? super P, String> attribute, int from, int length)
    public Upper(SingularAttribute<? super P, String> attribute)
    public <X> QuerySelection<E, X> attribute(SingularAttribute<? super E, X> attribute)
    public <N extends Number> QuerySelection<E, N> abs(SingularAttribute<? super E, N> attribute)
    public <N extends Number> QuerySelection<E, N> avg(SingularAttribute<? super E, N> attribute)
    public QuerySelection<E, Long> count(SingularAttribute<? super E, ?> attribute)
    public QuerySelection<E, Long> countDistinct(SingularAttribute<? super E, ?> attribute)
    public <N extends Number> QuerySelection<E, N> max(SingularAttribute<? super E, N> attribute)
    public <N extends Number> QuerySelection<E, N> min(SingularAttribute<? super E, N> attribute)
    public <N extends Number> QuerySelection<E, N> neg(SingularAttribute<? super E, N> attribute)
    public <N extends Number> QuerySelection<E, N> sum(SingularAttribute<? super E, N> attribute)
    public QuerySelection<E, Integer> modulo(SingularAttribute<? super E, Integer> attribute, Integer modulo)
    public QuerySelection<E, String> upper(SingularAttribute<? super E, String> attribute)
    public QuerySelection<E, String> lower(SingularAttribute<? super E, String> attribute)
    public QuerySelection<E, String> substring(SingularAttribute<? super E, String> attribute, int from)
    public QuerySelection<E, String> substring(SingularAttribute<? super E, String> attribute, int from, int length)
public class Simple extends SuperSimple
import org.apache.deltaspike.data.test.domain.SuperSimple_;
    public Simple findBySuperName(String superName) {
        return criteria()
                 .eq(SuperSimple_.superName, superName)
                 .getSingleResult();
    }

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
            try
            {
                if (errorViewDescriptor != null && View.NavigationMode.REDIRECT ==
                        .isAlwaysUseNavigationHandlerOnSecurityViolation())
                {
                    SecurityUtils.tryToHandleSecurityViolation(accessDeniedException);
                    errorView = errorViewDescriptor.getConfigClass();
                }
                else
                {
                    errorView = SecurityUtils.handleSecurityViolationWithoutNavigation(accessDeniedException);
                }
            finally
                broadcastAccessDeniedException(accessDeniedException);
import java.util.Date;
    
    private Date lastTimeLinkAction;

    public Date getLastTimeLinkAction()
    {
        return lastTimeLinkAction;
    }

    public void linkAction()
    {
        FacesContext context = FacesContext.getCurrentInstance();
        System.out.println("ViewActionController#linkAction with windowId: "  clientWindow.getWindowId(context));
        lastTimeLinkAction = new Date();
    }
import javax.faces.FacesException;
import java.lang.reflect.InvocationTargetException;
        try
            if (proceedMethod != null)
            {
                return proceedMethod.invoke(target, arguments);
            }
            return this.handlerInstance.invoke(target, method, arguments);
        catch (InvocationTargetException e)
        {
            if (e.getCause() instanceof FacesException)
            {
                throw e.getCause();
            }
            throw e;
        }
import javax.enterprise.inject.Stereotype;
        List<Annotation> viewMetaDataFromStereotype = new ArrayList<Annotation>();

            //TODO move to stereotype-util, improve it and merge it with DefaultViewConfigInheritanceStrategy
            if (annotation.annotationType().isAnnotationPresent(Stereotype.class))
            {
                for (Annotation metaAnnotation : annotation.annotationType().getAnnotations())
                {
                    if (metaAnnotation.annotationType().isAnnotationPresent(ViewMetaData.class))
                    {
                        viewMetaDataFromStereotype.add(metaAnnotation);
                    }
                }
            }
        //merge meta-data of same level
        List<Annotation> result = mergeAnnotationInstances(viewMetaDataFromStereotype, nodeViewMetaData);

        if (inheritedMetaData != null && !inheritedMetaData.isEmpty())
            //merge meta-data with levels above
            result = mergeAnnotationInstances(inheritedMetaData, result);
        return result;
    }

    private List<Annotation> mergeAnnotationInstances(List<Annotation> inheritedMetaData, List<Annotation> nodeMetaData)
    {
                Annotation currentNodeMetaData = findInResult(nodeMetaData, inheritedAnnotation);
        mergedResult.addAll(0, nodeMetaData);
import javax.servlet.http.Cookie;
import org.apache.deltaspike.jsf.impl.util.ClientWindowHelper;
        
        // see #729
        Object cookie = ClientWindowHelper.getRequestWindowIdCookie(context, windowId);
        if (cookie != null && cookie instanceof Cookie)
        {
            Cookie servletCookie = (Cookie) cookie;
            ClientWindowHelper.removeRequestWindowIdCookie(context, servletCookie);
            writer.write("window.deltaspikeInitialRedirectWindowId='"  servletCookie.getValue()  "';");
        }
import java.util.HashMap;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletResponse;
{    
    public static final String REQUEST_WINDOW_ID_COOKIE_PREFIX = "dsrwid-";
        // see #729
        addRequestWindowIdCookie(facesContext, newWindowId);

    
    public static void addRequestWindowIdCookie(FacesContext context, String windowId)
    {
        Map<String, Object> properties = new HashMap();
        properties.put("path", "/");
        properties.put("maxAge", 30);

        context.getExternalContext().addResponseCookie(
                REQUEST_WINDOW_ID_COOKIE_PREFIX  windowId, windowId, properties);
    }
    
    public static Object getRequestWindowIdCookie(FacesContext context, String windowId)
    {
        Map<String, Object> cookieMap = context.getExternalContext().getRequestCookieMap();
        
        if (cookieMap.containsKey(REQUEST_WINDOW_ID_COOKIE_PREFIX  windowId))
        {
            return cookieMap.get(REQUEST_WINDOW_ID_COOKIE_PREFIX  windowId);
        }
        
        return null;
    }
    
    public static void removeRequestWindowIdCookie(FacesContext context, Cookie cookie)
    {
        cookie.setMaxAge(0);
        ((HttpServletResponse) context.getExternalContext().getResponse()).addCookie(cookie);
    }
        List<Class<? extends AccessDecisionVoter>> voterClasses = new ArrayList<Class<? extends AccessDecisionVoter>>();
                voterClasses.addAll(Arrays.asList(((Secured) annotation).value()));
        invokeVoters(invocationContext, voterClasses);
        if (accessDecisionVoters.isEmpty())
 * Annotation a = AnnotationInstanceProvider.of(annotationClass)
import javax.enterprise.inject.spi.AnnotatedMethod;
import java.util.HashSet;
            Set<Annotation> annotations = new HashSet<Annotation>();
            annotations.addAll(annotated.getAnnotations());

            for (AnnotatedMethod annotatedMethod :
                (Set<javax.enterprise.inject.spi.AnnotatedMethod>)((AnnotatedType) annotated).getMethods())
            {
                annotations.addAll(annotatedMethod.getAnnotations());
            }

                beanManager, annotations, origin.getName()))
        while (cls != null && !cls.equals(Object.class))
import javax.enterprise.inject.Typed;

        if (type.isAnnotationPresent(Typed.class))
            Typed typed = type.getAnnotation(Typed.class);
            this.types.addAll(Arrays.asList(typed.value()));

        else
            for (Class<?> c = type.getJavaClass(); c != Object.class && c != null; c = c.getSuperclass())
            {
                this.types.add(c);
            }
            for (Class<?> i : type.getJavaClass().getInterfaces())
            {
                this.types.add(i);
            }
        }        
        List<ConfigSource> appConfigSources = sortAscending(Arrays.<ConfigSource> asList(getConfigSources()));
            String value = configSource.getPropertyValue(key);
        List<ConfigSource> appConfigSources = sortAscending(Arrays.<ConfigSource> asList(getConfigSources()));
        if (value == null || value.isEmpty())
            for (Map.Entry<?, ?> entry : p.entrySet())
                if (!ConfigSource.DELTASPIKE_ORDINAL.equals(key))
            String beanName = named == null ? null : named.value();
    Class<?> value();
        protected Descriptor(Class<?> beanClass, Class<? extends Annotation> callbackType)
    protected CallbackDescriptor(Class<?> beanClass, Class<? extends Annotation> callbackMarker)
    protected CallbackDescriptor(Class<?>[] beanClasses, Class<? extends Annotation> callbackMarker)
    protected void init(Class<?>[] targetBeanClasses, Class<? extends Annotation> callbackMarker)
        for (Class<?> targetBeanClass : targetBeanClasses)
    public Map<Class<?>, List<Method>> getCallbackMethods()
        Map<Class<?>, List<Method>> result = new HashMap<Class<?>, List<Method>>(this.callbacks.size());
    protected <T> T getTargetObject(Class<T> targetType)
        private CallbackEntry(Class<?> beanClass, Class<? extends Annotation> callbackMarker)
                                                  Class<?> classToAnalyze,
            Class<?> currentClass = classToAnalyze;
                for (Class<?> interfaceClass : currentClass.getInterfaces())
    @SuppressWarnings("rawtypes")
    //TODO <T extends ExecutableCallbackDescriptor<?>> when major version is incremented
    @SuppressWarnings("rawtypes")
    //TODO <T extends ExecutableCallbackDescriptor<?>> when major version is incremented
    protected ExecutableCallbackDescriptor(Class<?> beanClass, Class<? extends Annotation> callbackMarker)
    protected ExecutableCallbackDescriptor(Class<?>[] beanClasses, Class<? extends Annotation> callbackMarker)
                    @SuppressWarnings("unchecked")
    Class<? extends TargetViewConfigProvider<?>> targetViewConfigProvider();
    @SuppressWarnings("rawtypes")
    protected SimpleCallbackDescriptor(Class<?> beanClass, Class<? extends Annotation> callbackMarker)
    protected SimpleCallbackDescriptor(Class<?>[] beanClasses, Class<? extends Annotation> callbackMarker)
    ConfigDescriptor<?> getConfigDescriptor(Class<?> configClass);
    @SuppressWarnings("rawtypes")
    @SuppressWarnings("rawtypes")
    private static BeanManagerProvider bmpSingleton;
        private BeanManager loadTimeBm;
        private BeanManager finalBm;
        private boolean booted;
        bmi.loadTimeBm = beanManager;
        bmpSingleton.bmInfos.remove(ClassUtils.getClassLoader(null));
        BeanManagerInfo parentBmi = getParentBeanManagerInfo(ClassUtils.getClassLoader(null));

    private static final boolean LOG_DEPENDENT_WARNINGS =
            Arrays.asList(ProjectStage.Development, ProjectStage.UnitTest).contains(
                    ProjectStageProducer.getInstance().getProjectStage());
     * @param qualifiers additional qualifiers which further distinguish the resolved bean
     * This method is intended for usage where the BeanManager is known, e.g. in Extensions.
     * @param qualifiers additional qualifiers which further distinguish the resolved bean
        return getContextualReference(type, beanManager, Collections.<Bean<?>> singleton(bean));
        @SuppressWarnings("unchecked")
        Bean<T> bean = (Bean<T>) beanManager.resolve(beans);
        return createDependentProvider(beanManager, type, bean);
        @SuppressWarnings("unchecked")
        Bean<T> bean = (Bean<T>) beanManager.resolve(beans);
        @SuppressWarnings("unchecked")
        Class<T> beanClass = (Class<T>) bean.getBeanClass();
        return createDependentProvider(beanManager, beanClass, bean);
        @SuppressWarnings("unchecked")
            @SuppressWarnings("unchecked")
            Bean<T> beanT = (Bean<T>) bean;
            result.add(beanT);
        CreationalContext<T> creationalContext = beanManager.createCreationalContext(null);
        AnnotatedType<T> annotatedType = beanManager.createAnnotatedType((Class<T>) instance.getClass());
        InjectionTarget<T> injectionTarget = beanManager.createInjectionTarget(annotatedType);
        for (Bean<?> currentBean : beans)

    @SuppressWarnings("unchecked")
            String beanName;
            if (named == null)
            {
                beanName = null;
            }
            else
            {
                beanName = named.value();
            }
    private static final boolean LOG_DEPENDENT_WARNINGS;
    static
    {
        LOG_DEPENDENT_WARNINGS =
                Arrays.asList(ProjectStage.Development, ProjectStage.UnitTest).contains(
                        ProjectStageProducer.getInstance().getProjectStage());
    }
            if (beanClass.getMethod("get"  name) != null || beanClass.getMethod("is"  name) != null)
        // must use a new list because Arrays.asList() is resistant to sorting on some JVMs:
        List<ConfigSource> appConfigSources = sortAscending(new ArrayList<ConfigSource>(
                Arrays.<ConfigSource> asList(getConfigSources())));
        // must use a new list because Arrays.asList() is resistant to sorting on some JVMs:
        List<ConfigSource> appConfigSources = sortAscending(new ArrayList<ConfigSource>(
                Arrays.<ConfigSource> asList(getConfigSources())));
    interface RedirectedPages extends ViewConfig
    interface SecuredPages extends ViewConfig
    interface ViewConfigFolder extends ViewConfig
        class RedirectedPage implements RedirectedPages
        class ViewConfigPage implements RedirectedPages
        class NavigationParameterPage implements RedirectedPages
        class SecuredPage implements SecuredPages
        class AllowedPage implements ViewConfig
                .addPackages(true, "javassist")

    @Override
    public String toString()
    {
        return "MockHttpSession{" 
                "sessionId='"  sessionId  '\'' 
                '}';
    }
            ctxCtrl = null;
import java.util.WeakHashMap;
import java.util.concurrent.atomic.AtomicInteger;

    private static WeakHashMap<ContextsService, AtomicInteger> sessionRefCounters
        = new WeakHashMap<ContextsService, AtomicInteger>();

        incrementSessionRefCount(contextsService);
        if (decrementSessionRefCount(contextsService))
        {
            contextsService.endContext(SessionScoped.class, mockSession);
        }


    private synchronized void incrementSessionRefCount(ContextsService contextsService)
    {
        AtomicInteger sessionRefCounter = sessionRefCounters.get(contextsService);
        if (sessionRefCounter == null)
        {
            sessionRefCounter = new AtomicInteger(1);
            sessionRefCounters.put(contextsService, sessionRefCounter);
        }
        else
        {
            sessionRefCounter.incrementAndGet();
        }
    }

    /**
     * @return true if the refCounter is back to zero
     */
    private synchronized boolean decrementSessionRefCount(ContextsService contextsService)
    {
        AtomicInteger sessionRefCounter = sessionRefCounters.get(contextsService);
        if (sessionRefCounter == null)
        {
            return false;
        }

        return sessionRefCounter.decrementAndGet() <= 0;
    }

import javax.enterprise.inject.Instance;
import java.util.concurrent.atomic.AtomicInteger;
    private static ThreadLocal<RequestContextHolder> requestContexts = new ThreadLocal<RequestContextHolder>();

    private Instance<BoundRequestContext> requestContextFactory;
    private AtomicInteger sessionRefCounter = new AtomicInteger(0);
    synchronized void startSessionScope()
        sessionRefCounter.incrementAndGet();
    synchronized void stopSessionScope()
            if (sessionRefCounter.decrementAndGet() <= 0)
            {
                sessionMap = null;
            }
    synchronized void startConversationScope(String cid)
        RequestContextHolder rcHolder = requestContexts.get();
        if (rcHolder == null)
        {
            startRequestScope();
            rcHolder = requestContexts.get();
        }
        conversationContext.associate(new MutableBoundRequest(rcHolder.requestMap, sessionMap));
    synchronized void stopConversationScope()
        RequestContextHolder rcHolder = requestContexts.get();
        if (rcHolder == null)
        {
            startRequestScope();
            rcHolder = requestContexts.get();
        }
            conversationContext.dissociate(new MutableBoundRequest(rcHolder.getRequestMap(), sessionMap));
    synchronized void startRequestScope()
        RequestContextHolder rcHolder = requestContexts.get();
        if (rcHolder == null)
            rcHolder = new RequestContextHolder(requestContextFactory.get(), new HashMap<String, Object>());
            requestContexts.set(rcHolder);
        rcHolder.getBoundRequestContext().associate(rcHolder.getRequestMap());
        rcHolder.getBoundRequestContext().activate();
    synchronized void stopRequestScope()
        RequestContextHolder rcHolder = requestContexts.get();
        if (rcHolder != null && rcHolder.getBoundRequestContext().isActive())
            rcHolder.getBoundRequestContext().invalidate();
            rcHolder.getBoundRequestContext().deactivate();
            rcHolder.getBoundRequestContext().dissociate(rcHolder.getRequestMap());
            requestContexts.set(null);
            requestContexts.remove();
        }
    }

    private static class RequestContextHolder
    {
        private final BoundRequestContext boundRequestContext;
        private final Map<String, Object> requestMap;

        private RequestContextHolder(BoundRequestContext boundRequestContext, Map<String, Object> requestMap)
        {
            this.boundRequestContext = boundRequestContext;
            this.requestMap = requestMap;
        }

        public BoundRequestContext getBoundRequestContext()
        {
            return boundRequestContext;
        }

        public Map<String, Object> getRequestMap()
        {
            return requestMap;
        getContextController().startApplicationScope();
        getContextController().startSessionScope();
        getContextController().startConversationScope(null);
        getContextController().startRequestScope();
        getContextController().stopApplicationScope();
        getContextController().stopSessionScope();
        getContextController().stopConversationScope();
        getContextController().stopRequestScope();
        getContextController().stopSingletonScope();
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.spi.scope.window.WindowContextQuotaHandler;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import org.apache.deltaspike.core.util.ProxyUtils;
import org.apache.deltaspike.core.util.context.ContextualStorage;
import javax.annotation.PostConstruct;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;

    @Inject
    private WindowContextQuotaHandler windowContextQuotaHandler;

    private boolean windowContextQuotaHandlerEnabled;

    @PostConstruct
    protected void init()
    {
        Class<? extends Deactivatable> windowContextQuotaHandlerClass =
            ProxyUtils.getUnproxiedClass(windowContextQuotaHandler.getClass());

        this.windowContextQuotaHandlerEnabled = ClassDeactivationUtils.isActivated(windowContextQuotaHandlerClass);
    }

    @Override
    public ContextualStorage getContextualStorage(BeanManager beanManager, String key, boolean createIfNotExist)
    {
        ContextualStorage result = super.getContextualStorage(beanManager, key, createIfNotExist);
        if (this.windowContextQuotaHandlerEnabled)
        {
            //only check it once the storage was created successfully
            this.windowContextQuotaHandler.checkWindowContextQuota(key);
        }
        return result;
    }
    /**
     * Restricts the number of active windows.
     *
     * @return limit for active windows
     */
    int getMaxWindowContextCount();
import org.apache.deltaspike.core.api.config.ConfigResolver;
    private int maxWindowContextCount;

        String maxCount = ConfigResolver.getPropertyValue("deltaspike.scope.window.max-count", ""  64);
        this.maxWindowContextCount = Integer.parseInt(maxCount);

    @Override
    public int getMaxWindowContextCount()
    {
        return this.maxWindowContextCount;
    }
import org.apache.deltaspike.core.spi.scope.viewaccess.ViewAccessContextManager;
import javax.enterprise.context.spi.Contextual;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.Typed;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.PassivationCapable;
import java.lang.annotation.Annotation;
import java.util.Map;

@Typed()
public class ViewAccessContext extends AbstractContext implements ViewAccessContextManager
        close(view, false);
    }

    public void close(String view, boolean force)
    {

        if (force || !view.equals(viewAccessViewHistory.getLastView()))
            destroyExpiredBeans(force);
    private void destroyExpiredBeans(boolean force)
                if (force || !viewAccessBeanAccessHistory.getAccessedBeans().contains((String) storageEntry.getKey()))

    @Override
    public void close()
    {
        close(null, true);
    }

    /*enough for the integer generated by #generateNewWindowId - see DELTASPIKE-752 */
    private static final int SECURE_ID_LENGTH = 10;

        String windowId = getOrCreateWindowId(facesContext);

        if (windowId != null && windowId.length() > SECURE_ID_LENGTH)
        {
            windowId = windowId.substring(0, SECURE_ID_LENGTH);
        }
        return windowId;
    }

    protected String getOrCreateWindowId(FacesContext facesContext)
    {
import org.apache.deltaspike.jsf.impl.scope.window.DefaultClientWindow;

        //already ensured by DefaultClientWindow
        //just to ensure that we don't get a security issue in case of a customized client-window implementation
        //will never happen usually -> no real overhead
        if (windowId != null && windowId.length() > DefaultClientWindow.SECURE_ID_LENGTH)
        {
            windowId = windowId.substring(0, DefaultClientWindow.SECURE_ID_LENGTH);
        }

    /*enough for the integer generated by #generateNewWindowId - see DELTASPIKE-752 */
    public static final int SECURE_ID_LENGTH = 10;

    private ViewConfigResolver viewConfigResolver;

        lazyInit();
                        entry = this.viewConfigResolver.getDefaultErrorViewConfigDescriptor();
                        entry = this.viewConfigResolver
        return this.viewConfigResolver.getViewConfigDescriptor(navigateEvent.getToView());
        ViewConfigDescriptor oldViewConfigDescriptor = this.viewConfigResolver.getViewConfigDescriptor(oldViewId);
    private void lazyInit()
    {
        if (this.beanManager == null)
        {
            init();
        }
    }

    private synchronized void init()
            this.viewConfigResolver =
                    BeanProvider.getContextualReference(ViewConfigResolver.class);
                if (targetUrl.contains("dswid=&"))
                {
                    //remove empty dswid parameter
                    targetUrl = targetUrl.replace("dswid=&", "");
                }
        //TODO check if it isn't better to fix addRequestParameters itself
        url = facesContext.getExternalContext().encodeActionURL(url);

        //only #encodeResourceURL is portable currently
        url = facesContext.getExternalContext().encodeResourceURL(url);
    private int maxWindowIdCount = 10;
        if (windowId != null && windowId.length() > this.maxWindowIdCount)
            windowId = windowId.substring(0, this.maxWindowIdCount);
                    maxWindowIdCount = ClientWindowHelper.getMaxWindowIdLength();
import javax.annotation.PostConstruct;
    private int maxWindowIdCount = 10;


    @PostConstruct
    protected void init()
    {
        this.maxWindowIdCount = ClientWindowHelper.getMaxWindowIdLength();
    }
        if (windowId != null && windowId.length() > this.maxWindowIdCount)
            windowId = windowId.substring(0, this.maxWindowIdCount);
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.deltaspike.core.api.config.ConfigResolver;
{
    private static final Logger LOG = Logger.getLogger(ClientWindowHelper.class.getName());


    public static int getMaxWindowIdLength()
    {
        //10 is enough for the integer generated by DefaultClientWindow#generateNewWindowId - see DELTASPIKE-752
        int result = Integer.parseInt(ConfigResolver.getPropertyValue("deltaspike.window-id.max_length", ""  10));

        if (result > 10)
        {
            if (LOG.isLoggable(Level.WARNING))
            {
                LOG.warning("ATTENTION: if you change this value to be significant longer than 10, " 
                    "you can introduce a security issue in WindowIdHtmlRenderer. " 
                    "If you increase it because window.name contains a value already, " 
                    "please revisit that usage or " 
                    "create shorter unique ids since they just need to be unique within the user-session.");
            }
        }
        return result;
    }
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.deltaspike.data.impl.util.cl.AggregatedClassLoader;
    private static final Logger log = Logger.getLogger(DescriptorReader.class.getName());
            try
            {
                result.add(readFromUrl(u));
            }
            catch (Exception e)
            {
                log.log(Level.WARNING, "Could not load "  resource  " from "  u, e);
            }
        catch (Exception e)
        return AggregatedClassLoader.newInstance();
        catch (Exception e)
 * The respective integration code will provide a &064;Dependent scoped instance
 * which itself is stateless.
 *
 * The {@link #startContext(Class)} and {@link #stopContext(Class)} only affect
 * the current Thread. When leaving a Thread each started context needs to get
 * stopped as well (best practice is to do that in a <i>finally</i> block.
 *
 * If a container supports controlling the Session Context then each Thread will
 * get a new 'dummy' storage assigned. It is not intended to 'attach' to a real
 * Session but to allow the re-use of existing beans.
 *
 * Many containers make heavy use of ThreadLocals. Thus it might be necessary to
 * call
 * <pre>
 *     contextControl.startContext(ApplicationScoped.class);
 * </pre>
 * to 'attach' or 'activate' the ApplicationContext within your current Thread.
        return container.getContextControl();
    /**
     * we cannot directly link to MockHttpSession as this would lead to
     * NoClassDefFound errors for cases where no servlet-api is on the classpath.
     * E.g in pure SE environments.
     */
    private static ThreadLocal<Object> mockSessions = new ThreadLocal<Object>();

            mockSession = mockSessions.get();
            if (mockSession == null)
            {
                // we simply use the ThreadName as 'sessionId'
                mockSession = OwbHelper.getMockSession(Thread.currentThread().getName());
                mockSessions.set(mockSession);
            }
            mockSession = mockSessions.get();
            mockSessions.set(null);
            mockSessions.remove();
        contextsService.endContext(SessionScoped.class, mockSession);
    public static Object getMockSession(String sessionId)
        return new MockHttpSession(sessionId);
import javax.enterprise.inject.Instance;
import java.util.HashMap;
import java.util.Map;
import org.jboss.weld.context.AbstractSharedContext;
import org.jboss.weld.context.ApplicationContext;
import org.jboss.weld.context.bound.BoundConversationContext;
import org.jboss.weld.context.bound.BoundRequestContext;
import org.jboss.weld.context.bound.BoundSessionContext;
import org.jboss.weld.context.bound.MutableBoundRequest;
    private static ThreadLocal<RequestContextHolder> requestContexts = new ThreadLocal<RequestContextHolder>();
    private static ThreadLocal<Map<String, Object>> sessionMaps = new ThreadLocal<Map<String, Object>>();


    private ApplicationContext applicationContext;

    @Inject
    private BoundSessionContext sessionContext;

    @Inject
    private Instance<BoundRequestContext> requestContextFactory;

    @Inject
    private BoundConversationContext conversationContext;


        startConversationScope(null);
            startConversationScope(null);
        // Welds ApplicationContext is always active
        // No need to attach any ThreadLocals...
    }

    private void stopApplicationScope()
    {
        // Welds ApplicationContext gets cleaned at shutdown.
        //X TODO if we really drop the context then we might trash EE
        //X if we do not do it then we loose the ability to cleanup ApplicationScoped beans
        if (applicationContext.isActive())
        {
            applicationContext.invalidate();

            //needed for weld < v1.1.9
            if (applicationContext instanceof AbstractSharedContext)
            {
                ((AbstractSharedContext) applicationContext).getBeanStore().clear();
            }
        }
    }

    void startRequestScope()
    {
        RequestContextHolder rcHolder = requestContexts.get();
        if (rcHolder == null)
        {
            rcHolder = new RequestContextHolder(requestContextFactory.get(), new HashMap<String, Object>());
            requestContexts.set(rcHolder);
        }
        else
        {
            throw new IllegalStateException(RequestScoped.class.getName()  " started already");
        }

        rcHolder.getBoundRequestContext().associate(rcHolder.getRequestMap());
        rcHolder.getBoundRequestContext().activate();
    }

    void stopRequestScope()
    {
        RequestContextHolder rcHolder = requestContexts.get();
        if (rcHolder != null && rcHolder.getBoundRequestContext().isActive())
        {
            rcHolder.getBoundRequestContext().invalidate();
            rcHolder.getBoundRequestContext().deactivate();
            rcHolder.getBoundRequestContext().dissociate(rcHolder.getRequestMap());
            requestContexts.set(null);
            requestContexts.remove();
        }
        Map<String, Object> sessionMap = sessionMaps.get();
        if (sessionMap == null)
        {
            sessionMap = new HashMap<String, Object>();
            sessionMaps.set(sessionMap);
        }
        sessionContext.associate(sessionMap);
        sessionContext.activate();
        if (sessionContext.isActive())
            sessionContext.invalidate();
            sessionContext.deactivate();
            sessionContext.dissociate(sessionMaps.get());

            sessionMaps.set(null);
            sessionMaps.remove();
        }
    }

    void startConversationScope(String cid)
    {
        RequestContextHolder rcHolder = requestContexts.get();
        if (rcHolder == null)
        {
            startRequestScope();
            rcHolder = requestContexts.get();
        }
        conversationContext.associate(new MutableBoundRequest(rcHolder.requestMap, sessionMaps.get()));
        conversationContext.activate(cid);
    }

    void stopConversationScope()
    {
        RequestContextHolder rcHolder = requestContexts.get();
        if (rcHolder == null)
        {
            startRequestScope();
            rcHolder = requestContexts.get();
        }
        if (conversationContext.isActive())
        {
            conversationContext.invalidate();
            conversationContext.deactivate();
            conversationContext.dissociate(new MutableBoundRequest(rcHolder.getRequestMap(), sessionMaps.get()));
        }
    }


    private static class RequestContextHolder
    {
        private final BoundRequestContext boundRequestContext;
        private final Map<String, Object> requestMap;

        private RequestContextHolder(BoundRequestContext boundRequestContext, Map<String, Object> requestMap)
        {
            this.boundRequestContext = boundRequestContext;
            this.requestMap = requestMap;
        public BoundRequestContext getBoundRequestContext()
        {
            return boundRequestContext;
        }
        public Map<String, Object> getRequestMap()
        {
            return requestMap;
        }
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import org.apache.deltaspike.core.api.config.ConfigResolver;
import javax.enterprise.inject.Produces;
import javax.enterprise.inject.spi.AnnotatedField;
        if (!isMockSupportEnabled(annotated))
        {
            return false;
        }

    protected boolean isMockSupportEnabled(Annotated annotated)
    {
        if ((annotated instanceof AnnotatedMethod || annotated instanceof AnnotatedField) &&
                annotated.getAnnotation(Produces.class) != null)
        {
            return Boolean.parseBoolean(ConfigResolver.getPropertyValue(
                "deltaspike.testcontrol.mock-support.allow_mocked_producers", Boolean.FALSE.toString()));
        }
        return true;
    }

        else
        {
            return Boolean.parseBoolean(ConfigResolver.getPropertyValue(
                "deltaspike.testcontrol.mock-support.allow_mocked_beans", Boolean.FALSE.toString()));
        }
import org.apache.deltaspike.core.api.config.ConfigResolver;
        //check if this method gets used without changing the default-config
        if (!Boolean.parseBoolean(ConfigResolver.getPropertyValue(
            "deltaspike.testcontrol.mock-support.allow_mocked_beans", Boolean.FALSE.toString())) &&
                !Boolean.parseBoolean(ConfigResolver.getPropertyValue(
                    "deltaspike.testcontrol.mock-support.allow_mocked_producers", Boolean.FALSE.toString())))
        {
            throw new IllegalStateException("The support for mocked CDI-Beans is disabled " 
                "due to a reduced portability across different CDI-implementations. " 
                "Please set 'deltaspike.testcontrol.mock-support.allow_mocked_beans' and/or " 
                "'deltaspike.testcontrol.mock-support.allow_mocked_producers' to 'true' " 
                "(in 'META-INF/apache-deltaspike.properties') on your test-classpath.");
        }


        try
        {
            shutdown();
        }
        finally
        {
            cdiContainer.shutdown(); //also calls #stopContexts
        }
        return getContextualReference(getBeanManager(), name, optional, type);
    }

    /**
     * <p>Get a Contextual Reference by its EL Name.
     * This only works for beans with the &#064;Named annotation.</p>
     *
     * <p><b>Attention:</b> please see the notes on manually resolving &#064;Dependent bean
     * in {@link #getContextualReference(Class, boolean, java.lang.annotation.Annotation...)}!</p>
     *
     *
     * @param beanManager the BeanManager to use
     * @param name the EL name of the bean
     * @param optional if <code>true</code> it will return <code>null</code> if no bean could be found or created.
     *                 Otherwise it will throw an {@code IllegalStateException}
     * @param type the type of the bean in question - use {@link #getContextualReference(String, boolean)}
     *             if the type is unknown e.g. in dyn. use-cases
     * @param <T> target type
     * @return the resolved Contextual Reference
     */
    public static <T> T getContextualReference(BeanManager beanManager, String name, boolean optional, Class<T> type)
    {
                    if (cl.getParent() != null && !bmpSingleton.bmInfos.containsKey(cl.getParent()))
import java.lang.reflect.Method;
import java.util.logging.Level;
import org.apache.deltaspike.core.api.config.ConfigResolver;
    //for CDI 1.1 delegation
    private static final Method CDI_CURRENT_METHOD;
    private static final Method CDI_CURRENT_BEAN_MANAGER_METHOD;

    static
    {
        Class cdiClass = ClassUtils.tryToLoadClassForName("javax.enterprise.inject.spi.CDI");

        Method resolvedCdiCurrentMethod = null;
        Method resolvedCdiBeanManagerMethod = null;
        //only init methods if a cdi 1.1 container is available and the delegation-mode isn't deactivated.
        //deactivation is e.g. useful if owb is used in "parallel mode" in a weld-based server.
        if (cdiClass != null && !"false".equalsIgnoreCase(
            ConfigResolver.getPropertyValue("deltaspike.bean-manager.delegate_to_container", Boolean.TRUE.toString())))
        {

            try
            {
                resolvedCdiCurrentMethod = cdiClass.getDeclaredMethod("current");
                resolvedCdiBeanManagerMethod = cdiClass.getDeclaredMethod("getBeanManager");
            }
            catch (Exception e)
            {
                LOG.log(Level.SEVERE, "Couldn't get method from "  cdiClass.getName(), e);
            }
        }

        //null if no init happened e.g. due to CDI 1.0 or deactivated delegation-mode
        CDI_CURRENT_METHOD = resolvedCdiCurrentMethod;
        CDI_CURRENT_BEAN_MANAGER_METHOD = resolvedCdiBeanManagerMethod;
    }

        BeanManager result = resolveBeanManagerViaStaticHelper();

        if (result != null)
        {
            return result;
        }

        result = bmi.finalBm;
    private BeanManager resolveBeanManagerViaStaticHelper()
    {
        if (CDI_CURRENT_METHOD != null && CDI_CURRENT_BEAN_MANAGER_METHOD != null)
        {
            try
            {
                Object cdiCurrentObject = CDI_CURRENT_METHOD.invoke(null);
                return (BeanManager) CDI_CURRENT_BEAN_MANAGER_METHOD.invoke(cdiCurrentObject);
            }
            catch (Throwable t)
            {
                LOG.log(Level.FINEST, "failed to delegate bean-manager lookup -> fallback to default.", t);
            }
        }
        return null;
    }

            ConfigResolver.getPropertyValue("deltaspike.bean-manager.delegate_to_container", Boolean.FALSE.toString())))
            ConfigResolver.getPropertyValue("deltaspike.bean-manager.delegate_to_container", Boolean.TRUE.toString())))
        BeanManager result = bmi.finalBm;
                    // needs to be here to get a better performance and
                    // even in ee7 containers we can't rely on that lookup as a primary strategy
                    // (esp. in case of EAR based applications)
                    if (result == null)
                    {
                        result = resolveBeanManagerViaStaticHelper();
                    }

            ConfigResolver.getPropertyValue("deltaspike.bean-manager.delegate_lookup", Boolean.TRUE.toString())))
        FacesContext facesContext = FacesContext.getCurrentInstance();

        if (facesContext == null) // can happen in case of a very simple test-setup without a mocked jsf container
        {
            return false;
        }
        String configuredWindowHandling = facesContext.getExternalContext()
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.jsf.impl.util.JsfUtils;

        if (JsfUtils.isViewScopeDelegationEnabled())
        {
            this.mappedJsfScopes.put(javax.faces.bean.ViewScoped.class,
                ClassUtils.tryToLoadClassForName("javax.faces.view.ViewScoped"));
        }
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
        if (isActivated)
        {
            //this extension is only needed if the cdi-based view-scope handling isn't delegated to jsf 2.2
            isActivated = !JsfUtils.isViewScopeDelegationEnabled();
        }

import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.util.ClassUtils;

    /**
     * @return true if JSF 2.2 is available and the delegation mode isn't deactivated via config, false otherwise
     */
    public static boolean isViewScopeDelegationEnabled()
    {
        return ClassUtils.tryToLoadClassForName("javax.faces.view.ViewScoped") != null && !"false".equalsIgnoreCase(
            ConfigResolver.getPropertyValue("deltaspike.scope.view.delegate", Boolean.TRUE.toString()));
    }
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
        boolean jsfVersionWithClientWindowDetected =
            ClassUtils.tryToLoadClassForName(JsfModuleConfig.CLIENT_WINDOW_CLASS_NAME) != null;

        if (jsfVersionWithClientWindowDetected && ClassUtils.tryToLoadClassForName(
            "org.apache.deltaspike.jsf.impl.listener.request.JsfClientWindowAwareLifecycleWrapper") == null)
        {
            jsfVersionWithClientWindowDetected = false;
            JsfUtils.logWrongModuleUsage(getClass().getName());
        }
        this.jsfVersionWithClientWindowDetected = jsfVersionWithClientWindowDetected;
                return (Lifecycle) lifecycleWrapperClass.getConstructor(new Class[] { Lifecycle.class })
import org.apache.deltaspike.jsf.impl.util.JsfUtils;

            if (navigationHandlerWrapperClass != null)
            {
                manualNavigationHandlerWrapperMode = false;
            }
            else
            {
                JsfUtils.logWrongModuleUsage(NavigationHandlerAwareApplication.class.getName());
                manualNavigationHandlerWrapperMode = true;
            }
import java.util.logging.Level;
import java.util.logging.Logger;

    public static void logWrongModuleUsage(String name)
    {
        Logger.getLogger(name).log(
            Level.WARNING, "You are using the JSF module for JSF 2.0/2.1 with JSF 2.2 which " 
                "might cause issues in your application in different areas. Please upgrade " 
                    "org.apache.deltaspike.modules:deltaspike-jsf-module-impl-ee6 to " 
                        "org.apache.deltaspike.modules:deltaspike-jsf-module-impl");
    }
 * Common qualifier to manage co-existence of DeltaSpike features and Java EE features.
 * This Qualifier allows simple injection of configuration properties through the DeltaSpike configuration 
 * mechanism.
 * <p>
 * A default implementation is provided in DeltaSpike for basic String injection points:
 * <p>
 * It's possible to use config properties in a type-safe manner, which requires a custom producer:
 *   &#064;Target({FIELD, METHOD})
 *   public &#064;interface Location {
 *  <pre>
 *   public class CustomConfigPropertyProducer extends BaseConfigPropertyProducer {
 *     public String produceLocationId(InjectionPoint injectionPoint) {
 *       if (configuredValue == null) {
 * </p>
 * <p>
 * Producers can be implemented to support other types of injection points:
 * <pre>
 *   &#064;Inject
 *   &#064;Location
 *   private LocationId locationId;
 * </pre>
 *   public class CustomConfigPropertyProducer extends BaseConfigPropertyProducer {
 *     public LocationId produceLocationId(InjectionPoint injectionPoint) {
 *       if (configuredValue == null) {
 * </p>
 * For custom producer implementations, {@link org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer} can
 * be used as the base class.
 * 
     * This constant is a workaround for the java restriction that Annotation values cannot be set to null. Do not use
     * this String in your configuration.
     * Name/key of the property.
     *
 * The main entry point to the DeltaSpike configuration mechanism.
 * <p>
 * Resolves configured values of properties by going through the list of configured {@link ConfigSource}s and using the
 * one with the highest ordinal. If multiple {@link ConfigSource}s have the same ordinal, their order is undefined.</p>
 *
 * <p>
 * You can provide your own lookup paths by implementing and registering additional {@link PropertyFileConfig} or
 *
 * <p>
 * The resolved configuration is also accessible by simple injection using the {@link ConfigProperty} qualifier.</p>
 *
 * @see <a href="http://deltaspike.apache.org/documentation/configuration.html">DeltaSpike Configuration Mechanism</a>
     * Clear all ConfigSources for the current ClassLoader.
     * Add a {@link ConfigFilter} to the ConfigResolver. This will only affect the current WebApp (or more precisely the
     * current ClassLoader and it's children).
     *
     * {@link #getPropertyValue(java.lang.String)} which returns the provided default value if no configured value can
     * be found (<code>null</code> or empty).
     * @param key          the property key
     * @param defaultValue fallback value
     *
     * @return the configured property value from the {@link ConfigSource} with the highest ordinal or the defaultValue
     *         if there is no value explicitly configured
     * Resolves the value configured for the given key.
     * @param key the property key
     *
     * @return the configured property value from the {@link ConfigSource} with the highest ordinal or null if there is
     *         no configured value for it
     * Resolves the value configured for the given key in the current
     * {@link org.apache.deltaspike.core.api.projectstage.ProjectStage}.
     * <p>
     * First, it will search for a value configured for the given key suffixed with the current ProjectStage (e.g.
     * 'myproject.myconfig.Production'), and in case this value is not found (null or empty), it will look up the given
     * key without any suffix.</p>
     * <p>
     * <b>Attention</b> This method must only be used after all ConfigSources got registered and it also must not be
     * used to determine the ProjectStage itself.</p>
     *
     *
     * @return the value configured for {@code <given key>.<current project stage>}, or just the configured value of
     *         {@code <given key>} if the project-stage-specific value is not found (null or empty)
     * {@link #getProjectStageAwarePropertyValue(String)} which returns the provided default value if no configured
     * value can be found (<code>null</code> or empty).
     *
     * @param defaultValue fallback value
     *
     * Resolves the value configured for the given key, parameterized by the current
     * {@link org.apache.deltaspike.core.api.projectstage.ProjectStage} and by the value of a second property.
     * <p>
     * <b>Example:</b><br/>
     * Suppose the current ProjectStage is {@code UnitTest} and we are looking for the value of {@code datasource}
     * parameterized by the configured {@code dbvendor}.
     * </p>
     * <p>
     * The first step is to resolve the value of the second property, {@code dbvendor}. This will also take the current
     * ProjectStage into account. The following lookup is performed:
     * <ul><li>dbvendor.UnitTest</li></ul>
     * and if this value is not found then we will do a 2nd lookup for
     * <ul><li>dbvendor</li></ul></p>
     * <p>
     * If a value was found for the second property (e.g. dbvendor = 'mysql') then we will use its value for the main
     * lookup. If no value is found for the parameterized key {@code <key>.<second property value>.<project stage>}, we
     * will do the {@code <key>.<second property value>}, then {@code <key>.<project stage>} and finally a {@code <key>}
     * lookup:
     * <li>datasource.mysql.UnitTest</li>
     * <li>datasource.mysql</li>
     * <li>datasource.UnitTest</li>
     * <li>datasource</li>
     * <p>
     * <b>Attention</b> This method must only be used after all ConfigSources got registered and it also must not be
     * used to determine the ProjectStage itself.</p>
     * @param property the property to look up first and use as the parameter for the main lookup
     *
     * @return the configured value or null if no value is found for any of the key variants
    /**
     * {@link #getPropertyAwarePropertyValue(java.lang.String, java.lang.String)} which returns the provided default
     * value if no configured value can be found (<code>null</code> or empty).
     *
     * <p>
     * <b>Attention</b> This method must only be used after all ConfigSources got registered and it also must not be
     * used to determine the ProjectStage itself.</p>
     *
     * @param property     the property to look up first and use as the parameter for the main lookup
     * @param defaultValue fallback value
     *
     */
     * Resolve all values for the given key.
     * @param key
     *
     * @return a List of all found property values, sorted by their ordinal in ascending order
     *
    /**
     * Returns a Map of all properties from all scannable config sources. The values of the properties reflect the
     * values that would be obtained by a call to {@link #getPropertyValue(java.lang.String)}, that is, the value of the
     * property from the ConfigSource with the highest ordinal.
     *
     * @see ConfigSource#isScannable()
     */
 * Marker interface for all classes used for configuration of DeltaSpike itself.
 * <p>
 * All DeltaSpike configuration objects implement this interface so they can be found more easily. There is no other
 * <p>
 * DeltaSpike uses a <i>type-safe configuration</i> approach. Instead of writing a properties file or XML, you just
 * implement one of the configuration interfaces which will then be picked up as a CDI bean. If there is already a
 * default configuration for some functionality in DeltaSpike, you can use &#064;Specializes or &#064;Alternative to
 * change those.</p>
 * <p>
 * If you implement this interface inside a Bean Archive (a JAR or ClassPath entry with a META-INF/beans.xml file), the
 * property files with the given file name will be registered as
 * {@link org.apache.deltaspike.core.spi.config.ConfigSource}s.</p>
 * <p>
 * DeltaSpike will automatically pick up all the implementations during the
 * {@link javax.enterprise.inject.spi.ProcessAnnotatedType} phase and create a new instance via reflection. Thus the
 * implementations will need a non-private default constructor. There is <b>no</b> CDI injection being performed in
 * those instances! The scope of the implementations will also be ignored as they will not get picked up as CDI
 * beans.</p>
 * <p>
 * Please note that the configuration will only be available after the boot is finished. This means that you cannot use
 * this configuration inside a CDI Extension before the boot is finished!</p>
     * All the property files on the classpath which have this name will get picked up and registered as
 * Utility class to load configuration properties via arbitrary property files in a well defined order.
 * <p>
 * This will also pick up property files with names suffixed with {@code -<project stage>}, e.g.
 * myconfig-Production.properties.</p>
 * <p>
 * User configurations should have {@code deltaspike_ordinal} as the first property, with a value greater than
 * 100.</p>
     * Looks for all properties files with the given name in the classpath, loads them in ascending order determined by
     * their ordinal and merges them.
     * <p>
     * The idea is to be able to override properties by just providing a new properties file with the same name but a
     * higher 'deltaspike_ordinal' than the old one.</p>
     * <p>
     * If a property file defines no 'deltaspike_ordinal' property than a default value of
     * {@link #CONFIGURATION_ORDINAL_DEFAULT_VALUE} is assumed. Any sensitive default which is provided by the system
     * parsing for the configuration should have a 'deltaspike_ordinal' value lower than 10. In most cases a value of
     * 1.</p>
     * <p>
     * If two property files have the same 'deltaspike_ordinal', their order is undefined. The Properties file which
     * gets found first will be processed first and thus gets overwritten by the one found later.</p>
     *
     * Determine the 'deltaspike_ordinal' of the given properties.
 *
 * It's an abstract class instead of an interface, because it can be used for navigation (which is restricted to
 * classes).
 * Marker interface for type-safe view-config classes. Required for view-configs which represent a (logical) page and
 * optional for the rest (e.g. folder-configs).
 * A reference to a view-config, applied on a view-controller. The opposite direction of {@link ViewControllerRef}.
 *
 * ViewRef annotation instances are not present at runtime as metadata, they are instead transformed to
 * ViewControllerRef instances during deployment.
     * Specifies the views to bind to the view-controller.
     * @return {@link ViewConfig}s of views bound to the view-controller
 * Callback annotation for view-controllers. Methods annotated with this annotation will be invoked as soon as a view
 * has been initialized.
 * Callback annotation for view-controllers. Methods annotated with this annotation will be invoked after the view gets
 * rendered.
 * Callback annotation for view-controllers. Methods annotated with this annotation will be invoked before the view gets
 * rendered.
 * Callback annotation for view-controllers. Methods annotated with this annotation will be invoked before the method
 * binding gets invoked. Can be used as a callback in a view-controller in parallel with 3rd party flow-engines.
/**
 * Specifies one or more view-controllers for the view-config which has this annotation applied. View-controllers can
 * handle callbacks like {@link InitView}, {@link PreRenderView}, etc.
 */
     * Class of the view-controller.
     * @return class of the view-controller
     * Currently not implemented. 
     * Optional name of the view-controller.
     * @return name of the view-controller
 * Marks view-metadata annotations or their fields as aggregated metadata. That results in retention of multiple
 * instances of such annotation per view instead of the metadata getting overriden by lower levels.
 *
 * Core just provides this annotation, but the concrete behaviour is defined by a concrete ConfigNodeConverter. E.g.
 * DefaultConfigNodeConverter uses the result stored in
 * {@link org.apache.deltaspike.core.spi.config.view.ViewConfigNode#getInheritedMetaData} to replace default- (/ null-)
 * values of "higher" levels with custom values of "lower" levels, if #value is 'true'.
//TODO re-visit and discuss method-level (for annotation-attributes)
@Target({ ANNOTATION_TYPE })
     * @return false to override the same metadata type of the parent view-config, and true to allow multiple instances
     *         of a metadata per view
 * Basic descriptor for a given class and callback type. It finds and caches the method(s) of the given class which are
 * annotated with the given callback-type.
 * Base descriptor for all type-safe view-configs which describes the config class, metadata, callbacks and other
 * properties of a view-config.
 *
 * @param <CT> class of the view-config
public interface ConfigDescriptor<CT>
     * Metadata configured for this view-config. Resolves {@link ViewMetaData}-annotated annotations which are inherited
     * or directly present on the view-config class.
     * @return metadata of this view-config
     * Metadata which is configured for this view-config. Resolves {@link ViewMetaData}-annotated annotations which are
     * inherited or directly present on the view-config class.
     *
     * @return custom metadata for the given type of this view-config
     * Callbacks which are configured for this view-config and bound to the given metadata type.
     *
     * @param metaDataType type of the metadata (e.g. ViewControllerRef.class)
     *
     * @return descriptor for the callback or null if there is no callback method
     * Callbacks which are configured for this view-config and bound to the given metadata type.
     *
     * @param metaDataType type of the metadata (e.g. ViewControllerRef.class)
     *
     * Callbacks which are configured for this view-config and bound to the given metadata type.
     *
     * @param metaDataType type of the metadata (e.g. ViewControllerRef.class)
     * @param executorType type of the executor which returns a typed result (e.g. Secured.Descriptor)
     *
     * @return executable descriptor for the callback or null if there is no callback method
     * Callbacks which are configured for this view-config and bound to the given metadata type.
     *
     * @param metaDataType type of the metadata (e.g. ViewControllerRef.class)
     * @param executorType type of the executor which returns a typed result (e.g. Secured.Descriptor)
     *
     * @return executable descriptor for the callback or null if there is no callback method
     * Returns the string representation of the resource (page, folder) represented by this view-config.
     *
/**
 * A ConfigDescriptor can contain CallbackDescriptors or ExecutableCallbackDescriptors. An ExecutableCallbackDescriptor
 * can reference one or more callback method(s). If there is only one callback type, it's possible to annotate it with
 * {@code @DefaultCallback}. That eliminates the need for a special marker annotation for the target method.
 *
 * If there are multiple callback types, it's necessary to use custom annotations as marker for the target method (e.g.
 * see {@code @Secured} vs. {@code @ViewControllerRef}).
 *
 * <pre>
 * {@code
 * ViewConfigDescriptor viewConfigDescriptor = viewConfigResolver.getViewConfigDescriptor(SomePage.class);
 *
 * viewConfigDescriptor.getExecutableCallbackDescriptor(
 *   Secured.class, Secured.Descriptor.class).execute(accessDecisionVoterContext);
 * }</pre> is short for
 * <pre>
 * {@code
 * viewConfigDescriptor.getExecutableCallbackDescriptor(
 *   Secured.class, DefaultCallback.class, Secured.Descriptor.class).execute(accessDecisionVoterContext);
 * }</pre>
 *
 * whereas e.g.
 * <pre>
 * {@code
 * viewConfigDescriptor.getExecutableCallbackDescriptor(
 *   ViewControllerRef.class, PreRenderView.class, ViewControllerRef.Descriptor.class).execute();
 * }</pre> or just
 * <pre>
 * {@code
 * viewConfigDescriptor.getExecutableCallbackDescriptor(
 *   ViewControllerRef.class, PreRenderView.class, SimpleCallbackDescriptor.class).execute();
 * }</pre> are needed to call @PreRenderView callbacks specifically (instead of the others like @InitView which are also
 * bound to @ViewControllerRef).
 */
//TODO find a better name
public @interface DefaultCallback 
 * Specialized {@link CallbackDescriptor} which provides {@link #execute} only for concrete descriptors, but doesn't
 * expose it (and can't get used by accident). Concrete implementations can provide type-safe versions of it, but
 * delegate the final execution to {@link #execute}.
/**
 * Provides the ability to apply metadata to a view-config "remotely" &ndash; from a
 * different place than the view-config itself (and with different syntax and a different annotation).
 *
 * <p>
 * <b>For example</b>, the @ViewControllerRef (main) vs. @ViewRef (inline) &ndash; the @ViewControllerRef is applied
 * directly on a view-config and references a view-controller, but there's also @ViewRef, which has the same purpose,
 * but is applied in reverse &ndash; on a view-controller, referencing a view-config.
 * </p>
 */

 * {@link ExecutableCallbackDescriptor} for simple callback methods without (supported) parameters, which exposes
 * #execute without parameters.
/**
 * Disables metadata merging on attributes of @ViewMetaData annotations. Used in cases (e.g. @Folder#name) where it
 * doesn't make sense to merge that part with inherited information.
 */
 * Descriptor which represents a concrete view (page).
     * View ID of the current descriptor. The default implementation returns the same as ConfigDescriptor#getPath. For
     * the default implementation (and default integration with JSF) it's in place to provide a straightforward API.
     * @return current view ID
 * Resolver of view-configs.
 * A {@link ConfigDescriptor} can be bound to any config class (without required base type). That's needed e.g. for
 * folder-configs. Whereas {@link ViewConfigDescriptor}s only represent classes which inherit from {@link ViewConfig}
 * which is required for all view-configs.
 * Use {@link org.apache.deltaspike.core.spi.config.view.ViewConfigRoot} to register a custom resolver.
     * Resolves the {@link ConfigDescriptor} for the given class.
     * @param configClass config class which usually represents a folder node
     *
     * @return config descriptor which represents the given config class
     * Resolves all descriptors for folders.
     * @return all descriptors for the known folder-configs
     * Resolves the {@link ViewConfigDescriptor} for the given view-id.
     *
     * @return view-config descriptor which represents the given view-id, null otherwise
     * Resolves the {@link ViewConfigDescriptor} for the given view-config class.
     * @param viewDefinitionClass view-config class of the page
     *
     * @return view-config descriptor which represents the given view-config class
     * Resolves all descriptors for the known {@link ViewConfig}s.
     * Resolves the descriptor for the default error page.
     * @return descriptor for the default error page
 * Meta-annotation for custom metadata which can be applied to view-configs.
 *
 * By default, metadata of a lower level overrides metadata of the same type from a higher level (cascading behaviour).
 * This behaviour can be changed by annotating the target annotation (or only chosen fields of it) with
 * {@code @Aggregated(true)}.
 * Used on JSF action methods, this adds navigation parameters (key-value pairs) to the resulting navigation string.
 * Alternatively, {@link org.apache.deltaspike.core.api.config.view.navigation.NavigationParameterContext} can be used
 * to add the parameters.
     * Key of the parameter.
     * Value of the parameter, a plain String or an EL expression.
     * A container for multiple NavigationParameters.
         * One or more navigation parameters.
 * Can be used to add parameters dynamically to the final navigation string.
 * A type-safe {@link ViewConfig}-based NavigationHandler wrapper.
     * @param targetView the navigation target
 * This event is fired before a navigation from/to a view-config-based page occurs. With {@link #navigateTo(Class)} it's
 * possible to change the navigation target.
     * Constructor for creating the event for the given source and target view.
     * Changes the navigation target.
 * Marker annotation for a method to be considered an Exception Handler, handles the exception in the BEFORE traversal
 * of the exception chain.
 * <p>
 * Handlers methods typically have this form:<br />
 * <pre>public void handle(@BeforeHandles <i>@OptionalQualifier</i> ExceptionEvent&lt;<i>TypeOfTheException</i>&gt; evt)
 * </pre>.
 * </p>
 *
 * If a handler method has a return type, it is ignored.
     * Precedence relative to callbacks for the same type. Handler with a higher ordinal is invoked before a handler
     * with a lower ordinal.
 *
 * @see BeforeHandles
 * @see Handles
 * Enum of exception handling states. Used in the dispatcher to determine how to markHandled.
 * Metadata interface for an exception handler method. It is the responsibility of the
     * Obtains the precedence of the handler, relative to other handlers for the same type. Handler with a higher
     * ordinal is invoked before a handler with a lower ordinal.
 * Marker annotation for a method to be considered an Exception Handler.
 *
 * <p>
 * Handlers typically have this form:
 * <pre>
 * public void handle(@Handles <i>@OptionalQualifier</i> ExceptionEvent&lt;<i>TypeOfTheException</i>&gt; evt)</pre>
 * </p>
 *
 * If a handler method has a return type, it is ignored.
     * Precedence relative to handlers for the same type. Handler with a higher ordinal is invoked before a handler with
     * a lower ordinal.
 * Payload for an exception to be handled. Implementations of this interface should not expose internals and should
 * remain immutable.
 * Entry point event into the Exception Control system.  This object is nearly immutable, the only mutable portion
     * Test to see if the exception has already been processed by an
     * {@link org.apache.deltaspike.core.api.exception.control.ExceptionHandler}.
     * @return true if the exception has already been processed by a handler; false otherwise
 * <b>Examples:</b>
 * <br/>
 * <ul>
 * <li>
 * The following bean gets excluded in any case
 * </li>
 * <li>
 * The following bean gets excluded when the ProjectStage is 'Development'
 * </li>
 * <li>
 * The following bean gets excluded in every case except when then ProjectStage is 'Development'
 * </li>
 * <li>
 * The following bean gets excluded if the expression evaluates to true, which means there is a configured property
 * called 'myProperty' with the value 'myValue'
 * </li>
 * <li>The following bean gets excluded if the expression evaluates to true
 * <pre>
 * </pre>
 * </li>
 * </ul>
     * The {@link org.apache.deltaspike.core.api.projectstage.ProjectStage}s which lead to deactivating this bean. If
     * the current ProjectStage is in this list, the bean will get vetoed.
     *
     * The {@link org.apache.deltaspike.core.api.projectstage.ProjectStage}s which lead to activating this bean. If the
     * current ProjectStage is not in this list, the bean will get vetoed.
     *
     * Expression which signals if the annotated bean should be deactivated or not.
     *
 * Base implementation for simple (property) expressions.
 * Generic interface for evaluation of expressions, like the ones provided by
 * {@link org.apache.deltaspike.core.api.exclude.Exclude#onExpression()}.
 * 
 * @param <E> expression type
 * @param <R> result type
     * Evaluates the given expression and returns the result for it.
     *
     * @param expression expression to evaluate
     *
 * Operations supported by {@link BasePropertyExpressionInterpreter}.
 * Interface used to send JMX message from "CDI MBeans". It can only be used from CDI MBeans and should get injected in
 * other beans.
 * Describes a JMX operation or attribute, when used on a method or a field, respectively.
 * Used on a field it describes a JMX attribute. This attribute is readable if a getter on this field is available and
 * writable if a setter is found.
     * @return the category to use if no objectName was specified. Default is "org.apache.deltaspike" and can be
     *         overriden either directly by the value or by a key used to resolve a value using
     *         {@link org.apache.deltaspike.core.api.config.ConfigResolver}. It is a key if the value is between
     *         brackets. Default key is "org.apache.deltaspike.mbean.category".
     * @return the name of the bean used if no objectName was specified. It is used with category value to create the
     *         MBean {@link javax.management.ObjectName} using the following pattern:
     *         &lt;category&gt;:type=MBeans,name=&lt;name&gt;
 * Provides the current {@link java.util.Locale}.
 *
 * <p>
 * DeltaSpike provides a default implementation which returns the current system Locale.</p>
 * <p>
 * An application can provide custom implementation as an &#064;Alternative. This could e.g. examine a JSF View or the
 * Locale of any currently logged in User.</p>
 * Basic interface for all messages.
 * <p>
 * A <code>Message</code> is not a simple String but all the information needed to create those Strings for multiple
 * situations. The situation is determined by the used {@link MessageContext}.</p>
     * @param messageTemplate message key (or plain text) for the current message
     *
     * @return the current instance of the message builder to allow a fluent API
     *
     * @return the current instance of the message builder to allow a fluent API
     * Argument array. Similar to argument except it is meant to handle an array being passed in via a chain.
     *
     * @param arguments the arguments
     *
     * Argument. Similar to the other argument methods, this one handles collections.
     *
     * @param arguments the arguments
     *
     * @return the message key (or plain text) of the current message
     * Renders the Message to a String, using the {@link MessageContext} which created the Message.
     * Renders the Message to a String, using an arbitrary {@link MessageContext}.
     * Renders the Message to a String, using the {@link MessageContext} which created the Message. While resolving the
     * message we will first search for a messageTemplate with the given category by just adding an underscore '_' and
     * the category String to the {@link #getTemplate()}. If no such template exists we will fall back to the version
     * without the category String.
     * Renders the Message to a String, using an arbitrary {@link MessageContext}. While resolving the message we will
     * first search for a messageTemplate with the given category by just adding an underscore '_' and the category
     * String to the {@link #getTemplate()}. If no such template exists we will fall back to the version without the
     * category String.
 * Marker annotation for a message-bundle interface which provides type-safe messages.
 * <p>
 * This annotation must only be used on interfaces. If this annotation gets used on a concrete class, a deployment error
 * results!</p>
 * <p>
 * Each method on an interface annotated with <code>&#064;MessageBundle</code> will form a type-safe message. The
 * message lookup key (resource bundle key) can either be defined by annotating those methods with
 * &#064;{@link MessageTemplate}) or by convention. if no &#064;{@link MessageTemplate} annotation is used on a method,
 * the case sensitive method name name will be used as resource key.</p>
 * <p>
 * The parameters of the declared methods will be automatically passed as message parameters to the
 * {@link org.apache.deltaspike.core.api.message.MessageResolver}. Please note that all passed parameters should be
 * {@link java.io.Serializable}. If a parameter is not Serializable, we will instead store the <code>toString()</code>
 * <p>
 * The {@link java.util.ResourceBundle} or other resource lookup source which might be used is determined by the
 * {@link org.apache.deltaspike.core.api.message.MessageResolver} in conjunction with
 * {@link org.apache.deltaspike.core.api.message.MessageContext#messageSource(String...)}. The fully qualified class
 * name of the interface annotated with &#064;MessageBundle will automatically be registered as additional
 * <p>
 * <code>&#064;MessageBundle</code> can be combined with {@link MessageContextConfig} to further customize the
 * message resolution and processing.</p>
 * <p>
 * Debug hint: Set a breakpoint in <code>MessageBundleInvocationHandler#invoke</code>. This will get called for every
 * message bundle invocation.</p>
 * <br/>
 * Instances of this type are mutable but also {@link Cloneable}. If you need a new instance, then use
 * {@link Object#clone()}.
     * Clones the current MessageContext.
     * @return a message based on the current context modifiable via a fluent API
     * Configures a message source instance for use by a {@link MessageResolver}.
     *
     * @param messageSource message source to add
     *
     * @return list of registered message sources
 * Configures message resolution and processing of a {@link MessageBundle}.
     * <p>Additional message source.</p>
     * <p>A message source is a lookup hint for the {@link MessageResolver}. For the default MessageResolver this is the
     * name of the {@link java.util.ResourceBundle}.</p>
     * <p>Example: To use 2 additional ResourceBundles for the lookup, you can configure the MessageContextConfig like
     * this:
     * </pre>.
     * </p>
     *
     * {@link MessageResolver} to use for resolution of message templates to message text.
     *
     * @return class of the {@link MessageResolver} bean or the default marker
     * {@link MessageInterpolator} to use for interpolation of placeholders in the resolved text.
     *
     * @return class of the {@link MessageInterpolator} bean or the default marker
     * {@link LocaleResolver} providing the locale for message template resolution.
     *
     * @return class of the {@link LocaleResolver} bean or the default marker
 * Implementations are responsible to replace placeholders in a message with the final value.
 * <p>
 * An application can provide a custom implementation as &#064;Alternative.</p>
 * <p>
 * A simple implementation which uses the {@link String#format(java.util.Locale, String, Object...)} will be used by
 * default.</p>
     * Replaces the arguments of the given message with the given arguments.
     * @param arguments   a list of numbered and/or named arguments for the current message
     * @param locale      to use for the formatting
     *
     * @return the final (interpolated) message text if it was possible to replace the parameters with the given
     *         arguments, or the unmodified messageText otherwise
 * Implementations have to resolve the text stored for a given key in the message source they are aware of.
     * @param messageContext  messageContext which should be used
     * @param messageTemplate the message key (or inline text) of the current message
     * @param category        the category of the message, e.g. 'longText'. Can be <code>null</code>
     *
     * @return the final but not interpolated message text or <code>null</code> if an error happened or the resource
     *         could not be resolved.
 * Provides the message (template) for type-safe messages.
 * <p>
 * This only works on interfaces which are annotated with {@link MessageBundle}.</p>
 * <p>
 * Depending on the {@link org.apache.deltaspike.core.api.message.MessageResolver} this message template value might be
 * used as key to lookup internationalized values from a {@link java.util.ResourceBundle}.</p>
 * <p>
 * A MessageTemplate value which starts and ends with brackets '{', '}' will be interpreted as key for resolving from a
 * ResourceBundle or any other lookup mechanism determined by the
 * {@link org.apache.deltaspike.core.api.message.MessageResolver}. A small example:
 * </pre> This will lookup a <code>welcome_to = Hello to Aruba</code> from the configured resource bundle.
 * <p>
 * MessageTemplate values without '{', '}' bracelets will be directly used without resource lookup.</p>
 * This class is the base of all ProjectStages. A ProjectStage identifies the environment the application currently runs
 * in. It provides the same functionality as the JSF2 ProjectStage but has a few additional benefits:
 * <li>it works for JSF 1.0, JSF 1.1 and JSF 1.2 applications</li>
 * <li>it works in pure backends and unit tests without any JSF API</li>
 * <li>it is dynamic. Everyone can add their own ProjectStages!</li>
 * <p>
 * Technically this is kind of a 'dynamic enum'.</p>
 *
 * <p>
 * The following ProjectStages are provided by default:</p>
 * <li>UnitTest</li>
 * <li>Development</li>
 * <li>SystemTest</li>
 * <li>IntegrationTest</li>
 * <li>Staging</li>
 * <li>Production</li>
 * <p>
 * The following resolution mechanism is used to determine the current ProjectStage:</p>
 * <ul>
 * <li>TODO specify!</li>
 * </ul>
 * <p>
 * New ProjectStages can be added via the {@link java.util.ServiceLoader} mechanism. A class deriving from
 * {@link ProjectStage} must be provided and used for creating a single static instance of it.</p>
 *
 * <p>
 * Custom ProjectStages can be implemented by writing anonymous ProjectStage members into a registered
 * {@link ProjectStageHolder} as shown in the following example:</p>
 *
 *
 * <p>
 * To activate those ProjectStages, you have to register the ProjectStageHolder class to get picked up via the
 * ServiceLoader mechanism. Simply create a file
 * </pre> which contains the fully qualified class name of custom ProjectStageHolder implementation:
 *
 * <p>
 * You can use your own ProjectStages exactly the same way as all the ones provided by the system:
 * if (myOwnPs.equals(MyOwnProjectStage.MyOwnProjectStage)) ...
 * </p>
 * <p>
 * <b>Note:</b> DeltaSpike will only find {@link ProjectStageHolder}s which are accessible by this very class. If you
 * deploy the deltaspike-core jar to a shared EAR classloader, it will e.g. <i>not</i> be able to register ProjectStages
 * defined in a web application's WEB-INF/classes directory!
     * This function exists to prevent findbugs from complaining about
     * Exposes all registered {@link ProjectStage} implementations.
     *
     * @return provided and custom ProjectStage implementations
 * A marker interface for custom ProjectStage holders. A ProjectStage holder is a class which contains one or more
 * {@link ProjectStage}s.
 * <p>
 * Any custom ProjectStageHolder must get registered via the {@link java.util.ServiceLoader} mechanism. Simply create a
 * file
 * </pre> and write the fully qualified class name of your ProjectStageHolder into it.
 * This class provides access to the {@link BeanManager} by registering the current {@link BeanManager} in an extension
 * and making it available via a singleton factory for the current application.
 * <p>This is really handy when you need to access CDI functionality from places where no injection is available.</p>
 *
 * <p>If a simple but manual bean lookup is needed, it's easier to use the {@link BeanProvider}.</p>
 * 
 * <p>As soon as an application shuts down, the reference to the {@link BeanManager} is removed.</p>
 * 
 * <p>
 * Usage:

 * <pre>
 * BeanManager bm = BeanManagerProvider.getInstance().getBeanManager();</pre>
 * </p>
 * <p>
 * <b>Attention:</b> This approach is intended for use in user code at runtime. If BeanManagerProvider is used during
 * Container boot (in an Extension), non-portable behaviour results. During bootstrapping, an Extension shall
 * &#064;Inject BeanManager to get access to the underlying BeanManager (see e.g. {@link #cleanupFinalBeanManagers}).
 * This is the only way to guarantee that the right BeanManager is obtained in more complex Container scenarios.</p>
     * This data container is used for storing the BeanManager for each web application. This is needed in EAR or other
     * multi-webapp scenarios when the DeltaSpike classes (jars) are provided in a shared ClassLoader.
         * The BeanManager picked up via Extension loading.
         * The final BeanManager. After the container did finally boot, we first try to resolve them from JNDI, and only
         * if we don't find any BM there we take the ones picked up at startup.
         * Whether the CDI Application has finally booted. Please note that this is only a nearby value as there is no
         * reliable event for this status in EE6.
     * The BeanManagerInfo for the current ClassLoader.
     * 
     * Indicates whether the {@link BeanManagerProvider} has been initialized. Usually it's not necessary to call this
     * method in application code. It's useful e.g. for other frameworks to check if DeltaSpike and the CDI container in
     * general have been started.
     * @return true if the BeanManagerProvider is ready to be used
     * Returns the current provider instance which provides access to the current {@link BeanManager}.
     * @throws IllegalStateException if the {@link BeanManagerProvider} isn't ready to be used. That's the case if the
     *                               environment isn't configured properly and therefore the {@link AfterBeanDiscovery}
     *                               hasn't been called before this method gets called.
     * It doesn't really matter which of the system events is used to obtain the BeanManager, but
     * {@link AfterBeanDiscovery} has been chosen since it allows all events which occur after the
     * {@link AfterBeanDiscovery} to use the {@link BeanManagerProvider}.
     * The active {@link BeanManager} for the current application (current {@link ClassLoader}). This method will throw
     * an {@link IllegalStateException} if the BeanManager cannot be found.
     * @return the current BeanManager, never <code>null</code>
     *
     * By cleaning the final BeanManager map after the deployment gets validated, premature loading of information from
     * JNDI is prevented in cases where the container might not be fully setup yet.
     * This might happen if the BeanManagerProvider is used in an extension during CDI bootstrap. This should be
     * generally avoided. Instead, an injected BeanManager should be used in Extensions and propagated using setters.
     * In EARs with multiple webapps, each WAR might get a different Extension. This depends on the container used.
     * Cleanup on container shutdown.
     * @param beforeShutdown CDI shutdown event
     * Get or create the BeanManagerInfo for the given ClassLoader.
     * This function exists to prevent findbugs from complaining about setting a static member from a non-static
     * function.
     *
     * @return whether a BeanManagerInfo for a parent ClassLoader is available and has the booted flag set.
     * This method recurses into the parent ClassLoaders and checks whether a BeanManagerInfo for it exists.
     *
     * @return the BeanManagerInfo of the parent ClassLoader hierarchy if any exists, or <code>null</code> if there is
     *         no {@link BeanManagerInfo} for the ClassLoaders in the hierarchy.
 * This class contains utility methods for resolution of contextual references in situations where no injection is
 * available because the current class is not managed by the CDI Container. This can happen in e.g. a JPA 2.0
 * EntityListener, a ServletFilter, a Spring managed Bean, etc.
 * <p>
 * <b>Attention:</b> This approach is intended for use in user code at runtime. If BeanProvider is used during Container
 * boot (in an Extension), non-portable behaviour results. The CDI specification only allows injection of the
 * BeanManager during CDI container boot time.</p>
 * @see DependentProvider
     * Get a Contextual Reference by its type and qualifiers. You can use this method to get contextual references of a
     * given type. A "Contextual Reference" is a proxy which will automatically resolve the correct contextual instance
     * when you access any method.
     * <p>
     * <b>Attention:</b> You shall not use this method to manually resolve a &#064;Dependent bean! The reason is that
     * contextual instances usually live in the well-defined lifecycle of their injection point (the bean they got
     * injected into). But if we manually resolve a &#064;Dependent bean, then it does <b>not</b> belong to such well
     * defined lifecycle (because &#064;Dependent is not &#064;NormalScoped) and thus will not be automatically
     * Thus you also need to manually store the CreationalContext and the Bean you used to create the contextual
     * instance.</p>
     * @param type       the type of the bean in question
     * @param <T>        target type
     *
     *
     * {@link #getContextualReference(Class, Annotation...)} which returns <code>null</code> if the 'optional' parameter
     * is set to <code>true</code>.
     * @param type       the type of the bean in question
     * @param optional   if <code>true</code> it will return <code>null</code> if no bean could be found or created.
     *                   Otherwise it will throw an {@code IllegalStateException}
     * @param qualifiers additional qualifiers which distinguish the resolved bean
     * @param <T>        target type
     *
     *
     * {@link #getContextualReference(Class, Annotation...)} which returns <code>null</code> if the 'optional' parameter
     * is set to <code>true</code>. This method is intended for usage where the BeanManger is known, e.g. in Extensions.
     * @param type        the type of the bean in question
     * @param optional    if <code>true</code> it will return <code>null</code> if no bean could be found or created.
     *                    Otherwise it will throw an {@code IllegalStateException}
     * @param qualifiers  additional qualifiers which further distinct the resolved bean
     * @param <T>         target type
     *
     *
     * Get a Contextual Reference by its EL Name. This only works for beans with the &#064;Named annotation.
     * <p>
     * <b>Attention:</b> please see the notes on manually resolving &#064;Dependent beans in
     * {@link #getContextualReference(Class, java.lang.annotation.Annotation...)}!</p>
     * @param name the EL name of the bean
     *
     *
     * Get a Contextual Reference by its EL Name. This only works for beans with the &#064;Named annotation.
     * <p>
     * <b>Attention:</b> please see the notes on manually resolving &#064;Dependent beans in
     * {@link #getContextualReference(Class, java.lang.annotation.Annotation...)}!</p>
     *
     * Get a Contextual Reference by its EL Name. This only works for beans with the &#064;Named annotation.
     * <p>
     * <b>Attention:</b> please see the notes on manually resolving &#064;Dependent beans in
     * {@link #getContextualReference(Class, java.lang.annotation.Annotation...)}!</p>
     * @param name     the EL name of the bean
     * @param type     the type of the bean in question - use {@link #getContextualReference(String, boolean)} if the
     *                 type is unknown e.g. in dyn. use-cases
     * @param <T>      target type
     *
     * <p>
     * <b>Attention:</b> please see the notes on manually resolving &#064;Dependent beans in
     * {@link #getContextualReference(Class, java.lang.annotation.Annotation...)}!</p>
     *
     * @param bean bean definition for the contextual reference
     * @param <T>  target type
     *
     * Get a list of Contextual References by type, regardless of qualifiers (including dependent scoped beans).
     * You can use this method to get all contextual references of a given type. A 'Contextual Reference' is a proxy
     * which will automatically resolve the correct contextual instance when you access any method.
     * <p>
     * <b>Attention:</b> please see the notes on manually resolving &#064;Dependent beans in
     * {@link #getContextualReference(Class, java.lang.annotation.Annotation...)}!</p>
     * <p>
     * <b>Attention:</b> This will also return instances of beans for which an Alternative exists! The &#064;Alternative
     * resolving is only done via {@link BeanManager#resolve(java.util.Set)} which we cannot use in this case!</p>
     * @param type     the type of the bean in question
     * @param optional if <code>true</code> it will return an empty list if no bean could be found or created. Otherwise
     *                 it will throw an {@code IllegalStateException}
     * @param <T>      target type
     *
     * Get a list of Contextual References by type, regardless of the qualifier.
     * Further details are available at {@link #getContextualReferences(Class, boolean)}.
     * <p>
     * <b>Attention:</b> please see the notes on manually resolving &#064;Dependent bean in
     * {@link #getContextualReference(Class, java.lang.annotation.Annotation...)}!</p>
     * <p>
     * <b>Attention:</b> This will also return instances of beans for which an Alternative exists! The &#064;Alternative
     * resolving is only done via {@link BeanManager#resolve(java.util.Set)} which we cannot use in this case!</p>
     * @param type                      the type of the bean in question
     * @param optional                  if <code>true</code> it will return an empty list if no bean could be found or
     *                                  created. Otherwise it will throw an {@code IllegalStateException}
     * @param <T>                       target type
     *
     * Get a set of {@link Bean} definitions by type, regardless of qualifiers.
     * @param type                      the type of the bean in question
     * @param optional                  if <code>true</code> it will return an empty set if no bean could be found.
     *                                  Otherwise it will throw an {@code IllegalStateException}
     * @param includeDefaultScopedBeans specifies whether dependent scoped beans should be included in the result
     * @param <T>                       target type
     *
     * @return the resolved set of {@link Bean} definitions or an empty set if optional is true
     * Performs dependency injection on an instance. Useful for instances which aren't managed by CDI.
     * <b>Attention:</b><br/>
     * @param <T>      current type
     *
     * Log a warning if the given bean is of &#064;Dependent scope as we cannot properly clean up the contextual
     * instance afterwards.
     * Internal method to resolve the BeanManager via the {@link BeanManagerProvider}.
     *
     * @return current BeanManager
 * A {@link Provider} for &#064;Dependent scoped contextual instances. We need this to be able to properly clean them up
 * when they are not needed anymore via the {@link #destroy()} method.
 * Instances of this class are Serializable if the wrapped contextual instance is Serializable.
 *
 * @see BeanProvider#getDependent(java.lang.Class, java.lang.annotation.Annotation...)
 * A classpath-based resource provider.
 * A file-based resource provider, looking for a file based on the name.
/**
 * Qualifier which enables simple injection of resources into beans, eliminating the need to deal with their loading.
 *
 * <p>
 * <b>Example:</b>
 * <pre>
 * &#064;Inject
 * &#064;InjectableResource("myfile.properties")
 * private Properties props;
 *
 * &#064;Inject
 * &#064;InjectableResource("config.xml")
 * private InputStream inputStream;
 * </pre>
 *
 * This can be used to read files, from classpath or the file system, using two default implementations:
 * ClasspathResourceProvider and FileResourceProvider. They can be extended as well by implementing the
 * InjectableResourceProvider interface to allow reading from alternate sources, if needed (e.g. database LOBs, NoSQL
 * storage areas).
 * </p>
 */
/**
 * 
 * @see GroupedConversationScoped
 * @see ConversationSubGroup
 */
     * Class or interface which should be used as type-safe key for identification of the conversation group.
 * Represents a subgroup of a conversation group. Useful for closing a subset of {@code @GroupConversationScoped} beans
 * in a {@code ConversationGroup}.
 * <pre>
 *
 * &#064;ConversationScoped
 * &#064;ConversationGroup(MyGroup.class)
 *
 * &#064;ConversationScoped
 * &#064;ConversationGroup(MyGroup.class)
 *
 * &#064;ConversationScoped
 * &#064;ConversationGroup(MyGroup.class)
 *
 * &#064;ConversationSubGroup(of = MyGroup.class, subGroup = {BeanA.class, BeanB.class})
 * </pre> or
 * <pre>
 * &#064;ConversationSubGroup(subGroup = {BeanA.class, BeanB.class})
 *
 * </pre> or it's possible to use implicit subgroups (point to the interface instead of the bean class itself):
 * <pre>
 * &#064;ConversationSubGroup(of = MyGroup.class, subGroup = MyUseCase.class)
 * &#064;Named("myController")
 * &#064;ConversationScoped
 * &#064;ConversationGroup(MyGroup.class)
 * </pre>
 * 
 * @see ConversationGroup
 * @see GroupedConversationScoped
     * Optionally defines the base conversation group.
     *
     * Members of the subgroup.
     *
     * @return beans to include in the subgroup
 * The scope is active as long as its bean is accessed by a view. Basically &#064;ViewAccessScoped is a DeltaSpike
 * Conversation which automatically gets ended when the next view tree gets restored without hitting the bean.
 * Beans in this scope are bound to an application window (or browser tab).
import javax.interceptor.InvocationContext;
     * @param invocationContext current invocation-context
     * @param transaction current JTA transaction wrapped in an EntityTransaction adapter
    protected void beforeProceed(InvocationContext invocationContext,
                                 EntityManagerEntry entityManagerEntry,
                                 EntityTransaction transaction)
import javax.interceptor.InvocationContext;
    protected void beforeProceed(InvocationContext invocationContext,
                                 EntityManagerEntry entityManagerEntry,
                                 EntityTransaction transaction)
            super.beforeProceed(invocationContext, entityManagerEntry, transaction);
                    beforeBegin(invocationContext, entityManagerEntry, transaction);
                beforeProceed(invocationContext, entityManagerEntry, transaction);
                                        beforeRollback(invocationContext, currentEntityManagerEntry, transaction);
                                        beforeCommit(invocationContext, currentEntityManagerEntry, transaction);
                                finally
                                {
                                    afterProceed(invocationContext,currentEntityManagerEntry, firstException);
                                }
                throwException(firstException);
    protected void beforeBegin(InvocationContext invocationContext,
                               EntityManagerEntry entityManagerEntry,
                               EntityTransaction transaction)
    {
        //override if needed
    }

    protected void beforeProceed(InvocationContext invocationContext,
                                 EntityManagerEntry entityManagerEntry,
                                 EntityTransaction transaction)
    {
        //override if needed
    }

    protected void beforeCommit(InvocationContext invocationContext,
                                EntityManagerEntry entityManagerEntry,
                                EntityTransaction transaction)
    {
        //override if needed
    }

    protected void beforeRollback(InvocationContext invocationContext,
                                  EntityManagerEntry entityManagerEntry,
                                  EntityTransaction transaction)
    {
        //override if needed
    }

    /**
     * @param invocationContext current invocation-context
     * @param entityManagerEntry current entity-manager entry
     * @param exception the exception which occurred or null if everything went fine
     */
    protected void afterProceed(InvocationContext invocationContext,
                                EntityManagerEntry entityManagerEntry,
                                Exception exception)
    {
        //override if needed
    }

    protected void throwException(Exception exception) throws Exception
    {
        //override if needed
        throw exception;
    }

import org.apache.deltaspike.core.api.config.ConfigResolver;
            int priorityValue = Integer.parseInt(
                ConfigResolver.getPropertyValue("deltaspike.interceptor.priority", "0"));
            defaultValueMap.put("value", priorityValue);
            rcHolder.getBoundRequestContext().associate(rcHolder.getRequestMap());
            rcHolder.getBoundRequestContext().activate();
            // warn the user if he tries to use the BeanManager before container startup
            LOG.warning("When using the BeanManager to retrieve Beans before the Container is started," 
                    " non-portable behaviour results!");

            // This is a workaround for some containers with messed up EAR handling.
            // Those containers might boot up with the shared ear ClassLoader
            // and later run the WARs with their own child ClassLoaders.
            if (bmi.loadTimeBm == null)
            {
                BeanManagerInfo parentBmi = getParentBeanManagerInfo(ClassUtils.getClassLoader(null));
                if (parentBmi != null)
                {
                    bmi.loadTimeBm = parentBmi.loadTimeBm;
                }
        if (parentClassLoader == null)
            // recursive call up to the root ClassLoader
import java.lang.annotation.Annotation;
            if (!m.getDeclaringClass().equals(Object.class) && !m.getDeclaringClass().equals(Annotation.class))

    /**
     * @return true if the file is optional, false if the specified file has to be in place.
     */
    boolean isOptional();
        String fileName = "";
            fileName = propertyFileConfig.getPropertyFileName();
                = new EnvironmentPropertyConfigSourceProvider(fileName, propertyFileConfig.isOptional());
        catch (IllegalStateException e)
        {
            throw new IllegalStateException(
                propertyFileConfigClass.getName()  " points to an invalid file: '"  fileName  "'", e);
        }
        EnvironmentPropertyConfigSourceProvider epcsp =
            new EnvironmentPropertyConfigSourceProvider(PROPERTY_FILE_NAME, true);
    EnvironmentPropertyConfigSourceProvider(String propertyFileName, boolean optional)
            if (!optional && !propertyFileUrls.hasMoreElements())
            {
                throw new IllegalStateException(propertyFileName  " wasn't found.");
            }


    @Override
    public boolean isOptional()
    {
        return false;
    }

    @Override
    public boolean isOptional()
    {
        return false;
    }
import java.io.Serializable;
public interface ClientWindowConfig extends Serializable
public class DefaultClientWindowConfig implements ClientWindowConfig
    protected Boolean delegatedWindowHandlingEnabled;

        if (this.delegatedWindowHandlingEnabled == null)
        {
            lazyInitDelegatedWindowHandlingEnabled();
        }

        if (this.delegatedWindowHandlingEnabled)
    protected synchronized void lazyInitDelegatedWindowHandlingEnabled()
    {
        if (this.delegatedWindowHandlingEnabled != null)
        {
            return;
        }

        this.delegatedWindowHandlingEnabled = isDelegatedWindowHandlingEnabled();
    }

        if (viewId != null && context.isPostback() /*need for supporting view-actions correctly - see DELTASPIKE-795*/)
import org.apache.deltaspike.core.spi.activation.Deactivatable;

public interface EntityRepository<E, PK extends Serializable> extends Deactivatable
    @SuppressWarnings("unchecked")
                if (Deactivatable.class.isAssignableFrom(repoClass)
                        && !ClassDeactivationUtils.isActivated((Class<? extends Deactivatable>) repoClass))
                {
                    log.log(Level.FINER, "Class {0} is Deactivated", repoClass);
                    return;
                }
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
        if (cdiClass != null && !CoreBaseConfig.BeanManager.DELEGATE_LOOKUP.getValue())
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
            int priorityValue = CoreBaseConfig.Interceptor.PRIORITY.getValue();
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
        if (server.isRegistered(objectName) && CoreBaseConfig.MBean.AUTO_UNREGISTER.getValue())
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
        this.maxWindowContextCount = CoreBaseConfig.Scope.Window.MAX_COUNT.getValue();
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
                    JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER.getValue();
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
                    JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_BASE_PATH_BUILDER.getValue();
                    JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FILE_NAME_BUILDER.getValue();
                    JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_EXTENSION_BUILDER.getValue();
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
            JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER.getValue();
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
            JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_BASE_PATH_BUILDER.getValue();
            JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FILE_NAME_BUILDER.getValue();
            JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_EXTENSION_BUILDER.getValue();
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
        this.maxWindowContextCount = JsfBaseConfig.Scope.Window.MAX_COUNT.getValue();
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
        int result = JsfBaseConfig.Scope.Window.ID_MAX_LENGTH.getValue();
        if (result > JsfBaseConfig.Scope.Window.ID_MAX_LENGTH.getDefaultValue())
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
        return ClassUtils.tryToLoadClassForName("javax.faces.view.ViewScoped") != null &&
            JsfBaseConfig.Scope.View.DELEGATE_TO_JSF.getValue();
        String defaultJobFactoryName = SchedulerBaseConfig.Job.DEFAULT_JOB_FACTORY_CLASS_NAME.getValue();
            if (SchedulerBaseConfig.Lifecycle.START_SCOPES_PER_JOB.getValue())
                this.scheduler.startDelayed(SchedulerBaseConfig.Lifecycle.DELAYED_START_IN_SECONDS.getValue());
        String configFile = SchedulerBaseConfig.SCHEDULER_CONFIG_FILE.getValue();
                this.scheduler.shutdown(SchedulerBaseConfig.Lifecycle.FORCE_STOP.getValue());
            String jobClassName = SchedulerBaseConfig.Job.JOB_CLASS_NAME.getValue();
import org.apache.deltaspike.scheduler.impl.SchedulerBaseConfig;
        put(SchedulerBaseConfig.Job.JOB_CLASS_NAME.getKey(), CustomJob.class.getName());
import org.apache.deltaspike.scheduler.impl.SchedulerBaseConfig;
            put(SchedulerBaseConfig.Job.JOB_CLASS_NAME.getKey(), CustomJob.class.getName());
            put(SchedulerBaseConfig.Lifecycle.START_SCOPES_PER_JOB.getKey(), Boolean.FALSE.toString());
    }};
                    return MyFacesTestBaseConfig.WEBAPP_RESOURCE_PATH.getValue();
import org.apache.deltaspike.testcontrol.api.junit.TestBaseConfig;
        if (!TestBaseConfig.Mock.ALLOW_MOCKED_BEANS.getValue() &&
            !TestBaseConfig.Mock.ALLOW_MOCKED_PRODUCERS.getValue())
                "Please set '"  TestBaseConfig.Mock.ALLOW_MOCKED_BEANS.getKey()  "' and/or '" 
                TestBaseConfig.Mock.ALLOW_MOCKED_PRODUCERS.getKey()  "' to 'true' " 
import org.apache.deltaspike.testcontrol.api.junit.TestBaseConfig;
            return TestBaseConfig.Mock.ALLOW_MOCKED_PRODUCERS.getValue();
            return TestBaseConfig.Mock.ALLOW_MOCKED_BEANS.getValue();
import javax.enterprise.util.Nonbinding;
import java.lang.reflect.Type;
import java.util.Arrays;

    //based on org.apache.webbeans.container.BeanCacheKey#getQualifierHashCode
    public static int getQualifierHashCode(Annotation annotation)
    {
        Class annotationClass = annotation.annotationType();

        int hashCode = getTypeHashCode(annotationClass);

        for (Method member : annotationClass.getDeclaredMethods())
        {
            if (member.isAnnotationPresent(Nonbinding.class))
            {
                continue;
            }

            final Object annotationMemberValue;
            try
            {
                annotationMemberValue = ReflectionUtils.invokeMethod(annotation, member, Object.class, true);
            }
            catch (IllegalAccessException e)
            {
                throw ExceptionUtils.throwAsRuntimeException(e);
            }

            final int arrayValue;
            if (annotationMemberValue.getClass().isArray())
            {
                Class<?> annotationMemberType = annotationMemberValue.getClass().getComponentType();
                if (annotationMemberType.isPrimitive())
                {
                    if (Long.TYPE == annotationMemberType)
                    {
                        arrayValue = Arrays.hashCode((long[]) annotationMemberValue);
                    }
                    else if (Integer.TYPE == annotationMemberType)
                    {
                        arrayValue = Arrays.hashCode((int[]) annotationMemberValue);
                    }
                    else if (Short.TYPE == annotationMemberType)
                    {
                        arrayValue = Arrays.hashCode((short[]) annotationMemberValue);
                    }
                    else if (Double.TYPE == annotationMemberType)
                    {
                        arrayValue = Arrays.hashCode((double[]) annotationMemberValue);
                    }
                    else if (Float.TYPE == annotationMemberType)
                    {
                        arrayValue = Arrays.hashCode((float[]) annotationMemberValue);
                    }
                    else if (Boolean.TYPE == annotationMemberType)
                    {
                        arrayValue = Arrays.hashCode((boolean[]) annotationMemberValue);
                    }
                    else if (Byte.TYPE == annotationMemberType)
                    {
                        arrayValue = Arrays.hashCode((byte[]) annotationMemberValue);
                    }
                    else if (Character.TYPE == annotationMemberType)
                    {
                        arrayValue = Arrays.hashCode((char[]) annotationMemberValue);
                    }
                    else
                    {
                        arrayValue = 0;
                    }
                }
                else
                {
                    arrayValue = Arrays.hashCode((Object[]) annotationMemberValue);
                }
            }
            else
            {
                arrayValue = annotationMemberValue.hashCode();
            }

            hashCode = 29 * hashCode  arrayValue;
            hashCode = 29 * hashCode  member.getName().hashCode();
        }

        return hashCode;
    }

    private static int getTypeHashCode(Type type)
    {
        int typeHash = type.hashCode();
        if (typeHash == 0 && type instanceof Class)
        {
            return ((Class)type).getName().hashCode();
        }

        return typeHash;
    }
import org.apache.deltaspike.core.util.AnnotationUtils;

                        Set<Integer> hashCodesOfBusinessParameterAnnotations =
                            new HashSet<Integer>(businessParameterAnnotations.size());

                        for (Annotation annotation : businessParameterAnnotations)
                        {
                            hashCodesOfBusinessParameterAnnotations.add(
                                AnnotationUtils.getQualifierHashCode(annotation));
                        }
                        //2nd try (detailed check)
                        for (Annotation annotation : requiredBindingAnnotations)
                        {
                            if (hashCodesOfBusinessParameterAnnotations.contains(
                                AnnotationUtils.getQualifierHashCode(annotation)))
                            {
                                return invocation.getParameters()[i];
                            }
                        }
import org.apache.deltaspike.core.util.metadata.InjectionPointWrapper;
            // Check for null Beans, wrap if there isn't one -- DELTASPIKE-400
            final HashSet<InjectionPoint> ips = new HashSet<InjectionPoint>(injectionPoints.size());

            for (InjectionPoint ip : injectionPoints)
            {
                if (ip.getBean() == null)
                {
                    ips.add(new InjectionPointWrapper(ip, this));
                }
                else
                {
                    ips.add(ip);
                }
            }

            this.injectionPoints = ips;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.jsf.impl.scope.viewaccess.beans;

import java.io.Serializable;
import javax.inject.Named;
import org.apache.deltaspike.core.api.scope.ViewAccessScoped;

@Named
@ViewAccessScoped
public class ViewAccessScopedBeanX implements Serializable
{
    private String value;

    public String getValue()
    {
        return value;
    }

    public void setValue(String value)
    {
        this.value = value;
    }

    public void viewAction()
    {
    }
}
import java.util.logging.Logger;
    private static final Logger LOG = Logger.getLogger(ViewConfigResolverProducer.class.getName());

            return createEmptyDefaultViewConfigResolver();
        ViewConfigResolver viewConfigResolver = viewConfigExtension.getViewConfigResolver();

        if (viewConfigResolver == null)
        {
            LOG.warning("It wasn't possible to create a ViewConfigResolver");
            viewConfigResolver = createEmptyDefaultViewConfigResolver();
        }

        return viewConfigResolver;
    }

    private DefaultViewConfigResolver createEmptyDefaultViewConfigResolver()
    {
        return new DefaultViewConfigResolver(
            new FolderConfigNode(
                null, null, new HashSet<Annotation>()), null, null, new ArrayList<ConfigDescriptorValidator>());
import java.util.Stack;

    private final ThreadLocal<Stack<CdiQueryInvocationContext>> contextStack =
            new ThreadLocal<Stack<CdiQueryInvocationContext>>();
        if (contextStack.get() == null)
        {
            contextStack.set(new Stack<CdiQueryInvocationContext>());
        }
        contextStack.get().push(context);
        if (contextStack.get() != null && !contextStack.get().isEmpty())
        {
            return contextStack.get().peek();
        }
        return null;
        if (contextStack.get() != null && !contextStack.get().isEmpty())
            CdiQueryInvocationContext ctx = contextStack.get().pop();
        if (contextStack.get() != null && contextStack.get().isEmpty())
        {
            contextStack.remove();
        }
            int orderByIndex = lower.indexOf("order by");
                if (orderByIndex > 0)
                {
                    where = where.substring(0, orderByIndex - whereIndex);
                }
    @Query("select s from Simple s where s.name = ?1 order by s.counter desc")
    public abstract QueryResult<Simple> findByQueryWithOrderBy(String name);

import java.util.*;
        result.addAll(SecurityUtils.getAllAnnotations(method.getAnnotations(),
            new HashSet<Class<? extends Annotation>>()));
        result.addAll(SecurityUtils.getAllAnnotations(method.getDeclaringClass().getAnnotations(),
            new HashSet<Class<? extends Annotation>>()));
        List<Annotation> result = getAllAnnotations(annotation.annotationType().getAnnotations(),
            new HashSet<Class<? extends Annotation>>());
        List<Annotation> result = getAllAnnotations(annotation.annotationType().getAnnotations(),
            new HashSet<Class<? extends Annotation>>());
        List<Annotation> result = getAllAnnotations(annotation.annotationType().getAnnotations(),
            new HashSet<Class<? extends Annotation>>());
    public static List<Annotation> getAllAnnotations(Annotation[] annotations,
                                                     Set<Class<? extends Annotation>> annotationPath)

            if (!annotationPath.contains(annotation.annotationType()))
            {
                annotationPath.add(annotation.annotationType());
                result.addAll(getAllAnnotations(annotation.annotationType().getAnnotations(), annotationPath));
            }
            annotationMemberValue = ReflectionUtils.invokeMethod(annotation, member, Object.class, true);
import javax.enterprise.util.Nonbinding;
import java.lang.annotation.Annotation;
import java.util.Arrays;
    private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];

                                     Object... args)

    public static int calculateHashCodeOfAnnotation(Annotation annotation, boolean ignoreNonbindingMembers)
    {
        Class annotationClass = annotation.annotationType();

        if (annotationClass == null)
        {
            return calculateHashCodeOfType(annotation.annotationType());
        }

        // the hashCode of an Annotation is calculated solely via the hashCodes
        // of it's members. If there are no members, it is 0.
        // thus we first need to get the annotation-class hashCode
        int hashCode = calculateHashCodeOfType(annotationClass);

        // and now add the hashCode of all it's Nonbinding members
        // the following algorithm is defined by the Annotation class definition
        // see the JavaDoc for Annotation!
        // we only change it so far that we skip evaluating @Nonbinding members
        final Method[] members = annotationClass.getDeclaredMethods();

        for (Method member : members)
        {
            if (ignoreNonbindingMembers && member.isAnnotationPresent(Nonbinding.class))
            {
                // ignore the non binding
                continue;
            }

            // Member value
            final Object object = invokeMethod(annotation, member, Object.class, true, EMPTY_OBJECT_ARRAY);
            final int value;
            if (object.getClass().isArray())
            {
                Class<?> type = object.getClass().getComponentType();
                if (type.isPrimitive())
                {
                    if (Long.TYPE == type)
                    {
                        value = Arrays.hashCode((long[]) object);
                    }
                    else if (Integer.TYPE == type)
                    {
                        value = Arrays.hashCode((int[])object);
                    }
                    else if (Short.TYPE == type)
                    {
                        value = Arrays.hashCode((short[])object);
                    }
                    else if (Double.TYPE == type)
                    {
                        value = Arrays.hashCode((double[])object);
                    }
                    else if (Float.TYPE == type)
                    {
                        value = Arrays.hashCode((float[])object);
                    }
                    else if (Boolean.TYPE == type)
                    {
                        value = Arrays.hashCode((boolean[])object);
                    }
                    else if (Byte.TYPE == type)
                    {
                        value = Arrays.hashCode((byte[])object);
                    }
                    else if (Character.TYPE == type)
                    {
                        value = Arrays.hashCode((char[])object);
                    }
                    else
                    {
                        value = 0;
                    }
                }
                else
                {
                    value = Arrays.hashCode((Object[])object);
                }
            }
            else
            {
                value = object.hashCode();
            }

            hashCode = 29 * hashCode  value;
            hashCode = 29 * hashCode  member.getName().hashCode();
        }

        return hashCode;
    }

    /**
     * We need this method as some weird JVMs return 0 as hashCode for classes.
     * In that case we return the hashCode of the String.
     */
    public static int calculateHashCodeOfType(Type type)
    {
        int typeHash = type.hashCode();
        if (typeHash == 0 && type instanceof Class)
        {
            return ((Class)type).getName().hashCode();
            // the type.toString() is always the same: "java.lang.Class@<hexid>"
            // was: return type.toString().hashCode();
        }

        return typeHash;
    }
            new HashSet<Integer>()));
            new HashSet<Integer>()));
import org.apache.deltaspike.core.util.ReflectionUtils;
            new HashSet<Integer>());
            new HashSet<Integer>());
            new HashSet<Integer>());
    public static List<Annotation> getAllAnnotations(Annotation[] annotations, Set<Integer> annotationPath)
            int annotationHashCode = hashCodeOfAnnotation(annotation);
            if (!annotationPath.contains(annotationHashCode))
                result.add(annotation);
                annotationPath.add(annotationHashCode);

    private static int hashCodeOfAnnotation(Annotation annotation)
    {
        //with using System#identityHashCode instead, we could detect the real instances
        //-> that would lead to multiple entries in the result which look the same (same type and members)

        //to detect real cycles, nonbinding members aren't ignored here
        return ReflectionUtils.calculateHashCodeOfAnnotation(annotation, false);
    }
import org.apache.deltaspike.core.util.ReflectionUtils;

        int computedHashCode = 31 * ReflectionUtils.calculateHashCodeOfType(type);
        return ReflectionUtils.calculateHashCodeOfAnnotation(a, true);
                    final Object value1 = ReflectionUtils.invokeMethod(annotation1, member1[i], Object.class, true);
                    final Object value2 = ReflectionUtils.invokeMethod(annotation2, member2[j], Object.class, true);
    public static int calculateHashCodeOfAnnotation(Annotation annotation, boolean skipNonbindingMembers)
            if (skipNonbindingMembers && member.isAnnotationPresent(Nonbinding.class))
import org.apache.deltaspike.core.util.ClassUtils;
        ClassLoader currentClassLoader = ClassUtils.getClassLoader(null);
        configSources.remove(ClassUtils.getClassLoader(null));
        ClassLoader cl = ClassUtils.getClassLoader(null);
        ClassLoader currentClassLoader = ClassUtils.getClassLoader(null);
            return get(bean);

    @Override
    public String toString()
    {
        return "OpenWebBeansContainerControl";
    }
import org.jboss.weld.Container;
import org.jboss.weld.util.reflection.Formats;


    @Override
    public String toString()
    {
        return "WeldContainerControl [Weld "  Formats.version(Container.class.getPackage())  ']';
    }
        if (origin != null && origin.getPackage() == null)
        {
            LOG.warning("Please don't use the default-package for "  origin.getName());
            return true;
        }

 *
 * <p><b>Attention:</b> When using this logic inside an EAR then you might get
 * different behaviour depending on the Java EE
 * server you are using. Some EE container use a different ClassLoader to bootstrap
 * the application than later to serve Requests.
 * In that case we would register the ConfigSources on the <em>wrong</em> ConfigResolver
 * (means we register it to the wrong ClassLoader). If you did hit such an application server
 * then you might need to switch back to manually register the
 * {@link org.apache.deltaspike.core.spi.config.ConfigSource} or
 * {@link org.apache.deltaspike.core.spi.config.ConfigSourceProvider} via the
 * {@link java.util.ServiceLoader} mechanism described there.</p>.
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.deltaspike.core.util.ClassUtils;
    /**
     * This is a trick for EAR scenarios in some containers.
     * They e.g. boot up the shared EAR lib with the ear ClassLoader.
     * Thus any {@link org.apache.deltaspike.core.api.config.PropertyFileConfig} configuration will just get
     * activated for this very single EAR ClassLoader but <em>not</em> for all the webapps.
     * But if I have a property file in a jar in the shared EAR lib then I most likely also like to get it
     * if I call this from my webapp (TCCL).
     * So we also automatically register all the PropertyFileConfigs we found in the 'parent BeanManager'
     * as well.
     */
    private static Map<ClassLoader, List<Class<? extends PropertyFileConfig>>> detectedParentPropertyFileConfigs
        = new ConcurrentHashMap<ClassLoader, List<Class<? extends PropertyFileConfig>>>();

    private List<Class<? extends PropertyFileConfig>> propertyFileConfigClasses
        propertyFileConfigClasses.add(pcsClass);
        // create a local copy with all the collected PropertyFileConfig
        Set<Class<? extends PropertyFileConfig>> allPropertyFileConfigClasses
            = new HashSet<Class<? extends PropertyFileConfig>>(this.propertyFileConfigClasses);
        // now add any PropertyFileConfigs from a 'parent BeanManager'
        // we start with the current TCCL
        ClassLoader currentClassLoader = ClassUtils.getClassLoader(null);
        addParentPropertyFileConfigs(currentClassLoader, allPropertyFileConfigClasses);

        // now let's add our own PropertyFileConfigs to the detected ones.
        // because maybe WE are a parent BeanManager ourselves!
        if (!this.propertyFileConfigClasses.isEmpty())
        {
            detectedParentPropertyFileConfigs.put(currentClassLoader, this.propertyFileConfigClasses);
        }

        // collect all the ConfigSources from our PropertyFileConfigs
        List<ConfigSource> configSources = new ArrayList<ConfigSource>();
        for (Class<? extends PropertyFileConfig> propertyFileConfigClass : allPropertyFileConfigClasses)

     * Add all registered PropertyFileConfigs which got picked up in a parent ClassLoader already
     */
    private void addParentPropertyFileConfigs(ClassLoader currentClassLoader,
                                              Set<Class<? extends PropertyFileConfig>> propertyFileConfigClasses)
    {
        if (currentClassLoader.getParent() == null)
        {
            return;
        }

        for (Map.Entry<ClassLoader, List<Class<? extends PropertyFileConfig>>> classLoaderListEntry :
                detectedParentPropertyFileConfigs.entrySet())
        {
            if (currentClassLoader.getParent().equals(classLoaderListEntry.getKey()))
            {
                // if this is the direct parent ClassLoader then lets add those PropertyFileConfigs.
                propertyFileConfigClasses.addAll(classLoaderListEntry.getValue());

                // even check further parents
                addParentPropertyFileConfigs(classLoaderListEntry.getKey(), propertyFileConfigClasses);

                // and be done. There can only be a single parent CL...
                return;
            }
        }
    }

    /**
        detectedParentPropertyFileConfigs.remove(ClassUtils.getClassLoader(null));
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import org.apache.deltaspike.core.util.ServiceUtils;
import org.apache.deltaspike.core.util.bean.BeanBuilder;
import org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.partialbean.api.PartialBeanBinding;
import org.apache.deltaspike.partialbean.spi.PartialBeanDescriptor;
import org.apache.deltaspike.partialbean.spi.PartialBeanProvider;
    private final Map<Class<? extends Annotation>, PartialBeanDescriptor> descriptors =
            new HashMap<Class<? extends Annotation>, PartialBeanDescriptor>();
    private final List<Class<?>> alreadyProxied = new ArrayList<Class<?>>();

        if (!this.isActivated)
        {
            return;
        }

        List<PartialBeanProvider> providers = ServiceUtils.loadServiceImplementations(PartialBeanProvider.class);
        for (PartialBeanProvider provider : providers)
        {
            for (PartialBeanDescriptor descriptor : provider.get())
            {
                if (descriptors.containsKey(descriptor.getBinding()))
                {
                    PartialBeanDescriptor existingDescriptor = descriptors.get(descriptor.getBinding());

                    // check if multiple handlers are defined for the same binding
                    if ((descriptor.getHandler() != null
                            && descriptor.getHandler().equals(existingDescriptor.getHandler()))
                        || (existingDescriptor.getHandler() != null
                            && existingDescriptor.getHandler().equals(descriptor.getHandler())))
                    {
                        this.definitionError = new IllegalStateException("Multiple handlers found for "
                                 descriptor.getBinding().getName()  " ("
                                 descriptor.getHandler().getName()  " and "
                                 existingDescriptor.getHandler().getName()  ")");
                        return;
                    }

                    if (existingDescriptor.getClasses() == null)
                    {
                        existingDescriptor.setClasses(new ArrayList<Class<?>>());
                    }

                    // merge bean classes
                    if (descriptor.getClasses() != null && descriptor.getClasses().size() > 0)
                    {
                        existingDescriptor.getClasses().addAll(descriptor.getClasses());
                    }
                }
                else
                {
                    descriptors.put(descriptor.getBinding(), descriptor);
                }
            }
        }

        // loop early partial beans and register them via a new annotated type for the proxy
        // this enables interceptors on the early provided partial beans
        for (Map.Entry<Class<? extends Annotation>, PartialBeanDescriptor> entry : this.descriptors.entrySet())
        {
            PartialBeanDescriptor descriptor = entry.getValue();
            if (descriptor.getClasses() != null)
            {
                for (Class<?> partialBeanClass : descriptor.getClasses())
                {
                    // skip
                    if (alreadyProxied.contains(partialBeanClass))
                    {
                        continue;
                    }

                    // handler currently not defined - skip early partial bean process
                    // later if the handler is still null, we will throw a definition error
                    if (descriptor.getHandler() == null)
                    {
                        continue;
                    }

                    Class<?> partialBeanProxyClass =
                            PartialBeanProxyFactory.getProxyClass(partialBeanClass, descriptor.getHandler());
                    AnnotatedType<?> annotatedType =
                            new AnnotatedTypeBuilder().readFromType(partialBeanProxyClass).create();
                    beforeBeanDiscovery.addAnnotatedType(annotatedType);

                    alreadyProxied.add(partialBeanClass);
                }
            }
        }
        // skip early generated proxies
        if (PartialBeanProxyFactory.isProxyClass(beanClass))
        // skip classes without a partial bean binding
        Class<? extends Annotation> bindingClass = extractBindingClass(pat);
        if (bindingClass == null)
            return;
        }

        if (beanClass.isInterface() || Modifier.isAbstract(beanClass.getModifiers()))
        {
            pat.veto();

            // skip already proxied beans
            if (alreadyProxied.contains(beanClass))
            {
                return;
            }

            PartialBeanDescriptor descriptor = descriptors.get(bindingClass);

            if (descriptor == null)
            {
                descriptor = new PartialBeanDescriptor(bindingClass);
            }

            if (descriptor.getClasses() == null)
            {
                descriptor.setClasses(new ArrayList<Class<?>>());
            }

            if (!descriptor.getClasses().contains(beanClass))
            {
                descriptor.getClasses().add(beanClass);
                descriptors.put(bindingClass, descriptor);
            }
            PartialBeanDescriptor descriptor = descriptors.get(bindingClass);
            if (descriptor == null)
            {
                descriptor = new PartialBeanDescriptor(bindingClass, (Class<? extends InvocationHandler>) beanClass);
                descriptors.put(bindingClass, descriptor);
            }
            else
            {
                if (descriptor.getHandler() == null)
                {
                    descriptor.setHandler((Class<? extends InvocationHandler>) beanClass);
                }
                else if (!descriptor.getHandler().equals(beanClass))
                {
                    this.definitionError = new IllegalStateException("Multiple handlers found for "
                             bindingClass.getName()  " ("
                             descriptor.getHandler().getName()
                             " and "  beanClass.getName()  ")");
                }
            }
            this.definitionError = new IllegalStateException(beanClass.getName()  " is annotated with @"
                     bindingClass.getName()  " and therefore has to be "
                     "an abstract class, an interface or an implementation of "  InvocationHandler.class.getName());
        for (Map.Entry<Class<? extends Annotation>, PartialBeanDescriptor> entry : this.descriptors.entrySet())
            PartialBeanDescriptor descriptor = entry.getValue();
            if (descriptor.getClasses() != null)
                for (Class partialBeanClass : descriptor.getClasses())
                {
                    // skip already/early proxied beans
                    if (alreadyProxied.contains(partialBeanClass))
                    {
                        continue;
                    }

                    Bean partialBean = createPartialBean(partialBeanClass, descriptor, afterBeanDiscovery, beanManager);
                    if (partialBean != null)
                    {
                        afterBeanDiscovery.addBean(partialBean);
                        alreadyProxied.add(partialBeanClass);
                    }
                }
        this.descriptors.clear();
    protected <T> Bean<T> createPartialBean(Class<T> beanClass, PartialBeanDescriptor descriptor,
            AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
    {
        if (descriptor.getHandler() == null)
            afterBeanDiscovery.addDefinitionError(new IllegalStateException("A class which implements "
                     InvocationHandler.class.getName()
                     " and is annotated with @"  descriptor.getBinding().getName()
                     " is needed as a handler for "  beanClass.getName()
                     ". See the documentation about @"  PartialBeanBinding.class.getName()  "."));
                new PartialBeanLifecycle(beanClass, descriptor.getHandler(), beanManager);
    protected <X> Class<? extends Annotation> extractBindingClass(ProcessAnnotatedType<X> pat)
import javax.enterprise.context.Dependent;
import javax.enterprise.inject.spi.AnnotatedType;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import org.apache.deltaspike.core.api.provider.BeanProvider;
    private final Class<T> proxyClass;
    private final Class<T> partialBeanClass;
    
    private InjectionTarget<T> injectionTarget;
    PartialBeanLifecycle(Class<T> partialBeanClass, Class<H> handlerClass, BeanManager beanManager)
        this.partialBeanClass = partialBeanClass;
        this.proxyClass = PartialBeanProxyFactory.getProxyClass(partialBeanClass, handlerClass);
        if (!partialBeanClass.isInterface())
            AnnotatedType<T> annotatedType = beanManager.createAnnotatedType(this.partialBeanClass);
            this.injectionTarget = beanManager.createInjectionTarget(annotatedType);
    @Override
            T instance = proxyClass.newInstance();
            // only required here, for early partial beans, the handler will be injected and handled by CDI
            ((PartialBeanProxy) instance).setHandler(createHandlerInstance());

            if (this.injectionTarget != null)
                this.injectionTarget.inject(instance, creationalContext);
                this.injectionTarget.postConstruct(instance);

    @Override
    public void destroy(Bean<T> bean, T instance, CreationalContext<T> creationalContext)
        if (this.injectionTarget != null)
            this.injectionTarget.preDestroy(instance);
        
        if (this.creationalContextOfDependentHandler != null)
            this.creationalContextOfDependentHandler.release();

        creationalContext.release();
    
        
        
        CreationalContext<?> creationalContext = beanManager.createCreationalContext(handlerBean);
        
        H handlerInstance = (H) beanManager.getReference(handlerBean, this.handlerClass, creationalContext);
            this.creationalContextOfDependentHandler = creationalContext;


public abstract class ApplicationScopedPartialBean extends AbstractSuper
}
import java.util.ArrayList;
import java.util.Arrays;
        ArrayList<JavaArchive> result = new ArrayList<JavaArchive>();
        JavaArchive[] temp;
        temp = ShrinkWrapArchiveUtil.getArchives(null,
                new String[] { "org.apache.deltaspike.core",
                        "org.apache.deltaspike.partialbean" },
                new String[] { "META-INF.apache-deltaspike.properties" },
        result.addAll(Arrays.asList(temp));

        temp = ShrinkWrapArchiveUtil.getArchives(null,
                "META-INF/MANIFEST.MF",
                new String[] { "org.objectweb.asm" },
                new String[] { },
                "asm");
        result.addAll(Arrays.asList(temp));

        return result.toArray(new JavaArchive[result.size()]);
        mg.push(proxyType);
        
        // sort out method with same signature (see uc008)
        ArrayList<Method> duplicates = new ArrayList<Method>();
        for (Method outer : methods)
        {
            for (Method inner : methods)
            {
                if (inner != outer
                        && hasSameSignature(outer, inner)
                        && !(duplicates.contains(outer) || duplicates.contains(inner)))
                {
                    duplicates.add(inner);
                }
            }
        }
        methods.removeAll(duplicates);
    
    private static boolean hasSameSignature(Method a, Method b)
    {
        return a.getName().equals(b.getName())
                && a.getReturnType().equals(b.getReturnType())
                && Arrays.equals(a.getParameterTypes(), b.getParameterTypes());
    }
        mg.push(Type.getType(method.getDeclaringClass()));
        Class unproxiedClass = currentClass;
        
        while (isProxiedClass(unproxiedClass))
            unproxiedClass = unproxiedClass.getSuperclass();

        return unproxiedClass;
        
            Class unproxiedClass = proxyClass.getSuperclass();
            result.add(unproxiedClass);

            while (isProxiedClass(unproxiedClass))
            {
                unproxiedClass = unproxiedClass.getSuperclass();
                result.add(unproxiedClass);
            }
        if (Proxy.class.equals(proxyClass.getSuperclass()) &&
                interfaces != null && interfaces.length > 0)
        {
            return true;
        }
        
        if (proxyClass.getName().contains("$$"))
        {
            for (Class<?> iface : interfaces)
            {
                if (proxyClass.getName().startsWith(iface.getName()))
                {
                    return true;
                }
            }
        }
        
        return false;
        List<Method> methods = new ArrayList<Method>();
            if (!containsMethodWithSameSignature(method, methods))
            {
                methods.add(method);
            }
        }
        for (Method method : clazz.getMethods())
        {
            if (!containsMethodWithSameSignature(method, methods))
                for (Method method : currentSuperClass.getDeclaredMethods())
                    if (!containsMethodWithSameSignature(method, methods))
                for (Method method : currentSuperClass.getMethods())
                    if (!containsMethodWithSameSignature(method, methods))
    private static boolean containsMethodWithSameSignature(Method method, List<Method> methods)
    {
        for (Method currentMethod : methods)
        {
            if (hasSameSignature(currentMethod, method))
            {
                return true;
            }
        }
        
        return false;
    }
    
        if (methods.contains(method))
        {
            return true;
        }
        
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
            for (Class<?> currentInterface : proxyClass.getInterfaces())
            {
                if (proxyClass.getName().startsWith(iface.getName()))
                {
                    result.add(currentInterface);
                }
            }
            for (Class<?> currentInterface : interfaces)
                if (proxyClass.getName().startsWith(currentInterface.getName()))
                if (proxyClass.getName().startsWith(currentInterface.getName()))
        if (proxyClass.getSuperclass() != null && !proxyClass.getSuperclass().equals(Object.class))
        {
            return false;
        }
        
        return getDependent(beanManager, type, qualifiers);
    }

    public static <T> DependentProvider<T> getDependent(BeanManager beanManager, Class<T> type,
                                                        Annotation... qualifiers)
    {
        return getDependent(beanManager, name);
    }

    public static <T> DependentProvider<T> getDependent(BeanManager beanManager, String name)
    {
import java.beans.Introspector;
    protected final BeanManager beanManager;
    protected Class<?> beanClass;
    protected String name;
    protected Set<Annotation> qualifiers;
    protected Class<? extends Annotation> scope = Dependent.class;
    protected Set<Class<? extends Annotation>> stereotypes;
    protected Set<Type> types;
    protected Set<InjectionPoint> injectionPoints;
    protected boolean alternative;
    protected boolean nullable;
    protected ContextualLifecycle<T> beanLifecycle;
    protected boolean passivationCapable;
    protected String id;
    protected String toString;

        if (beanLifecycle == null)
            setDefaultBeanLifecycle(type);

                if (name == null || name.length() == 0)
                {
                    name = createDefaultBeanName(type);
                }


    private String createDefaultBeanName(AnnotatedType<T> type)
    {
        Class<T> javaClass = type.getJavaClass();
        return Introspector.decapitalize(javaClass.getSimpleName());
    }


    /**
     * Set the ContextualLifecycle and the InjectionPoints for the AnnotatedType
     * @param type
     */
    protected void setDefaultBeanLifecycle(AnnotatedType<T> type)
    {
        InjectionTarget<T> injectionTarget;
        if (!type.getJavaClass().isInterface())
        {
            injectionTarget = beanManager.createInjectionTarget(type);
        }
        else
        {
            injectionTarget = new DummyInjectionTarget<T>();
        }
        this.beanLifecycle = new DelegatingContextualLifecycle<T>(injectionTarget);
        this.injectionPoints = injectionTarget.getInjectionPoints();
    }

public class WrappingBeanBuilder<T> extends BeanBuilder<T>
        super(beanManager);
    protected void setDefaultBeanLifecycle(AnnotatedType<T> type)
        // do nothing. We don't need that as we delegate this information
    public Bean<T> create()
    private final InjectionPoint wrapped;
    private final Bean<?> newBean;
import java.lang.reflect.Proxy;
import javax.enterprise.inject.spi.*;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.api.provider.DependentProvider;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.bean.BeanBuilder;
import org.apache.deltaspike.core.util.metadata.builder.ContextualLifecycle;
            abd.addBean(createMessageBundleBean(type, beanManager));
    private <T> Bean<T> createMessageBundleBean(AnnotatedType<T> annotatedType,
        BeanBuilder<T> beanBuilder = new BeanBuilder<T>(beanManager).readFromType(annotatedType);
        beanBuilder.beanLifecycle(new MessageBundleLifecycle<T>(beanManager));


    private static class MessageBundleLifecycle<T> implements ContextualLifecycle<T>
    {
        private final BeanManager beanManager;

        private DependentProvider<MessageBundleInvocationHandler> invocationHandlerProvider;

        private MessageBundleLifecycle(BeanManager beanManager)
        {
            this.beanManager = beanManager;
        }

        @Override
        public T create(Bean<T> bean, CreationalContext<T> creationalContext)
        {
            invocationHandlerProvider = BeanProvider.getDependent(beanManager, MessageBundleInvocationHandler.class);

            return createMessageBundleProxy((Class<T>) bean.getBeanClass(), invocationHandlerProvider.get());
        }

        @Override
        public void destroy(Bean<T> bean, T instance, CreationalContext<T> creationalContext)
        {
            invocationHandlerProvider.destroy();
        }

        private <T> T createMessageBundleProxy(Class<T> type, MessageBundleInvocationHandler handler)
        {
            return type.cast(Proxy.newProxyInstance(ClassUtils.getClassLoader(null),
                    new Class<?>[]{type}, handler));
        }

    }
import javax.inject.Named;

@Named
import javax.enterprise.context.ApplicationScoped;
        beanBuilder.scope(ApplicationScoped.class); // needs to be a normalscope due to a bug in older Weld versions
                    new Class<?>[]{type, Serializable.class}, handler));
import org.apache.deltaspike.core.util.ClassUtils;

        //interceptor gets enabled globally -> restrict it the the use-case which contains the test for it
        if (ClassUtils.tryToLoadClassForName(
            "org.apache.deltaspike.test.core.api.partialbean.uc007.PartialBean") != null)
            Object target = invocationContext.getTarget();

            if (target instanceof TestInterceptorAware)
            {
                ((TestInterceptorAware)target).setIntercepted(true);
            }
import javax.inject.Inject;
    @Inject
    private TestInterceptedBeanProcessor testInterceptedBeanProcessor;

        return this.testInterceptedBeanProcessor.process(invocationContext);
import org.apache.deltaspike.core.util.ClassUtils;

        //interceptor gets enabled globally -> restrict it the the use-case which contains the test for it
        if (ClassUtils.tryToLoadClassForName(
            "org.apache.deltaspike.test.core.api.partialbean.uc007.PartialBean") != null)
        {
            Object target = invocationContext.getTarget();

            if (target instanceof TestInterceptorAware)
            {
                ((TestInterceptorAware)target).setIntercepted(true);
            }
        }

        return invocationContext.proceed();
import org.apache.deltaspike.test.core.api.partialbean.shared.CustomInterceptor;
@CustomInterceptor //doesn't work currently
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.InjectionTarget;
import javax.enterprise.inject.spi.PassivationCapable;

            StringBuilder beanInfo = new StringBuilder();
            for (Bean<H> bean : handlerBeans)
            {
                if (beanInfo.length() != 0)
                {
                    beanInfo.append(", ");
                }
                beanInfo.append(bean);

                if (bean instanceof PassivationCapable)
                {
                    beanInfo.append(" bean-id: ").append(((PassivationCapable)bean).getId());
                }
            }

            throw new IllegalStateException(handlerBeans.size()  " beans found for "  this.handlerClass 
                " found beans: "  beanInfo.toString());
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/impl/custom/spi/MyImpl.java
package org.apache.deltaspike.test.core.impl.custom.spi;
 b/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/impl/custom/spi/MyInterface.java
package org.apache.deltaspike.test.core.impl.custom.spi;
 * If you implement this interface, the property files with the given file name will be registered as
 *<p>There are 2 ways to register a {@code PropertyFileConfig}</p>
 * <h3>1. Automatic pickup via {@code ProcessAnnotatedType} phase</h3>
 * DeltaSpike will automatically pick up all the implementations which are
 * inside a Bean Archive (a JAR or ClassPath entry with a META-INF/beans.xml file) during the
 *
 * <h3>2. Automatic pickup via {@code java.util.ServiceLoader} mechanism</h3>
 * <p>In case you have an EAR or you need the configured values already during the CDI container start
 * then you can also register the PropertyFileConfig via the {@code java.util.ServiceLoader} mechanism.
 * To not have this configuration picked up twice it is required to annotate your own
 * {@code PropertyFileConfig} implementation with {@link org.apache.deltaspike.core.api.exclude.Exclude}.</p>
 *
 * <p>The {@code ServiceLoader} mechanism requires to have a file
 * <pre>
 *     META-INF/services/org.apache.deltaspike.core.api.config.PropertyFileConfig
 * </pre>
 * containing the fully qualified Class name of your own {@code PropertyFileConfig} implementation class.
 * <pre>
 *     com.acme.my.own.SomeSpecialPropertyFileConfig
 * </pre>
 * The implementation will look like the following:
 * <pre>
 *     &#064;Exclude
 *     public class SomeSpecialPropertyFileConfig implements PropertyFileConfig {
 *         public String getPropertyFileName() {
 *             return "myconfig/specialconfig.properties"
 *         }
 *         public boolean isOptional() {
 *             return false;
 *         }
 *     }
 * </pre>
 * </p>
 *
import org.apache.deltaspike.core.api.exclude.Exclude;
        if (pat.getAnnotatedType().isAnnotationPresent(Exclude.class))
        {
            // We only pick up PropertyFileConfigs if they are not excluded
            // This can be the case for PropertyFileConfigs which are registered via java.util.ServiceLoader
            return;
        }

import org.apache.deltaspike.core.api.config.PropertyFileConfig;
import org.apache.deltaspike.core.util.ServiceUtils;

        registerPropertyFileConfigs();
    }

    private void registerPropertyFileConfigs()
    {
        List<? extends PropertyFileConfig> propertyFileConfigs =
                ServiceUtils.loadServiceImplementations(PropertyFileConfig.class);
        for (PropertyFileConfig propertyFileConfig : propertyFileConfigs)
        {
            EnvironmentPropertyConfigSourceProvider environmentPropertyConfigSourceProvider
                = new EnvironmentPropertyConfigSourceProvider(propertyFileConfig.getPropertyFileName(),
                    propertyFileConfig.isOptional());

            configSources.addAll(environmentPropertyConfigSourceProvider.getConfigSources());
        }
 * Custom PropertyFileConfig which gets picked up during
 * {@link javax.enterprise.inject.spi.ProcessAnnotatedType}.
 * The values will be available <em>after</em> the container got booted!
        params.updateValues(root.getParameterUpdates());
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import org.apache.deltaspike.data.impl.param.ParameterUpdate;

    private final List<ParameterUpdate> paramUpdates;
        this.paramUpdates = new LinkedList<ParameterUpdate>();
    public void addParameterUpdate(ParameterUpdate update)
    {
        paramUpdates.add(update);
    }

    public List<ParameterUpdate> getParameterUpdates()
    {
        return Collections.unmodifiableList(paramUpdates);
    }

    LikeIgnoreCase("LikeIgnoreCase", "upper({0}) like {1}", true),
    NotEqualIgnoreCase("NotEqualIgnoreCase", "upper({0}) <> upper({1})"),
    EqualIgnoreCase("EqualIgnoreCase", "upper({0}) = upper({1})"),
    IgnoreCase("IgnoreCase", "upper({0}) = upper({1})"),
    private final boolean caseInsensitive;
    private QueryOperator(String expression, String jpql, boolean caseInsensitive)
    {
        this(expression, jpql, 1, caseInsensitive);
    }

        this(expression, jpql, paramNum, false);
    }

    private QueryOperator(String expression, String jpql, int paramNum, boolean caseInsensitive)
    {
        this.caseInsensitive = caseInsensitive;
    public boolean isCaseInsensitive()
    {
        return caseInsensitive;
    }

import org.apache.deltaspike.data.impl.param.ToUpperStringParameterUpdate;
        if (comparator.isCaseInsensitive() && args.length >= 1)
        {
            ctx.addParameterUpdate(new ToUpperStringParameterUpdate(args[1].substring(1)));
        }
import java.util.List;
import org.apache.deltaspike.data.impl.param.ParameterUpdate;
    private List<ParameterUpdate> paramUpdates;
    public List<ParameterUpdate> getParameterUpdates()
    {
        return paramUpdates;
    }

        paramUpdates = ctx.getParameterUpdates();
    public IndexedParameter(int index, Object value)
        super(value);
    @Override
    public boolean is(String ident)
    {
        try
        {
            return Integer.valueOf(ident).intValue() == index;
        }
        catch (NumberFormatException e)
        {
            return false;
        }
    }

    public NamedParameter(String name, Object value)
        super(value);
    @Override
    public boolean is(String ident)
    {
        return ident != null && ident.equals(name);
    }

    protected Object value;
    public Parameter(Object value)
    public abstract boolean is(String ident);

    public void updateValue(Object newValue)
    {
        if (mappedValue != null)
        {
            mappedValue = newValue;
        }
        else
        {
            value = newValue;
        }
    }

                    result.add(new NamedParameter(qpAnnotation.value(), parameters[i]));
                    result.add(new IndexedParameter(paramIndex, parameters[i]));
    public void updateValues(List<ParameterUpdate> updates)
    {
        for (ParameterUpdate update : updates)
        {
            for (Parameter param : parameterList)
            {
                if (param.is(update.forParamWithId()))
                {
                    param.updateValue(update.newParamValue(param.queryValue()));
                }
            }
        }
    }

    public abstract Simple findByNameLikeIgnoreCase(String name);

    public abstract Simple findByNameIgnoreCase(String name);


import java.util.HashSet;
import java.util.Set;
    private Set<Class> foundManagedJobClasses = new HashSet<Class>();
import org.apache.deltaspike.partialbean.impl.proxy.PartialBeanProxyFactory;
        this.isActivated = ClassDeactivationUtils.isActivated(getClass());      
 b/deltaspike/modules/partial-bean/impl/src/main/java/org/apache/deltaspike/partialbean/impl/PartialBeanDescriptor.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.partialbean.impl;

import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class PartialBeanDescriptor
{
    private Class<? extends Annotation> binding;
    private Class<? extends InvocationHandler> handler;
    private List<Class<?>> classes;

    public PartialBeanDescriptor(Class<? extends Annotation> binding)
    {
        this.binding = binding;
    }

    public PartialBeanDescriptor(Class<? extends Annotation> binding,
            Class<? extends InvocationHandler> handler)
    {
        this.binding = binding;
        this.handler = handler;
    }

    public PartialBeanDescriptor(Class<? extends Annotation> binding,
            Class<? extends InvocationHandler> handler,
            Class<?>... classes)
    {
        this.binding = binding;
        this.handler = handler;
        this.classes = new ArrayList<Class<?>>();
        if (classes.length > 0)
        {
            this.classes.addAll(Arrays.asList(classes));
        }
    }

    public PartialBeanDescriptor(Class<? extends Annotation> binding,
            Class<? extends InvocationHandler> handler,
            List<Class<?>> classes)
    {
        this.binding = binding;
        this.handler = handler;
        this.classes = classes;
    }

    public Class<? extends Annotation> getBinding()
    {
        return binding;
    }

    public void setBinding(Class<? extends Annotation> binding)
    {
        this.binding = binding;
    }

    public Class<? extends InvocationHandler> getHandler()
    {
        return handler;
    }

    public void setHandler(Class<? extends InvocationHandler> handler)
    {
        this.handler = handler;
    }

    public List<Class<?>> getClasses()
    {
        return classes;
    }

    public void setClasses(List<Class<?>> classes)
    {
        this.classes = classes;
    }
}
import org.apache.deltaspike.partialbean.impl.proxy.PartialBeanProxyFactory;
import org.apache.deltaspike.partialbean.impl.proxy.PartialBeanProxy;
            ((PartialBeanProxy) instance).setRedirectInvocationHandler(createHandlerInstance());
        
 b/deltaspike/modules/partial-bean/impl/src/main/java/org/apache/deltaspike/partialbean/impl/interception/ManualInvocationThrowableWrapperException.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.partialbean.impl.interception;

/**
 * Wrapper for {@link Throwable}s because the highest exception of
 * {@link javax.interceptor.InvocationContext#proceed()} is a {@link Exception}.
 */
public class ManualInvocationThrowableWrapperException extends RuntimeException
{
    public ManualInvocationThrowableWrapperException(Throwable e)
    {
        super(e);
    }
}
 b/deltaspike/modules/partial-bean/impl/src/main/java/org/apache/deltaspike/partialbean/impl/interception/ProceedOriginalMethodException.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.partialbean.impl.interception;

import java.io.Serializable;

/**
 * Exception which will be throewd by the {@link ManualInvocationContext} if all interecptors
 * are successfully handled and the original method should be called.
 */
public class ProceedOriginalMethodException extends RuntimeException implements Serializable
{

}
 b/deltaspike/modules/partial-bean/impl/src/main/java/org/apache/deltaspike/partialbean/impl/proxy/AsmProxyClassGenerator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.partialbean.impl.proxy;

import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.Arrays;
import javax.enterprise.inject.Typed;
import org.apache.deltaspike.partialbean.impl.interception.ManualInvocationHandler;
import org.apache.deltaspike.partialbean.impl.interception.ProceedOriginalMethodException;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.objectweb.asm.commons.Method;

@Typed
public abstract class AsmProxyClassGenerator
{
    private static final String FIELDNAME_HANDLER = "__handler";

    private static final Type TYPE_CLASS = Type.getType(Class.class);
    private static final Type TYPE_OBJECT = Type.getType(Object.class);

    private AsmProxyClassGenerator()
    {
        // prevent instantiation
    }

    public static <T> Class<T> generateProxyClass(ClassLoader classLoader,
            Class<T> targetClass,
            Class<? extends InvocationHandler> invocationHandlerClass,
            String suffix,
            java.lang.reflect.Method[] redirectMethods,
            java.lang.reflect.Method[] interceptionMethods)
    {
        String proxyName = targetClass.getCanonicalName()  suffix;
        String classFileName = proxyName.replace('.', '/');

        byte[] proxyBytes = generateProxyClassBytes(targetClass, invocationHandlerClass,
                classFileName, redirectMethods, interceptionMethods);
        Class<T> proxyClass = (Class<T>) loadClass(classLoader, proxyName, proxyBytes);

        return proxyClass;
    }

    private static byte[] generateProxyClassBytes(Class<?> targetClass,
            Class<? extends InvocationHandler> invocationHandlerClass,
            String proxyName,
            java.lang.reflect.Method[] redirectMethods,
            java.lang.reflect.Method[] interceptionMethods)
    {
        Class<?> superClass = targetClass;
        String[] interfaces = new String[] { };

        if (targetClass.isInterface())
        {
            superClass = Object.class;
            interfaces = new String[] { Type.getInternalName(targetClass) };
        }

        // add PartialBeanProxy as interface
        interfaces = Arrays.copyOf(interfaces, interfaces.length  1);
        interfaces[interfaces.length - 1] = Type.getInternalName(PartialBeanProxy.class);

        Type superType = Type.getType(superClass);
        Type proxyType = Type.getObjectType(proxyName);
        Type invocationHandlerType = Type.getType(invocationHandlerClass);

        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC  Opcodes.ACC_SUPER, proxyType.getInternalName(), null,
                superType.getInternalName(), interfaces);

        // copy annotations
        for (Annotation annotation : targetClass.getDeclaredAnnotations())
        {
            cw.visitAnnotation(Type.getDescriptor(annotation.annotationType()), true).visitEnd();
        }

        defineInvocationHandlerField(cw, invocationHandlerType);
        defineConstructor(cw, proxyType, superType);
        definePartialBeanProxyMethods(cw, proxyType, invocationHandlerType);

        for (java.lang.reflect.Method method : redirectMethods)
        {
            defineMethod(cw, method, proxyType, invocationHandlerType, superType, true);
        }

        for (java.lang.reflect.Method method : interceptionMethods)
        {
            defineMethod(cw, method, proxyType, invocationHandlerType, superType, false);
        }

        return cw.toByteArray();
    }

    private static void defineInvocationHandlerField(ClassWriter cw, Type invocationHandlerType)
    {
        // generates
        // private MyPartialBeanInvocationHandler __handler;
        cw.visitField(Opcodes.ACC_PRIVATE, FIELDNAME_HANDLER, invocationHandlerType.getDescriptor(), null, null)
                .visitEnd();
    }

    private static void defineConstructor(ClassWriter cw, Type proxyType, Type superType)
    {
        GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC,
                new Method("<init>", Type.VOID_TYPE, new Type[]{ }),
                null,
                null,
                cw);

        mg.visitCode();

        // invoke super constructor
        mg.loadThis();
        mg.invokeConstructor(superType, Method.getMethod("void <init> ()"));
        mg.returnValue();
        mg.endMethod();

        mg.visitEnd();
    }

    private static void definePartialBeanProxyMethods(ClassWriter cw, Type proxyType, Type invocationHandlerType)
    {
        try
        {
            // implement #setRedirectInvocationHandler
            Method asmMethod = Method.getMethod(
                            PartialBeanProxy.class.getDeclaredMethod("setRedirectInvocationHandler",
                            InvocationHandler.class));
            GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC, asmMethod, null, null, cw);

            mg.visitCode();

            mg.loadThis();
            mg.loadArg(0);
            mg.checkCast(invocationHandlerType);
            mg.putField(proxyType, FIELDNAME_HANDLER, invocationHandlerType);
            mg.returnValue();

            mg.visitMaxs(2, 1);
            mg.visitEnd();


            // implement #getRedirectInvocationHandler
            asmMethod = Method.getMethod(PartialBeanProxy.class.getDeclaredMethod("getRedirectInvocationHandler"));
            mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC, asmMethod, null, null, cw);

            mg.visitCode();

            mg.loadThis();
            mg.getField(proxyType, FIELDNAME_HANDLER, invocationHandlerType);
            mg.returnValue();

            mg.visitMaxs(2, 1);
            mg.visitEnd();
        }
        catch (NoSuchMethodException e)
        {
            throw new IllegalStateException("Unable to implement "  PartialBeanProxy.class.getName(), e);
        }
    }

    private static void defineMethod(ClassWriter cw, java.lang.reflect.Method method, Type proxyType,
            Type invocationHandlerType, Type superType, boolean callInvocationHandler)
    {
        Type methodType = Type.getType(method);
        Type[] exceptionTypes = getTypes(method.getExceptionTypes());

        // push the method definition
        int modifiers = (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED) & method.getModifiers();
        Method asmMethod = Method.getMethod(method);
        GeneratorAdapter mg = new GeneratorAdapter(modifiers, asmMethod, null, exceptionTypes, cw);

        // copy annotations
        for (Annotation annotation : method.getDeclaredAnnotations())
        {
            mg.visitAnnotation(Type.getDescriptor(annotation.annotationType()), true).visitEnd();
        }

        mg.visitCode();

        Label tryBlockStart = mg.mark();

        mg.loadThis();
        loadCurrentMethod(mg, method, methodType);
        loadArguments(mg, method, methodType);

        // invoke our ProxyInvocationHandler
        mg.invokeStatic(Type.getType(ManualInvocationHandler.class),
                Method.getMethod("Object staticInvoke(Object, java.lang.reflect.Method, Object[])"));

        // cast the result
        mg.unbox(methodType.getReturnType());

        Label tryBlockEnd = mg.mark();

        // push return
        mg.returnValue();

        boolean throwableCatched = false;

        // catch ProceedOriginalRuntimeException
        Label proceedOriginal = mg.mark();
        if (callInvocationHandler)
        {
            mg.loadThis();
            mg.getField(proxyType, FIELDNAME_HANDLER, invocationHandlerType);
            mg.loadThis();
            loadCurrentMethod(mg, method, methodType);
            loadArguments(mg, method, methodType);
            mg.invokeVirtual(invocationHandlerType,
                    Method.getMethod("Object invoke(Object, java.lang.reflect.Method, Object[])"));
            mg.unbox(methodType.getReturnType());
            mg.returnValue();
        }
        else
        {
            mg.loadThis();
            mg.loadArgs();
            mg.visitMethodInsn(Opcodes.INVOKESPECIAL,
                    superType.getInternalName(),
                    method.getName(),
                    Type.getMethodDescriptor(method),
                    false);
            mg.returnValue();
        }
        mg.visitTryCatchBlock(tryBlockStart, tryBlockEnd, proceedOriginal,
                Type.getInternalName(ProceedOriginalMethodException.class));

        // catch declared exceptions
        if (exceptionTypes.length > 0)
        {
            Label rethrow = mg.mark();
            mg.visitVarInsn(Opcodes.ASTORE, 1);
            mg.visitVarInsn(Opcodes.ALOAD, 1);
            mg.throwException();

            // catch declared exceptions and rethrow it...
            for (Type exceptionType : exceptionTypes)
            {
                if (exceptionType.getClassName().equals(Throwable.class.getName()))
                {
                    throwableCatched = true;
                }
                mg.visitTryCatchBlock(tryBlockStart, tryBlockEnd, rethrow, exceptionType.getInternalName());
            }
        }

        if (!throwableCatched)
        {
            // catch Throwable and wrap it with a UndeclaredThrowableException
            Type uteType = Type.getType(UndeclaredThrowableException.class);
            Label wrapAndRethrow = mg.mark();

            mg.visitVarInsn(Opcodes.ASTORE, 1);
            mg.newInstance(uteType);
            mg.dup();
            mg.visitVarInsn(Opcodes.ALOAD, 1);
            mg.invokeConstructor(uteType,
                    Method.getMethod("void <init>(java.lang.Throwable)"));
            mg.throwException();

            mg.visitTryCatchBlock(tryBlockStart, tryBlockEnd, wrapAndRethrow, Type.getInternalName(Throwable.class));
        }

        // finish the method
        mg.endMethod();
        mg.visitMaxs(10, 10);
        mg.visitEnd();
    }

    /**
     * Generates:
     * <pre>
     * Method method =
     *      method.getDeclaringClass().getMethod("methodName", new Class[] { args... });
     * </pre>
     * @param mg
     * @param method
     * @param methodType
     */
    private static void loadCurrentMethod(GeneratorAdapter mg, java.lang.reflect.Method method, Type methodType)
    {
        mg.push(Type.getType(method.getDeclaringClass()));
        mg.push(method.getName());

        // create the Class[]
        mg.push(methodType.getArgumentTypes().length);
        mg.newArray(TYPE_CLASS);

        // push parameters into array
        for (int i = 0; i < methodType.getArgumentTypes().length; i)
        {
            // keep copy of array on stack
            mg.dup();

            // push index onto stack
            mg.push(i);
            mg.push(methodType.getArgumentTypes()[i]);
            mg.arrayStore(TYPE_CLASS);
        }

        // invoke getMethod() with the method name and the array of types
        mg.invokeVirtual(TYPE_CLASS, Method.getMethod("java.lang.reflect.Method getDeclaredMethod(String, Class[])"));
    }

    /**
     * Defines a new Object[] and push all method argmuments into the array.
     *
     * @param mg
     * @param method
     * @param methodType
     */
    private static void loadArguments(GeneratorAdapter mg, java.lang.reflect.Method method, Type methodType)
    {
        // create the Object[]
        mg.push(methodType.getArgumentTypes().length);
        mg.newArray(TYPE_OBJECT);

        // push parameters into array
        for (int i = 0; i < methodType.getArgumentTypes().length; i)
        {
            // keep copy of array on stack
            mg.dup();

            // push index onto stack
            mg.push(i);

            mg.loadArg(i);
            mg.valueOf(methodType.getArgumentTypes()[i]);
            mg.arrayStore(TYPE_OBJECT);
        }
    }

    private static Type[] getTypes(Class<?>... src)
    {
        Type[] result = new Type[src.length];
        for (int i = 0; i < result.length; i)
        {
            result[i] = Type.getType(src[i]);
        }
        return result;
    }

    /**
     * Adapted from http://asm.ow2.org/doc/faq.html#Q5
     *
     * @param b
     *
     * @return Class<?>
     */
    private static Class<?> loadClass(ClassLoader loader, String className, byte[] b)
    {
        // override classDefine (as it is protected) and define the class.
        try
        {
            java.lang.reflect.Method method = ClassLoader.class.getDeclaredMethod(
                    "defineClass", String.class, byte[].class, int.class, int.class);

            // protected method invocation
            boolean accessible = method.isAccessible();
            if (!accessible)
            {
                method.setAccessible(true);
            }
            try
            {
                return (Class<?>) method.invoke(loader, className, b, Integer.valueOf(0), Integer.valueOf(b.length));
            }
            finally
            {
                if (!accessible)
                {
                    method.setAccessible(false);
                }
            }
        }
        catch (Exception e)
        {
            throw e instanceof RuntimeException ? ((RuntimeException) e) : new RuntimeException(e);
        }
    }
}
 b/deltaspike/modules/partial-bean/impl/src/main/java/org/apache/deltaspike/partialbean/impl/proxy/PartialBeanProxy.java
package org.apache.deltaspike.partialbean.impl.proxy;
    void setRedirectInvocationHandler(InvocationHandler redirectInvocationHandler);

    InvocationHandler getRedirectInvocationHandler();
}
 b/deltaspike/modules/partial-bean/impl/src/main/java/org/apache/deltaspike/partialbean/impl/proxy/PartialBeanProxyFactory.java
package org.apache.deltaspike.partialbean.impl.proxy;
            ArrayList<Method> redirectMethods = new ArrayList<Method>();
            ArrayList<Method> interceptionMethods = new ArrayList<Method>();
            collectMethods(targetClass, redirectMethods, interceptionMethods);

            proxyClass = AsmProxyClassGenerator.generateProxyClass(classLoader,
                    redirectMethods.toArray(new Method[redirectMethods.size()]),
                    interceptionMethods.toArray(new Method[interceptionMethods.size()]));
     * Checks if the given class is DS proxy class.
    private static void collectMethods(Class<?> clazz,
            ArrayList<Method> redirectMethods,
            ArrayList<Method> interceptionMethods)
            if (!ignoreMethod(method, methods))
            if (!ignoreMethod(method, methods))
                    if (!ignoreMethod(method, methods))
                    if (!ignoreMethod(method, methods))
                if (Modifier.isAbstract(method.getModifiers()))
                    try
                        Method foundMethod = currentClass.getMethod(method.getName(), method.getParameterTypes());
                        // if method is implementent in the current class -> remove it
                        if (foundMethod != null && !Modifier.isAbstract(foundMethod.getModifiers()))
                        {
                            methodIterator.remove();
                        }
                    catch (Exception e)
                    {
                        // ignore...
                    }
        Iterator<Method> it = methods.iterator();
        while (it.hasNext())
        {
            Method method = it.next();

            if (Modifier.isAbstract(method.getModifiers()))
            {
                redirectMethods.add(method);
            }
            else if (Modifier.isPublic(method.getModifiers()) && !Modifier.isFinal(method.getModifiers()))
            {
                interceptionMethods.add(method);
            }
        }


    private static boolean ignoreMethod(Method method, List<Method> methods)
        // we have no interest in generics bridge methods
        if (method.isBridge())
        {
            return true;
        }

        // we do not proxy finalize()
        if ("finalize".equals(method.getName()))
        {
            return true;
        }

        // same method...

        // check if a method with the same signature is already available


}
import static java.lang.annotation.ElementType.METHOD;
@Target({ TYPE, METHOD })
}
import java.io.Serializable;
import javax.inject.Inject;
    @Inject private CustomInterceptorState interceptionStateHolder;

        interceptionStateHolder.setIntercepted(true);
}
 b/deltaspike/modules/partial-bean/impl/src/test/java/org/apache/deltaspike/test/core/api/partialbean/shared/CustomInterceptorState.java
package org.apache.deltaspike.test.core.api.partialbean.shared;
import javax.enterprise.context.RequestScoped;

@RequestScoped
public class CustomInterceptorState
    private boolean intercepted;

    public boolean isIntercepted()
    {
        return intercepted;
    }

    public void setIntercepted(boolean intercepted)
    {
        this.intercepted = intercepted;
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc001;

import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;

import javax.enterprise.context.RequestScoped;

@TestPartialBeanBinding
@RequestScoped
public interface PartialBean
{
    String getResult();
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc002;

import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestBean;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;

@TestPartialBeanBinding
@RequestScoped
public abstract class PartialBean
{
    @Inject
    private TestBean testBean;

    private String value;

    public abstract String getResult(String value);

    @PostConstruct
    protected void onCreate()
    {
        this.value = "manual";
    }

    @PreDestroy
    protected void onDestroy()
    {
        //TODO check in a test
    }

    public String getManualResult()
    {
        return this.value  "-"  this.testBean.getValue();
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc003;

import javax.enterprise.context.ApplicationScoped;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;

@TestPartialBeanBinding
@ApplicationScoped
public interface PartialBean extends SuperInterface<Object>, SuperInterface2<Object>
{

 b/deltaspike/modules/partial-bean/impl/src/test/java/org/apache/deltaspike/test/core/api/partialbean/uc003/SuperInterface.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc003;

public interface SuperInterface<E>
{
    E test(E entity);
}
 b/deltaspike/modules/partial-bean/impl/src/test/java/org/apache/deltaspike/test/core/api/partialbean/uc003/SuperInterface2.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc003;

public interface SuperInterface2<E>
{
     E test(E entity);
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc004;

public abstract class AbstractSuper implements SuperInterface
{

}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc004;

import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;

import javax.enterprise.context.ApplicationScoped;

@TestPartialBeanBinding
@ApplicationScoped
public abstract class ApplicationScopedPartialBean extends AbstractSuper
{
    private int count;

    public abstract String getResult();

    public int getManualResult()
    {
        return count;
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc004;

public interface SuperInterface
{
    String willFail();
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc005;

public abstract class AbstractSuper
{
    public abstract String willFail2();
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc005;

import javax.enterprise.context.ApplicationScoped;

import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;

@TestPartialBeanBinding
@ApplicationScoped
public abstract class ApplicationScopedPartialBean extends AbstractSuper implements SuperInterface
{
    private int count;

    public abstract String getResult();

    public int getManualResult()
    {
        return count;
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc005;

public interface SuperInterface
{
    String willFail();
}
/*
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc006;

public abstract class AbstractSuper<T> extends AbstractSuperSuper
{
    public abstract T willFail2() throws Throwable;

    @Override
    public String willFail3() throws ClassNotFoundException, NoSuchMethodException, NoSuchFieldException
    {
        return "willFail3";
    }
}
/*
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc006;

public abstract class AbstractSuperSuper
{
    public abstract String willFail3() throws Throwable;
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc006;

import org.apache.deltaspike.test.core.api.partialbean.shared.ThrowExceptionPartialBeanBinding;
import javax.enterprise.context.ApplicationScoped;

@ThrowExceptionPartialBeanBinding
@ApplicationScoped
public abstract class ApplicationScopedPartialBean extends AbstractSuper<String>
{
    private int count;

    public abstract String getResult();

    public int getManualResult()
    {
        return count;
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc007;

import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;

import javax.enterprise.context.RequestScoped;
import org.apache.deltaspike.test.core.api.partialbean.shared.CustomInterceptor;

@TestPartialBeanBinding
@RequestScoped
public abstract class PartialBean
{
    @CustomInterceptor
    public abstract String getResult();

    @CustomInterceptor
    public void doSomething()
    {

    }
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.test.core.api.partialbean.uc008;

import org.apache.deltaspike.test.core.api.partialbean.shared.CustomInterceptor;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;

import javax.enterprise.context.RequestScoped;

@CustomInterceptor
@TestPartialBeanBinding
@RequestScoped
public abstract class PartialBean
{
    public abstract String getResult();

    public String getManualResult()
    {
        return "manual";
    }
}
            // call stored InvocationHandler
            // call super method
import java.util.concurrent.CopyOnWriteArrayList;
        List<ConfigFilter> currentConfigFilters = getInternalConfigFilters();
        return Collections.unmodifiableList(getInternalConfigFilters());
    }

    /**
     * @return the {@link ConfigFilter}s for the current application.
     */
    private static List<ConfigFilter> getInternalConfigFilters()
    {
            currentConfigFilters = new CopyOnWriteArrayList<ConfigFilter>();
        List<ConfigFilter> currentConfigFilters = getInternalConfigFilters();
        List<ConfigFilter> currentConfigFilters = getInternalConfigFilters();
    public static synchronized ConfigSource[] getConfigSources()
    /**
     * Filter the configured value.
     * This can e.g. be used for decryption.
     * @return the filtered value
     */
    public static String filterConfigValue(String key, String value)
    /**
     * Filter the configured value for logging.
     * This can e.g. be used for displaying ***** instead of a real password.
     * @return the filtered value
     */
    public static String filterConfigValueForLog(String key, String value)
        List<? extends ConfigFilter> configFilters = ServiceUtils.loadServiceImplementations(ConfigFilter.class);
        for (ConfigFilter configFilter : configFilters)
        {
            addConfigFilter(configFilter);
        }

 * <p>A filter which can be added to the
 * values for logging.</p>
 *
 * <p>Registering a {@code ConfigFilter} can either be done via the
 * {@code java.util.ServiceLoader} pattern or by manually adding it via
 * {@link org.apache.deltaspike.core.api.config.ConfigResolver#addConfigFilter(ConfigFilter)}.</p>

    /**
     * Load all {@link PropertyFileConfig}s which are registered via
     * {@code java.util.ServiceLoader}.
     */
     * This will also clean up all ConfigFilters.
        ClassLoader classLoader = ClassUtils.getClassLoader(null);
        configSources.remove(classLoader);
        configFilters.remove(classLoader);
                descriptor = new PartialBeanDescriptor(bindingClass, null, beanClass);
                descriptors.put(bindingClass, descriptor);
            else if (!descriptor.getClasses().contains(beanClass))
import java.util.HashSet;
import java.util.Set;
    private Set<Class<?>> classes;
        this.classes = new HashSet<Class<?>>();
        this(binding);
            Class<?> clazz)
        this(binding, handler);
        this.classes.add(clazz);
    
    public Set<Class<?>> getClasses()
    public void setClasses(Set<Class<?>> classes)
                    return manualInvocationHandler.proceedOriginal(target, method, parameters);
        Object value = manualInvocationHandler.proceedOriginal(target, method, parameters);
        return value;
            ManualInvocationContext invocationContext =
                    new ManualInvocationContext(this, interceptors, proxy, method, parameters, null);
            return invocationContext.proceed();
    protected Object proceedOriginal(Object proxy, Method method, Object[] parameters) throws Exception
        InputStream inputStream = null;
        try
        {
            inputStream = this.readStream(injectableResource);
            this.loadInputStreamToProperties(inputStream, properties, name);
            return properties;
        }
        finally
        {
            if (inputStream != null)
            {
                try
                {
                    inputStream.close();
                }
                catch (IOException e)
                {
                    if (logger.isLoggable(Level.FINE))
                    {
                        logger.log(Level.FINE, "Problem closing resource.", e);
                    }
                }
            }
        }
import javax.enterprise.inject.spi.BeanManager;
    
    protected BeanManager beanManager;
    
    protected boolean proceedOriginal;
        if (proceedOriginal)
        {
            return null;
        }
        
                // lazy init beanManager
                if (beanManager == null)
                    beanManager = BeanManagerProvider.getInstance().getBeanManager();
                interceptor = interceptors.get(interceptorIndex);
                creationalContext = beanManager.createCreationalContext(interceptor);
                interceptorInstance = interceptor.create(creationalContext);

                return interceptor.intercept(InterceptionType.AROUND_INVOKE, interceptorInstance, this);
        
        // workaround for OWB 1.1
        // interceptor#intercept always return null. Therefore we must remember here,
        // that our interceptor chain is finished and #proceedOriginal should be called outside
        proceedOriginal = true;
        
        return manualInvocationHandler.proceedOriginal(target, method, parameters);

    public boolean isProceedOriginal()
    {
        return proceedOriginal;
    }
    public static final Object PROCEED_ORIGINAL = new Object();
    
            Object returnValue = invocationContext.proceed();
            if (invocationContext.isProceedOriginal())
            {
                return proceedOriginal(proxy, method, parameters);
            }
            return returnValue;
        return PROCEED_ORIGINAL;

        // invoke our ProxyInvocationHandler and store it in a local variable
        int manualInvocationHandlerReturnValue = mg.newLocal(TYPE_OBJECT);
        mg.storeLocal(manualInvocationHandlerReturnValue);
        
        // check if ManualInvocationHandler returned the PROCEED_ORIGINAL object
        // if true, we switch to our special logic, otherwise return the returned value
        Label proceedOriginalStart = new Label();
        mg.getStatic(Type.getType(ManualInvocationHandler.class), "PROCEED_ORIGINAL", TYPE_OBJECT);
        mg.loadLocal(manualInvocationHandlerReturnValue);
        mg.ifCmp(TYPE_OBJECT, GeneratorAdapter.EQ, proceedOriginalStart);
        
        mg.loadLocal(manualInvocationHandlerReturnValue);
        mg.mark(proceedOriginalStart);
        
        
        
        boolean throwableCatched = false;
 b/deltaspike/modules/partial-bean/impl/src/main/java/org/apache/deltaspike/partialbean/impl/interception/AbstractManualInvocationHandler.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.partialbean.impl.interception;

import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import javax.enterprise.inject.Typed;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.InterceptionType;
import javax.enterprise.inject.spi.Interceptor;
import javax.interceptor.InterceptorBinding;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;

@Typed
public abstract class AbstractManualInvocationHandler implements InvocationHandler
{
    @Override
    public Object invoke(Object proxy, Method method, Object[] parameters) throws Throwable
    {
        List<Interceptor<?>> interceptors = resolveInterceptors(proxy, method);
        if (interceptors != null && interceptors.size() > 0)
        {
            try
            {
                ManualInvocationContext invocationContext =
                        new ManualInvocationContext(this, interceptors, proxy, method, parameters, null);

                Object returnValue = invocationContext.proceed();

                if (invocationContext.isProceedOriginal())
                {
                    return invocationContext.getProceedOriginalReturnValue();
                }

                return returnValue;
            }
            catch (ManualInvocationThrowableWrapperException e)
            {
                throw e.getCause();
            }
        }

        return proceedOriginal(proxy, method, parameters);
    }

    protected abstract Object proceedOriginal(Object proxy, Method method, Object[] parameters) throws Throwable;

    protected List<Interceptor<?>> resolveInterceptors(Object instance, Method method)
    {
        Annotation[] interceptorBindings = extractInterceptorBindings(instance, method);
        if (interceptorBindings.length > 0)
        {
            BeanManager beanManager = BeanManagerProvider.getInstance().getBeanManager();
            return beanManager.resolveInterceptors(InterceptionType.AROUND_INVOKE, interceptorBindings);
        }

        return null;
    }

    protected Annotation[] extractInterceptorBindings(Object instance, Method method)
    {
        ArrayList<Annotation> bindings = new ArrayList<Annotation>();

        for (Annotation annotation : instance.getClass().getDeclaredAnnotations())
        {
            if (annotation.annotationType().isAnnotationPresent(InterceptorBinding.class)
                    && !bindings.contains(annotation))
            {
                bindings.add(annotation);
            }
        }

        for (Annotation annotation : method.getDeclaredAnnotations())
        {
            if (annotation.annotationType().isAnnotationPresent(InterceptorBinding.class)
                    && !bindings.contains(annotation))
            {
                bindings.add(annotation);
            }
        }

        return bindings.toArray(new Annotation[bindings.size()]);
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.partialbean.impl.interception;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.Typed;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.InterceptionType;
import javax.enterprise.inject.spi.Interceptor;
import javax.interceptor.InvocationContext;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;

@Typed
public class ManualInvocationContext<T, H> implements InvocationContext
{
    protected List<Interceptor<H>> interceptors;
    protected int interceptorIndex;
    protected T target;
    protected Method method;
    protected Object[] parameters;
    protected Map<String, Object> contextData;
    protected Object timer;
    protected AbstractManualInvocationHandler manualInvocationHandler;

    protected BeanManager beanManager;

    protected boolean proceedOriginal;
    protected Object proceedOriginalReturnValue;

    public ManualInvocationContext(AbstractManualInvocationHandler manualInvocationHandler,
            List<Interceptor<H>> interceptors, T target, Method method, Object[] parameters, Object timer)
    {
        this.manualInvocationHandler = manualInvocationHandler;
        this.interceptors = interceptors;
        this.target = target;
        this.method = method;
        this.parameters = parameters;
        this.timer = timer;

        this.interceptorIndex = 0;
    }

    @Override
    public Object getTarget()
    {
        return target;
    }

    @Override
    public Method getMethod()
    {
        return method;
    }

    @Override
    public Object[] getParameters()
    {
        return parameters;
    }

    @Override
    public void setParameters(Object[] os)
    {
        parameters = os;
    }

    @Override
    public Map<String, Object> getContextData()
    {
        if (contextData == null)
        {
            contextData = new HashMap<String, Object>();
        }
        return contextData;
    }

    @Override
    public Object proceed() throws Exception
    {
        if (proceedOriginal)
        {
            return null;
        }

        if (interceptors.size() > interceptorIndex)
        {
            Interceptor<H> interceptor = null;
            CreationalContext<H> creationalContext = null;
            H interceptorInstance = null;

            try
            {
                // lazy init beanManager
                if (beanManager == null)
                {
                    beanManager = BeanManagerProvider.getInstance().getBeanManager();
                }

                interceptor = interceptors.get(interceptorIndex);
                creationalContext = beanManager.createCreationalContext(interceptor);
                interceptorInstance = interceptor.create(creationalContext);

                return interceptor.intercept(InterceptionType.AROUND_INVOKE, interceptorInstance, this);
            }
            finally
            {
                if (creationalContext != null)
                {
                    if (interceptorInstance != null && interceptor != null)
                    {
                        interceptor.destroy(interceptorInstance, creationalContext);
                    }

                    creationalContext.release();
                }
            }
        }


        // workaround for OWB 1.1, otherwise we could just return the proceedOriginalReturnValue value in this method
        try
        {
            proceedOriginal = true;
            proceedOriginalReturnValue = manualInvocationHandler.proceedOriginal(target, method, parameters);
        }
        catch (Exception e)
        {
            throw e;
        }
        catch (Throwable e)
        {
            // wrap the Throwable here as interceptors declared only "throws Exception"
            throw new ManualInvocationThrowableWrapperException(e);
        }

        return null;
    }

    @Override
    public Object getTimer()
    {
        return timer;
    }

    // @Override
    // CDI 1.1 compatibility
    public Constructor getConstructor()
    {
        return null;
    }

    public boolean isProceedOriginal()
    {
        return proceedOriginal;
    }

    public Object getProceedOriginalReturnValue()
    {
        return proceedOriginalReturnValue;
    }

    public void setProceedOriginalReturnValue(Object proceedOriginalReturnValue)
    {
        this.proceedOriginalReturnValue = proceedOriginalReturnValue;
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.partialbean.impl.proxy;

import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.Arrays;
import javax.enterprise.inject.Typed;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.objectweb.asm.commons.Method;

@Typed
public abstract class AsmProxyClassGenerator
{
    private static final String FIELDNAME_HANDLER = "__handler";

    private static final Type TYPE_CLASS = Type.getType(Class.class);
    private static final Type TYPE_OBJECT = Type.getType(Object.class);

    private AsmProxyClassGenerator()
    {
        // prevent instantiation
    }

    public static <T> Class<T> generateProxyClass(ClassLoader classLoader,
            Class<T> targetClass,
            Class<? extends InvocationHandler> invocationHandlerClass,
            String suffix,
            String superAccessorMethodSuffix,
            java.lang.reflect.Method[] redirectMethods,
            java.lang.reflect.Method[] interceptionMethods)
    {
        String proxyName = targetClass.getCanonicalName()  suffix;
        String classFileName = proxyName.replace('.', '/');

        byte[] proxyBytes = generateProxyClassBytes(targetClass, invocationHandlerClass,
                classFileName, superAccessorMethodSuffix, redirectMethods, interceptionMethods);
        
        Class<T> proxyClass = (Class<T>) loadClass(classLoader, proxyName, proxyBytes);

        return proxyClass;
    }

    private static byte[] generateProxyClassBytes(Class<?> targetClass,
            Class<? extends InvocationHandler> invocationHandlerClass,
            String proxyName,
            String superAccessorMethodSuffix,
            java.lang.reflect.Method[] redirectMethods,
            java.lang.reflect.Method[] interceptionMethods)
    {
        Class<?> superClass = targetClass;
        String[] interfaces = new String[] { };

        if (targetClass.isInterface())
        {
            superClass = Object.class;
            interfaces = new String[] { Type.getInternalName(targetClass) };
        }

        // add PartialBeanProxy as interface
        interfaces = Arrays.copyOf(interfaces, interfaces.length  1);
        interfaces[interfaces.length - 1] = Type.getInternalName(PartialBeanProxy.class);

        Type superType = Type.getType(superClass);
        Type proxyType = Type.getObjectType(proxyName);
        Type invocationHandlerType = Type.getType(invocationHandlerClass);

        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC  Opcodes.ACC_SUPER, proxyType.getInternalName(), null,
                superType.getInternalName(), interfaces);

        // copy annotations
        for (Annotation annotation : targetClass.getDeclaredAnnotations())
        {
            cw.visitAnnotation(Type.getDescriptor(annotation.annotationType()), true).visitEnd();
        }

        defineInvocationHandlerField(cw, invocationHandlerType);
        defineConstructor(cw, proxyType, superType);
        definePartialBeanProxyMethods(cw, proxyType, invocationHandlerType);

        for (java.lang.reflect.Method method : redirectMethods)
        {
            defineMethod(cw, method, RedirectManualInvocationHandler.class);
        }

        for (java.lang.reflect.Method method : interceptionMethods)
        {
            defineSuperAccessorMethod(cw, method, superType, superAccessorMethodSuffix);
            defineMethod(cw, method, CallSuperManualInvocationHandler.class);
        }

        return cw.toByteArray();
    }

    private static void defineInvocationHandlerField(ClassWriter cw, Type invocationHandlerType)
    {
        // generates
        // private MyPartialBeanInvocationHandler __handler;
        cw.visitField(Opcodes.ACC_PRIVATE, FIELDNAME_HANDLER, invocationHandlerType.getDescriptor(), null, null)
                .visitEnd();
    }

    private static void defineConstructor(ClassWriter cw, Type proxyType, Type superType)
    {
        GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC,
                new Method("<init>", Type.VOID_TYPE, new Type[]{ }),
                null,
                null,
                cw);

        mg.visitCode();

        // invoke super constructor
        mg.loadThis();
        mg.invokeConstructor(superType, Method.getMethod("void <init> ()"));
        mg.returnValue();
        mg.endMethod();

        mg.visitEnd();
    }

    private static void definePartialBeanProxyMethods(ClassWriter cw, Type proxyType, Type invocationHandlerType)
    {
        try
        {
            // implement #setRedirectInvocationHandler
            Method asmMethod = Method.getMethod(PartialBeanProxy.class.getDeclaredMethod(
                    "setRedirectInvocationHandler", InvocationHandler.class));
            GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC, asmMethod, null, null, cw);

            mg.visitCode();

            mg.loadThis();
            mg.loadArg(0);
            mg.checkCast(invocationHandlerType);
            mg.putField(proxyType, FIELDNAME_HANDLER, invocationHandlerType);
            mg.returnValue();

            mg.visitMaxs(2, 1);
            mg.visitEnd();


            // implement #getRedirectInvocationHandler
            asmMethod = Method.getMethod(PartialBeanProxy.class.getDeclaredMethod("getRedirectInvocationHandler"));
            mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC, asmMethod, null, null, cw);

            mg.visitCode();

            mg.loadThis();
            mg.getField(proxyType, FIELDNAME_HANDLER, invocationHandlerType);
            mg.returnValue();

            mg.visitMaxs(2, 1);
            mg.visitEnd();
        }
        catch (NoSuchMethodException e)
        {
            throw new IllegalStateException("Unable to implement "  PartialBeanProxy.class.getName(), e);
        }
    }

    private static void defineSuperAccessorMethod(ClassWriter cw, java.lang.reflect.Method method, Type superType,
            String superAccessorMethodSuffix) 
    {
        Method originalAsmMethod = Method.getMethod(method);
        Method newAsmMethod = new Method(method.getName()  superAccessorMethodSuffix,
                originalAsmMethod.getReturnType(),
                originalAsmMethod.getArgumentTypes());
        GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC, newAsmMethod, null, null, cw);
        
        mg.visitCode();
        
        // call super method
        mg.loadThis();
        mg.loadArgs();
        mg.visitMethodInsn(Opcodes.INVOKESPECIAL,
                superType.getInternalName(),
                method.getName(),
                Type.getMethodDescriptor(method),
                false);
        mg.returnValue();
        
        // finish the method
        mg.endMethod();
        mg.visitMaxs(10, 10);
        mg.visitEnd();
    }
    
    private static void defineMethod(ClassWriter cw, java.lang.reflect.Method method,
            Class manualInvocationHandlerClass)
    {
        Type methodType = Type.getType(method);
        Type[] exceptionTypes = getTypes(method.getExceptionTypes());

        // push the method definition
        int modifiers = (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED) & method.getModifiers();
        Method asmMethod = Method.getMethod(method);
        GeneratorAdapter mg = new GeneratorAdapter(modifiers, asmMethod, null, exceptionTypes, cw);

        // copy annotations
        for (Annotation annotation : method.getDeclaredAnnotations())
        {
            mg.visitAnnotation(Type.getDescriptor(annotation.annotationType()), true).visitEnd();
        }

        mg.visitCode();

        Label tryBlockStart = mg.mark();

        mg.loadThis();
        loadCurrentMethod(mg, method, methodType);
        loadArguments(mg, method, methodType);
        
        // invoke our ProxyInvocationHandler
        mg.invokeStatic(Type.getType(manualInvocationHandlerClass),
                Method.getMethod("Object staticInvoke(Object, java.lang.reflect.Method, Object[])"));

        // cast the result
        mg.unbox(methodType.getReturnType());

        // push return
        mg.returnValue();

        // build try catch
        Label tryBlockEnd = mg.mark();
        boolean throwableCatched = false;

        // catch declared exceptions
        if (exceptionTypes.length > 0)
        {
            Label rethrow = mg.mark();
            mg.visitVarInsn(Opcodes.ASTORE, 1);
            mg.visitVarInsn(Opcodes.ALOAD, 1);
            mg.throwException();

            // catch declared exceptions and rethrow it...
            for (Type exceptionType : exceptionTypes)
            {
                if (exceptionType.getClassName().equals(Throwable.class.getName()))
                {
                    throwableCatched = true;
                }
                mg.visitTryCatchBlock(tryBlockStart, tryBlockEnd, rethrow, exceptionType.getInternalName());
            }
        }

        if (!throwableCatched)
        {
            // catch Throwable and wrap it with a UndeclaredThrowableException
            Type uteType = Type.getType(UndeclaredThrowableException.class);
            Label wrapAndRethrow = mg.mark();

            mg.visitVarInsn(Opcodes.ASTORE, 1);
            mg.newInstance(uteType);
            mg.dup();
            mg.visitVarInsn(Opcodes.ALOAD, 1);
            mg.invokeConstructor(uteType,
                    Method.getMethod("void <init>(java.lang.Throwable)"));
            mg.throwException();

            mg.visitTryCatchBlock(tryBlockStart, tryBlockEnd, wrapAndRethrow, Type.getInternalName(Throwable.class));
        }

        // finish the method
        mg.endMethod();
        mg.visitMaxs(10, 10);
        mg.visitEnd();
    }

    /**
     * Generates:
     * <pre>
     * Method method =
     *      method.getDeclaringClass().getMethod("methodName", new Class[] { args... });
     * </pre>
     * @param mg
     * @param method
     * @param methodType
     */
    private static void loadCurrentMethod(GeneratorAdapter mg, java.lang.reflect.Method method, Type methodType)
    {
        mg.push(Type.getType(method.getDeclaringClass()));
        mg.push(method.getName());

        // create the Class[]
        mg.push(methodType.getArgumentTypes().length);
        mg.newArray(TYPE_CLASS);

        // push parameters into array
        for (int i = 0; i < methodType.getArgumentTypes().length; i)
        {
            // keep copy of array on stack
            mg.dup();

            // push index onto stack
            mg.push(i);
            mg.push(methodType.getArgumentTypes()[i]);
            mg.arrayStore(TYPE_CLASS);
        }

        // invoke getMethod() with the method name and the array of types
        mg.invokeVirtual(TYPE_CLASS, Method.getMethod("java.lang.reflect.Method getDeclaredMethod(String, Class[])"));
    }

    /**
     * Defines a new Object[] and push all method argmuments into the array.
     *
     * @param mg
     * @param method
     * @param methodType
     */
    private static void loadArguments(GeneratorAdapter mg, java.lang.reflect.Method method, Type methodType)
    {
        // create the Object[]
        mg.push(methodType.getArgumentTypes().length);
        mg.newArray(TYPE_OBJECT);

        // push parameters into array
        for (int i = 0; i < methodType.getArgumentTypes().length; i)
        {
            // keep copy of array on stack
            mg.dup();

            // push index onto stack
            mg.push(i);

            mg.loadArg(i);
            mg.valueOf(methodType.getArgumentTypes()[i]);
            mg.arrayStore(TYPE_OBJECT);
        }
    }

    private static Type[] getTypes(Class<?>... src)
    {
        Type[] result = new Type[src.length];
        for (int i = 0; i < result.length; i)
        {
            result[i] = Type.getType(src[i]);
        }
        return result;
    }

    /**
     * Adapted from http://asm.ow2.org/doc/faq.html#Q5
     *
     * @param b
     *
     * @return Class<?>
     */
    private static Class<?> loadClass(ClassLoader loader, String className, byte[] b)
    {
        // override classDefine (as it is protected) and define the class.
        try
        {
            java.lang.reflect.Method method = ClassLoader.class.getDeclaredMethod(
                    "defineClass", String.class, byte[].class, int.class, int.class);

            // protected method invocation
            boolean accessible = method.isAccessible();
            if (!accessible)
            {
                method.setAccessible(true);
            }
            try
            {
                return (Class<?>) method.invoke(loader, className, b, Integer.valueOf(0), Integer.valueOf(b.length));
            }
            finally
            {
                if (!accessible)
                {
                    method.setAccessible(false);
                }
            }
        }
        catch (Exception e)
        {
            throw e instanceof RuntimeException ? ((RuntimeException) e) : new RuntimeException(e);
        }
    }
}
    private static final String SUPER_ACCESSOR_METHOD_SUFFIX = "$super";
                    SUPER_ACCESSOR_METHOD_SUFFIX,
    private static String constructSuperAccessorMethodName(Method method)
    {
        return method.getName()  SUPER_ACCESSOR_METHOD_SUFFIX;
    }
    
    public static Method getSuperAccessorMethod(Object proxy, Method method) throws NoSuchMethodException
    {
        return proxy.getClass().getMethod(
                constructSuperAccessorMethodName(method),
                method.getParameterTypes());
    }
    
}
        String a = "test";
import java.util.ArrayList;
        
        ArrayList<Type> exceptionsToCatch = new ArrayList<Type>();
        for (Class<?> exception : method.getExceptionTypes())
        {
            if (!RuntimeException.class.isAssignableFrom(exception))
            {
                exceptionsToCatch.add(Type.getType(exception));
            }
        }
        
        GeneratorAdapter mg = new GeneratorAdapter(modifiers,
                asmMethod,
                null,
                getTypes(method.getExceptionTypes()),
                cw);
        // build try catch
        Label tryBlockEnd = mg.mark();
        
        // catch runtime exceptions and rethrow it
        Label rethrow = mg.mark();
        mg.visitVarInsn(Opcodes.ASTORE, 1);
        mg.visitVarInsn(Opcodes.ALOAD, 1);
        mg.throwException();
        mg.visitTryCatchBlock(tryBlockStart, tryBlockEnd, rethrow, Type.getInternalName(RuntimeException.class));
        // catch checked exceptions and rethrow it
        boolean throwableCatched = false;
        if (exceptionsToCatch.size() > 0)
            rethrow = mg.mark();
            for (Type exceptionType : exceptionsToCatch)
        // if throwable isn't alreached cachted, catch it and wrap it with an UndeclaredThrowableException and throw it
import java.lang.reflect.InvocationTargetException;
        try
        {
            Method superAccessorMethod = PartialBeanProxyFactory.getSuperAccessorMethod(proxy, method);
            return superAccessorMethod.invoke(proxy, parameters);
        }
        catch (InvocationTargetException e)
        {
            // rethrow original exception
            throw e.getCause();
        }
    public String willFail3() throws RuntimeException, ClassNotFoundException, NoSuchMethodException, NoSuchFieldException
    // TODO stereotypes
import java.lang.annotation.Annotation;
import javax.interceptor.InterceptorBinding;
            // check if a interceptor is defined on class level. if yes -> proxy all public methods
            if (!containsInterceptorBinding(targetClass.getDeclaredAnnotations()))
            {
                // loop every method and check if a interceptor is defined on the method -> otherwise don't proxy
                Iterator<Method> iterator = interceptionMethods.iterator();
                while (iterator.hasNext())
                {
                    Method method = iterator.next();
                    if (!containsInterceptorBinding(method.getDeclaredAnnotations()))
                    {
                        iterator.remove();
                    }
                }
            }
            
    // TODO stereotypes
    private static boolean containsInterceptorBinding(Annotation[] annotations)
    {
        for (Annotation annotation : annotations)
        {
            if (annotation.annotationType().isAnnotationPresent(InterceptorBinding.class))
            {
                return true;
            }
        }
        
        return false;
    }
    
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/invocation/AbstractManualInvocationHandler.java
package org.apache.deltaspike.core.util.invocation;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/invocation/ManualInvocationContext.java
package org.apache.deltaspike.core.util.invocation;
        // workaround for OWB 1.1, otherwise we could just return the proceedOriginalReturnValue here
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/invocation/ManualInvocationThrowableWrapperException.java
package org.apache.deltaspike.core.util.invocation;
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/proxy/AsmProxyClassGenerator.java
package org.apache.deltaspike.core.util.proxy;
import org.apache.deltaspike.core.util.proxy.invocation.InterceptManualInvocationHandler;
import org.apache.deltaspike.core.util.proxy.invocation.DelegateManualInvocationHandler;
    private static final String FIELDNAME_DELEGATE_INVOCATION_HANDLER = "delegateInvocationHandler";
            Class<?>[] additionalInterfaces,
            java.lang.reflect.Method[] delegateMethods,
            java.lang.reflect.Method[] interceptMethods)
                classFileName, superAccessorMethodSuffix, additionalInterfaces, delegateMethods, interceptMethods);
            Class<?>[] additionalInterfaces,
            java.lang.reflect.Method[] delegateMethods,
            java.lang.reflect.Method[] interceptMethods)
        // add DeltaSpikeProxy as interface
        interfaces[interfaces.length - 1] = Type.getInternalName(DeltaSpikeProxy.class);
        if (additionalInterfaces != null && additionalInterfaces.length > 0)
        {
            interfaces = Arrays.copyOf(interfaces, interfaces.length  additionalInterfaces.length);
            for (int i = 0; i < additionalInterfaces.length; i)
            {
                interfaces[(interfaces.length - 1)  i] = Type.getInternalName(additionalInterfaces[i]);
            }
        }
        
        defineDeltaSpikeProxyMethods(cw, proxyType, invocationHandlerType);
        for (java.lang.reflect.Method method : delegateMethods)
            defineMethod(cw, method, DelegateManualInvocationHandler.class);
        for (java.lang.reflect.Method method : interceptMethods)
            defineMethod(cw, method, InterceptManualInvocationHandler.class);
        // private MyInvocationHandler delegateInvocationHandler;
        cw.visitField(Opcodes.ACC_PRIVATE, FIELDNAME_DELEGATE_INVOCATION_HANDLER,
                invocationHandlerType.getDescriptor(), null, null).visitEnd();
    private static void defineDeltaSpikeProxyMethods(ClassWriter cw, Type proxyType, Type invocationHandlerType)
            // implement #setDelegateInvocationHandler
            Method asmMethod = Method.getMethod(DeltaSpikeProxy.class.getDeclaredMethod(
                    "setDelegateInvocationHandler", InvocationHandler.class));
            mg.putField(proxyType, FIELDNAME_DELEGATE_INVOCATION_HANDLER, invocationHandlerType);
            // implement #getDelegateInvocationHandler
            asmMethod = Method.getMethod(DeltaSpikeProxy.class.getDeclaredMethod("getDelegateInvocationHandler"));
            mg.getField(proxyType, FIELDNAME_DELEGATE_INVOCATION_HANDLER, invocationHandlerType);
            throw new IllegalStateException("Unable to implement "  DeltaSpikeProxy.class.getName(), e);
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/proxy/DeltaSpikeProxy.java
package org.apache.deltaspike.core.util.proxy;
public interface DeltaSpikeProxy
    void setDelegateInvocationHandler(InvocationHandler redirectInvocationHandler);
    InvocationHandler getDelegateInvocationHandler();
}
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/proxy/DeltaSpikeProxyContextualLifecycle.java
package org.apache.deltaspike.core.util.proxy;
import javax.enterprise.context.spi.CreationalContext;
import org.apache.deltaspike.core.util.ExceptionUtils;
import org.apache.deltaspike.core.util.metadata.builder.ContextualLifecycle;
public class DeltaSpikeProxyContextualLifecycle<T, H extends InvocationHandler> implements ContextualLifecycle<T>
    private final Class<H> delegateInvocationHandlerClass;
    private final Class<T> targetClass;
    public DeltaSpikeProxyContextualLifecycle(Class<T> targetClass, Class<H> delegateInvocationHandlerClass,
            DeltaSpikeProxyFactory proxyFactory, BeanManager beanManager)
        this.targetClass = targetClass;
        this.delegateInvocationHandlerClass = delegateInvocationHandlerClass;
        this.proxyClass = proxyFactory.getProxyClass(targetClass, delegateInvocationHandlerClass);
        if (!targetClass.isInterface())
            AnnotatedType<T> annotatedType = beanManager.createAnnotatedType(this.targetClass);
            if (delegateInvocationHandlerClass != null)
            {
                H delegateInvocationHandler = instantiateDelegateInvocationHandler();
                ((DeltaSpikeProxy) instance).setDelegateInvocationHandler(delegateInvocationHandler);
            }
        // can't happen
    protected H instantiateDelegateInvocationHandler()
        Set<Bean<H>> handlerBeans = BeanProvider.getBeanDefinitions(this.delegateInvocationHandlerClass, false, true);
            throw new IllegalStateException(handlerBeans.size()  " beans found for "
                     this.delegateInvocationHandlerClass  " found beans: "  beanInfo.toString());
        H handlerInstance = (H) beanManager.getReference(handlerBean,
                this.delegateInvocationHandlerClass, creationalContext);
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/proxy/DeltaSpikeProxyFactory.java
package org.apache.deltaspike.core.util.proxy;
public abstract class DeltaSpikeProxyFactory
    
    public <T> Class<T> getProxyClass(Class<T> targetClass,
    private synchronized <T> Class<T> createProxyClass(ClassLoader classLoader, Class<T> targetClass,
            ArrayList<Method> allMethods = collectAllMethods(targetClass);
            ArrayList<Method> interceptMethods = filterInterceptMethods(targetClass, allMethods);
            ArrayList<Method> delegateMethods = getDelegateMethods(targetClass, allMethods);
            // check if a interceptor is defined on class level. if not, skip interceptor methods
            if (delegateMethods != null
                    && interceptMethods.size() > 0
                    && !containsInterceptorBinding(targetClass.getDeclaredAnnotations()))
                Iterator<Method> iterator = interceptMethods.iterator();
                    getProxyClassSuffix(),
                    getAdditionalInterfacesToImplement(targetClass),
                    delegateMethods == null ? new Method[0]
                            : delegateMethods.toArray(new Method[delegateMethods.size()]),
                    interceptMethods == null ? new Method[0]
                            : interceptMethods.toArray(new Method[interceptMethods.size()]));
    
    protected boolean containsInterceptorBinding(Annotation[] annotations)
        
    protected String constructProxyClassName(Class<?> clazz)
        return clazz.getName()  getProxyClassSuffix();
    protected static String constructSuperAccessorMethodName(Method method)
    public boolean isProxyClass(Class<?> clazz)
        return clazz.getName().endsWith(getProxyClassSuffix());
    protected boolean hasSameSignature(Method a, Method b)
        return a.getName().equals(b.getName())
                && a.getReturnType().equals(b.getReturnType())
                && Arrays.equals(a.getParameterTypes(), b.getParameterTypes());
    }

    protected boolean ignoreMethod(Method method, List<Method> methods)
    {
        // we have no interest in generics bridge methods
        if (method.isBridge())
        {
            return true;
        }

        // we do not proxy finalize()
        if ("finalize".equals(method.getName()))
        {
            return true;
        }

        // same method...
        if (methods.contains(method))
        {
            return true;
        }

        // check if a method with the same signature is already available
        for (Method currentMethod : methods)
        {
            if (hasSameSignature(currentMethod, method))
            {
                return true;
            }
        }

        return false;
    }
    
    protected ArrayList<Method> collectAllMethods(Class<?> clazz)
    {
        ArrayList<Method> methods = new ArrayList<Method>();
        return methods;
    }
    
    protected ArrayList<Method> filterInterceptMethods(Class<?> targetClass, ArrayList<Method> allMethods)
    {
        ArrayList<Method> methods = new ArrayList<Method>();
        
        Iterator<Method> it = allMethods.iterator();
            if (Modifier.isPublic(method.getModifiers())
                    && !Modifier.isFinal(method.getModifiers())
                    && !Modifier.isAbstract(method.getModifiers()))
                methods.add(method);
        
        return methods;
    
    protected Class<?>[] getAdditionalInterfacesToImplement(Class<?> targetClass)
        return null;
    
    protected abstract ArrayList<Method> getDelegateMethods(Class<?> targetClass, ArrayList<Method> allMethods);
    
    protected abstract String getProxyClassSuffix();

 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/proxy/invocation/DelegateManualInvocationHandler.java
package org.apache.deltaspike.core.util.proxy.invocation;
import org.apache.deltaspike.core.util.invocation.AbstractManualInvocationHandler;
import org.apache.deltaspike.core.util.proxy.DeltaSpikeProxy;
public class DelegateManualInvocationHandler extends AbstractManualInvocationHandler
    private static final DelegateManualInvocationHandler INSTANCE = new DelegateManualInvocationHandler();
        InvocationHandler delegateInvocationHandler = ((DeltaSpikeProxy) proxy).getDelegateInvocationHandler();
        return delegateInvocationHandler.invoke(proxy, method, parameters);
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/proxy/invocation/InterceptManualInvocationHandler.java
package org.apache.deltaspike.core.util.proxy.invocation;
import org.apache.deltaspike.core.util.invocation.AbstractManualInvocationHandler;
import org.apache.deltaspike.core.util.proxy.DeltaSpikeProxyFactory;
public class InterceptManualInvocationHandler extends AbstractManualInvocationHandler
    private static final InterceptManualInvocationHandler INSTANCE = new InterceptManualInvocationHandler();
            Method superAccessorMethod = DeltaSpikeProxyFactory.getSuperAccessorMethod(proxy, method);
import org.apache.deltaspike.core.util.proxy.DeltaSpikeProxy;
        if (result instanceof DeltaSpikeProxy || ProxyUtils.isProxiedClass(result.getClass()))
        if (result instanceof DeltaSpikeProxy || ProxyUtils.isProxiedClass(result.getClass()))
import org.apache.deltaspike.core.util.proxy.DeltaSpikeProxyContextualLifecycle;
        DeltaSpikeProxyContextualLifecycle lifecycle = new DeltaSpikeProxyContextualLifecycle(beanClass,
                invocationHandlerClass, ConverterAndValidatorProxyFactory.getInstance(), beanManager);
            .beanLifecycle(lifecycle);
        return method.invoke(defaultPartialStateHolder, args);

    @Override
    @Override
    @Override
        return method.invoke(defaultPartialStateHolder, args);
import org.apache.deltaspike.core.util.proxy.DeltaSpikeProxyContextualLifecycle;
        DeltaSpikeProxyContextualLifecycle lifecycle = new DeltaSpikeProxyContextualLifecycle(beanClass,
                descriptor.getHandler(),
                PartialBeanProxyFactory.getInstance(),
                beanManager);
                .beanLifecycle(lifecycle);
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
        beanBuilder.addQualifier(new DefaultLiteral());

    interface BeanManagerDelegation
        interface WindowRestriction
        if (cdiClass != null && !CoreBaseConfig.BeanManagerDelegation.DELEGATE_LOOKUP.getValue())
        this.maxWindowContextCount = CoreBaseConfig.Scope.WindowRestriction.MAX_COUNT.getValue();
        interface WindowRestriction
                new TypedConfig<Integer>(CoreBaseConfig.Scope.WindowRestriction.MAX_COUNT.getKey(), 64);
        interface ViewDelegation
        this.maxWindowContextCount = JsfBaseConfig.Scope.WindowRestriction.MAX_COUNT.getValue();
        int result = JsfBaseConfig.Scope.WindowRestriction.ID_MAX_LENGTH.getValue();
        if (result > JsfBaseConfig.Scope.WindowRestriction.ID_MAX_LENGTH.getDefaultValue())
            JsfBaseConfig.Scope.ViewDelegation.DELEGATE_TO_JSF.getValue();
        String defaultJobFactoryName = SchedulerBaseConfig.JobCustomization.DEFAULT_JOB_FACTORY_CLASS_NAME.getValue();
    interface JobCustomization
            String jobClassName = SchedulerBaseConfig.JobCustomization.JOB_CLASS_NAME.getValue();
        put(SchedulerBaseConfig.JobCustomization.JOB_CLASS_NAME.getKey(), CustomJob.class.getName());
            put(SchedulerBaseConfig.JobCustomization.JOB_CLASS_NAME.getKey(), CustomJob.class.getName());
        if (!TestBaseConfig.MockIntegration.ALLOW_MOCKED_BEANS.getValue() &&
            !TestBaseConfig.MockIntegration.ALLOW_MOCKED_PRODUCERS.getValue())
                "Please set '"  TestBaseConfig.MockIntegration.ALLOW_MOCKED_BEANS.getKey()  "' and/or '" 
                TestBaseConfig.MockIntegration.ALLOW_MOCKED_PRODUCERS.getKey()  "' to 'true' " 
            return TestBaseConfig.MockIntegration.ALLOW_MOCKED_PRODUCERS.getValue();
            return TestBaseConfig.MockIntegration.ALLOW_MOCKED_BEANS.getValue();
        defineDefaultConstructor(cw, proxyType, superType);
        defineDelegateInvocationHandlerConstructor(cw, proxyType, superType, invocationHandlerType);
    private static void defineDefaultConstructor(ClassWriter cw, Type proxyType, Type superType)
    
    private static void defineDelegateInvocationHandlerConstructor(ClassWriter cw, Type proxyType, Type superType,
            Type invocationHandlerType)
    {
        GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC,
                new Method("<init>", Type.VOID_TYPE, new Type[] { invocationHandlerType }),
                null,
                null,
                cw);

        mg.visitCode();

        // invoke super constructor
        mg.loadThis();
        mg.invokeConstructor(superType, Method.getMethod("void <init> ()"));
        
        // set invocation handler
        mg.loadThis();
        mg.loadArg(0);
        mg.putField(proxyType, FIELDNAME_DELEGATE_INVOCATION_HANDLER, invocationHandlerType);
        
        mg.returnValue();
        mg.endMethod();

        mg.visitEnd();
    }
import java.lang.reflect.Constructor;
            T instance;
            if (delegateInvocationHandlerClass == null)
            {
                instance = proxyClass.newInstance();
            }
            else
                Constructor<T> constructor = proxyClass.getConstructor(delegateInvocationHandlerClass);
                instance = constructor.newInstance(delegateInvocationHandler);
        if (!StateHolder.class.isAssignableFrom(targetClass))
        {
            ArrayList<Method> delegateMethods = new ArrayList<Method>();
            delegateMethods.addAll(Arrays.asList(StateHolder.class.getDeclaredMethods()));
            delegateMethods.addAll(Arrays.asList(PartialStateHolder.class.getDeclaredMethods()));
            return delegateMethods;
        }
        
        if (!PartialStateHolder.class.isAssignableFrom(targetClass))
import java.security.ProtectionDomain;

        Class<T> proxyClass = (Class<T>) loadClass(classLoader, proxyName, proxyBytes,
                targetClass.getProtectionDomain());

    private static Class<?> loadClass(ClassLoader loader, String className, byte[] b,
            ProtectionDomain protectionDomain)
                    "defineClass", String.class, byte[].class, int.class, int.class, ProtectionDomain.class);
                return (Class<?>) method.invoke(loader, className, b, Integer.valueOf(0), Integer.valueOf(b.length),
                        protectionDomain);
import org.apache.deltaspike.core.api.literal.DestroyedLiteral;
import org.apache.deltaspike.core.api.literal.InitializedLiteral;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.metadata.AnnotationInstanceProvider;
import javax.annotation.PostConstruct;
import javax.faces.bean.RequestScoped;
import java.lang.annotation.Annotation;
import java.util.HashMap;
import java.util.Map;
 * Broadcaster for
 * {@link org.apache.deltaspike.core.api.lifecycle.Initialized}
 * {@link org.apache.deltaspike.core.api.lifecycle.Destroyed}
 * with
 * {@link FacesContext} as event-payload
 * and/or in case of CDI 1.1
 * {@link javax.enterprise.context.Initialized}
 * {@link javax.enterprise.context.Destroyed}
 * with
 * {@link javax.faces.bean.RequestScoped} as annotation-parameter and
 * {@link FacesContext} as event-payload
    private Event<FacesContext> jsfRequestEvent;
    /*
     * annotation-instances for the optional cdi 1.1 support
     */
    private Annotation initializedAnnotationInstance;
    private Annotation destroyedAnnotationInstance;

    @PostConstruct
    protected void init()
    {
        Map<String, Class> values = new HashMap<String, Class>();
        values.put("value", RequestScoped.class);
        Class<? extends Annotation> initializedAnnotationClass =
            ClassUtils.tryToLoadClassForName("javax.enterprise.context.Initialized");
        if (initializedAnnotationClass != null)
        {
            this.initializedAnnotationInstance = AnnotationInstanceProvider.of(initializedAnnotationClass, values);
        }

        Class<? extends Annotation> destroyedAnnotationClass =
            ClassUtils.tryToLoadClassForName("javax.enterprise.context.Destroyed");
        if (destroyedAnnotationClass != null)
        {
            this.destroyedAnnotationInstance = AnnotationInstanceProvider.of(destroyedAnnotationClass, values);
        }
    }
     * Broadcasts @Initialized-event(s)
        this.jsfRequestEvent.select(new InitializedLiteral()).fire(facesContext);

        if (this.initializedAnnotationInstance != null)
        {
            this.jsfRequestEvent.select(this.initializedAnnotationInstance).fire(facesContext);
        }
     * Broadcasts @Destroyed-event(s)
        this.jsfRequestEvent.select(new DestroyedLiteral()).fire(facesContext);

        if (this.destroyedAnnotationInstance != null)
        {
            this.jsfRequestEvent.select(this.destroyedAnnotationInstance).fire(facesContext);
        }
            final Object annotationMemberValue = ReflectionUtils.invokeMethod(annotation, member, Object.class, true);
            if (annotationMemberValue == null /*possible with literals*/)
            {
                arrayValue = 0;
            }
            else if (annotationMemberValue.getClass().isArray())
import org.apache.deltaspike.core.util.AnnotationUtils;
import java.util.Collection;
import java.util.Iterator;

                Annotation resultToAdd = preProcessor.beforeAddToConfig(annotation, node);

                //it isn't possible to detect changed annotations
                if (resultToAdd != annotation) //check if the annotation(-instance) was changed
                {
                    validateAnnotationChange(annotation);
                    rewriteMetaDataOfNode(node.getMetaData(), annotation, resultToAdd);
                    rewriteMetaDataOfNode(node.getInheritedMetaData(), annotation, resultToAdd);
                }
                result.add(resultToAdd);

    protected void validateAnnotationChange(Annotation annotation)
    {
        Class<? extends Annotation> annotationType = annotation.annotationType();

        if (Folder.class.equals(annotationType) || View.class.equals(annotationType))
        {
            return;
        }

        ViewMetaData viewMetaData = annotationType.getAnnotation(ViewMetaData.class);
        if (viewMetaData == null)
        {
            return;
        }

        Aggregated aggregated = viewMetaData.annotationType().getAnnotation(Aggregated.class);
        if (aggregated != null && aggregated.value())
        {
            throw new IllegalStateException("it isn't supported to change aggregated meta-data," 
                "because inheritance won't work correctly");
        }
    }

    protected void rewriteMetaDataOfNode(Collection<Annotation> metaData,
                                         Annotation oldMetaData, Annotation newMetaData)
    {
        Iterator<Annotation> metaDataIterator = metaData.iterator();

        while (metaDataIterator.hasNext())
        {
            Annotation currentMetaData = metaDataIterator.next();

            if (AnnotationUtils.getQualifierHashCode(currentMetaData) ==
                AnnotationUtils.getQualifierHashCode(oldMetaData))
            {
                metaDataIterator.remove();
                metaData.add(newMetaData);
                break;
            }
        }
    }
import org.apache.deltaspike.core.api.config.view.metadata.Aggregated;
import org.apache.deltaspike.jsf.api.config.view.Folder;
import org.apache.deltaspike.jsf.api.config.view.View;
import java.util.Collections;
                inheritedAnnotations.addAll(findViewMetaData(currentClass, viewConfigNode));
        inheritedAnnotations.addAll(findViewMetaData(viewConfigNode.getSource(), viewConfigNode));
    protected List<Annotation> findViewMetaData(Class currentClass, ViewConfigNode viewConfigNode)
        //don't include meta-data from the node itself, because it would be stored as inherited meta-data
        if (currentClass.equals(viewConfigNode.getSource()))
        {
            return Collections.emptyList();
        }


        result = tryToReplaceWithMergedMetaDataFromAncestor(currentClass, viewConfigNode.getParent(), result);
    //only supported for meta-data which isn't aggregated
    protected List<Annotation> tryToReplaceWithMergedMetaDataFromAncestor(
        Class currentClass, ViewConfigNode parentViewConfigNode, List<Annotation> foundResult)
    {
        ViewConfigNode ancestorNode = findNodeWithClass(currentClass, parentViewConfigNode);
        if (ancestorNode == null)
        {
            return foundResult;
        }

        List<Annotation> result = new ArrayList<Annotation>(foundResult.size());

        //only replace the meta-data found for the node and don't add all meta-data from the ancestor-node
        for (Annotation annotation : foundResult)
        {
            Annotation finalMetaData = getFinalMetaDataFromNode(ancestorNode, annotation);
            result.add(finalMetaData);
        }

        return result;
    }

    //the meta-data returned by this method is merged and potentially customized by a ConfigPreProcessor
    private Annotation getFinalMetaDataFromNode(ViewConfigNode viewConfigNode, Annotation annotation)
    {
        Class<? extends Annotation> targetType = annotation.annotationType();

        //skip @View and @Folder, because they get created dynamically to support their optional usage
        //the dynamic generation depends on the level and if it is a synthetic information
        if (View.class.equals(targetType) || Folder.class.equals(targetType))
        {
            return annotation;
        }

        //skip aggregated meta-data, because it can't be replaced
        //(there is no info available about the instance which replaced the original one
        // which might be equivalent to the annotation passed to this method)
        ViewMetaData viewMetaData = annotation.annotationType().getAnnotation(ViewMetaData.class);
        if (viewMetaData == null)
        {
            return annotation;
        }
        Aggregated aggregated = viewMetaData.annotationType().getAnnotation(Aggregated.class);
        if (aggregated == null || aggregated.value())
        {
            return annotation;
        }

        for (Annotation nodeMetaData : viewConfigNode.getMetaData())
        {
            if (targetType.equals(nodeMetaData.annotationType()))
            {
                return nodeMetaData;
            }
        }
        return annotation;
    }

    private ViewConfigNode findNodeWithClass(Class nodeClass, ViewConfigNode viewConfigNode)
    {
        if (viewConfigNode == null || nodeClass == null)
        {
            return null;
        }

        if (nodeClass.equals(viewConfigNode.getSource()))
        {
            return viewConfigNode;
        }
        return findNodeWithClass(nodeClass, viewConfigNode.getParent());
    }

import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
import org.apache.deltaspike.core.impl.util.AnnotationInstanceUtils;
    private Annotation priorityAnnotationInstance;

            if (isGlobalAlternativeActivated)
            {
                int priorityValue = CoreBaseConfig.Interceptor.PRIORITY.getValue();
                priorityAnnotationInstance = AnnotationInstanceUtils.getPriorityAnnotationInstance(priorityValue);
            }
            if (!doQualifiersMatch(qualifiersOfCurrentBean, qualifiersOfConfiguredBean))
            {
                continue;
            }

                //cdi 1.0
                if (priorityAnnotationInstance == null)
                //cdi 1.1
                else
                {
                    AnnotatedTypeBuilder<Object> annotatedTypeBuilder
                        = new AnnotatedTypeBuilder<Object>().readFromType(processAnnotatedType.getAnnotatedType());

                    annotatedTypeBuilder.addToClass(priorityAnnotationInstance);
                    processAnnotatedType.setAnnotatedType(annotatedTypeBuilder.create());
                    return;
                }
                //cdi 1.0 (no change needed with cdi 1.1)
                if (priorityAnnotationInstance == null)
import org.apache.deltaspike.core.impl.util.AnnotationInstanceUtils;
        int priorityValue = CoreBaseConfig.Interceptor.PRIORITY.getValue();
        priorityAnnotationInstance = AnnotationInstanceUtils.getPriorityAnnotationInstance(priorityValue);
        //delegate to JsfRequestLifecyclePhaseListener as a last step
        this.jsfRequestLifecyclePhaseListener.beforePhase(phaseEvent);

            if (StringUtils.isEmpty(windowId) && facesContext.isPostback())
            {
                windowId = getPostBackWindowId(facesContext);
            }
            
                if (this.jsfModuleConfig.isInitialRedirectEnabled() && !facesContext.isPostback())
        collectClasses(repoClass, result);
    private void collectClasses(Class<?> cls, Set<Class<?>> result)
    {
        if (cls == null || cls == Object.class)
        {
            return;
        }
        result.add(cls);
        for (Class<?> child : cls.getInterfaces())
        {
            collectClasses(child, result);
        }
        collectClasses(cls.getSuperclass(), result);
    }

     * Equals predicate, case insensitive.
     * @param att           The attribute to compare with.
     * @param value         The comparison value.
     * @return              Fluent API: Criteria instance.
     */
    <P> Criteria<C, R> eqIgnoreCase(SingularAttribute<? super C, String> att, String value);

    /**
     * Not Equals predicate, case insensitive.
     * @param att           The attribute to compare with.
     * @param value         The comparison value.
     * @return              Fluent API: Criteria instance.
     */
    <P> Criteria<C, R> notEqIgnoreCase(SingularAttribute<? super C, String> att, String value);

    /**
     * Like predicate, case insensitive.
     * @param att           The attribute to compare with.
     * @param value         The comparison value.
     * @return              Fluent API: Criteria instance.
     */
    <P> Criteria<C, R> likeIgnoreCase(SingularAttribute<? super C, String> att, String value);

    /**
     * Not like predicate, case insensitive.
     * @param att           The attribute to compare with.
     * @param value         The comparison value.
     * @return              Fluent API: Criteria instance.
     */
    <P> Criteria<C, R> notLikeIgnoreCase(SingularAttribute<? super C, String> att, String value);

    /**
import org.apache.deltaspike.data.impl.criteria.predicate.EqIgnoreCase;
import org.apache.deltaspike.data.impl.criteria.predicate.NotEqIgnoreCase;
    public <P> Criteria<C, R> eqIgnoreCase(SingularAttribute<? super C, String> att, String value)
    {
        add(new EqIgnoreCase<C>(att, value), value);
        return this;
    }

    @Override
    public <P> Criteria<C, R> notEqIgnoreCase(SingularAttribute<? super C, String> att, String value)
    {
        add(new NotEqIgnoreCase<C>(att, value), value);
        return this;
    }

    @Override
    public <P> Criteria<C, R> likeIgnoreCase(SingularAttribute<? super C, String> att, String value)
    {
        add(new Like<C>(att, value, true), value);
        return this;
    }

    @Override
    public <P> Criteria<C, R> notLikeIgnoreCase(SingularAttribute<? super C, String> att, String value)
    {
        add(new NotLike<C>(att, value, true), value);
        return this;
    }

    @Override
    private final boolean caseInsensitive;

        this(att, value, false);
    }

    public Like(SingularAttribute<? super E, String> att, String value, boolean caseInsensitive)
    {
        this.caseInsensitive = caseInsensitive;
        return Arrays.asList(builder.like(
                caseInsensitive ? builder.upper(path.<String>get(getAtt())) : path.get(getAtt()),
                caseInsensitive ? getValue().toUpperCase() : getValue()));
    private final boolean caseInsensitive;

        this(att, value, false);
    }

    public NotLike(SingularAttribute<? super E, String> att, String value, boolean caseInsensitive)
    {
        this.caseInsensitive = caseInsensitive;
        return Arrays.asList(builder.notLike(
                caseInsensitive ? builder.upper(path.<String>get(getAtt())) : path.get(getAtt()),
                caseInsensitive ? getValue().toUpperCase() : getValue()));
@SuppressWarnings("unchecked")
    public List<Simple> queryByIgnoreCase(String name, String nameLike)
    {
        return criteria()
                .or(
                    criteria()
                        .eqIgnoreCase(Simple_.name, name)
                        .notEqIgnoreCase(Simple_.name, nameLike),
                    criteria()
                        .likeIgnoreCase(Simple_.name, nameLike)
                        .notLikeIgnoreCase(Simple_.name, name)
                 )
                .getResultList();
    }

            if (errorViewDescriptor == null && errorView != null)
            {
                errorViewDescriptor = viewConfigResolver.getViewConfigDescriptor(errorView);
            }

            if (errorViewDescriptor != null)
            {
                return this.wrapped.createView(context, errorViewDescriptor.getViewId());
            }
            else
            {
                //only in case of GET requests, because an exception during POST requests leads to re-rendering
                //the previous page (including the error message)
                if (!context.isPostback() && context.getViewRoot() != null)
                {
                    context.getViewRoot().setViewId(null);
                }
            }
            throw accessDeniedException; //security exception without error-view
        if (errorView == null && allowNavigation)

            if (!isMessageAddedAlready(message))
            {
                FacesMessage facesMessage = new FacesMessage(FacesMessage.SEVERITY_ERROR, message, message);
                FacesContext.getCurrentInstance().addMessage(null, facesMessage);
            }

    private static boolean isMessageAddedAlready(String message)
    {
        FacesContext facesContext = FacesContext.getCurrentInstance();

        if (facesContext == null || message == null)
        {
            return false;
        }

        List<FacesMessage> existingMessages = facesContext.getMessageList();

        if (existingMessages == null)
        {
            return false;
        }

        for (FacesMessage facesMessage : existingMessages)
        {
            if (message.equals(facesMessage.getSummary()))
            {
                return true;
            }
        }
        return false;
    }
                    SecurityUtils.handleSecurityViolationWithoutNavigation(accessDeniedException);
    public static void handleSecurityViolationWithoutNavigation(RuntimeException exception)
        tryToHandleSecurityViolation(exception, false);
    private static void tryToHandleSecurityViolation(RuntimeException runtimeException,
                                                     boolean allowNavigation)
import java.lang.reflect.InvocationTargetException;
                    if (e instanceof InvocationTargetException)
                    {
                        ExceptionUtils.throwAsRuntimeException(e.getCause());
                    }
    boolean deleteJob(Class<? extends T> jobClass);

    public boolean deleteJob(Class<? extends Job> jobClass)
    {
        try
        {
            return this.scheduler.deleteJob(createJobKey(jobClass));
        }
        catch (SchedulerException e)
        {
            throw ExceptionUtils.throwAsRuntimeException(e);
        }
    }

    @Override
    public boolean deleteJob(Class<? extends CustomJob> jobClass) {
        return TestJobManager.getInstance().deleteJob(jobClass);
    }

public interface PropertyFileConfig

import org.apache.deltaspike.proxy.util.DeltaSpikeProxy;


import org.apache.deltaspike.proxy.util.DeltaSpikeProxyContextualLifecycle;
            @Observes ProcessAnnotatedType<X> pat, BeanManager beanManager)
        // veto normal converters/validators -> they will get excluded from the special handling later on
        // converters/validators without properties for tags, will be handled by the corresponding manual wrapper
                    "you they aren't allowed to be 'final'.");
        return scopeAnnotationClass != null && beanManager.isNormalScope(scopeAnnotationClass);
                    && currentMethod.getParameterTypes().length == 1 &&
                    hasGetterMethod(beanClass, currentMethod.getName().substring(3)))
                Converter.class.isAssignableFrom(beanClass) ?
                        ConverterInvocationHandler.class : ValidatorInvocationHandler.class;
                .readFromType(annotatedType)
                .passivationCapable(true)
                .beanLifecycle(lifecycle);


import org.apache.deltaspike.proxy.util.DeltaSpikeProxyFactory;


import org.apache.deltaspike.proxy.util.DeltaSpikeProxyContextualLifecycle;


import org.apache.deltaspike.proxy.util.DeltaSpikeProxyFactory;
 b/deltaspike/modules/proxy-utils/api/src/main/java/org/apache/deltaspike/proxy/invocation/AbstractManualInvocationHandler.java
package org.apache.deltaspike.proxy.invocation;
 b/deltaspike/modules/proxy-utils/api/src/main/java/org/apache/deltaspike/proxy/invocation/DelegateManualInvocationHandler.java
package org.apache.deltaspike.proxy.invocation;


import org.apache.deltaspike.proxy.util.DeltaSpikeProxy;
 b/deltaspike/modules/proxy-utils/api/src/main/java/org/apache/deltaspike/proxy/invocation/InterceptManualInvocationHandler.java
package org.apache.deltaspike.proxy.invocation;


import org.apache.deltaspike.proxy.util.DeltaSpikeProxyFactory;
 b/deltaspike/modules/proxy-utils/api/src/main/java/org/apache/deltaspike/proxy/invocation/ManualInvocationContext.java
package org.apache.deltaspike.proxy.invocation;
 b/deltaspike/modules/proxy-utils/api/src/main/java/org/apache/deltaspike/proxy/invocation/ManualInvocationThrowableWrapperException.java
package org.apache.deltaspike.proxy.invocation;
 b/deltaspike/modules/proxy-utils/api/src/main/java/org/apache/deltaspike/proxy/util/AsmProxyClassGenerator.java
package org.apache.deltaspike.proxy.util;
import org.apache.deltaspike.proxy.invocation.DelegateManualInvocationHandler;
import org.apache.deltaspike.proxy.invocation.InterceptManualInvocationHandler;



 b/deltaspike/modules/proxy-utils/api/src/main/java/org/apache/deltaspike/proxy/util/DeltaSpikeProxy.java
package org.apache.deltaspike.proxy.util;
 b/deltaspike/modules/proxy-utils/api/src/main/java/org/apache/deltaspike/proxy/util/DeltaSpikeProxyContextualLifecycle.java
package org.apache.deltaspike.proxy.util;
 b/deltaspike/modules/proxy-utils/api/src/main/java/org/apache/deltaspike/proxy/util/DeltaSpikeProxyFactory.java
package org.apache.deltaspike.proxy.util;
                , new String[]{ "org.apache.deltaspike.core",
                                "org.apache.deltaspike.proxy",
                                "org.apache.deltaspike.jsf" }
                "ds-core_proxy_jsf");
                        "org.apache.deltaspike.proxy",
                "ds-core_proxy_and_partial-bean");
/**
 * {@link DeltaSpikeProxyFactory} which delegates all abstract methods to the 
 * partial bean binding {@link java.lang.reflect.InvocationHandler}.
 */
        // check if interceptors are defined, otherwise just call the original logik
    /**
     * Calls the original logic after invoking the interceptor chain.
     * 
     * @param proxy The current proxy instance.
     * @param method The current invoked method.
     * @param parameters The method parameter.
     * @return The original value from the original method.
     * @throws Throwable 
     */
/**
 * {@link AbstractManualInvocationHandler} which delegates the method call to the defined {@link InvocationHandler}
 * in {@link DeltaSpikeProxy#getDelegateInvocationHandler()}.
 */
/**
 * {@link AbstractManualInvocationHandler} which just delegates to the original method after invoking interceptors.
 */
/**
 * {@link InvocationContext} implementation to support manual interceptor invocation before invoking the
 * original logic via the given {@link AbstractManualInvocationHandler}.
 */
/**
 * Wrapper exception to wrap and pass trough the original {@link Throwable} because
 * the {@link javax.interceptor.InvocationContext#proceed()} method only declares "throws Exception".
 */
/**
 * Interface which will automatically be implemented by the proxy instance.
 */
/**
 * {@link ContextualLifecycle} which handles a complete lifecycle of a proxy:
 * - creates a proxy via a {@link DeltaSpikeProxyFactory}
 * - handles the instantiation and injection of the proxy
 * - handles the instantiation via CDI of the delegate {@link InvocationHandler} and assign it to the proxy
 * - handles the release/destruction of both proxy and delegate {@link InvocationHandler}
 *
 * @param <T> The class of the original class.
 * @param <H> The class of the delegate {@link InvocationHandler}.
 */
        // check if a proxy is already defined for this class
            Class<? extends InvocationHandler> delegateInvocationHandlerClass,
        byte[] proxyBytes = generateProxyClassBytes(targetClass, delegateInvocationHandlerClass,
            Class<? extends InvocationHandler> delegateInvocationHandlerClass,
        Type delegateInvocationHandlerType = Type.getType(delegateInvocationHandlerClass);
        defineInvocationHandlerField(cw, delegateInvocationHandlerType);
        defineDelegateInvocationHandlerConstructor(cw, proxyType, superType, delegateInvocationHandlerType);
        defineDeltaSpikeProxyMethods(cw, proxyType, delegateInvocationHandlerType);
    private static void defineInvocationHandlerField(ClassWriter cw, Type delegateInvocationHandlerType)
                delegateInvocationHandlerType.getDescriptor(), null, null).visitEnd();
            Type delegateInvocationHandlerType)
                new Method("<init>", Type.VOID_TYPE, new Type[] { delegateInvocationHandlerType }),
        mg.putField(proxyType, FIELDNAME_DELEGATE_INVOCATION_HANDLER, delegateInvocationHandlerType);
    private static void defineDeltaSpikeProxyMethods(ClassWriter cw, Type proxyType, Type delegateInvocationHandlerType)
            mg.checkCast(delegateInvocationHandlerType);
            mg.putField(proxyType, FIELDNAME_DELEGATE_INVOCATION_HANDLER, delegateInvocationHandlerType);
            mg.getField(proxyType, FIELDNAME_DELEGATE_INVOCATION_HANDLER, delegateInvocationHandlerType);
    void setDelegateInvocationHandler(InvocationHandler delegateInvocationHandler);
            Class<? extends InvocationHandler> delegateInvocationHandlerClass)
            proxyClass = createProxyClass(targetClass.getClassLoader(), targetClass, delegateInvocationHandlerClass);
            Class<? extends InvocationHandler> delegateInvocationHandlerClass)
                // loop every method and check if a interceptor is defined on the method -> otherwise don't overwrite
                // interceptMethods
                    delegateInvocationHandlerClass,

    @Nonbinding
    boolean projectStageAware() default true;

    @Nonbinding
    String parameterizedBy() default NULL;
import org.apache.deltaspike.core.util.ExceptionUtils;

    private static <T> T fallbackToDefaultIfEmpty(String key, T value, T defaultValue)
        if (value == null || (value instanceof String && ((String)value).isEmpty()))
    public interface Converter<T>
    {

        T convert(String value);

    }

    public interface TypedResolver<T>
    {

        TypedResolver<T> parameterizedBy(String propertyName);

        TypedResolver<T> withCurrentProjectStage(boolean with);

        TypedResolver<T> strictly(boolean strictly);

        TypedResolver<T> withDefault(T value);

        TypedResolver<T> withStringDefault(String value);

        T getValue();

        String getKey();

        String getResolvedKey();

        T getDefaultValue();

    }

    public interface UntypedResolver<T> extends TypedResolver<T>
    {

        <N> TypedResolver<N> as(Class<N> clazz);

        <N> TypedResolver<N> as(Class<N> clazz, Converter<N> converter);

    }

    public static UntypedResolver<String> resolve(String name)
    {
        return new PropertyBuilder<String>(name);
    }

    private static class PropertyBuilder<T> implements UntypedResolver<T>
    {

        private String keyOriginal;

        private String keyResolved;

        private Class<?> configEntryType = String.class;

        private T defaultValue;

        private boolean projectStageAware = true;

        private String propertyParameter;

        private String parameterValue;

        private boolean strictly = false;

        private Converter<?> converter;


        private PropertyBuilder()
        {
        }

        protected PropertyBuilder(String propertyName)
        {
            this.keyOriginal = propertyName;
        }

        @Override
        @SuppressWarnings("unchecked")
        public <N> TypedResolver<N> as(Class<N> clazz)
        {
            configEntryType = clazz;
            return (TypedResolver<N>) this;
        }

        @Override
        @SuppressWarnings("unchecked")
        public <N> TypedResolver<N> as(Class<N> clazz, Converter<N> converter)
        {
            configEntryType = clazz;
            this.converter = converter;

            return (TypedResolver<N>) this;
        }

        @Override
        public TypedResolver<T> withDefault(T value)
        {
            defaultValue = value;
            return this;
        }

        @Override
        public TypedResolver<T> withStringDefault(String value)
        {
            if (value == null || value.isEmpty())
            {
                throw new RuntimeException("Empty String or null supplied as string-default value for property "
                         keyOriginal);
            }

            defaultValue = convert(value);
            return this;
        }

        @Override
        public TypedResolver<T> parameterizedBy(String propertyName)
        {
            this.propertyParameter = propertyName;

            if (propertyParameter != null && !propertyParameter.isEmpty())
            {
                String parameterValue = ConfigResolver
                        .resolve(propertyParameter)
                        .withCurrentProjectStage(projectStageAware)
                        .getValue();

                if (parameterValue != null && !parameterValue.isEmpty())
                {
                    this.parameterValue = parameterValue;
                }
            }

            return this;
        }

        @Override
        public TypedResolver<T> withCurrentProjectStage(boolean with)
        {
            this.projectStageAware = with;
            return this;
        }

        @Override
        public TypedResolver<T> strictly(boolean strictly)
        {
            this.strictly = strictly;
            return this;
        }

        @Override
        public T getValue()
        {
            String valueStr = resolveStringValue();
            T value = convert(valueStr);

            return fallbackToDefaultIfEmpty(keyResolved, value, defaultValue);
        }

        @Override
        public String getKey()
        {
            return keyOriginal;
        }

        @Override
        public String getResolvedKey()
        {
            return keyResolved;
        }

        @Override
        public T getDefaultValue()
        {
            return defaultValue;
        }

        /**
         * Performs the resolution cascade
         */
        private String resolveStringValue()
        {
            ProjectStage ps = null;
            String value = null;
            keyResolved = keyOriginal;
            int keySuffices = 0;

            // make the longest key
            // first, try appending resolved parameter
            if (propertyParameter != null && !propertyParameter.isEmpty())
            {
                if (parameterValue != null && !parameterValue.isEmpty())
                {
                    keyResolved = "."  parameterValue;
                    keySuffices;
                }
                // if parameter value can't be resolved and strictly
                else if (strictly)
                {
                    return null;
                }
            }

            // try appending projectstage
            if (projectStageAware)
            {
                ps = getProjectStage();
                keyResolved = "."  ps;
                keySuffices;
            }

            // make initial resolution of longest key
            value = getPropertyValue(keyResolved);

            // try fallbacks if not strictly
            if (value == null && !strictly)
            {

                // by the length of the longest resolved key already tried
                // breaks are left out intentionally
                switch (keySuffices)
                {

                    case 2:
                        // try base.param
                        keyResolved = keyOriginal  "."  parameterValue;
                        value = getPropertyValue(keyResolved);

                        if (value != null)
                        {
                            return value;
                        }

                        // try base.ps
                        ps = getProjectStage();
                        keyResolved = keyOriginal  "."  ps;
                        value = getPropertyValue(keyResolved);

                        if (value != null)
                        {
                            return value;
                        }

                    case 1:
                        // try base
                        keyResolved = keyOriginal;
                        value = getPropertyValue(keyResolved);
                        return value;

                    default:
                        // the longest key was the base, no fallback
                        return null;
                }
            }

            return value;
        }

        private T convert(String value)
        {

            if (value == null)
            {
                return null;
            }

            Object result = null;

            if (this.converter != null)
            {
                try
                {
                    result = converter.convert(value);
                }
                catch (Exception e)
                {
                    throw ExceptionUtils.throwAsRuntimeException(e);
                }
            }
            else if (String.class.equals(configEntryType))
            {
                result = value;
            }
            else if (Class.class.equals(configEntryType))
            {
                result = ClassUtils.tryToLoadClassForName(value);
            }
            else if (Boolean.class.equals(configEntryType))
            {
                Boolean isTrue = "TRUE".equalsIgnoreCase(value);
                isTrue |= "1".equalsIgnoreCase(value);
                isTrue |= "YES".equalsIgnoreCase(value);
                isTrue |= "Y".equalsIgnoreCase(value);
                isTrue |= "JA".equalsIgnoreCase(value);
                isTrue |= "J".equalsIgnoreCase(value);
                isTrue |= "OUI".equalsIgnoreCase(value);

                result = isTrue;
            }
            else if (Integer.class.equals(configEntryType))
            {
                result = Integer.parseInt(value);
            }
            else if (Long.class.equals(configEntryType))
            {
                result = Long.parseLong(value);
            }
            else if (Float.class.equals(configEntryType))
            {
                result = Float.parseFloat(value);
            }
            else if (Double.class.equals(configEntryType))
            {
                result = Double.parseDouble(value);
            }

            return (T) result;
        }

    }

import org.apache.deltaspike.core.api.config.ConfigResolver;

        Boolean DELEGATE_LOOKUP =
                ConfigResolver.resolve("deltaspike.bean-manager.delegate_lookup")
                        .as(Boolean.class)
                        .withCurrentProjectStage(true)
                        .withDefault(Boolean.TRUE)
                        .getValue();
        Integer PRIORITY =
                ConfigResolver.resolve("deltaspike.interceptor.priority")
                        .as(Integer.class)
                        .withCurrentProjectStage(true)
                        .withDefault(0)
                        .getValue();
        Boolean AUTO_UNREGISTER =
                ConfigResolver.resolve("deltaspike.mbean.auto-unregister")
                        .as(Boolean.class)
                        .withCurrentProjectStage(true)
                        .withDefault(Boolean.TRUE)
                        .getValue();
            String MAX_COUNT_KEY = "deltaspike.scope.window.max-count";

            Integer MAX_COUNT =
                    ConfigResolver.resolve(MAX_COUNT_KEY)
                            .as(Integer.class)
                            .withCurrentProjectStage(true)
                            .withDefault(1024)
                            .getValue();

        if (cdiClass != null && !CoreBaseConfig.BeanManagerDelegation.DELEGATE_LOOKUP)
        return getPropertyValue(injectionPoint, String.class);
    }
    protected <T> T getPropertyValue(InjectionPoint injectionPoint, Class<T> ipCls)
    {
        ConfigProperty configProperty = getAnnotation(injectionPoint, ConfigProperty.class);
        if (configProperty == null)
        {
            throw new IllegalStateException("producer method called without @ConfigProperty being present!");
        }

        ConfigResolver.TypedResolver<T> resolver = ConfigResolver.resolve(configProperty.name())
                .as(ipCls)
                .withCurrentProjectStage(configProperty.projectStageAware());

        String stringDefault = configProperty.defaultValue();
        if (!ConfigProperty.NULL.equals(stringDefault))
        {
            resolver.withStringDefault(stringDefault);
        }

        String parameterizedBy = configProperty.parameterizedBy();
        if (!ConfigProperty.NULL.equals(parameterizedBy))
        {
            resolver.parameterizedBy(parameterizedBy);
        }

        return resolver.getValue();
    public Class produceClassConfiguration(InjectionPoint injectionPoint)
        return getPropertyWithException(injectionPoint, Class.class);
        return getPropertyWithException(injectionPoint, Boolean.class);
    }
    @Produces
    @Dependent
    @ConfigProperty(name = "ignored") // we actually don't need the name
    public Integer produceIntegerConfiguration(InjectionPoint injectionPoint)
    {
        return getPropertyWithException(injectionPoint, Integer.class);
    }
    @Produces
    @Dependent
    @ConfigProperty(name = "ignored") // we actually don't need the name
    public Long produceLongConfiguration(InjectionPoint injectionPoint)
    {
        return getPropertyWithException(injectionPoint, Long.class);
        return getPropertyWithException(injectionPoint, Float.class);
    }
    @Produces
    @Dependent
    @ConfigProperty(name = "ignored") // we actually don't need the name
    public Double produceDoubleConfiguration(InjectionPoint injectionPoint)
    {
        return getPropertyWithException(injectionPoint, Double.class);

    }

    private <T> T getPropertyWithException(InjectionPoint ip, Class<T> ipCls)
    {
            return getPropertyValue(ip, ipCls);
        catch (RuntimeException rte)
            ConfigProperty configProperty = getAnnotation(ip, ConfigProperty.class);
            throw new RuntimeException("Error while converting property '"  configProperty.name() 
                    "' happening in bean "  ip.getBean(), rte);
                int priorityValue = CoreBaseConfig.Interceptor.PRIORITY;
        int priorityValue = CoreBaseConfig.Interceptor.PRIORITY;
        if (server.isRegistered(objectName) && CoreBaseConfig.MBean.AUTO_UNREGISTER)
        this.maxWindowContextCount = CoreBaseConfig.Scope.WindowRestriction.MAX_COUNT;
    @ConfigProperty(name = "configproperty.test.string")
    private String stringConfig;
    @Inject
    @ConfigProperty(name = "INVALIDKEY", defaultValue = "DEFAULT")
    private String stringConfigWithDefault;

    @Inject
    @ConfigProperty(name = "configproperty.test.string", projectStageAware = false)
    private String stringConfigWithoutProjectStage;

    @Inject
    @ConfigProperty(name = "configproperty.test.string", projectStageAware = true,
            parameterizedBy = "configproperty.test.param")
    private String stringConfigParameterized;

    @Inject
    @ConfigProperty(name = "configproperty.test.boolean")
    private Boolean booleanConfig;

    @Inject
    @ConfigProperty(name = "configproperty.test.class")
    private Class classConfig;

    @Inject
    @ConfigProperty(name = "configproperty.test.int")
    private Integer intConfig;

    @Inject
    @ConfigProperty(name = "configproperty.test.long")
    private Long longConfig;

    @Inject
    @ConfigProperty(name = "configproperty.test.float")
    private Float floatConfig;

    @Inject
    @ConfigProperty(name = "configproperty.test.double")
    private Double doubleConfig;

    public String getStringConfig()
        return stringConfig;

    public String getStringConfigWithDefault()
    {
        return stringConfigWithDefault;
    }

    public String getStringConfigWithoutProjectStage()
    {
        return stringConfigWithoutProjectStage;
    }

    public String getStringConfigParameterized()
    {
        return stringConfigParameterized;
    }

    public boolean getBooleanConfig()
    {
        return booleanConfig;
    }

    public Class getClassConfig()
    {
        return classConfig;
    }

    public int getIntConfig()
    {
        return intConfig;
    }

    public long getLongConfig()
    {
        return longConfig;
    }

    public float getFloatConfig()
    {
        return floatConfig;
    }

    public double getDoubleConfig()
    {
        return doubleConfig;
    }
import org.apache.deltaspike.core.api.config.ConfigResolver;
        String CUSTOM_DEFAULT_BASE_PATH_BUILDER = ConfigResolver.resolve(View.DefaultBasePathBuilder.class.getName())
                .withCurrentProjectStage(true)
                .getValue();
        String CUSTOM_DEFAULT_FILE_NAME_BUILDER = ConfigResolver.resolve(View.DefaultFileNameBuilder.class.getName())
                .withCurrentProjectStage(true)
                .getValue();
        String CUSTOM_DEFAULT_EXTENSION_BUILDER = ConfigResolver.resolve(View.DefaultExtensionBuilder.class.getName())
                .withCurrentProjectStage(true)
                .getValue();
        String CUSTOM_DEFAULT_FOLDER_NAME_BUILDER = ConfigResolver
                .resolve(Folder.DefaultFolderNameBuilder.class.getName())
                .withCurrentProjectStage(true)
                .getValue();
            int ID_MAX_LENGTH_DEFAULT = 10;

            Integer MAX_COUNT = ConfigResolver.resolve(CoreBaseConfig.Scope.WindowRestriction.MAX_COUNT_KEY)
                    .as(Integer.class)
                    .withCurrentProjectStage(true)
                    .withDefault(64)
                    .getValue();
            Integer ID_MAX_LENGTH = ConfigResolver.resolve("deltaspike.window-id.max_length")
                    .as(Integer.class)
                    .withCurrentProjectStage(true)
                    .withDefault(ID_MAX_LENGTH_DEFAULT)
                    .getValue();
            Boolean DELEGATE_TO_JSF = ConfigResolver.resolve("deltaspike.scope.view.delegate")
                    .as(Boolean.class)
                    .withCurrentProjectStage(true)
                    .withDefault(Boolean.TRUE)
                    .getValue();
                    JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER;
                    JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_BASE_PATH_BUILDER;
                    JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FILE_NAME_BUILDER;
                    JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_EXTENSION_BUILDER;
            JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER;
            JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_BASE_PATH_BUILDER;
            JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FILE_NAME_BUILDER;
            JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_EXTENSION_BUILDER;
        this.maxWindowContextCount = JsfBaseConfig.Scope.WindowRestriction.MAX_COUNT;
        int result = JsfBaseConfig.Scope.WindowRestriction.ID_MAX_LENGTH;
        if (result > JsfBaseConfig.Scope.WindowRestriction.ID_MAX_LENGTH_DEFAULT)
            JsfBaseConfig.Scope.ViewDelegation.DELEGATE_TO_JSF;
        String defaultJobFactoryName = SchedulerBaseConfig.JobCustomization.DEFAULT_JOB_FACTORY_CLASS_NAME;
            if (SchedulerBaseConfig.Lifecycle.START_SCOPES_PER_JOB)
                this.scheduler.startDelayed(SchedulerBaseConfig.Lifecycle.DELAYED_START_IN_SECONDS);
        String configFile = SchedulerBaseConfig.SCHEDULER_CONFIG_FILE;
                this.scheduler.shutdown(SchedulerBaseConfig.Lifecycle.FORCE_STOP);
import org.apache.deltaspike.core.api.config.ConfigResolver;
        String JOB_CLASS_NAME_KEY = "deltaspike.scheduler.job-class";
        String DEFAULT_JOB_FACTORY_CLASS_NAME = ConfigResolver.resolve("deltaspike.scheduler.DefaultJobFactory")
                .withCurrentProjectStage(true)
                .withDefault("org.quartz.simpl.PropertySettingJobFactory")
                .getValue();

        //don't type it to class to keep quartz optional
        String JOB_CLASS_NAME = ConfigResolver.resolve(JOB_CLASS_NAME_KEY)
                .withCurrentProjectStage(true)
                .withDefault("org.quartz.Job")
                .getValue();
    String SCHEDULER_CONFIG_FILE = ConfigResolver.resolve("deltaspike.scheduler.quartz_config-file")
            .withCurrentProjectStage(true)
            .withDefault("quartz")
            .getValue();
        String START_SCOPES_PER_JOB_KEY = "deltaspike.scheduler.start_scopes_for_jobs";
        Boolean START_SCOPES_PER_JOB = ConfigResolver.resolve(START_SCOPES_PER_JOB_KEY)
                .as(Boolean.class)
                .withCurrentProjectStage(true)
                .withDefault(Boolean.TRUE)
                .getValue();
        Boolean FORCE_STOP = ConfigResolver.resolve("deltaspike.scheduler.force_stop")
                .as(Boolean.class)
                .withCurrentProjectStage(true)
                .withDefault(Boolean.TRUE)
                .getValue();

        Integer DELAYED_START_IN_SECONDS = ConfigResolver.resolve("deltaspike.scheduler.delayed_start_in_seconds")
                .as(Integer.class)
                .withCurrentProjectStage(true)
                .withDefault(1)
                .getValue();
            String jobClassName = SchedulerBaseConfig.JobCustomization.JOB_CLASS_NAME;
        put(SchedulerBaseConfig.JobCustomization.JOB_CLASS_NAME_KEY, CustomJob.class.getName());
            put(SchedulerBaseConfig.JobCustomization.JOB_CLASS_NAME_KEY, CustomJob.class.getName());
            put(SchedulerBaseConfig.Lifecycle.START_SCOPES_PER_JOB_KEY, Boolean.FALSE.toString());
                    return MyFacesTestBaseConfig.WEBAPP_RESOURCE_PATH;
        if (!TestBaseConfig.MockIntegration.ALLOW_MOCKED_BEANS &&
            !TestBaseConfig.MockIntegration.ALLOW_MOCKED_PRODUCERS)
                "Please set '"  TestBaseConfig.MockIntegration.ALLOW_MOCKED_BEANS_KEY  "' and/or '" 
                TestBaseConfig.MockIntegration.ALLOW_MOCKED_PRODUCERS_KEY  "' to 'true' " 
            return TestBaseConfig.MockIntegration.ALLOW_MOCKED_PRODUCERS;
            return TestBaseConfig.MockIntegration.ALLOW_MOCKED_BEANS;
 * Marker interface for all classes used for dynamic configuration of DeltaSpike itself. The term <i>Dynamic
 * configuration</i> refers to values which can be determined and changed during runtime and shouldn't be accessed
 * during container boot time.
 * All DeltaSpike dynamic configuration objects implement this interface so they can be found more easily. There is no
 * other functionality implied with this interface.</p>
 * DeltaSpike uses a <i>type-safe configuration</i> approach for most internal configuration. Instead of writing a
 * properties file or XML, you just implement one of the configuration interfaces which will then be picked up as a
 * CDI bean. If* there is already a default configuration for some functionality in DeltaSpike, you can use &#064;
 * Specializes or &#064;Alternative to change those.</p>
 *
 * <p>
 * See {@link org.apache.deltaspike.core.api.config.base.DeltaSpikeBaseConfig} for static DeltaSpike configuration
 * based on properties.</p>
 *
public interface CoreBaseConfig extends DeltaSpikeBaseConfig
import org.apache.deltaspike.core.api.config.base.DeltaSpikeBaseConfig;
public interface JsfBaseConfig extends DeltaSpikeBaseConfig
import org.apache.deltaspike.core.api.config.base.DeltaSpikeBaseConfig;
public interface SchedulerBaseConfig extends DeltaSpikeBaseConfig
    /**
     * A very simple interface for conversion of configuration values from String to any Java type.
     * @param <T> The target type of the configuration entry
     */
        /**
         * Returns the converted value of the configuration entry.
         * @param value The String property value to convert
         * @return Converted value
         */
    /**
     * A builder-based typed resolution mechanism for configuration values.
     * @param <T> The target type of the configuration entry.
     */
        /**
         * Appends the resolved value of the given property to the key of this builder. This is described in more detail
         * in {@link ConfigResolver#getPropertyAwarePropertyValue(String, String)}.
         * @param propertyName The name of the parameter property
         * @return This builder
         */
        /**
         * Indicates whether to append the name of the current project stage to the key of this builder. This
         * is described in more detail in {@link ConfigResolver#getProjectStageAwarePropertyValue(String)}. True by
         * default.
         * @param with
         * @return This builder
         */
        /**
         * Indicates whether the fallback resolution sequence should be performed, as described in
         * {@link ConfigResolver#getPropertyAwarePropertyValue(String, String)}. This applies only when
         * {@link #parameterizedBy(String)} or {@link #withCurrentProjectStage(boolean)} is used.
         * @param strictly
         * @return This builder
         */
        /**
         * Sets the default value to use in case the resolution returns null.
         * @param value the default value
         * @return This builder
         */
        /**
         * Sets the default value to use in case the resolution returns null. Converts the given String to the type of
         * this resolver using the same method as used for the configuration entries.
         * @param value string value to be converted and used as default
         * @return This builder
         */
        /**
         * Returns the converted resolved filtered value.
         * @return the resolved value
         */
        /**
         * Returns the key given in {@link #resolve(String)}.
         * @return the original key
         */
        /**
         * Returns the actual key which led to successful resolution and corresponds to the resolved value. This applies
         * only when {@link #parameterizedBy(String)} or {@link #withCurrentProjectStage(boolean)} is used and
         * {@link #strictly(boolean)} is not used, otherwise the resolved key should always be equal to the original
         * key. This method is provided for cases, when projectStage-aware and/or parameterized resolution is
         * requested but the value for such appended key is not found and some of the fallback keys is used, as
         * described in {@link ConfigResolver#getPropertyAwarePropertyValue(String, String)}.
         * This should be called only after calling {@link #getValue()} otherwise the value is undefined (but likely
         * null).
         * @return
         */
        /**
         * Returns the default value provided by {@link #withDefault(Object)} or {@link #withStringDefault(String)}.
         * Returns null if no default was provided.
         * @return the default value or null
         */
    /**
     * A builder-based optionally typed resolution mechanism for configuration values.
     * @param <T> This type variable should always be String for UntypedResolver.
     */
        /**
         * Sets the type of the configuration entry to the given class and returns this builder as a TypedResolver.
         * Only one of the supported types should be used which includes: Boolean, Class, Integer, Long, Float, Double.
         * For custom types, see {@link #as(Class, Converter)}.
         * @param clazz The target type
         * @param <N> The target type
         * @return This builder as a TypedResolver
         */
        /**
         * Sets the type of the configuration entry to the given class, sets the converter to the one given and
         * returns this builder as a TypedResolver. If a converter is provided for one of the types supported by
         * default (see {@link #as(Class)} then the provided converter is used instead of the built-in one.
         * @param clazz The target type
         * @param converter The converter for the target type
         * @param <N> The target type
         * @return This builder as a TypedResolver
         */
    /**
     * The entry point to the builder-based optionally typed configuration resolution mechanism.
     *
     * String is the default type for configuration entries and is not considered a 'type' by this resolver. Therefore
     * an UntypedResolver is returned by this method. To convert the configuration value to another type, call
     * {@link UntypedResolver#as(Class)}.
     *
     * @param name The property key to resolve
     * @return A builder for configuration resolution.
     */
        /**
         * If a converter was provided for this builder, it takes precedence over the built-in converters.
         */
 * <p>DeltaSpikes own configuration system natively supports only Strings.
 * If you'd like to apply own Converters or extract other types from those Strings,
 *         return df.parse(configuredValue).floatValue();
import org.apache.deltaspike.proxy.spi.DeltaSpikeProxy;
import org.apache.deltaspike.proxy.api.DeltaSpikeProxyContextualLifecycle;
import org.apache.deltaspike.proxy.api.DeltaSpikeProxyFactory;

import org.apache.deltaspike.proxy.api.DeltaSpikeProxyContextualLifecycle;
import org.apache.deltaspike.proxy.api.DeltaSpikeProxyFactory;

 b/deltaspike/modules/proxy/api/src/main/java/org/apache/deltaspike/proxy/api/DeltaSpikeProxyContextualLifecycle.java
package org.apache.deltaspike.proxy.api;
    public DeltaSpikeProxyContextualLifecycle(Class<T> targetClass,
                                              Class<H> delegateInvocationHandlerClass,
                                              DeltaSpikeProxyFactory proxyFactory,
                                              BeanManager beanManager)
 b/deltaspike/modules/proxy/api/src/main/java/org/apache/deltaspike/proxy/api/DeltaSpikeProxyFactory.java
package org.apache.deltaspike.proxy.api;
import org.apache.deltaspike.core.util.ServiceUtils;
import org.apache.deltaspike.proxy.spi.ProxyClassGenerator;

            List<ProxyClassGenerator> proxyClassGeneratorList =
                ServiceUtils.loadServiceImplementations(ProxyClassGenerator.class);

            if (proxyClassGeneratorList.size() != 1)
            {
                throw new IllegalStateException(proxyClassGeneratorList.size()
                     " implementations of "  ProxyClassGenerator.class.getName()
                     " found. It's just allowed to use one implementation.");
            }

            proxyClass = proxyClassGeneratorList.iterator().next().generateProxyClass(classLoader,
 b/deltaspike/modules/proxy/api/src/main/java/org/apache/deltaspike/proxy/spi/DeltaSpikeProxy.java
package org.apache.deltaspike.proxy.spi;
 b/deltaspike/modules/proxy/impl-asm5/src/main/java/org/apache/deltaspike/proxy/impl/AsmProxyClassGenerator.java
package org.apache.deltaspike.proxy.impl;
import org.apache.deltaspike.proxy.spi.DeltaSpikeProxy;
import org.apache.deltaspike.proxy.impl.invocation.DelegateManualInvocationHandler;
import org.apache.deltaspike.proxy.impl.invocation.InterceptManualInvocationHandler;
import org.apache.deltaspike.proxy.spi.ProxyClassGenerator;
public class AsmProxyClassGenerator implements ProxyClassGenerator
    public <T> Class<T> generateProxyClass(ClassLoader classLoader,
 b/deltaspike/modules/proxy/impl-asm5/src/main/java/org/apache/deltaspike/proxy/impl/invocation/AbstractManualInvocationHandler.java
package org.apache.deltaspike.proxy.impl.invocation;
 b/deltaspike/modules/proxy/impl-asm5/src/main/java/org/apache/deltaspike/proxy/impl/invocation/DelegateManualInvocationHandler.java
package org.apache.deltaspike.proxy.impl.invocation;

import org.apache.deltaspike.proxy.spi.DeltaSpikeProxy;
 b/deltaspike/modules/proxy/impl-asm5/src/main/java/org/apache/deltaspike/proxy/impl/invocation/InterceptManualInvocationHandler.java
package org.apache.deltaspike.proxy.impl.invocation;

import org.apache.deltaspike.proxy.api.DeltaSpikeProxyFactory;
 b/deltaspike/modules/proxy/impl-asm5/src/main/java/org/apache/deltaspike/proxy/impl/invocation/ManualInvocationContext.java
package org.apache.deltaspike.proxy.impl.invocation;
 b/deltaspike/modules/proxy/impl-asm5/src/main/java/org/apache/deltaspike/proxy/impl/invocation/ManualInvocationThrowableWrapperException.java
package org.apache.deltaspike.proxy.impl.invocation;
import javax.servlet.http.HttpServletRequest;
            boolean post = isPost(facesContext);
            
            if (StringUtils.isEmpty(windowId) && post)
                if (this.jsfModuleConfig.isInitialRedirectEnabled() && !post)
            boolean post = isPost(facesContext);
            
            if (post)
    private boolean isPost(FacesContext context)
    {
        if (context.isPostback())
        {
            return true;
        }
        
        Object request = context.getExternalContext().getRequest();
        if (request instanceof HttpServletRequest)
        {
            if ("POST".equals(((HttpServletRequest) request).getMethod()))
            {
                return true;
            }
        }

        return false;
    }
    
import org.apache.deltaspike.core.spi.activation.ClassDeactivator;
                LOGGER.log(Level.WARNING, "Container issue detected -> can't validate view-configs. " 
                    "This exception is usually the effect (but not the reason) of a failed startup. " 
                    "You can deactivate "  getClass().getName()  " via a custom " 
                    ClassDeactivator.class.getName()  " to verify it.", e);
    interface BeanManagerIntegration
    interface InterceptorCustomization
    interface MBeanIntegration
    interface ScopeCustomization
        if (cdiClass != null && !CoreBaseConfig.BeanManagerIntegration.DELEGATE_LOOKUP)
                int priorityValue = CoreBaseConfig.InterceptorCustomization.PRIORITY;
        int priorityValue = CoreBaseConfig.InterceptorCustomization.PRIORITY;
        if (server.isRegistered(objectName) && CoreBaseConfig.MBeanIntegration.AUTO_UNREGISTER)
        this.maxWindowContextCount = CoreBaseConfig.ScopeCustomization.WindowRestriction.MAX_COUNT;
    interface ViewConfigCustomization
    interface ScopeCustomization
            Integer MAX_COUNT =
                ConfigResolver.resolve(CoreBaseConfig.ScopeCustomization.WindowRestriction.MAX_COUNT_KEY)
                    JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER;
                    JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_BASE_PATH_BUILDER;
                    JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_FILE_NAME_BUILDER;
                    JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_EXTENSION_BUILDER;
            JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER;
            JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_BASE_PATH_BUILDER;
            JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_FILE_NAME_BUILDER;
            JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_EXTENSION_BUILDER;
        this.maxWindowContextCount = JsfBaseConfig.ScopeCustomization.WindowRestriction.MAX_COUNT;
        int result = JsfBaseConfig.ScopeCustomization.WindowRestriction.ID_MAX_LENGTH;
        if (result > JsfBaseConfig.ScopeCustomization.WindowRestriction.ID_MAX_LENGTH_DEFAULT)
            JsfBaseConfig.ScopeCustomization.ViewDelegation.DELEGATE_TO_JSF;
            if (SchedulerBaseConfig.LifecycleIntegration.START_SCOPES_PER_JOB)
                this.scheduler.startDelayed(SchedulerBaseConfig.LifecycleIntegration.DELAYED_START_IN_SECONDS);
                this.scheduler.shutdown(SchedulerBaseConfig.LifecycleIntegration.FORCE_STOP);
    interface LifecycleIntegration
            put(SchedulerBaseConfig.LifecycleIntegration.START_SCOPES_PER_JOB_KEY, Boolean.FALSE.toString());
public class AuthenticationListener
{ 
    public void handleLoggedIn(@Observes UserEvent.LoggedIn event) 
    {
}
    private LoginController loginController;
    public void create()
    {
{
    public void create() 
import org.apache.deltaspike.data.test.domain.SimpleStringId;
    @Query(named = SimpleStringId.FIND_ALL_ORDER_BY_ID)
    public abstract QueryResult<SimpleStringId> findAllOrderByIdPaginate(@FirstResult int start, @MaxResults int pageSize);

    public static final String QUERY_DELETE = "delete from {0} e";
    public static String deleteQuery(String entityName)
    {
        return MessageFormat.format(QUERY_DELETE, entityName);
    }

        if (methodPrefix.isDelete())
        {
            ctx.append(QueryBuilder.deleteQuery(entityName));
        }
        else
        {
            ctx.append(QueryBuilder.selectQuery(entityName));
        }
import org.apache.deltaspike.data.impl.meta.MethodPrefix;
    private final MethodPrefix methodPrefix;
        this.methodPrefix = new MethodPrefix("", method.getName());
    }

    private QueryProcessorFactory(Method method, MethodPrefix methodPrefix)
    {
        this.method = method;
        this.methodPrefix = methodPrefix;
    public static QueryProcessorFactory newInstance(Method method, MethodPrefix methodPrefix)
    {
        return new QueryProcessorFactory(method, methodPrefix);
    }

        return (method.isAnnotationPresent(Modifying.class) && matchesType) || methodPrefix.isDelete();
    public static final String DEFAULT_DELETE_PREFIX = "deleteBy";
    public boolean isDelete()
    {
        return this.getPrefix().equalsIgnoreCase(DEFAULT_DELETE_PREFIX);
    }

        },
        DELETE_DEFAULT(DEFAULT_DELETE_PREFIX)
        {
            @Override
            public SingleResultType getStyle()
            {
                return SingleResultType.ANY;
            }
        this.queryProcessor = QueryProcessorFactory.newInstance(method, methodPrefix).build();
    public abstract void deleteByName(String name);

    public abstract void deleteByNameAndEnabled(String name, boolean enable);

import org.apache.deltaspike.core.api.provider.DependentProvider;
        private DependentProvider<ContextControl> contextControl;
                this.contextControl = BeanProvider.getDependent(ContextControl.class);
                    contextControl.get().startContext(scopeAnnotation);
                this.contextControl.get().stopContext(this.scopes.pop());
            this.contextControl.destroy();
            ProxyClassGenerator proxyClassGenerator = ProxyClassGeneratorLookup.lookupService();
            proxyClass = proxyClassGenerator.generateProxyClass(classLoader,
    private final OrderBy orderByProcessor = new OrderBy();
        addOrderBy(att, OrderDirection.ASC);
        addOrderBy(att, OrderDirection.DESC);
        orderByProcessor.process(query, builder, from);
    private void addOrderBy(SingularAttribute<? super C, ?> att, OrderDirection orderDirection)
    {
        orderByProcessor.add(att, orderDirection);
    }

import javax.persistence.criteria.Order;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

    private final List<OrderByDefinition> orderByDefinitions = new ArrayList<OrderByDefinition>();
    public void add(SingularAttribute<? super P, V> att, OrderDirection dir)
        orderByDefinitions.add(new OrderByDefinition(att, dir));
        List<Order> orders = new ArrayList<Order>();
        Iterator<OrderByDefinition> iterator = orderByDefinitions.iterator();
        while (iterator.hasNext())
            OrderByDefinition orderByDefinition = iterator.next();
            switch (orderByDefinition.getDir())
            {
                case ASC:
                    orders.add(builder.asc(path.get(orderByDefinition.getAtt())));
                    break;
                default:
                    orders.add(builder.desc(path.get(orderByDefinition.getAtt())));
            }
        query.orderBy(orders);
    private class OrderByDefinition
    {
        private final SingularAttribute<? super P, V> att;
        private final OrderDirection dir;

        public OrderByDefinition(SingularAttribute<? super P, V> att, OrderDirection dir)
        {
            this.att = att;
            this.dir = dir;
        }

        public SingularAttribute<? super P, V> getAtt()
        {
            return att;
        }

        public OrderDirection getDir()
        {
            return dir;
        }

        @Override
        public boolean equals(Object o)
        {
            if (this == o)
            {
                return true;
            }
            if (o == null || getClass() != o.getClass())
            {
                return false;
            }

            OrderByDefinition that = (OrderByDefinition) o;

            if (att != null ? !att.equals(that.att) : that.att != null)
            {
                return false;
            }
            return dir == that.dir;

        }

        @Override
        public int hashCode()
        {
            int result = att != null ? att.hashCode() : 0;
            result = 31 * result  (dir != null ? dir.hashCode() : 0);
            return result;
        }
    }
   public List<Simple> findOrderByNameAndCounter() {
      return criteria()
              .orderDesc(Simple_.counter)
              .orderAsc(Simple_.name)
              .getResultList();
   }

    @Nonbinding boolean readOnly() default false;
import org.apache.deltaspike.core.api.provider.DependentProvider;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
    @Inject
    private BeanManager beanManager;
    private transient TransactionConfig transactionConfig;
        //manual lookup needed because injecting UserTransactionResolver can fail (see the comment there)
            DependentProvider<UserTransactionResolver> provider =
                BeanProvider.getDependent(this.beanManager, UserTransactionResolver.class);

            UserTransaction userTransaction = provider.get().resolveUserTransaction();

            provider.destroy();
            return userTransaction;


import org.apache.deltaspike.core.util.ServiceUtils;
    private static ProxyClassGenerator generator;

    /**
     * Looks up a unique service implementation.
     *
     * @return ProxyClassGenerator service
     */
    private static ProxyClassGenerator lookupService()
    {
        if (generator == null)
        {
            List<ProxyClassGenerator> proxyClassGeneratorList = ServiceUtils
                .loadServiceImplementations(ProxyClassGenerator.class);

            if (proxyClassGeneratorList.size() != 1)
            {
                throw new IllegalStateException(proxyClassGeneratorList.size()
                     " implementations of "  ProxyClassGenerator.class.getName()
                     " found. Expected exactly one implementation.");
            }
            generator = proxyClassGeneratorList.get(0);
        }
        return generator;
    }

    /**
     * Setter invoked by OSGi Service Component Runtime
     *
     * @param generator
     *            generator service
     */
    public void setGenerator(ProxyClassGenerator generator)
    {
        DeltaSpikeProxyFactory.generator = generator;
    }

            ProxyClassGenerator proxyClassGenerator = lookupService();
    public static class GeneratorHolder
    {
        private static ProxyClassGenerator generator;

        /**
         * Setter invoked by OSGi Service Component Runtime.
         *
         * @param generator
         *            generator service
         */
        public void setGenerator(ProxyClassGenerator generator)
        {
            GeneratorHolder.generator = generator;
        }
    }

        if (GeneratorHolder.generator == null)
            GeneratorHolder.generator = proxyClassGeneratorList.get(0);
        return GeneratorHolder.generator;
     * Convenience access to {@link javax.persistence.EntityManager#remove(Object)}
     * with an detached entity.
     * @param entity            Entity to remove.
     */
    void attachAndRemove(E entity);

    /**
 * @param <E>  Entity type.
 * @param <PK> Primary key type, must be a serializable.
    public void attachAndRemove(E entity)
    {
        if (!entityManager().contains(entity))
        {
            entity = entityManager().merge(entity);
        }
        remove(entity);
    }

    @Override
    @RequiresTransaction
                               boolean useLikeOperator)
                .addCriteria(new NamedPropertyCriteria(names.toArray(new String[]{}))).getResultList();
                                        SingularAttribute<E, ?>... attributes)
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.JoinType;
import javax.persistence.metamodel.SingularAttribute;
 * @param <E> Entity type.
     *
     * @return Criteria instance related to the Repository entity class.
     *
     * @param <T>   Type related to the current criteria class.
     * @param clazz Class other than the current entity class.
     * @return Criteria instance related to a join type of the current entity class.
     *
     * @param <T>      Type related to the current criteria class.
     * @param clazz    Class other than the current entity class.
     * @param joinType Join type to apply.
     * @return Criteria instance related to a join type of the current entity class.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     * Create a query selection for the
     * {@link javax.persistence.criteria.CriteriaBuilder#trim(javax.persistence.criteria.Expression)}
     * over a String attribute.
     *
     * @param attribute Attribute to apply trim.
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     */
    QuerySelection<E, String> trim(SingularAttribute<? super E, String> attribute);

    /**
     * Create a query selection for the
     * {@link javax.persistence.criteria.CriteriaBuilder#trim(javax.persistence.criteria.CriteriaBuilder.Trimspec,
     * javax.persistence.criteria.Expression)}
     * over a String attribute.
     *
     * @param trimspec  Used to specify how strings are trimmed.
     * @param attribute Attribute to apply trim.
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     */
    QuerySelection<E, String> trim(CriteriaBuilder.Trimspec trimspec, SingularAttribute<? super E, String> attribute);


    /**
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
     *
     * @return {@link QuerySelection} part of a {@link Criteria#select(Class, QuerySelection...)} call.
import javax.persistence.criteria.CriteriaBuilder;
import org.apache.deltaspike.data.impl.criteria.selection.strings.Trim;
    @Override
    public QuerySelection<E, String> trim(SingularAttribute<? super E, String> attribute)
    {
        return new Trim<E>(attribute);
    }

    @Override
    public QuerySelection<E, String> trim(CriteriaBuilder.Trimspec trimspec,
                                          SingularAttribute<? super E, String> attribute)
    {
        return new Trim<E>(trimspec, attribute);
    }

import javax.persistence.criteria.CriteriaBuilder;

                        criteria()
                                .eqIgnoreCase(Simple_.name, name)
                                .notEqIgnoreCase(Simple_.name, nameLike),
                        criteria()
                                .likeIgnoreCase(Simple_.name, nameLike)
                                .notLikeIgnoreCase(Simple_.name, name)
                )
    public List<Simple> findByTimeBetween(Date from, Date to)
    {
                .gt(Simple_.temporal, from)
                .lt(Simple_.temporal, to)
                .getResultList();
    public Simple findBySuperName(String superName)
    {
                .eq(SuperSimple_.superName, superName)
                .getSingleResult();
    public List<Simple> findOrderByNameAndCounter()
    {
        return criteria()
                .orderDesc(Simple_.counter)
                .orderAsc(Simple_.name)
                .getResultList();
    }

    public Object[] queryWithSelectAttributesAndTrim(String name)
    {
        return criteria()
                .select(attribute(Simple_.name), trim(Simple_.name),
                        trim(CriteriaBuilder.Trimspec.LEADING, Simple_.name))
                .eq(Simple_.name, name)
                .createQuery()
                .getSingleResult();
    }
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
            JsfUtils.addStaticNavigationParameter(
                this.navigationParameterContext, currentParameter.key(), currentParameter.value());
        JsfUtils.addStaticNavigationParameter(
            this.navigationParameterContext, viewParameter.key(), viewParameter.value());

    public static void addStaticNavigationParameter(
        NavigationParameterContext navigationParameterContext, String key, String value)
    {
        Map<String, String> existingParameters = navigationParameterContext.getPageParameters();

        String existingValue = existingParameters.get(key);

        if (existingValue != null && value != null) //support null for special cases to reset an entry
        {
            return;
        }
        navigationParameterContext.addPageParameter(key, value);
    }

import org.apache.deltaspike.data.impl.meta.RepositoryComponents;
    private RepositoryComponents components = new RepositoryComponents();


                components.add(repoClass);
    
    public RepositoryComponents getComponents()
    {
        return components;
    }
import javax.inject.Inject;

import org.apache.deltaspike.core.api.lifecycle.Initialized;
import org.apache.deltaspike.data.impl.RepositoryExtension;
 * Repository components producer.
    @Inject
    private RepositoryExtension extension;
    
        return extension.getComponents();
    /**
     * Get the entity table name this Repository is related to.
     * @return          Repository entity table name.
     */
    protected abstract String tableName();

import java.util.Stack;
import org.apache.deltaspike.core.util.StringUtils;
import org.apache.deltaspike.data.api.EntityRepository;
import org.apache.deltaspike.data.impl.builder.QueryBuilder;
import org.apache.deltaspike.data.impl.meta.RequiresTransaction;
import org.apache.deltaspike.data.impl.meta.unit.PersistenceUnits;
import org.apache.deltaspike.data.impl.property.Property;
import org.apache.deltaspike.data.impl.property.query.NamedPropertyCriteria;
import org.apache.deltaspike.data.impl.property.query.PropertyQueries;
import org.apache.deltaspike.data.spi.DelegateQueryHandler;
import org.apache.deltaspike.data.spi.QueryInvocationContext;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.Table;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.metamodel.EntityType;
import javax.persistence.metamodel.SingularAttribute;
import static org.apache.deltaspike.data.impl.util.EntityUtils.entityName;
import static org.apache.deltaspike.data.impl.util.QueryUtils.isEmpty;
import static org.apache.deltaspike.data.impl.util.QueryUtils.isString;
    public String tableName()
    {
        final Class<?> entityClass = context.getEntityClass();
        final String tableName = PersistenceUnits.instance().entityTableName(entityClass);
        if (StringUtils.isEmpty(tableName))
        {
            final EntityType<?> entityType = entityManager().getMetamodel().entity(entityClass);
            Table tableAnnotation = entityClass.getAnnotation(Table.class);
            return (tableAnnotation == null)
                    ? entityType.getName()
                    : tableAnnotation.name();
        }
        return tableName;
    }

import static org.apache.deltaspike.data.impl.util.QueryUtils.isEmpty;

    protected final String tableName;

    EntityDescriptor(String name, String packageName, String className, String idClass, String id, String tableName)
        this.tableName = tableName;
    public String getTableName()
    {
        return tableName;
    }

                .append(", tableName=").append(tableName)
            return new MappingFile(Collections.<EntityDescriptor>emptyList(),
                    Collections.<MappedSuperclassDescriptor>emptyList());
            protected EntityDescriptor instance(String name, String packageName, String className,
                                      String idClass, String id, String tableName)
                return new EntityDescriptor(name, packageName, className, idClass, id, tableName);
            protected String tagName()
        List<MappedSuperclassDescriptor> superClasses = new MappedSuperClassBuilder<MappedSuperclassDescriptor>()
            protected MappedSuperclassDescriptor instance(String name, String packageName, String className,
                                                String idClass, String id)
            protected String tagName()

    private abstract class PersistenceBuilder<T extends PersistentClassDescriptor>
        protected List<T> result;
        protected String packageName;
        protected String name;
        protected String className;
        protected String idClass;
        protected String id;
        protected String embeddedId;
            this.result = new LinkedList<T>();
            this.packageName = extractNodeContent(doc.getDocumentElement(), "package");
                this.name = extractAttribute(mappings.item(i), "name");
                this.className = extractAttribute(mappings.item(i), "class");
                this.idClass = extractNodeAttribute((Element) mappings.item(i), "id-class", "class");
                this.id = extractNodeAttribute((Element) mappings.item(i), "id", "name");
                this.embeddedId = extractNodeAttribute((Element) mappings.item(i), "embedded-id", "name");
                addFields((Element) mappings.item(i));
                addInResult();
            return this.result;
        protected abstract String tagName();
        protected abstract void addInResult();
        protected abstract void addFields(Element element);
    }

    private abstract class MappedSuperClassBuilder<T extends PersistentClassDescriptor> extends PersistenceBuilder
    {
        protected abstract T instance(String name, String packageName, String className, String idClass, String id);

        protected abstract String tagName();

        @Override
        protected void addInResult()
        {
            result.add(instance(name, packageName, className, idClass, id != null ? id : embeddedId));
        }

        @Override
        protected void addFields(Element element)
        {
            // do nothing;
        }
    }

    private abstract class EntityBuilder<T extends PersistentClassDescriptor> extends PersistenceBuilder
    {

        protected String tableName;

        protected abstract T instance(String name, String packageName, String className, String idClass, String id,
                            String tableName);

        protected abstract String tagName();

        @Override
        protected void addInResult()
        {
            result.add(instance(name, packageName, className, idClass, id != null ? id : embeddedId, tableName));
        }

        @Override
        protected void addFields(Element element)
        {
            this.tableName = extractNodeAttribute(element, "table", "name");
        }
    public String entityTableName(Class<?> entityClass)
    {
        EntityDescriptor entity = find(entityClass);
        if (entity != null)
        {
            return entity.getTableName();
        }
        return null;
    }
    /**
     * Get the entity name this Repository is related to.
     * @return          Repository entity name.
     */
    protected abstract String entityName();

import org.apache.deltaspike.data.impl.util.EntityUtils;
    public String entityName()
    {
        return EntityUtils.entityName(entityClass());
    }

        return QueryBuilder.selectQuery(entityName());
        return QueryBuilder.countQuery(entityName());

    public String getEntityName()
    {
        return entityName();
    }

    public String getEntityName()
    {
        return entityName();
    }
            int numArchives = 0;
                String suffix = (numArchives == 0) ? "" : Integer.toString(numArchives);
                    = createArchive(foundFile, markerFile, includeIfPackageExists, excludeIfPackageExists, 
                        archiveName  suffix);
                    numArchives;
        return Collections.emptyList();
    public SimpleStringId()
    {

    }

import java.lang.reflect.Method;
     *
     * @param entity Entity object, non nullable.
     * @return true if the entity is not persisted, false otherwise and if no entity.
import javax.persistence.EntityManager;
import java.lang.reflect.Method;

import static org.apache.deltaspike.data.impl.util.QueryUtils.isNotEmpty;

        return context.applyRestrictions(result);
        return context.applyRestrictions(result);

import javax.persistence.Query;
import java.lang.reflect.Method;
import java.text.MessageFormat;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.Query;
import javax.persistence.QueryHint;
import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.List;

                                     EntityManager entityManager)
        this.args = args == null ? new Object[]{} : args;
    public Query applyRestrictions(Query query)
    {
        Parameters params = getParams();
        Method method = getMethod();
        if (params.hasSizeRestriction())
        {
            query.setMaxResults(params.getSizeRestriciton());
        }
        if (params.hasFirstResult())
        {
            query.setFirstResult(params.getFirstResult());
        }
        if (hasLockMode(method))
        {
            query.setLockMode(extractLockMode(method));
        }
        if (hasQueryHints(method))
        {
            QueryHint[] hints = extractQueryHints(method);
            for (QueryHint hint : hints)
            {
                query.setHint(hint.name(), hint.value());
            }
        }
        query = applyJpaQueryPostProcessors(query);
        return query;
    }

    private boolean hasLockMode(Method method)
    {
        return extractLockMode(method) != null;
    }

    private LockModeType extractLockMode(Method method)
    {
        Class<org.apache.deltaspike.data.api.Query> query = org.apache.deltaspike.data.api.Query.class;
        if (method.isAnnotationPresent(query) &&
                method.getAnnotation(query).lock() != LockModeType.NONE)
        {
            return method.getAnnotation(query).lock();
        }
        return null;
    }

    private QueryHint[] extractQueryHints(Method method)
    {
        Class<org.apache.deltaspike.data.api.Query> query = org.apache.deltaspike.data.api.Query.class;
        if (method.isAnnotationPresent(query) &&
                method.getAnnotation(query).hints().length > 0)
        {
            return method.getAnnotation(query).hints();
        }
        return null;
    }

    private boolean hasQueryHints(Method method)
    {
        return extractQueryHints(method) != null;
    }

    private CdiQueryInvocationContext context;
        return context.applyRestrictions(entityManager().createQuery(allQuery(), entityClass())).getResultList();
        return context.applyRestrictions(query).getResultList();
        return (Long) context.applyRestrictions(entityManager().createQuery(countQuery(), Long.class))
                .getSingleResult();
        context.applyRestrictions(query);
        context.applyRestrictions(query);

    /**
     * Return the id of the entity. Returns null if the entity does not yet have an id.
     * @param example           Sample entity.
     * @return                  id of the entity
     */
    PK getPrimaryKey(E example);
import org.apache.deltaspike.data.impl.util.jpa.PersistenceUnitUtilDelegateFactory;
import javax.persistence.PersistenceUnitUtil;
    public PK getPrimaryKey(E entity)
    {
        return (PK) persistenceUnitUtil().getIdentifier(entity);
    }

    @Override

    private PersistenceUnitUtil persistenceUnitUtil()
    {
        return PersistenceUnitUtilDelegateFactory.get(entityManager());
    }
import org.apache.deltaspike.data.impl.util.jpa.PersistenceUnitUtilDelegateFactory;
            return PersistenceUnitUtilDelegateFactory.get(entityManager).getIdentifier(entity) == null;
import org.apache.deltaspike.data.impl.util.EntityUtils;

    private final EntityManager entityManager;
        this.entityManager = entityManager;
        try
            if (!entityManager.contains(entity))
                entity = entityManager.getReference(entity.getClass(), EntityUtils.primaryKeyValue(entity));
            }

            final Object identifier = persistenceUnitUtil.getIdentifier(entity);
            if (identifier != null)
            {
                final Method method;

        }
        catch (NoSuchMethodException e)
        {
            throw new RuntimeException(e);
        }
        catch (InvocationTargetException e)
        {
            throw new RuntimeException(e);
        }
        catch (IllegalAccessException e)
        {
            throw new RuntimeException(e);
        }
        catch (IllegalStateException e)
        {
            return null;
import org.apache.deltaspike.jsf.impl.scope.window.strategy.ClientSideWindowStrategy;
import org.apache.deltaspike.jsf.impl.scope.window.strategy.DelegatedWindowStrategy;
import org.apache.deltaspike.jsf.impl.scope.window.strategy.LazyWindowStrategy;
import org.apache.deltaspike.jsf.impl.scope.window.strategy.NoneWindowStrategy;
    private ClientSideWindowStrategy clientSideWindowStrategy;
    private DelegatedWindowStrategy delegatedWindowStrategy;
    @Inject
    private LazyWindowStrategy lazyWindowStrategy;
    @Inject
    private NoneWindowStrategy noneWindowStrategy;
        return getClientWindow(facesContext).getWindowId(facesContext);
        getClientWindow(facesContext).disableClientWindowRenderMode(facesContext);
        getClientWindow(facesContext).enableClientWindowRenderMode(facesContext);
        return getClientWindow(facesContext).isClientWindowRenderModeEnabled(facesContext);
        return getClientWindow(facesContext).getQueryURLParameters(facesContext);
    }

    protected ClientWindow getClientWindow(FacesContext facesContext)
    {
        switch (clientWindowRenderMode)
            case CLIENTWINDOW:
                return clientSideWindowStrategy;
            case CUSTOM:
                return null;
            case DELEGATED:
                return delegatedWindowStrategy;
            case LAZY:
                return lazyWindowStrategy;
            case NONE:
                return noneWindowStrategy;
            default:
                return null;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.jsf.impl.util;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.enterprise.inject.Typed;
import javax.faces.FacesException;
import javax.faces.context.ExternalContext;
import javax.faces.context.FacesContext;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletResponse;

import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;

@Typed()
public abstract class ClientWindowHelper
{
    private static final Logger LOG = Logger.getLogger(ClientWindowHelper.class.getName());

    private static final String INITIAL_REDIRECT_WINDOW_ID = ClientWindowHelper.class.getName()
             ".INITIAL_REDIRECT_WINDOW_ID";

    public abstract class RequestParameters
    {
        public static final String POST_WINDOW_ID = "dspwid";
        public static final String JSF_POST_WINDOW_ID = "javax.faces.ClientWindow";
        public static final String GET_WINDOW_ID = "dswid";
        public static final String REQUEST_TOKEN = "dsrid";
    }

    public abstract class Cookies
    {
        public static final String REQUEST_WINDOW_ID_PREFIX = "dsrwid-";
        public static final String WINDOW_ID_PREFIX = "dsWindowId-";
    }


    /**
     * Handles the initial redirect for the LAZY mode, if no windowId is available in the current request URL.
     *
     * @param facesContext the {@link FacesContext}
     * @param newWindowId the new windowId
     */
    public static void handleInitialRedirect(FacesContext facesContext, String newWindowId)
    {        
        // store the new windowId as context attribute to prevent infinite loops
        // #sendRedirect will append the windowId (from ClientWindow#getWindowId again) to the redirectUrl
        facesContext.getAttributes().put(INITIAL_REDIRECT_WINDOW_ID, newWindowId);

        ExternalContext externalContext = facesContext.getExternalContext();

        String url = externalContext.getRequestContextPath()
                 externalContext.getRequestServletPath();

        if (externalContext.getRequestPathInfo() != null)
        {
            url = externalContext.getRequestPathInfo();
        }

        url = JsfUtils.addRequestParameters(externalContext, url, true);
        //TODO check if it isn't better to fix addRequestParameters itself
        //only #encodeResourceURL is portable currently
        url = facesContext.getExternalContext().encodeResourceURL(url);

        // see #729
        addRequestWindowIdCookie(facesContext, newWindowId);

        try
        {
            externalContext.redirect(url);
        }
        catch (IOException e)
        {
            throw new FacesException("Could not send initial redirect!", e);
        }
    }

    public static boolean isInitialRedirect(FacesContext facesContext)
    {
        return facesContext.getAttributes().containsKey(INITIAL_REDIRECT_WINDOW_ID);
    }

    public static String getInitialRedirectWindowId(FacesContext facesContext)
    {
        return (String) facesContext.getAttributes().get(INITIAL_REDIRECT_WINDOW_ID);
    }

    /**
     * Appends the current windowId to the given url, if enabled via
     * {@link ClientWindow#isClientWindowRenderModeEnabled(javax.faces.context.FacesContext)}
     *
     * @param facesContext the {@link FacesContext}
     * @param url the url
     * @param clientWindow the {@link ClientWindow} to use
     * @return if enabled, the url with windowId, otherwise the umodified url
     */
    public static String appendWindowId(FacesContext facesContext, String url, ClientWindow clientWindow)
    {
        if (clientWindow != null && clientWindow.isClientWindowRenderModeEnabled(facesContext))
        {
            Map<String, String> parameters = clientWindow.getQueryURLParameters(facesContext);

            if (parameters != null && !parameters.isEmpty())
            {
                String targetUrl = url;

                for (Entry<String, String> entry : parameters.entrySet())
                {
                    targetUrl = JsfUtils.addParameter(facesContext.getExternalContext(),
                            targetUrl,
                            true,
                            entry.getKey(),
                            entry.getValue());

                    //remove empty parameter (e.g. dswid)
                    String emptyParameter = entry.getKey()  "=&";
                    if (targetUrl.contains(emptyParameter))
                    {
                        targetUrl = targetUrl.replace(emptyParameter, "");
                    }
                }
                return targetUrl;
            }
        }

        return url;
    }

    public static void addRequestWindowIdCookie(FacesContext context, String windowId)
    {
        Map<String, Object> properties = new HashMap();
        properties.put("path", "/");
        properties.put("maxAge", 30);

        context.getExternalContext().addResponseCookie(
                Cookies.REQUEST_WINDOW_ID_PREFIX  windowId, windowId, properties);
    }

    public static Object getRequestWindowIdCookie(FacesContext context, String windowId)
    {
        Map<String, Object> cookieMap = context.getExternalContext().getRequestCookieMap();

        if (cookieMap.containsKey(Cookies.REQUEST_WINDOW_ID_PREFIX  windowId))
        {
            return cookieMap.get(Cookies.REQUEST_WINDOW_ID_PREFIX  windowId);
        }

        return null;
    }

    public static void removeRequestWindowIdCookie(FacesContext context, Cookie cookie)
    {
        cookie.setMaxAge(0);
        ((HttpServletResponse) context.getExternalContext().getResponse()).addCookie(cookie);
    }

    public static int getMaxWindowIdLength()
    {
        int result = JsfBaseConfig.ScopeCustomization.WindowRestriction.ID_MAX_LENGTH;

        if (result > JsfBaseConfig.ScopeCustomization.WindowRestriction.ID_MAX_LENGTH_DEFAULT)
        {
            if (LOG.isLoggable(Level.WARNING))
            {
                LOG.warning("ATTENTION: if you change this value to be significant longer than 10, " 
                    "you can introduce a security issue in WindowIdHtmlRenderer. " 
                    "If you increase it because window.name contains a value already, " 
                    "please revisit that usage or " 
                    "create shorter unique ids since they just need to be unique within the user-session.");
            }
        }
        return result;
    }
}
import javax.servlet.http.HttpServletResponse;
            
            // expire/remove cookie
            servletCookie.setMaxAge(0);
            ((HttpServletResponse) context.getExternalContext().getResponse()).addCookie(servletCookie);
        if (windowId != null)
            if (windowId.length() > this.maxWindowIdCount)
            {
                windowId = windowId.substring(0, this.maxWindowIdCount);
            }
    protected String getWindowIdPostParameter(FacesContext facesContext)

    protected String getWindowIdParameter(FacesContext facesContext)
    {
        Map<String, String> requestParameters = facesContext.getExternalContext().getRequestParameterMap();
        return requestParameters.get(ClientWindowHelper.RequestParameters.GET_WINDOW_ID);
    }
    
            windowId = getWindowIdPostParameter(facesContext);
        String cookieName =
                ClientWindowHelper.Cookies.REQUEST_WINDOW_ID_PREFIX  getRequestTokenParameter(externalContext);
    protected String getRequestTokenParameter(ExternalContext externalContext)
            windowId = getWindowIdParameter(facesContext);
            windowId = getWindowIdPostParameter(facesContext);
        // rember the initial redirect windowId till the next request - see #729
        addRequestWindowIdCookie(facesContext, newWindowId, newWindowId);
    public static void addRequestWindowIdCookie(FacesContext context, String requestToken, String windowId)
                Cookies.REQUEST_WINDOW_ID_PREFIX  requestToken, windowId, properties);
    public static Object getRequestWindowIdCookie(FacesContext context, String requestToken)
        if (cookieMap.containsKey(Cookies.REQUEST_WINDOW_ID_PREFIX  requestToken))
            return cookieMap.get(Cookies.REQUEST_WINDOW_ID_PREFIX  requestToken);
    
    /**
     * @return true if the implementation possible sends an initial redirect.
     */
    boolean isInitialRedirectSupported(FacesContext facesContext);
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
    private volatile ClientWindow clientWindow;
        lazyInit();
        
        String windowId = clientWindow.getWindowId(context);
        String clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(context).name();
        writer.write("window.deltaspikeClientWindowRenderMode='"  clientWindowRenderMode  "';");
        if (clientWindow.isInitialRedirectSupported(context))
            Object cookie = ClientWindowHelper.getRequestWindowIdCookie(context, windowId);
            if (cookie != null && cookie instanceof Cookie)
            {
                Cookie servletCookie = (Cookie) cookie;
                writer.write("window.deltaspikeInitialRedirectWindowId='"  servletCookie.getValue()  "';");

                // expire/remove cookie
                servletCookie.setMaxAge(0);
                ((HttpServletResponse) context.getExternalContext().getResponse()).addCookie(servletCookie);
            }
    private void lazyInit()
        if (clientWindow == null)
                if (clientWindow == null)
                    clientWindowConfig = BeanProvider.getContextualReference(ClientWindowConfig.class);
                    clientWindow = BeanProvider.getContextualReference(ClientWindow.class);
    
    @Override
    public boolean isInitialRedirectSupported(FacesContext facesContext)
    {
        return getClientWindow(facesContext).isInitialRedirectSupported(facesContext);
    }
    public boolean isInitialRedirectSupported(FacesContext facesContext)
    {
        return false;
    }
    
    @Override
    
    @Override
    protected boolean isSupportClientWindowRenderingMode()
    {
        return true;
    }

    @Override
    public boolean isInitialRedirectSupported(FacesContext facesContext)
    {
        return true;
    }
    
    @Override
    public boolean isClientWindowRenderModeEnabled(FacesContext facesContext)
    {
        return facesContext.getExternalContext().getClientWindow().isClientWindowRenderModeEnabled(facesContext);
    }
    private volatile Boolean initialized;
    private boolean delegatedWindowHandlingEnabled;
    private boolean jsf22Available;
        lazyInit();
    public boolean isJsf22Available()
        lazyInit();
        
        return this.jsf22Available;
    }
    
    public boolean isDelegatedWindowHandlingEnabled()
    {
        lazyInit();
        
        return this.delegatedWindowHandlingEnabled;
    }
    
    private void lazyInit()
    {
        if (this.initialized == null)
            init();
    }
    protected synchronized void init()
    {
        if (this.initialized == null)
            this.jsf22Available = ClassUtils.tryToLoadClassForName(CLIENT_WINDOW_CLASS_NAME) != null;
            if (!this.jsf22Available)
            {
                this.delegatedWindowHandlingEnabled = false;
            }
            else
            {
                FacesContext facesContext = FacesContext.getCurrentInstance();

                // can happen in case of a very simple test-setup without a mocked jsf container
                if (facesContext == null)
                {
                    this.delegatedWindowHandlingEnabled = false;
                }
                else
                {
                    
                    String initParam = facesContext.getExternalContext().getInitParameter(CLIENT_WINDOW_CONFIG_KEY);
                    this.delegatedWindowHandlingEnabled =
                            !(initParam == null || "none".equalsIgnoreCase(initParam.trim()));
                }
            }
            
            this.initialized = true;
        }
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
import org.apache.deltaspike.jsf.impl.scope.window.ClientWindowAdapter;
    private volatile Boolean initialized;

    private ClientWindow clientWindow;
    private JsfModuleConfig jsfModuleConfig;
        lazyInit();
        
        boolean clientWindowRenderModeEnabled = clientWindow.isClientWindowRenderModeEnabled(context);
        
        if (jsfModuleConfig.isJsf22Available())
        {
            Boolean jsfClientWindowRenderModeEnabled =
                    ClientWindowAdapter.isJsf22ClientWindowRenderModeEnabled(context);
            if (jsfClientWindowRenderModeEnabled != null)
            {
                clientWindowRenderModeEnabled = clientWindowRenderModeEnabled || jsfClientWindowRenderModeEnabled;
            }
        }
        
                clientWindow.disableClientWindowRenderMode(context);
                clientWindow.enableClientWindowRenderMode(context);
    private void lazyInit()
        if (this.initialized == null)
            init();
    }
    protected synchronized void init()
    {
        if (this.initialized == null)
        {
            clientWindow = BeanProvider.getContextualReference(ClientWindow.class);
            jsfModuleConfig = BeanProvider.getContextualReference(JsfModuleConfig.class);
        }
                facesContext.getExternalContext().setClientWindow(
                        new ClientWindowAdapter(clientWindow, delegateWindowHandling));
    private final boolean delegateWindowHandling;
    public ClientWindowAdapter(org.apache.deltaspike.jsf.spi.scope.window.ClientWindow window,
            boolean delegateWindowHandling)
        this.delegateWindowHandling = delegateWindowHandling;
    public static Boolean isJsf22ClientWindowRenderModeEnabled(FacesContext context)
        ClientWindow clientWindow = context.getExternalContext().getClientWindow();
            if (clientWindow instanceof ClientWindowAdapter)
            {
                ClientWindowAdapter clientWindowAdapter = (ClientWindowAdapter) clientWindow;
                return clientWindowAdapter.isOriginalClientWindowRenderModeEnabled(context);
            }
            else
            {
                return clientWindow.isClientWindowRenderModeEnabled(context);
            }
        
    
    
    @Override
    public boolean isClientWindowRenderModeEnabled(FacesContext context)
    {
        if (!delegateWindowHandling)
        {
            return false;
        }
        
        return super.isClientWindowRenderModeEnabled(context);
    }
    
    protected boolean isOriginalClientWindowRenderModeEnabled(FacesContext context)
    {
        return super.isClientWindowRenderModeEnabled(context);
    }
import org.apache.deltaspike.jsf.impl.scope.window.ClientWindowAdapter;

        if (jsfModuleConfig.isJsf22Available())
        {
            if (facesContext.getExternalContext().getClientWindow() != null)
            {
                facesContext.getExternalContext().getClientWindow().disableClientWindowRenderMode(facesContext);
            }
        }
        
        if (jsfModuleConfig.isJsf22Available())
        {
            if (facesContext.getExternalContext().getClientWindow() != null)
            {
                facesContext.getExternalContext().getClientWindow().enableClientWindowRenderMode(facesContext);
            }
        }
        // skip dswid rendering if JSF2.2 render mode is disabled
        if (jsfModuleConfig.isJsf22Available())
        {
            if (ClientWindowAdapter.isJsf22ClientWindowRenderModeEnabled(facesContext) == false)
            {
                return false;
            }
        }

        if (facesContext.getExternalContext().getClientWindow() != null)
        {
            return facesContext.getExternalContext().getClientWindow().getId();
        }
        
        return null;
        boolean dsClientWindowRenderModeEnabled = clientWindow.isClientWindowRenderModeEnabled(context);
        boolean jsfClientWindowRenderModeEnabled = false;
            if (context.getExternalContext().getClientWindow() != null)
                jsfClientWindowRenderModeEnabled =
                        context.getExternalContext().getClientWindow().isClientWindowRenderModeEnabled(context);
            if (dsClientWindowRenderModeEnabled)
            if (jsfClientWindowRenderModeEnabled)
            {
                context.getExternalContext().getClientWindow().disableClientWindowRenderMode(context);
            }
            if (dsClientWindowRenderModeEnabled)
            if (jsfClientWindowRenderModeEnabled)
            {
                context.getExternalContext().getClientWindow().enableClientWindowRenderMode(context);
            }
import javax.faces.FacesException;
    @Override
        lazyInit();
                facesContext.getExternalContext().setClientWindow(new ClientWindowAdapter(clientWindow));
    @Override
    public void render(FacesContext context) throws FacesException
    {
        lazyInit();

        // prevent jfwid rendering
        if (!delegateWindowHandling && context.getExternalContext().getClientWindow() != null)
        {
            context.getExternalContext().getClientWindow().disableClientWindowRenderMode(context);
        }
        
        super.render(context);
    }
    
        if (this.initialized == null)
            this.delegateWindowHandling = ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(
            this.initialized = true;
    public ClientWindowAdapter(org.apache.deltaspike.jsf.spi.scope.window.ClientWindow window)
    private ClientWindowConfig clientWindowConfig;
        boolean delegateWindowHandling = ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(
                clientWindowConfig.getClientWindowRenderMode(facesContext));
        
        if (delegateWindowHandling)
    public void render(FacesContext facesContext) throws FacesException
        boolean delegateWindowHandling = ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(
                clientWindowConfig.getClientWindowRenderMode(facesContext));
        if (!delegateWindowHandling && facesContext.getExternalContext().getClientWindow() != null)
            facesContext.getExternalContext().getClientWindow().disableClientWindowRenderMode(facesContext);
        super.render(facesContext);
            this.clientWindowConfig = BeanProvider.getContextualReference(ClientWindowConfig.class);
import org.apache.deltaspike.data.impl.util.EntityUtils;
            if (EntityUtils.primaryKeyValue(entity) == null)
            {
                return true;
            }

            if (!entityManager.contains(entity) && countCheck(entity))
            {
                return true;
            }
            return false;
    private boolean countCheck(Object entity)
    {
        StringBuilder sql = new StringBuilder("SELECT COUNT(e) FROM "  getEntityClass()
                .getSimpleName()  " e ");
        sql.append("WHERE e.");
        sql.append(EntityUtils.primaryKey(getEntityClass()).getName());
        sql.append(" = "  EntityUtils.primaryKeyValue(entity));

        final Query query = entityManager.createQuery(sql.toString());
        final Long result = (Long) query.getSingleResult();
        if (Long.valueOf(0).equals(result))
        {
            return true;
        }
        return false;
    }

    public static Property<Serializable> primaryKey(Class<?> entityClass)

    
    @CustomInterceptorStereotype
    public void doSomething2()
    {
        String a = "test2";
    }
        this.proxyClass = proxyFactory.getProxyClass(beanManager, targetClass, delegateInvocationHandlerClass);
import javax.enterprise.inject.spi.BeanManager;
    public <T> Class<T> getProxyClass(BeanManager beanManager, Class<T> targetClass,
            proxyClass = createProxyClass(beanManager, targetClass.getClassLoader(), targetClass,
                    delegateInvocationHandlerClass);
    private synchronized <T> Class<T> createProxyClass(BeanManager beanManager, ClassLoader classLoader,
            Class<T> targetClass, Class<? extends InvocationHandler> delegateInvocationHandlerClass)
                    && !containsInterceptorBinding(beanManager, targetClass.getDeclaredAnnotations()))
                    if (!containsInterceptorBinding(beanManager, method.getDeclaredAnnotations()))

    protected boolean containsInterceptorBinding(BeanManager beanManager, Annotation[] annotations)
        {            
            Class<? extends Annotation> annotationType = annotation.annotationType();
            
            if (annotationType.isAnnotationPresent(InterceptorBinding.class))

            if (beanManager.isStereotype(annotationType))
            {                
                boolean containsInterceptorBinding = containsInterceptorBinding(
                        beanManager,
                        annotationType.getDeclaredAnnotations());
                
                if (containsInterceptorBinding)
                {
                    return true;
                }
            }
        BeanManager beanManager = BeanManagerProvider.getInstance().getBeanManager();
        
        Annotation[] interceptorBindings = extractInterceptorBindings(beanManager, instance, method);
    protected Annotation[] extractInterceptorBindings(BeanManager beanManager, Object instance, Method method)
        addInterceptorBindings(beanManager, bindings, instance.getClass().getDeclaredAnnotations());
        addInterceptorBindings(beanManager, bindings, method.getDeclaredAnnotations());
    
    protected void addInterceptorBindings(BeanManager beanManager, ArrayList<Annotation> bindings,
            Annotation[] declaredAnnotations)
    {
        for (Annotation annotation : declaredAnnotations)
        {
            if (bindings.contains(annotation))
            {
                continue;
            }
            
            Class<? extends Annotation> annotationType = annotation.annotationType();
            
            if (annotationType.isAnnotationPresent(InterceptorBinding.class))
            {
                bindings.add(annotation);
            }
            
            if (beanManager.isStereotype(annotationType))
            {
                for (Annotation subAnnotation : annotationType.getDeclaredAnnotations())
                {                    
                    if (bindings.contains(subAnnotation))
                    {
                        continue;
                    }

                    if (subAnnotation.annotationType().isAnnotationPresent(InterceptorBinding.class))
                    {
                        bindings.add(subAnnotation);
                    }  
                }
            }
        }
    }
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;

public class RequestResponseHolderListener implements ServletRequestListener, Deactivatable
    private final boolean activated;

    public RequestResponseHolderListener()
    {
        this.activated = ClassDeactivationUtils.isActivated(this.getClass());
    }

        if (activated)
        {
            RequestResponseHolder.REQUEST.bind(sre.getServletRequest());
        }
        if (activated)
        {
            RequestResponseHolder.REQUEST.release();
        }
            /*
             * For some reason Tomcat seems to call requestInitialized() more than
             * once for a request. Not sure if this allowed according to the spec.
             */
            if (!RequestResponseHolder.REQUEST.isBound())
            {
                RequestResponseHolder.REQUEST.bind(sre.getServletRequest());
            }
        writer.write("dswh.init('"  windowId  "','"  clientWindowRenderMode  "'");
                writer.write(",{'initialRedirectWindowId':'"  servletCookie.getValue()  "'}");
        writer.write(");");

        writer.write("(function(){");

        writer.write("})();");
    
    /**
     * @return whether localStorage is used in the browser to store the HTML content between client redirects.
     *          Currently it's only used by {@link ClientWindowRenderMode#CLIENTWINDOW}.
     * @see windowhandler.html
     */
    boolean isClientWindowStoreWindowTreeEnabled(); 
    
    @Override
    public boolean isClientWindowStoreWindowTreeEnabled()
    {
        return true;
    }
        writer.write("dswh.init('"  windowId  "','"  clientWindowRenderMode  "',{");
        writer.write("'storeWindowTree':'"  clientWindowConfig.isClientWindowStoreWindowTreeEnabled()  "'");
        
                writer.write(",'initialRedirectWindowId':'"  servletCookie.getValue()  "'");
        writer.write("});");



    @Override
    public boolean isClientWindowRenderModeEnabled(FacesContext context)
    {
        return false;
    }

     *




        ClientWindowConfig.ClientWindowRenderMode clientWindowRenderMode =
                clientWindowConfig.getClientWindowRenderMode(context);
        // don't cut the windowId generated from JSF
        if (!ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))
            //already ensured by DefaultClientWindow
            //just to ensure that we don't get a security issue in case of a customized client-window implementation
            //will never happen usually -> no real overhead
            if (windowId != null && windowId.length() > this.maxWindowIdCount)
            {
                windowId = windowId.substring(0, this.maxWindowIdCount);
            }
        writer.write("dswh.init('"  windowId  "','"  clientWindowRenderMode.name()  "',{");

            // don't cut the windowId generated from JSF
            ClientWindowConfig.ClientWindowRenderMode clientWindowRenderMode =
                    clientWindowConfig.getClientWindowRenderMode(facesContext);
            if (!ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))
                if (windowId.length() > this.maxWindowIdCount)
                {
                    windowId = windowId.substring(0, this.maxWindowIdCount);
                }


        boolean delegatedWindowMode =
            ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode);

        if (!delegatedWindowMode)
            windowId = secureWindowId(windowId);
        if (!delegatedWindowMode && clientWindow.isInitialRedirectSupported(context))
                writer.write(",'initialRedirectWindowId':'"  secureWindowId(servletCookie.getValue())  "'");
    protected String secureWindowId(String windowId)
    {
        //restrict the length to prevent script-injection
        if (windowId != null && windowId.length() > this.maxWindowIdCount)
        {
            windowId = windowId.substring(0, this.maxWindowIdCount);
        }
        return windowId;
    }

        writer.write("'storeWindowTree':"  clientWindowConfig.isClientWindowStoreWindowTreeEnabled());
                    
                    if (encodeValues)
                    {
                        finalUrl.append(JsfUtils.encodeURLParameterValue(key, externalContext));
                    }
                    else
                    {
                        finalUrl.append(key);
                    }

        if (encodeValues)
        {
            finalUrl.append(JsfUtils.encodeURLParameterValue(name, externalContext));
        }
        else
        {
            finalUrl.append(name);
        }

                    if (encodeValues)
                    {
                        finalUrl.append(JsfUtils.encodeURLParameterValue(entry.getKey(), externalContext));
                    }
                    else
                    {
                        finalUrl.append(entry.getKey());
                    }

                    appendUrlParameter(finalUrl, key, parameterValue, encodeValues, externalContext);
        appendUrlParameter(finalUrl, name, value, encodeValues, externalContext);
                    appendUrlParameter(finalUrl, entry.getKey(), value, encodeValues, externalContext);
    protected static void appendUrlParameter(StringBuilder url, String name, String value, boolean encode, ExternalContext externalContext)
    {
        if (encode)
        {
            url.append(encodeURLParameterValue(name, externalContext));
        }
        else
        {
            url.append(name);
        }

        url.append("=");

        if (encode)
        {
            url.append(encodeURLParameterValue(value, externalContext));
        }
        else
        {
            url.append(value);
        }
    }
    


    protected static void appendUrlParameter(StringBuilder url, String name, String value, boolean encode,
            ExternalContext externalContext)


    boolean isClientWindowStoreWindowTreeEnabled();

    boolean isClientWindowTokenizedRedirectEnabled();

    @Override
    public boolean isClientWindowTokenizedRedirectEnabled()
    {
        return false;
    }
        writer.write(",'tokenizedRedirect':"  clientWindowConfig.isClientWindowTokenizedRedirectEnabled());
        StringBuilder jpql = new StringBuilder("SELECT COUNT(e) FROM "  getEntityClass()
        jpql.append("WHERE e.");
        jpql.append(EntityUtils.primaryKey(getEntityClass()).getName());
        jpql.append(" = :id");
        final Query query = entityManager.createQuery(jpql.toString());
        query.setParameter("id", EntityUtils.primaryKeyValue(entity));
import javax.enterprise.inject.Stereotype;
@Stereotype

import javax.enterprise.inject.Typed;
    @Typed()
    @Typed()
    @Typed()
    @Typed()
    @Typed()
    @Typed()
import javax.enterprise.inject.Typed;
@Typed()
import javax.enterprise.inject.Stereotype;

@Stereotype
import org.apache.deltaspike.jsf.util.ValueExpressionEvaluationInputStream;
        // wrap InputStream to evaluate EL expressions like resource includes
        is = new ValueExpressionEvaluationInputStream(FacesContext.getCurrentInstance(), is);
    interface Validation
    {
        ViolationMode VIOLATION_MODE =
                ConfigResolver.resolve("deltaspike.validation.violation-mode")
                        .as(ViolationMode.class, new ConfigResolver.Converter<ViolationMode>()
                        {
                            @Override
                            public ViolationMode convert(String value)
                            {
                                return ViolationMode.valueOf(value);
                            }
                        })
                        .withCurrentProjectStage(true)
                        .withDefault(ViolationMode.FAIL)
                        .getValue();

        enum ViolationMode
        {
            IGNORE, WARN, FAIL
        }
    }

import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
        if (!ServiceUtils.loadServiceImplementations(ClassDeactivator.class).isEmpty())
        {
            CoreBaseConfig.Validation.ViolationMode violationMode = CoreBaseConfig.Validation.VIOLATION_MODE;

            String message = "It isn't supported to configure "  ClassDeactivator.class.getName() 
                    " via the std. service-loader config. " 
                    "Please remove all META-INF/services/"  ClassDeactivator.class.getName()  " files. " 
                    "Please configure it via the DeltaSpike-Config (e.g. META-INF/apache-deltaspike.properties).";

            if (violationMode == CoreBaseConfig.Validation.ViolationMode.FAIL)
            {
                throw new IllegalStateException(message);
            }
            else if (violationMode == CoreBaseConfig.Validation.ViolationMode.WARN)
            {
                LOG.warning(message);
            }
        }

import java.io.IOException;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

            List<EntityDescriptor> entities = extractMappings((Element) node, baseUrl, unitName);
    private List<EntityDescriptor> extractMappings(Element element, String baseUrl, String unitName)
            readMappingFiles(baseUrl, unitName, reader, entities, superClasses, list);
    private void readMappingFiles(String baseUrl, String unitName, EntityDescriptorReader reader,
                                  List<EntityDescriptor> entities, List<MappedSuperclassDescriptor> superClasses,
                                  NodeList list)
    {
        for (int i = 0; i < list.getLength(); i)
        {
            String resource = list.item(i).getTextContent();
            try
            {
                MappingFile mappings = reader.readAll(baseUrl, resource);
                entities.addAll(mappings.getEntities());
                superClasses.addAll(mappings.getSuperClasses());
            }
            catch (Exception e)
            {
                throw new RuntimeException("[PersistenceUnit: "  unitName  "] " 
                        "Unable to resolve named mapping-file ["  resource  "]");
            }
        }
    }

import javax.enterprise.inject.Stereotype;
@Stereotype

import javax.enterprise.inject.Stereotype;
@Stereotype

        writer.write("<script type=\"text/javascript\">");
        writer.write("</script>");
    private DependentProvider<? extends EntityManagerResolver> dependentResolverProvider;

                dependentResolverProvider = resolver;
    public void release()
    {
        if (dependentResolverProvider != null)
        {
            dependentResolverProvider.destroy();
        }
    }

            entityManagerLookup.release();
     * @return Whether the DOM tree should stored in the localStorage for the windowhandler.html
     *         when clicking on a link.
     *         Currently it's only used by {@link ClientWindowRenderMode#CLIENTWINDOW}.
    boolean isClientWindowStoreWindowTreeEnabledOnLinkClick();

    /**
     * @return Whether the DOM tree should stored in the localStorage for the windowhandler.html
     *         when sending a AJAX request.
     *         Currently it's only used by {@link ClientWindowRenderMode#CLIENTWINDOW}.
     * @see windowhandler.html
     */
    boolean isClientWindowStoreWindowTreeEnabledOnAjaxRequest();
    
    /**
     * @return Whether the DOM tree should stored in the localStorage for the windowhandler.html
     *         when clicking on a button.
     *         Currently it's only used by {@link ClientWindowRenderMode#CLIENTWINDOW}.
     * @see windowhandler.html
     */
    boolean isClientWindowStoreWindowTreeEnabledOnButtonClick();
    
    public boolean isClientWindowStoreWindowTreeEnabledOnLinkClick()
    
    @Override
    public boolean isClientWindowStoreWindowTreeEnabledOnAjaxRequest()
    {
        return false;
    }
    
    @Override
    public boolean isClientWindowStoreWindowTreeEnabledOnButtonClick()
    {
        return false;
    }
    
        writer.write("'tokenizedRedirect':"  clientWindowConfig.isClientWindowTokenizedRedirectEnabled());
        writer.write(",'storeWindowTreeOnLinkClick':"
                 clientWindowConfig.isClientWindowStoreWindowTreeEnabledOnLinkClick());
        writer.write(",'storeWindowTreeOnButtonClick':"
                 clientWindowConfig.isClientWindowStoreWindowTreeEnabledOnButtonClick());
        writer.write(",'storeWindowTreeOnAjaxRequest':"
                 clientWindowConfig.isClientWindowStoreWindowTreeEnabledOnAjaxRequest());
import org.apache.deltaspike.jpa.api.config.base.JpaBaseConfig;
                return JpaBaseConfig.UserTransaction.TIMEOUT_IN_SECONDS;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.api.provider.DependentProvider;
import org.apache.deltaspike.jpa.api.config.base.JpaBaseConfig;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
    @Inject
    private BeanManager beanManager;
        UserTransaction userTransaction;

        try
        {
            DependentProvider<ManagedUserTransactionResolver> provider =
                BeanProvider.getDependent(this.beanManager, ManagedUserTransactionResolver.class);

            userTransaction = provider.get().resolveUserTransaction();

            provider.destroy();
        }
        catch (Throwable t)
        {
            //it was just a try
            userTransaction = null;
        }

        String jndiName = JpaBaseConfig.UserTransaction.JNDI_NAME;

        String[] jndiNames = jndiName.split(",");

        for (String currentJndiName : jndiNames)
            try
            {
                userTransaction = JndiUtils.lookup(currentJndiName, UserTransaction.class);

                if (userTransaction != null)
                {
                    break;
                }
            }
            catch (Exception e)
            {
                userTransaction = null;
            }

        return userTransaction;
import org.apache.deltaspike.core.util.ExceptionUtils;
            catch (Exception e)
                throw ExceptionUtils.throwAsRuntimeException(e);
    /**
     * Generates a proxy class from the given source class.
     * The proxy class will be generated in the same package as the original class
     * and the suffix will be appended to the name of the class.
     * 
     * @param <T> The target class.
     * @param classLoader The {@link ClassLoader} to be used to define the proxy class.
     * @param targetClass The class to proxy.
     * @param delegateInvocationHandlerClass The {@link InvocationHandler} which will be used for the delegateMethods.
     * @param suffix The classname suffix.
     * @param superAccessorMethodSuffix It's required to generate methods which just invokes the original method.
     *                                  We generate them with the same name as the original method
     *                                  and append the suffix.
     * @param additionalInterfaces Additional interfaces which should be implemented.
     * @param delegateMethods Methods which should be delegated to the {@code delegateInvocationHandlerClass}
     *                        instead of invoking the original method.
     * @param interceptMethods Methods which should be intercepted (to call interceptors or decorators)
     *                         before invoking the original method.
     * @return The generated proxy class.
     */
    @Override
import org.apache.deltaspike.data.impl.property.Property;
import java.io.Serializable;
            Property<Serializable> versionProperty = EntityUtils.getVersionProperty(entity);
            if (versionProperty != null)
            {
                return versionProperty.getValue(entity) == null;
            }

    EntityDescriptor(String name, String packageName, String className, String idClass, String id,
                     String version, String tableName)
        super(name, packageName, className, idClass, id, version);
                                      String idClass, String id, String version, String tableName)
                return new EntityDescriptor(name, packageName, className, idClass, id, version, tableName);
                                                String idClass, String id, String version)
                return new MappedSuperclassDescriptor(name, packageName, className, idClass, id, version);
        protected String version;
                this.version = extractNodeAttribute((Element) mappings.item(i), "version", "name");
        protected abstract T instance(String name, String packageName, String className, String idClass, String id,
                                      String version);
            result.add(instance(name, packageName, className, idClass, id != null ? id : embeddedId, version));
                                      String version, String tableName);
            result.add(instance(name, packageName, className, idClass, id != null ? id : embeddedId,
                version, tableName));
    MappedSuperclassDescriptor(String name, String packageName, String className, String idClass, String id,
                               String version)
        super(name, packageName, className, idClass, id, version);
    public String versionField(Class<?> entityClass)
    {
        EntityDescriptor entity = find(entityClass);
        if (entity != null)
        {
            return entity.getVersion();
        }
        return null;
    }

    protected final String version;
    PersistentClassDescriptor(String name, String packageName, String className, String idClass, String id,
                              String version)
        this.version = version;
    public String getVersion()
    {
        return version;
    }

import javax.persistence.Version;

    public static Property<Serializable> getVersionProperty(Object entity)
    {
        Class<?> entityClass = entity.getClass();
        List<PropertyCriteria> criteriaList = new LinkedList<PropertyCriteria>();
        criteriaList.add(new AnnotatedPropertyCriteria(Version.class));

        String fromMappingFiles = PersistenceUnits.instance().versionField(entityClass);
        if (fromMappingFiles != null)
        {
            criteriaList.add(new NamedPropertyCriteria(fromMappingFiles));
        }

        for (PropertyCriteria criteria : criteriaList)
        {
            PropertyQuery<Serializable> query =
                PropertyQueries.<Serializable> createQuery(entityClass).addCriteria(criteria);
            Property<Serializable> result = query.getFirstResult();
            if (result != null)
            {
                return result;
            }
        }

        return null;
    }
import java.util.Collections;
            Collections.addAll(this.types, type.getJavaClass().getInterfaces());
            this.types.add(Object.class);
                        .withDefault(999) //PLATFORM_BEFORE is 0, LIBRARY_BEFORE is 1000 and APPLICATION is 2000
import java.lang.reflect.Method;
import org.apache.deltaspike.core.util.ReflectionUtils;
    private static final String RELEASE_INSTANCE_METHOD_NAME = "releaseInstance";
    private static Boolean releaseInstanceMethodFound;
    private static Method releaseInstanceMethod;
        T resolvedInst = BeanProvider.getContextualReference(validatorClass, true);
    //BV v1.1
    public void releaseInstance(ConstraintValidator<?, ?> constraintValidator)
    {
        if (releaseInstanceMethodFound == null)
        {
            lazyInit();
        }
        if (Boolean.TRUE.equals(releaseInstanceMethodFound))
        {
            ReflectionUtils.invokeMethod(this.delegate, releaseInstanceMethod, Void.class, true, constraintValidator);
        }
    }

    private synchronized void lazyInit()
    {
        if (releaseInstanceMethodFound != null)
        {
            return;
        }

        Class<?> currentClass = delegate.getClass();
        while (currentClass != null && !Object.class.getName().equals(currentClass.getName()))
        {
            for (Method currentMethod : currentClass.getDeclaredMethods())
            {
                if (RELEASE_INSTANCE_METHOD_NAME.equals(currentMethod.getName()) &&
                        currentMethod.getParameterTypes().length == 1 &&
                        currentMethod.getParameterTypes()[0].equals(ConstraintValidator.class))
                {
                    releaseInstanceMethod = currentMethod;
                    releaseInstanceMethodFound = true;
                    return;
                }

            }

            currentClass = currentClass.getSuperclass();
        }

        releaseInstanceMethodFound = false;
    }
            result = params.applyTo(entityManager.createNativeQuery(jpqlQuery, context.getEntityClass()));
            if (invocationHandlerProvider != null)
            {
                invocationHandlerProvider.destroy();
            }
                        "org.apache.deltaspike.scheduler",
                        "org.quartz"},
                        "org.apache.deltaspike.scheduler"},
import org.apache.deltaspike.core.api.projectstage.ProjectStage;
import org.apache.deltaspike.core.util.activation.BaseClassDeactivationController;
import org.apache.deltaspike.core.util.activation.CachingClassDeactivationController;
import org.apache.deltaspike.core.util.activation.NonCachingClassDeactivationController;
import java.util.Arrays;
    private static final List<ProjectStage> NON_CACHING_PROJECT_STAGES =
        Arrays.asList(ProjectStage.Development,ProjectStage.UnitTest);
    private static BaseClassDeactivationController classDeactivationController = null;
        return getController().isActivated(targetClass);
    private static BaseClassDeactivationController getController()
        if (classDeactivationController == null)
            classDeactivationController = calculateControllerToUse();
        return classDeactivationController;
    private static BaseClassDeactivationController calculateControllerToUse()
        ProjectStage currentProjectStage = ProjectStageProducer.getInstance().getProjectStage();
        if (NON_CACHING_PROJECT_STAGES.contains(currentProjectStage))
            return new NonCachingClassDeactivationController();
        else
            return new CachingClassDeactivationController();
            if (this.contextControl != null)
            {
                this.contextControl.destroy();
            }
            if (this.contextControl == null)
            {
                return;
            }

            this.contextControl.destroy();
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
import org.apache.deltaspike.core.spi.activation.ClassDeactivator;
import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;
    private static final Logger LOG = Logger.getLogger(ClassDeactivationUtils.class.getName());
    /**
     * This Map holds the ClassLoader as first level to make it possible to have different configurations per 
     * WebApplication in an EAR or other Multi-ClassLoader scenario.
     * 
     * The Map then contains a List of {@link ClassDeactivator}s in order of their configured ordinal.
     */
    private static Map<ClassLoader, List<ClassDeactivator>> classDeactivatorMap
        = new ConcurrentHashMap<ClassLoader, List<ClassDeactivator>>();
    /**
     * Cache for the result. It won't contain many classes but it might be accessed frequently.
     * Valid entries are only true or false. If an entry isn't available or null, it gets calculated.
     */
    private static Map<Class<? extends Deactivatable>, Boolean> activationStatusCache
        = new ConcurrentHashMap<Class<? extends Deactivatable>, Boolean>();
    
        Boolean activatedClassCacheEntry = activationStatusCache.get(targetClass);

        if (activatedClassCacheEntry == null)
        {
            initDeactivatableCacheFor(targetClass);
            activatedClassCacheEntry = activationStatusCache.get(targetClass);
        }
        return activatedClassCacheEntry;
    private static synchronized void initDeactivatableCacheFor(Class<? extends Deactivatable> targetClass)
        Boolean activatedClassCacheEntry = activationStatusCache.get(targetClass);

        if (activatedClassCacheEntry != null) //double-check
            return;
        List<ClassDeactivator> classDeactivators = getClassDeactivators();

        Boolean isActivated = Boolean.TRUE;
        Class<? extends ClassDeactivator> deactivatedBy = null;

        LOG.fine("start evaluation if "  targetClass.getName()  " is de-/activated");

        // we get the classActivators ordered by it's ordinal
        // thus the last one which returns != null 'wins' ;)
        for (ClassDeactivator classDeactivator : classDeactivators)
        {
            Boolean isLocallyActivated = classDeactivator.isActivated(targetClass);

            if (isLocallyActivated != null)
            {
                isActivated = isLocallyActivated;

                /*
                * Check and log the details across class-deactivators
                */
                if (!isActivated)
                {
                    deactivatedBy = classDeactivator.getClass();
                    LOG.fine("Deactivating class "  targetClass);
                }
                else if (deactivatedBy != null)
                {
                    LOG.fine("Reactivation of: "  targetClass.getName()  " by " 
                            classDeactivator.getClass().getName() 
                            " - original deactivated by: "  deactivatedBy.getName()  ".\n" 
                            "If that isn't the intended behaviour, you have to use a higher ordinal for " 
                            deactivatedBy.getName());
                }
            }
        }

        cacheResult(targetClass, isActivated);
    private static void cacheResult(Class<? extends Deactivatable> targetClass, Boolean activated)
        activationStatusCache.put(targetClass, activated);
        LOG.info("class: "  targetClass.getName()  " activated="  activated);
    }
    /**
     * @return the List of configured @{link ClassDeactivator}s for the current context ClassLoader.
     */
    private static List<ClassDeactivator> getClassDeactivators()
    {
        ClassLoader classLoader = ClassUtils.getClassLoader(null);
        List<ClassDeactivator> classDeactivators = classDeactivatorMap.get(classLoader);

        if (classDeactivators == null)
            return initConfiguredClassDeactivators(classLoader);

        return classDeactivators;
    }

    //synchronized isn't needed - #initDeactivatableCacheFor is already synchronized
    private static List<ClassDeactivator> initConfiguredClassDeactivators(ClassLoader classLoader)
    {
        if (!ServiceUtils.loadServiceImplementations(ClassDeactivator.class).isEmpty())
            CoreBaseConfig.Validation.ViolationMode violationMode = CoreBaseConfig.Validation.VIOLATION_MODE;

            String message = "It isn't supported to configure "  ClassDeactivator.class.getName() 
                    " via the std. service-loader config. " 
                    "Please remove all META-INF/services/"  ClassDeactivator.class.getName()  " files. " 
                    "Please configure it via the DeltaSpike-Config (e.g. META-INF/apache-deltaspike.properties).";

            if (violationMode == CoreBaseConfig.Validation.ViolationMode.FAIL)
            {
                throw new IllegalStateException(message);
            }
            else if (violationMode == CoreBaseConfig.Validation.ViolationMode.WARN)
            {
                LOG.warning(message);
            }

        List<String> classDeactivatorClassNames = ConfigResolver.getAllPropertyValues(ClassDeactivator.class.getName());

        List<ClassDeactivator> classDeactivators = new ArrayList<ClassDeactivator>();

        for (String classDeactivatorClassName : classDeactivatorClassNames)
        {
            LOG.fine("processing ClassDeactivator: "  classDeactivatorClassName);

            try
            {
                ClassDeactivator currentClassDeactivator =
                        (ClassDeactivator) ClassUtils.instantiateClassForName(classDeactivatorClassName);
                classDeactivators.add(currentClassDeactivator);
            }
            catch (Exception e)
            {
                LOG.warning(classDeactivatorClassName  " can't be instantiated");
                throw new IllegalStateException(e);
            }
        }

        classDeactivatorMap.put(classLoader, classDeactivators);
        return classDeactivators;
import org.apache.deltaspike.core.api.projectstage.ProjectStage;
     *

    private static ProjectStage previouslyDetectedProjectStage;

        performProjectStageDependentCleanup();

        //just to support parallel access to #isActivated ( reset) in project-stage unit-test and development
        Map<Class<? extends Deactivatable>, Boolean> activeCache = activationStatusCache;
        Boolean activatedClassCacheEntry = activeCache.get(targetClass);
            initDeactivatableCacheFor(targetClass, activeCache);
            activatedClassCacheEntry = activeCache.get(targetClass);
    private static void performProjectStageDependentCleanup()
        ProjectStage currentProjectStage = ProjectStageProducer.getInstance().getProjectStage();

        if (previouslyDetectedProjectStage != currentProjectStage)
        {
            previouslyDetectedProjectStage = currentProjectStage;
            //don't use #clear to support parallel access to #isActivated ( reset) without synchronization
            activationStatusCache = new ConcurrentHashMap<Class<? extends Deactivatable>, Boolean>();

            //#clear is ok here due to the handling in the synchronized method #initDeactivatableCacheFor
            classDeactivatorMap.clear();
        }
        else if (currentProjectStage == ProjectStage.UnitTest || currentProjectStage == ProjectStage.Development)
        {
            activationStatusCache = new ConcurrentHashMap<Class<? extends Deactivatable>, Boolean>();
        }
    }

    private static synchronized void initDeactivatableCacheFor(Class<? extends Deactivatable> targetClass,
                                                               Map<Class<? extends Deactivatable>, Boolean> activeCache)
    {
        Boolean activatedClassCacheEntry = activeCache.get(targetClass);
        cacheResult(targetClass, isActivated, activeCache);
    private static void cacheResult(Class<? extends Deactivatable> targetClass, Boolean activated,
                                    Map<Class<? extends Deactivatable>, Boolean> activeCache)
        activeCache.put(targetClass, activated);
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import javax.enterprise.context.Dependent;
import javax.enterprise.inject.Produces;
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
import org.apache.deltaspike.core.util.AnnotationUtils;
import org.apache.deltaspike.core.util.BeanUtils;

                        List<Bean> partialProducerBeans =
                            createPartialProducersDefinedIn(partialBean, afterBeanDiscovery, beanManager);

                        for (Bean partialProducerBean : partialProducerBeans)
                        {
                            afterBeanDiscovery.addBean(partialProducerBean);
                        }

    /*
     * logic for partial-producers
     */

    protected List<Bean> createPartialProducersDefinedIn(
        Bean partialBean, AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
    {
        Class currentClass = partialBean.getBeanClass();
        return createPartialProducersDefinedIn(partialBean, afterBeanDiscovery, beanManager, currentClass);
    }

    private List<Bean> createPartialProducersDefinedIn(
        Bean partialBean, AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager, Class currentClass)
    {
        List<Bean> result = new ArrayList<Bean>();

        while (currentClass != null && !Object.class.getName().equals(currentClass.getName()))
        {
            for (Class interfaceClass : currentClass.getInterfaces())
            {
                if (interfaceClass.getName().startsWith("java.") || interfaceClass.getName().startsWith("javax."))
                {
                    continue;
                }
                result.addAll(
                    createPartialProducersDefinedIn(partialBean, afterBeanDiscovery, beanManager, interfaceClass));
            }

            for (Method currentMethod : currentClass.getDeclaredMethods())
            {
                if (currentMethod.isAnnotationPresent(Produces.class))
                {
                    if (currentMethod.getParameterTypes().length > 0)
                    {
                        afterBeanDiscovery.addDefinitionError(
                            new IllegalStateException(
                                "Producer-methods in partial-beans currently don't support injection-points. " 
                                "Please remove the parameters from " 
                                currentMethod.toString()  " in "  currentClass.getName()));
                    }

                    DeltaSpikePartialProducerLifecycle lifecycle =
                        new DeltaSpikePartialProducerLifecycle(partialBean.getBeanClass(), currentMethod);

                    Class<? extends Annotation> scopeClass =
                        extractScope(currentMethod.getDeclaredAnnotations(), beanManager);

                    Class<?> producerResultType = currentMethod.getReturnType();

                    boolean passivationCapable =
                        Serializable.class.isAssignableFrom(producerResultType) || producerResultType.isPrimitive();

                    Set<Annotation> qualifiers = extractQualifiers(currentMethod.getDeclaredAnnotations(), beanManager);

                    BeanBuilder<?> beanBuilder = new BeanBuilder(beanManager)
                            .beanClass(producerResultType)
                            .types(Object.class, producerResultType)
                            .qualifiers(qualifiers)
                            .passivationCapable(passivationCapable)
                            .scope(scopeClass)
                            .id(createPartialProducerId(currentClass, currentMethod, qualifiers))
                            .beanLifecycle(lifecycle);

                    result.add(beanBuilder.create());
                }
            }

            currentClass = currentClass.getSuperclass();
        }

        return result;
    }

    private Set<Annotation> extractQualifiers(Annotation[] annotations, BeanManager beanManager)
    {
        Set<Annotation> result = BeanUtils.getQualifiers(beanManager, annotations);

        if (result.isEmpty())
        {
            result.add(new DefaultLiteral());
        }
        return result;
    }

    private Class<? extends Annotation> extractScope(Annotation[] annotations, BeanManager beanManager)
    {
        for (Annotation annotation : annotations)
        {
            if (beanManager.isScope(annotation.annotationType()))
            {
                return annotation.annotationType();
            }
        }
        return Dependent.class;
    }

    private String createPartialProducerId(Class currentClass, Method currentMethod, Set<Annotation> qualifiers)
    {
        int qualifierHashCode = 0;
        for (Annotation qualifier : qualifiers)
        {
            qualifierHashCode = AnnotationUtils.getQualifierHashCode(qualifier);
        }
        return "PartialProducer#"  currentClass.getName()  "#"  currentMethod.getName()  "#"  qualifierHashCode;
    }
import org.apache.deltaspike.core.util.AbstractInvocationContext;
public abstract class InvocationContextWrapper extends AbstractInvocationContext<Object>
        super(context.getProxy(), context.getMethod(), context.getMethodParameters(), null);

import org.apache.deltaspike.core.util.AbstractInvocationContext;
 * {@link javax.interceptor.InvocationContext}
 * implementation to support manual interceptor invocation before invoking the
public class ManualInvocationContext<T, H> extends AbstractInvocationContext<T>
        super(target, method, parameters, timer);

import javax.enterprise.inject.spi.BeanManager;
import org.apache.deltaspike.core.util.AbstractInvocationContext;
import org.apache.deltaspike.core.util.AnnotationUtils;
import org.apache.deltaspike.core.util.ExceptionUtils;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy;
    @Inject
    private BeanManager beanManager;

    @Inject
    private TransactionStrategy transactionStrategy;

    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable
    {
        Transactional transactionalAnnotation =
            AnnotationUtils.extractAnnotationFromMethodOrClass(
                this.beanManager, method, proxy.getClass(), Transactional.class);

        if (transactionalAnnotation != null)
        {
            return transactionStrategy.execute(
                new AbstractInvocationContext<Object>(proxy, method, args, null)
                {
                    @Override
                    public Object proceed() throws Exception
                    {
                        try
                        {
                            return process(proxy, method, args);
                        }
                        catch (Throwable t)
                        {
                            throw ExceptionUtils.throwAsRuntimeException(t);
                        }
                    }
                });
        }
        else
        {
            return process(proxy, method, args);
        }
    }

    public Object process(Object proxy, Method method, Object[] args) throws Throwable
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/interceptor/AbstractInvocationContext.java
package org.apache.deltaspike.core.util.interceptor;
import org.apache.deltaspike.core.util.interceptor.AbstractInvocationContext;
import org.apache.deltaspike.core.util.interceptor.AbstractInvocationContext;
import org.apache.deltaspike.core.util.interceptor.AbstractInvocationContext;
     * @return the type to use if no objectName was specified. Default is <pre>MBeans</pre> and can be
     *         overriden either directly by the value or by a key used to resolve a value using
     *         {@link org.apache.deltaspike.core.api.config.ConfigResolver}. It is a key if the value is between
     *         brackets.
     */
    String type() default "";

    /**
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
            final String type = getConfigurableAttribute(mBeanAnnotation.type(), "MBeans");
            final String category = getConfigurableAttribute(mBeanAnnotation.category(), "org.apache.deltaspike");
            objectNameValue = category  ":type="  type  ",name="  name;
        LOGGER.info("Registered MBean "  objectName); // don't use canonical name cause it can reorder properties

    private String getConfigurableAttribute(final String annotationAttributeValue, final String defaultValue)
    {
        String val = annotationAttributeValue.trim();
        if (val.startsWith("{") && val.endsWith("}"))
        {
            val = ConfigResolver.getPropertyValue(val.substring(1, val.length() - 1), defaultValue);
        }
        return val == null || val.isEmpty() ? defaultValue : val;
    }
     * @return the properties part of the objectName if no objectName was specified.
     *         If name and type are specified this segment is concatenated after.
     */
    String properties() default "";

    /**
    private static final String DEFAULT_TYPE = "MBeans";
    private static final String DEFAULT_CATEGORY = "org.apache.deltaspike";
            final String type = getConfigurableAttribute(mBeanAnnotation.type(), DEFAULT_TYPE);
            final String category = getConfigurableAttribute(mBeanAnnotation.category(), DEFAULT_CATEGORY);
            final String properties = getConfigurableAttribute(mBeanAnnotation.properties(), "");
            final String name = mBeanAnnotation.name();

            final StringBuilder builder = new StringBuilder(category).append(':');
            if (!properties.contains("type="))
                builder.append("type=").append(type);
            else if (!DEFAULT_TYPE.equals(type))
            {
                LOGGER.warning("type() ignored on "  clazz  " since properties contains it.");
            }
            if (!properties.contains("name="))
            {
                if (!name.isEmpty() || properties.isEmpty())
                {
                    builder.append(",name=");
                    if (name.isEmpty())
                    {
                        builder.append(clazz.getName());
                    }
                    else
                    {
                        builder.append(name);
                    }
                } // else skip. type is important in JMX but name is a fully custom property so we are able to skip it
            }
            if (!properties.isEmpty())
            {
                builder.append(',').append(properties);
            }
            objectNameValue = builder.toString();
        //later on method-level annotations need to overrule class-level annotations -> don't change the order
        result.addAll(SecurityUtils.getAllAnnotations(method.getAnnotations(),
                new HashSet<Integer>()));
import org.apache.deltaspike.core.spi.config.ConfigValidator;
import org.apache.deltaspike.core.util.ServiceUtils;

        processConfigurationValidation(adv);

    protected void processConfigurationValidation(AfterDeploymentValidation adv)
    {
        for (ConfigValidator configValidator : ServiceUtils.loadServiceImplementations(ConfigValidator.class))
        {
            Set<String> violations = configValidator.processValidation();

            if (violations == null)
            {
                continue;
            }

            for (String violation : violations)
            {
                adv.addDeploymentProblem(new IllegalStateException(violation));
            }
        }
    }
import javax.enterprise.inject.spi.BeforeShutdown;
    private static RepositoryComponents staticComponents = new RepositoryComponents();

                staticComponents.add(repoClass);

        RepositoryComponents result = new RepositoryComponents();
        if (components.getRepositories().isEmpty() && !staticComponents.getRepositories().isEmpty())
        {
            result.addAll(staticComponents.getRepositories());
        }

        if (!components.getRepositories().isEmpty())
        {
            result.addAll(components.getRepositories());
        }

        return result;
    protected void cleanup(@Observes BeforeShutdown beforeShutdown)
    {
        //we can reset it in any case,
        //because every application produced a copy as application-scoped bean (see RepositoryComponentsFactory)
        staticComponents.getRepositories().clear();
    }
import java.util.concurrent.ConcurrentHashMap;
    private final Map<Class<?>, RepositoryComponent> repos = new ConcurrentHashMap<Class<?>, RepositoryComponent>();
    public Map<Class<?>, RepositoryComponent> getRepositories()
    {
        return repos;
    }

    public void addAll(Map<Class<?>, RepositoryComponent> repositories)
    {
        this.repos.putAll(repositories);
    }
import javax.enterprise.context.ApplicationScoped;
    @ApplicationScoped
 * <p>
 * By default the Message Source is a resource bundle with the same name as the {@code &#064;MessageBundle}
 * annotated interface, e.g. {@code com.acme.MyMessages_en.properties}.
 * </p>
 * message resolution and processing. To use a different resourcebundle, e.g. {@code somepath/myownmessages_en.properties}
 * you might write:
 * <pre>
 * &#064;MessageBundle
 * &#064;MessageContextConfig(messageSource = "somepath/myownmessages")
 * </pre>
 * 
 * </p>
 * message resolution and processing. To use a different resourcebundle, e.g. 
 * {@code somepath/myownmessages_en.properties} you might write:
     * <p>
     * DeltaSpike JSF messages e.g. distinguish between categories
     * {@code &quot;summary&quot;} and {@code &quot;detail&quot;}
     * to allow a short and a more detailed explanation in Error, Warn and Info popups at the same time.
     * </p>
 *
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.deltaspike.core.impl.message;

import java.io.Serializable;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.event.Observes;
import javax.enterprise.inject.spi.AfterBeanDiscovery;
import javax.enterprise.inject.spi.AfterDeploymentValidation;
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import javax.enterprise.inject.spi.Extension;
import javax.enterprise.inject.spi.ProcessAnnotatedType;

import org.apache.deltaspike.core.api.literal.DefaultLiteral;
import org.apache.deltaspike.core.api.message.Message;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.api.provider.DependentProvider;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.ParentExtensionStorage;
import org.apache.deltaspike.core.util.bean.BeanBuilder;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import org.apache.deltaspike.core.util.metadata.builder.ContextualLifecycle;

/**
 * Extension for handling {@link MessageBundle}s.
 *
 * @see MessageBundle
 * @see MessageTemplate
 */
public class MessageBundleExtension implements Extension, Deactivatable
{
    private final Collection<AnnotatedType<?>> messageBundleTypes = new HashSet<AnnotatedType<?>>();

    private List<String> deploymentErrors = new ArrayList<String>();

    private Boolean isActivated = true;

    @SuppressWarnings("UnusedDeclaration")
    protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
    {
        isActivated = ClassDeactivationUtils.isActivated(getClass());
        ParentExtensionStorage.addExtension(this);
    }

    @SuppressWarnings("UnusedDeclaration")
    protected void detectInterfaces(@Observes ProcessAnnotatedType processAnnotatedType)
    {
        if (!isActivated)
        {
            return;
        }

        AnnotatedType<?> type = processAnnotatedType.getAnnotatedType();

        if (type.isAnnotationPresent(MessageBundle.class))
        {
            if (validateMessageBundle(type.getJavaClass()))
            {
                messageBundleTypes.add(type);
            }
        }
    }

    /**
     * @return <code>true</code> if all is well
     */
    private boolean validateMessageBundle(Class<?> currentClass)
    {
        boolean ok = true;

        // sanity check: annotated class must be an Interface
        if (!currentClass.isInterface())
        {
            deploymentErrors.add("@MessageBundle must only be used on Interfaces, but got used on class " 
                    currentClass.getName());
            return false;
        }

        for (Method currentMethod : currentClass.getDeclaredMethods())
        {
            if (!currentMethod.isAnnotationPresent(MessageTemplate.class))
            {
                continue;
            }
            
            if (String.class.isAssignableFrom(currentMethod.getReturnType()))
            {
                continue;
            }

            if (Message.class.isAssignableFrom(currentMethod.getReturnType()))
            {
                continue;
            }

            deploymentErrors.add(currentMethod.getReturnType().getName()  " isn't supported. Details: " 
                    currentMethod.getDeclaringClass().getName()  "#"  currentMethod.getName() 
                    " only "  String.class.getName()  " or "  Message.class.getName());
            ok = false;
        }

        return ok;
    }

    @SuppressWarnings("UnusedDeclaration")
    protected void installMessageBundleProducerBeans(@Observes AfterBeanDiscovery abd, BeanManager beanManager)
    {
        if (!deploymentErrors.isEmpty())
        {
            abd.addDefinitionError(new IllegalArgumentException("The following MessageBundle problems where found: " 
                    Arrays.toString(deploymentErrors.toArray())));
            return;
        }

        MessageBundleExtension parentExtension = ParentExtensionStorage.getParentExtension(this);
        if (parentExtension != null)
        {
            messageBundleTypes.addAll(parentExtension.messageBundleTypes);
        }

        for (AnnotatedType<?> type : messageBundleTypes)
        {
            abd.addBean(createMessageBundleBean(type, beanManager));
        }
    }

    private <T> Bean<T> createMessageBundleBean(AnnotatedType<T> annotatedType,
                                                BeanManager beanManager)
    {
        BeanBuilder<T> beanBuilder = new BeanBuilder<T>(beanManager).readFromType(annotatedType);

        beanBuilder.beanLifecycle(new MessageBundleLifecycle<T>(beanManager));

        beanBuilder.types(annotatedType.getJavaClass(), Object.class, Serializable.class);
        beanBuilder.addQualifier(new DefaultLiteral());

        beanBuilder.passivationCapable(true);
        beanBuilder.scope(ApplicationScoped.class); // needs to be a normalscope due to a bug in older Weld versions
        beanBuilder.id("MessageBundleBean#"  annotatedType.getJavaClass().getName());

        return beanBuilder.create();
    }

    @SuppressWarnings("UnusedDeclaration")
    protected void cleanup(@Observes AfterDeploymentValidation afterDeploymentValidation)
    {
        messageBundleTypes.clear();
    }

    private static class MessageBundleLifecycle<T> implements ContextualLifecycle<T>
    {
        private final BeanManager beanManager;

        private DependentProvider<MessageBundleInvocationHandler> invocationHandlerProvider;

        private MessageBundleLifecycle(BeanManager beanManager)
        {
            this.beanManager = beanManager;
        }

        @Override
        public T create(Bean<T> bean, CreationalContext<T> creationalContext)
        {
            invocationHandlerProvider = BeanProvider.getDependent(beanManager, MessageBundleInvocationHandler.class);

            return createMessageBundleProxy((Class<T>) bean.getBeanClass(), invocationHandlerProvider.get());
        }

        @Override
        public void destroy(Bean<T> bean, T instance, CreationalContext<T> creationalContext)
        {
            if (invocationHandlerProvider != null)
            {
                invocationHandlerProvider.destroy();
            }
        }

        private <T> T createMessageBundleProxy(Class<T> type, MessageBundleInvocationHandler handler)
        {
            return type.cast(Proxy.newProxyInstance(ClassUtils.getClassLoader(null),
                    new Class<?>[]{type, Serializable.class}, handler));
        }

    }
}
import org.apache.deltaspike.core.util.ParentExtensionStorage;
        ParentExtensionStorage.addExtension(this);

        SecurityExtension parentExtension = ParentExtensionStorage.getParentExtension(this);
        if (parentExtension != null)
        {
            // also add the authorizers from the parent extension
            Set<Authorizer> parentAuthorizers = parentExtension.getMetaDataStorage().getAuthorizers();
            for (Authorizer parentAuthorizer : parentAuthorizers)
            {
                metaDataStorage.addAuthorizer(parentAuthorizer);
            }
        }

    
    /**
     * @return The new redirect url.
     */
    String interceptRedirect(FacesContext facesContext, String url);

import javax.faces.context.PartialViewContext;
import org.apache.deltaspike.jsf.impl.navigation.DeltaSpikePartialViewContext;
    public PartialViewContext getPartialViewContext()
    {
        PartialViewContext partialViewContext = getWrapped().getPartialViewContext();
        return new DeltaSpikePartialViewContext(partialViewContext);
    }
    
    @Override
    @Override
    public String interceptRedirect(FacesContext facesContext, String url)
    {
        return getClientWindow(facesContext).interceptRedirect(facesContext, url);
    }

    
    @Override
    public String interceptRedirect(FacesContext facesContext, String url)
    {
        return url;
    }
    
    @Override
    public String interceptRedirect(FacesContext facesContext, String url)
    {
        if (facesContext.getPartialViewContext().isAjaxRequest())
        {
            String requestToken = newRequestToken();
            String windowId = getWindowId(facesContext);
            
            ClientWindowHelper.addRequestWindowIdCookie(facesContext,
                    requestToken,
                    windowId);

            url = JsfUtils.addParameter(facesContext.getExternalContext(),
                    url,
                    true,
                    ClientWindowHelper.RequestParameters.GET_WINDOW_ID,
                    windowId);
            url = JsfUtils.addParameter(facesContext.getExternalContext(),
                    url,
                    true,
                    ClientWindowHelper.RequestParameters.REQUEST_TOKEN,
                    requestToken);

            return url;
        }
        
        return url;
    }
    
    protected String newRequestToken()
    {
        return ""  ((int) Math.floor(Math.random() * 999));
    }
        // remember the initial redirect windowId till the next request - see #729
        if (clientWindow != null)
        {
            url = clientWindow.interceptRedirect(facesContext, url);
        }
        this.wrapped.redirect(url);
    protected String generateNewRequestToken()
    {
        return ""  ((int) Math.floor(Math.random() * 999));
    }
    
        return ClientWindowHelper.appendWindowId(facesContext, url, this);

            String requestToken = generateNewRequestToken();
        // following cases we can mark as valid next request:
        // 1) request == !ajax and GET
        //   A redirect via ExternalContext can only be done in a JSF request.
        //   As the windowId is validated before the JSF lifecycle starts
        //   (via windowhandler streaming/request token validation), we can assume that the current request
        //   is valid and we can just mark the next request/redirect as valid, too.
        // 2) request == ajax and POST
        //   Ajax is always a "post back", so the browser tab was already validated in earlier requests.
        //   
        //   
        // following cases we can NOT mark as valid next request:
        // 1) request == !ajax and POST
        //   This is a Post/Redirect/Get - as the post can be done to a new browser tab
        //   (via the target attribute on the form), the windowId must NOT be valid.
        // 2) request == ajax and GET
        //   Not a common JSF request.
        //   
        boolean ajax = facesContext.getPartialViewContext().isAjaxRequest();
        boolean post = isPost(facesContext);
        boolean get = !post;
        if ((!ajax && get) || (ajax && post))
import java.io.Serializable;
public interface ActiveEntityManagerHolder extends Serializable
import java.util.Map;
public class PersistenceUnit
    private final Map<String, String> properties;
    PersistenceUnit(String unitName, List<EntityDescriptor> entities, Map<String, String> properties)
        this.properties = properties;
    
    public Map<String, String> getProperties()
    {
        return properties;
    }
import java.util.HashMap;
import java.util.Map;
            Map<String, String> properties = extractProperties((Element) node);
            result.add(new PersistenceUnit(unitName, entities, properties));
    private Map<String, String> extractProperties(Element element)
    {
        Map<String, String> propertiesMap = new HashMap<String, String>();

        Node propertiesNode = element.getElementsByTagName("properties").item(0);
        if (propertiesNode != null)
        {
            NodeList propertyNodes = propertiesNode.getChildNodes();
            for (int i = 0; i < propertyNodes.getLength(); i)
            {
                if ("property".equals(propertyNodes.item(i).getNodeName()))
                {
                    Element propertyNode = (Element) propertyNodes.item(i);
                    propertiesMap.put(propertyNode.getAttribute("name"), propertyNode.getAttribute("value"));
                }
            }
        }

        return Collections.unmodifiableMap(propertiesMap);
    }
    public PersistenceUnit get(String name)
    {
        for (PersistenceUnit unit : persistenceUnits)
        {
            if (name.equalsIgnoreCase(unit.getUnitName()))
            {
                return unit;
            }
        }
        return null;
    }

import java.util.logging.Level;
        if (LOG.isLoggable(Level.FINE))
        {
            LOG.fine("class: "  targetClass.getName()  " activated="  activated);
        }
    
    /**
     * Tries to load a class based on the given name and interface or abstract class.
     * @param name name of the concrete class
     * @param targetType target type (interface or abstract class)
     * @param classLoader The {@link ClassLoader}.
     * @param <T> current type
     * @return loaded class or null if it isn't in the classpath
     */
    public static <T> Class<T> tryToLoadClassForName(String name, Class<T> targetType, ClassLoader classLoader)
    {
        return (Class<T>) tryToLoadClassForName(name, classLoader);
    }
    
    /**
     * Tries to load a class based on the given name
     * @param name name of the class
     * @param classLoader The {@link ClassLoader}.
     * @return loaded class or <code>null</code> if it isn't in the classpath
     */
    public static Class tryToLoadClassForName(String name, ClassLoader classLoader)
    {
        try
        {
            return classLoader.loadClass(name);
        }
        catch (ClassNotFoundException e)
        {
            //do nothing - it's just a try
            return null;
        }
    }
    public <T> Class<T> resolveAlreadyDefinedProxyClass(Class<T> targetClass)
    {
        Class<T> proxyClass = ClassUtils.tryToLoadClassForName(constructProxyClassName(targetClass),
                targetClass,
                targetClass.getClassLoader());

        return proxyClass;
    }
    
        Class<T> proxyClass = resolveAlreadyDefinedProxyClass(targetClass);
        Class<T> proxyClass = resolveAlreadyDefinedProxyClass(targetClass);
import java.util.logging.Level;
        if (LOG.isLoggable(Level.FINE))
        {
            LOG.fine("class: "  targetClass.getName()  " activated="  activated);
        }
    
    /**
     * Tries to load a class based on the given name and interface or abstract class.
     * @param name name of the concrete class
     * @param targetType target type (interface or abstract class)
     * @param classLoader The {@link ClassLoader}.
     * @param <T> current type
     * @return loaded class or null if it isn't in the classpath
     */
    public static <T> Class<T> tryToLoadClassForName(String name, Class<T> targetType, ClassLoader classLoader)
    {
        return (Class<T>) tryToLoadClassForName(name, classLoader);
    }
    
    /**
     * Tries to load a class based on the given name
     * @param name name of the class
     * @param classLoader The {@link ClassLoader}.
     * @return loaded class or <code>null</code> if it isn't in the classpath
     */
    public static Class tryToLoadClassForName(String name, ClassLoader classLoader)
    {
        try
        {
            return classLoader.loadClass(name);
        }
        catch (ClassNotFoundException e)
        {
            //do nothing - it's just a try
            return null;
        }
    }
    public <T> Class<T> resolveAlreadyDefinedProxyClass(Class<T> targetClass)
    {
        Class<T> proxyClass = ClassUtils.tryToLoadClassForName(constructProxyClassName(targetClass),
                targetClass,
                targetClass.getClassLoader());

        return proxyClass;
    }
    
        Class<T> proxyClass = resolveAlreadyDefinedProxyClass(targetClass);
        Class<T> proxyClass = resolveAlreadyDefinedProxyClass(targetClass);
        String proxyName = targetClass.getName()  suffix;
    private static final String REQUEST_URL_REPLACE_PATTERN = "$$requestUrl$$";
            windowHandlerHtml = windowHandlerHtml.replace(WINDOW_ID_REPLACE_PATTERN,
                    windowId);
            // set the current request url
            // on the client we can't use window.location as the location
            // could be a different when using forwards
            windowHandlerHtml = windowHandlerHtml.replace(REQUEST_URL_REPLACE_PATTERN,
                    ClientWindowHelper.constructRequestUrl(externalContext));
    public static String constructRequestUrl(ExternalContext externalContext)
    {
        String url = externalContext.getRequestContextPath()
                 externalContext.getRequestServletPath();
        if (externalContext.getRequestPathInfo() != null)
        {
            url = externalContext.getRequestPathInfo();
        }
        
        url = JsfUtils.addRequestParameters(externalContext, url, true);
        //TODO check if it isn't better to fix addRequestParameters itself
        //only #encodeResourceURL is portable currently
        url = externalContext.encodeResourceURL(url);
        
        return url;
    }
    
        String url = constructRequestUrl(externalContext);
import org.apache.deltaspike.core.util.StringUtils;
                    if (StringUtils.isEmpty(entry.getKey()) && StringUtils.isEmpty(value))
                    {
                        continue;
                    }

import org.apache.deltaspike.data.api.AbstractFullEntityRepository;
        Class<X> javaClass = annotated.getJavaClass();
        return javaClass.equals(AbstractEntityRepository.class) ||
               javaClass.equals(AbstractFullEntityRepository.class);
import java.io.Serializable;

public class EmbeddedSimple implements Serializable
    private static final long serialVersionUID = 1L;
    private static final long serialVersionUID = 1L;
    
import java.io.Serializable;

public class SuperSimple implements Serializable
    private static final long serialVersionUID = 1L;

public interface JtaTransactionalRepositoryInterface extends EntityRepository<Simple, Long>
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * or more contributor license agreements. See the NOTICE file
 * regarding copyright ownership. The ASF licenses this file
 * with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * KIND, either express or implied. See the License for the
 * or more contributor license agreements. See the NOTICE file
 * regarding copyright ownership. The ASF licenses this file
 * with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * KIND, either express or implied. See the License for the
 * or more contributor license agreements. See the NOTICE file
 * regarding copyright ownership. The ASF licenses this file
 * with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * KIND, either express or implied. See the License for the
 * or more contributor license agreements. See the NOTICE file
 * regarding copyright ownership. The ASF licenses this file
 * with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * KIND, either express or implied. See the License for the
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 * Handles concrete mapping of query results and
    @SuppressWarnings("unchecked")
    @SuppressWarnings("unchecked")
                private static final long serialVersionUID = 1L;

                    @SuppressWarnings("unchecked")
            if (getClass() != o.getClass())
            @SuppressWarnings("unchecked")

    @SuppressWarnings("unchecked")
    @SuppressWarnings("unchecked")
    @SuppressWarnings("unchecked")
    private final Class<? extends QueryInOutMapper<?>> mapper;
            final DependentProvider<? extends QueryInOutMapper<?>> mappedProvider = BeanProvider.getDependent(mapper);
    private Class<? extends QueryInOutMapper<?>> extractMapper(Method queryMethod, RepositoryComponent repoComponent)
        EntityBuilder<EntityDescriptor> entityDescriptorBuilder = new EntityBuilder<EntityDescriptor>()
        };
        
        MappedSuperClassBuilder<MappedSuperclassDescriptor> superClassBuilder = 
            new MappedSuperClassBuilder<MappedSuperclassDescriptor>()
                @Override
                protected MappedSuperclassDescriptor instance(String name, String packageName, String className,
                                                    String idClass, String id, String version)
                {
                    return new MappedSuperclassDescriptor(name, packageName, className, idClass, id, version);
                }
                @Override
                protected String tagName()
                {
                    return "mapped-superclass";
                }
            };
        return new MappingFile(entityDescriptorBuilder.build(doc), superClassBuilder.build(doc));
    private abstract class MappedSuperClassBuilder<T extends PersistentClassDescriptor> extends PersistenceBuilder<T>
    private abstract class EntityBuilder<T extends PersistentClassDescriptor> extends PersistenceBuilder<T>
    private static final long serialVersionUID = 1L;

                method = identifier.getClass().getMethod(methodName);
                return method.invoke(identifier);
public interface EntityRepository<E, PK extends Serializable>
{
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.Query;
import javax.persistence.QueryHint;

import org.apache.deltaspike.data.api.EntityGraph;
import org.apache.deltaspike.data.impl.graph.EntityGraphHelper;
        applyEntityGraph(query, method);
    
    private void applyEntityGraph(Query query, Method method)
    {
        EntityGraph entityGraphAnn = method.getAnnotation(EntityGraph.class);
        if (entityGraphAnn == null)
        {
            return;
        }
        
        String graphName = entityGraphAnn.value();
        Object graph = EntityGraphHelper.getEntityGraph(getEntityManager(), graphName);
        query.setHint(entityGraphAnn.type().getHintName(), graph);
    }

    
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
    private static final Class<?> SUBGRAPH_CLASS;
    private static final Method ADD_ATTRIBUTE_NODES;
    private static final Method ADD_SUBGRAPH;
    private static final Method SUBGRAPH_ADD_ATTRIBUTE_NODES;
        SUBGRAPH_CLASS = ClassUtils.tryToLoadClassForName("javax.persistence.Subgraph");
        if (ENTITY_GRAPH_CLASS == null)
        {
            ADD_ATTRIBUTE_NODES = null;
            ADD_SUBGRAPH = null;
            SUBGRAPH_ADD_ATTRIBUTE_NODES = null;
        }
        else
        {
            try
            {
                ADD_ATTRIBUTE_NODES = ENTITY_GRAPH_CLASS.getMethod("addAttributeNodes",
                    String[].class);
                ADD_SUBGRAPH = ENTITY_GRAPH_CLASS.getMethod("addSubgraph", String.class);
                SUBGRAPH_ADD_ATTRIBUTE_NODES = SUBGRAPH_CLASS.getMethod("addAttributeNodes",
                    String[].class);
            }
            catch (NoSuchMethodException e)
            {
                throw new EntityGraphException(e.getMessage(), e.getCause());
            }
            catch (SecurityException e)
            {
                throw new EntityGraphException(e.getMessage(), e.getCause());
            }
        }

    public static Object createEntityGraph(EntityManager em, Class<?> entityClass)
    {
        ensureAvailable();
        try
        {
            Method method = EntityManager.class.getMethod("createEntityGraph", Class.class);
            return method.invoke(em, entityClass);
        }
        catch (NoSuchMethodException e)
        {
            throw new EntityGraphException("no method EntityManager.createEntityGraph()", e);
        }
        catch (SecurityException e)
        {
            throw new EntityGraphException("no access to method EntityManager.createEntityGraph()",
                e);
        }
        catch (IllegalAccessException e)
        {
            throw new EntityGraphException("no access to method EntityManager.createEntityGraph()",
                e);
        }
        catch (InvocationTargetException e)
        {
            throw new EntityGraphException(e.getCause().getMessage(), e.getCause());
        }
    }

            throw new EntityGraphException("Class java.persistence.EntityGraph is not available. "

    public static Object addSubgraph(Object entityGraph, String attributeName)
    {
        try
        {
            return ADD_SUBGRAPH.invoke(entityGraph, attributeName);
        }
        catch (IllegalAccessException e)
        {
            throw new EntityGraphException("no access to method EntityGraph.addSubgraph()", e);
        }
        catch (InvocationTargetException e)
        {
            throw new EntityGraphException(e.getCause().getMessage(), e.getCause());
        }
    }

    public static void addAttributeNodes(Object graph, String attributeName)
    {
        try
        {
            if (ENTITY_GRAPH_CLASS.isInstance(graph))
            {
                ADD_ATTRIBUTE_NODES.invoke(graph, new Object[] { new String[] { attributeName } });
            }
            else if (SUBGRAPH_CLASS.isInstance(graph))
            {
                SUBGRAPH_ADD_ATTRIBUTE_NODES.invoke(graph,
                    new Object[] { new String[] { attributeName } });
            }
        }
        catch (IllegalAccessException e)
        {
            throw new EntityGraphException("no access to method addAttributeNodes()", e);
        }
        catch (InvocationTargetException e)
        {
            throw new EntityGraphException(e.getCause().getMessage(), e.getCause());
        }
    }

    public static Object buildEntityGraph(EntityManager em, Class<?> entityClass,
        String[] attributePaths)
    {
        Object graph = createEntityGraph(em, entityClass);
        List<String> paths = new ArrayList<String>(Arrays.asList(attributePaths));

        Collections.sort(paths);
        Collections.reverse(paths);

        for (String path : attributePaths)
        {
            if (path.contains("."))
            {
                String[] segments = path.split("\\.");
                Object parent = addSubgraph(graph, segments[0]);

                for (int i = 1; i < segments.length - 1; i)
                {
                    addSubgraph(parent, segments[i]);
                }

                addAttributeNodes(parent, segments[segments.length - 1]);
            }
            else
            {
                addAttributeNodes(graph, path);
            }
        }
        return graph;
    }
        Object graph;
        if (graphName.isEmpty())
        {
            graph = EntityGraphHelper.buildEntityGraph(getEntityManager(), entityClass, entityGraphAnn.paths());
        }
        else
        {
            graph = EntityGraphHelper.getEntityGraph(getEntityManager(), graphName);
        }
import java.util.ArrayList;
import java.util.List;
import javax.persistence.CascadeType;
import javax.persistence.OneToMany;
import javax.persistence.OrderColumn;
    
    @OneToMany(mappedBy = "flat", cascade = CascadeType.ALL)
    @OrderColumn
    private List<Tenant> tenants = new ArrayList<Tenant>();

    
    public List<Tenant> getTenants()
    {
        return tenants;
    }

    
    public void setTenants(List<Tenant> tenants)
    {
        this.tenants = tenants;
    }
import javax.persistence.OrderColumn;
    @OrderColumn
    @OrderColumn
    @Query("select h from House h where h.name = ?1")
    @EntityGraph(paths = {"flats", "garages"})
    House fetchByNameWithDynamicGraph(String name);

    @Query("select h from House h where h.name = ?1")
    @EntityGraph(paths = {"flats.tenants", "garages"})
    House fetchByNameWithFlatTenants(String name);

/**
 * Defines an entity graph to be applied to a query. This annotation can be added to any query
 * method of a repository class.
 * <p>
 * The arguments {@code value} and {@code paths} are mutually exclusive. If {@value is set}, it
 * references a named entity graph defined by JPA metadata.
 * <p>
 * If {@code paths} is set, an entity graph is constructed programmatically from the list of
 * attribute paths.
 * 
 */
    /**
     * Name of a named entity graph.
     * @return graph name
     */

    /**
     * Type of entity graph (fetch or load).
     * @return graph type
     */

    /**
     * List of attribute paths. Each path may have multiple components, separated
     * by dots. A single component path adds an attribute node to the entity graph.
     * A path {@code foo.bar.baz} adds an attribute node {@code baz} to a subgraph
     * {@code bar} for the subgraph {@code foo}.
     * 
     * @return list of paths
     */
/**
 * Entity graph type (fetch graph or load graph). The type determines
 * the query hint name used to pass the entity graph to a query.
 */
    /** Fetch graph. */

    /** Load graph. */
    /**
     * Gets the query hint name corresponding to this type.
     * @return hint name
     */
import org.apache.deltaspike.data.api.criteria.CriteriaSupport;
 * Full repository base class to be extended by concrete implementations. A convenience class
 * combining {@code AbstractEntityRepository}, {@code EntityManagerDelegate} and
 * {@code CriteriaSupport}.
 * 
 * @param <E>
 *            Entity type.
 * @param <PK>
 *            Primary key type.
public abstract class AbstractFullEntityRepository<E, PK extends Serializable> extends
    AbstractEntityRepository<E, PK> implements EntityManagerDelegate<E>, CriteriaSupport<E>
import org.apache.deltaspike.data.api.criteria.CriteriaSupport;

 * Full repository interface. A convenience class combining {@code EntityRepository},
 * {@code EntityManagerDelegate} and {@code CriteriaSupport}.
    extends EntityRepository<E, PK>, EntityManagerDelegate<E>, CriteriaSupport<E>
import org.apache.deltaspike.data.test.domain.Simple_;

    public Simple fetchByName(String name)
    {
        return criteria().eq(Simple_.name, name).getOptionalResult();
    }
 * The arguments {@code value} and {@code paths} are mutually exclusive. If {@code value} is set, it
import org.apache.deltaspike.core.util.ExceptionUtils;
import org.apache.deltaspike.data.api.EntityGraph;
/**
 * Helper for invoking methods related to entity graphs by reflection.
 * <p>
 * Reflection is required to stay compatible with JPA 2.0.
 */
    private static final Method EG_ADD_ATTRIBUTE_NODES;
    private static final Method EG_ADD_SUBGRAPH;
    private static final Method SUBGRAPH_ADD_SUBGRAPH;
    private static final Method EM_GET_ENTITY_GRAPH;
    private static final Method EM_CREATE_ENTITY_GRAPH;
            EG_ADD_ATTRIBUTE_NODES = null;
            EG_ADD_SUBGRAPH = null;
            SUBGRAPH_ADD_SUBGRAPH = null;
            EM_GET_ENTITY_GRAPH = null;
            EM_CREATE_ENTITY_GRAPH = null;
                EG_ADD_ATTRIBUTE_NODES = ENTITY_GRAPH_CLASS.getMethod("addAttributeNodes",
                EG_ADD_SUBGRAPH = ENTITY_GRAPH_CLASS.getMethod("addSubgraph", String.class);
                SUBGRAPH_ADD_SUBGRAPH = SUBGRAPH_CLASS.getMethod("addSubgraph", String.class);
                EM_GET_ENTITY_GRAPH = EntityManager.class.getMethod("getEntityGraph", String.class);
                EM_CREATE_ENTITY_GRAPH = EntityManager.class.getMethod("createEntityGraph",
                    Class.class);
                throw ExceptionUtils.throwAsRuntimeException(e);
    /*
     * TODO Check if this can be replaced by org.apache.deltaspike.core.util.ReflectionUtils.invokeMethod.
     * This does not work at the moment due to an issue with exception handling in that method
     * which needs further analysis. 
     */
    private static Object uncheckedInvoke(Method method, Object target, Object... args)
            return method.invoke(target, args);
            throw ExceptionUtils.throwAsRuntimeException(e);
            throw ExceptionUtils.throwAsRuntimeException(e.getCause());
    public static Object getEntityGraph(EntityManager em, Class<?> entityClass, EntityGraph entityGraphAnn)
        String graphName = entityGraphAnn.value();
        if (graphName.isEmpty())
            return buildEntityGraph(em, entityClass, entityGraphAnn.paths());
        else
            return uncheckedInvoke(EM_GET_ENTITY_GRAPH, em, graphName);
    }

    private static Object createEntityGraph(EntityManager em, Class<?> entityClass)
    {
        return uncheckedInvoke(EM_CREATE_ENTITY_GRAPH, em, entityClass);
    private static Object addSubgraph(Object graph, String attributeName)
        if (ENTITY_GRAPH_CLASS.isInstance(graph))
            return uncheckedInvoke(EG_ADD_SUBGRAPH, graph, attributeName);
        else if (SUBGRAPH_CLASS.isInstance(graph))
            return uncheckedInvoke(SUBGRAPH_ADD_SUBGRAPH, graph, attributeName);
        return null;
    }

    private static void addAttributeNodes(Object graph, String attributeName)
    {
        if (ENTITY_GRAPH_CLASS.isInstance(graph))
            uncheckedInvoke(EG_ADD_ATTRIBUTE_NODES, graph,
                new Object[] { new String[] { attributeName } });
        }
        else if (SUBGRAPH_CLASS.isInstance(graph))
        {
            uncheckedInvoke(SUBGRAPH_ADD_ATTRIBUTE_NODES, graph,
                new Object[] { new String[] { attributeName } });
    private static Object buildEntityGraph(EntityManager em, Class<?> entityClass,
        // handle longest paths first
        Object graph = EntityGraphHelper.getEntityGraph(getEntityManager(), entityClass, entityGraphAnn);
 b/deltaspike/modules/scheduler/impl/src/main/java/org/apache/deltaspike/scheduler/impl/AbstractQuartzScheduler.java
public abstract class AbstractQuartzScheduler<T> implements Scheduler<T>
    private static final Logger LOG = Logger.getLogger(AbstractQuartzScheduler.class.getName());
    public void registerNewJob(Class<? extends T> jobClass)
                Class<? extends Job> jobClassToAdd = createFinalJobClass(jobClass);
                jobDetail = JobBuilder.newJob(jobClassToAdd)
                Logger.getLogger(AbstractQuartzScheduler.class.getName()).info(
                    jobKey  " exists already and will be ignored.");
    protected abstract Class<? extends Job> createFinalJobClass(Class<? extends T> jobClass);

    public void startJobManually(Class<? extends T> jobClass)
    public void interruptJob(Class<? extends T> jobClass)
    public boolean deleteJob(Class<? extends T> jobClass)
    public void pauseJob(Class<? extends T> jobClass)
    public void resumeJob(Class<? extends T> jobClass)
    public boolean isExecutingJob(Class<? extends T> jobClass)
    private JobKey createJobKey(Class<?> jobClass)
        String jobName = getJobName(jobClass);
    protected String getJobName(Class<?> jobClass)
    {
        return jobClass.getSimpleName();
    }

    private static class JobListenerContext
            //in case of implementing the Scheduler interface directly

            //in case of extending e.g. AbstractQuartzScheduler
            if (scheduler.getClass().getGenericSuperclass() instanceof ParameterizedType)
            {
                ParameterizedType parameterizedType = (ParameterizedType) scheduler.getClass().getGenericSuperclass();
                for (Type typeArgument : parameterizedType.getActualTypeArguments())
                {
                    if (jobClass.isAssignableFrom((Class)typeArgument))
                    {
                        return scheduler;
                    }
                }
            }
        return !"QuartzScheduler".equals(targetClass.getSimpleName()) &&
                !"RunnableQuartzScheduler".equals(targetClass.getSimpleName());
import org.apache.deltaspike.core.util.ClassUtils;
    private Class<? extends Job> runnableAdapter;

    @Override
    public void start()
    {
        String configuredAdapterClassName = SchedulerBaseConfig.JobCustomization.RUNNABLE_ADAPTER_CLASS_NAME;
        this.runnableAdapter = ClassUtils.tryToLoadClassForName(configuredAdapterClassName, Job.class);

        super.start();
    }

        return runnableAdapter;
        String RUNNABLE_ADAPTER_CLASS_NAME_KEY = "deltaspike.scheduler.runnable-adapter-class";

        //don't type it to class to keep quartz optional (JobRunnableAdapter imports classes from quartz)
        String RUNNABLE_ADAPTER_CLASS_NAME = ConfigResolver.resolve(RUNNABLE_ADAPTER_CLASS_NAME_KEY)
                .withCurrentProjectStage(true)
                .withDefault("org.apache.deltaspike.scheduler.impl.JobRunnableAdapter")
                .getValue();
    private final OrderBy<C> orderByProcessor = new OrderBy<C>();
            CriteriaQuery<R> query = createCriteriaQuery(builder);
    private <P> void addOrderBy(SingularAttribute<? super C, P> att, OrderDirection orderDirection)
    @SuppressWarnings("unchecked")
    private CriteriaQuery<R> createCriteriaQuery(CriteriaBuilder builder)
            return (CriteriaQuery<R>) builder.createQuery();
public class OrderBy<P> implements QueryProcessor<P>
    private final List<OrderByDefinition<?>> orderByDefinitions = new ArrayList<OrderByDefinition<?>>();
    public <V> void add(SingularAttribute<? super P, V> att, OrderDirection dir)
        orderByDefinitions.add(new OrderByDefinition<V>(att, dir));
        Iterator<OrderByDefinition<?>> iterator = orderByDefinitions.iterator();
            OrderByDefinition<?> orderByDefinition = iterator.next();
    private class OrderByDefinition<V>
            OrderByDefinition<V> that = (OrderByDefinition<V>) o;
        return builder.createQuery(resultClass);
                LOG.info(processAnnotatedType.getAnnotatedType().getJavaClass().getName() 
                    " is configured as global-alternative");

import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
//configured via SchedulerBaseConfig
    @Inject
    private BeanManager beanManager;


        try
        {
            runnableBean.run();
        }
        catch (Throwable t)
        {
            //just in this case to reduce the implementation(s) of runnable (annotated with @Scheduled)
            //to an absolute minimum.
            //(custom implementations of org.quartz.Job need to do it on their own)
            this.beanManager.fireEvent(new ExceptionToCatchEvent(t));
        }
        if (!jobClass.isAssignableFrom(beanClass) && !Runnable.class.isAssignableFrom(beanClass))
        Class configuredJobClass = this.jobClass;

        this.jobClass = resolveFinalJobType();

        if (this.jobClass == null)
        {
            afterBeanDiscovery.addDefinitionError(new IllegalStateException("Please only annotate classes with @" 
                Scheduled.class.getName()  " of type " 
                configuredJobClass.getName()  " or of type "  Runnable.class.getName()  ", but not both!"));
            return;
        }

    /**
     * Allows to support implementations of {@link java.lang.Runnable}
     * annotated with {@link Scheduled} >without< explicit config.
     * @return the job-type which will be used to select the scheduler
     */
    protected Class resolveFinalJobType()
    {
        Set<Class> foundTypes = new HashSet<Class>();

        for (Class foundJobClass : this.foundManagedJobClasses)
        {
            if (jobClass.isAssignableFrom(foundJobClass))
            {
                foundTypes.add(jobClass);
            }
            else if (Runnable.class.isAssignableFrom(foundJobClass))
            {
                foundTypes.add(Runnable.class);
            }
        }

        if (foundTypes.size() > 1)
        {
            return null;
        }
        else if (foundTypes.size() == 1)
        {
            return foundTypes.iterator().next();
        }
        else
        {
            //use the configured type
            //it's still useful if there is no annotated job-class, but a dyn. usage of the scheduler is still possible
            return jobClass;
        }
    }

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
        final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        if (delegateMethods != null)
            for (java.lang.reflect.Method method : delegateMethods)
            {
                defineMethod(cw, method, DelegateManualInvocationHandler.class);
            }
        if (interceptMethods != null)
            for (java.lang.reflect.Method method : interceptMethods)
            {
                defineSuperAccessorMethod(cw, method, superType, superAccessorMethodSuffix);
                defineMethod(cw, method, InterceptManualInvocationHandler.class);
            }
        }

        // copy all annotations from the source class
        try
        {
            // ClassVisitor to intercept all annotation visits on the class
            ClassVisitor cv = new ClassVisitor(Opcodes.ASM5)
            {
                @Override
                public AnnotationVisitor visitAnnotation(String desc, boolean visible)
                {
                    return new CopyAnnotationVisitorAdapter(
                            super.visitAnnotation(desc, visible),
                            cw.visitAnnotation(desc, visible));
                }
            };

            // visit class to proxy with our visitor to copy all annotations from the source class to our ClassWriter
            String sourceClassFilename = targetClass.getName().replace('.', '/')  ".class";
            ClassReader cr = new ClassReader(targetClass.getClassLoader().getResourceAsStream(sourceClassFilename));
            cr.accept(cv, 0);
        }
        catch (Exception e)
        {
            throw new RuntimeException(e);
    
import org.apache.deltaspike.jpa.spi.entitymanager.ActiveEntityManagerHolder;
    @Inject
    private ActiveEntityManagerHolder activeEntityManagerHolder;

            if (activeEntityManagerHolder.isSet())
            {
                return activeEntityManagerHolder.get();
            }

import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.util.interceptor.AbstractInvocationContext;
import org.apache.deltaspike.core.util.metadata.AnnotationInstanceProvider;
import org.apache.deltaspike.jpa.spi.entitymanager.ActiveEntityManagerHolder;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceException;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

    @Inject
    private ActiveEntityManagerHolder activeEntityManagerHolder;

            if (transactionalAnnotation.qualifier().length > 1)
            {
                throw new IllegalStateException(proxy.getClass().getName()  " uses @"  Transactional.class.getName() 
                    " with multiple qualifiers. That isn't supported with @"  Repository.class.getName());
            }

            Class<? extends Annotation> qualifier = transactionalAnnotation.qualifier()[0];
            if (!Any.class.equals(qualifier))
            {
                EntityManager entityManager = BeanProvider.getContextualReference(
                    EntityManager.class, false, AnnotationInstanceProvider.of(qualifier));
                activeEntityManagerHolder.set(entityManager);
            }

import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
public class QueryBuilderFactory
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
public class RepositoryComponents
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
    private EntityManagerRefLookup entityManagerRefLookup;
        EntityManagerRef entityManagerRef = null;

            entityManagerRef = entityManagerRefLookup.lookupReference(repo);
            queryContext = createContext(proxy, method, args, entityManagerRef.getEntityManager(), repoMethod);
            
            if (entityManagerRef != null && entityManagerRef.getEntityManagerResolverDependentProvider() != null)
            {
                entityManagerRef.getEntityManagerResolverDependentProvider().destroy();
            }
            Object[] args, EntityManager entityManager, RepositoryMethod repoMethod)
                entityManager);
    public void release()
    {
        if (entityManagerResolverDependentProvider != null)
        {
            entityManagerResolverDependentProvider.destroy();
        }
    }

            if (entityManagerRef != null)
                entityManagerRef.release();

    public static boolean isEmpty(Object[] array)
    {
        return array == null || array.length == 0;
    }

    public static boolean isNotEmpty(String text)
    {
        return !isEmpty(text);
    }
import static org.apache.deltaspike.core.util.StringUtils.isNotEmpty;
import static org.apache.deltaspike.core.util.StringUtils.isNotEmpty;
import static org.apache.deltaspike.core.util.StringUtils.isNotEmpty;
import static org.apache.deltaspike.core.util.ArraysUtils.isEmpty;
import static org.apache.deltaspike.core.util.StringUtils.isNotEmpty;
import static org.apache.deltaspike.core.util.StringUtils.isEmpty;
import org.apache.deltaspike.core.util.StringUtils;
        if (StringUtils.isEmpty(id) && getParent() != null)
import org.apache.deltaspike.core.util.StringUtils;
        if (StringUtils.isEmpty(value))
 * <p>DeltaSpike allows you to deactivate pre-configured parts (like Extensions, event-broadcasters,...).
 * Therefore DeltaSpike offers {@link ClassDeactivator} and {@link Deactivatable}.</p>
 *
 * <p>A {@link ClassDeactivator} allows to specify deactivated classes (if they implement {@link Deactivatable})
 * which can't be deactivated/customized via std. CDI mechanisms
 * (like the veto-method or alternative/specialized CDI-beans).
 * This might be the case e.g. for CDI Extensions because CDI mechanisms are not available at startup time.</p>
 *
 * <p>Use it mainly to deactivate specific parts explicitly (blacklist approach),
 * if there is an issue with such parts (and waiting for the next release isn't an option).</p>
            // ignore forwards - Tomcat calls #requestInitialized two times with form authentication
            if (instance instanceof ServletRequest)
            {
                ServletRequest servletRequest = (ServletRequest) instance;
                if (servletRequest.getAttribute("javax.servlet.forward.request_uri") != null)
                {
                    return;
                }
            }

import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import java.util.Arrays;
import java.util.UUID;
                scheduleNewJob(scheduled, jobKey, jobDetail);
                    scheduleNewJob(scheduled, jobKey, jobDetail);
                if (scheduled.cronExpression().startsWith("{") && scheduled.cronExpression().endsWith("}"))
                {
                    this.scheduler.unscheduleJobs(Arrays.asList(trigger.getKey()));
                    scheduleNewJob(scheduled, jobKey, jobDetail);
                }
                else
                {
                    trigger = TriggerBuilder.newTrigger()
                            .withIdentity(trigger.getKey())
                            .withSchedule(CronScheduleBuilder.cronSchedule(scheduled.cronExpression()))
                            .build();

                    this.scheduler.rescheduleJob(trigger.getKey(), trigger);
                }
    private void scheduleNewJob(Scheduled scheduled, JobKey jobKey, JobDetail jobDetail) throws SchedulerException
    {
        String cronExpression = evaluateExpression(scheduled);
        this.scheduler.scheduleJob(jobDetail, createTrigger(scheduled, jobKey, cronExpression));
    }

    private Trigger createTrigger(Scheduled scheduled, JobKey jobKey, String cronExpression) throws SchedulerException
    {
        UUID triggerKey = UUID.randomUUID();

        if (!scheduled.cronExpression().endsWith(cronExpression))
        {
            createExpressionObserverJob(jobKey, triggerKey, scheduled.cronExpression(), cronExpression);
        }

        Trigger trigger = TriggerBuilder.newTrigger()
                .forJob(jobKey)
                .withIdentity(triggerKey.toString())
                .withSchedule(CronScheduleBuilder.cronSchedule(cronExpression))
                .build();
        return trigger;
    }

    private void createExpressionObserverJob(
        JobKey jobKey, UUID triggerKey, String configExpression, String cronExpression) throws SchedulerException
    {
        if (!ClassDeactivationUtils.isActivated(DynamicExpressionObserverJob.class))
        {
            return;
        }

        JobKey observerJobKey =
                new JobKey(jobKey.getName()  DynamicExpressionObserverJob.OBSERVER_POSTFIX, jobKey.getGroup());

        JobDetail jobDetail  = JobBuilder.newJob(DynamicExpressionObserverJob.class)
                .usingJobData(DynamicExpressionObserverJob.CONFIG_EXPRESSION_KEY, configExpression)
                .usingJobData(DynamicExpressionObserverJob.TRIGGER_ID_KEY, triggerKey.toString())
                .usingJobData(DynamicExpressionObserverJob.ACTIVE_CRON_EXPRESSION_KEY, cronExpression)
                .withDescription("Config observer for: "  jobKey)
                .withIdentity(observerJobKey)
                .build();

        Trigger trigger = TriggerBuilder.newTrigger()
                .forJob(observerJobKey)
                .withSchedule(CronScheduleBuilder.cronSchedule(
                    SchedulerBaseConfig.JobCustomization.DYNAMIC_EXPRESSION_OBSERVER_INTERVAL))
                .build();

        this.scheduler.scheduleJob(jobDetail, trigger);
    }

    private String evaluateExpression(Scheduled scheduled)
    {
        String expression = scheduled.cronExpression();

        if (expression.startsWith("{") && expression.endsWith("}"))
        {
            String configKey = expression.substring(1, expression.length() - 1);
            expression = ConfigResolver.getProjectStageAwarePropertyValue(configKey, null);

            if (expression == null)
            {
                throw new IllegalStateException("No config-value found for config-key: "  configKey);
            }
        }
        return expression;
    }

        String DYNAMIC_EXPRESSION_OBSERVER_INTERVAL_KEY =
            "deltaspike.scheduler.dynamic-expression.observer-interval";

        String DYNAMIC_EXPRESSION_OBSERVER_INTERVAL =
                ConfigResolver.resolve(DYNAMIC_EXPRESSION_OBSERVER_INTERVAL_KEY)
                .withCurrentProjectStage(true)
                .withDefault("0 0/1 * * * ?")
                .getValue();
    //keep it as a string (needed by some containers - due to the imports)
    private static Set<String> classNamesToVeto = new HashSet<String>();

    public SchedulerExtension()
    {
        classNamesToVeto.add("org.apache.deltaspike.scheduler.impl.DynamicExpressionObserverJob");
    }

        if (Scheduler.class.isAssignableFrom(beanClass) || isInternalUnmanagedClass(beanClass))
    private <X> boolean isInternalUnmanagedClass(Class<X> beanClass)
    {
        return classNamesToVeto.contains(beanClass.getName());
    }

                LOGGER.log(Level.SEVERE, actionName  " can't be invoked", e);
 *
 * We also allow to write underlines _ instead of dots _ in the
 * environment via export (unix) or SET (windows)

    @Override
    public String getPropertyValue(String key)
    {
        String val = super.getPropertyValue(key);
        if (val == null || val.isEmpty())
        {
            val = super.getPropertyValue(key.replace('.', '_'));
        }

        return val;
    }

    @Override
    public boolean isScannable()
    {
        return false;
    }
            Property<Serializable> versionProperty =
                    repoMethod.getRepository().getRepositoryEntity().getVersionProperty();
            Property<Serializable> primaryKeyProperty =
                    repoMethod.getRepository().getRepositoryEntity().getPrimaryKeyProperty();
            if (EntityUtils.primaryKeyValue(entity, primaryKeyProperty) == null)
            if (!entityManager.contains(entity) && countCheck(entity, primaryKeyProperty))

    private boolean countCheck(Object entity, Property<Serializable> primaryKeyProperty)
        jpql.append(primaryKeyProperty.getName());
        query.setParameter("id", EntityUtils.primaryKeyValue(entity, primaryKeyProperty));
        return EntityUtils.tableName(context.getEntityClass(), entityManager());
        return context.getRepositoryMethod().getRepository().getRepositoryEntity().getEntityName();
    private final RepositoryEntity repositoryEntity;
    public RepositoryComponent(Class<?> repoClass, RepositoryEntity repositoryEntity)
        if (repositoryEntity == null)
            throw new IllegalArgumentException("repositoryEntity cannot be null");
        this.repositoryEntity = repositoryEntity;
        return repositoryEntity.getEntityName();
        return repositoryEntity.getEntityClass();
        return repositoryEntity.getPrimaryKeyClass();
    
    public RepositoryEntity getRepositoryEntity()
    {
        return repositoryEntity;
    }
    
import org.apache.deltaspike.data.impl.property.Property;
import org.apache.deltaspike.data.impl.util.EntityUtils;
 * Data structure to store information about an entity.
    private Class<? extends Serializable> primaryKeyClass;
    private Property<Serializable> primaryKeyProperty;
    private Property<Serializable> versionProperty;
    private String entityName;
        this.primaryKeyClass = primaryClass;
        
        this.primaryKeyProperty = EntityUtils.primaryKeyProperty(entityClass);
        this.versionProperty = EntityUtils.getVersionProperty(entityClass);
        this.entityName = EntityUtils.entityName(entityClass);
    public Class<? extends Serializable> getPrimaryKeyClass()
        return primaryKeyClass;
    public void setPrimaryKeyClass(Class<? extends Serializable> primaryKeyClass)
        this.primaryKeyClass = primaryKeyClass;
    public Property<Serializable> getVersionProperty()
    {
        return versionProperty;
    }

    public void setVersionProperty(Property<Serializable> versionProperty)
    {
        this.versionProperty = versionProperty;
    }

    public String getEntityName()
    {
        return entityName;
    }

    public void setEntityName(String entityName)
    {
        this.entityName = entityName;
    }

    public Property<Serializable> getPrimaryKeyProperty()
    {
        return primaryKeyProperty;
    }

    public void setPrimaryKeyProperty(Property<Serializable> primaryKeyProperty)
    {
        this.primaryKeyProperty = primaryKeyProperty;
    }
                result.setPrimaryKeyClass((Class<? extends Serializable>) genericType);
import javax.persistence.EntityManager;
import javax.persistence.Table;
import javax.persistence.metamodel.EntityType;
import org.apache.deltaspike.core.util.StringUtils;
        Property<Serializable> property = primaryKeyProperty(entityClass);
        Property<Serializable> property = primaryKeyProperty(entity.getClass());
        return primaryKeyValue(entity, property);
    public static Object primaryKeyValue(Object entity, Property<Serializable> primaryKeyProperty)
    {
        return primaryKeyProperty.getValue(entity);
    }
    
    public static String tableName(Class<?> entityClass, EntityManager entityManager)
    {
        String tableName = PersistenceUnits.instance().entityTableName(entityClass);
        if (StringUtils.isEmpty(tableName))
        {
            EntityType<?> entityType = entityManager.getMetamodel().entity(entityClass);
            Table tableAnnotation = entityClass.getAnnotation(Table.class);
            return tableAnnotation == null ? entityType.getName() : tableAnnotation.name();
        }
        return tableName;
    }
    
    public static Property<Serializable> primaryKeyProperty(Class<?> entityClass)
    public static Property<Serializable> getVersionProperty(Class<?> entityClass)
    @Override
import java.lang.reflect.Method;
    
    /**
     * Checks if the given class contains a method with the same signature.
     * 
     * @param targetClass The class to check
     * @param method The source method
     * @return if it contains a method with the same signature.
     */
    public static boolean containsMethod(Class<?> targetClass, Method method)
    {
        return extractMethod(targetClass, method) != null;
    }

    /**
     * Extracts a method with same signature as the source method.
     * 
     * @param clazz The target class
     * @param sourceMethod The source method.
     * @return the extracted method or <code>null</code>
     */
    public static Method extractMethod(Class<?> clazz, Method sourceMethod)
    {
        try
        {
            String name = sourceMethod.getName();
            return clazz != null ? clazz.getMethod(name, sourceMethod.getParameterTypes()) : null;
        }
        catch (NoSuchMethodException e)
        {
            return null;
        }
    }
import org.apache.deltaspike.core.util.ClassUtils;
            if (ClassUtils.containsMethod(bean.getBeanClass(), context.getMethod()))
        Method extract = ClassUtils.extractMethod(target.getClass(), method);
import org.apache.deltaspike.core.util.ClassUtils;
        if (ClassUtils.containsMethod(EntityRepositoryHandler.class, method))
            Method executed = ClassUtils.extractMethod(EntityRepositoryHandler.class, method);
        if (!Future.class.isAssignableFrom(returnType) &&
                (COMPLETION_STAGE == null || !COMPLETION_STAGE.isAssignableFrom(returnType)))
                    final Future<?> future = COMPLETION_STAGE == null || !COMPLETION_STAGE.isInstance(proceed) ?
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
 b/deltaspike/core/api/src/main/java/org/apache/deltaspike/core/util/AggregatedClassLoader.java
package org.apache.deltaspike.core.util;
        
        
import org.apache.deltaspike.jpa.spi.descriptor.xml.PersistenceUnitDescriptorProvider;
        PersistenceUnitDescriptorProvider.getInstance().init();
        
        
        
        // don't use a foreach here, we must be sure that the we first get the entity type
        for (int i = 0; i < genericTypes.length; i)
            Type genericType = genericTypes[i];
            
import org.apache.deltaspike.jpa.spi.descriptor.xml.PersistenceUnitDescriptorProvider;
        return entity.isAnnotationPresent(Entity.class)
                || PersistenceUnitDescriptorProvider.getInstance().isEntity(entity);
import org.apache.deltaspike.jpa.spi.descriptor.xml.PersistenceUnitDescriptorProvider;
        Class clazz = PersistenceUnitDescriptorProvider.getInstance().primaryKeyIdClass(entityClass);
            result = PersistenceUnitDescriptorProvider.getInstance().entityName(entityClass);
        String tableName = PersistenceUnitDescriptorProvider.getInstance().entityTableName(entityClass);
        for (PropertyCriteria c : primaryKeyPropertyCriteriaList(entityClass))
    private static List<PropertyCriteria> primaryKeyPropertyCriteriaList(Class<?> entityClass)
        String[] fromMappingFiles = PersistenceUnitDescriptorProvider.getInstance().primaryKeyFields(entityClass);
            for (String id : fromMappingFiles)
            {
                criteria.add(new NamedPropertyCriteria(id));
            }
        String fromMappingFiles = PersistenceUnitDescriptorProvider.getInstance().versionField(entityClass);
 b/deltaspike/modules/jpa/api/src/main/java/org/apache/deltaspike/jpa/spi/descriptor/xml/AbstractEntityHierarchyBuilder.java
package org.apache.deltaspike.jpa.spi.descriptor.xml;
public final class AbstractEntityHierarchyBuilder
    private AbstractEntityHierarchyBuilder()
    public static void buildHierarchy(List<EntityDescriptor> entities, List<MappedSuperclassDescriptor> superClasses)
            buildHierarchy(descriptor, entities, superClasses);
    protected static void buildHierarchy(AbstractEntityDescriptor descriptor,
            List<EntityDescriptor> entities, List<MappedSuperclassDescriptor> superClasses)
            AbstractEntityDescriptor superDescriptor =
                    findPersistentClassDescriptor(superClass, entities, superClasses);
                    buildHierarchy(superDescriptor, entities, superClasses);


    protected static AbstractEntityDescriptor findPersistentClassDescriptor(Class<?> superClass,
            List<EntityDescriptor> entities, List<MappedSuperclassDescriptor> superClasses)


 b/deltaspike/modules/jpa/api/src/main/java/org/apache/deltaspike/jpa/spi/descriptor/xml/Descriptor.java
package org.apache.deltaspike.jpa.spi.descriptor.xml;
public class Descriptor
 b/deltaspike/modules/jpa/api/src/main/java/org/apache/deltaspike/jpa/spi/descriptor/xml/DescriptorReader.java
package org.apache.deltaspike.jpa.spi.descriptor.xml;
import org.apache.deltaspike.core.util.AggregatedClassLoader;
    private static final Logger LOG = Logger.getLogger(DescriptorReader.class.getName());
    protected List<Descriptor> readAllFromClassPath(String resource) throws IOException
                LOG.log(Level.WARNING, "Could not load "  resource  " from "  u, e);
    protected Descriptor readFromClassPath(String resource) throws IOException
    protected Descriptor readFromUrl(URL url) throws IOException
    protected Descriptor read(String baseUrl, String resource) throws IOException
    protected String extractBaseUrl(URL fileUrl, String resource)
    protected ClassLoader classLoader()
 b/deltaspike/modules/jpa/api/src/main/java/org/apache/deltaspike/jpa/spi/descriptor/xml/PersistenceUnitDescriptorParser.java
package org.apache.deltaspike.jpa.spi.descriptor.xml;
import javax.enterprise.inject.Typed;
@Typed
public class PersistenceUnitDescriptorParser extends DescriptorReader
    public static final String RESOURCE_PATH = "META-INF/persistence.xml";
    private final EntityMappingsDescriptorParser entityMappingsDescriptorParser
        = new EntityMappingsDescriptorParser();
    
    public List<PersistenceUnitDescriptor> readAll() throws IOException
        List<PersistenceUnitDescriptor> result = new LinkedList<PersistenceUnitDescriptor>();
        List<Descriptor> persistenceXmls = readAllFromClassPath(RESOURCE_PATH);
    protected List<PersistenceUnitDescriptor> lookupUnits(Descriptor descriptor)
        List<PersistenceUnitDescriptor> result = new LinkedList<PersistenceUnitDescriptor>();

            String baseUrl = extractBaseUrl(descriptor.getUrl(), RESOURCE_PATH);

            result.add(new PersistenceUnitDescriptor(unitName, entities, properties));
    protected List<EntityDescriptor> extractMappings(Element element, String baseUrl, String unitName)
            readMappingFiles(baseUrl, unitName, entities, superClasses, list);
            EntityMappingsDescriptor mappings = entityMappingsDescriptorParser.readDefaultOrm(baseUrl);
            entities.addAll(mappings.getEntityDescriptors());
            superClasses.addAll(mappings.getMappedSuperclassDescriptors());
            AbstractEntityHierarchyBuilder.buildHierarchy(entities, superClasses);
    protected void readMappingFiles(String baseUrl, String unitName,
                EntityMappingsDescriptor mappings = entityMappingsDescriptorParser.readAll(baseUrl, resource);
                entities.addAll(mappings.getEntityDescriptors());
                superClasses.addAll(mappings.getMappedSuperclassDescriptors());
    protected String extractUnitName(Node node)
    protected Map<String, String> extractProperties(Element element)
 b/deltaspike/modules/jpa/impl/src/test/java/org/apache/deltaspike/test/jpa/spi/descriptor/xml/MappedId.java
package org.apache.deltaspike.test.jpa.spi.descriptor.xml;
public class MappedId
    private Long id;
    public Long getId()
        return id;
    public void setId(Long id)
        this.id = id;
 b/deltaspike/modules/jpa/impl/src/test/java/org/apache/deltaspike/test/jpa/spi/descriptor/xml/MappedOne.java
package org.apache.deltaspike.test.jpa.spi.descriptor.xml;
public class MappedOne
    private Long id;
    private String name;
    public MappedOne()
    public MappedOne(String name)
        this.name = name;
    public Long getId()
        return id;
    }

    public void setId(Long id)
    {
        this.id = id;
    }

    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
 b/deltaspike/modules/jpa/impl/src/test/java/org/apache/deltaspike/test/jpa/spi/descriptor/xml/MappedSuperclass.java
package org.apache.deltaspike.test.jpa.spi.descriptor.xml;
public class MappedSuperclass extends MappedId
    private Long counter;
    public Long getCounter()
        return counter;
    public void setCounter(Long id)
        this.counter = id;
 b/deltaspike/modules/jpa/impl/src/test/java/org/apache/deltaspike/test/jpa/spi/descriptor/xml/MappedThree.java
package org.apache.deltaspike.test.jpa.spi.descriptor.xml;
public class MappedThree extends MappedSuperclass
    private String name;
    public String getName()
        return name;
    public void setName(String name)
        this.name = name;
import javax.faces.application.ProjectStage;
    private final ProjectStage projectStage;
            Application wrapped, JsfModuleConfig jsfModuleConfig, boolean preDestroyViewMapEventFilterMode,
            ProjectStage projectStage)
        this.projectStage = projectStage;

    @Override
    public ProjectStage getProjectStage()
    {
        if (this.projectStage == null)
        {
            return getWrapped().getProjectStage();
        }
        return this.projectStage;
    }

import org.apache.deltaspike.core.api.projectstage.TestStage;
import org.apache.deltaspike.core.util.ProjectStageProducer;
import javax.faces.application.ProjectStage;
    private ProjectStage projectStage;
            org.apache.deltaspike.core.api.projectstage.ProjectStage dsProjectStage =
                ProjectStageProducer.getInstance().getProjectStage();

            for (ProjectStage ps : ProjectStage.values())
            {
                if (ps.name().equals(dsProjectStage.getClass().getSimpleName()))
                {
                    this.projectStage = ps;
                    break;
                }
            }

            if (this.projectStage == null && dsProjectStage instanceof TestStage)
            {
                this.projectStage = ProjectStage.Development;
            }

            if (this.projectStage == null)
            {
                this.projectStage = ProjectStage.Production;
            }

            wrappedApplication, this.jsfModuleConfig, this.preDestroyViewMapEventFilterMode, this.projectStage);
            if (this.projectStage == ProjectStage.Production)
                this.projectStage = null; //reset it to force the delegation to the default handling
import org.apache.deltaspike.proxy.spi.DummyInvocationHandler;
    
    public <T> Class<T> getProxyClass(BeanManager beanManager, Class<T> targetClass)
    {
        return getProxyClass(beanManager, targetClass, DummyInvocationHandler.class);
    }
            if (interceptMethods != null
 b/deltaspike/modules/proxy/api/src/main/java/org/apache/deltaspike/proxy/api/EnableInterceptors.java
public @interface EnableInterceptors
 b/deltaspike/modules/proxy/api/src/main/java/org/apache/deltaspike/proxy/spi/EnableInterceptorsDelegate.java
package org.apache.deltaspike.proxy.spi;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
public class EnableInterceptorsDelegate implements InvocationHandler, Serializable
    private final Object instance;
    
    public EnableInterceptorsDelegate(Object instance)
        this.instance = instance;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
    {
        return method.invoke(instance, args);
 b/deltaspike/modules/proxy/api/src/main/java/org/apache/deltaspike/proxy/spi/EnableInterceptorsInterceptor.java
import java.lang.reflect.Constructor;
import org.apache.deltaspike.proxy.api.EnableInterceptors;
@EnableInterceptors
public class EnableInterceptorsInterceptor implements Serializable
                     EnableInterceptors.class.getSimpleName()
        Class proxyClass = EnableInterceptorsProxyFactory.getInstance().getProxyClass(beanManager,
                beanCandidate.getClass(), EnableInterceptorsDelegate.class);
                
        Constructor constructor = proxyClass.getConstructor(EnableInterceptorsDelegate.class);
        return constructor.newInstance(new EnableInterceptorsDelegate(beanCandidate));
 b/deltaspike/modules/proxy/impl-asm5/src/test/java/org/apache/deltaspike/proxy/impl/enableinterceptors/MyBean.java
package org.apache.deltaspike.proxy.impl.enableinterceptors;
 b/deltaspike/modules/proxy/impl-asm5/src/test/java/org/apache/deltaspike/proxy/impl/enableinterceptors/MyBeanInterceptor.java
package org.apache.deltaspike.proxy.impl.enableinterceptors;
 b/deltaspike/modules/proxy/impl-asm5/src/test/java/org/apache/deltaspike/proxy/impl/enableinterceptors/MyBeanInterceptorBinding.java
package org.apache.deltaspike.proxy.impl.enableinterceptors;
 b/deltaspike/modules/proxy/impl-asm5/src/test/java/org/apache/deltaspike/proxy/impl/enableinterceptors/MyBeanProducer.java
package org.apache.deltaspike.proxy.impl.enableinterceptors;
import org.apache.deltaspike.proxy.api.EnableInterceptors;
    @EnableInterceptors
        MyBean myBean = new MyBean();
        return myBean;
/**
 * {@link InvocationHandler} to delegate every method call to an provided object instance.
 */
        Object producerResult = invocationContext.proceed();
        return EnableInterceptorsProxyFactory.wrap(producerResult, beanManager);
import java.lang.reflect.Constructor;
import javax.enterprise.inject.spi.BeanManager;
    public static <T> T wrap(T obj, BeanManager beanManager)
        if (obj == null)
            throw new IllegalArgumentException("obj must not be null!");
        // generate proxy
        Class proxyClass = EnableInterceptorsProxyFactory.getInstance().getProxyClass(beanManager,
                obj.getClass(), EnableInterceptorsDelegate.class);

        // delegate method calls to our original instance from the wrapped producer method
        EnableInterceptorsDelegate delegate = new EnableInterceptorsDelegate(obj);

        try
        {
            // instantiate proxy
            Constructor constructor = proxyClass.getConstructor(EnableInterceptorsDelegate.class);
            return (T) constructor.newInstance(delegate);
        }
        catch (Exception e)
        {
            throw new RuntimeException("Could not create proxy instance by class "  obj.getClass(), e);
        }
    protected ArrayList<Method> getDelegateMethods(Class<?> targetClass, ArrayList<Method> allMethods)
    {
        // the default #filterInterceptMethods filters all non-public, final and abstract methods
        // which means actually every publich proxyable method
        // as we need to delegate method call to the original object instance -> proxy all public methods
        ArrayList<Method> delegateMethods = super.filterInterceptMethods(targetClass, allMethods);
        return delegateMethods;
    }

    @Override
        // we don't need to overwrite methods to just execute interceptors
        // all method call are delegated to our EnableInterceptorsDelegate, to delegate to the original object instance


    public void somethingNotIntercepted()
    {
        methodCalled = true;
    }
import org.jboss.shrinkwrap.api.ShrinkWrap;
                        "org.apache.deltaspike.test.category"},
        // add asm - it isn't shaded yet in the test phase
        result.add(ShrinkWrap.create(JavaArchive.class, "ds-asm.jar")
                    .addPackages(true, "org.objectweb.asm"));

    
    private static class DummyInvocationHandler implements InvocationHandler
    {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
        {
            return null;
        }
    }
 b/deltaspike/modules/proxy/api/src/main/java/org/apache/deltaspike/proxy/util/EnableInterceptorsInterceptor.java
package org.apache.deltaspike.proxy.util;
 b/deltaspike/modules/proxy/api/src/main/java/org/apache/deltaspike/proxy/util/EnableInterceptorsProxyFactory.java
package org.apache.deltaspike.proxy.util;
import java.io.Serializable;
import java.lang.reflect.InvocationHandler;

    private EnableInterceptorsProxyFactory()
        

        Class proxyClass = INSTANCE.getProxyClass(beanManager, obj.getClass(), EnableInterceptorsDelegate.class);
    
    /**
     * {@link InvocationHandler} to delegate every method call to an provided object instance.
     */
    private static class EnableInterceptorsDelegate implements InvocationHandler, Serializable
    {
        private final Object instance;

        public EnableInterceptorsDelegate(Object instance)
        {
            this.instance = instance;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
        {
            return method.invoke(instance, args);
        }
    }
import org.apache.deltaspike.core.impl.util.AnnotatedMethods;
            final AnnotatedMethod<?> annotatedMethod = AnnotatedMethods.findMethod(annotatedType, method);
import org.apache.deltaspike.core.impl.util.AnnotatedMethods;
                final AnnotatedMethod<?> annotatedMethod = AnnotatedMethods.findMethod(annotatedType, method);
    public static final String DEFAULT_REMOVE_PREFIX = "removeBy";
        return this.getPrefix().equalsIgnoreCase(DEFAULT_DELETE_PREFIX) ||
                this.getPrefix().equalsIgnoreCase(DEFAULT_REMOVE_PREFIX);
        },
        REMOVE_DEFAULT(DEFAULT_REMOVE_PREFIX)
        {
            @Override
            public SingleResultType getStyle()
            {
                return SingleResultType.ANY;
            }
    public abstract void removeByName(String name);

    public abstract void removeByNameAndEnabled(String name, Boolean aTrue);

     * @param attribute Sort attribute.
     * @return Fluent API: the result instance.
     * Sort the query result ascending by the given entity singular attribute.
     * This is the typesafe version, alternatively a {@link #orderAsc(String)}
     * String can be used.
     *
     * @param attribute        Sort attribute.
     * @param appendEntityName whether the entity name 'e' should be appended to this attribute
     * @return Fluent API: the result instance.
     */
    <X> QueryResult<E> orderAsc(SingularAttribute<E, X> attribute, boolean appendEntityName);

    /**
     * @param attribute Sort attribute.
     * @return Fluent API: the result instance.
     * Sort the query result ascending by the given entity attribute.
     *
     * @param attribute        Sort attribute.
     * @param appendEntityName whether the entity name 'e' should be appended to this attribute
     * @return Fluent API: the result instance.
     */
    QueryResult<E> orderAsc(String attribute, boolean appendEntityName);

    /**
     * @param attribute Sort attribute.
     * @return Fluent API: the result instance.
     * Sort the query result descending by the given entity singular attribute.
     * This is the typesafe version, alternatively a {@link #orderDesc(String)}
     * String can be used.
     *
     * @param attribute        Sort attribute.
     * @param appendEntityName whether the entity name 'e' should be appended to this attribute
     * @return Fluent API: the result instance.
     */
    <X> QueryResult<E> orderDesc(SingularAttribute<E, X> attribute, boolean appendEntityName);

    /**
     * @param attribute Sort attribute.
     * @return Fluent API: the result instance.
     * Sort the query result descending by the given entity attribute.
     *
     * @param attribute        Sort attribute.
     * @param appendEntityName whether the entity name 'e' should be appended to this attribute
     * @return Fluent API: the result instance.
     */
    QueryResult<E> orderDesc(String attribute, boolean appendEntityName);

    /**
     * @param attribute Sort attribute.
     * @return Fluent API: the result instance.
     *
     * @return Fluent API: the result instance.
     * @param attribute Sort attribute.
     * @return Fluent API: the result instance.
     * @param max Max number of results.
     * @return Fluent API: the result instance.
     * @param first Result start position.
     * @return Fluent API: the result instance.
     * @param lockMode Query lock mode to use in the query.
     * @return Fluent API: the result instance.
     * @param flushMode Query flush mode to use in the query.
     * @return Fluent API: the result instance.
     * @param hint  Hint name.
     * @param value Hint value.
     * @return Fluent API: the result instance.
     * @return List of entities retrieved by the query.
     * @return Entity retrieved by the query.
     * @return Entity retrieved by the query, or {@code null} if no result.
     * @return First Entity retrieved by the query, or {@code null} if no result.
     *
     * @return Result count.
     * @param pageSize Page size for further queries.
     * @return Fluent API: the result instance.
     * @param page Page to move to for the next query.
     * @return Fluent API: the result instance.
     * @return Fluent API: the result instance.
     * @return Fluent API: the result instance.
     *
     * @return Page count.
     *
     * @return Page position.
     *
     * @return Page size.
    private boolean appendEntityName;
    public OrderByQueryStringPostProcessor(SingularAttribute<?, ?> attribute, OrderDirection direction,
                                           boolean appendEntityName)
        this.appendEntityName = appendEntityName;
    public OrderByQueryStringPostProcessor(String attribute, OrderDirection direction, boolean appendEntityName)
        this.appendEntityName = appendEntityName;
        if (appendEntityName)
        {
            builder.append(QueryBuilder.ENTITY_NAME)
                .append(".");
        }

        return builder
                .append(attribute)
        return orderAsc(attribute, true);
    }

    @Override
    public <X> QueryResult<T> orderAsc(SingularAttribute<T, X> attribute, boolean appendEntityName)
    {
        context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.ASC,
                appendEntityName));
        return orderAsc(attribute, true);
    }

    @Override
    public QueryResult<T> orderAsc(String attribute, boolean appendEntityName)
    {
        context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.ASC,
                appendEntityName));
        return orderDesc(attribute, true);
    }

    @Override
    public <X> QueryResult<T> orderDesc(SingularAttribute<T, X> attribute, boolean appendEntityName)
    {
        context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.DESC,
                appendEntityName));
        return orderDesc(attribute, true);
    }

    @Override
    public QueryResult<T> orderDesc(String attribute, boolean appendEntityName)
    {
        context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.DESC,
                appendEntityName));
import java.util.concurrent.TimeUnit;
         * Specify that a resolved value will get cached for a certain amount of time.
         * After the time expires the next {@link #getValue()} will again resolve the value
         * from the underlying {@link ConfigResolver}.
         *
         * @param timeUnit the TimeUnit for the value
         * @param value the amount of the TimeUnit to wait
         * @return This builder
         */
        TypedResolver<T> cacheFor(TimeUnit timeUnit, long value);

        /**
        private long cacheTimeMs = -1;
        private volatile long reloadAfter = -1;
        private T lastValue = null;

        public TypedResolver<T> cacheFor(TimeUnit timeUnit, long value)
        {
            this.cacheTimeMs = timeUnit.toMillis(value);
            return this;
        }

        @Override
            if (cacheTimeMs > 0)
            {
                long now = System.currentTimeMillis();
                if (now <= reloadAfter)
                {
                    return lastValue;
                }
                reloadAfter = now  cacheTimeMs;
            }

            value = fallbackToDefaultIfEmpty(keyResolved, value, defaultValue);
            if (cacheTimeMs > 0)
            {
                lastValue = value;
            }
            return value;
            if (scheduled == null && !jobClass.equals(DynamicExpressionObserverJob.class))
            if (scheduled == null)
            {
                return;
            }

import org.apache.deltaspike.core.api.config.ConfigResolver;

 * Please note that you need to enable this handling if you are running DeltaSpike
 * in an EAR on a container which supports parent Extensions.
 * You can do that by settting {@link #CONFIG_ENABLE_PARENT_EXTENSION} to &quote;true&quote;
 *
    /**
     * Enable DeltaSpike ParentExtension handling by setting this configuration option to &quote;true&quote;
     */
    public static final String CONFIG_ENABLE_PARENT_EXTENSION = "deltaspike.parent.extension.enabled";
        if (usingParentExtension())
        {
            removeAbandonedExtensions();
            ClassLoader classLoader = ClassUtils.getClassLoader(null);
            extensionStorage.add(new ExtensionStorageInfo(classLoader, extension));
        }

    private static boolean usingParentExtension()
    {
        final boolean usingParentExtension =
            Boolean.parseBoolean(ConfigResolver.getPropertyValue(CONFIG_ENABLE_PARENT_EXTENSION));
        return usingParentExtension;
    }

        if (usingParentExtension())
            ClassLoader parentClassLoader = ClassUtils.getClassLoader(null).getParent();

            Iterator<ExtensionStorageInfo> extIt = extensionStorage.iterator();
            while (extIt.hasNext())
                ExtensionStorageInfo extensionInfo = extIt.next();
                if (!extensionInfo.isAbandoned() && // weak reference case
                    extension.getClass().equals(extensionInfo.getExtension().getClass()) &&
                    extensionInfo.getClassLoader().equals(parentClassLoader))
                {
                    return (T) extensionInfo.getExtension();
                }
    public static String getPropertyValue(String key, String defaultValue, boolean evaluateVariables)
    {
        String value = getPropertyValue(key, defaultValue);
        if (value != null && evaluateVariables)
        {
            int startVar = 0;
            while ((startVar = value.indexOf("${", startVar)) >= 0)
            {
                int endVar = value.indexOf("}", startVar);
                if (endVar <= 0)
                {
                    break;
                }
                String variable = value.substring(startVar  2, endVar);
                if (variable.isEmpty())
                {
                    break;
                }
                String variableValue = getPropertyValue(variable, null, true);
                if (variableValue != null)
                {
                    value = value.replace("${"  variable  "}", variableValue);
                }
                startVar;
            }
        }
        return value;
    }

         * Whether to evaluate variables in configured values.
         * A variable starts with '${' and ends with '}', e.g.
         * <pre>
         * mycompany.some.url=${myserver.host}/some/path
         * myserver.host=http://localhost:8081
         * </pre>
         * If 'evaluateVariables' is enabled, the result for the above key
         * {@code "mycompany.some.url"} would be:
         * {@code "http://localhost:8081/some/path"}
         * @param evaluateVariables whether to evaluate variables in values or not
         * @return This builder
         */
        TypedResolver<T> evaluateVariables(boolean evaluateVariables);

        /**
        private boolean evaluateVariables = false;

        public TypedResolver<T> evaluateVariables(boolean evaluateVariables)
        {
            this.evaluateVariables = evaluateVariables;
            return this;
        }

        @Override
            value = getPropertyValue(keyResolved, null, evaluateVariables);
                        value = getPropertyValue(keyResolved, null, evaluateVariables);
                        value = getPropertyValue(keyResolved, null, evaluateVariables);
                        value = getPropertyValue(keyResolved, null, evaluateVariables);
import org.apache.deltaspike.core.spi.throttling.ThrottledStrategy;
    private ThrottledStrategy throttledStrategy;
        return throttledStrategy.execute(ic);
import org.apache.deltaspike.core.spi.future.FutureableStrategy;
@Futureable
    private FutureableStrategy futureableStrategy;
        return futureableStrategy.execute(ic);
import org.apache.deltaspike.core.spi.lock.LockedStrategy;
    private LockedStrategy lockedStrategy;
        return lockedStrategy.execute(ic);
         * Whether to log picking up any value changes as INFO.
         *
         * @return This builder
         */
        TypedResolver<T> logChanges(boolean logChanges);

        /**
        private boolean logChanges = false;
        public TypedResolver<T> logChanges(boolean logChanges)
        {
            this.logChanges = logChanges;
            return this;
        }

        @Override

            if (logChanges && (value != null && lastValue == null || !value.equals(lastValue)) )
            {
                LOG.log(Level.INFO, "New value {0} for key {1}.",
                    new Object[]{filterConfigValueForLog(keyOriginal, valueStr), keyOriginal});
            }



    /**
     * Whether to resolve 'variables' in configured values.
     *
     * @see org.apache.deltaspike.core.api.config.ConfigResolver.TypedResolver#evaluateVariables(boolean)
     */
    @Nonbinding
    boolean evaluateVariables() default true;
        resolver.evaluateVariables(configProperty.evaluateVariables());

    @Inject
    @ConfigProperty(name = "testDbConfig")
    private String dbConfig;


    public String getDbConfig()
    {
        return dbConfig;
    }
        // see DELTASPIKE-1113
        if (delegatedWindowMode)
            return;
        String windowId = clientWindow.getWindowId(context);
        // just to get sure if a user provides a own client window
        windowId = secureWindowId(windowId);

import java.util.concurrent.TimeUnit;


    interface TimeoutCustomization
    {
        Integer FUTUREABLE_TERMINATION_TIMEOUT_IN_MILLISECONDS =
                ConfigResolver.resolve("deltaspike.futureable.termination-timeout_in_milliseconds")
                        .as(Integer.class)
                        .withCurrentProjectStage(true)
                        .withDefault((int) TimeUnit.MINUTES.toMillis(1))
                        .getValue();
    }
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
        final long timeout = CoreBaseConfig.TimeoutCustomization.FUTUREABLE_TERMINATION_TIMEOUT_IN_MILLISECONDS;
        return getPropertyValue(key, defaultValue, true);
        String value = getPropertyValue(key, evaluateVariables);

        return fallbackToDefaultIfEmpty(key, value, defaultValue);
        return getPropertyValue(key, true);
    }

    /**
     * Resolves the value configured for the given key.
     *
     * @param key the property key
     * @param evaluateVariables whether to evaluate any '${variablename}' variable expressions
     *
     * @return the configured property value from the {@link ConfigSource} with the highest ordinal or null if there is
     *         no configured value for it
     */
    public static String getPropertyValue(String key, boolean evaluateVariables)
    {

                if (evaluateVariables)
                {
                    // recursively resolve any ${varName} in the value
                    int startVar = 0;
                    while ((startVar = value.indexOf("${", startVar)) >= 0)
                    {
                        int endVar = value.indexOf("}", startVar);
                        if (endVar <= 0)
                        {
                            break;
                        }
                        String varName = value.substring(startVar  2, endVar);
                        if (varName.isEmpty())
                        {
                            break;
                        }
                        String variableValue = getPropertyValue(varName, true);
                        if (variableValue != null)
                        {
                            value = value.replace("${"  varName  "}", variableValue);
                        }
                        startVar;
                    }
                }


    interface ParentExtensionCustomization
    {
        Boolean PARENT_EXTENSION_ENABLED =
                ConfigResolver.resolve("deltaspike.parent.extension.enabled")
                        .as(Boolean.class)
                        .withCurrentProjectStage(true)
                        .withDefault(Boolean.FALSE)
                        .getValue();
    }
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
 * You can do that by settting {@code "deltaspike.parent.extension.enabled"} to &quote;true&quote;
 *
 * @see org.apache.deltaspike.core.api.config.base.CoreBaseConfig.ParentExtensionCustomization
        return CoreBaseConfig.ParentExtensionCustomization.PARENT_EXTENSION_ENABLED;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
    private Map<String, Object> sessionMap = new ConcurrentHashMap<String, Object>();

        return this.sessionMap.get(name);
        return getAttribute(name);
        this.sessionMap.put(name, value);
        setAttribute(name, value);
        this.sessionMap.remove(name);
        removeAttribute(name);
        this.sessionMap.clear();
        if (facesContext != null && facesContext.getCurrentPhaseId() != null)
        if (facesContext == null || facesContext.getCurrentPhaseId() == null)
            long now = -1;
                now = System.currentTimeMillis();
                reloadAfter = now  cacheTimeMs;
import java.util.Arrays;
import java.util.LinkedList;
    // only for weld1
    private static final boolean IS_WELD1;
    private static final ThreadLocal<LinkedList<CallKey>> STACK = new ThreadLocal<LinkedList<CallKey>>()
    {
        @Override
        protected LinkedList<CallKey> initialValue()
        {
            return new LinkedList<CallKey>();
        }
    };


        { // workaround for weld -> use a thread local to track the invocations
            boolean weld1 = false;
            try
            {
                final Class<?> impl = Thread.currentThread().getContextClassLoader()
                        .loadClass("org.jboss.weld.manager.BeanManagerImpl");
                final Package pck = impl.getPackage();
                weld1 = "Weld Implementation".equals(pck.getImplementationTitle())
                        && pck.getSpecificationVersion() != null && pck.getSpecificationVersion().startsWith("1.1.");
            }
            catch (final Throwable cnfe)
            {
                // no-op
            }
            IS_WELD1 = weld1;
        }
        final CallKey invocationKey;
        if (IS_WELD1)
        {
            invocationKey = new CallKey(ic);
            { // weld1 workaround
                final LinkedList<CallKey> stack = STACK.get();
                if (!stack.isEmpty() && stack.getLast().equals(invocationKey))
                {
                    try
                    {
                        return ic.proceed();
                    }
                    finally
                    {
                        if (stack.isEmpty())
                        {
                            STACK.remove();
                        }
                    }
                }
            }
        }
        else
        {
            invocationKey = null;
        }

                final LinkedList<CallKey> callStack;
                if (IS_WELD1)
                {
                    callStack = STACK.get();
                    callStack.add(invocationKey);
                }
                else
                {
                    callStack = null;
                }
                finally
                {
                    if (IS_WELD1)
                    {
                        callStack.removeLast();
                        if (callStack.isEmpty())
                        {
                            STACK.remove();
                        }
                    }
                }

    private static final class CallKey
    {
        private final InvocationContext ic;
        private final int hash;

        private CallKey(final InvocationContext ic)
        {
            this.ic = ic;

            final Object[] parameters = ic.getParameters();
            this.hash = ic.getMethod().hashCode()  (parameters == null ? 0 : Arrays.hashCode(parameters));
        }

        @Override
        public boolean equals(final Object o)
        {
            return this == o || !(o == null || getClass() != o.getClass()) && equals(ic, CallKey.class.cast(o).ic);
        }

        @Override
        public int hashCode()
        {
            return hash;
        }

        private boolean equals(final InvocationContext ic1, final InvocationContext ic2)
        {
            final Object[] parameters1 = ic1.getParameters();
            final Object[] parameters2 = ic2.getParameters();
            return ic2.getMethod().equals(ic1.getMethod()) &&
                    (parameters1 == parameters2 ||
                    (parameters1 != null && parameters2 != null && Arrays.equals(parameters1, ic2.getParameters())));
        }
    }
            if (logChanges && (value != null && !value.equals(lastValue) || (value == null && lastValue != null)) )
            lastValue = value;

        //just access the transaction-scoped bean
        entityManager.getTransaction();
    private int maxWindowIdLength = 10;
        writer.write("dswh.init('"  windowId  "','"
                 clientWindowRenderMode.name()  "',"
                 maxWindowIdLength  ",{");
        if (windowId != null && windowId.length() > this.maxWindowIdLength)
            windowId = windowId.substring(0, this.maxWindowIdLength);
                    maxWindowIdLength = ClientWindowHelper.getMaxWindowIdLength();

        private boolean withDefault = false;
            withDefault = true;
            withDefault = true;
            if (withDefault)
            {
                value = fallbackToDefaultIfEmpty(keyResolved, value, defaultValue);
            }
            value = getPropertyValue(keyResolved, evaluateVariables);
        this.params = Parameters.create(method, this.args, repoMethod);
import java.util.regex.Matcher;
import java.util.regex.Pattern;

    private static final String FIND_FIRST_PREFIX = "find(First|Top)(\\d)By";
    private static final String FIND_FIRST_PREFIX_PATTERN = FIND_FIRST_PREFIX  "(.)";
    private static final Pattern DIGIT_PATTERN = Pattern.compile("\\d");

    private int definedMaxResults = 0;
        if (this.methodName != null)
        {
            this.parseMaxResults();
        }
    public int getDefinedMaxResults()
        return definedMaxResults;
    }

    private void parseMaxResults()
    {
        if (this.methodName.matches(FIND_FIRST_PREFIX_PATTERN))
        {
            Matcher matcher = DIGIT_PATTERN.matcher(this.methodName);
            if (matcher.find())
            {
                this.definedMaxResults = Integer.parseInt(matcher.group());
            }
        }
    }

    private enum KnownQueryPrefix
    {
        DEFAULT(DEFAULT_PREFIX, SingleResultType.JPA),
        FIND_FIRST(FIND_FIRST_PREFIX, SingleResultType.JPA)
            public String removePrefix(String queryPart)
                return queryPart.replaceFirst(FIND_FIRST_PREFIX,"");
        OPTIONAL(DEFAULT_OPT_PREFIX,SingleResultType.OPTIONAL),
        ANY(DEFAULT_ANY_PREFIX, SingleResultType.ANY),
        DELETE_DEFAULT(DEFAULT_DELETE_PREFIX, SingleResultType.ANY),
        REMOVE_DEFAULT(DEFAULT_REMOVE_PREFIX, SingleResultType.ANY);
        private final SingleResultType singleResultType;
        KnownQueryPrefix(String prefix, SingleResultType singleResultType)
            this.singleResultType = singleResultType;
        public SingleResultType getStyle()
        {
            return this.singleResultType;
        }
            if (name.matches(FIND_FIRST_PREFIX_PATTERN))
            {
                return FIND_FIRST;
            }
    public int getDefinedMaxResults()
    {
        return this.methodPrefix.getDefinedMaxResults();
    }

import org.apache.deltaspike.data.impl.meta.RepositoryMethod;
    public static Parameters create(Method method, Object[] parameters, RepositoryMethod repositoryMethod)
        int max = extractSizeRestriction(method, repositoryMethod);
    private static int extractSizeRestriction(Method method, RepositoryMethod repositoryMethod)
        return repositoryMethod.getDefinedMaxResults();
    public abstract List<Simple> findFirst2ByName(String name);

    public abstract List<Simple> findTop2ByName(String name);

        String orderByPart = orderByParts[0];
        String prefix = methodPrefix.getPrefix();
        return !prefix.equals(orderByPart) && !orderByPart.matches(prefix);
    private static final String FIND_ALL_PREFIX = "findAll";
    private static final String FIND_FIRST_PREFIX = "find(First|Top)(\\d)(By)*";
    private static final String FIND_FIRST_PREFIX_PATTERN = FIND_FIRST_PREFIX  "(.*)";
    int getDefinedMaxResults()
        ALL(FIND_ALL_PREFIX, SingleResultType.JPA),
            public boolean matches(String name)
            {
                return name.matches(FIND_FIRST_PREFIX_PATTERN);
            }
            @Override
        public boolean matches(String name)
        {
            return name.startsWith(getPrefix());
        }

                if (mapping.matches(name))
    public abstract List<Simple> findFirst3OrderByName();

    public abstract List<Simple> findAllOrderByName();

        boolean isEntityClass = !Object.class.equals(repoEntity) && EntityVerifier.INSTANCE.verify(repoEntity);
    public static final EntityVerifier INSTANCE = new EntityVerifier();
        return EntityVerifier.INSTANCE.verify(entityClass);
            if (tableAnnotation != null && StringUtils.isNotEmpty(tableAnnotation.name()))
            {
                return tableAnnotation.name();
            }

            EntityType<?> entityType = entityManager.getMetamodel().entity(entityClass);
            return entityType.getName();

        boolean isEntityClass = !Object.class.equals(repoEntity) && EntityUtils.isEntityClass(repoEntity);
        return entityClass.isAnnotationPresent(Entity.class)
                || PersistenceUnitDescriptorProvider.getInstance().isEntity(entityClass);
import java.lang.annotation.Inherited;
@Inherited
import org.apache.deltaspike.data.api.Query;
import javax.persistence.QueryHint;
import java.util.HashMap;
import java.util.Map;
        Query query = context.getMethod().getAnnotation(Query.class);
        if (query != null && query.hints().length > 0)
        {
            Map<String, Object> hints = new HashMap<String, Object>();
            for (QueryHint hint : query.hints())
            {
                hints.put(hint.name(), hint.value());
            }
            return entityManager().find(entityClass(), primaryKey, hints);
        }
        else
        {
            return entityManager().find(entityClass(), primaryKey);
        }

    /**
     * Checks if the given class has a method with the same signature, taking in to account generic types
     * @param targetClass
     * @param method
     * @return if it contains a method with the same signature.
     */
    public static boolean containsPossiblyGenericMethod(Class<?> targetClass, Method method)
    {
        return extractPossiblyGenericMethod(targetClass, method) != null;
    }

    /**
     * Extracts a method matching the source method, allowing generic type parameters to be substituted as
     * long as they are properly castable.
     *
     * @param clazz The target class
     * @param sourceMethod The source method.
     * @return the extracted method or <code>null</code>
     */
    public static Method extractPossiblyGenericMethod(Class<?> clazz, Method sourceMethod)
    {
        Method exactMethod = extractMethod(clazz, sourceMethod);
        if (exactMethod == null)
        {
            String methodName = sourceMethod.getName();
            Class<?>[] parameterTypes = sourceMethod.getParameterTypes();
            for (Method method : clazz.getMethods())
            {
                if (method.getName().equals(methodName) &&
                        allSameType(method.getParameterTypes(), parameterTypes))
                {
                    return method;
                }
            }
            return null;
        }
        else
        {
            return exactMethod;
        }
    }

    /**
     * Whether all of the parameters from left to right are equivalent.
     * In order to support generics, it takes the form of left.isAssignableFrom(right)
     * @param left left hand side to check
     * @param right right hand side to check
     * @return whether all of the left classes can be assigned to the right hand side types
     */
    private static boolean allSameType(Class<?>[] left, Class<?>[] right)
    {
        if (left.length != right.length)
        {
            return false;
        }
        for (int p = 0; p < left.length; p)
        {
            if (!left[p].isAssignableFrom(right[p]))
            {
                return false;
            }
        }
        return true;
    }
            if (ClassUtils.containsPossiblyGenericMethod(bean.getBeanClass(), context.getMethod()))
        Method extract = ClassUtils.extractPossiblyGenericMethod(target.getClass(), method);
import org.apache.deltaspike.data.api.EntityRepository;
import org.apache.deltaspike.data.api.Query;
import javax.persistence.QueryHint;

public interface SimpleIntermediateRepository extends EntityRepository<Simple, Long>
    @Query(hints = {
            @QueryHint(name = "openjpa.hint.OptimizeResultCount", value = "some.invalid.value"),
            @QueryHint(name = "org.hibernate.comment", value = "I'm a little comment short and stout")
    })
    Simple findBy(Long id);
    /**
     * For native queries only, whether or not this query returns the defined entity class or not.
     * Due to type erasure from generics, we don't have runtime information about the return collection
     */
    boolean returnsEntity() default true;

            if (query.returnsEntity())
            {
                result = params.applyTo(entityManager.createNativeQuery(jpqlQuery, context.getEntityClass()));
            }
            else
            {
                result = params.applyTo(entityManager.createNativeQuery(jpqlQuery));
            }
import java.util.List;

    @Query(value = "select name from simple_table", isNative = true, returnsEntity = false)
    List<String> findAllNames();
import org.apache.deltaspike.cdise.api.ContextControl;
import org.apache.deltaspike.test.utils.CdiContainerUnderTest;
import org.jboss.shrinkwrap.api.ShrinkWrap;

    public static JavaArchive getContextControlForDeployment()
    {
        JavaArchive jar = ShrinkWrap.create(JavaArchive.class, "cdi-control.jar")
                .addClass(ContextControl.class);

        if (CdiContainerUnderTest.is("owb"))
        {
            jar.addPackage("org.apache.deltaspike.cdise.owb");
        }
        return jar;
    }
    private EntityManager entityManager;
                        BeanProvider.getDependent(ref.getEntityManagerResolverClass()));
                ref.setEntityManager(entityManager);
            RepositoryMethod repoMethod = components.lookupMethod(repo, method);
    
    public RepositoryMethod lookupMethod(RepositoryComponent component, Method method)
    {
        return component.lookupMethod(method);
    }
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
        QueryBuilder builder = BeanProvider.getContextualReference(
            return new WrappedQueryBuilder(builder);
        return builder;
    private QueryBuilderFactory queryBuilderFactory;
            QueryBuilder builder = queryBuilderFactory.build(repoMethod, queryContext);
import org.apache.deltaspike.core.util.OptionalUtil;
            Object result = null;
                        result = query.getSingleResult();
                    break;
                    result = queryResult.size() > 0 ? queryResult.get(0) : null;
            }
            if (context.isOptional())
            {
                return OptionalUtil.wrap(result);
            }
            else
            {
                return result;
        SingleResultType baseSingleResultType = repoMethod.getSingleResultStyle();
        if (repoMethod.isOptional() && baseSingleResultType == SingleResultType.JPA)
        {
            return SingleResultType.OPTIONAL;
        }
        else
        {
            return baseSingleResultType;
        }

    public boolean isOptional()
    {
        return this.repoMethod.isOptional();
    }
import org.apache.deltaspike.core.util.OptionalUtil;
    private final boolean isOptional;
        this.isOptional = OptionalUtil.isOptionalReturned(this.method);
    public boolean isOptional()
    {
        return this.isOptional;
    }
//    TODO Figure out a way to test this that doesn't require java 8
//    public abstract java.util.Optional<Simple> findById(Long id);

    private DependentProvider<? extends EntityManager> entityManagerDependentProvider;
    
    private Class<? extends EntityManagerResolver> entityManagerResolverClass;
    private DependentProvider<? extends EntityManagerResolver> entityManagerResolverDependentProvider;
        
        if (entityManagerDependentProvider != null)
        {
            entityManagerDependentProvider.destroy();
        }
        

    public DependentProvider<? extends EntityManager> getEntityManagerDependentProvider()
    {
        return entityManagerDependentProvider;
    }

    public void setEntityManagerDependentProvider(
            DependentProvider<? extends EntityManager> entityManagerDependentProvider)
    {
        this.entityManagerDependentProvider = entityManagerDependentProvider;
    }
import java.lang.annotation.Annotation;
import java.util.Set;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
    private volatile Boolean globalEntityManagerInitialized;
    private boolean globalEntityManagerIsNormalScope;
    private EntityManager globalEntityManager;
    
    private void lazyInitGlobalEntityManager()
    {
        if (this.globalEntityManagerInitialized == null)
        {
            initGlobalEntityManager();
        }
    }

    private synchronized void initGlobalEntityManager()
    {
        // switch into paranoia mode
        if (this.globalEntityManagerInitialized == null)
        {
            this.globalEntityManagerInitialized = true;
            
            BeanManager beanManager = BeanManagerProvider.getInstance().getBeanManager();
            Set<Bean<?>> beans = beanManager.getBeans(EntityManager.class);

            if (!beans.isEmpty() && beans.size() == 1)
            {
                Class<? extends Annotation> scope = beanManager.resolve(beans).getScope();
                globalEntityManagerIsNormalScope = beanManager.isNormalScope(scope);

                if (globalEntityManagerIsNormalScope)
                {
                    Bean<?> bean = beans.iterator().next();
                    globalEntityManager = (EntityManager) beanManager.getReference(bean,
                            EntityManager.class,
                            beanManager.createCreationalContext(bean));
                }
            }
            else
            {
                throw new IllegalArgumentException(
                        "None or multiple EntityManager's found with the default qualifier.");
            }            
        }
    }
    
                lazyInitGlobalEntityManager();
                if (globalEntityManagerIsNormalScope)
                {
                    ref.setEntityManager(globalEntityManager);
                }
                else
                {
                    ref.setEntityManagerDependentProvider(
                            BeanProvider.getDependent(EntityManager.class));
                    ref.setEntityManager(
                            ref.getEntityManagerDependentProvider().get());
                }
            Bean<?> bean = beanManager.resolve(beans);
            globalEntityManagerIsNormalScope = beanManager.isNormalScope(bean.getScope());
            globalEntityManager = (EntityManager) beanManager.getReference(bean,
                    EntityManager.class,
                    beanManager.createCreationalContext(bean));       
            if (bean == null)
            {
                throw new IllegalStateException("Could not find EntityManager with default qualifier.");
            }
            
            if (globalEntityManagerIsNormalScope)
            {
                globalEntityManager = (EntityManager) beanManager.getReference(bean,
                        EntityManager.class,
                        beanManager.createCreationalContext(bean));       
            }
    static
    {
        return optionalSupported && optionalClass.isAssignableFrom(method.getReturnType());
import java.util.Collection;
import org.apache.deltaspike.core.util.OptionalUtil;
import org.apache.deltaspike.core.util.StreamUtil;
                Object result = invoke(delegate, context);
                if (result instanceof Collection && StreamUtil.isStreamReturned(context.getMethod()))
                {
                    return StreamUtil.wrap(result);
                }
                else if (OptionalUtil.isOptionalReturned(context.getMethod()))
                {
                    return OptionalUtil.wrap(result);
                }
                else
                {
                    return result;
                }
import org.apache.deltaspike.core.util.StreamUtil;
        if (streams())
        {
            return new StreamQueryProcessor();
        }
    private boolean streams()
    {
        return StreamUtil.isStreamReturned(method);
    }

    private static final class StreamQueryProcessor implements QueryProcessor
    {
        @Override
        public Object executeQuery(Query query, CdiQueryInvocationContext context)
        {
            return StreamUtil.wrap(query.getResultList());
        }
    }

import org.apache.deltaspike.core.util.OptionalUtil;
    public Object findOptional(PK primaryKey)
    {
        Object found = null;
        try
        {
            found = findBy(primaryKey);
        }
        catch (Exception e)
        {
        }
        return OptionalUtil.wrap(found);
    }

import javax.persistence.Entity;
import java.lang.reflect.ParameterizedType;
import java.util.List;
            Class<?> resultType = getQueryResultType(context.getMethod());
            if (isEntityType(resultType))
                result = params.applyTo(entityManager.createNativeQuery(jpqlQuery, resultType));
    private boolean isEntityType(Class<?> cls)
    {
        return cls.getAnnotation(Entity.class) != null;
    }

    private Class<?> getQueryResultType(Method m)
    {
        Class<?> rt = m.getReturnType();
        if (rt.isAssignableFrom(List.class) && rt != Object.class)
        {
            ParameterizedType pt = (ParameterizedType) m.getGenericReturnType();
            return (Class<?>) pt.getActualTypeArguments()[0];
        }
        return rt;
    }
    @Query(value = "select name from simple_table", isNative = true)
import java.util.List;

import org.apache.deltaspike.data.api.Query;
import org.apache.deltaspike.data.test.domain.Simple;
    @Query("SELECT s FROM Simple s WHERE s.name = ?1")
    Simple findByName(String name);

    @Query("SELECT s FROM Simple s WHERE s.name = ?1")
    List<Simple> findByName2(String name);
import java.util.stream.Stream;

    @Query(value = "select name from simple_table", isNative = true)
    Stream<String> findSimpleNames();
import java.util.HashMap;
import java.util.Map;
    private final Map<Method, Bean<DelegateQueryHandler>> lookupCache
        = new HashMap<Method, Bean<DelegateQueryHandler>>();
    
            DelegateQueryHandler delegate = lookup(context);
    private DelegateQueryHandler lookup(CdiQueryInvocationContext context)
        Bean<DelegateQueryHandler> selectedBean = lookupCache.get(context.getMethod());
        
        if (selectedBean == null)
            Set<Bean<DelegateQueryHandler>> beans = BeanProvider
                    .getBeanDefinitions(DelegateQueryHandler.class, true, true);
            for (Bean<DelegateQueryHandler> bean : beans)
                if (ClassUtils.containsPossiblyGenericMethod(bean.getBeanClass(), context.getMethod()))
                    selectedBean = bean;
            
            if (selectedBean != null)
            {
                lookupCache.put(context.getMethod(), selectedBean);
            }
        }
        
        
        if (selectedBean != null)
        {
            CreationalContext<DelegateQueryHandler> cc = beanManager.createCreationalContext(selectedBean);
            DelegateQueryHandler instance = (DelegateQueryHandler) beanManager.getReference(
                    selectedBean, DelegateQueryHandler.class, cc);
            
            if (selectedBean.getScope().equals(Dependent.class))
            {
                context.addDestroyable(new BeanDestroyable<DelegateQueryHandler>(selectedBean, instance, cc));
            }

            return instance;
            Method extract = ClassUtils.extractPossiblyGenericMethod(delegate.getClass(), context.getMethod());
            return extract.invoke(delegate, context.getMethodParameters());
        this.proxyClass = proxyFactory.getProxyClass(beanManager, targetClass);
                Constructor<T> constructor = proxyClass.getConstructor(InvocationHandler.class);
    public <T> Class<T> getProxyClass(BeanManager beanManager, Class<T> targetClass)
            proxyClass = createProxyClass(beanManager, targetClass.getClassLoader(), targetClass);
            Class<T> targetClass)
        Class proxyClass = INSTANCE.getProxyClass(beanManager, obj.getClass());
            Constructor constructor = proxyClass.getConstructor(InvocationHandler.class);
        byte[] proxyBytes = generateProxyClassBytes(targetClass,
        Type delegateInvocationHandlerType = Type.getType(InvocationHandler.class);
import org.apache.deltaspike.core.api.provider.BeanProvider;
    private volatile Boolean initialized;
    private InterceptorLookup interceptorLookup;
    
        lazyInit();

        List<Interceptor<?>> interceptors = interceptorLookup.lookup(proxy, method);
    
    private void lazyInit()
        if (this.initialized == null)
            init();
        }
    }
    private synchronized void init()
    {
        // switch into paranoia mode
        if (this.initialized == null)
        {
            this.initialized = true;
            
            this.interceptorLookup = BeanProvider.getContextualReference(InterceptorLookup.class);
public interface EntityRepository<E, PK extends Serializable> extends EntityPersistenceRepository<E, PK>,
        EntityCountRepository<E>
import javax.enterprise.context.Dependent;
@Dependent
import org.apache.deltaspike.core.api.provider.BeanProvider;
        DelegateManualInvocationHandler handler = BeanProvider.getContextualReference(DelegateManualInvocationHandler.class);
        return handler.invoke(proxy, method, parameters);
import org.apache.deltaspike.core.api.provider.BeanProvider;
        InterceptManualInvocationHandler handler = BeanProvider.getContextualReference(InterceptManualInvocationHandler.class);
        return handler.invoke(proxy, method, parameters);
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
        DelegateManualInvocationHandler handler = BeanProvider
              .getContextualReference(DelegateManualInvocationHandler.class);
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
        InterceptManualInvocationHandler handler = BeanProvider
              .getContextualReference(InterceptManualInvocationHandler.class);
            final List<Object> mapped = new ArrayList<Object>(result.size());
            return mapped;
        return new ArrayList<Object>();
        if (beanManager != null)
        if (clientWindow.isInitialRedirectSupported(context))
                        methodName = Character.toString(Character.toUpperCase(fieldName.charAt(0)));
        return Integer.toString((new Random()).nextInt() % 10000);
        return Integer.toString((int) Math.floor(Math.random() * 999));
        if (urls.isEmpty())
        return !queryResult.isEmpty() ? queryResult.get(0) : null;
                    result = !queryResult.isEmpty() ? queryResult.get(0) : null;
        return !queryResult.isEmpty() ? queryResult.get(0) : null;
        if (!oldTci.isEmpty())
                    && !interceptMethods.isEmpty()
        if (!exceptionsToCatch.isEmpty())
        if (interceptors != null && !interceptors.isEmpty())
        else if (!this.foundManagedJobClasses.isEmpty())
                if (violations != null && !violations.isEmpty())
        String value = getPropertyValue(
                key, 
                new ConfigResolverContext()
                        .setEvaluateVariables(evaluateVariables));
        return getPropertyValue(
                key, 
                new ConfigResolverContext().setEvaluateVariables(true));
        return getPropertyValue(
                key, 
                new ConfigResolverContext()
                        .setEvaluateVariables(evaluateVariables));        
        ConfigResolverContext configResolverContext = 
                new ConfigResolverContext()
                    .setProjectStageAware(true)
                    .setEvaluateVariables(true);
        
        String value = getPropertyValue(key  '.'  ps, configResolverContext);
            configResolverContext.setProjectStageAware(false);            
            value = getPropertyValue(key, configResolverContext);
    
    private static String getPropertyValue(String key, ConfigResolverContext configResolverContext)
    {
        ConfigSource[] appConfigSources = getConfigSources();

        String value;
        for (ConfigSource configSource : appConfigSources)
        {
            value = configSource.getPropertyValue(key);

            if (value != null)
            {
                LOG.log(Level.FINE, "found value {0} for key {1} in ConfigSource {2}.",
                        new Object[]{filterConfigValueForLog(key, value), key, configSource.getConfigName()});

                if (configResolverContext.isEvaluateVariables())
                {
                    value = resolveVariables(value, configResolverContext);
                }

                return filterConfigValue(key, value);
            }

            LOG.log(Level.FINER, "NO value found for key {0} in ConfigSource {1}.",
                    new Object[]{key, configSource.getConfigName()});
        }

        return null;        
    }

    /**
     * recursively resolve any ${varName} in the value
     */
    private static String resolveVariables(String value, ConfigResolverContext configResolverContext)
    {
        int startVar = 0;
        while ((startVar = value.indexOf("${", startVar)) >= 0)
        {
            int endVar = value.indexOf("}", startVar);
            if (endVar <= 0)
            {
                break;
            }
            String varName = value.substring(startVar  2, endVar);
            if (varName.isEmpty())
            {
                break;
            }
            
            String variableValue;
            if (configResolverContext.isProjectStageAware())
            {
                variableValue = getProjectStageAwarePropertyValue(varName);
            }
            else
            {
                variableValue = getPropertyValue(varName, true);
            }
            
            if (variableValue != null)
            {
                value = value.replace("${"  varName  "}", variableValue);
            }
            startVar;
        }
        return value;
    }
import javax.enterprise.inject.spi.Interceptor;
import javax.inject.Inject;
    @Inject

                      new ManualInvocationContext(this, interceptors, proxy, method, parameters, null);
     *
     * @throws Throwable
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.management.MBeanParameterInfo;

import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.api.jmx.JmxBroadcaster;
import org.apache.deltaspike.core.api.jmx.JmxManaged;
import org.apache.deltaspike.core.api.jmx.JmxParameter;
import org.apache.deltaspike.core.api.jmx.MBean;
import org.apache.deltaspike.core.api.jmx.NotificationInfo;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.util.ExceptionUtils;
import org.apache.deltaspike.core.util.ParameterUtil;
            
            Annotation[][] parametersAnnotations = method.getParameterAnnotations();
            Class<?>[] parameterTypes = method.getParameterTypes();
            MBeanParameterInfo[] parameterInfos = new MBeanParameterInfo[parameterTypes.length];
            for (int i = 0; i < parametersAnnotations.length; i)
            {
                String parameterDescription = null;
                String parameterName = "p"  (i  1);
                String java8ParameterName = ParameterUtil.getName(method, i);
                if (java8ParameterName != null)
                {
                    parameterName = java8ParameterName;
                }
                for (int j = 0; j < parametersAnnotations[i].length; j)
                {
                    if (parametersAnnotations[i][j] instanceof JmxParameter)
                    {
                        JmxParameter jmxParameter = (JmxParameter) parametersAnnotations[i][j];
                        if (!"".equals(jmxParameter.name()))
                        {
                            parameterName = jmxParameter.name();
                        }
                        if (!"".equals(jmxParameter.description()))
                        {
                            parameterDescription = jmxParameter.description();
                        }
                    }
                }
                parameterInfos[i] = new MBeanParameterInfo(parameterName,
                    parameterTypes[i].getName(),
                    parameterDescription
                );
            }
            operationInfos.add(new MBeanOperationInfo(method.getName(),
                operationDescr,
                parameterInfos,
                method.getReturnType().getName(),
                MBeanOperationInfo.UNKNOWN
            ));
import org.apache.deltaspike.core.api.jmx.JmxParameter;
    public int multiply(@JmxParameter(name = "multiplier", description = "the multiplier") final int n)
                !void.class.isAssignableFrom(returnType) &&
            throw new IllegalArgumentException("Return type should be a CompletableStage, Future or Void");
        
        if (void.class.isAssignableFrom(returnType))
        {
            pool.submit(invocation);
            return null;
        }
        

import java.util.concurrent.CountDownLatch;

    @Futureable
    public void thatSLong(final long sleep, CountDownLatch latch) {
    	try
        {
            Thread.sleep(sleep);
            latch.countDown();
        }
        catch (final InterruptedException e)
        {
            Thread.interrupted();
            throw new IllegalStateException(e);
        }
    }

        implements EntityRepository<E, PK>, EntityPersistenceRepository<E, PK>,
        EntityCountRepository<E>
import javax.enterprise.context.ConversationScoped;
import javax.enterprise.context.RequestScoped;
import javax.enterprise.context.SessionScoped;

                // stops all built-in contexts except for ApplicationScoped as that one is handled by Weld
                ctxCtrl.stopContext(ConversationScoped.class);
                ctxCtrl.stopContext(RequestScoped.class);
                ctxCtrl.stopContext(SessionScoped.class);
     * Stops Conversation, Request and Session contexts.
     * Does NOT stop Application context, only invalidates 
     * App scoped beans, as in Weld this context always active and clears
     * automatically on shutdown.
        stopApplicationScope();
     * This is a no-op method. In Weld Application Context is active as soon as the container starts
        // No-op, in Weld Application context is always active
    /**
     * Weld Application context is active from container start to its shutdown
     * This method merely clears out all ApplicationScoped beans BUT the context
     * will still be active which may result in immediate re-creation of some beans.
     */
        // Weld App context should be always active
            // destroys the bean instances, but the context stays active
        
        //TODO broadcastApplicationStartupBroadcaster();
        broadcastInitializedJsfRequestEvent(facesContext);
        //TODO broadcastApplicationStartupBroadcaster();
        broadcastInitializedJsfRequestEvent(facesContext);

import org.picketlink.authentication.event.PostLoggedOutEvent;
    public void handleLogout(@Observes PostLoggedOutEvent event)
    {
        this.viewNavigationHandler.navigateTo(Pages.Login.class);
    }
}
    @Secured(LoggedInAccessDecisionVoter.class)
    {   
        
        class Test implements ViewConfig
        {
        }
 * <p>
 * An exception thrown by the method will be wrapped in a {@link javax.management.MBeanException}
 * unless it already is a {@code MBeanException}.
 * <p>
            catch (InvocationTargetException e)
                final Throwable cause = e.getCause();
                if (cause instanceof Error)
                {
                    throw (Error) cause;
                }
                if (cause instanceof MBeanException)
                {
                    throw (MBeanException) cause;
                }
                throw new MBeanException((Exception) cause, actionName  " failed with exception");
            }
            catch (IllegalAccessException e)
            {
                throw new ReflectionException(e, actionName  " could not be invoked");
            }
            catch (IllegalArgumentException e)
            {
                throw new ReflectionException(e, actionName  " could not be invoked");
        throw new ReflectionException(new NoSuchMethodException(actionName  " doesn't exist"));
 * <pre>
 * &#064;Repository
 * </pre>
     * Expects a single result. Other than {@link SingleResultType#JPA} it returns {@code null}
    AbstractEntityRepository<E, PK> implements FullEntityRepository<E, PK>

    /**
     * Converter for this property.
     * @return the converter to use to read this property in the expected type.
     */
    @Nonbinding
    Class<? extends ConfigResolver.Converter> converter() default ConfigResolver.Converter.class;
import java.lang.reflect.Type;
         * @param type target type, includes List and Map using a Converter
         * @param converter The converter for the target type
         * @param <N> target type
         * @return this builder typed.
         */
        <N> TypedResolver<N> as(Type type, Converter<N> converter);

        /**
        private Type configEntryType = String.class;
        @SuppressWarnings("unchecked")
        public <N> TypedResolver<N> as(Type clazz, Converter<N> converter)
        {
            configEntryType = clazz;
            this.converter = converter;

            return (TypedResolver<N>) this;
        }

        @Override
import java.lang.reflect.Type;
import org.apache.deltaspike.core.api.provider.BeanProvider;
        return getUntypedPropertyValue(injectionPoint, ipCls);
    }

    protected <T> T getUntypedPropertyValue(InjectionPoint injectionPoint, Type ipCls)
    {
        return readEntry(configProperty.name(), configProperty.defaultValue(), ipCls,
                configProperty.converter(), configProperty.parameterizedBy(),
                configProperty.projectStageAware(), configProperty.evaluateVariables());

    public <T> T readEntry(final String key, final String stringDefault, final Type ipCls,
                           final Class<? extends ConfigResolver.Converter> converterType,
                           final String parameterizedBy, final boolean projectStageAware, final boolean evaluate)
    {
        final ConfigResolver.UntypedResolver<String> untypedResolver = ConfigResolver.resolve(key);
        final ConfigResolver.TypedResolver<T> resolver =
                (ConfigResolver.Converter.class == converterType ?
                        untypedResolver.as(Class.class.cast(ipCls)) :
                        untypedResolver.as(ipCls, BeanProvider.getContextualReference(converterType)))
                        .withCurrentProjectStage(projectStageAware);
        if (!ConfigProperty.NULL.equals(stringDefault))
        {
            resolver.withStringDefault(stringDefault);
        }
        if (!ConfigProperty.NULL.equals(parameterizedBy))
        {
            resolver.parameterizedBy(parameterizedBy);
        }
        return resolver.evaluateVariables(evaluate).getValue();
    }
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.Produces;
import javax.enterprise.inject.Typed;
import javax.enterprise.inject.spi.AfterBeanDiscovery;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.InjectionPoint;
import javax.enterprise.inject.spi.ProcessBean;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer;
    private final Set<Type> dynamicConfigTypes = new HashSet<Type>();
    private Bean<DynamicBeanProducer> dynamicProducer;

    public void findDynamicProducer(@Observes ProcessBean<DynamicBeanProducer> processBean)
    {
        dynamicProducer = processBean.getBean();
    }

    public void collectDynamicTypes(@Observes ProcessBean<?> processBean)
    {
        for (final InjectionPoint ip : processBean.getBean().getInjectionPoints())
        {
            final ConfigProperty annotation = ip.getAnnotated().getAnnotation(ConfigProperty.class);
            if (annotation == null || annotation.converter() == ConfigResolver.Converter.class)
            {
                continue;
            }

            dynamicConfigTypes.add(ip.getType());
        }
    }

    public void addDynamicBean(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager bm)
    {
        if (dynamicProducer != null && !dynamicConfigTypes.isEmpty())
        {
            afterBeanDiscovery.addBean(new DynamicBean(dynamicProducer, dynamicConfigTypes));
        }
    }


    @ApplicationScoped
    @Typed(DynamicBeanProducer.class) // used as an internal bean
    static class DynamicBeanProducer extends BaseConfigPropertyProducer
    {
        @Produces
        @ConfigProperty(name = "ignored")
        public Object create(final InjectionPoint ip)
        {
            return super.getUntypedPropertyValue(ip, ip.getType());
        }
    }

    @Typed
    private static final class DynamicBean<T> implements Bean<T>
    {
        private final Bean<T> producer;
        private final Set<Type> types;

        private DynamicBean(final Bean<T> producer, final Set<Type> types)
        {
            this.producer = producer;
            this.types = types;
        }

        @Override
        public Set<Type> getTypes()
        {
            return types;
        }

        @Override
        public Set<Annotation> getQualifiers()
        {
            return producer.getQualifiers();
        }

        @Override
        public Class<? extends Annotation> getScope()
        {
            return producer.getScope();
        }

        @Override
        public String getName()
        {
            return producer.getName();
        }

        @Override
        public boolean isNullable()
        {
            return producer.isNullable();
        }

        @Override
        public Set<InjectionPoint> getInjectionPoints()
        {
            return producer.getInjectionPoints();
        }

        @Override
        public Class<?> getBeanClass()
        {
            return producer.getBeanClass();
        }

        @Override
        public Set<Class<? extends Annotation>> getStereotypes()
        {
            return producer.getStereotypes();
        }

        @Override
        public boolean isAlternative()
        {
            return producer.isAlternative();
        }

        @Override
        public T create(final CreationalContext<T> creationalContext)
        {
            return producer.create(creationalContext);
        }

        @Override
        public void destroy(final T t, final CreationalContext<T> creationalContext)
        {
            producer.destroy(t, creationalContext);
        }
    }
import java.lang.reflect.Type;

    private <T> T getPropertyWithException(InjectionPoint ip, Type ipCls)
            return getUntypedPropertyValue(ip, ipCls);
import org.apache.deltaspike.core.api.config.ConfigResolver;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
    @Inject
    @ConfigProperty(name = "urlList", converter = UrlList.class, defaultValue = "http://localhost,http://127.0.0.1")
    private List<URL> urlList;

    @Inject
    @ConfigProperty(name = "urlListFromProperties", converter = UrlList.class)
    private List<URL> urlListFromProperties;


    public List<URL> getUrlList() {
        return urlList;
    }

    public List<URL> getUrlListFromProperties() {
        return urlListFromProperties;
    }

    public static class UrlList implements ConfigResolver.Converter<List<URL>>
    {
        @Override
        public List<URL> convert(final String value)
        {
            final List<URL> urls = new ArrayList<URL>();
            if (value != null)
            {
                for (final String segment : value.split(","))
                {
                    try
                    {
                        urls.add(new URL(segment));
                    }
                    catch (final MalformedURLException e)
                    {
                        throw new IllegalArgumentException(e);
                    }
                }
            }
            return urls;
        }
    }
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.spi.config.ConfigFilter;
    private final List<Bean<? extends ConfigSource>> cdiSources = new ArrayList<Bean<? extends ConfigSource>>();
    private final List<Bean<? extends ConfigFilter>> cdiFilters = new ArrayList<Bean<? extends ConfigFilter>>();

    public void findSources(@Observes ProcessBean<? extends ConfigSource> source)
    {
        final Class<?> beanClass = source.getBean().getBeanClass();
        if (beanClass != null && beanClass.getName().startsWith("org.apache.deltaspike.core.impl.config.")) // built-in
        {
            return;
        }
        cdiSources.add(source.getBean());
    }

    public void findFilters(@Observes ProcessBean<? extends ConfigFilter> filter)
    {
        cdiFilters.add(filter.getBean());
    }

        for (final Bean bean : cdiSources)
        {
            configSources.add(BeanProvider.getContextualReference(ConfigSource.class, bean));
        }
        for (final Bean bean : cdiFilters)
        {
            ConfigResolver.addConfigFilter(BeanProvider.getContextualReference(ConfigFilter.class, bean));
        }

    @Inject
    @ConfigProperty(name = "custom-source.test")
    private String customSourceValue;

    public String getCustomSourceValue() {
        return customSourceValue;
    }

import org.apache.deltaspike.core.api.config.Filter;
import org.apache.deltaspike.core.api.config.Source;
        if (!source.getAnnotated().isAnnotationPresent(Source.class)) {
        if (!filter.getAnnotated().isAnnotationPresent(Filter.class)) {
            return;
        }
import org.apache.deltaspike.core.api.config.Filter;
@Filter
import org.apache.deltaspike.core.api.config.Source;
@Source
        final ConfigResolver.TypedResolver<T> resolver = asResolver(
                key, stringDefault, ipCls, converterType, parameterizedBy, projectStageAware, evaluate);
        return resolver.getValue();
    }

    public <T> ConfigResolver.TypedResolver<T> asResolver(final String key, final String stringDefault,
                                                          final Type ipCls,
                                                          final Class<? extends ConfigResolver.Converter> converterType,
                                                          final String parameterizedBy,
                                                          final boolean projectStageAware, final boolean evaluate)
    {
        return resolver.evaluateVariables(evaluate);
import org.apache.deltaspike.core.api.config.Configuration;
import org.apache.deltaspike.core.api.literal.AnyLiteral;
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
import org.apache.deltaspike.core.util.bean.BeanBuilder;
    private final List<Class<?>> dynamicConfigurationBeanClasses = new ArrayList<Class<?>>();
    public void findDynamicConfigurationBeans(@Observes ProcessAnnotatedType<?> pat)
    {
        if (!pat.getAnnotatedType().isAnnotationPresent(Configuration.class))
        {
            return;
        }
        final Class<?> javaClass = pat.getAnnotatedType().getJavaClass();
        if (!javaClass.isInterface())
        {
            return;
        }
        dynamicConfigurationBeanClasses.add(javaClass);
    }

        if (!source.getAnnotated().isAnnotationPresent(Source.class))
        {
        if (!filter.getAnnotated().isAnnotationPresent(Filter.class))
        {
    public void addDynamicBeans(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager bm)
        for (final Class<?> proxyType : dynamicConfigurationBeanClasses)
        {
            afterBeanDiscovery.addBean(new BeanBuilder(null)
                    .types(proxyType, Object.class)
                    .qualifiers(new DefaultLiteral(), new AnyLiteral())
                    .beanLifecycle(new ProxyConfigurationLifecycle(proxyType))
                    .scope(ApplicationScoped.class)
                    .passivationCapable(true)
                    .beanClass(proxyType)
                    .create());
        }

    /**
     * @return the key prefix to apply to all methods.
     */
    String prefix() default "";
                new ConfigurationHandler(
                        cacheFor <= 0 ? -1 : configuration.cacheUnit().toMillis(cacheFor), configuration.prefix()));
        private final String prefix;
        private ConfigurationHandler(final long cacheMs, final String prefix)
            this.prefix = prefix;
                        prefix  annotation.name(), annotation.defaultValue(), returnType,
                    .id("DeltaSpikeConfiguration#"  proxyType.getName())
import javax.enterprise.inject.Typed;
@Typed // ignore this as CDI bean
import javax.enterprise.inject.Typed;
@Typed // ignore this as CDI bean
import java.util.EventListener;
import java.util.Map;
import javax.servlet.Filter;
import javax.servlet.FilterRegistration;
import javax.servlet.ServletRegistration;
import javax.servlet.SessionCookieConfig;
import javax.servlet.SessionTrackingMode;
import javax.servlet.descriptor.JspConfigDescriptor;




    @Override
    public boolean setInitParameter(String name, String value)
    {
        return false;
    }

    @Override
    public ServletRegistration.Dynamic addServlet(String servletName, String className)
        throws IllegalArgumentException, IllegalStateException
    {
        return null;
    }

    @Override
    public ServletRegistration.Dynamic addServlet(String servletName, Servlet servlet)
        throws IllegalArgumentException, IllegalStateException
    {
        return null;
    }

    @Override
    public ServletRegistration.Dynamic addServlet(String servletName, Class<? extends Servlet> clazz)
        throws IllegalArgumentException, IllegalStateException
    {
        return null;
    }

    @Override
    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException
    {
        return null;
    }

    @Override
    public ServletRegistration getServletRegistration(String servletName)
    {
        return null;
    }

    @Override
    public Map<String, ? extends ServletRegistration> getServletRegistrations()
    {
        return null;
    }

    @Override
    public FilterRegistration.Dynamic addFilter(String filterName, String className)
        throws IllegalArgumentException, IllegalStateException
    {
        return null;
    }

    @Override
    public FilterRegistration.Dynamic addFilter(String filterName, Filter filter)
        throws IllegalArgumentException, IllegalStateException
    {
        return null;
    }

    @Override
    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass)
        throws IllegalArgumentException, IllegalStateException
    {
        return null;
    }

    @Override
    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException
    {
        return null;
    }

    @Override
    public FilterRegistration getFilterRegistration(String filterName)
    {
        return null;
    }

    @Override
    public Map<String, ? extends FilterRegistration> getFilterRegistrations()
    {
        return null;
    }

    @Override
    public void addListener(Class<? extends EventListener> listenerClass)
    {

    }

    @Override
    public void addListener(String className)
    {

    }

    @Override
    public <T extends EventListener> void addListener(T t)
    {

    }

    @Override
    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException
    {
        return null;
    }

    @Override
    public void declareRoles(String... roleNames)
    {

    }

    @Override
    public SessionCookieConfig getSessionCookieConfig()
    {
        return null;
    }

    @Override
    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes)
    {

    }

    @Override
    public Set<SessionTrackingMode> getDefaultSessionTrackingModes()
    {
        return null;
    }

    @Override
    public int getEffectiveMajorVersion() throws UnsupportedOperationException
    {
        return 0;
    }

    @Override
    public int getEffectiveMinorVersion() throws UnsupportedOperationException
    {
        return 0;
    }

    @Override
    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes()
    {
        return null;
    }

    @Override
    public ClassLoader getClassLoader()
    {
        return null;
    }

    @Override
    public JspConfigDescriptor getJspConfigDescriptor()
    {
        return null;
    }
