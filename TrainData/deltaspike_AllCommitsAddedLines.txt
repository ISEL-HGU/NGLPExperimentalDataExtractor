import javax.enterprise.inject.Typed;
@Typed()
public static String getPropertyValue(String key)
public static List<String> getAllPropertyValues(String key)
private static synchronized ConfigSource[] getConfigSources()
private static List<ConfigSource> resolveConfigSources()
private static ConfigSource[] sortConfigSources(List<ConfigSource> configSources)
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.api.util.ClassUtils;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
private static final Logger LOG = Logger.getLogger(ClassDeactivation.class.getName());
ClassDeactivator classDeactivator = getConfiguredClassDeactivator();
private static ClassDeactivator getConfiguredClassDeactivator()
{
List<String> classDeactivatorClassNames = ConfigResolver.getAllPropertyValues(ClassDeactivator.class.getName());
Set<Class> deactivatedClasses = new HashSet<Class>();
ClassDeactivator currentClassDeactivator;
for(String classDeactivatorClassName : classDeactivatorClassNames)
{
currentClassDeactivator =
ClassUtils.tryToInstantiateClassForName(classDeactivatorClassName, ClassDeactivator.class);
if(currentClassDeactivator != null)
{
deactivatedClasses.addAll(currentClassDeactivator.getDeactivatedClasses());
}
else
{
}
}
return new DefaultClassDeactivator(deactivatedClasses);
}
String className = pathToClassName(entryName.substring(0, entryName.length()-(".class".length())));
String className = pathToClassName(entryName.substring(0, entryName.length()-(".class".length())));
javaArchive.addAsResource(entryName.replace('\\', '/'));
String packageName = pathToClassName(jarEntryName);
String packageName = pathToClassName(jarEntryName);
private static String pathToClassName(String pathName) {
}
import java.util.logging.Level;
import java.util.logging.Logger;
public abstract class ConfigSource
protected Logger LOG = Logger.getLogger(getClass().getName());
private static final String ORDINAL_KEY = "org_apache_deltaspike_ORDINAL";
private int ordinal;
protected ConfigSource()
{
init();
}
public int getOrdinal()
{
return this.ordinal;
}
public abstract String getPropertyValue(String key);
public abstract String getConfigName();
protected int getDefaultOrdinal()
{
return 1000;
}
protected void init()
{
this.ordinal = getDefaultOrdinal();
Integer configuredOrdinal = null;
String configuredOrdinalString = getPropertyValue(getOrdinalKey());
try
{
if(configuredOrdinalString != null)
{
configuredOrdinal = new Integer(configuredOrdinalString.trim());
}
}
catch (NumberFormatException e)
{
LOG.log(Level.WARNING,
}
catch (Exception e)
{
}
if(configuredOrdinal != null)
{
this.ordinal = configuredOrdinal;
}
}
protected String getOrdinalKey()
{
return ORDINAL_KEY;
}
if (urlString.contains("%20"))
urlString = urlString.replaceAll("%20", " ");
f = new File( (new URL(ensureCorrectUrlFormat(urlString))).getFile() );
public final class ConfigResolver
private ConfigResolver()
{
}
import javax.enterprise.inject.Typed;
@Typed()
public final class BeanProvider
catch (InstantiationException e)
{
}
catch (IllegalAccessException e)
public final class ClassDeactivation
import org.apache.deltaspike.core.api.literal.AnyLiteral;
import javax.enterprise.context.Dependent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
public static <T> List<T> getContextualReferences(Class<T> type,
boolean optional,
boolean includeDefaultScopedBeans)
{
BeanManager beanManager = getBeanManager();
Set<Bean<?>> beans = beanManager.getBeans(type, new AnyLiteral());
if (beans == null || beans.isEmpty())
{
if (optional)
{
return Collections.emptyList();
}
}
if(!includeDefaultScopedBeans)
{
beans = filterDefaultScopedBeans(beans);
}
List<T> result = new ArrayList<T>(beans.size());
for(Bean<?> bean : beans)
{
result.add(getContextualReference(type, beanManager,
new HashSet<Bean<?>>((Collection)Arrays.asList(new Object[]{bean}))));
}
return result;
}
private static Set<Bean<?>> filterDefaultScopedBeans(Set<Bean<?>> beans)
{
Set<Bean<?>> result = new HashSet<Bean<?>>(beans.size());
Iterator<Bean<?>> beanIterator = beans.iterator();
Bean<?> currentBean;
while (beanIterator.hasNext())
{
currentBean = beanIterator.next();
if(!Dependent.class.isAssignableFrom(currentBean.getScope()))
{
result.add(currentBean);
}
}
return result;
}
classDeactivator = resolveAndCacheClassDeactivator();
private static ClassDeactivator resolveAndCacheClassDeactivator()
for (Class<?> deactivatedClass : classDeactivator.getDeactivatedClasses())
public static <T> List<T> getContextualReferences(Class<T> type,
boolean optional)
{
return getContextualReferences(type, optional, true);
}
import org.apache.deltaspike.example.echo.DefaultEchoService;
import org.apache.deltaspike.example.optional.OptionalService;
List<EchoService> echoServiceList = BeanProvider.getContextualReferences(EchoService.class, false);
LOG.info(echoService.echo("Hello CDI bean!"));
LOG.info(echoService.echo("Hello non dependent CDI scoped bean!"));
LOG.info("---");
EchoService defaultEchoService = BeanProvider.getContextualReference(DefaultEchoService.class, false);
LOG.info(defaultEchoService.echo("Hello explicitly resolved CDI bean!"));
defaultEchoService = BeanProvider.getContextualReference(EchoService.class, false, "defaultEchoService");
LOG.info(defaultEchoService.echo("Hello CDI bean resolved by name!"));
OptionalService optionalService = BeanProvider.getContextualReference(OptionalService.class, true);
if(optionalService == null)
{
}
else
{
}
import javax.inject.Named;
@Named("defaultEchoService")
public static Object getContextualReference(String name, boolean optional)
{
return getContextualReference(name, optional, Object.class);
}
public static <T> T getContextualReference(String name, boolean optional, Class<T> type)
defaultEchoService = BeanProvider.getContextualReference("defaultEchoService", false, EchoService.class);
package org.apache.deltaspike.test.core.api.provider;
package org.apache.deltaspike.test.core.api.provider;
package org.apache.deltaspike.test.core.api.provider;
package org.apache.deltaspike.test.core.api.provider;
package org.apache.deltaspike.test.core.api.temptestutil;
"If your setup is correct, please clear all caches and compiled artifacts.");
public void setBeanManager(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
{
BeanManagerProvider bmpFirst = setBeanManagerProvider(this);
ClassLoader cl = ClassUtils.getClassLoader(null);
bmpFirst.bms.put(cl, beanManager);
}
public void cleanupStoredBeanManagerOnShutdown(@Observes BeforeShutdown beforeShutdown)
{
bms.remove(ClassUtils.getClassLoader(null));
}
"separator: ';'");
StringBuilder operations = new StringBuilder();
operations.append(operation);
operations.append(" ");
return operations.toString();
configuredOrdinal = Integer.valueOf(configuredOrdinalString.trim());
if (resourceBundle != null && resourceBundle.containsKey(key))
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
public AnnotatedConstructorImpl(AnnotatedTypeImpl<X> type, Constructor<?> constructor, AnnotationStore annotations,
Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> typeOverrides)
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
public AnnotatedFieldImpl(AnnotatedType<X> declaringType, Field field, AnnotationStore annotations,
Type overridenType)
@Override
@Override
@Override
@Override
@Override
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
@Override
@Override
@Override
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
public AnnotatedMethodImpl(AnnotatedType<X> type, Method method, AnnotationStore annotations,
Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> parameterTypeOverrides)
public AnnotatedParameterImpl(AnnotatedCallable<X> declaringCallable, Class<?> type, int position,
AnnotationStore annotations, Type genericType, Type typeOverride)
@Override
@Override
@Override
@Override
@Override
@Override
protected <A extends Annotation> void redefineAnnotationBuilder(Class<A> annotationType,
AnnotationRedefiner<A> redefinition,
AnnotatedElement annotated, Type baseType,
AnnotationBuilder builder, String elementName)
import java.util.Collection;
public AnnotationBuilder addAll(Collection<Annotation> annotations)
private static <X, Y extends Member> List<AnnotatedParameter<X>> getAnnotatedParameters(AnnotatedCallableImpl<X, Y> callable, Class<?>[] parameterTypes, Type[] genericTypes,
Map<Integer, AnnotationStore> parameterAnnotations,
Map<Integer, Type> parameterTypeOverrides)
public AnnotatedTypeImpl(Class<X> clazz, AnnotationStore typeAnnotations, Map<Field, AnnotationStore> fieldAnnotations, Map<Method, AnnotationStore> methodAnnotations,
Map<Method, Map<Integer, AnnotationStore>> methodParameterAnnotations, Map<Constructor<?>, AnnotationStore> constructorAnnotations,
Map<Constructor<?>, Map<Integer, AnnotationStore>> constructorParameterAnnotations, Map<Field, Type> fieldTypes,
Map<Method, Map<Integer, Type>> methodParameterTypes, Map<Constructor<?>, Map<Integer, Type>> constructorParameterTypes)
AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(this, c, constructorAnnotations.get(c), constructorParameterAnnotations.get(c),
constructorParameterTypes.get(c));
AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(this, c.getKey(), c.getValue(), constructorParameterAnnotations.get(c.getKey()),
constructorParameterTypes.get(c.getKey()));
AnnotatedMethodImpl<X> nc = new AnnotatedMethodImpl<X>(this, c.getKey(), c.getValue(), methodParameterAnnotations.get(c.getKey()),
methodParameterTypes.get(c.getKey()));
return (ownerType == null ? thatOwnerType == null : ownerType.equals(thatOwnerType))
&& (rawType == null ? thatRawType == null : rawType.equals(thatRawType))
&& Arrays.equals(actualTypeArguments, that.getActualTypeArguments());
throw new ClassNotFoundException(String.format("Could not load class %s with the context class loader %s or any of the additional ClassLoaders: %s",
name, Thread.currentThread().getContextClassLoader(), loaders));
{
{
}
}
if (binding.annotationType().isAnnotationPresent(Qualifier.class)
&& binding.annotationType().isAnnotationPresent(Retention.class)
&& binding.annotationType().getAnnotation(Retention.class).value().equals(RetentionPolicy.RUNTIME))
package org.apache.deltaspike.integration.util;
package org.apache.deltaspike.integration.category;
package org.apache.deltaspike.integration.category;
package org.apache.deltaspike.integration.category;
import java.util.Collections;
import java.util.Comparator;
appConfigSources = sortDescending(resolveConfigSources());
private static ConfigSource[] sortDescending(List<ConfigSource> configSources)
Collections.sort(configSources, new Comparator<ConfigSource>()
@Override
public int compare(ConfigSource configSource1, ConfigSource configSource2)
return (configSource1.getOrdinal() > configSource2.getOrdinal()) ? -1 : 1 ;
});
return configSources.toArray(new ConfigSource[configSources.size()]);
return 300;
return 200;
return 100;
return 400;
import org.apache.deltaspike.core.api.literal.NamedLiteral;
public interface ConfigSource
static final String DELTASPIKE_ORDINAL = "deltaspike_ordinal";
int getOrdinal();
String getPropertyValue(String key);
String getConfigName();
import org.apache.deltaspike.core.api.util.ClassUtils;
import java.io.IOException;
import java.net.URL;
import java.util.Enumeration;
private static final String PROPERTY_FILE_NAME = "META-INF/apache-deltaspike.properties";
ClassLoader cl = ClassUtils.getClassLoader(this);
try
{
Enumeration<URL> propertyFileUrls = cl.getResources(PROPERTY_FILE_NAME);
while (propertyFileUrls.hasMoreElements())
{
URL propertyFileUrl = propertyFileUrls.nextElement();
this.configSources.add(new PropertyFileConfigSource(propertyFileUrl));
}
}
catch (IOException ioe)
{
throw new RuntimeException("problem while loading DeltaSpike property files", ioe);
}
class EnvironmentPropertyConfigSource implements ConfigSource
private int ordinal = 300;
public EnvironmentPropertyConfigSource()
{
String envOrdinal = System.getenv(ConfigSource.DELTASPIKE_ORDINAL);
if (envOrdinal != null && envOrdinal.length() > 0)
{
ordinal = Integer.parseInt(envOrdinal);
}
}
public int getOrdinal()
return ordinal;
class LocalJndiConfigSource implements ConfigSource
private Integer ordinal = Integer.valueOf(100);
public LocalJndiConfigSource()
String ordinalVal = getPropertyValue(ConfigSource.DELTASPIKE_ORDINAL);
if (ordinalVal != null && ordinalVal.length() > 0)
{
ordinal = Integer.valueOf(ordinalVal);
}
}
@Override
public int getOrdinal()
{
return ordinal;
import java.net.URL;
class PropertyFileConfigSource implements ConfigSource
private Properties properties;
private String fileName;
PropertyFileConfigSource(URL propertyFileUrl)
fileName = propertyFileUrl.toExternalForm();
properties = loadProperties(propertyFileUrl);
String ordinalVal = getPropertyValue(ConfigSource.DELTASPIKE_ORDINAL);
if (ordinalVal != null && ordinalVal.length() > 0)
{
ordinal = Integer.valueOf(ordinalVal);
}
}
private int ordinal = 100;
@Override
public int getOrdinal()
{
return ordinal;
return (String) properties.get(key);
return fileName;
private Properties loadProperties(URL url)
Properties props = new Properties();
InputStream inputStream = null;
inputStream = url.openStream();
if (inputStream != null)
{
props.load(inputStream);
}
catch (IOException e)
finally
if (inputStream != null)
}
catch (IOException e)
{
return props;
class SystemPropertyConfigSource implements ConfigSource
private int ordinal = 400;
SystemPropertyConfigSource()
{
String envOrdinal = getPropertyValue(ConfigSource.DELTASPIKE_ORDINAL);
if (envOrdinal != null && envOrdinal.length() > 0)
{
ordinal = Integer.parseInt(envOrdinal);
}
}
public int getOrdinal()
return ordinal;
import javax.enterprise.context.Dependent;
@Dependent
public class AlwaysActiveBean
@Exclude(ifProjectStage = {ProjectStage.Development.class, ProjectStage.IntegrationTest.class})
class EnvironmentPropertyConfigSource extends BaseConfigSource
initOrdinal(300);
class LocalJndiConfigSource extends BaseConfigSource
initOrdinal(300);
class PropertyFileConfigSource extends BaseConfigSource
initOrdinal(100);
class SystemPropertyConfigSource extends BaseConfigSource
initOrdinal(400);
static String DELTASPIKE_ORDINAL = "deltaspike_ordinal";
package org.apache.deltaspike.test.category;
package org.apache.deltaspike.test.category;
package org.apache.deltaspike.test.category;
import org.apache.webbeans.annotation.NamedLiteral;
private static <X, Y extends Member> List<AnnotatedParameter<X>> getAnnotatedParameters(AnnotatedCallableImpl<X, Y> callable, Class<?>[] parameterTypes, Type[] genericTypes, Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> parameterTypeOverrides)
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
public AnnotatedTypeImpl(Class<X> clazz, AnnotationStore typeAnnotations, Map<Field, AnnotationStore> fieldAnnotations, Map<Method, AnnotationStore> methodAnnotations, Map<Method, Map<Integer, AnnotationStore>> methodParameterAnnotations, Map<Constructor<?>, AnnotationStore> constructorAnnotations, Map<Constructor<?>, Map<Integer, AnnotationStore>> constructorParameterAnnotations, Map<Field, Type> fieldTypes, Map<Method, Map<Integer, Type>> methodParameterTypes, Map<Constructor<?>, Map<Integer, Type>> constructorParameterTypes)
AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(this, c, constructorAnnotations.get(c), constructorParameterAnnotations.get(c), constructorParameterTypes.get(c));
AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(this, c.getKey(), c.getValue(), constructorParameterAnnotations.get(c.getKey()), constructorParameterTypes.get(c.getKey()));
AnnotatedMethodImpl<X> nc = new AnnotatedMethodImpl<X>(this, c.getKey(), c.getValue(), methodParameterAnnotations.get(c.getKey()), methodParameterTypes.get(c.getKey()));
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
return (ownerType == null ? thatOwnerType == null : ownerType.equals(thatOwnerType)) && (rawType == null ? thatRawType == null : rawType.equals(thatRawType)) && Arrays.equals(actualTypeArguments, that.getActualTypeArguments());
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.PrivilegedAction;
if (binding.annotationType().isAnnotationPresent(Qualifier.class) && binding.annotationType().isAnnotationPresent(Retention.class) && binding.annotationType().getAnnotation(Retention.class).value().equals(RetentionPolicy.RUNTIME))
AnnotatedConstructorImpl(AnnotatedTypeImpl<X> type, Constructor<?> constructor, AnnotationStore annotations,
Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> typeOverrides)
AnnotatedFieldImpl(AnnotatedType<X> declaringType, Field field, AnnotationStore annotations, Type overridenType)
AnnotatedMethodImpl(AnnotatedType<X> type, Method method, AnnotationStore annotations,
Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> parameterTypeOverrides)
AnnotatedParameterImpl(AnnotatedCallable<X> declaringCallable, Class<?> type, int position,
AnnotationStore annotations, Type genericType, Type typeOverride)
protected <A extends Annotation> void redefineAnnotationBuilder(Class<A> annotationType, AnnotationRedefiner<A> redefinition, AnnotatedElement annotated, Type baseType, AnnotationBuilder builder, String elementName)
public AnnotationBuilder addAll(Set<Annotation> annotations)
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
public AnnotatedConstructorImpl(AnnotatedTypeImpl<X> type, Constructor<?> constructor, AnnotationStore annotations,
Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> typeOverrides)
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
public AnnotatedFieldImpl(AnnotatedType<X> declaringType, Field field, AnnotationStore annotations,
Type overridenType)
@Override
@Override
@Override
@Override
@Override
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
@Override
@Override
@Override
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
public AnnotatedMethodImpl(AnnotatedType<X> type, Method method, AnnotationStore annotations,
Map<Integer, AnnotationStore> parameterAnnotations, Map<Integer, Type> parameterTypeOverrides)
public AnnotatedParameterImpl(AnnotatedCallable<X> declaringCallable, Class<?> type, int position,
AnnotationStore annotations, Type genericType, Type typeOverride)
@Override
@Override
@Override
@Override
@Override
@Override
protected <A extends Annotation> void redefineAnnotationBuilder(Class<A> annotationType,
AnnotationRedefiner<A> redefinition,
AnnotatedElement annotated, Type baseType,
AnnotationBuilder builder, String elementName)
import java.util.Collection;
public AnnotationBuilder addAll(Collection<Annotation> annotations)
private static <X, Y extends Member> List<AnnotatedParameter<X>> getAnnotatedParameters(AnnotatedCallableImpl<X, Y> callable, Class<?>[] parameterTypes, Type[] genericTypes,
Map<Integer, AnnotationStore> parameterAnnotations,
Map<Integer, Type> parameterTypeOverrides)
public AnnotatedTypeImpl(Class<X> clazz, AnnotationStore typeAnnotations, Map<Field, AnnotationStore> fieldAnnotations, Map<Method, AnnotationStore> methodAnnotations,
Map<Method, Map<Integer, AnnotationStore>> methodParameterAnnotations, Map<Constructor<?>, AnnotationStore> constructorAnnotations,
Map<Constructor<?>, Map<Integer, AnnotationStore>> constructorParameterAnnotations, Map<Field, Type> fieldTypes,
Map<Method, Map<Integer, Type>> methodParameterTypes, Map<Constructor<?>, Map<Integer, Type>> constructorParameterTypes)
AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(this, c, constructorAnnotations.get(c), constructorParameterAnnotations.get(c),
constructorParameterTypes.get(c));
AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(this, c.getKey(), c.getValue(), constructorParameterAnnotations.get(c.getKey()),
constructorParameterTypes.get(c.getKey()));
AnnotatedMethodImpl<X> nc = new AnnotatedMethodImpl<X>(this, c.getKey(), c.getValue(), methodParameterAnnotations.get(c.getKey()),
methodParameterTypes.get(c.getKey()));
return (ownerType == null ? thatOwnerType == null : ownerType.equals(thatOwnerType))
&& (rawType == null ? thatRawType == null : rawType.equals(thatRawType))
&& Arrays.equals(actualTypeArguments, that.getActualTypeArguments());
throw new ClassNotFoundException(String.format("Could not load class %s with the context class loader %s or any of the additional ClassLoaders: %s",
name, Thread.currentThread().getContextClassLoader(), loaders));
{
{
}
}
if (binding.annotationType().isAnnotationPresent(Qualifier.class)
&& binding.annotationType().isAnnotationPresent(Retention.class)
&& binding.annotationType().getAnnotation(Retention.class).value().equals(RetentionPolicy.RUNTIME))
import org.apache.deltaspike.core.api.literal.NamedLiteral;
public interface AnnotationRedefiner
public void redefine(RedefinitionContext ctx);
public class RedefinitionContext
package org.apache.deltaspike.core.api.metadata.builder;
package org.apache.deltaspike.core.api.metadata.builder;
package org.apache.deltaspike.core.api.metadata.builder;
package org.apache.deltaspike.core.api.metadata.builder;
package org.apache.deltaspike.core.api.metadata.builder;
package org.apache.deltaspike.core.api.metadata.builder;
package org.apache.deltaspike.core.api.metadata.builder;
public <A extends Annotation> AnnotatedTypeBuilder<X> redefine(Class<A> annotationType, AnnotationRedefiner redefinition)
AnnotationRedefiner redefinition,
redefinition.redefine(new RedefinitionContext(annotated, baseType, builder, elementName));
package org.apache.deltaspike.core.api.metadata.builder;
class AnnotatedTypeImpl<X> extends AnnotatedImpl implements AnnotatedType<X>
AnnotatedTypeImpl(Class<X> clazz, AnnotationStore typeAnnotations, Map<Field, AnnotationStore> fieldAnnotations, Map<Method, AnnotationStore> methodAnnotations,
package org.apache.deltaspike.core.api.metadata.builder;
class AnnotationStore
AnnotationStore(Map<Class<? extends Annotation>, Annotation> annotationMap, Set<Annotation> annotationSet)
AnnotationStore()
<T extends Annotation> T getAnnotation(Class<T> annotationType)
Set<Annotation> getAnnotations()
boolean isAnnotationPresent(Class<? extends Annotation> annotationType)
package org.apache.deltaspike.core.api.metadata.builder;
abstract class Parameter<X> implements AnnotatedElement
package org.apache.deltaspike.core.api.util;
class ParameterizedTypeImpl implements ParameterizedType
ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type ownerType)
public class NamedAnnotationRedefiner implements AnnotationRedefiner
public void redefine(RedefinitionContext ctx)
@Named("DefaultEchoService")
private static <X, Y extends Member> List<AnnotatedParameter<X>> getAnnotatedParameters(
AnnotatedCallableImpl<X, Y> callable, Class<?>[] parameterTypes, Type[] genericTypes,
Map<Integer, AnnotationStore> parameterAnnotations,
Map<Integer, Type> parameterTypeOverrides)
AnnotatedParameterImpl<X> p = new AnnotatedParameterImpl<X>(
callable, parameterTypes[i], i, builder.create(), genericTypes[i], over);
Map<Integer, AnnotationStore> parameterAnnotations,
Map<Integer, Type> typeOverrides)
public AnnotatedMethodImpl(AnnotatedType<X> type,
Method method,
AnnotationStore annotations,
Map<Integer, AnnotationStore> parameterAnnotations,
Map<Integer, Type> parameterTypeOverrides)
public AnnotatedTypeBuilder<X> removeFromField(AnnotatedField<? super X> field,
Class<? extends Annotation> annotationType)
public AnnotatedTypeBuilder<X> removeFromMethod(AnnotatedMethod<? super X> method,
Class<? extends Annotation> annotationType)
public AnnotatedTypeBuilder<X> removeFromMethodParameter(Method method,
int position, Class<? extends Annotation> annotationType)
throw new IllegalArgumentException(
String.format("parameter %s not present on method %s declared on class %s",
public AnnotatedTypeBuilder<X> removeFromConstructor(Constructor<X> constructor,
Class<? extends Annotation> annotationType)
public AnnotatedTypeBuilder<X> removeFromConstructor(AnnotatedConstructor<X> constructor,
Class<? extends Annotation> annotationType)
public AnnotatedTypeBuilder<X> addToConstructorParameter(Constructor<X> constructor,
int position,
Annotation annotation)
public AnnotatedTypeBuilder<X> removeFromConstructorParameter(Constructor<X> constructor,
int position,
Class<? extends Annotation> annotationType)
public AnnotatedTypeBuilder<X> removeFromParameter(AnnotatedParameter<? super X> parameter,
Class<? extends Annotation> annotationType)
for (Map.Entry<Integer, AnnotationBuilder> parameter :
constructorParameters.get(constructor.getKey()).entrySet())
mergeAnnotationsOnElement(
p, overwrite, methodParameters.get(method.getJavaMember()).get(p.getPosition()));
if (constructorParameters.get(
constructor.getJavaMember()) == null)
constructorParameters.put(
constructor.getJavaMember(), new HashMap<Integer, AnnotationBuilder>());
if (constructorParameters.get(
constructor.getJavaMember()).get(p.getPosition()) == null)
constructorParameters.get(
constructor.getJavaMember()).put(p.getPosition(), new AnnotationBuilder());
mergeAnnotationsOnElement(
p, overwrite, constructorParameters.get(constructor.getJavaMember()).get(p.getPosition()));
protected void mergeAnnotationsOnElement(Annotated annotated,
boolean overwriteExisting,
AnnotationBuilder typeAnnotations)
Map<Constructor<?>, Map<Integer, AnnotationStore>> constructorParameterAnnnotations =
new HashMap<Constructor<?>, Map<Integer, AnnotationStore>>();
Map<Constructor<?>, AnnotationStore> constructorAnnotations =
new HashMap<Constructor<?>, AnnotationStore>();
Map<Method, Map<Integer, AnnotationStore>> methodParameterAnnnotations =
new HashMap<Method, Map<Integer, AnnotationStore>>();
Map<Method, AnnotationStore> methodAnnotations =
new HashMap<Method, AnnotationStore>();
Map<Field, AnnotationStore> fieldAnnotations =
new HashMap<Field, AnnotationStore>();
AnnotatedTypeImpl(Class<X> clazz,
AnnotationStore typeAnnotations,
Map<Field, AnnotationStore> fieldAnnotations,
Map<Method, AnnotationStore> methodAnnotations,
Map<Method, Map<Integer, AnnotationStore>> methodParameterAnnotations,
Map<Constructor<?>, AnnotationStore> constructorAnnotations,
Map<Constructor<?>, Map<Integer, AnnotationStore>> constructorParameterAnnotations,
Map<Field, Type> fieldTypes,
Map<Method, Map<Integer, Type>> methodParameterTypes,
Map<Constructor<?>, Map<Integer, Type>> constructorParameterTypes)
AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(
this, c, constructorAnnotations.get(c), constructorParameterAnnotations.get(c),
AnnotatedConstructor<X> nc = new AnnotatedConstructorImpl<X>(
this, c.getKey(), c.getValue(), constructorParameterAnnotations.get(c.getKey()),
AnnotatedMethodImpl<X> met = new AnnotatedMethodImpl<X>(this, m, methodAnnotations.get(m),
methodParameterAnnotations.get(m), methodParameterTypes.get(m));
AnnotatedMethodImpl<X> nc = new AnnotatedMethodImpl<X>(
this, c.getKey(),
c.getValue(),
methodParameterAnnotations.get(c.getKey()),
throw new IllegalArgumentException(
return this.getDeclaringMember().equals(that.getDeclaringMember()) &&
this.getPosition() == that.getPosition();
import javax.enterprise.inject.Typed;
@Typed()
@SuppressWarnings("UnnecessaryLocalVariable")
ParameterizedType parameterizedType =
new ParameterizedTypeImpl(clazz, actualTypeParameters, clazz.getDeclaringClass());
import javax.enterprise.inject.Typed;
@Typed()
return Arrays.hashCode(actualTypeArguments) ^ (ownerType == null ? 0 :
ownerType.hashCode()) ^ (rawType == null ? 0 : rawType.hashCode());
import javax.enterprise.inject.Typed;
@Typed()
private Reflections()
{
}
if (annotatedField.getDeclaringType().getJavaClass().equals(field.getDeclaringClass()) &&
annotatedField.getJavaMember().getName().equals(field.getName()))
public static Set<Annotation> getAnnotationsWithMetaAnnotation(Set<Annotation> annotations,
Class<? extends Annotation> metaAnnotationType)
throw new ClassNotFoundException(String.format(
"Could not load class %s with the context class loader %s or any of the additional ClassLoaders: %s",
name, Thread.currentThread().getContextClassLoader(), loaders));
StringBuilder message = new StringBuilder(String.format(
"Exception invoking method [%s] on object [%s], using arguments [", method.getName(), obj));
message.append(i > 0 ? "," : "")
.append(args[i]);
public static <T> T invokeMethod(boolean setAccessible,
Method method, Class<T> expectedReturnType,
Object instance, Object... args)
ExceptionInInitializerError e2 =
new ExceptionInInitializerError(buildInvokeMethodErrorMessage(method, instance, args));
ExceptionInInitializerError e2 =
new ExceptionInInitializerError(buildSetFieldValueErrorMessage(field, instance, value));
ExceptionInInitializerError e2 =
new ExceptionInInitializerError(buildGetFieldValueErrorMessage(field, instance));
public static boolean isAssignableFrom(Class<?> rawType1,
Type[] actualTypeArguments1,
Class<?> rawType2,
Type[] actualTypeArguments2)
return Types.boxedClass(rawType1).isAssignableFrom(Types.boxedClass(rawType2)) &&
isAssignableFrom(actualTypeArguments1, actualTypeArguments2);
public static boolean matches(Class<?> rawType1,
Type[] actualTypeArguments1,
Class<?> rawType2,
Type[] actualTypeArguments2)
return Types.boxedClass(rawType1).equals(Types.boxedClass(rawType2)) &&
isAssignableFrom(actualTypeArguments1, actualTypeArguments2);
if (isAssignableFrom((Class<?>) parameterizedType1.getRawType(),
parameterizedType1.getActualTypeArguments(),
type2))
if (matches((Class<?>) parameterizedType1.getRawType(),
parameterizedType1.getActualTypeArguments(),
type2))
if (isAssignableFrom(
rawType1,
actualTypeArguments1,
(Class<?>) parameterizedType.getRawType(),
parameterizedType.getActualTypeArguments()))
if (matches(
rawType1,
actualTypeArguments1,
(Class<?>) parameterizedType.getRawType(),
parameterizedType.getActualTypeArguments()))
return rawType != null && rawType.isPrimitive();
import javax.enterprise.inject.Typed;
@Typed()
import javax.enterprise.inject.Typed;
@Typed()
private Types()
{
}
protected Logger log = Logger.getLogger(getClass().getName());
log.log(Level.WARNING,
@Override
private static final Logger LOG = Logger.getLogger(ConfigResolver.class.getName());
= new ConcurrentHashMap<ClassLoader, ConfigSource[]>();
private ConfigResolver()
{
}
= ServiceLoader.load(ConfigSourceProvider.class);
@Target({ ElementType.TYPE })
Class<? extends ProjectStage>[] ifProjectStage() default { };
Class<? extends ProjectStage>[] exceptIfProjectStage() default { };
private static final String ASTERISK = "*";
@Override
for (String expression : foundExpressions)
if (expression.contains(SimpleOperationEnum.IS.getValue()))
else if (expression.contains(SimpleOperationEnum.NOT.getValue()))
if (configuredValue != null)
if (!ASTERISK.equals(keyValue[1]) && "".equals(configuredValue))
if (ASTERISK.equals(keyValue[1]) && !"".equals(configuredValue))
if (SimpleOperationEnum.IS.equals(operation) && !keyValue[1].equalsIgnoreCase(configuredValue))
else if (SimpleOperationEnum.NOT.equals(operation) && keyValue[1].equalsIgnoreCase(configuredValue))
for (SimpleOperationEnum operation : SimpleOperationEnum.values())
@Override
private final Class<?>[] value;
private final int position;
Parameter(int position)
{
this.position = position;
}
public abstract Member getDeclaringMember();
public int getPosition()
{
return position;
}
@Override
public int hashCode()
{
int hash = 1;
return hash;
}
@Override
public boolean equals(Object obj)
{
if (obj instanceof Parameter<?>)
{
Parameter<?> that = (Parameter<?>) obj;
return this.getDeclaringMember().equals(that.getDeclaringMember()) &&
this.getPosition() == that.getPosition();
}
else
{
return false;
}
}
public <T extends Annotation> T getAnnotation(Class<T> annotationClass)
{
for (Annotation annotation : getAnnotations())
{
if (annotation.annotationType().equals(annotationClass))
{
return annotationClass.cast(annotation);
}
}
return null;
}
public Annotation[] getDeclaredAnnotations()
{
return getAnnotations();
}
public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)
{
return getAnnotation(annotationClass) != null;
}
public abstract Type getBaseType();
if (bmp == null)
if (bmp == null)
if (result != null)
if (!includeDefaultScopedBeans)
for (Bean<?> bean : beans)
new HashSet<Bean<?>>((Collection) Arrays.asList(new Object[]{bean}))));
if (!Dependent.class.isAssignableFrom(currentBean.getScope()))
@SuppressWarnings({ "unchecked", "UnnecessaryLocalVariable" })
T result = (T) beanManager.getReference(bean, type, creationalContext);
@Override
throws ClassNotFoundException, IllegalAccessException, InstantiationException
private Reflections()
{
}
String DELTASPIKE_ORDINAL = "deltaspike_ordinal";
if (configuredOrdinalString != null)
@Override
private static final long serialVersionUID = -2987762608635612074L;
protected ProjectStageProducer()
{
}
if (projectStage == null)
if (projectStage == null)
if (customProjectStageProducerName != null)
if (customConfiguredProducer != null)
if (projectStageProducer == null)
if (projectStage == null)
if (projectStage == null)
for (String classDeactivatorClassName : classDeactivatorClassNames)
if (currentClassDeactivator != null)
= new ConcurrentHashMap<ClassLoader, ClassDeactivator>();
private ClassDeactivatorStorage()
{
}
public final synchronized Set<Class> getDeactivatedClasses()
Boolean isActivated(Class<? extends Deactivatable> deactivatableClazz);
import org.apache.deltaspike.core.api.activation.ClassDeactivation;
private Boolean isActivated = null;
if (isActivated == null)
{
isActivated = ClassDeactivation.isActivated(getClass());
}
return isActivated;
import org.apache.deltaspike.core.api.activation.Deactivatable;
public class ActivatedClass implements Deactivatable
import org.apache.deltaspike.core.api.activation.Deactivatable;
public class DeactivatedClass implements Deactivatable
private static Map<Class<? extends Deactivatable>, Boolean> activationStatusCache
= new ConcurrentHashMap<Class<? extends Deactivatable>, Boolean>();
public static boolean isActivated(Class<? extends Deactivatable> targetClass)
Boolean activatedClassCacheEntry = activationStatusCache.get(targetClass);
if (activatedClassCacheEntry == null)
{
initDeactivatableCacheFor(targetClass);
activatedClassCacheEntry = activationStatusCache.get(targetClass);
}
return activatedClassCacheEntry;
}
private static synchronized void initDeactivatableCacheFor(Class<? extends Deactivatable> targetClass)
{
Boolean activatedClassCacheEntry = activationStatusCache.get(targetClass);
{
return;
}
Boolean isActivated = null;
Boolean isLocallyActivated;
Class<? extends ClassDeactivator> deactivationDetected = null;
isLocallyActivated = classDeactivator.isActivated(targetClass);
if (Boolean.FALSE.equals(isActivated))
{
deactivationDetected = classDeactivator.getClass();
}
else if (Boolean.TRUE.equals(isActivated) && deactivationDetected != null)
{
LOG.fine("If that isn't the intended behaviour, you have to use a higher ordinal for "
deactivationDetected.getName());
}
cacheResult(targetClass, isActivated);
private static void cacheResult(Class<? extends Deactivatable> targetClass, Boolean activated)
{
if (Boolean.FALSE.equals(activated))
{
activationStatusCache.put(targetClass, false);
}
{
activationStatusCache.put(targetClass, true);
}
}
ClassLoader classLoader = ClassUtils.getClassLoader(null);
List<ClassDeactivator> classDeactivators = classDeactivatorMap.get(classLoader);
return initConfiguredClassDeactivators(classLoader);
private static List<ClassDeactivator> initConfiguredClassDeactivators(ClassLoader classLoader)
throw new IllegalStateException(e);
classDeactivatorMap.put(classLoader, classDeactivators);
Boolean isActivated = Boolean.TRUE;
Class<? extends ClassDeactivator> deactivatedBy = null;
Boolean isLocallyActivated = classDeactivator.isActivated(targetClass);
if (!isActivated)
{
deactivatedBy = classDeactivator.getClass();
}
else if (isActivated && deactivatedBy != null)
{
classDeactivator.getClass().getName()
"If that isn't the intended behaviour, you have to use a higher ordinal for "
deactivatedBy.getName());
}
activationStatusCache.put(targetClass, activated);
else if (deactivatedBy != null)
package org.apache.deltaspike.core.spi.activation;
package org.apache.deltaspike.core.spi.activation;
package org.apache.deltaspike.core.spi.activation.util;
import org.apache.deltaspike.core.spi.activation.ClassDeactivator;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.spi.activation.util.ClassDeactivation;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
protected void setBeanManager(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
protected void cleanupStoredBeanManagerOnShutdown(@Observes BeforeShutdown beforeShutdown)
import javax.enterprise.event.Observes;
import javax.enterprise.inject.spi.BeanManager;
protected void doSomeObservation(@Observes Cat cat, BeanManager beanManager)
{
this.color = cat.color;
}
Boolean isActivated(Class<? extends Deactivatable> targetClass);
package org.apache.deltaspike.core.api.projectstage;
protected void reset()
{
projectStage = null;
projectStageProducer = null;
}
public static void setProjectStage(ProjectStage ps)
{
projectStage = ps;
}
import org.apache.deltaspike.core.api.projectstage.ProjectStageProducer;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.HierarchyDiscovery;
import org.apache.deltaspike.core.util.Reflections;
import org.apache.deltaspike.core.util.Reflections;
import org.apache.deltaspike.core.util.ClassUtils;
package org.apache.deltaspike.core.util;
package org.apache.deltaspike.core.util;
import javax.enterprise.inject.Typed;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.jar.Manifest;
import java.util.jar.Attributes;
import java.net.URL;
@Typed()
public abstract class ClassUtils
{
private ClassUtils()
{
}
public static ClassLoader getClassLoader(Object o)
{
ClassLoader loader = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>()
{
@Override
public ClassLoader run()
{
try
{
return Thread.currentThread().getContextClassLoader();
}
catch (Exception e)
{
return null;
}
}
}
);
if (loader == null && o != null)
{
loader = o.getClass().getClassLoader();
}
if (loader == null)
{
loader = ClassUtils.class.getClassLoader();
}
return loader;
}
public static <T> Class<T> tryToLoadClassForName(String name, Class<T> targetType)
{
return (Class<T>) tryToLoadClassForName(name);
}
public static Class tryToLoadClassForName(String name)
{
try
{
return loadClassForName(name);
}
catch (ClassNotFoundException e)
{
return null;
}
}
public static Class loadClassForName(String name) throws ClassNotFoundException
{
try
{
getClassLoader(null));
}
catch (ClassNotFoundException ignore)
{
ClassUtils.class.getClassLoader());
}
}
public static <T> T tryToInstantiateClass(Class<T> targetClass)
{
try
{
return targetClass.newInstance();
}
catch (InstantiationException e)
{
}
catch (IllegalAccessException e)
{
}
return null;
}
public static <T> T tryToInstantiateClassForName(String className, Class<T> targetType)
{
Object result = tryToInstantiateClassForName(className);
return result != null ? (T) result : null;
}
public static Object tryToInstantiateClassForName(String className)
{
try
{
return instantiateClassForName(className);
}
catch (Exception e)
{
}
return null;
}
public static Object instantiateClassForName(String className)
throws ClassNotFoundException, IllegalAccessException, InstantiationException
{
return loadClassForName(className).newInstance();
}
public static String getJarVersion(Class targetClass)
{
String manifestFileLocation = getManifestFileLocationOfClass(targetClass);
try
{
return new Manifest(new URL(manifestFileLocation).openStream())
.getMainAttributes().getValue(Attributes.Name.IMPLEMENTATION_VERSION);
}
catch (Exception e)
{
return null;
}
}
public static String getRevision(Class targetClass)
{
String manifestFileLocation = getManifestFileLocationOfClass(targetClass);
try
{
return new Manifest(new URL(manifestFileLocation).openStream())
.getMainAttributes().getValue("Revision");
}
catch (Exception e)
{
return null;
}
}
private static String getManifestFileLocationOfClass(Class targetClass)
{
String manifestFileLocation;
try
{
manifestFileLocation = getManifestLocation(targetClass);
}
catch (Exception e)
{
manifestFileLocation = getManifestLocation(targetClass.getSuperclass());
}
return manifestFileLocation;
}
private static String getManifestLocation(Class targetClass)
{
String manifestFilePath = "/META-INF/MANIFEST.MF";
}
}
package org.apache.deltaspike.core.util;
package org.apache.deltaspike.core.util;
package org.apache.deltaspike.core.util;
import org.apache.deltaspike.core.api.projectstage.ProjectStage;
package org.apache.deltaspike.core.util;
package org.apache.deltaspike.core.util;
package org.apache.deltaspike.core.util;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.ProjectStageProducer;
import org.apache.deltaspike.core.util.ClassDeactivation;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.ClassUtils;
public interface ProjectStageHolder
@Override
throw new IllegalStateException(e);
return Reflections.<T>cast(field.get(instance));
if (result == null)
throw new IllegalStateException("Unable to find BeanManager. "
"Please ensure that you configured the CDI implementation of your choice properly.");
bms.put(classLoader, result);
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.core.util.ClassDeactivation;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.ProjectStageProducer;
import javax.enterprise.inject.Alternative;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.util.Nonbinding;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
private Boolean isGlobalAlternativeActivated = null;
protected void vetoBeans(@Observes ProcessAnnotatedType<Object> processAnnotatedType, BeanManager beanManager)
initActivation();
if (this.isGlobalAlternativeActivated)
{
activateGlobalAlternatives(processAnnotatedType, beanManager);
}
if (!this.isActivated)
if (!processAnnotatedType.getAnnotatedType().getJavaClass().isAnnotationPresent(Exclude.class))
{
return;
}
private void activateGlobalAlternatives(ProcessAnnotatedType<Object> processAnnotatedType, BeanManager beanManager)
{
Class<Object> currentBean = processAnnotatedType.getAnnotatedType().getJavaClass();
Set<Class> beanBaseTypes = resolveBeanTypes(currentBean);
boolean isAlternativeBeanImplementation = currentBean.isAnnotationPresent(Alternative.class);
List<Annotation> qualifiersOfCurrentBean =
resolveQualifiers(processAnnotatedType.getAnnotatedType().getAnnotations(), beanManager);
String configuredBeanName;
List<Annotation> qualifiersOfConfiguredBean;
Class<Object> alternativeBeanClass;
Set<Annotation> alternativeBeanAnnotations;
for (Class currentType : beanBaseTypes)
{
alternativeBeanAnnotations = new HashSet<Annotation>();
configuredBeanName = ConfigResolver.getPropertyValue(currentType.getName());
if (configuredBeanName != null && configuredBeanName.length() > 0)
{
alternativeBeanClass = ClassUtils.tryToLoadClassForName(configuredBeanName);
if (alternativeBeanClass == null)
{
}
alternativeBeanAnnotations.addAll(Arrays.asList(alternativeBeanClass.getAnnotations()));
qualifiersOfConfiguredBean = resolveQualifiers(alternativeBeanAnnotations, beanManager);
}
else
{
continue;
}
if (isAlternativeBeanImplementation)
{
if (doQualifiersMatch(qualifiersOfCurrentBean, qualifiersOfConfiguredBean))
{
processAnnotatedType.veto();
break;
}
}
else
{
if (!alternativeBeanClass.isAnnotationPresent(Alternative.class))
{
continue;
}
if (doQualifiersMatch(qualifiersOfCurrentBean, qualifiersOfConfiguredBean))
{
AnnotatedTypeBuilder<Object> annotatedTypeBuilder
= new AnnotatedTypeBuilder<Object>().readFromType(alternativeBeanClass);
annotatedTypeBuilder.removeFromClass(Alternative.class);
processAnnotatedType.setAnnotatedType(annotatedTypeBuilder.create());
}
}
}
}
private boolean doQualifiersMatch(List<Annotation> qualifiersOfCurrentBean,
List<Annotation> qualifiersOfConfiguredBean)
{
if (qualifiersOfCurrentBean.size() != qualifiersOfConfiguredBean.size())
{
return false;
}
int matchingQualifiers = 0;
for (Annotation currentQualifier : qualifiersOfCurrentBean)
{
for (Annotation qualifierConfiguredBean : qualifiersOfConfiguredBean)
{
if (doesQualifierMatch(currentQualifier, qualifierConfiguredBean))
{
matchingQualifiers;
break;
}
}
}
return qualifiersOfConfiguredBean.size() == matchingQualifiers;
}
private boolean doesQualifierMatch(Annotation currentQualifier, Annotation qualifierConfiguredBean)
{
if (!currentQualifier.annotationType().equals(qualifierConfiguredBean.annotationType()))
{
return false;
}
Object currentValue;
Object valueOfQualifierConfiguredBean;
for (Method currentMethod : currentQualifier.annotationType().getDeclaredMethods())
{
if (currentMethod.isAnnotationPresent(Nonbinding.class))
{
continue;
}
try
{
currentMethod.setAccessible(true);
currentValue = currentMethod.invoke(currentQualifier);
valueOfQualifierConfiguredBean = currentMethod.invoke(qualifierConfiguredBean);
if (!currentValue.equals(valueOfQualifierConfiguredBean))
{
return false;
}
}
catch (Exception e)
{
}
}
return true;
}
private List<Annotation> resolveQualifiers(Set<Annotation> annotations, BeanManager beanManager)
{
List<Annotation> result = new ArrayList<Annotation>();
for (Annotation annotation : annotations)
{
if (beanManager.isQualifier(annotation.annotationType()))
{
result.add(annotation);
}
}
return result;
}
private Set<Class> resolveBeanTypes(Class beanClass)
{
Set<Class> result = new HashSet<Class>();
Class<?> currentClass = beanClass;
while (currentClass != null && !Object.class.getName().equals(currentClass.getName()))
{
result.add(currentClass);
for (Class interfaceClass : currentClass.getInterfaces())
{
if (interfaceClass.getName().startsWith("java.") || interfaceClass.getName().startsWith("javax."))
{
continue;
}
result.addAll(resolveBeanTypes(interfaceClass));
}
currentClass = currentClass.getSuperclass();
}
return result;
}
public void initActivation()
isGlobalAlternativeActivated = ClassDeactivation.isActivated(GlobalAlternative.class);
continue;
private static Boolean isOwbDetected = null;
detectCdiImplementation();
if (isOwbDetected)
{
activateGlobalAlternativesOwb(processAnnotatedType, beanManager);
}
else
{
activateGlobalAlternativesWeld(processAnnotatedType, beanManager);
}
private void activateGlobalAlternativesWeld(ProcessAnnotatedType<Object> processAnnotatedType,
BeanManager beanManager)
{
Class<Object> currentBean = processAnnotatedType.getAnnotatedType().getJavaClass();
if (currentBean.isInterface())
{
return;
}
Set<Class> beanBaseTypes = resolveBeanTypes(currentBean);
boolean isAlternativeBeanImplementation = currentBean.isAnnotationPresent(Alternative.class);
List<Annotation> qualifiersOfCurrentBean =
resolveQualifiers(processAnnotatedType.getAnnotatedType().getAnnotations(), beanManager);
String configuredBeanName;
List<Annotation> qualifiersOfConfiguredBean;
Class<Object> alternativeBeanClass;
Set<Annotation> alternativeBeanAnnotations;
for (Class currentType : beanBaseTypes)
{
alternativeBeanAnnotations = new HashSet<Annotation>();
configuredBeanName = ConfigResolver.getPropertyValue(currentType.getName());
if (configuredBeanName != null && configuredBeanName.length() > 0)
{
alternativeBeanClass = ClassUtils.tryToLoadClassForName(configuredBeanName);
if (alternativeBeanClass == null)
{
}
if (!alternativeBeanClass.isAnnotationPresent(Alternative.class))
{
continue;
}
alternativeBeanAnnotations.addAll(Arrays.asList(alternativeBeanClass.getAnnotations()));
qualifiersOfConfiguredBean = resolveQualifiers(alternativeBeanAnnotations, beanManager);
}
else
{
continue;
}
{
if (doQualifiersMatch(qualifiersOfCurrentBean, qualifiersOfConfiguredBean))
{
AnnotatedTypeBuilder<Object> annotatedTypeBuilder
= new AnnotatedTypeBuilder<Object>().readFromType(processAnnotatedType.getAnnotatedType());
annotatedTypeBuilder.removeFromClass(Alternative.class);
processAnnotatedType.setAnnotatedType(annotatedTypeBuilder.create());
return;
}
}
{
if (doQualifiersMatch(qualifiersOfCurrentBean, qualifiersOfConfiguredBean))
{
processAnnotatedType.veto();
return;
}
}
}
}
private void activateGlobalAlternativesOwb(ProcessAnnotatedType<Object> processAnnotatedType,
BeanManager beanManager)
if (currentBean.isInterface())
{
return;
}
private void detectCdiImplementation()
{
if (isOwbDetected == null)
{
isOwbDetected = false;
RuntimeException runtimeException = new RuntimeException();
for (StackTraceElement element : runtimeException.getStackTrace())
{
if (element.toString().contains("org.apache.webbeans."))
{
isOwbDetected = true;
break;
}
}
}
}
initOrdinal(200);
void bootContainer();
void shutdownContainer();
public void bootContainer()
public void shutdownContainer()
import org.apache.deltaspike.containerctrl.api.ContainerControl;
import org.apache.deltaspike.containerctrl.api.ContainerControlLoader;
import javax.enterprise.context.ApplicationScoped;
private SimpleBeanLookupExample()
{
}
ContainerControl containerControl = ContainerControlLoader.getCdiContainer();
containerControl.bootContainer();
containerControl.startContext(ApplicationScoped.class);
for (EchoService echoService : echoServiceList)
for (EchoService echoService : echoServiceList)
if (optionalService == null)
else
containerControl.stopContext(ApplicationScoped.class);
containerControl.shutdownContainer();
if (namedAnnotation != null &&
.addToClass(new NamedLiteral(newBeanName));
package org.apache.deltaspike.cdise.api;
public interface CdiContainer
package org.apache.deltaspike.cdise.api;
public final class CdiContainerLoader
private CdiContainerLoader()
public static CdiContainer getCdiContainer()
CdiContainer testContainer;
ServiceLoader<CdiContainer> cdiContainerLoader = ServiceLoader.load(CdiContainer.class);
Iterator<CdiContainer> cdiIt = cdiContainerLoader.iterator();
throw new RuntimeException("Could not find a CdiContainer available in the classpath!");
throw new RuntimeException("Too many CdiContainer found in the classpath!");
package org.apache.deltaspike.cdise.owb;
package org.apache.deltaspike.cdise.owb;
package org.apache.deltaspike.cdise.owb;
import org.apache.deltaspike.cdise.api.CdiContainer;
public class OpenWebBeansContainerControl implements CdiContainer
package org.apache.deltaspike.cdise.tck.beans;
package org.apache.deltaspike.cdise.tck.beans;
package org.apache.deltaspike.cdise.tck.beans;
import org.apache.deltaspike.cdise.api.CdiContainer;
import org.apache.deltaspike.cdise.api.CdiContainerLoader;
CdiContainer cdiContainer = CdiContainerLoader.getCdiContainer();
cdiContainer.bootContainer();
cdiContainer.startContext(ApplicationScoped.class);
cdiContainer.stopContext(ApplicationScoped.class);
cdiContainer.shutdownContainer();
import java.util.Arrays;
LOG.log(Level.FINE, "found value {0} for key {1} in ConfigSource {2}.",
return null;
List<ConfigSource> appConfigSources = sortAscending(Arrays.asList(getConfigSources()));
if (LOG.isLoggable(Level.FINE))
LOG.log(Level.FINE, "Adding ordinal {0} ConfigSource {1}",
return (configSource1.getOrdinal() > configSource2.getOrdinal()) ? -1 : 1;
private static List<ConfigSource> sortAscending(List<ConfigSource> configSources)
{
Collections.sort(configSources, new Comparator<ConfigSource>()
{
@Override
public int compare(ConfigSource configSource1, ConfigSource configSource2)
{
return (configSource1.getOrdinal() > configSource2.getOrdinal()) ? 1 : -1;
}
});
return configSources;
}
" available in the classpath!");
String foundContainers = getContainerDetails();
private static String getContainerDetails()
{
StringBuilder result = new StringBuilder();
Class containerClass;
for (CdiContainer cdiContainer : ServiceLoader.load(CdiContainer.class))
{
containerClass = cdiContainer.getClass();
result.append(containerClass.getProtectionDomain().getCodeSource().getLocation().toExternalForm());
result.append(containerClass.getName());
result.append(System.getProperty("line.separator"));
}
return result.toString();
}
private static final Logger LOG = Logger.getLogger(OpenWebBeansContainerControl.class.getName());
logDestroyOfInactiveContext(Singleton.class.getName());
logDestroyOfInactiveContext(ApplicationScoped.class.getName());
logDestroyOfInactiveContext(ConversationScoped.class.getName());
logDestroyOfInactiveContext(RequestScoped.class.getName());
logDestroyOfInactiveContext(SessionScoped.class.getName());
private void logDestroyOfInactiveContext(String contextName)
{
LOG.log(Level.WARNING,
}
private static final long serialVersionUID = -4171521313675763849L;
private static final long serialVersionUID = 6805980497117269525L;
if (constructorParameters.get(constructor) != null &&
constructorParameters.get(constructor).get(position) != null)
constructorParameters.get(constructor).get(position).remove(annotationType);
Reflections.setAccessible(field);
Reflections.setAccessible(method);
init(projectStageClassName, this);
}
private static void init(String projectStageClassName, ProjectStage projectStage)
{
projectStages.put(projectStageClassName, projectStage);
ProjectStage[] result = new ProjectStage[values.length];
System.arraycopy(values, 0, result, 0, values.length);
return result;
public abstract class ClassDeactivation
import java.util.logging.Level;
import java.util.logging.Logger;
Logger logger = Logger.getLogger(HierarchyDiscovery.class.getName());
resetCache();
}
private static void resetCache()
{
public abstract class Reflections
else if (type instanceof ParameterizedType && ((ParameterizedType) type).getRawType() instanceof Class<?>)
return (Class<T>) ((ParameterizedType) type).getRawType();
public abstract class Types
throw new IllegalStateException("problem while loading DeltaSpike property files", ioe);
IllegalStateException runtimeException = new IllegalStateException();
public abstract class JndiUtils
public class ImmutableInjectionPoint implements InjectionPoint
{
private final boolean isTransient;
public ImmutableInjectionPoint(AnnotatedField<?> field, Set<Annotation> qualifiers, Bean<?> declaringBean,
boolean isTransient, boolean delegate)
{
this.isTransient = isTransient;
public ImmutableInjectionPoint(AnnotatedField<?> field, BeanManager beanManager, Bean<?> declaringBean,
boolean isTransient, boolean delegate)
{
this.isTransient = isTransient;
public ImmutableInjectionPoint(AnnotatedParameter<?> parameter, Set<Annotation> qualifiers, Bean<?> declaringBean,
boolean isTransient, boolean delegate)
{
this.isTransient = isTransient;
public ImmutableInjectionPoint(AnnotatedParameter<?> parameter, BeanManager beanManager, Bean<?> declaringBean,
boolean isTransient, boolean delegate)
{
this.isTransient = isTransient;
public Annotated getAnnotated()
{
public Bean<?> getBean()
{
public Member getMember()
{
public Set<Annotation> getQualifiers()
{
public Type getType()
{
public boolean isDelegate()
{
public boolean isTransient()
{
return isTransient;
public class InjectableMethod<X>
{
public InjectableMethod(AnnotatedMethod<X> method, Bean<?> declaringBean, BeanManager beanManager)
{
public InjectableMethod(AnnotatedMethod<X> method, Collection<InjectionPoint> parameters, BeanManager beanManager)
{
protected BeanManager getBeanManager()
{
protected List<InjectionPoint> getParameters()
{
public <T> T invoke(Object receiver, CreationalContext<T> creationalContext)
{
public <T> T invoke(Object receiver, CreationalContext<T> creationalContext, ParameterValueRedefiner redefinition)
{
{
if (redefinition != null)
{
}
else
{
T result = (T) invokeMethod(true, method.getJavaMember(), receiver, parameterValues
.toArray(EMPTY_OBJECT_ARRAY));
public interface ParameterValueRedefiner
{
Object redefineParameterValue(ParameterValue value);
public static class ParameterValue
{
ParameterValue(int position, InjectionPoint injectionPoint, BeanManager beanManager)
{
public int getPosition()
{
public InjectionPoint getInjectionPoint()
{
public Object getDefaultValue(CreationalContext<?> creationalContext)
{
public class Beans
{
private Beans()
{
public static Set<Annotation> getQualifiers(BeanManager beanManager, Iterable<Annotation>... annotations)
{
for (Iterable<Annotation> annotationSet : annotations)
{
for (Annotation annotation : annotationSet)
{
if (beanManager.isQualifier(annotation.annotationType()))
{
public static Set<Annotation> getQualifiers(BeanManager beanManager, Iterable<Annotation> annotations)
{
public static Set<Annotation> getQualifiers(BeanManager beanManager, Annotation[]... annotations)
{
for (Annotation[] annotationArray : annotations)
{
for (Annotation annotation : annotationArray)
{
if (beanManager.isQualifier(annotation.annotationType()))
{
public static void checkReturnValue(Object instance, Bean<?> bean, InjectionPoint injectionPoint,
BeanManager beanManager)
{
if (instance == null && !Dependent.class.equals(bean.getScope()))
{
}
else if (instance != null)
{
if (passivating && !instanceSerializable)
{
throw new IllegalStateException(
if (injectionPoint != null && injectionPoint.getBean() != null)
{
if (!instanceSerializable && beanManager.isPassivatingScope(injectionPoint.getBean().getScope()))
{
if (injectionPoint.getMember() instanceof Field)
{
if (!injectionPoint.isTransient() && instance != null && !instanceSerializable)
{
throw new IllegalStateException(
"Producers cannot produce non-serializable instances for injection into "
"non-transient fields of passivating beans. Producer "
}
else if (injectionPoint.getMember() instanceof Method)
{
if (method.isAnnotationPresent(Inject.class))
{
throw new IllegalStateException("Producers cannot produce non-serializable instances for "
"injection into parameters of initializers of beans declaring passivating scope. "
if (method.isAnnotationPresent(Produces.class))
{
throw new IllegalStateException("Producers cannot produce non-serializable instances for "
"injection into parameters of producer methods declaring passivating scope. "
}
else if (injectionPoint.getMember() instanceof Constructor<?>)
{
throw new IllegalStateException("Producers cannot produce non-serializable instances for "
"injection into parameters of constructors of beans declaring passivating scope. "
public static <X> List<InjectionPoint> createInjectionPoints(AnnotatedMethod<X> method, Bean<?> declaringBean,
BeanManager beanManager)
{
for (AnnotatedParameter<X> parameter : method.getParameters())
{
InjectionPoint injectionPoint =
new ImmutableInjectionPoint(parameter, beanManager, declaringBean, false, false);
import org.apache.deltaspike.core.util.ServiceUtils;
List<ConfigSourceProvider> configSourceProviderServiceLoader =
ServiceUtils.loadServiceImplementations(ConfigSourceProvider.class);
import org.apache.deltaspike.core.util.ServiceUtils;
import java.util.List;
List<ProjectStageHolder> projectStageHolders =
ServiceUtils.loadServiceImplementations(ProjectStageHolder.class);
if (!propertyFileUrls.hasMoreElements())
{
cl = getClass().getClassLoader();
propertyFileUrls = cl.getResources(PROPERTY_FILE_NAME);
}
@SecurityBindingType
import java.io.Serializable;
import java.lang.reflect.Method;
import org.apache.deltaspike.security.impl.SecurityExtension.Authorizer;
@SecurityInterceptorBinding
public class SecurityInterceptor implements Serializable
private static final long serialVersionUID = -6567750187000766925L;
@Inject private SecurityExtension extension;
public Object aroundInvoke(InvocationContext invocation) throws Exception
Method method = invocation.getMethod();
for (Authorizer authorizer : extension.lookupAuthorizerStack(method, invocation.getTarget().getClass()))
{
authorizer.authorize(invocation);
}
return invocation.proceed();
try
{
@SuppressWarnings("unchecked")
T result = (T) invokeMethod(true, method.getJavaMember(), receiver, parameterValues
.toArray(EMPTY_OBJECT_ARRAY));
return result;
}
catch (RuntimeException e)
{
if (RuntimeException.class.getName().equals(e.getClass().getName()) &&
e.getCause() instanceof RuntimeException)
{
throw (RuntimeException)e.getCause();
}
throw e;
}
Method method = invocationContext.getMethod();
SecurityMetaDataStorage metaDataStorage = SecurityExtension.getMetaDataStorage();
for (Authorizer authorizer : metaDataStorage.getAuthorizers(invocationContext.getTarget().getClass(), method))
authorizer.authorize(invocationContext);
import org.apache.deltaspike.core.api.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.security.api.Secures;
import org.apache.deltaspike.security.api.SecurityDefinitionException;
import org.apache.deltaspike.security.spi.Authenticator;
import java.lang.annotation.Annotation;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class SecurityExtension implements Extension
private static final Map<ClassLoader, SecurityMetaDataStorage> SECURITY_METADATA_STORAGE_MAPPING
= new ConcurrentHashMap<ClassLoader, SecurityMetaDataStorage>();
public static SecurityMetaDataStorage getMetaDataStorage()
{
ClassLoader classLoader = ClassUtils.getClassLoader(null);
SecurityMetaDataStorage securityMetaDataStorage = SECURITY_METADATA_STORAGE_MAPPING.get(classLoader);
if (securityMetaDataStorage == null)
{
securityMetaDataStorage = new SecurityMetaDataStorage();
SECURITY_METADATA_STORAGE_MAPPING.put(classLoader, securityMetaDataStorage);
}
return securityMetaDataStorage;
}
@SuppressWarnings("UnusedDeclaration")
public <X> void processAnnotatedType(@Observes ProcessAnnotatedType<X> event, final BeanManager beanManager)
if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
break;
registerAuthorizer(m, beanManager);
if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
getMetaDataStorage().addSecuredType(type);
@SuppressWarnings("UnusedDeclaration")
public void validateBindings(@Observes AfterBeanDiscovery event, BeanManager beanManager)
SecurityMetaDataStorage metaDataStorage = getMetaDataStorage();
for (final AnnotatedType<?> type : metaDataStorage.getSecuredTypes())
if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
for (Authorizer auth : metaDataStorage.getAuthorizers())
if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
metaDataStorage.registerSecuredMethod(type.getJavaClass(), method.getJavaMember());
metaDataStorage.resetSecuredTypes();
private void registerAuthorizer(AnnotatedMethod<?> m, BeanManager beanManager)
for (Annotation annotation : m.getAnnotations())
if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
binding = annotation;
Authorizer authorizer = new Authorizer(binding, m, beanManager);
getMetaDataStorage().addAuthorizer(authorizer);
@SuppressWarnings("UnusedDeclaration")
public void validateAuthenticatorImplementation(@Observes ProcessSessionBean<Authenticator> event)
import org.apache.deltaspike.security.spi.SecurityStrategy;
import java.io.Serializable;
public class SecurityInterceptor implements Serializable
private static final long serialVersionUID = -7094673146532371976L;
@Inject
private SecurityStrategy securityStrategy;
public Object filterDeniedInvocations(InvocationContext invocationContext) throws Exception
return this.securityStrategy.execute(invocationContext);
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivation;
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
public class SecurityExtension implements Extension, Deactivatable
private Boolean isActivated = null;
protected void init(@Observes BeforeBeanDiscovery afterBeanDiscovery)
{
initActivation();
}
if (!this.isActivated)
{
return;
}
if (!this.isActivated)
{
return;
}
!m.getJavaMember().getReturnType().equals(Boolean.TYPE))
if (binding != null)
if (!this.isActivated)
{
return;
}
public void initActivation()
{
if (isActivated == null)
{
isActivated = ClassDeactivation.isActivated(getClass());
}
}
import org.apache.deltaspike.security.api.annotation.Secured;
import org.apache.deltaspike.security.api.annotation.SecurityBindingType;
import org.apache.deltaspike.security.api.annotation.Secured;
import org.apache.deltaspike.security.api.annotation.Secures;
import org.apache.deltaspike.security.api.annotation.Secures;
import org.apache.deltaspike.security.api.annotation.SecurityBindingType;
AuthenticationResult login();
public enum AuthenticationResult
{
success, failed, exception
}
@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD })
public @interface LoggedIn
{
import org.apache.deltaspike.security.api.annotation.Secured;
import org.apache.deltaspike.security.api.annotation.Secured;
import org.apache.deltaspike.security.api.annotation.Secured;
void quietLogin();
@Target({TYPE, METHOD} )
throws IOException
{
void start();
void stop();
@Override
public void start()
{
bootContainer();
startContexts();
}
@Override
public void stop()
{
stopContexts();
shutdownContainer();
}
cdiContainer.stop();
import org.apache.deltaspike.cdise.api.CdiContainer;
import org.apache.webbeans.config.WebBeansContext;
import org.apache.webbeans.context.ContextFactory;
import org.apache.webbeans.context.type.ContextTypes;
import org.apache.webbeans.spi.ContainerLifecycle;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
private ContainerLifecycle lifecycle;
private MockServletContext servletContext;
private MockHttpSession session;
private Boolean resetSuccessful;
@Override
public  BeanManager getBeanManager()
{
return lifecycle.getBeanManager();
}
@Override
@Override
@Override
ContextFactory contextFactory = getContextFactory();
@Override
stopSingletonScope();
private void startApplicationScope()
ContextFactory contextFactory = getContextFactory();
contextFactory.initApplicationContext(servletContext);
}
private void startSessionScope()
{
ContextFactory contextFactory = getContextFactory();
contextFactory.initSessionContext(session);
}
private void startRequestScope()
{
ContextFactory contextFactory = getContextFactory();
contextFactory.initRequestContext(null);
}
private void startConversationScope()
{
ContextFactory contextFactory = getContextFactory();
contextFactory.initConversationContext(null);
}
private void stopSingletonScope()
{
ContextFactory contextFactory = getContextFactory();
Context context = contextFactory.getStandardContext(ContextTypes.SINGLETON);
if (context != null && context.isActive())
{
contextFactory.destroySingletonContext(servletContext);
resetCache();
}
else
{
logDestroyOfInactiveContext(Singleton.class.getName());
}
}
private void stopApplicationScope()
{
ContextFactory contextFactory = getContextFactory();
Context context = contextFactory.getStandardContext(ContextTypes.APPLICATION);
if (context != null && context.isActive())
{
contextFactory.destroyApplicationContext(servletContext);
resetCache();
}
else
{
logDestroyOfInactiveContext(ApplicationScoped.class.getName());
}
}
private void stopSessionScope()
{
ContextFactory contextFactory = getContextFactory();
Context context = contextFactory.getStandardContext(ContextTypes.SESSION);
if (context != null && context.isActive())
{
contextFactory.destroySessionContext(session);
resetCache();
}
else
{
logDestroyOfInactiveContext(SessionScoped.class.getName());
}
}
private void stopRequestScope()
{
ContextFactory contextFactory = getContextFactory();
resetCache();
private void stopConversationScope()
ContextFactory contextFactory = getContextFactory();
Context context = contextFactory.getStandardContext(ContextTypes.CONVERSATION);
contextFactory.destroyConversationContext();
resetCache();
logDestroyOfInactiveContext(ConversationScoped.class.getName());
private void resetCache()
if (Boolean.FALSE.equals(this.resetSuccessful))
{
return;
}
BeanManager beanManager = getBeanManager();
try
{
Field cacheProxiesField = beanManager.getClass().getDeclaredField("cacheProxies");
cacheProxiesField.setAccessible(true);
Map cacheProxies = (Map)cacheProxiesField.get(beanManager);
if (cacheProxies != null)
{
cacheProxies.clear();
this.resetSuccessful = true;
}
}
catch (Exception e)
{
this.resetSuccessful = false;
}
catch (LinkageError e)
{
this.resetSuccessful = false;
}
}
private ContextFactory getContextFactory()
{
WebBeansContext webBeansContext = WebBeansContext.getInstance();
return webBeansContext.getContextFactory();
import org.jboss.weld.context.api.ContextualInstance;
import org.jboss.weld.context.beanstore.BeanStore;
import java.lang.reflect.Field;
import java.util.Iterator;
private Boolean resetSuccessful;
{
if (applicationContext.isActive())
{
applicationContext.invalidate();
this.applicationScopeStarted = false;
}
return;
}
org.jboss.weld.bootstrap.api.Singleton<BeanStore> beanStoreHolder = null;
BeanStore originalBeanStore = null;
try
{
Field field = this.applicationContext.getClass().getSuperclass().getDeclaredField("beanStore");
field.setAccessible(true);
beanStoreHolder = (org.jboss.weld.bootstrap.api.Singleton)field.get(this.applicationContext);
final BeanStore beanStore = beanStoreHolder.get();
originalBeanStore = beanStore;
beanStoreHolder.set(new BeanStore()
{
@Override
public <T> ContextualInstance<T> get(String id)
{
return beanStore.get(id);
}
@Override
public boolean contains(String id)
{
return beanStore.contains(id);
}
@Override
public void clear()
{
}
@Override
public Iterator<String> iterator()
{
return beanStore.iterator();
}
@Override
public <T> void put(String id, ContextualInstance<T> contextualInstance)
{
beanStore.put(id, contextualInstance);
}
});
}
catch (Exception e)
{
this.resetSuccessful = false;
}
catch (LinkageError e)
{
this.resetSuccessful = false;
}
if (beanStoreHolder != null)
{
Iterator<String> idIterator = originalBeanStore.iterator();
String currentId;
ContextualInstance<Object> currentContextualInstance;
while (idIterator.hasNext())
{
currentId = idIterator.next();
currentContextualInstance = originalBeanStore.get(currentId);
if (currentContextualInstance.getInstance().getClass().getName().startsWith("org.jboss."))
{
continue;
}
idIterator.remove();
}
beanStoreHolder.set(originalBeanStore);
}
this.resetSuccessful = true;
this.sessionContext.invalidate();
this.sessionContext.deactivate();
this.sessionContext.dissociate(this.sessionMap);
this.sessionMap = null;
this.conversationContext.invalidate();
this.conversationContext.deactivate();
this.conversationContext.dissociate(new MutableBoundRequest(this.requestMap, this.sessionMap));
this.requestContext.invalidate();
this.requestContext.deactivate();
this.requestContext.dissociate(this.requestMap);
this.requestMap = null;
import java.util.Set;
import javax.management.relation.Role;
import org.apache.deltaspike.security.Group;
import org.apache.deltaspike.security.api.User;
public enum AuthenticationStatus
{
SUCCESS,
FAILURE,
DEFERRED
}
void authenticate();
void postAuthenticate();
AuthenticationStatus getStatus();
User getUser();
Set<Role>  getRoleMemberships();
Set<Group>  getGroupMemberships();
import org.apache.deltaspike.security.api.AuthenticatorSelector;
import org.apache.deltaspike.security.api.events.PostAuthenticateEvent;
import org.apache.deltaspike.security.api.events.PreAuthenticateEvent;
import org.apache.deltaspike.security.spi.Authenticator.AuthenticationStatus;
@Inject
private Instance<AuthenticatorSelector> authenticatorSelector;
private Authenticator activeAuthenticator;
private boolean authenticating;
if (authenticating)
{
authenticating = false;
throw new IllegalStateException("Authentication already in progress.");
}
try
{
authenticating = true;
user = null;
beanManager.fireEvent(new PreAuthenticateEvent());
activeAuthenticator = authenticatorSelector.get().getSelectedAuthenticator();
if (activeAuthenticator == null)
{
authenticating = false;
throw new AuthenticationException("An Authenticator could not be located");
}
activeAuthenticator.authenticate();
if (activeAuthenticator.getStatus() == null)
{
throw new AuthenticationException("Authenticator must return a valid authentication status");
}
switch (activeAuthenticator.getStatus())
{
case SUCCESS:
postAuthenticate();
return true;
case FAILURE:
default:
authenticating = false;
return false;
}
}
catch (Exception ex)
{
authenticating = false;
if (ex instanceof AuthenticationException)
{
throw (AuthenticationException) ex;
}
else
{
throw new AuthenticationException("Authentication failed.", ex);
}
}
}
protected void postAuthenticate()
{
if (activeAuthenticator == null)
{
throw new IllegalStateException("activeAuthenticator is null");
}
try
{
activeAuthenticator.postAuthenticate();
if (!activeAuthenticator.getStatus().equals(AuthenticationStatus.SUCCESS))
{
return;
}
user = activeAuthenticator.getUser();
if (user == null)
{
throw new AuthenticationException(
"Authenticator must provide a non-null User after successful authentication");
}
if (isLoggedIn())
{
{
{
{
{
}
}
}
}
{
{
{
}
}
}
beanManager.fireEvent(new PostAuthenticateEvent());
}
finally
{
activeAuthenticator = null;
credentials.setCredential(null);
authenticating = false;
}
@Target({TYPE, METHOD } )
private static Boolean testMode;
private volatile Map<ClassLoader, BeanManagerHolder> bms = new ConcurrentHashMap<ClassLoader, BeanManagerHolder>();
"Please ensure that you configured the CDI implementation of your choice properly. "
"If your setup is correct, please clear all caches and compiled artifacts.");
BeanManagerHolder resultHolder = bms.get(classLoader);
BeanManager result;
if (resultHolder == null)
if (result != null)
bms.put(classLoader, new RootBeanManagerHolder(result));
else
{
result = resultHolder.getBeanManager();
if (!(resultHolder instanceof RootBeanManagerHolder))
{
BeanManager jndiBeanManager = resolveBeanManagerViaJndi();
{
setRootBeanManager(jndiBeanManager);
result = jndiBeanManager;
}
else
{
setRootBeanManager(result);
}
}
}
if (result == null)
{
throw new IllegalStateException("Unable to find BeanManager. "
"Please ensure that you configured the CDI implementation of your choice properly.");
}
setBeanManager(new BeanManagerHolder(beanManager));
}
public void setRootBeanManager(BeanManager beanManager)
{
setBeanManager(new RootBeanManagerHolder(beanManager));
}
private void setBeanManager(BeanManagerHolder beanManagerHolder)
{
if (beanManagerHolder instanceof RootBeanManagerHolder ||
(!(bmpFirst.bms.get(cl) instanceof RootBeanManagerHolder)))
{
bmpFirst.bms.put(cl, beanManagerHolder);
}
if (Boolean.TRUE.equals(testMode))
{
bmpFirst.bms.put(cl, beanManagerHolder);
}
public void cleanupStoredBeanManagerOnShutdown(@Observes BeforeShutdown beforeShutdown)
protected void setTestMode()
{
activateTestMode();
}
private static void activateTestMode()
{
testMode = true;
}
public static final class UnitTest extends ProjectStage implements TestStage
public static final class SystemTest extends ProjectStage implements TestStage
public static final class IntegrationTest extends ProjectStage implements TestStage
bmpFirst.bms.put(cl, new TestBeanManagerHolder(beanManagerHolder.getBeanManager()));
BeanManager resolveBeanManagerViaJndi()
import org.apache.deltaspike.core.api.projectstage.TestStage;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
if (TestStage.class.isAssignableFrom(projectStage.getClass()))
{
new BeanManagerProvider()
{
@Override
public void setTestMode()
{
super.setTestMode();
}
} .setTestMode();
}
ProjectStage projectStage = ProjectStageProducer.getInstance().getProjectStage();
if (!evalExcludeInProjectStage(processAnnotatedType, exclude, projectStage))
if (!evalExcludeNotInProjectStage(processAnnotatedType, exclude, projectStage))
private boolean evalExcludeInProjectStage(ProcessAnnotatedType<Object> processAnnotatedType, Exclude exclude,
ProjectStage currentlyConfiguredProjectStage)
if (isInProjectStage(activatedIn, currentlyConfiguredProjectStage))
private boolean evalExcludeNotInProjectStage(ProcessAnnotatedType<Object> processAnnotatedType, Exclude exclude,
ProjectStage currentlyConfiguredProjectStage)
if (!isInProjectStage(notIn, currentlyConfiguredProjectStage))
private boolean isInProjectStage(Class<? extends ProjectStage>[] activatedIn,
ProjectStage currentlyConfiguredProjectStage)
if (currentlyConfiguredProjectStage.getClass().equals(activated))
package org.apache.deltaspike.security.api;
import org.apache.deltaspike.security.api.Group;
import org.apache.deltaspike.security.api.Group;
import org.apache.deltaspike.security.api.Group;
void boot();
void shutdown();
ContextControl getContextControl();
import javax.enterprise.context.Dependent;
import javax.inject.Inject;
import org.apache.deltaspike.cdise.api.ContextControl;
@Dependent
public class WeldContextControl implements ContextControl
{
@Inject
private BeanManager beanManager;
try
{
getContextController().startApplicationScope();
}
catch (IllegalStateException ise)
{
}
try
{
getContextController().startSessionScope();
}
catch (IllegalStateException ise)
{
}
try
{
getContextController().startConversationScope(null);
}
catch (IllegalStateException ise)
{
}
try
{
getContextController().startRequestScope();
}
catch (IllegalStateException ise)
{
}
try
{
getContextController().stopApplicationScope();
}
catch (IllegalStateException ise)
{
}
try
{
getContextController().stopSessionScope();
}
catch (IllegalStateException ise)
{
}
try
{
getContextController().stopConversationScope();
}
catch (IllegalStateException ise)
{
}
try
{
getContextController().stopRequestScope();
}
catch (IllegalStateException ise)
{
}
try
{
getContextController().stopSingletonScope();
}
catch (IllegalStateException ise)
{
}
import org.apache.deltaspike.cdise.api.ContextControl;
cdiContainer.boot();
ContextControl contextControl = cdiContainer.getContextControl();
contextControl.startContext(ApplicationScoped.class);
contextControl.stopContext(ApplicationScoped.class);
cdiContainer.shutdown();
import org.apache.deltaspike.cdise.api.ContextControl;
cdiContainer.boot();
ContextControl contextControl = cdiContainer.getContextControl();
contextControl.startContext(ApplicationScoped.class);
contextControl.stopContext(ApplicationScoped.class);
cdiContainer.shutdown();
public static <T> T getContextualReference(Class<T> type, Annotation... qualifiers)
{
return getContextualReference(type, false, qualifiers);
}
public static Object getContextualReference(String name)
{
return getContextualReference(name, false);
}
public static <T> List<T> getContextualReferences(Class<T> type, boolean optional)
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.InjectionTarget;
new HashSet<Bean<?>>((Collection) Arrays.asList(bean))));
@SuppressWarnings("unchecked")
public static <T> T injectFields(T instance)
{
if (instance == null)
{
return null;
}
BeanManager beanManager = getBeanManager();
CreationalContext creationalContext = beanManager.createCreationalContext(null);
AnnotatedType annotatedType = beanManager.createAnnotatedType(instance.getClass());
InjectionTarget injectionTarget = beanManager.createInjectionTarget(annotatedType);
injectionTarget.inject(instance, creationalContext);
return instance;
}
import java.lang.annotation.Annotation;
<S, T> Converter<S, T> create(Class<S> sourceType, Class<T> targetType, Class<? extends Annotation> metaDataType);
converter = converterFactory.create(String.class, (Class<?>) this.beanType,
this.customQualifier != null ? customQualifier.annotationType() : null);
qualifier = annotation;
@SuppressWarnings("UnusedDeclaration")
if (optionalCustomQualifier != null ? !optionalCustomQualifier
.equals(that.optionalCustomQualifier) : that.optionalCustomQualifier != null)
{
return false;
}
import java.lang.annotation.Annotation;
private final Class<? extends Annotation> metaDataType;
ConverterKey(Class sourceType, Class targetType, Class<? extends Annotation> metaDataType)
this.metaDataType = metaDataType;
if (metaDataType != null ? !metaDataType.equals(that.metaDataType) : that.metaDataType != null)
{
return false;
}
import org.apache.deltaspike.core.api.converter.MetaDataAwareConverter;
import java.lang.annotation.Annotation;
@Override
public <S, T> Converter<S, T> create(
Class<S> sourceType, Class<T> targetType, Class<? extends Annotation> metaDataType)
{
Converter<S, T> result;
result = this.converterMapping.get(new ConverterKey(sourceType, targetType, metaDataType));
if (result != null)
{
return result;
}
return this.converterMapping.get(new ConverterKey(sourceType, targetType, null));
}
registerConverter(new StringToLongConverter());
Class metaDataType = null;
if (MetaDataAwareConverter.class.isAssignableFrom((Class<?>) parameterizedType.getRawType()))
{
metaDataType = (Class<?>) parameterizedType.getActualTypeArguments()[2];
}
this.converterMapping.put(new ConverterKey(sourceType, targetType, metaDataType), converter);
import org.apache.deltaspike.core.util.ReflectionUtils;
for (Field field : ReflectionUtils.getAllDeclaredFields(type))
ReflectionUtils.setAccessible(field);
for (Method method : ReflectionUtils.getAllDeclaredMethods(type))
ReflectionUtils.setAccessible(method);
import org.apache.deltaspike.core.util.ReflectionUtils;
return ReflectionUtils.<T>cast(annotationMap.get(anType));
import org.apache.deltaspike.core.util.BeanUtils;
this.qualifiers = BeanUtils.getQualifiers(beanManager, field.getAnnotations());
this.qualifiers = BeanUtils.getQualifiers(beanManager, parameter.getAnnotations());
import static org.apache.deltaspike.core.util.BeanUtils.createInjectionPoints;
import static org.apache.deltaspike.core.util.ReflectionUtils.EMPTY_OBJECT_ARRAY;
import static org.apache.deltaspike.core.util.ReflectionUtils.invokeMethod;
import static org.apache.deltaspike.core.util.ReflectionUtils.isSerializable;
public class BeanUtils
private BeanUtils()
public abstract class ReflectionUtils
private ReflectionUtils()
return ReflectionUtils.<T>cast(field.get(instance));
@SuppressWarnings({ "unchecked", "UnnecessaryLocalVariable" })
T result =
(T) invokeMethod(receiver, method.getJavaMember(), Object.class, true, parameterValues.toArray());
import org.apache.deltaspike.core.api.metadata.builder.ImmutableInjectionPoint;
import javax.enterprise.inject.Typed;
import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
@Typed()
public abstract class BeanUtils
Set<Annotation> qualifiers = new HashSet<Annotation>();
for (Annotation annotation : annotations)
{
if (beanManager.isQualifier(annotation.annotationType()))
{
qualifiers.add(annotation);
}
}
return qualifiers;
}
public abstract class ClassDeactivationUtils
private static final Logger LOG = Logger.getLogger(ClassDeactivationUtils.class.getName());
private ClassDeactivationUtils()
import java.util.Collections;
Collections.addAll(fields, c.getDeclaredFields());
public static Field tryToFindDeclaredField(Class<?> clazz, String name)
Collections.addAll(methods, c.getDeclaredMethods());
"Details: Exception invoking method [%s] on object [%s], using arguments [", method.getName(), obj));
message.append(i > 0 ? ", " : "").append(args[i]);
public static <T> T invokeMethod(Object instance,
boolean setAccessible,
Object... args)
catch (Exception e)
String customMessage = createCustomMessage(e, method, instance, args);
ExceptionUtils.changeAndThrowException(e, customMessage);
return null;
private static String createCustomMessage(Exception e, Method method, Object targetObject, Object... arguments)
private static <T> Class<T> getRawType(Type type)
public static Type[] getTypeArguments(Class<?> clazz)
public static Type[] getTypeArguments(Type type)
public static boolean isParameterizedTypeWithWildcard(Class<?> type)
private static boolean containsWildcards(Type[] types)
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
this.isActivated = ClassDeactivationUtils.isActivated(getClass());
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
isActivated = ClassDeactivationUtils.isActivated(getClass());
isGlobalAlternativeActivated = ClassDeactivationUtils.isActivated(GlobalAlternative.class);
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
isActivated = ClassDeactivationUtils.isActivated(getClass());
public static Type[] getActualTypeArguments(Class<?> clazz)
public static Type[] getActualTypeArguments(Type type)
import org.apache.deltaspike.core.util.StringUtils;
if (!StringUtils.isEmpty(authenticatorName))
if (clazz == null)
{
throw new IllegalArgumentException("null isn't supported");
}
return clazz.getTypeParameters();
if (type instanceof Class)
{
return getActualTypeArguments((Class)type);
}
import org.apache.deltaspike.core.util.ClassUtils;
import org.jboss.shrinkwrap.api.asset.Asset;
import org.jboss.shrinkwrap.api.asset.StringAsset;
public static JavaArchive[] getDeltaSpikeCoreAndSecurityArchive()
boolean isOwbAvailable = ClassUtils.tryToLoadClassForName("org.apache.webbeans.spi.ContainerLifecycle") != null;
String[] excludedFiles;
if (isOwbAvailable)
{
excludedFiles = new String[]{"META-INF.apache-deltaspike.properties"};
}
else
{
excludedFiles = new String[]{"META-INF.apache-deltaspike.properties", "META-INF.beans.xml"};
}
new String[]{"org.apache.deltaspike.core", "org.apache.deltaspike.security"}, excludedFiles);
public static Asset getBeansXml()
{
@SuppressWarnings("UnnecessaryLocalVariable")
Asset beansXml = new StringAsset(
"<beans>"
"<interceptors><class>org.apache.deltaspike.security.impl.SecurityInterceptor</class></interceptors>"
"</beans>"
);
return beansXml;
}
}
private TestUser user;
public TestUser getUser()
return user;
public void setUser(TestUser user)
this.user = user;
import javax.enterprise.inject.spi.BeforeShutdown;
protected static void removeMetaDataStorage()
{
ClassLoader classLoader = ClassUtils.getClassLoader(null);
SECURITY_METADATA_STORAGE_MAPPING.remove(classLoader);
}
protected void cleanup(@Observes BeforeShutdown beforeShutdown)
{
removeMetaDataStorage();
}
projectStageProducer = new ProjectStageProducer();
private Boolean servletApiAvailable = null;
private Object session = null;
private Object servletContext = null;
protected boolean isServletApiAvailable()
{
if (servletApiAvailable == null)
{
try
{
Class servletClass = Class.forName("javax.servlet.http.HttpSession");
servletApiAvailable = servletClass != null;
}
catch (ClassNotFoundException e)
{
servletApiAvailable = Boolean.FALSE;
}
}
return servletApiAvailable;
}
protected Object getMockSession()
{
if (isServletApiAvailable() && session == null)
{
session = new MockHttpSession();
}
return session;
}
protected Object getMockServletContext()
{
if (isServletApiAvailable() && servletContext == null)
{
servletContext  = new MockServletContext();
}
return servletContext;
}
contextFactory.initSingletonContext(getMockServletContext());
contextFactory.initApplicationContext(getMockServletContext());
contextFactory.initSessionContext(getMockSession());
contextFactory.initApplicationContext(getMockServletContext());
contextFactory.initSessionContext(getMockSession());
contextFactory.destroySingletonContext(getMockServletContext());
contextFactory.destroyApplicationContext(getMockServletContext());
contextFactory.destroySessionContext(getMockSession());
public static void throwAsRuntimeException(Throwable throwable)
{
new ExceptionHelper<RuntimeException>().throwException(throwable);
}
import java.io.Serializable;
public interface Identity extends Serializable
SUCCESS, FAILED
import javax.enterprise.inject.Typed;
import java.io.Serializable;
@Typed()
public class User implements Serializable
{
private static final long serialVersionUID = -2234530384311026364L;
private final String id;
public User(String id)
{
this.id = id;
}
public String getId()
{
return id;
}
package org.apache.deltaspike.security.api.authentication;
public class AuthenticationException extends org.apache.deltaspike.security.api.SecurityException
package org.apache.deltaspike.security.api.authentication;
public class UnexpectedCredentialException extends AuthenticationException
private static final long serialVersionUID = 4827200587997989123L;
public UnexpectedCredentialException(String message)
public UnexpectedCredentialException(String message, Throwable cause)
package org.apache.deltaspike.security.api.authentication.events;
public class AlreadyLoggedInEvent
{
}
package org.apache.deltaspike.security.api.authentication.events;
public class LoggedInEvent
{
}
package org.apache.deltaspike.security.api.authentication.events;
public class LoginFailedEvent
{
private Exception loginException;
public LoginFailedEvent(Exception loginException)
{
this.loginException = loginException;
}
public Exception getLoginException()
{
return loginException;
}
}
package org.apache.deltaspike.security.api.authentication.events;
public class PostAuthenticateEvent
{
}
package org.apache.deltaspike.security.api.authentication.events;
import org.apache.deltaspike.security.api.User;
public class PostLoggedOutEvent
{
private User user;
public PostLoggedOutEvent(User user)
{
this.user = user;
}
public User getUser()
{
return user;
}
}
package org.apache.deltaspike.security.api.authentication.events;
public class PreAuthenticateEvent
{
}
package org.apache.deltaspike.security.api.authentication.events;
import org.apache.deltaspike.security.api.User;
public class PreLoggedOutEvent
{
private User user;
public PreLoggedOutEvent(User user)
{
this.user = user;
}
public User getUser()
{
return user;
}
}
package org.apache.deltaspike.security.api.authorization;
package org.apache.deltaspike.security.api.authorization;
package org.apache.deltaspike.security.api.authorization;
package org.apache.deltaspike.security.api.authorization;
public class AccessDeniedException extends org.apache.deltaspike.security.api.SecurityException
package org.apache.deltaspike.security.api.authorization;
public class AuthorizationException extends org.apache.deltaspike.security.api.SecurityException
package org.apache.deltaspike.security.api.authorization;
public class SecurityDefinitionException extends org.apache.deltaspike.security.api.SecurityException
package org.apache.deltaspike.security.api.authorization;
package org.apache.deltaspike.security.api.authorization.annotation;
import org.apache.deltaspike.security.api.authorization.AccessDecisionVoter;
package org.apache.deltaspike.security.api.authorization.annotation;
package org.apache.deltaspike.security.api.authorization.annotation;
package org.apache.deltaspike.security.api.credential;
public interface Credential<T>
T getValue();
package org.apache.deltaspike.security.api.credential;
public interface LoginCredential
String getUserId();
void setUserId(String userId);
package org.apache.deltaspike.security.spi.authentication;
package org.apache.deltaspike.security.spi.authentication;
package org.apache.deltaspike.security.spi.authentication;
public AuthenticationStatus getStatus()
protected void setStatus(AuthenticationStatus status)
public void postAuthenticate()
package org.apache.deltaspike.security.spi.authorization;
import org.apache.deltaspike.security.api.authorization.AccessDecisionState;
import org.apache.deltaspike.security.api.authorization.AccessDecisionVoterContext;
import org.apache.deltaspike.security.api.authorization.SecurityViolation;
package org.apache.deltaspike.security.spi.authorization;
package org.apache.deltaspike.security.impl.authentication;
import org.apache.deltaspike.security.spi.authentication.Authenticator;
import org.apache.deltaspike.security.spi.authentication.AuthenticatorSelector;
import javax.enterprise.context.RequestScoped;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import java.util.List;
@RequestScoped
public class DefaultAuthenticatorSelector implements AuthenticatorSelector
if (isExternalAuthenticator(auth.getClass()))
}
if (selectedAuth == null)
{
return !authClass.getName().startsWith(getClass().getPackage().getName());
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.api.authorization.AuthorizationException;
import org.apache.deltaspike.security.api.authorization.SecurityDefinitionException;
import org.apache.deltaspike.security.api.authorization.annotation.SecurityBindingType;
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.api.authorization.AccessDecisionState;
import org.apache.deltaspike.security.api.authorization.SecurityViolation;
import org.apache.deltaspike.security.spi.authorization.EditableAccessDecisionVoterContext;
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.spi.authorization.SecurityStrategy;
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.api.authorization.AccessDecisionState;
import org.apache.deltaspike.security.api.authorization.AccessDecisionVoter;
import org.apache.deltaspike.security.api.authorization.AccessDecisionVoterContext;
import org.apache.deltaspike.security.api.authorization.AccessDeniedException;
import org.apache.deltaspike.security.api.authorization.SecurityViolation;
import org.apache.deltaspike.security.api.authorization.annotation.Secured;
import org.apache.deltaspike.security.api.authorization.annotation.Secures;
import org.apache.deltaspike.security.spi.authorization.EditableAccessDecisionVoterContext;
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.api.authorization.SecurityDefinitionException;
import org.apache.deltaspike.security.api.authorization.annotation.Secures;
import org.apache.deltaspike.security.spi.authentication.Authenticator;
public static void removeMetaDataStorage()
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.spi.authorization.SecurityStrategy;
package org.apache.deltaspike.security.impl.authorization;
import javax.interceptor.InterceptorBinding;
package org.apache.deltaspike.security.impl.authorization;
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.api.authorization.SecurityDefinitionException;
package org.apache.deltaspike.security.impl.authorization;
import org.apache.deltaspike.security.api.authorization.annotation.SecurityBindingType;
abstract class SecurityUtils
package org.apache.deltaspike.test.security.impl.authentication;
interface Inquiry
String getInquiryId();
package org.apache.deltaspike.test.security.impl.authentication;
public interface InquiryStorage
{
boolean addInquiry(Inquiry inquiry);
}
package org.apache.deltaspike.test.security.impl.authentication;
import javax.inject.Inject;
public class Shop
@Inject
private InquiryStorage inquiryStorage;
public String sendInquiry(Inquiry inquiry)
if (this.inquiryStorage.addInquiry(inquiry))
{
return inquiry.getInquiryId();
}
return null;
package org.apache.deltaspike.test.security.impl.authorization.secured;
import org.apache.deltaspike.security.api.authorization.annotation.Secured;
package org.apache.deltaspike.test.security.impl.authorization.secured;
package org.apache.deltaspike.test.security.impl.authorization.secured;
import org.apache.deltaspike.security.api.authorization.annotation.Secured;
package org.apache.deltaspike.test.security.impl.authorization.secured;
import org.apache.deltaspike.security.api.authorization.annotation.Secured;
"<interceptors>"
"<class>org.apache.deltaspike.security.impl.authorization.SecurityInterceptor</class>"
"</interceptors>"
}
public class AccessDeniedException extends SecurityException
import org.apache.deltaspike.security.api.authorization.AccessDeniedException;
import org.apache.deltaspike.security.api.authorization.SecurityViolation;
import javax.enterprise.inject.Typed;
import java.util.HashSet;
@Typed()
private Annotation bindingAnnotation;
private Map<Method, Object> bindingSecurityBindingMembers = new HashMap<Method, Object>();
private AnnotatedMethod<?> boundAuthorizerMethod;
private Bean<?> boundAuthorizerBean;
private InjectableMethod<?> boundAuthorizerMethodProxy;
Authorizer(Annotation bindingAnnotation, AnnotatedMethod<?> boundAuthorizerMethod, BeanManager beanManager)
this.bindingAnnotation = bindingAnnotation;
this.boundAuthorizerMethod = boundAuthorizerMethod;
for (Method method : bindingAnnotation.annotationType().getDeclaredMethods())
bindingSecurityBindingMembers.put(method, method.invoke(bindingAnnotation));
void authorize(final InvocationContext ic)
if (boundAuthorizerBean == null)
final CreationalContext<?> creationalContext = beanManager.createCreationalContext(boundAuthorizerBean);
Object reference = beanManager.getReference(boundAuthorizerBean,
boundAuthorizerMethod.getJavaMember().getDeclaringClass(), creationalContext);
Object result = boundAuthorizerMethodProxy.invoke(reference, creationalContext, new ParameterValueRedefiner() {
Set<SecurityViolation> violations = new HashSet<SecurityViolation>();
violations.add(new SecurityViolation()
{
private static final long serialVersionUID = 2358753444038521129L;
@Override
public String getReason()
{
return "Authorization check failed";
}
});
throw new AccessDeniedException(violations);
if (boundAuthorizerBean == null)
Method method = boundAuthorizerMethod.getJavaMember();
boundAuthorizerBean = beans.iterator().next();
boundAuthorizerMethodProxy = new InjectableMethod(boundAuthorizerMethod, boundAuthorizerBean, beanManager);
boolean matchesBinding(Annotation annotation)
if (!annotation.annotationType().equals(bindingAnnotation.annotationType()))
if (!bindingSecurityBindingMembers.containsKey(method))
if (!bindingSecurityBindingMembers.get(method).equals(value))
Method getBoundAuthorizerMethod()
return boundAuthorizerMethod.getJavaMember();
@SuppressWarnings("UnusedDeclaration")
@SuppressWarnings("UnusedDeclaration")
@SuppressWarnings("UnusedDeclaration")
private void registerAuthorizer(AnnotatedMethod<?> annotatedMethod, BeanManager beanManager)
if (!annotatedMethod.getJavaMember().getReturnType().equals(Boolean.class) &&
!annotatedMethod.getJavaMember().getReturnType().equals(Boolean.TYPE))
for (Annotation annotation : annotatedMethod.getAnnotations())
Authorizer authorizer = new Authorizer(binding, annotatedMethod, beanManager);
sb.append(authorizer.getBoundAuthorizerMethod().getDeclaringClass().getName());
sb.append(authorizer.getBoundAuthorizerMethod().getName());
sb.append(a.getBoundAuthorizerMethod().getDeclaringClass().getName());
sb.append(a.getBoundAuthorizerMethod().getName());
@SuppressWarnings("UnusedDeclaration")
@SuppressWarnings("UnusedDeclaration")
public BeanManager getBeanManager()
@SuppressWarnings("UnusedDeclaration")
import org.apache.webbeans.config.WebBeansContext;
if (beanManager == null)
{
beanManager = WebBeansContext.getInstance().getBeanManagerImpl();
}
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.apache.deltaspike.core.api.metadata.builder.InjectableMethod;
import org.apache.deltaspike.security.api.authorization.AccessDeniedException;
import org.apache.deltaspike.security.api.authorization.SecurityDefinitionException;
import org.apache.deltaspike.security.api.authorization.SecurityViolation;
import org.apache.deltaspike.security.api.authorization.annotation.SecurityBindingType;
Object result = boundAuthorizerMethodProxy.invoke(reference, creationalContext,
new SecurityParameterValueRedefiner(creationalContext, ic));
}
}
}
public static <T> Class<T> getRawType(Type type)
import org.apache.deltaspike.core.util.ReflectionUtils;
return ReflectionUtils.<T> cast(delegate.create(ReflectionUtils
delegate.destroy(instance, ReflectionUtils
.<CreationalContext<Object>> cast(creationalContext));
import static org.apache.deltaspike.core.util.ReflectionUtils.getRawType;
.readFromType(type).types(type.getBaseType(), Object.class)
public class MessageBundleLiteral extends AnnotationLiteral<MessageBundle> implements MessageBundle
import org.apache.deltaspike.core.impl.util.ArraysUtils;
public AbstractImmutableBean(Class<?> beanClass,
String name,
Set<Annotation> qualifiers,
Class<? extends Annotation> scope,
Set<Class<? extends Annotation>> stereotypes,
Set<Type> types,
boolean alternative,
boolean nullable,
Set<InjectionPoint> injectionPoints,
String toString)
this.qualifiers = Collections.<Annotation>singleton(new DefaultLiteral());
this.stereotypes = new HashSet<Class<? extends Annotation>>(stereotypes);
this.types = ArraysUtils.<Type>asSet(Object.class, beanClass);
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
package org.apache.deltaspike.core.impl.message;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Set;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.spi.Bean;
import org.apache.deltaspike.core.util.ReflectionUtils;
class ImmutableBeanWrapper<T> extends AbstractImmutableBean<T>
{
private final Bean<T> wrapped;
public ImmutableBeanWrapper(Bean<T> bean,
String name,
Set<Annotation> qualifiers,
Class<? extends Annotation> scope,
Set<Class<? extends Annotation>> stereotypes,
Set<Type> types,
boolean alternative,
boolean nullable,
String toString)
{
super(bean.getBeanClass(), name, qualifiers, scope, stereotypes,
types, alternative, nullable, bean.getInjectionPoints(), toString);
this.wrapped = bean;
}
@Override
public T create(CreationalContext<T> creationalContext)
{
return ReflectionUtils.cast(wrapped.create(creationalContext));
}
@Override
public void destroy(T instance, CreationalContext<T> creationalContext)
{
wrapped.destroy(instance, creationalContext);
}
}
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
private final Collection<AnnotatedType<?>> messageBundleTypes = new HashSet<AnnotatedType<?>>();
private Boolean isActivated = null;
@SuppressWarnings("UnusedDeclaration")
protected void init(@Observes BeforeBeanDiscovery afterBeanDiscovery)
initActivation();
@SuppressWarnings("UnusedDeclaration")
protected void detectInterfaces(@Observes ProcessAnnotatedType<?> event)
if (!this.isActivated)
{
return;
}
@SuppressWarnings("UnusedDeclaration")
protected void detectProducers(@Observes ProcessProducerMethod<Object, TypedMessageBundleProducer> event)
if (!this.isActivated)
{
return;
}
@SuppressWarnings("UnusedDeclaration")
protected void detectProducersInverted(@Observes ProcessProducerMethod<TypedMessageBundleProducer, Object> event)
if (!this.isActivated)
{
return;
}
protected void captureProducers(AnnotatedMethod<?> method, Bean<?> bean)
@SuppressWarnings("UnusedDeclaration")
protected void installBeans(@Observes AfterBeanDiscovery event, BeanManager beanManager)
AnnotatedType<T> type, BeanManager beanManager)
@SuppressWarnings("UnusedDeclaration")
protected void cleanup(@Observes AfterDeploymentValidation event)
protected void initActivation()
{
if (isActivated == null)
{
isActivated = ClassDeactivationUtils.isActivated(getClass());
}
}
import org.apache.deltaspike.core.api.message.Message;
public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable
result = String.format(message.value(), args);
result = MessageFormat.format(message.value(), args);
return result;
import static org.apache.deltaspike.core.impl.util.ArraysUtils.asSet;
private final Bean<T> delegate;
NarrowingBeanBuilder(Bean<Object> delegate, BeanManager beanManager)
this.delegate = (Bean<T>)delegate;
public ImmutableBeanWrapper<T> create()
return new ImmutableBeanWrapper<T>(delegate, name, qualifiers, scope,
package org.apache.deltaspike.core.impl.message;
import org.apache.deltaspike.core.util.ClassUtils;
import javax.enterprise.inject.Typed;
import java.lang.reflect.Proxy;
@Typed()
abstract class ProxyUtils
{
private ProxyUtils()
{
}
static <T> T createMessageBundleProxy(Class<T> type)
{
return type.cast(Proxy.newProxyInstance(
ClassUtils.getClassLoader(null), new Class<?>[]{type}, new MessageBundleInvocationHandler()));
}
}
import static org.apache.deltaspike.core.impl.message.ProxyUtils.createMessageBundleProxy;
@SuppressWarnings("UnusedDeclaration")
return createMessageBundleProxy(getRawType(injectionPoint.getType()));
package org.apache.deltaspike.core.impl.util;
import javax.enterprise.inject.Typed;
import java.util.HashSet;
import java.util.Set;
@Typed()
public abstract class ArraysUtils
{
private ArraysUtils()
{
}
public static <T> Set<T> asSet(T... array)
{
Set<T> result = new HashSet<T>();
for (T a : array)
{
result.add(a);
}
return result;
}
}
public interface BirdMessages
{
@Message("Spotted %s jays")
String numberOfJaysSpotted(int number);
public class Jay
{
@Inject
@MessageBundle
private BirdMessages messages;
String getMessage()
{
return messages.numberOfJaysSpotted(8);
}
import java.util.Collections;
Collections.addAll(result, array);
package org.apache.deltaspike.core.api.message;
import java.io.Serializable;
import java.util.Locale;
public interface LocaleResolver extends Serializable
Locale getLocale();
}
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
package org.apache.deltaspike.core.api.message;
import java.io.Serializable;
public interface MessageResolver extends Serializable
String MISSING_RESOURCE_MARKER = "???";
String getMessage(String messageDescriptor);
import org.apache.deltaspike.core.util.PropertyFileUtils;
try
Enumeration<URL> propertyFileUrls = PropertyFileUtils.resolvePropertyFiles(PROPERTY_FILE_NAME);
import org.apache.deltaspike.core.util.PropertyFileUtils;
properties = PropertyFileUtils.loadProperties(propertyFileUrl);
protected void installMessageBundleProducerBeans(@Observes AfterBeanDiscovery event, BeanManager beanManager)
event.addBean(createMessageBundleBean(bundleProducerBean, type, beanManager));
AnnotatedType<T> annotatedType,
BeanManager beanManager)
.readFromType(annotatedType)
.types(annotatedType.getJavaClass(), Object.class)
.create();
import org.apache.deltaspike.core.api.literal.MessageContextConfigLiteral;
import org.apache.deltaspike.core.api.message.LocaleResolver;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import org.apache.deltaspike.core.api.message.MessageResolver;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.util.ClassUtils;
import java.util.Locale;
MessageContextConfig messageContextConfig =
method.getDeclaringClass().getAnnotation(MessageContextConfig.class);
if (messageContextConfig == null)
messageContextConfig = new MessageContextConfigLiteral();
String messageTemplate;
if (!MessageResolver.class.equals(messageContextConfig.messageResolver()))
{
Class<? extends MessageResolver> messageResolverClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.messageResolver().getName());
MessageResolver messageResolver = BeanProvider.getContextualReference(messageResolverClass);
messageTemplate = messageResolver.getMessage(message.value());
}
else
{
Class<? extends LocaleResolver> localeResolverClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.localeResolver().getName());
Locale resolvedLocale = Locale.getDefault();
if (!LocaleResolver.class.equals(localeResolverClass))
{
LocaleResolver localeResolver = BeanProvider.getContextualReference(localeResolverClass);
resolvedLocale = localeResolver.getLocale();
}
String messageBundleName = method.getDeclaringClass().getName();
messageTemplate = new DefaultMessageResolver(messageBundleName, resolvedLocale).getMessage(message.value());
}
Class<? extends MessageInterpolator> messageInterpolatorClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.messageInterpolator().getName());
String result = messageTemplate;
if (!MessageInterpolator.class.equals(messageInterpolatorClass))
{
MessageInterpolator messageInterpolator = BeanProvider.getContextualReference(messageInterpolatorClass);
result = messageInterpolator.interpolate(messageTemplate, args);
}
private TestMessages messages;
public interface SimpleMessage
@Message("Welcome to DeltaSpike")
String welcomeToDeltaSpike();
package org.apache.deltaspike.core.api.config.annotation;
package org.apache.deltaspike.core.api.exclude.annotation;
import org.apache.deltaspike.core.api.message.annotation.MessageBundle;
import org.apache.deltaspike.core.api.message.annotation.MessageContextConfig;
package org.apache.deltaspike.core.api.message.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
@Target(METHOD)
@Retention(RUNTIME)
@Documented
public @interface Message
{
String value();
}
package org.apache.deltaspike.core.api.message.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
@Target({ TYPE, METHOD, PARAMETER, FIELD })
@Retention(RUNTIME)
@Documented
public @interface MessageBundle
{
}
package org.apache.deltaspike.core.api.message.annotation;
import org.apache.deltaspike.core.api.message.LocaleResolver;
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import org.apache.deltaspike.core.api.message.MessageResolver;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.message.annotation.MessageBundle;
import org.apache.deltaspike.core.api.message.annotation.Message;
import org.apache.deltaspike.core.api.message.annotation.MessageContextConfig;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.message.annotation.Message;
import org.apache.deltaspike.core.api.message.annotation.Message;
import org.apache.deltaspike.core.api.message.annotation.MessageBundle;
import org.apache.deltaspike.core.api.message.annotation.MessageBundle;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.config.annotation.ConfigProperty;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
import org.apache.deltaspike.core.api.exclude.annotation.Exclude;
package org.apache.deltaspike.core.api.message;
public interface Message
String getMessageTemplate();
Object[] getArguments();
Message addArgument(Object... arguments);
String getMessage(String messageTemplate);
public @interface MessageTemplate
package org.apache.deltaspike.core.impl.message;
import org.apache.deltaspike.core.api.message.LocaleResolver;
import javax.enterprise.inject.Typed;
import java.io.Serializable;
import java.util.Locale;
@Typed()
class DefaultLocaleResolver implements LocaleResolver, Serializable
private static final long serialVersionUID = 2075618472090834156L;
@Override
public Locale getLocale()
{
return Locale.getDefault();
}
package org.apache.deltaspike.core.impl.message;
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import javax.enterprise.inject.Typed;
import java.io.Serializable;
@Typed()
class DefaultMessageInterpolator implements MessageInterpolator, Serializable
private static final long serialVersionUID = -8854087197813424812L;
@Override
public String interpolate(String messageTemplate, Object... arguments)
{
return messageTemplate;
}
public String getMessage(String messageTemplate)
if (this.messageBundle != null && messageTemplate != null &&
messageTemplate.startsWith("{") && messageTemplate.endsWith("}"))
return this.messageBundle.getString(messageTemplate.substring(1, messageTemplate.length() - 1));
return messageTemplate;
import java.lang.reflect.Method;
import org.apache.deltaspike.core.api.message.Message;
import org.apache.deltaspike.core.api.message.MessageContext;
import org.apache.deltaspike.core.api.message.annotation.MessageTemplate;
validateMessageBundle(type.getJavaClass());
private void validateMessageBundle(Class<?> currentClass)
{
for (Method currentMethod : currentClass.getDeclaredMethods())
{
if (!currentMethod.isAnnotationPresent(MessageTemplate.class))
{
continue;
}
if (String.class.isAssignableFrom(currentMethod.getReturnType()))
{
continue;
}
if (Message.class.isAssignableFrom(currentMethod.getReturnType()))
{
validateMessageContextAwareMethod(currentMethod);
}
else
{
throw new IllegalStateException(
}
}
}
private void validateMessageContextAwareMethod(Method currentMethod)
{
for (Class currentParameterType : currentMethod.getParameterTypes())
{
if (MessageContext.class.isAssignableFrom(currentParameterType))
{
return;
}
}
}
import org.apache.deltaspike.core.api.message.MessageContext;
import org.apache.deltaspike.core.api.message.annotation.MessageContextConfig;
import org.apache.deltaspike.core.api.message.annotation.MessageTemplate;
import java.util.ArrayList;
import java.util.List;
final MessageTemplate messageTemplate = method.getAnnotation(MessageTemplate.class);
if (messageTemplate == null)
MessageContext messageContext = null;
List<Object> arguments = null;
if (args != null && args.length > 0)
arguments = new ArrayList<Object>(args.length);
for (Object arg : args)
if (MessageContext.class.isAssignableFrom(arg.getClass()))
{
messageContext = (MessageContext)arg;
continue;
}
arguments.add(arg);
}
}
if (messageContext == null)
{
MessageContextConfig messageContextConfig =
method.getDeclaringClass().getAnnotation(MessageContextConfig.class);
if (messageContextConfig == null)
{
messageContextConfig = new MessageContextConfigLiteral();
String resolvedMessageTemplate;
if (!MessageResolver.class.equals(messageContextConfig.messageResolver()))
{
Class<? extends MessageResolver> messageResolverClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.messageResolver().getName());
MessageResolver messageResolver = BeanProvider.getContextualReference(messageResolverClass);
resolvedMessageTemplate = messageResolver.getMessage(messageTemplate.value());
}
else
{
Class<? extends LocaleResolver> localeResolverClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.localeResolver().getName());
Locale resolvedLocale = Locale.getDefault();
if (!LocaleResolver.class.equals(localeResolverClass))
{
LocaleResolver localeResolver = BeanProvider.getContextualReference(localeResolverClass);
resolvedLocale = localeResolver.getLocale();
}
String messageBundleName = method.getDeclaringClass().getName();
resolvedMessageTemplate = new DefaultMessageResolver(messageBundleName, resolvedLocale)
.getMessage(messageTemplate.value());
}
Class<? extends MessageInterpolator> messageInterpolatorClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.messageInterpolator().getName());
String result = resolvedMessageTemplate;
if (!MessageInterpolator.class.equals(messageInterpolatorClass))
{
MessageInterpolator messageInterpolator = BeanProvider.getContextualReference(messageInterpolatorClass);
result = messageInterpolator.interpolate(resolvedMessageTemplate, args);
}
return result;
else
if (String.class.isAssignableFrom(method.getReturnType()))
{
return messageContext.message().text(messageTemplate.value()).argument(arguments.toArray()).toText();
}
return messageContext.message().text(messageTemplate.value()).argument(arguments.toArray()).create();
}
import org.apache.deltaspike.core.api.message.Message;
import org.apache.deltaspike.core.api.message.MessageContext;
import org.apache.deltaspike.core.api.message.annotation.MessageTemplate;
@MessageTemplate("Welcome to DeltaSpike")
@MessageTemplate("Welcome to %s")
Message welcomeTo(MessageContext messageContext, String name);
@Nonbinding
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
int ordinal() default 0;
public CaughtException(final ExceptionStack stack, final boolean beforeTraversal, final boolean handled)
if (stack == null)
throw new IllegalArgumentException("null is not valid for stack");
this.exception = (T) stack.getCurrent();
this.exceptionStack = stack;
public boolean isUnmute()
public ExceptionHandlingFlow getFlow()
public Throwable getThrowNewException()
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@SuppressWarnings("CdiManagedBeanInconsistencyInspection")
this.causes = this.createThrowableCollection(exceptionStackItems);
}
else
private Collection<ExceptionStackItem> createExceptionStackFrom(Collection<Throwable> throwables)
private Collection<Throwable> createThrowableCollection(final Collection<ExceptionStackItem> exceptionStackItems)
return Collections.unmodifiableCollection(this.createThrowableCollection(this.remaining));
public void setCauseElements(Collection<Throwable> elements)
this.exceptionStackItems = new ArrayDeque<ExceptionStackItem>(this.createExceptionStackFrom(elements));
this.init();
}
public void skipCause()
{
private final Throwable throwable;
private final StackTraceElement[] stackTraceElements;
public void setHandled(boolean handled)
boolean isBefore();
import javax.enterprise.inject.spi.BeanManager;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Collection;
import java.util.Set;
Collection<HandlerMethod<? extends Throwable>> getHandlersForException(Type exceptionClass, BeanManager bm,
Set<Annotation> handlerQualifiers,
boolean isBefore);
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@SuppressWarnings({ "MethodWithMoreThanThreeNegations" })
@Override
import org.apache.deltaspike.core.impl.exception.control.extension.CatchExtension;
public void executeHandlers(@Observes @Any ExceptionToCatch eventException, final BeanManager bm) throws Throwable
final HandlerMethodStorage handlerMethodStorage = CatchExtension.createStorage();
inbound_cause:
break;
default:
bm, eventException.getQualifiers(), false);
break;
default:
}
finally
public HandlerMethodImpl(final AnnotatedMethod<?> method, final BeanManager bm)
{
if (!HandlerMethodImpl.isHandler(method))
{
throw new IllegalArgumentException(MessageFormat.format("{0} is not a valid handler", method));
}
this.beanManager = bm;
final Set<Annotation> tmpQualifiers = new HashSet<Annotation>();
this.handler = method;
this.javaMethod = method.getJavaMember();
this.handlerParameter = findHandlerParameter(method);
if (!this.handlerParameter.isAnnotationPresent(Handles.class)
&& !this.handlerParameter.isAnnotationPresent(BeforeHandles.class))
{
throw new IllegalArgumentException("Method is not annotated with @Handles or @BeforeHandles");
}
this.before = this.handlerParameter.getAnnotation(BeforeHandles.class) != null;
this.ordinal = this.handlerParameter.getAnnotation(Handles.class).ordinal();
tmpQualifiers.addAll(BeanUtils.getQualifiers(bm, this.handlerParameter.getAnnotations()));
if (tmpQualifiers.isEmpty())
{
tmpQualifiers.add(new AnyLiteral());
}
this.qualifiers = tmpQualifiers;
this.beanClass = method.getJavaMember().getDeclaringClass();
this.exceptionType = ((ParameterizedType) this.handlerParameter.getBaseType()).getActualTypeArguments()[0];
this.injectionPoints = new HashSet<InjectionPoint>(method.getParameters().size() - 1);
for (AnnotatedParameter<?> param : method.getParameters())
{
if (!param.equals(this.handlerParameter))
{
this.injectionPoints.add(new ImmutableInjectionPoint(param, bm, this.getBean(bm), false, false));
}
}
}
@Override
@Override
@Override
}
finally
private <X> InjectableMethod<X> createInjectableMethod(AnnotatedMethod<X> handlerMethod,
Bean<?> bean, BeanManager manager)
@Override
package org.apache.deltaspike.core.impl.exception.control;
import org.apache.deltaspike.core.api.exception.control.HandlerMethod;
private final CaughtException<?> event;
private final BeanManager bm;
private final Bean<?> declaringBean;
private final HandlerMethodImpl<?> handlerMethod;
@Override
}
finally
import org.apache.deltaspike.core.impl.exception.control.HandlerMethodStorage;
import org.apache.deltaspike.core.impl.exception.control.HandlerMethodStorageImpl;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
@SuppressWarnings({ "unchecked", "CdiManagedBeanInconsistencyInspection" })
public class CatchExtension implements Extension, Deactivatable
private Logger log = Logger.getLogger(CatchExtension.class.toString());
CatchExtension.allHandlers = new HashMap<Type, Collection<HandlerMethod<? extends Throwable>>>();
if (!ClassDeactivationUtils.isActivated(CatchExtension.class))
{
return;
}
final Class<? extends Throwable> exceptionType = (Class<? extends Throwable>) ((ParameterizedType)
param.getBaseType()).getActualTypeArguments()[0];
if (!ClassDeactivationUtils.isActivated(CatchExtension.class))
{
return;
}
for (Map.Entry<? super Type, Collection<HandlerMethod<? extends Throwable>>> entry : allHandlers.entrySet())
}
catch (InjectionException e)
public static HandlerMethodStorage createStorage()
return new HandlerMethodStorageImpl(Collections.unmodifiableMap(CatchExtension.allHandlers));
private <T extends Throwable> void registerHandlerMethod(HandlerMethod<T> handlerMethod)
@Target(ElementType.PARAMETER)
return this.markedHandled;
}
public boolean isBeforeTraversal()
{
return beforeTraversal;
@SuppressWarnings({"MethodWithMoreThanThreeNegations"})
if (!isBefore)
inbound_cause:
if (this.before)
{
this.ordinal = this.handlerParameter.getAnnotation(BeforeHandles.class).ordinal();
}
else
{
this.ordinal = this.handlerParameter.getAnnotation(Handles.class).ordinal();
}
if (handler.isBefore() && isBefore)
{
if (handler.getQualifiers().contains(new AnyLiteral()))
{
returningHandlers.add(handler);
}
else
{
if (!handlerQualifiers.isEmpty() && this.containsAny(handler.getQualifiers(),
handlerQualifiers))
{
returningHandlers.add(handler);
}
}
}
else if (!handler.isBefore() && !isBefore)
public static <T> T getContextualReference(Class<T> type, Bean<T> bean)
{
return getContextualReference(type, getBeanManager(), bean);
}
private static <T> T getContextualReference(Class<T> type, BeanManager beanManager, Bean<?> bean)
{
return getContextualReference(type, beanManager, new HashSet<Bean<?>>((Collection) Arrays.asList(bean)));
}
Set<Bean<T>> beans = getBeanDefinitions(type, optional, includeDefaultScopedBeans, beanManager);
List<T> result = new ArrayList<T>(beans.size());
for (Bean<?> bean : beans)
{
result.add(getContextualReference(type, beanManager, bean));
}
return result;
}
public static <T> Set<Bean<T>> getBeanDefinitions(Class<T> type,
boolean optional,
boolean includeDefaultScopedBeans)
{
BeanManager beanManager = getBeanManager();
return getBeanDefinitions(type, optional, includeDefaultScopedBeans, beanManager);
}
private static <T> Set<Bean<T>> getBeanDefinitions(Class<T> type,
boolean optional,
boolean includeDefaultScopedBeans,
BeanManager beanManager)
{
return Collections.emptySet();
Set<Bean<T>> result = new HashSet<Bean<T>>();
result.add((Bean<T>) bean);
@SuppressWarnings({ "unchecked", "CdiManagedBeanInconsistencyInspection" })
public ExceptionHandlingFlow getCurrentExceptionHandlingFlow()
private static final long serialVersionUID = -6069790756478700680L;
e = e.getCause();
while (e != null);
boolean isBeforeHandler();
@Override
@SuppressWarnings({ "MethodWithMoreThanThreeNegations" })
lhs.isBeforeHandler());
import org.apache.deltaspike.core.api.provider.BeanProvider;
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
@SuppressWarnings("UnusedDeclaration")
public class ExceptionHandlerDispatch
private static final Logger LOG = Logger.getLogger(ExceptionHandlerDispatch.class.getName());
@SuppressWarnings({ "unchecked", "MethodWithMultipleLoops", "ThrowableResultOfMethodCallIgnored" })
public void executeHandlers(@Observes @Any ExceptionToCatch exceptionEvent,
final BeanManager beanManager) throws Throwable
LOG.entering(ExceptionHandlerDispatch.class.getName(), "executeHandlers", exceptionEvent.getException());
CreationalContext<Object> creationalContext = null;
final HandlerMethodStorage handlerMethodStorage =
BeanProvider.getContextualReference(HandlerMethodStorage.class);
creationalContext = beanManager.createCreationalContext(null);
final ExceptionStack stack = new ExceptionStack(exceptionEvent.getException());
beanManager, exceptionEvent.getQualifiers(), true));
LOG.fine(String.format("Notifying handler %s", handler));
exceptionEvent.isHandled());
LOG.fine(String.format("Handler %s returned status %s", handler,
breadthFirstEvent.getCurrentExceptionHandlingFlow().name()));
switch (breadthFirstEvent.getCurrentExceptionHandlingFlow())
exceptionEvent.setHandled(true);
exceptionEvent.setHandled(true);
exceptionEvent.setHandled(true);
throwException = exceptionEvent.getException();
throw new IllegalStateException(
beanManager, exceptionEvent.getQualifiers(), false);
LOG.fine(String.format("Notifying handler %s", handler));
exceptionEvent.isHandled());
LOG.fine(String.format("Handler %s returned status %s", handler,
depthFirstEvent.getCurrentExceptionHandlingFlow().name()));
switch (depthFirstEvent.getCurrentExceptionHandlingFlow())
exceptionEvent.setHandled(true);
exceptionEvent.setHandled(true);
exceptionEvent.setHandled(true);
throwException = exceptionEvent.getException();
throw new IllegalStateException(
stack.skipCause();
if (!exceptionEvent.isHandled() && throwException == null)
LOG.warning(String.format("No handlers found for exception %s", exceptionEvent.getException()));
throw exceptionEvent.getException();
if (creationalContext != null)
creationalContext.release();
LOG.exiting(ExceptionHandlerDispatch.class.getName(), "executeHandlers", exceptionEvent.getException());
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import javax.enterprise.inject.Typed;
@Typed()
private final Class beanClass;
private Set<InjectionPoint> injectionPoints;
public Bean<?> getBean()
initBean();
private synchronized void initBean()
{
if (this.bean != null)
{
return;
}
@SuppressWarnings("unchecked")
Set<Bean<?>> beans = BeanProvider.getBeanDefinitions(this.beanClass, false, true);
if (beans.size() > 1)
{
}
this.bean = beans.iterator().next();
}
ctx = getBeanManager().createCreationalContext(null);
@SuppressWarnings("unchecked")
Object handlerInstance = BeanProvider.getContextualReference(this.beanClass);
InjectableMethod<?> im = createInjectableMethod(this.handler, this.getBean());
im.invoke(handlerInstance, ctx, new OutboundParameterValueRedefiner(event, this));
private <X> InjectableMethod<X> createInjectableMethod(AnnotatedMethod<X> handlerMethod, Bean<?> bean)
return new InjectableMethod<X>(handlerMethod, bean, getBeanManager());
public boolean isBeforeHandler()
if (this.injectionPoints == null)
{
this.injectionPoints = new HashSet<InjectionPoint>(handler.getParameters().size() - 1);
for (AnnotatedParameter<?> param : handler.getParameters())
{
if (!param.equals(this.handlerParameter))
{
this.injectionPoints.add(
new ImmutableInjectionPoint(param, getBeanManager(), getBean(), false, false));
}
}
}
private BeanManager getBeanManager()
{
if (this.beanManager == null)
{
this.beanManager = BeanManagerProvider.getInstance().getBeanManager();
}
return this.beanManager;
}
import javax.enterprise.inject.Typed;
@Typed()
class HandlerMethodStorageImpl implements HandlerMethodStorage
HandlerMethodStorageImpl(Map<? super Type, Collection<HandlerMethod<? extends Throwable>>> allHandlers)
if (handler.isBeforeHandler() && isBefore)
else if (!handler.isBeforeHandler() && !isBefore)
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
class OutboundParameterValueRedefiner implements ParameterValueRedefiner
OutboundParameterValueRedefiner(final CaughtException<?> event, final HandlerMethodImpl<?> handlerMethod)
this.declaringBean = handlerMethod.getBean();
this.handlerMethod = handlerMethod;
CreationalContext<?> ctx = BeanManagerProvider.getInstance().getBeanManager()
.createCreationalContext(this.declaringBean);
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import javax.enterprise.inject.spi.ProcessAnnotatedType;
private static final Logger LOG = Logger.getLogger(CatchExtension.class.getName());
private Map<? super Type, Collection<HandlerMethod<? extends Throwable>>> allHandlers
= new HashMap<Type, Collection<HandlerMethod<? extends Throwable>>>();
private Boolean isActivated = null;
@SuppressWarnings("UnusedDeclaration")
protected void init(@Observes BeforeBeanDiscovery afterBeanDiscovery)
initActivation();
@SuppressWarnings("UnusedDeclaration")
public <T> void findHandlers(@Observes final ProcessAnnotatedType processAnnotatedType,
final BeanManager beanManager)
if (!this.isActivated)
if (processAnnotatedType.getAnnotatedType().getJavaClass().isAnnotationPresent(ExceptionHandler.class))
final Set<AnnotatedMethod<? super T>> methods = processAnnotatedType.getAnnotatedType().getMethods();
throw new IllegalStateException(
String.format("Handler method %s must not throw exceptions", method.getJavaMember()));
registerHandlerMethod(new HandlerMethodImpl(method, beanManager));
@SuppressWarnings("UnusedDeclaration")
final AfterDeploymentValidation afterDeploymentValidation,
final BeanManager beanManager)
if (!this.isActivated)
beanManager.validate(ip);
afterDeploymentValidation.addDeploymentProblem(e);
public Map<? super Type, Collection<HandlerMethod<? extends Throwable>>> getAllExceptionHandlers()
return Collections.unmodifiableMap(allHandlers);
LOG.fine(String.format("Adding handler %s to known handlers", handlerMethod));
if (allHandlers.containsKey(handlerMethod.getExceptionType()))
allHandlers.get(handlerMethod.getExceptionType()).add(handlerMethod);
allHandlers.put(handlerMethod.getExceptionType(),
new HashSet<HandlerMethod<? extends Throwable>>(Arrays.asList(handlerMethod)));
}
}
public void initActivation()
{
if (isActivated == null)
{
isActivated = ClassDeactivationUtils.isActivated(getClass());
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
private boolean abortCalled = false;
private boolean proceedCalled = false;
public boolean isAbortCalled()
{
return abortCalled;
}
public boolean isProceedCalled()
{
return proceedCalled;
}
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
private boolean abortCalled = false;
private boolean proceedCalled = false;
protected AbortingDepthHandler()
{
}
public boolean isAbortCalled()
{
return abortCalled;
}
public boolean isProceedCalled()
{
return proceedCalled;
}
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
private boolean exAscCalled = false;
private boolean iaeAscCalled = false;
private boolean npeDescCalled = false;
exAscCalled = true;
iaeAscCalled = true;
npeDescCalled = true;
public boolean isExAscCalled()
{
return exAscCalled;
}
public boolean isIaeAscCalled()
{
return iaeAscCalled;
}
public boolean isNpeDescCalled()
{
return npeDescCalled;
}
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
private int breadthFirstNpeCalled = 0;
private int breadthFirstNpeLowerPrecedenceCalled = 0;
private int depthFirstNpeCalled = 0;
private int depthFirstNpeHigherPrecedenceCalled = 0;
public void npeInboundHandler(@BeforeHandles CaughtException<NullPointerException> event)
breadthFirstNpeCalled;
breadthFirstNpeLowerPrecedenceCalled;
depthFirstNpeCalled;
depthFirstNpeHigherPrecedenceCalled;
public int getBreadthFirstNpeCalled()
{
return breadthFirstNpeCalled;
}
public int getBreadthFirstNpeLowerPrecedenceCalled()
{
return breadthFirstNpeLowerPrecedenceCalled;
}
public int getDepthFirstNpeCalled()
{
return depthFirstNpeCalled;
}
public int getDepthFirstNpeHigherPrecedenceCalled()
{
return depthFirstNpeHigherPrecedenceCalled;
}
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
private boolean outboundHandlerCalled = false;
private int outboundHandlerTimesCalled = 0;
private boolean protectedHandlerCalled = false;
private int inboundHandlerTimesCalled = 0;
private boolean beanmanagerInjected = false;
private boolean locationDifferBeanmanagerInjected = false;
outboundHandlerCalled = true;
outboundHandlerTimesCalled;
inboundHandlerTimesCalled;
beanmanagerInjected = true;
protectedHandlerCalled = true;
locationDifferBeanmanagerInjected = true;
public boolean isOutboundHandlerCalled()
{
return outboundHandlerCalled;
}
public int getOutboundHandlerTimesCalled()
{
return outboundHandlerTimesCalled;
}
public boolean isProtectedHandlerCalled()
{
return protectedHandlerCalled;
}
public void setOutboundHandlerTimesCalled(int outboundHandlerTimesCalled)
{
this.outboundHandlerTimesCalled = outboundHandlerTimesCalled;
}
public void setInboundHandlerTimesCalled(int inboundHandlerTimesCalled)
{
this.inboundHandlerTimesCalled = inboundHandlerTimesCalled;
}
public int getInboundHandlerTimesCalled()
{
return inboundHandlerTimesCalled;
}
public boolean isBeanmanagerInjected()
{
return beanmanagerInjected;
}
public boolean isLocationDifferBeanmanagerInjected()
{
return locationDifferBeanmanagerInjected;
}
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
private int depthFirstNumberCalled = 0;
private int breadthFirstNumberCalled = 0;
depthFirstNumberCalled;
breadthFirstNumberCalled;
public int getDepthFirstNumberCalled()
{
return depthFirstNumberCalled;
}
public int getBreadthFirstNumberCalled()
{
return breadthFirstNumberCalled;
}
import org.apache.deltaspike.core.api.provider.BeanProvider;
protected HandlerMethodStorage createHandlerMethodStorage()
CatchExtension catchExtension = BeanProvider.getContextualReference(CatchExtension.class);
import java.net.URI;
final JavaArchive foundJar = ShrinkWrap.createFromZipFile(JavaArchive.class, new File(URI.create(jarUrlPath)));
if (excludeIfPackageExists != null)
{
for (String excludePackage : excludeIfPackageExists)
{
if (foundJar.contains(excludePackage.replaceAll("\\.", "\\/"))) {
return null;
}
}
}
if (includeIfPackageExists != null)
{
for (String includePackage : includeIfPackageExists)
{
if (foundJar.contains(includePackage.replaceAll("\\.", "\\/")))
{
return foundJar;
}
}
}
import java.net.URI;
final JavaArchive foundJar = ShrinkWrap.createFromZipFile(JavaArchive.class, new File(URI.create(jarUrlPath)));
if (excludeIfPackageExists != null)
{
for (String excludePackage : excludeIfPackageExists)
{
if (foundJar.contains(excludePackage.replaceAll("\\.", "\\/"))) {
return null;
}
}
}
if (includeIfPackageExists != null)
{
for (String includePackage : includeIfPackageExists)
{
if (foundJar.contains(includePackage.replaceAll("\\.", "\\/")))
{
return foundJar;
}
}
}
import org.apache.deltaspike.core.impl.exception.control.extension.ExceptionControlExtension;
ExceptionControlExtension exceptionControlExtension =
BeanProvider.getContextualReference(ExceptionControlExtension.class);
return new HandlerMethodStorageImpl(exceptionControlExtension.getAllExceptionHandlers());
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.Decorator;
import javax.enterprise.inject.spi.Interceptor;
import javax.enterprise.inject.spi.ProcessBean;
public class ExceptionControlExtension implements Extension, Deactivatable
private static final Logger LOG = Logger.getLogger(ExceptionControlExtension.class.getName());
public <T> void findHandlers(@Observes final ProcessBean<?> processBean, final BeanManager beanManager)
if (processBean.getBean() instanceof Interceptor || processBean.getBean() instanceof Decorator ||
!(processBean.getAnnotated() instanceof AnnotatedType))
return;
}
AnnotatedType annotatedType = (AnnotatedType)processBean.getAnnotated();
if (annotatedType.getJavaClass().isAnnotationPresent(ExceptionHandler.class))
{
final Set<AnnotatedMethod<? super T>> methods = annotatedType.getMethods();
processBean.addDefinitionError(new IllegalArgumentException(
String.format("Handler method %s must not throw exceptions", method.getJavaMember())));
void notify(ExceptionEvent<T> event);
package org.apache.deltaspike.core.impl.exception.control;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandlingFlow;
import org.apache.deltaspike.core.api.exception.control.ExceptionStack;
import org.apache.deltaspike.core.spi.exception.control.IntrospectiveExceptionEvent;
@SuppressWarnings({"unchecked", "CdiManagedBeanInconsistencyInspection"})
public class ExceptionEventImpl<T extends Throwable> implements IntrospectiveExceptionEvent<T>
public ExceptionEventImpl(final ExceptionStack stack, final boolean beforeTraversal, final boolean handled)
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@SuppressWarnings({"unchecked", "MethodWithMultipleLoops", "ThrowableResultOfMethodCallIgnored"})
BeanProvider.getContextualReference(HandlerMethodStorage.class);
inbound_cause:
final ExceptionEventImpl breadthFirstEvent = new ExceptionEventImpl(stack, true,
final ExceptionEventImpl depthFirstEvent = new ExceptionEventImpl(stack, false,
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
public void notify(final ExceptionEvent<T> event)
new ImmutableInjectionPoint(param, getBeanManager(), getBean(), false, false));
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
private final ExceptionEvent<?> event;
OutboundParameterValueRedefiner(final ExceptionEvent<?> event, final HandlerMethodImpl<?> handlerMethod)
.createCreationalContext(this.declaringBean);
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
public void abortHandler(@BeforeHandles ExceptionEvent<Exception> event)
public void proceedHandler(@Handles ExceptionEvent<NullPointerException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
public void abortHandler(@Handles ExceptionEvent<Exception> event)
public void proceedHandler(@Handles ExceptionEvent<Throwable> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
public void exHandler(@Handles ExceptionEvent<Exception> event)
public void npeHandler(@Handles ExceptionEvent<IllegalArgumentException> event)
public void npeDescHandler(@BeforeHandles ExceptionEvent<NullPointerException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
public void npeInboundHandler(@BeforeHandles ExceptionEvent<NullPointerException> event)
@BeforeHandles(ordinal = -50) ExceptionEvent<NullPointerException> event)
public void npeOutboundHandler(@Handles ExceptionEvent<NullPointerException> event)
public void npeHigherPrecedenceOutboundHandler(@Handles(ordinal = -10) ExceptionEvent<NullPointerException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
public void rethrow(@Handles ExceptionEvent<NullPointerException> event)
@BeforeHandles ExceptionEvent<IllegalArgumentException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
public void rethrow(@Handles ExceptionEvent<NullPointerException> event)
@BeforeHandles ExceptionEvent<IllegalArgumentException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
void handleException(int firstParam, @Handles ExceptionEvent<Exception> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
public void basicHandler(@Handles ExceptionEvent<Exception> event)
public void basicInboundHandler(@BeforeHandles ExceptionEvent<Exception> event)
public void extraInjections(@Handles ExceptionEvent<IllegalArgumentException> event, BeanManager bm)
void protectedHandler(@Handles ExceptionEvent<IllegalStateException> event)
private void handlerLocationInjections(BeanManager bm, @Handles ExceptionEvent<SQLException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
public void catchDescException(@BeforeHandles ExceptionEvent<Exception> event)
public void catchFrameworkDescException(@BeforeHandles(ordinal = -50) ExceptionEvent<Exception> event)
public void catchRuntime(@Handles ExceptionEvent<RuntimeException> event)
@BeforeHandles(ordinal = 10) ExceptionEvent<Throwable> event)
@BeforeHandles(ordinal = 20) ExceptionEvent<Throwable> event)
@Handles(ordinal = 10) ExceptionEvent<Throwable> event)
@Handles(ordinal = 20) ExceptionEvent<Throwable> event)
public void catchIAE(@Handles ExceptionEvent<IllegalArgumentException> event)
public void qualifiedHandler(@Handles @CatchQualifier ExceptionEvent<Exception> event)
public void arqHandler(@Handles @Arquillian ExceptionEvent<Throwable> event)
public void arqTestingHandler(@Handles @Arquillian @CatchQualifier ExceptionEvent<Throwable> event)
@Handles ExceptionEvent<SQLException> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
public void throwsAnException(@Handles ExceptionEvent<Throwable> evt) throws Exception
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
public void unMuteHandlerAsc(@Handles ExceptionEvent<Exception> event)
public void unMuteHandlerDesc(@BeforeHandles ExceptionEvent<Exception> event)
import org.apache.deltaspike.core.api.exception.control.ExceptionEvent;
public void handleException1BF(@BeforeHandles ExceptionEvent<Exceptions.Exception1> event)
public void handleException2BF(@BeforeHandles ExceptionEvent<Exceptions.Exception2> event)
public void handleException3DF(@Handles ExceptionEvent<Exceptions.Exception3> event)
public void handleException3BF(@BeforeHandles ExceptionEvent<Exceptions.Exception3> event)
public void handleException3SuperclassBF(@BeforeHandles ExceptionEvent<Exceptions.Exception3Super> event)
public void handleException3SuperclassDF(@Handles ExceptionEvent<Exceptions.Exception3Super> event)
public void handleException2DF(@Handles ExceptionEvent<Exceptions.Exception2> event)
public void handleException1DF(@Handles ExceptionEvent<Exceptions.Exception1> event)
@SuppressWarnings({ "unchecked", "CdiManagedBeanInconsistencyInspection" })
public class DefaultExceptionEvent<T extends Throwable> implements IntrospectiveExceptionEvent<T>
public DefaultExceptionEvent(final ExceptionStack stack, final boolean beforeTraversal, final boolean handled)
@SuppressWarnings({ "unchecked", "MethodWithMultipleLoops", "ThrowableResultOfMethodCallIgnored" })
inbound_cause:
final List<HandlerMethod<?>> callbackExceptionEvent = new ArrayList<HandlerMethod<?>>(
for (HandlerMethod<?> handler : callbackExceptionEvent)
final DefaultExceptionEvent callbackEvent = new DefaultExceptionEvent(stack, true,
handler.notify(callbackEvent);
callbackEvent.getCurrentExceptionHandlingFlow().name()));
if (!callbackEvent.isUnmute())
switch (callbackEvent.getCurrentExceptionHandlingFlow())
throwException = callbackEvent.getThrowNewException();
final List<HandlerMethod<? extends Throwable>> handlerMethods =
Collections.reverse(handlerMethods);
for (HandlerMethod<?> handler : handlerMethods)
final DefaultExceptionEvent depthFirstEvent = new DefaultExceptionEvent(stack, false,
package org.apache.deltaspike.security.api.authentication.event;
package org.apache.deltaspike.security.api.authentication.event;
package org.apache.deltaspike.security.api.authentication.event;
package org.apache.deltaspike.security.api.authentication.event;
package org.apache.deltaspike.security.api.authentication.event;
package org.apache.deltaspike.security.api.authentication.event;
package org.apache.deltaspike.security.api.authentication.event;
import org.apache.deltaspike.security.api.authentication.event.AlreadyLoggedInEvent;
import org.apache.deltaspike.security.api.authentication.event.LoggedInEvent;
import org.apache.deltaspike.security.api.authentication.event.LoginFailedEvent;
import org.apache.deltaspike.security.api.authentication.event.PostAuthenticateEvent;
import org.apache.deltaspike.security.api.authentication.event.PostLoggedOutEvent;
import org.apache.deltaspike.security.api.authentication.event.PreAuthenticateEvent;
import org.apache.deltaspike.security.api.authentication.event.PreLoggedOutEvent;
import org.apache.deltaspike.security.api.authentication.event.LoginFailedEvent;
import org.apache.deltaspike.security.api.authentication.event.PostAuthenticateEvent;
import org.apache.deltaspike.security.api.authentication.event.LoginFailedEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
package org.apache.deltaspike.core.api.exception.control.event;
package org.apache.deltaspike.core.api.exception.control.event;
import org.apache.deltaspike.core.api.exception.control.ExceptionStackItem;
public class ExceptionStackEvent implements Serializable
public ExceptionStackEvent(final Throwable exception)
package org.apache.deltaspike.core.api.exception.control.event;
public class ExceptionToCatchEvent implements Serializable
public ExceptionToCatchEvent(Throwable exception, Annotation... qualifiers)
public ExceptionToCatchEvent(Throwable exception)
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionStackEvent;
public DefaultExceptionEvent(final ExceptionStackEvent stackEvent, final boolean beforeTraversal,
final boolean handled)
if (stackEvent == null)
throw new IllegalArgumentException("null is not valid for stackEvent");
this.exception = (T) stackEvent.getCurrent();
import org.apache.deltaspike.core.api.exception.control.event.ExceptionStackEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
public void executeHandlers(@Observes @Any ExceptionToCatchEvent exceptionEventEvent,
LOG.entering(ExceptionHandlerDispatch.class.getName(), "executeHandlers", exceptionEventEvent.getException());
final ExceptionStackEvent stack = new ExceptionStackEvent(exceptionEventEvent.getException());
beanManager, exceptionEventEvent.getQualifiers(), true));
exceptionEventEvent.isHandled());
exceptionEventEvent.setHandled(true);
exceptionEventEvent.setHandled(true);
exceptionEventEvent.setHandled(true);
throwException = exceptionEventEvent.getException();
beanManager, exceptionEventEvent.getQualifiers(), false);
exceptionEventEvent.isHandled());
exceptionEventEvent.setHandled(true);
exceptionEventEvent.setHandled(true);
exceptionEventEvent.setHandled(true);
throwException = exceptionEventEvent.getException();
if (!exceptionEventEvent.isHandled() && throwException == null)
LOG.warning(String.format("No handlers found for exception %s", exceptionEventEvent.getException()));
throw exceptionEventEvent.getException();
LOG.exiting(ExceptionHandlerDispatch.class.getName(), "executeHandlers",
exceptionEventEvent.getException());
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
package org.apache.deltaspike.core.api.exception.control.event;
package org.apache.deltaspike.core.api.exception.control.event;
import org.apache.deltaspike.core.api.exception.control.ExceptionStackItem;
public class ExceptionStackEvent implements Serializable
public ExceptionStackEvent(final Throwable exception)
package org.apache.deltaspike.core.api.exception.control.event;
public class ExceptionToCatchEvent implements Serializable
public ExceptionToCatchEvent(Throwable exception, Annotation... qualifiers)
public ExceptionToCatchEvent(Throwable exception)
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionStackEvent;
public DefaultExceptionEvent(final ExceptionStackEvent stackEvent, final boolean beforeTraversal,
final boolean handled)
if (stackEvent == null)
throw new IllegalArgumentException("null is not valid for stackEvent");
this.exception = (T) stackEvent.getCurrent();
import org.apache.deltaspike.core.api.exception.control.event.ExceptionStackEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
public void executeHandlers(@Observes @Any ExceptionToCatchEvent exceptionEventEvent,
LOG.entering(ExceptionHandlerDispatch.class.getName(), "executeHandlers", exceptionEventEvent.getException());
final ExceptionStackEvent stack = new ExceptionStackEvent(exceptionEventEvent.getException());
beanManager, exceptionEventEvent.getQualifiers(), true));
exceptionEventEvent.isHandled());
exceptionEventEvent.setHandled(true);
exceptionEventEvent.setHandled(true);
exceptionEventEvent.setHandled(true);
throwException = exceptionEventEvent.getException();
beanManager, exceptionEventEvent.getQualifiers(), false);
exceptionEventEvent.isHandled());
exceptionEventEvent.setHandled(true);
exceptionEventEvent.setHandled(true);
exceptionEventEvent.setHandled(true);
throwException = exceptionEventEvent.getException();
if (!exceptionEventEvent.isHandled() && throwException == null)
LOG.warning(String.format("No handlers found for exception %s", exceptionEventEvent.getException()));
throw exceptionEventEvent.getException();
LOG.exiting(ExceptionHandlerDispatch.class.getName(), "executeHandlers",
exceptionEventEvent.getException());
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionEvent;
String value;
for (ConfigSource configSource : appConfigSources)
value = configSource.getPropertyValue(key);
if (value != null)
new Object[]{value, key, configSource.getConfigName()});
return value;
new Object[]{key, configSource.getConfigName()});
List<String> result = new ArrayList<String>();
String value;
for (ConfigSource configSource : appConfigSources)
value = configSource.getPropertyValue(key);
if (value != null && !result.contains(value))
result.add(value);
return result;
ClassLoader currentClassLoader = ClassUtils.getClassLoader(null);
ConfigSource[] appConfigSources = configSources.get(currentClassLoader);
configSources.put(currentClassLoader, appConfigSources);
for (ConfigSourceProvider configSourceProvider : configSourceProviderServiceLoader)
appConfigSources.addAll(configSourceProvider.getConfigSources());
@SuppressWarnings("UnusedDeclaration")
private static final long serialVersionUID = -1399119195483111935L;
package org.apache.deltaspike.core.api.exception.control.annotation;
package org.apache.deltaspike.core.api.exception.control.annotation;
package org.apache.deltaspike.core.api.exception.control.annotation;
package org.apache.deltaspike.core.impl.config.injectable.extension;
import org.apache.deltaspike.core.impl.config.injectable.ConfigPropertyBean;
package org.apache.deltaspike.core.impl.config.injectable.extension;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
package org.apache.deltaspike.core.impl.exclude.extension;
import org.apache.deltaspike.core.impl.exclude.GlobalAlternative;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
import org.apache.deltaspike.core.api.exception.control.annotation.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.annotation.Handles;
@SuppressWarnings("UnusedDeclaration")
@SuppressWarnings("UnusedDeclaration")
public SecurityDefinitionException(Throwable cause)
import org.apache.deltaspike.core.impl.exclude.CustomProjectStageBeanFilter;
private Boolean isCustomProjectStageBeanFilterActivated = null;
if (this.isCustomProjectStageBeanFilterActivated)
{
vetoCustomProjectStageBeans(processAnnotatedType);
}
protected void vetoCustomProjectStageBeans(ProcessAnnotatedType<Object> processAnnotatedType)
{
if (ProjectStage.class.isAssignableFrom(processAnnotatedType.getAnnotatedType().getJavaClass()))
{
processAnnotatedType.veto();
}
}
isActivated =
ClassDeactivationUtils.isActivated(getClass());
isGlobalAlternativeActivated =
ClassDeactivationUtils.isActivated(GlobalAlternative.class);
isCustomProjectStageBeanFilterActivated =
ClassDeactivationUtils.isActivated(CustomProjectStageBeanFilter.class);
import org.apache.deltaspike.core.util.metadata.builder.ImmutableInjectionPoint;
package org.apache.deltaspike.core.util.metadata.builder;
package org.apache.deltaspike.core.util.metadata.builder;
package org.apache.deltaspike.core.util.metadata.builder;
package org.apache.deltaspike.core.util.metadata.builder;
package org.apache.deltaspike.core.util.metadata.builder;
package org.apache.deltaspike.core.util.metadata.builder;
package org.apache.deltaspike.core.util.metadata.builder;
package org.apache.deltaspike.core.util.metadata.builder;
package org.apache.deltaspike.core.util.metadata.builder;
package org.apache.deltaspike.core.util.metadata.builder;
package org.apache.deltaspike.core.util.metadata.builder;
package org.apache.deltaspike.core.util.metadata.builder;
package org.apache.deltaspike.core.util.metadata.builder;
import org.apache.deltaspike.core.util.metadata.builder.ParameterValueRedefiner.ParameterValue;
package org.apache.deltaspike.core.util.metadata.builder;
import org.apache.deltaspike.core.util.metadata.builder.ImmutableInjectionPoint;
import org.apache.deltaspike.core.util.metadata.builder.InjectableMethod;
import org.apache.deltaspike.core.util.metadata.builder.ParameterValueRedefiner;
import org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.core.util.metadata.builder.InjectableMethod;
import org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder;
}
import org.apache.deltaspike.core.util.metadata.builder.ParameterValueRedefiner;
class AnnotationBuilder
import org.apache.deltaspike.core.util.securitymanaged.SetAccessiblePrivilegedAction;
AccessController.doPrivileged(new SetAccessiblePrivilegedAction(method));
import org.apache.deltaspike.core.util.securitymanaged.SetAccessiblePrivilegedAction;
import java.security.AccessController;
AccessController.doPrivileged(new SetAccessiblePrivilegedAction(field));
AccessController.doPrivileged(new SetAccessiblePrivilegedAction(method));
package org.apache.deltaspike.core.util.securitymanaged;
import org.apache.deltaspike.core.util.ClassUtils;
= new WeakHashMap<ClassLoader, Map<String, Annotation>>();
if (Proxy.isProxyClass(args[0].getClass()))
{
if (Proxy.getInvocationHandler(args[0]) instanceof AnnotationInstanceProvider)
{
return equals(Proxy.getInvocationHandler(args[0]));
}
}
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.Collections;
private static final Class[] EMPTY_CLASS_ARRAY = new Class[0];
private final Class<? extends Annotation> annotationClass;
private final Map<String, ?> memberValues;
private AnnotationInstanceProvider(Class<? extends Annotation> annotationClass, Map<String, ?> memberValues)
this.memberValues = memberValues;
@SuppressWarnings("unchecked")
public static <T extends Annotation> T of(Class<T> annotationClass, Map<String, ?> values)
{
if (values == null)
{
throw new IllegalArgumentException("Map of values must not be null");
}
Map<String, Annotation> cache = getAnnotationCache();
Annotation annotation = cache.get(key);
if (annotation == null)
{
annotation = initAnnotation(key, annotationClass, cache, values);
}
return (T) annotation;
}
@SuppressWarnings("unchecked")
return (T) of(annotationClass, Collections.EMPTY_MAP);
Map<String, Annotation> cache,
Map<String, ?> values)
new AnnotationInstanceProvider(annotationClass, values));
else
{
if (this.memberValues.containsKey(method.getName()))
{
return this.memberValues.get(method.getName());
}
{
return method.getDefaultValue();
}
}
if (annotationClass.isInstance(o))
{
for (Map.Entry<String, ?> entry : this.memberValues.entrySet())
{
try
{
Object oValue = annotationClass.getMethod(entry.getKey(), EMPTY_CLASS_ARRAY)
.invoke(o, EMPTY_OBJECT_ARRAY);
if (oValue != null && entry.getValue() != null)
{
if (!oValue.equals(entry.getValue()))
{
return false;
}
}
{
return false;
}
}
catch (IllegalAccessException e)
{
throw new RuntimeException(e);
}
catch (InvocationTargetException e)
{
throw new RuntimeException(e);
}
catch (NoSuchMethodException e)
{
throw new RuntimeException(e);
}
}
return true;
}
return memberValues.equals(that.memberValues);
int result = 0;
Class<? extends Annotation> type = annotationClass;
for (Method m : type.getDeclaredMethods())
{
try
{
Object value = this.invoke(this, m, EMPTY_OBJECT_ARRAY);
if (value == null)
{
throw new IllegalStateException(String.format("Annotation method %s returned null", m));
}
}
catch (RuntimeException ex)
{
throw ex;
}
catch (Exception ex)
{
throw new RuntimeException(ex);
}
}
return result;
}
private int hashMember(String name, Object value)
{
int part1 = name.hashCode() * 127;
if (value.getClass().isArray())
{
return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value);
}
if (value instanceof Annotation)
{
return part1 ^ hashCode((Annotation) value);
}
return part1 ^ value.hashCode();
}
private static int arrayMemberHash(Class<?> componentType, Object o)
{
if (componentType.equals(Byte.TYPE))
{
return Arrays.hashCode((byte[]) o);
}
if (componentType.equals(Short.TYPE))
{
return Arrays.hashCode((short[]) o);
}
if (componentType.equals(Integer.TYPE))
{
return Arrays.hashCode((int[]) o);
}
if (componentType.equals(Character.TYPE))
{
return Arrays.hashCode((char[]) o);
}
if (componentType.equals(Long.TYPE))
{
return Arrays.hashCode((long[]) o);
}
if (componentType.equals(Float.TYPE))
{
return Arrays.hashCode((float[]) o);
}
if (componentType.equals(Double.TYPE))
{
return Arrays.hashCode((double[]) o);
}
if (componentType.equals(Boolean.TYPE))
{
return Arrays.hashCode((boolean[]) o);
}
return Arrays.hashCode((Object[]) o);
}
private int hashCode(Annotation a)
{
int result = 0;
Class<? extends Annotation> type = a.annotationType();
for (Method m : type.getDeclaredMethods())
{
try
{
Object value = m.invoke(a);
if (value == null)
{
throw new IllegalStateException(String.format("Annotation method %s returned null", m));
}
}
catch (RuntimeException ex)
{
throw ex;
}
catch (Exception ex)
{
throw new RuntimeException(ex);
}
}
return result;
= new WeakHashMap<ClassLoader, Map<String, Annotation>>();
public class RequestScopedLiteral extends AnnotationLiteral<RequestScoped> implements RequestScoped
return (T) initAnnotation(key, annotationClass, values);
return (Annotation) Proxy.newProxyInstance(annotationClass.getClassLoader(),
return (T) initAnnotation(key, annotationClass, values);
return (Annotation) Proxy.newProxyInstance(annotationClass.getClassLoader(),
new Class[]{annotationClass},
new AnnotationInstanceProvider(annotationClass, values));
if (String.class.isAssignableFrom(this.beanType))
{
return (T)configuredValue;
}
return (T)annotationMap.get(anType);
return wrapped.create(creationalContext);
import org.apache.deltaspike.core.api.projectstage.TestStage;
import org.apache.deltaspike.core.util.ProjectStageProducer;
import javax.annotation.PostConstruct;
private boolean isTestProjectStage;
@PostConstruct
protected void init()
{
this.isTestProjectStage = TestStage.class.isAssignableFrom(
ProjectStageProducer.getInstance().getProjectStage().getClass());
}
cleanupTransactionBeanStorage();
cleanupTransactionBeanStorage();
private void cleanupTransactionBeanStorage()
{
TransactionBeanStorage.getStorage().endAllTransactionScopes();
TransactionBeanStorage.resetStorage();
}
if (this.isTestProjectStage)
{
this.beanManager.fireEvent(new PersistenceStrategyCleanupTestEvent());
}
import org.apache.deltaspike.core.api.projectstage.TestStage;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import org.apache.deltaspike.core.util.ProjectStageProducer;
import org.apache.deltaspike.jpa.impl.transaction.TransactionBeanStorageCleanupTestEvent;
private boolean isTestProjectStage;
this.isTestProjectStage = TestStage.class.isAssignableFrom(
ProjectStageProducer.getInstance().getProjectStage().getClass());
TransactionBeanStorage currentBeanStorage = currentStorage.get();
if (currentBeanStorage != null)
{
currentBeanStorage.close();
currentStorage.set(null);
currentStorage.remove();
}
}
private void close()
{
if (this.isTestProjectStage)
{
BeanManagerProvider.getInstance().getBeanManager().fireEvent(new TransactionBeanStorageCleanupTestEvent());
}
import org.apache.deltaspike.core.api.literal.AnyLiteral;
import javax.enterprise.inject.spi.Bean;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
private static final long serialVersionUID = -1432802805095533499L;
@Inject
private TransactionBeanStorage transactionBeanStorage;
@Inject
private PersistenceStrategyHelper persistenceHelper;
Transactional transactionalAnnotation = persistenceHelper.extractTransactionalAnnotation(invocationContext);
Set<Class<? extends Annotation>> emQualifiers = persistenceHelper.resolveEntityManagerQualifiers(
transactionalAnnotation, invocationContext.getTarget().getClass());
List<EntityManager> ems = new ArrayList<EntityManager>();
boolean isOutermostInterceptor = transactionBeanStorage.isEmpty();
if (isOutermostInterceptor)
transactionBeanStorage.startTransactionScope();
int transactionLayer = transactionBeanStorage.incrementRefCounter();
for (Class<? extends Annotation> emQualifier : emQualifiers)
EntityManager entityManager = resolveEntityManagerForQualifier(emQualifier);
transactionBeanStorage.storeUsedEntityManager(emQualifier, entityManager);
ems.add(entityManager);
for (EntityManager entityManager : ems)
{
EntityTransaction transaction = entityManager.getTransaction();
if (!transaction.isActive())
{
transaction.begin();
}
}
if (isOutermostInterceptor)
HashMap<Class, EntityManager> emsEntries = transactionBeanStorage.getUsedEntityManagers();
for (Map.Entry<Class, EntityManager> emsEntry: emsEntries.entrySet())
EntityManager em = emsEntry.getValue();
EntityTransaction transaction = em.getTransaction();
if (transaction != null && transaction.isActive())
try
transaction.rollback();
}
catch (Exception eRollback)
{
if (LOGGER.isLoggable(Level.SEVERE))
LOGGER.log(Level.SEVERE,
"Got additional Exception while subsequently "
"rolling back other SQL transactions", eRollback);
transactionBeanStorage.cleanUsedEntityManagers();
if (isOutermostInterceptor)
if (firstException == null)
HashMap<Class, EntityManager> emsEntries = transactionBeanStorage.getUsedEntityManagers();
for (EntityManager em: emsEntries.values())
EntityTransaction transaction = em.getTransaction();
em.flush();
for (EntityManager em : emsEntries.values())
EntityTransaction transaction = em.getTransaction();
transaction.commit();
transactionBeanStorage.endTransactionScope();
transactionBeanStorage.decrementRefCounter();
private EntityManager resolveEntityManagerForQualifier(Class<? extends Annotation> emQualifier)
Bean<EntityManager> entityManagerBean = resolveEntityManagerBean(emQualifier);
if (entityManagerBean == null)
return null;
return (EntityManager) beanManager.getReference(entityManagerBean, EntityManager.class,
beanManager.createCreationalContext(entityManagerBean));
protected Bean<EntityManager> resolveEntityManagerBean(Class<? extends Annotation> qualifierClass)
{
Set<Bean<?>> entityManagerBeans = beanManager.getBeans(EntityManager.class, new AnyLiteral());
if (entityManagerBeans == null)
entityManagerBeans = new HashSet<Bean<?>>();
for (Bean<?> currentEntityManagerBean : entityManagerBeans)
Set<Annotation> foundQualifierAnnotations = currentEntityManagerBean.getQualifiers();
for (Annotation currentQualifierAnnotation : foundQualifierAnnotations)
if (currentQualifierAnnotation.annotationType().equals(qualifierClass))
return (Bean<EntityManager>) currentEntityManagerBean;
return null;
import javax.annotation.PreDestroy;
import javax.enterprise.context.RequestScoped;
import javax.persistence.EntityManager;
import java.lang.annotation.Annotation;
import java.util.Stack;
import java.util.concurrent.atomic.AtomicInteger;
@RequestScoped
private static class TransactionContextInfo
private Map<Contextual, TransactionBeanEntry> contextualInstances =
new HashMap<Contextual, TransactionBeanEntry>();
private HashMap<Class, EntityManager> ems = new HashMap<Class, EntityManager>();
private AtomicInteger refCounter = new AtomicInteger(0);
private Stack<TransactionContextInfo> oldTci = new Stack<TransactionContextInfo>();
private TransactionContextInfo currentTci = null;
public int incrementRefCounter()
return currentTci.refCounter.incrementAndGet() - 1;
public int decrementRefCounter()
if (currentTci == null)
return 0;
return currentTci.refCounter.decrementAndGet();
}
public boolean isEmpty()
{
return currentTci == null;
}
public void startTransactionScope()
{
if (currentTci != null)
oldTci.push(currentTci);
}
currentTci = new TransactionContextInfo();
if (LOGGER.isLoggable(Level.FINER))
{
LOGGER.finer( "starting TransactionScope");
public void endTransactionScope()
LOGGER.finer("ending TransactionScope");
destroyBeans(currentTci.contextualInstances);
if (oldTci.size() > 0)
currentTci = oldTci.pop();
else
{
currentTci = null;
}
public EntityManager storeUsedEntityManager(Class<? extends Annotation> emQualifier, EntityManager entityManager)
{
return currentTci.ems.put(emQualifier, entityManager);
}
public HashMap<Class,EntityManager> getUsedEntityManagers()
{
return currentTci.ems;
}
public void cleanUsedEntityManagers()
{
currentTci.ems.clear();
}
public Map<Contextual, TransactionBeanEntry> getActiveTransactionContext()
if (currentTci == null)
{
return null;
}
return currentTci.contextualInstances;
}
@PreDestroy
public void requestEnded()
{
endAllTransactionScopes();
}
private void endAllTransactionScopes()
{
while (!isEmpty())
{
endTransactionScope();
}
import org.apache.deltaspike.core.api.provider.BeanProvider;
private TransactionBeanStorage beanStorage;
Map<Contextual, TransactionBeanEntry> transactionBeanEntryMap = getBeanStorage().getActiveTransactionContext();
if (transactionBeanEntryMap == null)
throw new ContextNotActiveException("Not accessed within a transactional method - use @"
Transactional.class.getName());
TransactionBeanEntry transactionBeanEntry = transactionBeanEntryMap.get(component);
Map<Contextual, TransactionBeanEntry> transactionBeanEntryMap = getBeanStorage().getActiveTransactionContext();
if (transactionBeanEntryMap == null)
TransactionBeanEntry transactionBeanEntry = transactionBeanEntryMap.get(component);
if (transactionBeanEntry != null)
return (T) transactionBeanEntry.getContextualInstance();
transactionBeanEntryMap.put(component, transactionBeanEntry);
try
{
return getBeanStorage().getActiveTransactionContext() != null;
}
catch (ContextNotActiveException e)
{
return false;
}
private TransactionBeanStorage getBeanStorage()
{
if (beanStorage == null)
{
synchronized (this)
{
beanStorage = BeanProvider.getContextualReference(TransactionBeanStorage.class);
}
}
return beanStorage;
}
public class ResourceLocalPersistenceStrategy implements PersistenceStrategy
private static final Logger LOGGER = Logger.getLogger(ResourceLocalPersistenceStrategy.class.getName());
Class<? extends Annotation>[] qualifierClasses = null;
if (transactionalAnnotation != null)
{
qualifierClasses = transactionalAnnotation.qualifier();
}
if (qualifierClasses == null || qualifierClasses.length == 1 && Any.class.equals(qualifierClasses[0]) )
import java.util.Collections;
Set<Class<? extends Annotation>> emQualifiers = new HashSet<Class<? extends Annotation>>();
Collections.addAll(emQualifiers, qualifierClasses);
@SuppressWarnings("UnusedDeclaration")
transactionBeanStorage.endTransactionScope();
endTransactionScope();
if (!isEmpty())
{
LOGGER.warning("the current TransactionContextInfo isn't empty. a fallback cleanup will be performed.");
}
for (TransactionBeanEntry beanEntry : activeBeans.values())
beanEntry.getBean().destroy(beanEntry.getContextualInstance(), beanEntry.getCreationalContext());
@SuppressWarnings("UnusedDeclaration")
protected void recordConfigPropertyAwareInjectionPoint(@Observes ProcessInjectionTarget<?> event)
import org.apache.deltaspike.core.impl.exclude.InternalUntypedBean;
import javax.enterprise.inject.Typed;
import javax.inject.Named;
private Boolean isInternalUntypedBeanFilterActivated = null;
if (this.isInternalUntypedBeanFilterActivated)
{
vetoInternalUntypedBeans(processAnnotatedType);
}
protected void vetoInternalUntypedBeans(ProcessAnnotatedType<Object> processAnnotatedType)
{
Class<?> beanClass = processAnnotatedType.getAnnotatedType().getJavaClass();
Typed typed = beanClass.getAnnotation(Typed.class);
if (typed != null && typed.value().length == 0 && !beanClass.isAnnotationPresent(Named.class) &&
beanClass.getName().startsWith("org.apache.deltaspike."))
{
processAnnotatedType.veto();
}
}
isInternalUntypedBeanFilterActivated =
ClassDeactivationUtils.isActivated(InternalUntypedBean.class);
import javax.enterprise.inject.Typed;
@Typed()
return "org.apache.deltaspike.test.jpa.datasource.DummyJdbcDriver";
return "jdbc:dummy:mem:test";
@Deprecated
import java.util.HashMap;
private volatile Map<ClassLoader, BeanManager> loadTimeBms = new HashMap<ClassLoader, BeanManager>();
private volatile Map<ClassLoader, BeanManager> finalBms = new ConcurrentHashMap<ClassLoader, BeanManager>();
public void setBeanManager(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
{
BeanManagerProvider bmpFirst = setBeanManagerProvider(this);
ClassLoader cl = ClassUtils.getClassLoader(null);
bmpFirst.loadTimeBms.put(cl, beanManager);
}
BeanManager result = bmp.finalBms.get(classLoader);
synchronized (this)
{
result = bmp.finalBms.get(classLoader);
if (result == null)
{
result = resolveBeanManagerViaJndi();
if (result == null)
{
result = bmp.loadTimeBms.get(classLoader);
}
if (result == null)
{
throw new IllegalStateException("Unable to find BeanManager. "
"Please ensure that you configured the CDI implementation of your choice properly.");
}
bmp.finalBms.put(classLoader, result);
}
}
ClassLoader classLoader = ClassUtils.getClassLoader(null);
bmp.finalBms.remove(classLoader);
bmp.loadTimeBms.remove(classLoader);
@Deprecated
@Deprecated
import javax.enterprise.inject.spi.AfterDeploymentValidation;
public void cleanFinalBeanManagerMap(@Observes AfterDeploymentValidation adv)
{
bmp.finalBms.clear();
}
private static BeanManagerProvider bmpSingleton = null;
private static class BeanManagerInfo
{
private BeanManager loadTimeBm = null;
private BeanManager finalBm = null;
private boolean booted = false;
}
private volatile Map<ClassLoader, BeanManagerInfo> bmInfos = new ConcurrentHashMap<ClassLoader, BeanManagerInfo>();
return bmpSingleton != null;
if (bmpSingleton == null)
if (bmpSingleton == null)
return bmpSingleton;
setBeanManagerProvider(this);
BeanManagerInfo bmi = getBeanManagerInfo(cl);
bmi.loadTimeBm =  beanManager;
private BeanManagerInfo getBeanManagerInfo(ClassLoader cl)
{
BeanManagerInfo bmi = bmpSingleton.bmInfos.get(cl);
if (bmi == null)
{
synchronized (this)
{
bmi = bmpSingleton.bmInfos.get(cl);
if (bmi == null)
{
bmi = new BeanManagerInfo();
bmpSingleton.bmInfos.put(cl, bmi);
}
}
}
return bmi;
}
BeanManagerInfo bmi = getBeanManagerInfo(classLoader);
BeanManager result = bmi.finalBm;
result = bmi.finalBm;
result = bmi.loadTimeBm;
bmi.finalBm = result;
for (BeanManagerInfo bmi : bmpSingleton.bmInfos.values())
{
bmi.finalBm = null;
bmi.booted = true;
}
bmpSingleton.bmInfos.remove(classLoader);
if (bmpSingleton == null)
bmpSingleton = beanManagerProvider;
return bmpSingleton;
import java.util.logging.Logger;
private static Logger logger = Logger.getLogger(BeanManagerProvider.class.getName());
if (!bmi.booted)
{
logger.warning("When using the BeanManager to retrieve Beans before the Container is started,"
" non-portable behaviour results!");
}
Bean<ContextControl> ctxCtrlBean = (Bean<ContextControl>) getBeanManager().resolve(beans);
CreationalContext<ContextControl> ctxCtrlCreationalContext = getBeanManager().createCreationalContext(ctxCtrlBean);
return weldContainer.getBeanManager();
weld = new Weld();
weldContainer = weld.initialize();
weld.shutdown();
CreationalContext<ContextControl> ctxCtrlCreationalContext =
getBeanManager().createCreationalContext(ctxCtrlBean);
if (applicationScopeStarted)
applicationScopeStarted = true;
applicationScopeStarted = false;
Field field = applicationContext.getClass().getSuperclass().getDeclaredField("beanStore");
beanStoreHolder = (org.jboss.weld.bootstrap.api.Singleton)field.get(applicationContext);
resetSuccessful = false;
resetSuccessful = false;
applicationScopeStarted = false;
resetSuccessful = true;
if (singletonScopeStarted)
singletonScopeStarted = true;
singletonScopeStarted = false;
if (sessionMap == null)
sessionMap = new HashMap<String, Object>();
sessionContext.associate(sessionMap);
sessionContext.activate();
if (sessionContext.isActive())
sessionContext.invalidate();
sessionContext.deactivate();
sessionContext.dissociate(sessionMap);
sessionMap = null;
conversationContext.associate(new MutableBoundRequest(requestMap, sessionMap));
conversationContext.activate(cid);
conversationContext.invalidate();
conversationContext.deactivate();
conversationContext.dissociate(new MutableBoundRequest(requestMap, sessionMap));
if (requestMap == null)
requestMap = new HashMap<String, Object>();
requestContext.associate(requestMap);
requestContext.activate();
if (requestContext.isActive())
requestContext.invalidate();
requestContext.deactivate();
requestContext.dissociate(requestMap);
requestMap = null;
if (contextController != null)
return contextController;
contextController = new ContextController();
return tryToInjectFields(contextController);
return stackTraceElements.clone();
return throwable;
exceptionStackItems = new ArrayDeque<ExceptionStackItem>();
exceptionStackItems.addFirst(new ExceptionStackItem(e));
exceptionStackItems.addFirst(new ExceptionStackItem(sqlException));
initialStackSize = exceptionStackItems.size();
causes = createThrowableCollection(exceptionStackItems);
init();
root = exceptionStackItems.size() == initialStackSize;
if (!exceptionStackItems.isEmpty())
current = exceptionStackItems.removeFirst().getThrowable();
remaining = Collections.unmodifiableCollection(exceptionStackItems);
remaining = Collections.emptyList();
current = null;
last = remaining.isEmpty();
next = (last) ? null : exceptionStackItems.peekFirst().getThrowable();
return Collections.unmodifiableCollection(causes);
return last;
return next;
return Collections.unmodifiableCollection(createThrowableCollection(remaining));
return root;
return current;
exceptionStackItems = new ArrayDeque<ExceptionStackItem>(createExceptionStackFrom(elements));
init();
init();
qualifiers = Collections.emptySet();
return exception;
return handled;
return Collections.unmodifiableSet(qualifiers);
return messageResolver;
return messageInterpolator;
return localeResolver;
value = "";
String projectStageClassName = getClass().getSimpleName();
types = new HashMap<Type, Class<?>>();
if (memberValues.containsKey(method.getName()))
return memberValues.get(method.getName());
Method[] methods = annotationClass.getDeclaredMethods();
for (Map.Entry<String, ?> entry : memberValues.entrySet())
Object value = invoke(this, m, EMPTY_OBJECT_ARRAY);
parameters = getAnnotatedParameters(this, parameterTypes, genericTypes, parameterAnnotations,
typeClosure = Collections.singleton(overridenType);
javaMember = member;
typeAnnotations = new AnnotationBuilder();
constructors = new HashMap<Constructor<?>, AnnotationBuilder>();
constructorParameters = new HashMap<Constructor<?>, Map<Integer, AnnotationBuilder>>();
constructorParameterTypes = new HashMap<Constructor<?>, Map<Integer, Type>>();
fields = new HashMap<Field, AnnotationBuilder>();
fieldTypes = new HashMap<Field, Type>();
methods = new HashMap<Method, AnnotationBuilder>();
methodParameters = new HashMap<Method, Map<Integer, AnnotationBuilder>>();
methodParameterTypes = new HashMap<Method, Map<Integer, Type>>();
javaClass = type.getJavaClass();
javaClass = type;
javaClass = clazz;
constructors = new HashSet<AnnotatedConstructor<X>>();
methods = new HashSet<AnnotatedMethod<? super X>>();
fields = new HashSet<AnnotatedField<? super X>>();
annotationMap = new HashMap<Class<? extends Annotation>, Annotation>();
annotationSet = new HashSet<Annotation>();
annotationMap = emptyMap();
annotationSet = emptySet();
annotated = field;
member = field.getJavaMember();
type = field.getJavaMember().getGenericType();
annotated = field;
member = field.getJavaMember();
qualifiers = BeanUtils.getQualifiers(beanManager, field.getAnnotations());
type = field.getJavaMember().getGenericType();
annotated = parameter;
member = parameter.getDeclaringCallable().getJavaMember();
type = parameter.getBaseType();
annotated = parameter;
member = parameter.getDeclaringCallable().getJavaMember();
qualifiers = BeanUtils.getQualifiers(beanManager, parameter.getAnnotations());
type = parameter.getBaseType();
color = cat.color;
ordinal = defaultOrdinal;
configSources.add(new SystemPropertyConfigSource());
configSources.add(new EnvironmentPropertyConfigSource());
configSources.add(new LocalJndiConfigSource());
configSources.add(new PropertyFileConfigSource(propertyFileUrl));
return configSources;
qualifiers = new HashSet<Annotation>();
qualifiers.add(customQualifier);
qualifiers.add(configProperty);
beanType = (Class<?>) targetType;
types = new HashSet<Type>();
types.add(beanType);
return types;
return qualifiers;
return beanType;
converter = converterFactory.create(String.class, (Class<?>) beanType,
customQualifier != null ? customQualifier.annotationType() : null);
if (String.class.isAssignableFrom(beanType))
if (customQualifier != null && converter instanceof MetaDataAwareConverter)
return (T) ((MetaDataAwareConverter) converter).convert(configuredValue, customQualifier);
if (!isActivated)
injectionTargets.add(
if (!isActivated)
for (InjectionTargetEntry injectionTargetEntry : injectionTargets)
if (isActivated == null)
isActivated = ClassDeactivationUtils.isActivated(getClass());
result = converterMapping.get(new ConverterKey(sourceType, targetType, metaDataType));
return converterMapping.get(new ConverterKey(sourceType, targetType, null));
converterMapping.put(new ConverterKey(sourceType, targetType, metaDataType), converter);
exception = (T) stackEvent.getCurrent();
markedHandled = handled;
flow = ExceptionHandlingFlow.HANDLED_AND_CONTINUE;
return exception;
flow = ExceptionHandlingFlow.ABORT;
flow = ExceptionHandlingFlow.THROW_ORIGINAL;
flow = ExceptionHandlingFlow.HANDLED;
flow = ExceptionHandlingFlow.HANDLED_AND_CONTINUE;
flow = ExceptionHandlingFlow.SKIP_CAUSE;
unmute = true;
return unmute;
return flow;
return markedHandled;
throwNewException = t;
flow = ExceptionHandlingFlow.THROW;
return throwNewException;
final int returnValue = comparePrecedence(lhs.getOrdinal(), rhs.getOrdinal(),
handler = method;
javaMethod = method.getJavaMember();
handlerParameter = findHandlerParameter(method);
if (!handlerParameter.isAnnotationPresent(Handles.class)
&& !handlerParameter.isAnnotationPresent(BeforeHandles.class))
before = handlerParameter.getAnnotation(BeforeHandles.class) != null;
if (before)
ordinal = handlerParameter.getAnnotation(BeforeHandles.class).ordinal();
ordinal = handlerParameter.getAnnotation(Handles.class).ordinal();
tmpQualifiers.addAll(BeanUtils.getQualifiers(bm, handlerParameter.getAnnotations()));
qualifiers = tmpQualifiers;
beanClass = method.getJavaMember().getDeclaringClass();
exceptionType = ((ParameterizedType) handlerParameter.getBaseType()).getActualTypeArguments()[0];
if (bean == null)
return bean;
if (bean != null)
Set<Bean<?>> beans = BeanProvider.getBeanDefinitions(beanClass, false, true);
bean = beans.iterator().next();
return Collections.unmodifiableSet(qualifiers);
return exceptionType;
Object handlerInstance = BeanProvider.getContextualReference(beanClass);
InjectableMethod<?> im = createInjectableMethod(handler, getBean());
return before;
return ordinal;
return handlerParameter;
if (injectionPoints == null)
injectionPoints = new HashSet<InjectionPoint>(handler.getParameters().size() - 1);
if (!param.equals(handlerParameter))
injectionPoints.add(
return new HashSet<InjectionPoint>(injectionPoints);
if (beanManager == null)
beanManager = BeanManagerProvider.getInstance().getBeanManager();
return beanManager;
return new StringBuilder("Qualifiers: ").append(qualifiers).append(" ")
.append("Handles Type: ").append(exceptionType).append(" ")
.append("Before: ").append(before).append(" ")
.append("Precedence: ").append(ordinal).append(" ")
.append(handler.toString()).toString();
if (allHandlers.containsKey(handlerMethod.getExceptionType()))
allHandlers.get(handlerMethod.getExceptionType()).add(handlerMethod);
allHandlers.put(handlerMethod.getExceptionType(),
if (allHandlers.get(hierarchyType) != null)
for (HandlerMethod<?> handler : allHandlers.get(hierarchyType))
if (!handlerQualifiers.isEmpty() && containsAny(handler.getQualifiers(),
if (!handlerQualifiers.isEmpty() && containsAny(handler.getQualifiers(),
declaringBean = handlerMethod.getBean();
.createCreationalContext(declaringBean);
if (value.getPosition() == handlerMethod.getHandlerParameter().getPosition())
if (!isActivated)
if (!isActivated)
if (isGlobalAlternativeActivated)
if (isCustomProjectStageBeanFilterActivated)
if (!isActivated)
if (arguments == null)
arguments = new ArrayList<Object>();
arguments.add(argument);
return messageTemplate;
return arguments.toArray();
return toString(new DefaultMessageContext(messageContextConfig));
Collections.addAll(argumentList, arguments);
if (messageTemplate == null)
return new DefaultMessage(messageContext.config(), messageTemplate,
argumentList.toArray(new Object[argumentList.size()]));
messageTemplate = null;
argumentList = new ArrayList<Object>();
MessageResolver messageResolver = messageContext.config().getMessageResolver();
MessageInterpolator messageInterpolator = messageContext.config().getMessageInterpolator();
messageInterpolator = messageContextConfigTemplate.getMessageInterpolator();
messageResolver = messageContextConfigTemplate.getMessageResolver();
localeResolver = messageContextConfigTemplate.getLocaleResolver();
return new DefaultMessageContext(newMessageContextConfig);
messageInterpolator = new DefaultMessageInterpolator();
messageResolver = null;
localeResolver = new DefaultLocaleResolver();
return messageInterpolator;
return messageResolver;
return localeResolver;
if (messageInterpolator != null)
configInfo.append("   MessageInterpolator class: ").append(messageInterpolator.getClass());
if (messageResolver != null)
configInfo.append("   MessageResolver class: ").append(messageResolver.getClass());
if (localeResolver != null)
configInfo.append("   LocaleResolver class: ").append(localeResolver.getClass());
messageBundle = resolvedBundle;
if (messageBundle != null && messageTemplate != null &&
return messageBundle.getString(messageTemplate.substring(1, messageTemplate.length() - 1));
wrapped = bean;
if (!isActivated)
if (!isActivated)
if (!isActivated)
bundleProducerBean = (Bean<Object>) bean;
messageBundleTypes.clear();
types = new HashSet<Type>(type.getTypeClosure());
qualifiers = new HashSet<Annotation>();
stereotypes = new HashSet<Class<? extends Annotation>>();
qualifiers.add(annotation);
stereotypes.add(annotation.annotationType());
qualifiers.add(new DefaultLiteral());
qualifiers.add(new AnyLiteral());
alternative = type.isAnnotationPresent(Alternative.class);
types.add(type);
qualifiers.add(qualifier);
return messageContextConfig.use();
inverseProperty2 = inverseProperty;
return persistenceStrategy.execute(invocationContext);
nestedTransactionBean.executeInTransaction();
nestedTransactionBean.executeInTransaction();
nestedTransactionBean.executeInTransaction();
nestedTransactionBean.executeInTransaction();
nestedTransactionBean.executeInTransaction();
nestedTransactionBean.executeInTransaction();
nestedTransactionBean.executeInTransaction();
nestedTransactionBean.executeInTransaction();
nestedTransactionBean.executeInTransaction();
nestedTransactionBean.executeInTransaction();
nestedTransactionBean.executeInTransaction();
testEntityTransactionHolder.setTestEntityTransaction(
(TestEntityTransaction) entityManager.getTransaction());
return user != null;
return user;
return isLoggedIn() && loginCredential.getUserId() != null &&
!loginCredential.getUserId().equals(user.getId());
user = activeAuthenticator.getUser();
beanManager.fireEvent(new PreLoggedOutEvent(user));
PostLoggedOutEvent postLoggedOutEvent = new PostLoggedOutEvent(user);
user = null;
return state;
if (securityViolations == null)
return Collections.unmodifiableList(securityViolations);
return (T) source;
return Collections.unmodifiableMap(metaData);
return (T) metaData.get(key);
state = accessDecisionVoterState;
metaData.clear();
if (securityViolations == null)
securityViolations.add(securityViolation);
if (!isActivated)
if (!isActivated)
if (!isActivated)
return securityStrategy.execute(invocationContext);
authorizers.add(authorizer);
securedTypes.add(annotatedType);
securedTypes = null;
for (Authorizer authorizer : authorizers)
Map<Method, Set<Authorizer>> resultForClass = methodAuthorizers.get(targetClass);
Map<Method, Set<Authorizer>> resultForClass = methodAuthorizers.get(targetClass);
methodAuthorizers.put(targetClass, new HashMap<Method, Set<Authorizer>>());
Map<Method, Set<Authorizer>> result = methodAuthorizers.get(targetClass);
Map<Method, Set<Authorizer>> authorizerMapping = methodAuthorizers.get(targetClass);
methodAuthorizers.put(targetClass, authorizerMapping);
Map<Method, Set<Authorizer>> resultForClass = methodAuthorizers.get(targetClass);
credential = null;
userId = null;
observedException = loginFailedEvent.getLoginException();
id = UUID.randomUUID().toString();
return id;
return question;
return id.hashCode();
return obj instanceof NewProductInquiry && id.equals(((NewProductInquiry) obj).id);
if (inquiryStorage.addInquiry(inquiry))
loginCredential.setUserId(userName);
loginCredential.setCredential(new Credential<String>()
{
identity.login();
identity.logout();
return shop.sendInquiry(new NewProductInquiry(customText));
MOE, LARRY, CURLY, JOE, SHEMP
{
append("stackTraceElements: ").append(Arrays.toString(stackTraceElements)).
Type overriddenType)
super(declaringType, field, field.getType(), annotations, field.getGenericType(), overriddenType);
protected AnnotatedImpl(Class<?> type, AnnotationStore annotations, Type genericType, Type overriddenType)
if (overriddenType == null)
this.type = overriddenType;
typeClosure = Collections.singleton(overriddenType);
AnnotationStore annotations, Type genericType, Type overriddenType)
super(memberType, annotations, genericType, overriddenType);
Map<Constructor<?>, Map<Integer, AnnotationStore>> constructorParameterAnnotations =
Map<Method, Map<Integer, AnnotationStore>> methodParameterAnnotations =
methodParameterAnnotations.put(parameters.getKey(), parameterAnnotations);
constructorParameterAnnotations.put(parameters.getKey(), parameterAnnotations);
methodParameterAnnotations, constructorAnnotations, constructorParameterAnnotations, fieldTypes,
private static BeanManagerProvider bmpSingleton = null;
BeanManagerInfo bmi = getBeanManagerInfo(ClassUtils.getClassLoader(null));
BeanManagerInfo bmi = getBeanManagerInfo(ClassUtils.getClassLoader(null));
public void cleanupFinalBeanManagers(@Observes AfterDeploymentValidation adv)
private BeanManager resolveBeanManagerViaJndi()
private BeanManagerInfo getBeanManagerInfo(ClassLoader cl)
{
BeanManagerInfo bmi = bmpSingleton.bmInfos.get(cl);
if (bmi == null)
{
synchronized (this)
{
bmi = bmpSingleton.bmInfos.get(cl);
if (bmi == null)
{
bmi = new BeanManagerInfo();
bmpSingleton.bmInfos.put(cl, bmi);
}
}
}
return bmi;
}
private static Logger LOG = Logger.getLogger(BeanManagerProvider.class.getName());
LOG.warning("When using the BeanManager to retrieve Beans before the Container is started,"
private static final Logger  LOG = Logger.getLogger(BeanManagerProvider.class.getName());
import java.util.concurrent.Executor;
public int getNetworkTimeout() throws SQLException
{
return 0;
}
public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException
{
}
public void abort(Executor executor) throws SQLException
{
}
public String getSchema() throws SQLException
{
return null;
}
public void setSchema(String schema) throws SQLException
{
}
import java.sql.SQLFeatureNotSupportedException;
import java.util.logging.Logger;
public Logger getParentLogger() throws SQLFeatureNotSupportedException
{
return null;
}
class ConfigInjectionTargetEntry
ConfigInjectionTargetEntry(Type type, ConfigProperty configProperty, Annotation optionalCustomQualifier)
ConfigInjectionTargetEntry that = (ConfigInjectionTargetEntry) o;
private Set<ConfigInjectionTargetEntry> injectionTargets = new HashSet<ConfigInjectionTargetEntry>();
Annotation qualifier = null;
ConfigProperty configProperty = injectionPoint.getAnnotated().getAnnotation(ConfigProperty.class);
injectionTargets.add(new ConfigInjectionTargetEntry(injectionPoint.getType(),
configProperty, qualifier));
for (ConfigInjectionTargetEntry injectionTargetEntry : injectionTargets)
event.addBean(new ConfigPropertyBean<Object>(injectionTargetEntry.getType(),
injectionTargetEntry.getConfigProperty(), injectionTargetEntry.getCustomQualifier()));
public static String getPropertyValue(String key, String defaultValue)
{
String configuredValue = getPropertyValue(key);
if (configuredValue == null)
{
LOG.log(Level.FINE, "no configured value found for key {1}, using default value {2}.",
new Object[]{key, defaultValue});
configuredValue = defaultValue;
}
return configuredValue;
}
String NULL = "org.apache.deltaspike.NullValueMarker";
@Nonbinding
String defaultValue() default NULL;
String configuredValue;
String defaultValue = configProperty.defaultValue();
if (ConfigProperty.NULL.equals(defaultValue))
{
configuredValue = ConfigResolver.getPropertyValue(configProperty.name());
}
else
{
configuredValue = ConfigResolver.getPropertyValue(configProperty.name(), defaultValue);
}
if (configProperty.eager() && ConfigProperty.NULL.equals(configProperty.defaultValue()) &&
ConfigResolver.getPropertyValue(configProperty.name()) == null)
@ConfigProperty(name = "configProperty1", defaultValue = "myDefaultValue")
private String stringProperty3Filled;
@Inject
@ConfigProperty(name = "nonexistingProperty", defaultValue = "myDefaultValue")
private String stringProperty3Defaulted;
@Inject
@ConfigProperty(name = "nonexistingProperty", defaultValue = "42")
private Integer intProperty4Defaulted;
@Inject
public String getProperty3Defaulted()
{
return stringProperty3Defaulted;
}
public String getProperty3Filled()
{
return stringProperty3Filled;
}
public int getProperty4Defaulted()
{
return intProperty4Defaulted;
}
@Nonbinding
@Deprecated
private Boolean isActivated = Boolean.FALSE;
import javax.enterprise.inject.Stereotype;
import javax.enterprise.inject.Stereotype;
@Deprecated
@Deprecated
final static String PROPERTY_NAME = "configProperty2";
public SettingsBean(@ConfigProperty(name= PROPERTY_NAME) Long property2)
import javax.enterprise.inject.Stereotype;
@Deprecated
package org.apache.deltaspike.core.impl.config;
public SettingsBean(@ConfigProperty(name = "property2") Long property2)
package org.apache.deltaspike.core.spi.config;
import org.apache.deltaspike.core.api.config.ConfigResolver;
public abstract class BaseConfigPropertyProducer
import org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer;
import org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer;
public class DefaultConfigPropertyProducer extends BaseConfigPropertyProducer
@Produces
@Dependent
public Boolean produceBooleanConfiguration(InjectionPoint injectionPoint)
{
String configuredValue = getStringPropertyValue(injectionPoint);
if (configuredValue == null)
{
return null;
}
return Boolean.parseBoolean(configuredValue);
}
@Produces
@Dependent
public Float produceFloatConfiguration(InjectionPoint injectionPoint)
{
String configuredValue = getStringPropertyValue(injectionPoint);
if (configuredValue == null)
{
return null;
}
return Float.parseFloat(configuredValue);
}
Boolean isTrue = "TRUE".equalsIgnoreCase(configuredValue);
isTrue |= "1".equalsIgnoreCase(configuredValue);
isTrue |= "YES".equalsIgnoreCase(configuredValue);
isTrue |= "Y".equalsIgnoreCase(configuredValue);
isTrue |= "JA".equalsIgnoreCase(configuredValue);
isTrue |= "J".equalsIgnoreCase(configuredValue);
isTrue |= "OUI".equalsIgnoreCase(configuredValue);
return isTrue;
@Inject
@ConfigProperty(name = "configProperty1")
private Boolean booleanPropertyNull;
@Inject
@ConfigProperty(name = "configProperty1", defaultValue = "false")
private Boolean booleanPropertyFalse;
@Inject
@ConfigProperty(name = "configPropertyTrue1")
private Boolean booleanPropertyTrue1;
@Inject
@ConfigProperty(name = "configPropertyTrue2")
private Boolean booleanPropertyTrue2;
@Inject
@ConfigProperty(name = "configPropertyTrue3")
private Boolean booleanPropertyTrue3;
@Inject
@ConfigProperty(name = "configPropertyTrue4")
private Boolean booleanPropertyTrue4;
@Inject
@ConfigProperty(name = "configPropertyTrue5")
private Boolean booleanPropertyTrue5;
@Inject
@ConfigProperty(name = "configPropertyTrue6")
private Boolean booleanPropertyTrue6;
@Inject
@ConfigProperty(name = "configPropertyTrue7")
private Boolean booleanPropertyTrue7;
@Inject
@ConfigProperty(name = "configPropertyTrue8")
private Boolean booleanPropertyTrue8;
public Boolean getBooleanPropertyNull()
{
return booleanPropertyNull;
}
public boolean getBooleanPropertyFalse()
{
return booleanPropertyFalse;
}
public Boolean getBooleanPropertyTrue1()
{
return booleanPropertyTrue1;
}
public Boolean getBooleanPropertyTrue2()
{
return booleanPropertyTrue2;
}
public Boolean getBooleanPropertyTrue3()
{
return booleanPropertyTrue3;
}
public Boolean getBooleanPropertyTrue4()
{
return booleanPropertyTrue4;
}
public Boolean getBooleanPropertyTrue5()
{
return booleanPropertyTrue5;
}
public Boolean getBooleanPropertyTrue6()
{
return booleanPropertyTrue6;
}
public Boolean getBooleanPropertyTrue7()
{
return booleanPropertyTrue7;
}
public Boolean getBooleanPropertyTrue8()
{
return booleanPropertyTrue8;
}
@SuppressWarnings("UnusedDeclaration")
ConfigProperty configProperty = getAnnotation(injectionPoint, ConfigProperty.class);
protected <T extends Annotation> T getAnnotation(InjectionPoint injectionPoint, Class<T> targetType)
Annotated annotated = injectionPoint.getAnnotated();
T result = annotated.getAnnotation(targetType);
if (result == null)
result = annotation.annotationType().getAnnotation(targetType);
if (result != null)
return result;
private Long inverseProperty;
public SettingsBean(@Property2 Long property2)
@Inject
protected void init(@Property2WithInverseSupport(inverseConvert = true) Long inverseProperty)
{
this.inverseProperty = inverseProperty;
}
public Long getInverseProperty()
{
return inverseProperty;
}
import org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer;
getAnnotation(injectionPoint, CustomConfigAnnotationWithMetaData.class);
getAnnotation(injectionPoint, CustomConfigAnnotationWithMetaData.class);
import org.apache.deltaspike.core.util.BeanUtils;
return BeanUtils.extractAnnotation(injectionPoint.getAnnotated(), targetType);
import javax.enterprise.inject.spi.Annotated;
public static <T extends Annotation> T extractAnnotation(Annotated annotated, Class<T> targetType)
{
T result = annotated.getAnnotation(targetType);
if (result == null)
{
for (Annotation annotation : annotated.getAnnotations())
{
result = annotation.annotationType().getAnnotation(targetType);
if (result != null)
{
break;
}
}
}
return result;
}
List<ConfigSource> appConfigSources = ServiceUtils.loadServiceImplementations(ConfigSource.class);
import java.util.logging.Logger;
private static final Logger LOG = Logger.getLogger(AbstractImmutableBean.class.getName());
configuredValue = getPropertyValue(configProperty.name(), defaultValue);
return configuredValue;
}
protected String getPropertyValue(String propertyName, String defaultValue)
{
String configuredValue;
configuredValue = ConfigResolver.getPropertyValue(propertyName);
configuredValue = ConfigResolver.getPropertyValue(propertyName, defaultValue);
try
{
return Integer.parseInt(configuredValue);
}
catch (NumberFormatException nfe)
{
ConfigProperty configProperty = getAnnotation(injectionPoint, ConfigProperty.class);
}
try
{
return Long.parseLong(configuredValue);
}
catch (NumberFormatException nfe)
{
ConfigProperty configProperty = getAnnotation(injectionPoint, ConfigProperty.class);
}
try
{
return Float.parseFloat(configuredValue);
}
catch (NumberFormatException nfe)
{
ConfigProperty configProperty = getAnnotation(injectionPoint, ConfigProperty.class);
}
@Target({ TYPE })
protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
protected void detectInterfaces(@Observes ProcessAnnotatedType<?> processAnnotatedType)
AnnotatedType<?> type = processAnnotatedType.getAnnotatedType();
if (!currentClass.isInterface())
{
throw new IllegalStateException("@MessageBundle must only be used on Interfaces, but got used on class "
currentClass.getName());
}
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
private List<String> deploymentErrors = new ArrayList<String>();
if (validateMessageBundle(type.getJavaClass()))
{
messageBundleTypes.add(type);
}
private boolean validateMessageBundle(Class<?> currentClass)
boolean ok = true;
deploymentErrors.add("@MessageBundle must only be used on Interfaces, but got used on class "
return false;
ok |= validateMessageContextAwareMethod(currentMethod);
ok = false;
return ok;
private boolean validateMessageContextAwareMethod(Method currentMethod)
return true;
return false;
protected void installMessageBundleProducerBeans(@Observes AfterBeanDiscovery abd, BeanManager beanManager)
if (!deploymentErrors.isEmpty())
{
abd.addDefinitionError(new IllegalArgumentException("The following MessageBundle problems where found: "
Arrays.toString(deploymentErrors.toArray())));
}
abd.addBean(createMessageBundleBean(bundleProducerBean, type, beanManager));
protected void cleanup(@Observes AfterDeploymentValidation afterDeploymentValidation)
return;
package org.apache.deltaspike.core.util;
package org.apache.deltaspike.core.util.builder;
import org.apache.deltaspike.core.util.ArraysUtils;
package org.apache.deltaspike.core.util.builder;
package org.apache.deltaspike.core.util.builder;
import org.apache.deltaspike.core.util.ArraysUtils;
public class WrappingBeanBuilder<T>
public WrappingBeanBuilder(Bean<Object> delegate, BeanManager beanManager)
public WrappingBeanBuilder<T> readFromType(AnnotatedType<T> type)
public WrappingBeanBuilder<T> types(Set<Type> types)
public WrappingBeanBuilder<T> types(Type... types)
this.types = ArraysUtils.asSet(types);
public WrappingBeanBuilder<T> addType(Type type)
public WrappingBeanBuilder<T> addTypes(Type... types)
this.types.addAll(ArraysUtils.asSet(types));
public WrappingBeanBuilder<T> addTypes(Collection<Type> types)
public WrappingBeanBuilder<T> qualifiers(Set<Annotation> qualifiers)
public WrappingBeanBuilder<T> qualifiers(Annotation... qualifiers)
this.qualifiers = ArraysUtils.asSet(qualifiers);
public WrappingBeanBuilder<T> addQualifier(Annotation qualifier)
public WrappingBeanBuilder<T> addQualifiers(Annotation... qualifiers)
this.qualifiers.addAll(ArraysUtils.asSet(qualifiers));
public WrappingBeanBuilder<T> addQualifiers(
public WrappingBeanBuilder<T> name(String name)
public WrappingBeanBuilder<T> scope(Class<? extends Annotation> scope)
public WrappingBeanBuilder<T> alternative(boolean alternative)
public WrappingBeanBuilder<T> stereotypes(
public WrappingBeanBuilder<T> toString(String toString)
public WrappingBeanBuilder<T> nullable(boolean nullable)
public WrappingBeanBuilder<T> passivationCapable(boolean passivationCapable)
public WrappingBeanBuilder<T> id(String id)
import org.apache.deltaspike.core.util.builder.WrappingBeanBuilder;
return new WrappingBeanBuilder<T>(delegate, beanManager)
if (isPassivationCapable())
{
return new ImmutablePassivationCapableBeanWrapper<T>(delegate,
name, qualifiers, scope, stereotypes, types, alternative,
nullable, toString, id);
}
else
{
return new ImmutableBeanWrapper<T>(delegate, name, qualifiers, scope,
stereotypes, types, alternative, nullable, toString);
}
package org.apache.deltaspike.core.util.bean;
public abstract class AbstractImmutableBean<T> implements Bean<T>
package org.apache.deltaspike.core.util.bean;
public class ImmutableBeanWrapper<T> extends AbstractImmutableBean<T>
package org.apache.deltaspike.core.util.bean;
public ImmutablePassivationCapableBeanWrapper(Bean<T> bean,
super(bean, name, qualifiers, scope, stereotypes, types, alternative, nullable, toString);
package org.apache.deltaspike.core.util.bean;
import org.apache.deltaspike.core.util.bean.WrappingBeanBuilder;
if (arguments == null || arguments.length == 0)
{
return messageTemplate;
}
return String.format(messageTemplate, arguments);
import java.lang.reflect.Proxy;
import org.apache.deltaspike.core.util.ClassUtils;
private <T> T createMessageBundleProxy(Class<T> type)
{
return type.cast(Proxy.newProxyInstance(ClassUtils.getClassLoader(null),
new Class<?>[]{type}, new MessageBundleInvocationHandler()));
}
@MessageTemplate("Welcome to %s")
String simpleText(String name);
import org.apache.deltaspike.core.api.config.DeltaSpikeConfig;
public interface LocaleResolver extends Serializable, DeltaSpikeConfig
}
import java.util.Locale;
public interface MessageContext extends Serializable
Locale getLocale();
import org.apache.deltaspike.core.api.config.DeltaSpikeConfig;
public interface MessageInterpolator extends Serializable, DeltaSpikeConfig
import org.apache.deltaspike.core.api.config.annotation.DefaultConfiguration;
import javax.enterprise.context.Dependent;
@Dependent
@DefaultConfiguration
public class DefaultLocaleResolver implements LocaleResolver, Serializable
if (result == null || result.equals(oldTemplate) || result.equals(baseMessage.getMessageTemplate()))
private MessageInterpolator messageInterpolator = null;
private MessageResolver messageResolver = null;
private LocaleResolver localeResolver = null;
import org.apache.deltaspike.core.api.config.annotation.DefaultConfiguration;
import javax.enterprise.context.Dependent;
@Dependent
@DefaultConfiguration
public class DefaultMessageInterpolator implements MessageInterpolator, Serializable
import org.apache.deltaspike.core.api.config.annotation.DefaultConfiguration;
import org.apache.deltaspike.core.api.literal.DefaultConfigurationLiteral;
private MessageInterpolator interpolator;
private LocaleResolver localeResolver;
MessageInterpolator messageInterpolator;
messageInterpolator = BeanProvider.getContextualReference(messageInterpolatorClass);
else
{
messageInterpolator = getDefaultMessageInterpolator();
}
result = messageInterpolator.interpolate(resolvedMessageTemplate, args);
private MessageInterpolator getDefaultMessageInterpolator()
{
if (interpolator == null)
{
initDefaultConfig();
}
return interpolator;
}
private LocaleResolver getDefaultLocaleResolver()
{
if (localeResolver == null)
{
initDefaultConfig();
}
return localeResolver;
}
private synchronized void initDefaultConfig()
{
if (interpolator == null)
{
DefaultConfiguration defaultConfiguration = new DefaultConfigurationLiteral();
interpolator = BeanProvider.getContextualReference(MessageInterpolator.class, defaultConfiguration);
localeResolver = BeanProvider.getContextualReference(LocaleResolver.class, defaultConfiguration);
}
}
public interface MessageContext extends LocaleResolver
import java.util.Locale;
String interpolate(Locale locale, String messageText, Object[] arguments);
import java.util.Locale;
this.locale = messageContext.getLocale();
Locale l = locale != null ? locale : Locale.getDefault();
return messageInterpolator.interpolate(l, getEscapedTemplate(messageTemplate), arguments);
import java.util.Locale;
public String interpolate(Locale locale, String messageTemplate, Object... arguments)
return String.format(locale, messageTemplate, arguments);
private MessageInterpolator defaultInterpolator;
private LocaleResolver defaultLocaleResolver;
result = messageInterpolator.interpolate(localeResolver.getLocale(), resolvedMessageTemplate, args);
if (defaultInterpolator == null)
return defaultInterpolator;
if (defaultLocaleResolver == null)
return defaultLocaleResolver;
if (defaultInterpolator == null)
defaultInterpolator = BeanProvider.getContextualReference(MessageInterpolator.class, defaultConfiguration);
defaultLocaleResolver = BeanProvider.getContextualReference(LocaleResolver.class, defaultConfiguration);
String welcomeWithStringVariable(String name);
@MessageTemplate("Welcome to %f")
String welcomeWithFloatVariable(Float value);
}
String interpolate(String messageText, Object[] arguments, Locale locale);
public String interpolate(String messageTemplate, Object[] arguments, Locale locale)
return messageInterpolator.interpolate(getEscapedTemplate(messageTemplate), arguments, l);
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
result = messageInterpolator.interpolate(resolvedMessageTemplate, args, localeResolver.getLocale());
if (this.lifecycle == null)
{
initLifecycle();
}
initLifecycle();
private void initLifecycle()
{
lifecycle = WebBeansContext.getInstance().getService(ContainerLifecycle.class);
}
Locale l = messageContext.getLocale();
import org.apache.deltaspike.core.api.config.annotation.DefaultConfiguration;
import javax.inject.Inject;
@Inject
@DefaultConfiguration
private LocaleResolver localeResolver;
@Inject
@DefaultConfiguration
private MessageInterpolator messageInterpolator;
protected MessageContext createDefaultMessageContext(Instance<MessageResolver> customMessageResolver)
messageContextConfig.change().messageInterpolator(messageInterpolator);
messageContextConfig.change().localeResolver(localeResolver);
import java.util.Locale;
void initialize(String messageBundleName, Locale locale);
import org.apache.deltaspike.core.api.config.annotation.DefaultConfiguration;
import javax.enterprise.context.Dependent;
@Dependent
@DefaultConfiguration
private ResourceBundle messageBundle;
public void initialize(String messageBundleName, Locale locale)
MessageResolver messageResolver = new DefaultMessageResolver();
messageResolver.initialize(messageBundleName, resolvedLocale);
resolvedMessageTemplate = messageResolver.getMessage(messageTemplate.value());
@Inject
@DefaultConfiguration
private MessageResolver messageResolver;
protected MessageContext createDefaultMessageContext()
messageContextConfig.change().messageResolver(messageResolver);
private Config config = null;
config = new DefaultMessageContextConfig();
import org.apache.deltaspike.core.api.message.annotation.MessageContextConfig;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.util.ClassUtils;
DefaultMessageContextConfig(MessageContextConfig messageContextConfig)
{
if (!MessageResolver.class.equals(messageContextConfig.messageResolver()))
{
Class<? extends MessageResolver> messageResolverClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.messageResolver().getName());
messageResolver = BeanProvider.getContextualReference(messageResolverClass);
}
if (!MessageInterpolator.class.equals(messageContextConfig.messageInterpolator()))
{
Class<? extends MessageInterpolator> messageInterpolatorClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.messageInterpolator().getName());
messageInterpolator = BeanProvider.getContextualReference(messageInterpolatorClass);
}
if (!LocaleResolver.class.equals(messageContextConfig.localeResolver()))
{
Class<? extends LocaleResolver> localeResolverClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.localeResolver().getName());
localeResolver = BeanProvider.getContextualReference(localeResolverClass);
}
}
private MessageContext defaultMessageContext = null;
MessageContext messageContext = resolveMessageContextFromArguments(args);
List<Object> arguments = resolveMessageArguments(args);
if (messageContextConfig != null)
messageContext = applyMessageContextConfig(messageContextConfig, method.getDeclaringClass().getName());
messageContext = getDefaultMessageContext();
}
}
if (String.class.isAssignableFrom(method.getReturnType()))
{
return messageContext.message().text(messageTemplate.value()).argument(arguments.toArray()).toText();
}
return messageContext.message().text(messageTemplate.value()).argument(arguments.toArray()).create();
}
private MessageContext applyMessageContextConfig(MessageContextConfig messageContextConfigLiteral,
String messageBundleName)
{
MessageContext.Config config = new DefaultMessageContextConfig(messageContextConfigLiteral);
if (MessageResolver.class.equals(messageContextConfigLiteral.messageResolver()))
{
MessageResolver messageResolver = new DefaultMessageResolver();
messageResolver.initialize(messageBundleName, config.getLocaleResolver().getLocale());
config.change().messageResolver(messageResolver);
}
return config.use().create();
}
private List<Object> resolveMessageArguments(Object[] args)
{
List<Object> arguments = new ArrayList<Object>();
if (args != null && args.length > 0)
{
{
if (i == 0 && MessageContext.class.isAssignableFrom(args[0].getClass()))
continue;
arguments.add(args[i]);
return arguments;
private MessageContext resolveMessageContextFromArguments(Object[] args)
if (args != null && args.length > 0 &&
MessageContext.class.isAssignableFrom(args[0].getClass()))
{
return (MessageContext) args[0];
}
return null;
}
private MessageContext getDefaultMessageContext()
{
if (defaultMessageContext == null)
return defaultMessageContext;
if (defaultMessageContext == null)
defaultMessageContext = BeanProvider.getContextualReference(MessageContext.class);
import org.apache.deltaspike.core.api.literal.AnyLiteral;
messageResolver = BeanProvider.getContextualReference(messageResolverClass, new AnyLiteral());
messageInterpolator = BeanProvider.getContextualReference(messageInterpolatorClass, new AnyLiteral());
localeResolver = BeanProvider.getContextualReference(localeResolverClass, new AnyLiteral());
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
import org.apache.deltaspike.core.api.literal.AnyLiteral;
defaultMessageContext = BeanProvider.getContextualReference(MessageContext.class, new AnyLiteral());
protected void vetoBeans(@Observes ProcessAnnotatedType processAnnotatedType, BeanManager beanManager)
Exclude exclude = (Exclude) processAnnotatedType.getAnnotatedType().getJavaClass().getAnnotation(Exclude.class);
protected void vetoCustomProjectStageBeans(ProcessAnnotatedType processAnnotatedType)
private void activateGlobalAlternativesWeld(ProcessAnnotatedType processAnnotatedType,
private void activateGlobalAlternativesOwb(ProcessAnnotatedType processAnnotatedType,
private boolean evalExcludeWithoutCondition(ProcessAnnotatedType processAnnotatedType, Exclude exclude)
private boolean evalExcludeInProjectStage(ProcessAnnotatedType processAnnotatedType, Exclude exclude,
private boolean evalExcludeNotInProjectStage(ProcessAnnotatedType processAnnotatedType, Exclude exclude,
private void evalExcludeWithExpression(ProcessAnnotatedType processAnnotatedType, Exclude exclude)
private void veto(ProcessAnnotatedType processAnnotatedType, String vetoType)
protected void detectInterfaces(@Observes ProcessAnnotatedType processAnnotatedType)
public static synchronized void addConfigSources(List<ConfigSource> configSourcesToAdd)
{
getConfigSources();
ClassLoader currentClassLoader = ClassUtils.getClassLoader(null);
ConfigSource[] configuredConfigSources = configSources.get(currentClassLoader);
List<ConfigSource> allConfigSources = Arrays.asList(configuredConfigSources);
allConfigSources.addAll(configSourcesToAdd);
configSources.put(currentClassLoader, sortDescending(allConfigSources));
}
EnvironmentPropertyConfigSourceProvider epcsp = new EnvironmentPropertyConfigSourceProvider(PROPERTY_FILE_NAME);
configSources.addAll(epcsp.getConfigSources());
List<ConfigSource> allConfigSources = new ArrayList<ConfigSource>();
allConfigSources.addAll(Arrays.asList(configuredConfigSources));
Class<? extends PropertyConfigSource> pcsClass = pat.getAnnotatedType().getJavaClass();
if (pcsClass.isAnnotation() ||
pcsClass.isInterface()  ||
pcsClass.isSynthetic()  ||
pcsClass.isArray()      ||
pcsClass.isEnum()         )
{
return;
}
configSourcesClasses.add(pcsClass);
if (o == null || !HandlerMethod.class.isAssignableFrom(o.getClass()))
public class FixedEnglishLocalResolver implements LocaleResolver
class FixedGermanLocaleResolver implements LocaleResolver
public interface MessageContext extends LocaleResolver, Serializable
MessageInterpolator getMessageInterpolator();
MessageResolver getMessageResolver();
LocaleResolver getLocaleResolver();
MessageContext setMessageInterpolator(MessageInterpolator messageInterpolator);
MessageContext setMessageResolver(MessageResolver messageResolver);
MessageContext setLocaleResolver(LocaleResolver localeResolver);
private MessageContext messageContext;
DefaultMessage(MessageContext messageContext,
this.messageContext = messageContext;
return toString(new DefaultMessageContext(messageContext));
this.messageContext = new UnmodifiableMessageContext(messageContext);
return new DefaultMessage(messageContext, messageTemplate,
MessageResolver messageResolver = messageContext.getMessageResolver();
MessageInterpolator messageInterpolator = messageContext.getMessageInterpolator();
import org.apache.deltaspike.core.api.literal.AnyLiteral;
import org.apache.deltaspike.core.api.message.LocaleResolver;
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import org.apache.deltaspike.core.api.message.MessageResolver;
import org.apache.deltaspike.core.api.message.annotation.MessageContextConfig;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.util.ClassUtils;
private MessageInterpolator messageInterpolator = null;
private MessageResolver messageResolver = null;
private LocaleResolver localeResolver = null;
DefaultMessageContext(MessageContext otherMessageContext)
setMessageInterpolator(otherMessageContext.getMessageInterpolator());
setLocaleResolver(otherMessageContext.getLocaleResolver());
setMessageResolver(otherMessageContext.getMessageResolver()) ;
DefaultMessageContext(MessageContextConfig messageContextConfig)
{
if (!MessageResolver.class.equals(messageContextConfig.messageResolver()))
{
Class<? extends MessageResolver> messageResolverClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.messageResolver().getName());
messageResolver = BeanProvider.getContextualReference(messageResolverClass, new AnyLiteral());
}
if (!MessageInterpolator.class.equals(messageContextConfig.messageInterpolator()))
{
Class<? extends MessageInterpolator> messageInterpolatorClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.messageInterpolator().getName());
messageInterpolator = BeanProvider.getContextualReference(messageInterpolatorClass, new AnyLiteral());
}
if (!LocaleResolver.class.equals(messageContextConfig.localeResolver()))
{
Class<? extends LocaleResolver> localeResolverClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.localeResolver().getName());
localeResolver = BeanProvider.getContextualReference(localeResolverClass, new AnyLiteral());
}
}
if (getLocaleResolver() == null)
{
return null;
}
return getLocaleResolver().getLocale();
public LocaleResolver getLocaleResolver()
{
return localeResolver;
}
public MessageContext setLocaleResolver(LocaleResolver localeResolver)
{
this.localeResolver = localeResolver;
return this;
}
public MessageInterpolator getMessageInterpolator()
{
return messageInterpolator;
}
public MessageContext setMessageInterpolator(MessageInterpolator messageInterpolator)
{
this.messageInterpolator = messageInterpolator;
return this;
}
public MessageResolver getMessageResolver()
{
return messageResolver;
}
public MessageContext setMessageResolver(MessageResolver messageResolver)
{
this.messageResolver = messageResolver;
return this;
}
if (!localeResolver.equals(that.localeResolver))
{
return false;
}
if (messageInterpolator != null
? !messageInterpolator.equals(that.messageInterpolator) : that.messageInterpolator != null)
{
return false;
}
if (messageResolver != null ? !messageResolver.equals(that.messageResolver) : that.messageResolver != null)
int result = messageInterpolator != null ? messageInterpolator.hashCode() : 0;
return result;
MessageContext messageContext = new DefaultMessageContext(messageContextConfigLiteral);
messageResolver.initialize(messageBundleName, messageContext.getLocaleResolver().getLocale());
messageContext.setMessageResolver(messageResolver);
return messageContext;
MessageContext messageContext = new DefaultMessageContext();
messageContext.setMessageInterpolator(messageInterpolator);
messageContext.setLocaleResolver(localeResolver);
messageContext.setMessageResolver(messageResolver);
return messageContext;
import org.apache.deltaspike.core.api.message.LocaleResolver;
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import org.apache.deltaspike.core.api.message.MessageResolver;
public LocaleResolver getLocaleResolver()
return messageContext.getLocaleResolver();
@Override
public MessageInterpolator getMessageInterpolator()
{
return messageContext.getMessageInterpolator();
}
@Override
public MessageResolver getMessageResolver()
{
return messageContext.getMessageResolver();
}
public MessageContext setLocaleResolver(LocaleResolver localeResolver)
{
throw new UnsupportedOperationException();
}
@Override
public MessageContext setMessageInterpolator(MessageInterpolator messageInterpolator)
{
throw new UnsupportedOperationException();
}
@Override
public MessageContext setMessageResolver(MessageResolver messageResolver)
{
throw new UnsupportedOperationException();
}
@Override
Message bundle(String messageBundleName);
Message template(String messageTemplate);
Message argument(Object... arguments);
String getBundle();
String getTemplate();
public interface MessageContext extends LocaleResolver, Serializable, Cloneable
MessageContext clone();
Message message();
MessageContext messageInterpolator(MessageInterpolator messageInterpolator);
MessageContext messageResolver(MessageResolver messageResolver);
MessageContext localeResolver(LocaleResolver localeResolver);
String getMessage(String bundleName, Locale locale, String messageTemplate);
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import org.apache.deltaspike.core.api.message.MessageResolver;
import java.util.Collections;
import java.util.Locale;
import static org.apache.deltaspike.core.api.message.MessageResolver.MISSING_RESOURCE_MARKER;
protected String messageBundleName = null;
DefaultMessage(MessageContext messageContext)
{
reset();
this.messageContext = messageContext;
}
String messageBundleName,
reset();
this.messageBundleName = messageBundleName;
Collections.addAll(this.arguments, arguments);
}
protected void reset()
{
messageBundleName = null;
messageTemplate = null;
arguments = new ArrayList<Object>();
public Message bundle(String messageBundleName)
this.messageBundleName = messageBundleName;
@Override
public Message argument(Object... arguments)
Collections.addAll(this.arguments, arguments);
return this;
public Message template(String messageTemplate)
{
this.messageTemplate = messageTemplate;
return this;
}
@Override
public String getBundle()
{
return messageBundleName;
}
@Override
public String getTemplate()
Locale locale = messageContext.getLocale();
String template = getTemplate();
String ret = template;
MessageResolver messageResolver = messageContext.getMessageResolver();
if (messageResolver != null)
{
String resolvedTemplate = messageResolver.getMessage(getBundle(), locale, template);
if (resolvedTemplate == null)
{
resolvedTemplate = markAsUnresolved(template);
}
ret = resolvedTemplate;
template = resolvedTemplate;
}
MessageInterpolator messageInterpolator = messageContext.getMessageInterpolator();
if (messageInterpolator != null)
{
ret = messageInterpolator.interpolate(template, getArguments(), locale);
}
return ret;
}
private String markAsUnresolved(String template)
{
if (messageTemplate.startsWith("{") && messageTemplate.endsWith("}"))
{
template = messageTemplate.substring(1, messageTemplate.length() - 1);
}
if (getArguments() != null && getArguments().length > 0)
{
sb.append(" ").append(Arrays.toString(getArguments()));
}
return sb.toString();
.template(getTemplate())
.toString();
if (!getTemplate().equals(that.getTemplate()))
int result = getTemplate().hashCode();
class DefaultMessageBuilder
this.messageContext = messageContext;
return new DefaultMessage(messageContext, null, messageTemplate,
String messageTemplate = baseMessage.getTemplate();
if (result == null || isKey(baseMessage.getTemplate()) || isKeyWithoutMarkers(result, baseMessage))
String oldTemplate = extractTemplate(baseMessage.getTemplate());
if (result == null || result.equals(oldTemplate) || result.equals(baseMessage.getTemplate()))
return (!result.contains(" ") && result.endsWith(baseMessage.getTemplate()));
import org.apache.deltaspike.core.api.message.Message;
messageInterpolator(otherMessageContext.getMessageInterpolator());
localeResolver(otherMessageContext.getLocaleResolver());
messageResolver(otherMessageContext.getMessageResolver()) ;
public MessageContext clone()
return new DefaultMessageContext(this);
}
@Override
public Message message()
{
return new DefaultMessage(this);
return Locale.getDefault();
public MessageContext localeResolver(LocaleResolver localeResolver)
public MessageContext messageInterpolator(MessageInterpolator messageInterpolator)
public MessageContext messageResolver(MessageResolver messageResolver)
public String getMessage(String bundleName, Locale locale, String messageTemplate)
if (messageTemplate.startsWith("{{"))
return messageTemplate.substring(1);
}
if (messageTemplate.startsWith("{") && messageTemplate.endsWith("}"))
{
String resourceKey = messageTemplate.substring(1, messageTemplate.length() - 1);
if (bundleName == null)
{
return null;
}
ResourceBundle messageBundle = PropertyFileUtils.getResourceBundle(bundleName, locale);
return messageBundle.getString(resourceKey);
return null;
import org.apache.deltaspike.core.api.message.LocaleResolver;
import org.apache.deltaspike.core.api.message.MessageInterpolator;
import org.apache.deltaspike.core.util.ClassUtils;
messageContext = getDefaultMessageContext().clone();
applyMessageContextConfig(messageContext, messageContextConfig);
String messageBundleName = method.getDeclaringClass().getName();
return messageContext.message().bundle(messageBundleName).template(messageTemplate.value())
.argument(arguments.toArray()).toString();
return messageContext.message().bundle(messageBundleName).template(messageTemplate.value())
.argument(arguments.toArray());
private void applyMessageContextConfig(MessageContext messageContext, MessageContextConfig messageContextConfig)
if (!MessageResolver.class.equals(messageContextConfig.messageResolver()))
Class<? extends MessageResolver> messageResolverClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.messageResolver().getName());
messageContext.messageResolver(
BeanProvider.getContextualReference(messageResolverClass, new AnyLiteral()));
if (!MessageInterpolator.class.equals(messageContextConfig.messageInterpolator()))
{
Class<? extends MessageInterpolator> messageInterpolatorClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.messageInterpolator().getName());
messageContext.messageInterpolator(
BeanProvider.getContextualReference(messageInterpolatorClass, new AnyLiteral()));
}
if (!LocaleResolver.class.equals(messageContextConfig.localeResolver()))
{
Class<? extends LocaleResolver> localeResolverClass =
ClassUtils.tryToLoadClassForName(messageContextConfig.localeResolver().getName());
messageContext.localeResolver(
BeanProvider.getContextualReference(localeResolverClass, new AnyLiteral()));
}
return BeanProvider.getContextualReference(MessageContext.class);
messageContext.messageInterpolator(messageInterpolator);
messageContext.localeResolver(localeResolver);
messageContext.messageResolver(messageResolver);
@Qualifier
@Target({ TYPE, METHOD, PARAMETER, FIELD })
@Retention(RUNTIME)
@Documented
MessageContext bundle(String messageBundleName);
String getBundle();
String getMessage(MessageContext messageContext, String messageTemplate);
String resolvedTemplate = messageResolver.getMessage(messageContext, template);
Locale locale = messageContext.getLocale();
private String messageBundleName = null;
public MessageContext bundle(String messageBundleName)
{
this.messageBundleName = messageBundleName;
return this;
}
@Override
public String getBundle()
{
return messageBundleName;
}
@Override
import org.apache.deltaspike.core.api.message.MessageContext;
public String getMessage(MessageContext messageContext, String messageTemplate)
String bundleName = messageContext.getBundle();
Locale locale = messageContext.getLocale();
return messageContext.bundle(messageBundleName).message().template(messageTemplate.value())
return messageContext.bundle(messageBundleName).message().template(messageTemplate.value())
String messageTemplateValue;
if (messageTemplate != null)
{
messageTemplateValue = messageTemplate.value();
}
else
{
}
return messageContext.bundle(messageBundleName).message().template(messageTemplateValue)
return messageContext.bundle(messageBundleName).message().template(messageTemplateValue)
import org.apache.deltaspike.core.api.message.MessageSource;
private final Class<? extends MessageSource>[] messageSource;
this(MessageResolver.class, MessageInterpolator.class, LocaleResolver.class, MessageSource.class);
Class<? extends LocaleResolver> localeResolver,
Class<? extends MessageSource>... messageSource)
this.messageSource = messageSource;
}
@Override
public Class<? extends MessageSource>[] messageSource()
{
return this.messageSource;
import java.util.List;
MessageContext messageSource(MessageSource messageSource);
MessageContext messageSource(Class<? extends MessageSource> messageSourceClass);
List<MessageSource> getMessageSources();
import org.apache.deltaspike.core.api.message.MessageSource;
Class<? extends MessageSource>[] messageSource() default MessageSource.class;
import org.apache.deltaspike.core.api.message.MessageSource;
import org.apache.deltaspike.core.util.ClassUtils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
private List<MessageSource> messageSources = new ArrayList<MessageSource>();
messageResolver(otherMessageContext.getMessageResolver());
this.messageSources.addAll(otherMessageContext.getMessageSources());
public Message message()
return new DefaultMessage(this);
}
@Override
public MessageContext messageSource(MessageSource messageSource)
{
this.messageSources.add(messageSource);
public MessageContext messageSource(Class<? extends MessageSource> messageSourceClass)
if (MessageSource.class.equals(messageSourceClass))
{
return this;
}
return messageSource(ClassUtils.tryToInstantiateClass(messageSourceClass));
@Override
@Override
public List<MessageSource> getMessageSources()
{
return Collections.unmodifiableList(this.messageSources);
}
@Override
@Override
@Override
@Override
@Override
import org.apache.deltaspike.core.api.message.MessageSource;
import java.util.Iterator;
import java.util.List;
@SuppressWarnings("UnusedDeclaration")
List<MessageSource> messageSources = messageContext.getMessageSources();
if (messageSources == null || messageSources.isEmpty())
Iterator<MessageSource> messageSourceIterator = messageSources.iterator();
MessageSource currentMessageSource;
while (messageSourceIterator.hasNext())
currentMessageSource = messageSourceIterator.next();
try
{
Locale locale = messageContext.getLocale();
ResourceBundle messageBundle = PropertyFileUtils
.getResourceBundle(currentMessageSource.getKey(), locale);
return messageBundle.getString(resourceKey);
}
catch (MissingResourceException e)
{
if (!messageSourceIterator.hasNext())
{
return null;
}
}
import org.apache.deltaspike.core.api.message.MessageSource;
messageContext.messageSource(createDefaultMessageSource(method.getDeclaringClass()));
return messageContext.message().template(messageTemplateValue).argument(arguments.toArray()).toString();
return messageContext.message().template(messageTemplateValue).argument(arguments.toArray());
Class<? extends MessageSource>[] messageSources = messageContextConfig.messageSource();
for (Class<? extends MessageSource> currentMessageSource : messageSources)
{
messageContext.messageSource(currentMessageSource);
}
private MessageSource createDefaultMessageSource(final Class<?> messageBundleClass)
{
final String className = messageBundleClass.getName();
return new MessageSource()
{
@Override
public String getKey()
{
return className;
}
};
}
if (template == null)
{
return "";
}
Message other = (Message) o;
if (getTemplate() == null && other.getTemplate() != null)
{
return false;
}
if (getTemplate() != null && !getTemplate().equals(other.getTemplate()))
if (arguments != null
? !Arrays.equals(arguments.toArray(), other.getArguments())
: other.getArguments() != null)
private final String[] messageSource;
this(MessageResolver.class, MessageInterpolator.class, LocaleResolver.class, new String[0]);
String[] messageSource)
public String[] messageSource()
MessageContext messageSource(String... messageSource);
List<String> getMessageSources();
String[] messageSource() default { };
import java.util.Arrays;
private List<String> messageSources = new ArrayList<String>();
public MessageContext messageSource(String... messageSource)
this.messageSources.addAll(0, Arrays.asList(messageSource));
public List<String> getMessageSources()
List<String> messageSources = messageContext.getMessageSources();
Iterator<String> messageSourceIterator = messageSources.iterator();
String currentMessageSource;
ResourceBundle messageBundle = PropertyFileUtils.getResourceBundle(currentMessageSource, locale);
String messageBundleName = method.getDeclaringClass().getName();
return messageContext.messageSource(messageBundleName).message().template(messageTemplateValue)
.argument(arguments.toArray()).toString();
return messageContext.messageSource(messageBundleName).message().template(messageTemplateValue)
.argument(arguments.toArray());
String[] messageSources = messageContextConfig.messageSource();
messageContext.messageSource(messageSources);
messageSource = "customMinimalMessage")
List<String> newMessageSources = new ArrayList<String>();
for (String currentMessageSource : messageSource)
{
if (!this.messageSources.contains(currentMessageSource))
{
newMessageSources.add(currentMessageSource);
}
}
this.messageSources.addAll(0, newMessageSources);
String toString();
String toString(MessageContext messageContext);
@Override
import java.io.Serializable;
public interface Message extends Serializable
Message argument(Serializable... arguments);
String interpolate(String messageText, Serializable[] arguments, Locale locale);
import java.io.Serializable;
protected List<Serializable> arguments = new ArrayList<Serializable>();
arguments = new ArrayList<Serializable>();
public Message argument(Serializable... arguments)
public Serializable[] getArguments()
return arguments.toArray(new Serializable[arguments.size()]);
public String interpolate(String messageTemplate, Serializable[] arguments, Locale locale)
import java.io.Serializable;
import org.apache.deltaspike.core.api.message.Message;
List<Serializable> arguments = resolveMessageArguments(args);
Message message =  messageContext
.messageSource(messageBundleName).message()
.template(messageTemplateValue)
.argument(arguments.toArray(new Serializable[arguments.size()]));
return message.toString();
return message;
private List<Serializable> resolveMessageArguments(Object[] args)
List<Serializable> arguments = new ArrayList<Serializable>();
Object arg = args[i];
if (arg instanceof Serializable)
{
arguments.add((Serializable) arg);
}
else
{
arguments.add(arg.toString());
}
if (annotation.annotationType().equals(Named.class))
{
name = Named.class.cast(annotation).value();
}
else if (beanManager.isQualifier(annotation.annotationType()))
public class DefaultMessage implements Message
private String messageTemplate;
private List<Serializable> arguments = new ArrayList<Serializable>();
public DefaultMessage(MessageContext messageContext)
public DefaultMessageContext()
public DefaultMessageContext(MessageContext otherMessageContext)
messageSources.addAll(otherMessageContext.getMessageSources());
if (!messageSources.contains(currentMessageSource))
messageSources.addAll(0, newMessageSources);
return Collections.unmodifiableList(messageSources);
public class DefaultMessageResolver implements MessageResolver
public class TypedMessageBundleProducer implements Serializable
return messageSource;
private String sessionId;
public MockHttpSession(String sessionId)
{
this.sessionId = sessionId;
}
return sessionId;
@Override
public boolean equals(Object o)
{
if (this == o)
{
return true;
}
if (o == null || getClass() != o.getClass())
{
return false;
}
MockHttpSession that = (MockHttpSession) o;
if (sessionId != null ? !sessionId.equals(that.sessionId) : that.sessionId != null)
{
return false;
}
return true;
}
@Override
public int hashCode()
{
return sessionId != null ? sessionId.hashCode() : 0;
}
private static MockServletContext instance = new MockServletContext();
private MockServletContext()
{
}
public static synchronized MockServletContext getInstance()
{
return instance;
}
session = new MockHttpSession("mockSession1");
servletContext = MockServletContext.getInstance();
@SuppressWarnings("CloneDoesntDeclareCloneNotSupportedException")
import java.io.Serializable;
WrappingBeanBuilder<T> beanBuilder = new WrappingBeanBuilder<T>(delegate, beanManager)
.readFromType(annotatedType);
beanBuilder.types(annotatedType.getJavaClass(), Object.class, Serializable.class);
return beanBuilder.create();
public void collectUserConfigSources(@Observes ProcessAnnotatedType<? extends PropertyConfigSource> pat)
import javax.servlet.ServletContextEvent;
public static ServletContextEvent getServletContextEvent()
{
return new ServletContextEvent(getInstance());
}
contextFactory.initSingletonContext(OwbHelper.getMockServletContextEvent());
contextFactory.initApplicationContext(OwbHelper.getMockServletContextEvent());
contextFactory.initSessionContext(OwbHelper.getMockSession());
contextFactory.initApplicationContext(OwbHelper.getMockServletContextEvent());
contextFactory.initSessionContext(OwbHelper.getMockSession());
contextFactory.destroySingletonContext(OwbHelper.getMockServletContextEvent());
contextFactory.destroyApplicationContext(OwbHelper.getMockServletContextEvent());
contextFactory.destroySessionContext(OwbHelper.getMockSession());
@SuppressWarnings("UnusedDeclaration")
if (System.getSecurityManager() != null)
return AccessController.doPrivileged(new GetClassLoaderAction(o));
}
else
{
return getClassLoaderInternal(o);
}
}
static class GetClassLoaderAction implements PrivilegedAction<ClassLoader>
{
private Object object;
GetClassLoaderAction(Object object)
{
this.object = object;
}
@Override
public ClassLoader run()
{
try
return getClassLoaderInternal(object);
}
catch (Exception e)
{
return null;
}
private static ClassLoader getClassLoaderInternal(Object o)
{
ClassLoader loader = Thread.currentThread().getContextClassLoader();
new String[]{"org.apache.deltaspike.core", "org.apache.deltaspike.test.category"},
excludedPackagesOrFiles);
private final Map<Type, Collection<HandlerMethod<? extends Throwable>>> allHandlers;
HandlerMethodStorageImpl(Map<Type, Collection<HandlerMethod<? extends Throwable>>> allHandlers)
new HashSet<HandlerMethod<? extends Throwable>>(Collections.singleton(handlerMethod)));
private Map<Type, Collection<HandlerMethod<? extends Throwable>>> allHandlers
for (Map.Entry<Type, Collection<HandlerMethod<? extends Throwable>>> entry : allHandlers.entrySet())
public Map<Type, Collection<HandlerMethod<? extends Throwable>>> getAllExceptionHandlers()
public static synchronized void freeConfigSources()
{
configSources.remove(ClassUtils.getClassLoader(null));
}
import javax.enterprise.inject.spi.BeforeShutdown;
@SuppressWarnings("UnusedDeclaration")
public void freeConfigSources(@Observes BeforeShutdown bs)
{
ConfigResolver.freeConfigSources();
}
List<ConfigSource> appConfigSources =
sortAscending(new ArrayList<ConfigSource>(Arrays.asList(getConfigSources())));
public class ConfigExample
private static final Logger LOG = Logger.getLogger(ConfigExample.class.getName());
private ConfigExample()
@Produces
@Dependent
@Location
public LocationId produceLocationId(InjectionPoint injectionPoint)
{
String configuredValue = getStringPropertyValue(injectionPoint);
if (configuredValue == null)
{
}
return LocationId.valueOf(configuredValue.trim().toUpperCase());
}
@Inject
@Location
private LocationId locationId;
public LocationId getLocationId()
{
return locationId;
}
LOG.log(Level.FINE, "no configured value found for key {0}, using default value {1}.",
import java.util.logging.Level;
import java.util.logging.Logger;
private static final Logger LOG = Logger.getLogger(EnvironmentPropertyConfigSourceProvider.class.getName());
LOG.log(Level.INFO,
"Custom config found by DeltaSpike. Name: ''{0}'', URL: ''{1}''",
new Object[] {propertyFileName, propertyFileUrl});
public interface PropertyFileConfig extends DeltaSpikeConfig
String getFilePath();
import org.apache.deltaspike.core.api.config.PropertyFileConfig;
private static final String CANNOT_CREATE_CONFIG_SOURCE_FOR_CUSTOM_PROPERTY_FILE_CONFIG =
"Cannot create ConfigSource for custom property-file config ";
private List<Class<? extends PropertyFileConfig>> configSourcesClasses
= new ArrayList<Class<?  extends PropertyFileConfig>>();
public void collectUserConfigSources(@Observes ProcessAnnotatedType<? extends PropertyFileConfig> pat)
Class<? extends PropertyFileConfig> pcsClass = pat.getAnnotatedType().getJavaClass();
for (Class<? extends PropertyFileConfig> propertyFileConfigClass : configSourcesClasses)
configSources.addAll(createPropertyConfigSource(propertyFileConfigClass));
private List<ConfigSource> createPropertyConfigSource(Class<? extends PropertyFileConfig> propertyFileConfigClass)
PropertyFileConfig propertyFileConfig = propertyFileConfigClass.newInstance();
= new EnvironmentPropertyConfigSourceProvider(propertyFileConfig.getFilePath());
throw new RuntimeException(CANNOT_CREATE_CONFIG_SOURCE_FOR_CUSTOM_PROPERTY_FILE_CONFIG
propertyFileConfigClass.getName(), e);
throw new RuntimeException(CANNOT_CREATE_CONFIG_SOURCE_FOR_CUSTOM_PROPERTY_FILE_CONFIG
propertyFileConfigClass.getName(), e);
class EnvironmentPropertyConfigSourceProvider implements ConfigSourceProvider
EnvironmentPropertyConfigSourceProvider(String propertyFileName)
import org.apache.deltaspike.core.api.config.PropertyFileConfig;
public class MyCustomPropertyFileConfig implements PropertyFileConfig
public String getFilePath()
import org.apache.deltaspike.core.api.config.PropertyFileConfig;
public class CustomPropertyFileConfig implements PropertyFileConfig
public String getFilePath()
public abstract class BasePropertyExpressionInterpreter implements ExpressionInterpreter<String, Boolean>
package org.apache.deltaspike.core.util.bean;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;
import javax.enterprise.context.Dependent;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.InjectionPoint;
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
import org.apache.deltaspike.core.util.ArraysUtils;
public abstract class BaseImmutableBean<T> implements Bean<T>
{
private static final Logger LOG = Logger.getLogger(BaseImmutableBean.class.getName());
private final Class<?> beanClass;
private final String name;
private final Set<Annotation> qualifiers;
private final Class<? extends Annotation> scope;
private final Set<Class<? extends Annotation>> stereotypes;
private final Set<Type> types;
private final boolean alternative;
private final boolean nullable;
private final Set<InjectionPoint> injectionPoints;
private final String toString;
public BaseImmutableBean(Class<?> beanClass,
String name,
Set<Annotation> qualifiers,
Class<? extends Annotation> scope,
Set<Class<? extends Annotation>> stereotypes,
Set<Type> types,
boolean alternative,
boolean nullable,
Set<InjectionPoint> injectionPoints,
String toString)
{
if (beanClass == null)
{
throw new IllegalArgumentException("beanClass cannot be null");
}
this.beanClass = beanClass;
this.name = name;
if (qualifiers == null)
{
this.qualifiers = Collections.<Annotation>singleton(new DefaultLiteral());
}
else
{
this.qualifiers = new HashSet<Annotation>(qualifiers);
}
if (scope == null)
{
this.scope = Dependent.class;
}
else
{
this.scope = scope;
}
if (stereotypes == null)
{
this.stereotypes = Collections.emptySet();
}
else
{
this.stereotypes = new HashSet<Class<? extends Annotation>>(stereotypes);
}
if (types == null)
{
this.types = ArraysUtils.<Type>asSet(Object.class, beanClass);
".class]");
}
else
{
this.types = new HashSet<Type>(types);
}
if (injectionPoints == null)
{
this.injectionPoints = Collections.emptySet();
}
else
{
this.injectionPoints = new HashSet<InjectionPoint>(injectionPoints);
}
this.alternative = alternative;
this.nullable = nullable;
if (toString != null)
{
this.toString = toString;
}
else
{
}
}
@Override
public Class<?> getBeanClass()
{
return beanClass;
}
@Override
public Set<InjectionPoint> getInjectionPoints()
{
return injectionPoints;
}
@Override
public String getName()
{
return name;
}
@Override
public Set<Annotation> getQualifiers()
{
return Collections.unmodifiableSet(qualifiers);
}
@Override
public Class<? extends Annotation> getScope()
{
return scope;
}
@Override
public Set<Class<? extends Annotation>> getStereotypes()
{
return Collections.unmodifiableSet(stereotypes);
}
@Override
public Set<Type> getTypes()
{
return Collections.unmodifiableSet(types);
}
@Override
public boolean isAlternative()
{
return alternative;
}
@Override
public boolean isNullable()
{
return nullable;
}
@Override
public String toString()
{
return toString;
}
}
public class ImmutableBeanWrapper<T> extends BaseImmutableBean<T>
import org.apache.deltaspike.core.api.interpreter.BasePropertyExpressionInterpreter;
public class PropertyExpressionInterpreter extends BasePropertyExpressionInterpreter
String getPropertyFileName();
= new EnvironmentPropertyConfigSourceProvider(propertyFileConfig.getPropertyFileName());
public String getPropertyFileName()
public String getPropertyFileName()
import org.apache.deltaspike.core.api.projectstage.ProjectStage;
import org.apache.deltaspike.core.util.ProjectStageProducer;
import java.util.logging.Level;
import java.util.logging.Logger;
private static final Logger LOG = Logger.getLogger(BeanProvider.class.getName());
private static final boolean LOG_DEPENDENT_WARNINGS;
static {
ProjectStage ps = ProjectStageProducer.getInstance().getProjectStage();
LOG_DEPENDENT_WARNINGS = ps.equals(ProjectStage.Development) || ps.equals(ProjectStage.UnitTest);
}
logWarningIfDependent(bean);
private static void logWarningIfDependent(Bean<?> bean)
{
if (LOG_DEPENDENT_WARNINGS && bean.getScope().equals(Dependent.class))
{
LOG.log(Level.WARNING, "BeanProvider shall not be used to create @Dependent scoped beans. "
}
}
Object mockSession = null;
if (isServletApiAvailable())
{
mockSession = OwbHelper.getMockSession();
}
Object mockServletContextEvent = null;
if (isServletApiAvailable())
{
mockServletContextEvent = OwbHelper.getMockServletContextEvent();
}
contextFactory.initSingletonContext(mockServletContextEvent);
contextFactory.initApplicationContext(mockServletContextEvent);
contextFactory.initSessionContext(mockSession);
private static boolean isServletApiAvailable()
{
try
{
Class servletClass = Class.forName("javax.servlet.http.HttpSession");
return servletClass != null;
}
catch (ClassNotFoundException e)
{
return false;
}
}
Object mockServletContextEvent = null;
if (isServletApiAvailable())
{
mockServletContextEvent = OwbHelper.getMockServletContextEvent();
}
contextFactory.initApplicationContext(mockServletContextEvent);
Object mockSession = null;
if (isServletApiAvailable())
{
mockSession = OwbHelper.getMockSession();
}
contextFactory.initSessionContext(mockSession);
Object mockServletContextEvent = null;
if (isServletApiAvailable())
{
mockServletContextEvent = OwbHelper.getMockServletContextEvent();
}
contextFactory.destroySingletonContext(mockServletContextEvent);
Object mockServletContextEvent = null;
if (isServletApiAvailable())
{
mockServletContextEvent = OwbHelper.getMockServletContextEvent();
}
contextFactory.destroyApplicationContext(mockServletContextEvent);
Object mockSession = null;
if (isServletApiAvailable())
{
mockSession = OwbHelper.getMockSession();
}
contextFactory.destroySessionContext(mockSession);
return new MockHttpSession("mockSession1");
return new ServletContextEvent(MockServletContext.getInstance());
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
import org.apache.deltaspike.core.util.ArraysUtils;
import javax.enterprise.context.Dependent;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.InjectionPoint;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.spi.Bean;
types, alternative, nullable, bean.getInjectionPoints(), toString);
private final String id;
import org.apache.deltaspike.core.api.literal.AnyLiteral;
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
import org.apache.deltaspike.core.util.ArraysUtils;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
this.delegate = (Bean<T>) delegate;
method, position, getJavaClass()));
constructorParameters.get(constructor).get(position) != null)
constructor.getJavaMember(), new HashMap<Integer, AnnotationBuilder>());
constructor.getJavaMember()).put(p.getPosition(), new AnnotationBuilder());
return (T) annotationMap.get(anType);
import org.apache.deltaspike.core.util.BeanUtils;
import java.lang.annotation.Annotation;
import java.lang.reflect.Member;
import java.lang.reflect.Type;
import java.util.HashSet;
import java.util.Set;
import org.apache.deltaspike.core.util.metadata.builder.ParameterValueRedefiner.ParameterValue;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
throw (RuntimeException) e.getCause();
import javax.inject.Singleton;
Context context = contextFactory.getStandardContext(Singleton.class);
Context context = contextFactory.getStandardContext(ApplicationScoped.class);
Context context = contextFactory.getStandardContext(SessionScoped.class);
Context context = contextFactory.getStandardContext(RequestScoped.class);
Context context = contextFactory.getStandardContext(ConversationScoped.class);
import java.util.Map;
String getName();
void setAttribute(String name, String value);
void setAttribute(String name, String[] values);
void removeAttribute(String name);
String getAttribute(String name);
String[] getAttributeValues(String name);
Map<String, String[]> getAttributes();
public interface Group extends IdentityType
String getName();
public interface IdentityType
String getKey();
public interface Role extends IdentityType
String getName();
public interface User extends IdentityType
String getId();
boolean hasPermission(Object resource, String operation);
boolean hasPermission(Class<?> resourceClass, Serializable identifier, String operation);
public interface LoginCredentials
import java.util.Date;
void addToGroup(IdentityType identityType, Group group);
void removeFromGroup(IdentityType identityType, Group group);
Collection<IdentityType> getGroupMembers(Group group);
Collection<Role> getRoles(IdentityType identityType, Group group);
boolean hasRole(Role role, IdentityType identityType, Group group);
void grantRole(Role role, IdentityType identityType, Group group);
void revokeRole(Role role, IdentityType identityType, Group group);
boolean validatePassword(String password);
void updatePassword(String password);
void setEnabled(IdentityType identityType, boolean enabled);
void setExpirationDate(IdentityType identityType, Date expirationDate);
import java.util.Date;
boolean isEnabled();
Date getExpirationDate();
Date getCreationDate();
RoleQuery setOwner(IdentityType owner);
void setLastName(String lastName);
import org.apache.deltaspike.security.api.User;
private AuthenticationStatus status = AuthenticationStatus.FAILURE;
private User user;
protected void setUser(User user)
{
this.user = user;
}
public User getUser()
{
return user;
}
import org.apache.deltaspike.security.api.credential.LoginCredentials;
@Named("loginCredentials")
public class DefaultLoginCredentials implements LoginCredentials
public String getPassword()
{
return credential != null && credential.getValue() instanceof String ? (String) credential.getValue() : null;
}
public void setPassword(final String password)
{
this.credential = new Credential<String>() {
@Override
public String getValue()
{
return password;
}
};
}
<<<<<<< HEAD
=======
import org.apache.deltaspike.security.api.User;
>>>>>>> added missing files
<<<<<<< HEAD
=======
import org.apache.deltaspike.security.api.credential.LoginCredential;
>>>>>>> added missing files
<<<<<<< HEAD
=======
private LoginCredential loginCredential;
>>>>>>> added missing files
import org.apache.deltaspike.security.api.idm.User;
import org.apache.deltaspike.security.api.idm.User;
import org.apache.deltaspike.security.api.idm.User;
private Range()
{
private Range(int offset, int limit)
{
int getPage()
{
public int getOffset()
{
public int getLimit()
{
public Range of(int offset, int limit)
{
public Range next()
{
import java.util.Collection;
PermissionQuery createPermissionQuery();
void grantPermission(Permission permission);
void grantPermissions(Collection<Permission> permission);
void revokePermission(Permission permission);
void revokePermissions(Collection<Permission> permissions);
import org.apache.deltaspike.security.api.idm.User;
import org.apache.deltaspike.security.api.idm.User;
User createUser(String name);
void removeUser(User user);
User getUser(String name);
Group createGroup(String name, Group parent);
void removeGroup(Group group);
Group getGroup(String name);
Role createRole(String name);
void removeRole(Role role);
Role getRole(String role);
Membership createMembership(Role role, User user, Group group);
void removeMembership(Role role, User user, Group group);
Membership getMembership(Role role, User user, Group group);
List<User> executeQuery(UserQuery query, Range range);
List<Group> executeQuery(GroupQuery query, Range range);
List<Role> executeQuery(RoleQuery query, Range range);
List<Membership> executeQuery(MembershipQuery query, Range range);
void setAttribute(User user, String name, String[] values);
void removeAttribute(User user, String name);
String[] getAttributeValues(User user, String name);
Map<String, String[]> getAttributes(User user);
void setAttribute(Group group, String name, String[] values);
void removeAttribute(Group group, String name);
String[] getAttributeValues(Group group, String name);
Map<String, String[]> getAttributes(Group group);
void setAttribute(Role role, String name, String[] values);
void removeAttribute(Role role, String name);
String[] getAttributeValues(Role role, String name);
Map<String, String[]> getAttributes(Role role);
import java.util.Collection;
import org.apache.deltaspike.security.api.permission.PermissionQuery;
List<Permission> getPermissions(PermissionQuery query);
boolean grantPermissions(Collection<Permission> permissions);
boolean revokePermissions(Collection<Permission> permissions);
package org.apache.deltaspike.security.api.permission.annotations;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
@Target({ METHOD, FIELD })
public @interface ACLIdentifier
package org.apache.deltaspike.security.api.permission.annotations;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
@Target({ METHOD, FIELD })
public @interface ACLPermission
package org.apache.deltaspike.security.api.permission.annotations;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
@Target({ METHOD, FIELD })
public @interface ACLRecipient
package org.apache.deltaspike.security.api.permission.annotations;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
@Target({ METHOD, FIELD })
public @interface ACLResourceClass
package org.apache.deltaspike.security.api.permission.annotations;
<<<<<<< HEAD
=======
>>>>>>> added ACL permission storage annotations, copied reflections utils from Solder (to be merged with DS core later), minor fixes
<<<<<<< HEAD
=======
import org.apache.deltaspike.security.api.credential.LoginCredentials;
import org.apache.deltaspike.security.api.idm.User;
>>>>>>> added ACL permission storage annotations, copied reflections utils from Solder (to be merged with DS core later), minor fixes
<<<<<<< HEAD
=======
private LoginCredentials loginCredential;
>>>>>>> added ACL permission storage annotations, copied reflections utils from Solder (to be merged with DS core later), minor fixes
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import org.apache.deltaspike.security.api.permission.annotations.ACLStore;
@ApplicationScoped
private Class<?> generalPermissionStore = null;
private Map<Class<?>, Class<?>> permissionStoreMap = new HashMap<Class<?>, Class<?>>();
@Inject
private Instance<EntityManager> entityManagerInstance;
final BeanManager beanManager)
{
EntityManager em = entityManagerInstance.get();
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import javax.persistence.Query;
import org.apache.deltaspike.security.api.permission.annotations.ACLIdentifier;
import org.apache.deltaspike.security.api.permission.annotations.ACLPermission;
import org.apache.deltaspike.security.api.permission.annotations.ACLRecipient;
import org.apache.deltaspike.security.api.permission.annotations.ACLResourceClass;
import org.apache.deltaspike.security.impl.util.properties.Property;
import org.apache.deltaspike.security.impl.util.properties.query.AnnotatedPropertyCriteria;
import org.apache.deltaspike.security.impl.util.properties.query.PropertyQueries;
private StoreMetadata generalStore = null;
private Map<Class<?>, StoreMetadata> storeMap = new HashMap<Class<?>, StoreMetadata>();
private Instance<EntityManager> entityManagerInstance;
if (event.getAnnotatedType().isAnnotationPresent(Entity.class))
{
if (generalStore == null)
generalStore = new StoreMetadata(type.getJavaClass());
if (storeMap.containsKey(store.value()))
type.getJavaClass().getName());
storeMap.put(store.value(), new StoreMetadata(type.getJavaClass()));
}
Map<StoreMetadata, Set<Object>> resourceMetadata = new HashMap<StoreMetadata, Set<Object>>();
if (query.getResources() != null)
{
for (Object resource : query.getResources())
{
Class<?> resourceClass = resource.getClass();
StoreMetadata meta = (storeMap.containsKey(resourceClass)) ? storeMap.get(resourceClass) : generalStore;
if (!resourceMetadata.containsKey(meta))
{
resourceMetadata.put(meta, new HashSet<Object>());
}
resourceMetadata.get(meta).add(resource);
}
}
else if (query.getResource() != null)
{
Class<?> resourceClass = query.getResource().getClass();
StoreMetadata meta = (storeMap.containsKey(resourceClass)) ? storeMap.get(resourceClass) : generalStore;
if (!resourceMetadata.containsKey(meta))
{
resourceMetadata.put(meta, new HashSet<Object>());
}
resourceMetadata.get(meta).add(query.getResource());
}
if (resourceMetadata.isEmpty())
{
for (StoreMetadata meta : storeMap.values())
{
Query permissionQuery = buildPermissionQuery(meta, query, em);
}
}
else
{
List<Permission> results = new ArrayList<Permission>();
for (StoreMetadata meta : resourceMetadata.keySet())
{
Query permissionQuery = buildPermissionQuery(meta, query, em);
}
}
private Query buildPermissionQuery(StoreMetadata meta, PermissionQuery query, EntityManager em)
{
StringBuilder queryText = new StringBuilder();
queryText.append("SELECT P FROM ");
queryText.append(meta.getStoreClass().getName());
queryText.append(" P WHERE ");
if (query.getRecipient() != null)
{
queryText.append(meta.getAclRecipient().getName());
queryText.append(" = :RECIPIENT");
}
Query q = em.createQuery(queryText.toString())
.setParameter("RECIPIENT", query.getRecipient().getKey());
return q;
}
private class StoreMetadata
{
private Class<?> storeClass;
private Property<String> aclIdentifier;
private Property<?> aclPermission;
private Property<String> aclRecipient;
private Property<String> aclResourceClass;
public StoreMetadata(Class<?> storeClass)
{
this.storeClass = storeClass;
validateStore();
}
private void validateStore()
{
aclIdentifier = PropertyQueries.<String>createQuery(storeClass)
.addCriteria(new AnnotatedPropertyCriteria(ACLIdentifier.class))
.getFirstResult();
if (aclIdentifier == null)
{
" must have a field annotated @ACLIdentifier");
}
aclPermission = PropertyQueries.createQuery(storeClass)
.addCriteria(new AnnotatedPropertyCriteria(ACLPermission.class))
.getFirstResult();
if (aclPermission == null)
{
" must have a field annotated @ACLPermission");
}
aclRecipient = PropertyQueries.<String>createQuery(storeClass)
.addCriteria(new AnnotatedPropertyCriteria(ACLRecipient.class))
.getFirstResult();
if (aclRecipient == null)
{
" must have a field annotated @ACLRecipient");
}
aclResourceClass = PropertyQueries.<String>createQuery(storeClass)
.addCriteria(new AnnotatedPropertyCriteria(ACLResourceClass.class))
.getFirstResult();
}
public Class<?> getStoreClass()
{
return storeClass;
}
public Property<String> getAclIdentifier()
{
return aclIdentifier;
}
public Property<?> getAclPermission()
{
return aclPermission;
}
public Property<String> getAclRecipient()
{
return aclRecipient;
}
public Property<String> getAclResourceClass()
{
return aclResourceClass;
}
}
public Class<V> getJavaClass()
{
public void setValue(Object instance, V value)
{
public Class<?> getDeclaringClass()
{
public boolean isReadOnly()
{
public void setAccessible()
{
public String toString()
{
public int hashCode()
{
public boolean equals(Object obj)
{
Method getAnnotatedElement();
throw new IllegalArgumentException(
throw new IllegalArgumentException(
throw new IllegalArgumentException(
throw new IllegalArgumentException(
throw new IllegalArgumentException(
"Invalid accessor method, must return boolean primitive if starts with 'is'. Method: "
method);
throw new IllegalArgumentException(
if (propertyNameInAccessorMethod.length() == 0 ||
!Character.isUpperCase(propertyNameInAccessorMethod.charAt(0)))
public V getValue(Object instance)
{
if (getterMethod == null)
{
throw new UnsupportedOperationException("Property "
" cannot be read, as there is no getter method.");
if (setterMethod == null)
{
throw new UnsupportedOperationException("Property "
" is read only, as there is no setter method.");
if (Introspector.decapitalize(
methodName.substring(BOOLEAN_GETTER_METHOD_PREFIX_LENGTH)).equals(name))
}
else
throw new IllegalArgumentException("Cannot make a property of "
public class AnnotatedPropertyCriteria implements PropertyCriteria
{
public AnnotatedPropertyCriteria(Class<? extends Annotation> annotationClass)
{
public boolean fieldMatches(Field f)
{
public boolean methodMatches(Method m)
{
public class NamedPropertyCriteria implements PropertyCriteria
{
public NamedPropertyCriteria(String... propertyNames)
{
public boolean fieldMatches(Field f)
{
for (String propertyName : propertyNames)
{
if (propertyName.equals(f.getName()))
{
return true;
}
public boolean methodMatches(Method m)
{
for (String propertyName : propertyNames)
{
Introspector.decapitalize(m.getName().substring(3)).equals(propertyName))
{
return true;
}
public interface PropertyCriteria
{
public class PropertyQueries
{
private PropertyQueries()
{
public static <V> PropertyQuery<V> createQuery(Class<?> targetClass)
{
throw new RuntimeException(
"Expected one property match, but the criteria did not match any properties on "
targetClass.getName());
throw new RuntimeException(
"Expected one property match, but the criteria did not match any properties on "
targetClass.getName());
throw new RuntimeException("Expected one property match, but the criteria matched "
public class HierarchyDiscovery
{
public HierarchyDiscovery(Type type)
{
protected void add(Class<?> clazz, Type type)
{
public Set<Type> getTypeClosure()
{
if (types == null)
{
private void init()
{
try
{
}
catch (StackOverflowError e)
{
public Type getResolvedType()
{
if (type instanceof Class<?>)
{
private void discoverTypes(Type type)
{
if (type != null)
{
if (type instanceof Class<?>)
{
}
else
{
if (type instanceof ParameterizedType)
{
if (rawType instanceof Class<?>)
{
private Type resolveType(Class<?> clazz)
{
if (clazz.getTypeParameters().length > 0)
{
ParameterizedType parameterizedType = new ParameterizedTypeImpl(
clazz, actualTypeParameters, clazz.getDeclaringClass());
}
else
{
private void discoverFromClass(Class<?> clazz)
{
for (Type c : clazz.getGenericInterfaces())
{
private Type resolveType(Type beanType, Type beanType2, Type type)
{
if (type instanceof ParameterizedType)
{
if (beanType instanceof ParameterizedType)
{
if (beanType instanceof Class<?>)
{
if (type instanceof TypeVariable<?>)
{
if (beanType instanceof ParameterizedType)
{
if (beanType instanceof Class<?>)
{
private Type resolveParameterizedType(ParameterizedType beanType, ParameterizedType parameterizedType)
{
{
private Type resolveTypeParameter(ParameterizedType type, Type beanType, TypeVariable<?> typeVariable)
{
{
if (typeVariables[i].equals(typeVariable) && !actualTypes[i].equals(typeVariable))
{
if (!(resolvedGenericSuperType instanceof TypeVariable<?>))
{
if (beanType instanceof ParameterizedType)
{
for (Type interfaceType : ((Class<?>) ((ParameterizedType) beanType).getRawType()).getGenericInterfaces())
{
if (!(resolvedType instanceof TypeVariable<?>))
{
public class ParameterizedTypeImpl implements ParameterizedType
{
public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type ownerType)
{
public Type[] getActualTypeArguments()
{
public Type getOwnerType()
{
public Type getRawType()
{
public int hashCode()
{
return Arrays.hashCode(actualTypeArguments) ^ (ownerType == null ? 0 :
ownerType.hashCode()) ^ (rawType == null ? 0 : rawType.hashCode());
public boolean equals(Object obj)
{
if (this == obj)
{
}
else if (obj instanceof ParameterizedType)
{
return (ownerType == null ? thatOwnerType == null :
ownerType.equals(thatOwnerType)) && (rawType == null ? thatRawType == null :
rawType.equals(thatRawType)) && Arrays.equals(actualTypeArguments, that.getActualTypeArguments());
}
else
{
public String toString()
{
if (actualTypeArguments.length > 0)
{
for (Type actualType : actualTypeArguments)
{
private Reflections()
{
}
if (annotatedField.getDeclaringType().getJavaClass().equals(
field.getDeclaringClass()) && annotatedField.getJavaMember().getName().equals(field.getName()))
public static Set<Annotation> getAnnotationsWithMetaAnnotation(
Set<Annotation> annotations, Class<? extends Annotation> metaAnnotationType)
try
{
" using Class.forName or using any of the additional ClassLoaders: "
Arrays.toString(loaders));
StringBuilder message = new StringBuilder(
String.format("Exception invoking method [%s] on object [%s], using arguments [",
method.getName(), obj));
public static <T> T invokeMethod(boolean setAccessible, Method method,
Class<T> expectedReturnType, Object instance, Object... args)
ExceptionInInitializerError e2 = new ExceptionInInitializerError(
buildInvokeMethodErrorMessage(method, instance, args));
ExceptionInInitializerError e2 = new ExceptionInInitializerError(
buildSetFieldValueErrorMessage(field, instance, value));
ExceptionInInitializerError e2 = new ExceptionInInitializerError(
buildGetFieldValueErrorMessage(field, instance));
public static boolean isAssignableFrom(Class<?> rawType1, Type[] actualTypeArguments1,
Class<?> rawType2, Type[] actualTypeArguments2)
return Types.boxedClass(rawType1).isAssignableFrom(Types.boxedClass(rawType2)) &&
isAssignableFrom(actualTypeArguments1, actualTypeArguments2);
public static boolean matches(Class<?> rawType1, Type[] actualTypeArguments1,
Class<?> rawType2, Type[] actualTypeArguments2)
return Types.boxedClass(rawType1).equals(Types.boxedClass(rawType2)) &&
isAssignableFrom(actualTypeArguments1, actualTypeArguments2);
if (isAssignableFrom((Class<?>) parameterizedType1.getRawType(),
parameterizedType1.getActualTypeArguments(), type2))
if (type2 instanceof WildcardType)
{
if (matches((Class<?>) parameterizedType1.getRawType(),
parameterizedType1.getActualTypeArguments(), type2))
public class SetAccessiblePriviligedAction implements PrivilegedAction<Void>
{
public SetAccessiblePriviligedAction(AccessibleObject member)
{
public Void run()
{
private Types()
{
}
public static Type boxedType(Type type)
{
if (type instanceof Class<?>)
{
return boxedClass((Class<?>) type);
}
else
{
return type;
}
}
public static Class<?> boxedClass(Class<?> type)
{
if (!type.isPrimitive())
{
return type;
}
else if (type.equals(Boolean.TYPE))
{
return Boolean.class;
}
else if (type.equals(Character.TYPE))
{
return Character.class;
}
else if (type.equals(Byte.TYPE))
{
return Byte.class;
}
else if (type.equals(Short.TYPE))
{
return Short.class;
}
else if (type.equals(Integer.TYPE))
{
return Integer.class;
}
else if (type.equals(Long.TYPE))
{
return Long.class;
}
else if (type.equals(Float.TYPE))
{
return Float.class;
}
else if (type.equals(Double.TYPE))
{
return Double.class;
}
else if (type.equals(Void.TYPE))
{
return Void.class;
}
else
{
return type;
}
}
{
private InMemoryUserStorage() { }
import org.apache.deltaspike.security.api.credential.LoginCredentials;
private LoginCredentials loginCredential;
@Target({ TYPE, METHOD })
public boolean doSecuredCheck(@MockParamBinding MockObject obj, InvocationContext invocationContext)
throws Exception
@Target({ TYPE, METHOD })
private ArchiveUtils() { }
if (includeIfPackageExists == null)
{
try
{
for (ZipEntry jarEntry = jar.getNextEntry(); jarEntry != null; jarEntry = jar.getNextEntry())
{
if (jarEntry.isDirectory())
{
if (excludeIfPackageExists(entryName, excludeIfPackageExists))
{
if (ret == null && includeIfPackageExists(entryName, includeIfPackageExists))
{
if (entryName.endsWith(".class"))
{
else
{
finally
{
try
{
catch (IOException ignored)
{
throws IOException
{
if (!archiveBasePath.exists())
{
if (includeIfPackageExists == null)
{
for (File archiveEntry : collectArchiveEntries(archiveBasePath) )
{
if (excludeIfPackageExists(entryName, excludeIfPackageExists))
{
if (ret == null && includeIfPackageExists(entryName, includeIfPackageExists))
{
if (entryName.endsWith(".class"))
{
else
{
if (archiveBasePath.isDirectory())
{
for (File file : files)
{
if (file.isDirectory())
{
else
{
private static boolean excludeIfPackageExists(String jarEntryName, String[] excludeOnPackages)
{
if (excludeOnPackages != null)
{
for (String excludeOnPackage : excludeOnPackages)
{
if (packageName.startsWith(excludeOnPackage))
{
private static boolean includeIfPackageExists(String jarEntryName, String[] includeOnPackages)
{
if (includeOnPackages == null )
{
for (String includeOnPackage : includeOnPackages)
{
if (packageName.startsWith(includeOnPackage))
{
private static String isJarUrl(String urlPath)
{
if (urlPath.endsWith("!/") && jarColon > 0)
{
private static String ensureCorrectUrlFormat(String url)
{
if(!url.startsWith("file:/"))
{
private static String pathToClassName(String pathName)
{
import org.apache.deltaspike.security.api.credential.LoginCredentials;
import org.apache.deltaspike.security.impl.idm.SimpleUser;
private LoginCredentials credentials;
if ("shane".equals(credentials.getUserId()) &&
"password".equals(credentials.getCredential().getValue()))
setUser(new SimpleUser("shane"));
import java.io.Serializable;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import org.apache.deltaspike.security.api.permission.annotations.ACLStore;
@ACLStore
@Entity
public class ObjectPermission implements Serializable
{
private static final long serialVersionUID = 2386489292457994509L;
@Id @GeneratedValue
private Long id;
public Long getId()
{
return id;
}
public void setId(Long id)
{
this.id = id;
}
Class<?> value() default GENERAL.class;
static final class GENERAL
{ }
import org.apache.deltaspike.security.impl.extension.SecurityExtension;
package org.apache.deltaspike.security.impl.extension;
import org.apache.deltaspike.security.impl.authorization.Authorizer;
import org.apache.deltaspike.security.impl.authorization.SecurityInterceptorBinding;
import org.apache.deltaspike.security.impl.authorization.SecurityInterceptorBindingLiteral;
import org.apache.deltaspike.security.impl.authorization.SecurityMetaDataStorage;
import org.apache.deltaspike.security.impl.authorization.SecurityUtils;
import org.apache.deltaspike.security.impl.util.SecurityUtils;
package org.apache.deltaspike.security.impl.extension;
import org.apache.deltaspike.security.impl.authorization.SecurityParameterValueRedefiner;
import org.apache.deltaspike.security.impl.util.SecurityUtils;
package org.apache.deltaspike.security.impl.extension;
import org.apache.deltaspike.security.impl.util.SecurityUtils;
package org.apache.deltaspike.security.impl.extension;
package org.apache.deltaspike.security.impl.extension;
package org.apache.deltaspike.security.impl.extension;
package org.apache.deltaspike.security.impl.extension;
import org.apache.deltaspike.security.impl.util.SecurityUtils;
package org.apache.deltaspike.security.impl.util;
public abstract class SecurityUtils
public static boolean isMetaAnnotatedWithSecurityBindingType(Annotation annotation)
public static Annotation resolveSecurityBindingType(Annotation annotation)
public static List<Annotation> getAllAnnotations(Annotation[] annotations)
private InMemoryUserStorage()
{ }
private boolean value;
public MockObject(boolean value)
{
this.value = value;
}
public boolean isValue()
{
return value;
}
public void setValue(boolean value)
{
this.value = value;
}
@Target({ PARAMETER })
private ArchiveUtils()
{ }
private ShrinkWrapArchiveUtil()
{ }
"<class>org.apache.deltaspike.security.impl.extension.SecurityInterceptor</class>"
if (classLoader == null)
{
try
{
while (foundFiles.hasMoreElements())
{
JavaArchive archive = createArchive(foundFile, markerFile, includeIfPackageExists,
excludeIfPackageExists);
if (archive != null)
{
catch (IOException ioe)
{
throws IOException
{
final JavaArchive foundJar = ShrinkWrap.createFromZipFile(JavaArchive.class,
new File(URI.create(jarUrlPath)));
if (foundJar.contains(excludePackage.replaceAll("\\.", "\\/")))
{
String className = pathToClassName(
entryName.substring(0, entryName.length() - (".class".length())));
throws IOException
String className = pathToClassName(entryName.substring(0, entryName.length() - (".class".length())));
if (!url.startsWith("file:/"))
import org.apache.deltaspike.security.api.idm.SimpleUser;
import org.apache.deltaspike.security.api.permission.annotations.ACLIdentifier;
import org.apache.deltaspike.security.api.permission.annotations.ACLPermission;
import org.apache.deltaspike.security.api.permission.annotations.ACLRecipient;
@ACLIdentifier
private Long identifier;
@ACLRecipient
private String recipient;
@ACLPermission
private String permission;
public Long getIdentifier()
{
return identifier;
}
public void setIdentifier(Long identifier)
{
this.identifier = identifier;
}
public String getRecipient()
{
return recipient;
}
public void setRecipient(String recipient)
{
this.recipient = recipient;
}
public String getPermission()
{
return permission;
}
public void setPermission(String permission)
{
this.permission = permission;
}
import org.apache.deltaspike.security.api.permission.annotations.ACLIdentifier;
import org.apache.deltaspike.security.api.permission.annotations.ACLPermission;
import org.apache.deltaspike.security.api.permission.annotations.ACLRecipient;
@ACLIdentifier
private String identifier;
@ACLRecipient
private String recipient;
@ACLPermission
private String permission;
public String getIdentifier()
{
return identifier;
}
public void setIdentifier(String identifier)
{
this.identifier = identifier;
}
public String getRecipient()
{
return recipient;
}
public void setRecipient(String recipient)
{
this.recipient = recipient;
}
public String getPermission()
{
return permission;
}
public void setPermission(String permission)
{
this.permission = permission;
}
public String toString()
{
return String.format("%d: %s %s", id, firstName, lastName);
}
package org.apache.deltaspike.security.api.idm;
package org.apache.deltaspike.security.api.idm;
package org.apache.deltaspike.security.api.idm;
package org.apache.deltaspike.security.api.idm;
import org.apache.deltaspike.security.spi.permission.PermissionStore;
private PermissionStore permissionStore;
public PermissionQuery(PermissionStore permissionStore)
{
this.permissionStore = permissionStore;
}
public PermissionQuery setResource(Object resource)
return this;
public PermissionQuery setResources(Set<Object> resources)
return this;
public PermissionQuery setRange(Range range)
return this;
public PermissionQuery setRecipient(IdentityType recipient)
return this;
return permissionStore.getPermissions(this);
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import org.apache.deltaspike.security.spi.permission.PermissionStore;
@ApplicationScoped
@Inject
PermissionStore permissionStore;
PermissionQuery q = new PermissionQuery(permissionStore);
return q;
import org.apache.deltaspike.security.impl.permission.JPAPermissionStoreConfig.StoreMetadata;
public class JPAPermissionStore implements PermissionStore
{
@Inject
private JPAPermissionStoreConfig config;
StoreMetadata meta = (config.getStores().containsKey(resourceClass)) ?
config.getStores().get(resourceClass) : config.getGeneralStore();
StoreMetadata meta = (config.getStores().containsKey(resourceClass)) ?
config.getStores().get(resourceClass) : config.getGeneralStore();
for (StoreMetadata meta : config.getStores().values())
Map<String,Object> paramValues = new HashMap<String,Object>();
if (query.getResource() != null)
{
queryText.append(meta.getAclIdentifier().getName());
queryText.append(" = :IDENTIFIER");
paramValues.put("IDENTIFIER", null);
}
else if (query.getResources() != null)
{
}
queryText.append(" = :RECIPIENT");
paramValues.put("RECIPIENT", query.getRecipient().getKey());
Query q = em.createQuery(queryText.toString());
for (String param : paramValues.keySet())
{
q.setParameter(param, paramValues.get(param));
}
import javax.enterprise.context.SessionScoped;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
import javax.inject.Named;
EntityTransaction transaction = getTransaction(entityManager);
EntityTransaction transaction = getTransaction(em);
EntityTransaction transaction = getTransaction(em);
EntityTransaction transaction = getTransaction(em);
protected EntityTransaction getTransaction(EntityManager entityManager)
{
return entityManager.getTransaction();
}
if (System.getSecurityManager() != null)
{
AccessController.doPrivileged(new SetAccessiblePrivilegedAction(method));
}
else
{
method.setAccessible(true);
}
if (System.getSecurityManager() != null)
{
AccessController.doPrivileged(new SetAccessiblePrivilegedAction(field));
}
else
{
field.setAccessible(true);
}
if (System.getSecurityManager() != null)
{
AccessController.doPrivileged(new SetAccessiblePrivilegedAction(method));
}
else
{
method.setAccessible(true);
}
public static RuntimeException throwAsRuntimeException(Throwable throwable)
for (Class<? extends Annotation> emQualifier : emQualifiers)
EntityManager entityManager = resolveEntityManagerForQualifier(emQualifier);
transactionBeanStorage.storeUsedEntityManager(emQualifier, entityManager);
ems.add(entityManager);
prepareEntityManager(entityManager);
protected void prepareEntityManager(EntityManager entityManager)
{
}
boolean rollbackOnly = false;
if (!rollbackOnly && transaction.getRollbackOnly())
{
rollbackOnly = true;
}
if (rollbackOnly)
{
commitFailed = true;
}
transaction.rollback();
transaction.commit();
import org.apache.deltaspike.jpa.impl.transaction.context.EntityManagerEntry;
import org.apache.deltaspike.jpa.impl.transaction.context.JtaEntityManagerEntry;
import java.lang.annotation.Annotation;
protected static final String USER_TRANSACTION_JNDI_NAME = "java:comp/UserTransaction";
@Override
protected EntityManagerEntry createEntityManagerEntry(
EntityManager entityManager, Class<? extends Annotation> qualifier)
{
return new JtaEntityManagerEntry(entityManager, qualifier);
}
protected EntityTransaction getTransaction(EntityManagerEntry entityManagerEntry)
return new UserTransactionAdapter(entityManagerEntry.getEntityManager());
protected void beforeProceed(EntityManagerEntry entityManagerEntry)
entityManagerEntry.getEntityManager().joinTransaction();
import org.apache.deltaspike.jpa.impl.transaction.context.EntityManagerEntry;
EntityManagerEntry entityManagerEntry = createEntityManagerEntry(entityManager, emQualifier);
transactionBeanStorage.storeUsedEntityManager(entityManagerEntry);
EntityTransaction transaction = getTransaction(entityManagerEntry);
beforeProceed(entityManagerEntry);
Set<EntityManagerEntry> entityManagerEntryList =
transactionBeanStorage.getUsedEntityManagerEntries();
for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
Set<EntityManagerEntry> entityManagerEntryList =
transactionBeanStorage.getUsedEntityManagerEntries();
for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
currentEntityManagerEntry.getEntityManager().flush();
for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
onCloseTransactionScope();
protected EntityManagerEntry createEntityManagerEntry(
EntityManager entityManager, Class<? extends Annotation> qualifier)
{
return new EntityManagerEntry(entityManager, qualifier);
}
protected EntityTransaction getTransaction(EntityManagerEntry entityManagerEntry)
return entityManagerEntry.getEntityManager().getTransaction();
protected void beforeProceed(EntityManagerEntry entityManagerEntry)
protected void onCloseTransactionScope()
{
}
import java.util.HashSet;
import java.util.Set;
private Set<EntityManagerEntry> ems = new HashSet<EntityManagerEntry>();
public void storeUsedEntityManager(EntityManagerEntry entityManagerEntry)
currentTci.ems.add(entityManagerEntry);
public Set<EntityManagerEntry> getUsedEntityManagerEntries()
public interface TransactionStrategy extends InterceptorStrategy
public class AdvancedEnvironmentAwareTransactionStrategy extends EnvironmentAwareTransactionStrategy
Logger.getLogger(AdvancedEnvironmentAwareTransactionStrategy.class.getName());
public class BeanManagedUserTransactionTransactionStrategy extends ResourceLocalTransactionStrategy
public class EnvironmentAwareTransactionStrategy extends BeanManagedUserTransactionTransactionStrategy
Logger.getLogger(EnvironmentAwareTransactionStrategy.class.getName());
import org.apache.deltaspike.jpa.spi.TransactionStrategy;
public class ResourceLocalTransactionStrategy implements TransactionStrategy
private static final Logger LOGGER = Logger.getLogger(ResourceLocalTransactionStrategy.class.getName());
private TransactionStrategyHelper transactionHelper;
Transactional transactionalAnnotation = transactionHelper.extractTransactionalAnnotation(invocationContext);
Set<Class<? extends Annotation>> emQualifiers = transactionHelper.resolveEntityManagerQualifiers(
public class TransactionStrategyHelper implements Serializable
import org.apache.deltaspike.jpa.spi.TransactionStrategy;
private TransactionStrategy transactionStrategy;
return transactionStrategy.execute(invocationContext);
import org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder;
public class AdvancedEnvironmentAwareTransactionStrategy extends SimpleEnvironmentAwareTransactionStrategy
public class SimpleEnvironmentAwareTransactionStrategy extends BeanManagedUserTransactionTransactionStrategy
Logger.getLogger(SimpleEnvironmentAwareTransactionStrategy.class.getName());
public class EnvironmentAwareTransactionStrategy extends SimpleEnvironmentAwareTransactionStrategy
Logger.getLogger(EnvironmentAwareTransactionStrategy.class.getName());
private boolean isActivated = true;
private Boolean isActivated = true;
protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
isActivated = ClassDeactivationUtils.isActivated(getClass());
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
private Boolean isActivated = true;
private Boolean isGlobalAlternativeActivated = true;
private Boolean isCustomProjectStageBeanFilterActivated = true;
@SuppressWarnings("UnusedDeclaration")
protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
{
isActivated =
ClassDeactivationUtils.isActivated(getClass());
isGlobalAlternativeActivated =
ClassDeactivationUtils.isActivated(GlobalAlternative.class);
isCustomProjectStageBeanFilterActivated =
ClassDeactivationUtils.isActivated(CustomProjectStageBeanFilter.class);
}
private Boolean isActivated = true;
isActivated = ClassDeactivationUtils.isActivated(getClass());
private Boolean isActivated = true;
protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
isActivated = ClassDeactivationUtils.isActivated(getClass());
protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
{
isActivated = ClassDeactivationUtils.isActivated(getClass());
}
import org.apache.deltaspike.jpa.impl.transaction.context.JtaAwareEntityManagerEntry;
public class BeanManagedUserTransactionStrategy extends ResourceLocalTransactionStrategy
return new JtaAwareEntityManagerEntry(entityManager, qualifier);
import org.apache.deltaspike.jpa.impl.transaction.context.JtaAwareEntityManagerEntry;
return new JtaAwareEntityManagerEntry(entityManager, qualifier, isTransactionTypeJta);
import org.apache.deltaspike.jpa.impl.transaction.context.JtaAwareEntityManagerEntry;
public class SimpleEnvironmentAwareTransactionStrategy extends BeanManagedUserTransactionStrategy
return new JtaAwareEntityManagerEntry(entityManager, qualifier, false);
if (((JtaAwareEntityManagerEntry)entityManagerEntry).isTransactionTypeJta())
if (((JtaAwareEntityManagerEntry)entityManagerEntry).isTransactionTypeJta())
public class JtaAwareEntityManagerEntry extends EntityManagerEntry
public JtaAwareEntityManagerEntry(EntityManager entityManager, Class<? extends Annotation> qualifier)
public JtaAwareEntityManagerEntry(
import java.util.logging.Level;
import java.util.logging.Logger;
private static final Logger LOGGER = Logger.getLogger(BeanManagedUserTransactionStrategy.class.getName());
protected void applyTransactionTimeout()
{
Integer transactionTimeout = getDefaultTransactionTimeoutInSeconds();
if (transactionTimeout == null)
{
return;
}
try
{
UserTransaction userTransaction = resolveUserTransaction();
userTransaction.setTransactionTimeout(transactionTimeout);
}
catch (SystemException e)
{
LOGGER.log(Level.WARNING, "UserTransaction#setTransactionTimeout failed", e);
}
}
protected Integer getDefaultTransactionTimeoutInSeconds()
{
return null;
}
protected UserTransaction resolveUserTransaction()
{
return JndiUtils.lookup(USER_TRANSACTION_JNDI_NAME, UserTransaction.class);
}
this.userTransaction = resolveUserTransaction();
if (isTransactionTypeJta)
{
}
package org.apache.deltaspike.jpa.api.transaction;
package org.apache.deltaspike.jpa.api.transaction;
package org.apache.deltaspike.jpa.api.transaction;
package org.apache.deltaspike.jpa.spi.transaction;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy;
import org.apache.deltaspike.jpa.api.transaction.TransactionScoped;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.TransactionScoped;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import javax.persistence.EntityTransaction;
public class EnvironmentAwareTransactionStrategy extends BeanManagedUserTransactionStrategy
@Override
protected void beforeProceed(EntityManagerEntry entityManagerEntry)
{
if (((JtaAwareEntityManagerEntry)entityManagerEntry).isTransactionTypeJta())
{
super.beforeProceed(entityManagerEntry);
}
}
@Override
protected EntityTransaction getTransaction(EntityManagerEntry entityManagerEntry)
{
if (((JtaAwareEntityManagerEntry)entityManagerEntry).isTransactionTypeJta())
{
return super.getTransaction(entityManagerEntry);
}
return entityManagerEntry.getEntityManager().getTransaction();
}
beanStoreHolder.set(ProxyUtils.createProxy(BeanStore.class, new BeanStoreFilter(beanStore)));
import org.apache.deltaspike.core.impl.util.ProxyUtils;
import java.io.Serializable;
import static org.apache.deltaspike.core.util.ReflectionUtils.getRawType;
return ProxyUtils.createProxy(getRawType(injectionPoint.getType()), new MessageBundleInvocationHandler());
beanStoreHolder.set(new BeanStore()
{
@Override
public <T> ContextualInstance<T> get(String id)
{
return beanStore.get(id);
}
@Override
public boolean contains(String id)
{
return beanStore.contains(id);
}
@Override
public void clear()
{
}
@Override
public Iterator<String> iterator()
{
return beanStore.iterator();
}
@Override
public <T> void put(String id, ContextualInstance<T> contextualInstance)
{
beanStore.put(id, contextualInstance);
}
});
import static org.apache.deltaspike.core.util.ReflectionUtils.getRawType;
import java.io.Serializable;
import java.lang.reflect.Proxy;
import org.apache.deltaspike.core.util.ClassUtils;
return createMessageBundleProxy(getRawType(injectionPoint.getType()));
}
private <T> T createMessageBundleProxy(Class<T> type)
{
return type.cast(Proxy.newProxyInstance(ClassUtils.getClassLoader(null),
new Class<?>[]{type}, new MessageBundleInvocationHandler()));
return new UserTransactionAdapter();
public UserTransactionAdapter()
return super.createEntityManagerEntry(entityManager, qualifier);
return new EntityManagerEntry(entityManager, qualifier);
if (this.isJtaModeDetected.get())
if (this.isJtaModeDetected.get())
isTransactionTypeJta = isInJtaTransaction();
if (isInJtaTransaction())
if (isInJtaTransaction())
private static boolean isInJtaTransaction()
{
return Boolean.TRUE.equals(isJtaModeDetected.get());
}
import org.jboss.weld.context.AbstractSharedContext;
if (applicationContext instanceof AbstractSharedContext)
((AbstractSharedContext) applicationContext).getBeanStore().clear();
if (lifecycle == null)
return null;
lifecycle = WebBeansContext.currentInstance().getService(ContainerLifecycle.class);
Object mockServletContextEvent = null;
if (OpenWebBeansContextControl.isServletApiAvailable())
{
mockServletContextEvent = OwbHelper.getMockServletContextEvent();
}
lifecycle.startApplication(mockServletContextEvent);
Object mockServletContextEvent = null;
if (OpenWebBeansContextControl.isServletApiAvailable())
{
mockServletContextEvent = OwbHelper.getMockServletContextEvent();
}
lifecycle.stopApplication(mockServletContextEvent);
lifecycle = null;
import org.apache.webbeans.spi.ContextsService;
ContextsService contextsService = getContextsService();
startSingletonScope();
startApplicationScope();
startSessionScope();
startRequestScope();
startConversationScope();
static boolean isServletApiAvailable()
private void startSingletonScope()
ContextsService contextsService = getContextsService();
Object mockServletContext = null;
mockServletContext = OwbHelper.getMockServletContext();
contextsService.startContext(Singleton.class, mockServletContext);
}
private void startApplicationScope()
{
ContextsService contextsService = getContextsService();
Object mockServletContext = null;
if (isServletApiAvailable())
{
mockServletContext = OwbHelper.getMockServletContext();
}
contextsService.startContext(ApplicationScoped.class, mockServletContext);
ContextsService contextsService = getContextsService();
contextsService.startContext(SessionScoped.class, mockSession);
ContextsService contextsService = getContextsService();
contextsService.startContext(RequestScoped.class, null);
ContextsService contextsService = getContextsService();
contextsService.startContext(ConversationScoped.class, null);
ContextsService contextsService = getContextsService();
Object mockServletContext = null;
if (isServletApiAvailable())
mockServletContext = OwbHelper.getMockServletContext();
contextsService.endContext(Singleton.class, mockServletContext);
ContextsService contextsService = getContextsService();
Object mockServletContext = null;
if (isServletApiAvailable())
mockServletContext = OwbHelper.getMockServletContext();
contextsService.endContext(ApplicationScoped.class, mockServletContext);
ContextsService contextsService = getContextsService();
Object mockSession = null;
if (isServletApiAvailable())
mockSession = OwbHelper.getMockSession();
contextsService.endContext(SessionScoped.class, mockSession);
ContextsService contextsService = getContextsService();
contextsService.endContext(RequestScoped.class, null);
ContextsService contextsService = getContextsService();
contextsService.endContext(ConversationScoped.class, null);
private ContextsService getContextsService()
WebBeansContext webBeansContext = WebBeansContext.currentInstance();
return webBeansContext.getContextsService();
public static Object getMockServletContext()
{
return MockServletContext.getInstance();
}
public static boolean isServletApiAvailable()
{
try
{
Class servletClass = Class.forName("javax.servlet.http.HttpSession");
return servletClass != null;
}
catch (ClassNotFoundException e)
{
return false;
}
}
private static CdiContainer cdiContainer = null;
public static synchronized CdiContainer getCdiContainer()
if (cdiContainer == null)
{
ServiceLoader<CdiContainer> cdiContainerLoader = ServiceLoader.load(CdiContainer.class);
Iterator<CdiContainer> cdiIt = cdiContainerLoader.iterator();
if (cdiIt.hasNext())
{
cdiContainer = cdiIt.next();
}
else
{
" available in the classpath!");
}
if (cdiIt.hasNext())
{
String foundContainers = getContainerDetails();
}
return cdiContainer;
private Bean<ContextControl> ctxCtrlBean = null;
private CreationalContext<ContextControl> ctxCtrlCreationalContext = null;
if (weldContainer == null)
{
return null;
}
public synchronized void boot()
public synchronized  void shutdown()
if (ctxCtrl != null)
{
ctxCtrlBean.destroy(ctxCtrl, ctxCtrlCreationalContext);
}
weld = null;
ctxCtrl = null;
ctxCtrlBean = null;
ctxCtrlCreationalContext = null;
public synchronized ContextControl getContextControl()
ctxCtrlBean = (Bean<ContextControl>) getBeanManager().resolve(beans);
ctxCtrlCreationalContext = getBeanManager().createCreationalContext(ctxCtrlBean);
ctxCtrl = null;
ctxCtrlBean = null;
ctxCtrlCreationalContext = null;
beanManager = null;
Authorizer(Annotation bindingAnnotation, AnnotatedMethod<?> boundAuthorizerMethod)
void authorize(final InvocationContext ic, BeanManager beanManager)
lazyInitTargetBean(beanManager);
private synchronized void lazyInitTargetBean(BeanManager beanManager)
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
@Inject
private BeanManager beanManager;
authorizer.authorize(invocationContext, this.beanManager);
Authorizer authorizer = new Authorizer(binding, annotatedMethod);
boundAuthorizerBean = beanManager.resolve(beans);
if (boundAuthorizerBean == null)
registerAuthorizer(m);
private void registerAuthorizer(AnnotatedMethod<?> annotatedMethod)
public <X> void processAnnotatedType(@Observes ProcessAnnotatedType<X> event)
@SuppressWarnings({ "unchecked" })
@Inject
private SecurityExtension securityExtension;
SecurityMetaDataStorage metaDataStorage = securityExtension.getMetaDataStorage();
private SecurityMetaDataStorage securityMetaDataStorage;
securityMetaDataStorage = new SecurityMetaDataStorage();
public SecurityMetaDataStorage getMetaDataStorage()
private static Boolean isOwbDetected = false;
private boolean isActivated = true;
private boolean isGlobalAlternativeActivated = true;
private boolean isCustomProjectStageBeanFilterActivated = true;
isOwbDetected = isOpenWebBeans();
private boolean isOpenWebBeans()
IllegalStateException runtimeException = new IllegalStateException();
for (StackTraceElement element : runtimeException.getStackTrace())
if (element.toString().contains("org.apache.webbeans."))
return true;
return false;
protected boolean isTransactionAllowedToRollback() throws SystemException
return  this.userTransaction.getStatus() != Status.STATUS_COMMITTED &&
this.userTransaction.getStatus() != Status.STATUS_NO_TRANSACTION &&
this.userTransaction.getStatus() != Status.STATUS_UNKNOWN;
protected boolean isTransactionReadyToCommit() throws SystemException
public void verifyInjectionPoints(@Observes final AfterDeploymentValidation afterDeploymentValidation,
import java.io.Serializable;
public class ContextualInstanceInfo<T> implements Serializable
private T contextualInstance;
private CreationalContext<T> creationalContext;
public ContextualInstanceInfo(CreationalContext<T> creationalContext, T contextualInstance)
public CreationalContext<T> getCreationalContext()
return creationalContext;
public T getContextualInstance()
import javax.enterprise.context.ContextNotActiveException;
protected AbstractContext(Class<? extends Annotation> scope)
protected abstract ContextualStorage getContextualStorage();
public <T> T get(Contextual<T> bean)
checkActive();
if (getContextualStorage() == null)
{
return null;
}
Map<Contextual<?>, ContextualInstanceInfo<?>> contextMap = getContextualStorage().getStorage();
ContextualInstanceInfo<?> contextualInstanceInfo = contextMap.get(bean);
if (contextualInstanceInfo == null)
{
return null;
}
return (T) contextualInstanceInfo.getContextualInstance();
public <T> T get(Contextual<T> bean, CreationalContext<T> creationalContext)
checkActive();
ContextualStorage storage = getContextualStorage();
Map<Contextual<?>, ContextualInstanceInfo<?>> contextMap = storage.getStorage();
ContextualInstanceInfo<?> contextualInstanceInfo = contextMap.get(bean);
T instance = null;
if (contextualInstanceInfo != null)
{
instance =  (T) contextualInstanceInfo.getContextualInstance();
}
if (instance != null)
{
return instance;
}
return storage.createContextualInstance(bean, creationalContext);
ContextualInstanceInfo<?> contextualInstanceInfo = getContextualStorage().getStorage().get(bean);
Map<Contextual<?>, ContextualInstanceInfo<?>> storage = getContextualStorage().getStorage();
protected void checkActive()
{
if (!isActive())
{
throw new ContextNotActiveException("CDI context with scope annotation @"
}
}
public void setCreationalContext(CreationalContext<T> creationalContext)
{
this.creationalContext = creationalContext;
}
public void setContextualInstance(T contextualInstance)
{
this.contextualInstance = contextualInstance;
}
import javax.enterprise.context.spi.CreationalContext;
public boolean isConcurrent()
{
return concurrent;
}
public <T> T createContextualInstance(Contextual<T> bean, CreationalContext<T> creationalContext)
{
if (isConcurrent())
{
ContextualInstanceInfo<T> instanceInfo = new ContextualInstanceInfo<T>();
ConcurrentHashMap<Contextual<?>, ContextualInstanceInfo<?>> concurrentMap
= (ConcurrentHashMap<Contextual<?>, ContextualInstanceInfo<?>>) contextualInstances;
ContextualInstanceInfo<T> oldInstanceInfo
= (ContextualInstanceInfo<T>) concurrentMap.putIfAbsent(bean, instanceInfo);
if (oldInstanceInfo != null)
{
instanceInfo = oldInstanceInfo;
}
synchronized (instanceInfo)
{
T instance = instanceInfo.getContextualInstance();
if (instance == null)
{
instance = bean.create(creationalContext);
instanceInfo.setContextualInstance(instance);
instanceInfo.setCreationalContext(creationalContext);
}
return instance;
}
}
else
{
ContextualInstanceInfo<T> instanceInfo = new ContextualInstanceInfo<T>();
instanceInfo.setCreationalContext(creationalContext);
instanceInfo.setContextualInstance(bean.create(creationalContext));
contextualInstances.put(bean, instanceInfo);
return instanceInfo.getContextualInstance();
}
}
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.PassivationCapable;
private boolean isPassivatingScope;
protected AbstractContext(BeanManager beanManager)
isPassivatingScope = beanManager.isPassivatingScope(getScope());
protected abstract ContextualStorage getContextualStorage(boolean createIfNotExist);
ContextualStorage storage = getContextualStorage(false);
if (storage == null)
Map<Contextual<?>, ContextualInstanceInfo<?>> contextMap = storage.getStorage();
if (isPassivatingScope)
{
if (!(bean instanceof PassivationCapable))
{
throw new IllegalStateException(bean.toString()
}
}
ContextualStorage storage = getContextualStorage(true);
ContextualStorage storage = getContextualStorage(false);
if (storage == null)
{
return false;
}
ContextualInstanceInfo<?> contextualInstanceInfo = storage.getStorage().get(bean);
public void destroyAllActive()
ContextualStorage storage = getContextualStorage(false);
if (storage == null)
{
return;
}
Map<Contextual<?>, ContextualInstanceInfo<?>> contextMap = storage.getStorage();
for (Map.Entry<Contextual<?>, ContextualInstanceInfo<?>> entry : contextMap.entrySet())
import javax.enterprise.inject.spi.BeanManager;
public MockViewScopedContext(BeanManager beanManager)
{
super(beanManager);
}
import org.apache.deltaspike.core.util.context.AbstractContext;
import org.apache.deltaspike.core.util.context.ContextualStorage;
public class ViewScopedContext extends AbstractContext implements SystemEventListener
private static final String CONTEXTUAL_MAP_NAME = "deltaspike.contextualInstanceMap";
private BeanManager beanManager;
public ViewScopedContext(BeanManager beanManager)
super(beanManager);
this.beanManager = beanManager;
@Override
protected ContextualStorage getContextualStorage(boolean createIfNotExists)
{
Map<String, Object> viewMap = getViewMap();
ContextualStorage storage = (ContextualStorage) viewMap.get(CONTEXTUAL_MAP_NAME);
if (storage == null && createIfNotExists)
{
storage = new ContextualStorage(beanManager, false);
viewMap.put(CONTEXTUAL_MAP_NAME, storage);
}
return storage;
}
@Override
public <T> T get(Contextual<T> bean)
{
subscribeToJsf();
return super.get(bean);
}
public <T> T get(Contextual<T> bean, CreationalContext<T> creationalContext)
subscribeToJsf();
return super.get(bean, creationalContext);
private void subscribeToJsf()
if (!isJsfSubscribed)
FacesContext.getCurrentInstance().getApplication().subscribeToEvent(PreDestroyViewMapEvent.class, this);
isJsfSubscribed = true;
destroyAllActive();
import javax.enterprise.inject.spi.BeanManager;
public void registerViewContext(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
afterBeanDiscovery.addContext(new MockViewScopedContext(beanManager));
afterBeanDiscovery.addContext(new ViewScopedContext(beanManager));
afterBeanDiscovery.addContext(new ViewScopedContext(beanManager));
excludedFiles = new String[]{"META-INF.apache-deltaspike.properties"};
import org.apache.deltaspike.test.utils.ShrinkWrapArchiveUtil;
import org.apache.deltaspike.test.utils.ShrinkWrapArchiveUtil;
private ArchiveUtils()
{
}
import org.apache.deltaspike.test.utils.ShrinkWrapArchiveUtil;
{
}
package org.apache.deltaspike.test.utils;
{
}
if (classLoader == null)
try
while (foundFiles.hasMoreElements())
JavaArchive archive
= createArchive(foundFile, markerFile, includeIfPackageExists, excludeIfPackageExists);
if (archive != null)
catch (IOException ioe)
throws IOException
JavaArchive foundJar = ShrinkWrap.createFromZipFile(JavaArchive.class, new File(URI.create(jarUrlPath)));
if (foundJar.contains(excludePackage.replaceAll("\\.", "\\/")))
throws IOException
if (includeIfPackageExists == null)
try
for (ZipEntry jarEntry = jar.getNextEntry(); jarEntry != null; jarEntry = jar.getNextEntry())
if (jarEntry.isDirectory())
if (excludeIfPackageExists(entryName, excludeIfPackageExists))
if (ret == null && includeIfPackageExists(entryName, includeIfPackageExists))
if (entryName.endsWith(".class"))
String className
= pathToClassName(entryName.substring(0, entryName.length() - (".class".length())));
else
finally
try
catch (IOException ignored)
throws IOException
if (!archiveBasePath.exists())
if (includeIfPackageExists == null)
for (File archiveEntry : collectArchiveEntries(archiveBasePath) )
if (excludeIfPackageExists(entryName, excludeIfPackageExists))
if (ret == null && includeIfPackageExists(entryName, includeIfPackageExists))
if (entryName.endsWith(".class"))
String className
= pathToClassName(entryName.substring(0, entryName.length() - (".class".length())));
else
if (archiveBasePath.isDirectory())
for (File file : files)
if (file.isDirectory())
else
private static boolean excludeIfPackageExists(String jarEntryName, String[] excludeOnPackages)
if (excludeOnPackages != null)
for (String excludeOnPackage : excludeOnPackages)
private static boolean includeIfPackageExists(String jarEntryName, String[] includeOnPackages)
if (includeOnPackages == null )
for (String includeOnPackage : includeOnPackages)
if (packageName.startsWith(includeOnPackage))
private static String isJarUrl(String urlPath)
if (urlPath.endsWith("!/") && jarColon > 0)
private static String ensureCorrectUrlFormat(String url)
if (!url.startsWith("file:/"))
private static String pathToClassName(String pathName)
import javax.enterprise.inject.spi.BeanManager;
void notify(ExceptionEvent<T> event, BeanManager beanManager);
import org.apache.deltaspike.core.api.exception.control.HandlerMethod;
handler.notify(callbackEvent, beanManager);
handler.notify(depthFirstEvent, beanManager);
import org.apache.deltaspike.core.api.exception.control.HandlerMethod;
import org.apache.deltaspike.core.util.metadata.builder.ImmutableInjectionPoint;
import org.apache.deltaspike.core.util.metadata.builder.InjectableMethod;
private final Class declaringBeanClass;
private final Bean<?> declaringBean;
public HandlerMethodImpl(final Bean<?> handlerDeclaringBean, final AnnotatedMethod<?> method, final BeanManager bm)
declaringBean = handlerDeclaringBean;
declaringBeanClass = method.getJavaMember().getDeclaringClass();
public Bean<?> getDeclaringBean()
return declaringBean;
public void notify(final ExceptionEvent<T> event, BeanManager beanManager)
ctx = beanManager.createCreationalContext(null);
Object handlerInstance = BeanProvider.getContextualReference(declaringBeanClass);
InjectableMethod<?> im = createInjectableMethod(handler, getDeclaringBean(), beanManager);
private <X> InjectableMethod<X> createInjectableMethod(AnnotatedMethod<X> handlerMethod, Bean<?> bean,
BeanManager bm)
return new InjectableMethod<X>(handlerMethod, bean, bm);
public Set<InjectionPoint> getInjectionPoints(final BeanManager bm)
new ImmutableInjectionPoint(param, bm, getDeclaringBean(), false, false));
int result = declaringBeanClass.hashCode();
import org.apache.deltaspike.core.util.metadata.builder.ParameterValueRedefiner;
declaringBean = handlerMethod.getDeclaringBean();
import org.apache.deltaspike.core.api.exception.control.annotation.ExceptionHandler;
registerHandlerMethod(new HandlerMethodImpl(processBean.getBean(), method, beanManager));
final BeanManager bm)
for (InjectionPoint ip : ((HandlerMethodImpl<? extends Throwable>) handler).getInjectionPoints(bm))
bm.validate(ip);
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.apache.deltaspike.test.category.WebProfileCategory;
import org.jboss.arquillian.ajocado.framework.GrapheneSelenium;
import org.jboss.shrinkwrap.api.ShrinkWrap;
JavaArchive grapheneJar = ShrinkWrap
.create(JavaArchive.class, "graphene.jar")
.addPackage(GrapheneSelenium.class.getPackage())
.addPackage(WebProfileCategory.class.getPackage());
JavaArchive[] coreArchives = ShrinkWrapArchiveUtil.getArchives(null,
"META-INF/beans.xml",
new String[]{"org.apache.deltaspike.core", "org.apache.deltaspike.jsf"}, excludedFiles);
List<JavaArchive> archives = new ArrayList<JavaArchive>(Arrays.asList(coreArchives));
archives.add(grapheneJar);
return archives.toArray(new JavaArchive[archives.size()]);
private boolean passivatingScope;
passivatingScope = beanManager.isPassivatingScope(getScope());
public boolean isPassivatingScope()
{
return passivatingScope;
}
Map<Object, ContextualInstanceInfo<?>> contextMap = storage.getStorage();
ContextualInstanceInfo<?> contextualInstanceInfo = contextMap.get(storage.getBeanKey(bean));
if (passivatingScope)
Map<Object, ContextualInstanceInfo<?>> contextMap = storage.getStorage();
ContextualInstanceInfo<?> contextualInstanceInfo = contextMap.get(storage.getBeanKey(bean));
ContextualInstanceInfo<?> contextualInstanceInfo = storage.getStorage().get(storage.getBeanKey(bean));
Map<Object, ContextualInstanceInfo<?>> contextMap = storage.getStorage();
for (Map.Entry<Object, ContextualInstanceInfo<?>> entry : contextMap.entrySet())
Contextual bean = storage.getBean(entry.getKey());
private Map<Object, ContextualInstanceInfo<?>> contextualInstances;
private boolean passivationCapable;
public ContextualStorage(BeanManager beanManager, boolean concurrent, boolean passivationCapable)
this.passivationCapable = passivationCapable;
contextualInstances = new ConcurrentHashMap<Object, ContextualInstanceInfo<?>>();
contextualInstances = new HashMap<Object, ContextualInstanceInfo<?>>();
public Map<Object, ContextualInstanceInfo<?>> getStorage()
Object beanKey = getBeanKey(bean);
ConcurrentHashMap<Object, ContextualInstanceInfo<?>> concurrentMap
= (ConcurrentHashMap<Object, ContextualInstanceInfo<?>>) contextualInstances;
= (ContextualInstanceInfo<T>) concurrentMap.putIfAbsent(beanKey, instanceInfo);
contextualInstances.put(beanKey, instanceInfo);
public <T> Object getBeanKey(Contextual<T> bean)
{
if (passivationCapable)
{
return ((PassivationCapable) bean).getId();
}
return bean;
}
public Contextual<?> getBean(Object beanKey)
{
if (passivationCapable)
{
return beanManager.getPassivationCapableBean((String) beanKey);
}
else
{
return (Contextual<?>) beanKey;
}
}
storage = new ContextualStorage(beanManager, concurrent, isPassivatingScope());
storage = new ContextualStorage(beanManager, false, isPassivatingScope());
package org.apache.deltaspike.test.jsf.impl.util;
.create(JavaArchive.class, "deltaspikeUtils.jar")
.addClass(ArchiveUtils.class)
.addPackages(true, "org.jboss.arquillian.graphene")
.addPackages(true, "org.jboss.arquillian.ajocado")
JavaArchive[] coreArchives = ShrinkWrapArchiveUtil.getArchives(null
, "META-INF/beans.xml"
, new String[]{ "org.apache.deltaspike.core"
, "org.apache.deltaspike.jsf" }
, excludedFiles);
.addPackages(true, "org.openqa.selenium")
String toString(String category);
String toString(MessageContext messageContext, String category);
return toString((String) null);
}
@Override
public String toString(String category)
{
return toString(messageContext, null);
}
@Override
public String toString(MessageContext messageContext, String category)
{
.toString(category);
continue;
ok = false;
String getMessage(MessageContext messageContext, String messageTemplate, String category);
String resolvedTemplate = messageResolver.getMessage(messageContext, template, category);
public String getMessage(MessageContext messageContext, String messageTemplate, String category)
if (category != null && category.length() > 0)
{
try
{
}
catch (MissingResourceException e)
{
messageBundle.getString(resourceKey);
}
}
javaArchive.addAsResource(archiveEntry, entryName.replace('\\', '/'));
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.apache.deltaspike.test.category.WebProfileCategory;
import org.apache.deltaspike.test.core.api.context.DummyContext;
import org.apache.deltaspike.test.core.api.context.DummyScopeExtension;
import org.apache.deltaspike.test.core.api.context.DummyScoped;
import org.jboss.shrinkwrap.api.ShrinkWrap;
JavaArchive extensionsJar = ShrinkWrap
.create(JavaArchive.class, "testExtensions.jar")
.addClass(ArchiveUtils.class)
.addClass(DummyScopeExtension.class)
.addClass(DummyScoped.class)
.addClass(DummyContext.class)
.addPackage(WebProfileCategory.class.getPackage());
JavaArchive[] coreArchives = ShrinkWrapArchiveUtil.getArchives(null,
List<JavaArchive> archives = new ArrayList<JavaArchive>(Arrays.asList(coreArchives));
archives.add(extensionsJar);
return archives.toArray(new JavaArchive[archives.size()]);
T get();
public class MessageBundleInvocationHandler implements InvocationHandler, Serializable
import org.apache.deltaspike.core.util.ReflectionUtils;
return createMessageBundleProxy(ReflectionUtils.getRawType(injectionPoint.getType()));
import java.io.Serializable;
public interface JsfMessage<T> extends Serializable
String CATEGORY_DETAIL = "detail";
String CATEGORY_SUMMARY = "summary";
JsfMessage<T> forClientId(String clientId);
import javax.faces.application.FacesMessage;
import java.lang.reflect.Proxy;
import org.apache.deltaspike.core.api.message.annotation.MessageBundle;
import org.apache.deltaspike.core.util.ClassUtils;
private String clientId = null;
private Class<T> type;
public DefaultJsfMessage(Class<T> type, String clientId)
{
this.type = type;
this.clientId = clientId;
if (! type.isInterface() || type.getAnnotation(MessageBundle.class) == null)
{
throw new IllegalArgumentException("JsfMessage must only be used for interfaces "
"annotated with @MessageBundle!");
}
}
@Override
public JsfMessage<T> forClientId(String clientId)
{
return new DefaultJsfMessage<T>(type, clientId);
}
return getMessage(FacesMessage.SEVERITY_ERROR);
return getMessage(FacesMessage.SEVERITY_FATAL);
return getMessage(FacesMessage.SEVERITY_INFO);
return getMessage(FacesMessage.SEVERITY_WARN);
return getMessage(null);
private T getMessage(FacesMessage.Severity severity)
{
return type.cast(Proxy.newProxyInstance(ClassUtils.getClassLoader(null),
new Class<?>[]{type}, new JsfMessageBundleInvocationHandler(severity, clientId)));
}
import javax.faces.component.UIComponent;
JsfMessage<T> forComponent(UIComponent uiComponent);
import javax.faces.component.UIComponent;
public JsfMessage<T> forComponent(UIComponent uiComponent)
{
return forClientId(uiComponent.getClientId());
}
@Override
public JsfMessage createJsfMessage(InjectionPoint injectionPoint)
private JsfMessage createJsfMessageFor(InjectionPoint injectionPoint, Class<Object> rawType)
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
if (! (injectionPoint.getType() instanceof ParameterizedType))
{
throw new IllegalArgumentException("JsfMessage must be used as generic type");
}
ParameterizedType paramType = (ParameterizedType) injectionPoint.getType();
Type[] actualTypes = paramType.getActualTypeArguments();
if (actualTypes.length != 1)
{
throw new IllegalArgumentException("JsfMessage must have the MessageBundle as generic type parameter");
}
return createJsfMessageFor(injectionPoint, actualTypes[0]);
private JsfMessage createJsfMessageFor(InjectionPoint injectionPoint, Type rawType)
return new DefaultJsfMessage((Class) rawType, null);
public class ViewScopedBackingBean implements Serializable
Locale result = null;
result = viewRoot.getLocale();
}
if (result == null)
{
result = facesContext.getApplication().getDefaultLocale();
}
if (result != null)
{
return result;
Locale locale = messageContext.getLocale();
return messageBundle.getString(resourceKey);
private String locale = "en";
public String getLocale()
{
return locale;
}
public void setLocale(String locale)
{
this.locale = locale;
}
package org.apache.deltaspike.jsf.api.message;
import org.apache.deltaspike.jsf.api.message.JsfMessage;
import org.apache.deltaspike.jsf.api.message.JsfMessage;
import org.apache.deltaspike.jsf.api.message.JsfMessage;
import org.apache.deltaspike.jsf.api.message.JsfMessage;
private volatile Bean<?> boundAuthorizerBean;
private volatile InjectableMethod<?> boundAuthorizerMethodProxy;
import java.io.Serializable;
import java.util.Arrays;
public final class Annotateds
private static final char SEPARATOR = ';';
private Annotateds()
{
}
private static class AnnotatedCallableComparator<T>
implements Comparator<AnnotatedCallable<? super T>>, Serializable
private static class AnnotatedMethodComparator<T>
implements Comparator<AnnotatedMethod<? super T>>, Serializable
private static class AnnotatedConstructorComparator<T>
implements Comparator<AnnotatedConstructor<? super T>>, Serializable
private static class AnnotatedFieldComparator<T>
implements Comparator<AnnotatedField<? super T>>, Serializable
private static class AnnotationComparator implements Comparator<Annotation>, Serializable
builder.append(SEPARATOR);
builder.append(SEPARATOR);
builder.append(SEPARATOR);
methods.addAll(Arrays.asList(declaredMethods));
import org.apache.deltaspike.core.api.config.view.metadata.annotation.DefaultCallback;
@DefaultCallback
import org.apache.deltaspike.core.api.config.view.metadata.annotation.DefaultCallback;
import org.apache.deltaspike.core.api.config.view.metadata.annotation.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.CallbackDescriptor;
import org.apache.deltaspike.core.spi.config.view.ConfigPreProcessor;
import org.apache.deltaspike.core.spi.config.view.ViewConfigNode;
import org.apache.deltaspike.security.api.authorization.SecurityViolation;
import java.lang.annotation.Annotation;
import java.util.Set;
@ViewMetaData(preProcessor = Secured.SecuredConfigPreProcessor.class)
class SecuredConfigPreProcessor implements ConfigPreProcessor<Secured>
{
@Override
public Secured beforeAddToConfig(Secured metaData, ViewConfigNode viewConfigNode)
{
viewConfigNode.registerCallbackDescriptors(Secured.class,
new SecuredDescriptor(metaData.value(), DefaultCallback.class));
}
}
static class SecuredDescriptor extends CallbackDescriptor<Set<SecurityViolation>>
{
public SecuredDescriptor(Class[] beanClasses, Class<? extends Annotation> callbackMarker)
{
super(beanClasses, callbackMarker);
}
}
boolean isActivated()
{
return isActivated;
}
boolean isTransformed()
{
return transformed;
}
ViewConfigResolver getViewConfigResolver()
{
return viewConfigResolver;
}
public interface WindowContext
String getCurrentWindowId();
void activateWindowContext(String windowId);
boolean closeCurrentWindowContext();
void closeAllWindowContexts();
if (message instanceof Message)
{
return message;
}
Object setAttribute(String name, Object value);
void destroy();
destroyAllActive(storage);
}
public void destroyAllActive(ContextualStorage storage)
{
import org.apache.deltaspike.core.api.config.view.View;
import org.apache.deltaspike.jsf.api.literal.PageBeanLiteral;
protected void buildViewConfigMetaDataTree(@Observes ProcessAnnotatedType pat)
if (ViewConfig.class.isAssignableFrom(pat.getAnnotatedType().getJavaClass()))
{
addPageDefinition(pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations());
pat.veto();
}
else
{
addIndirectlyInheritedMetaData(
pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations());
}
}
public void addIndirectlyInheritedMetaData(Class configClass)
{
addIndirectlyInheritedMetaData(
configClass, new HashSet<Annotation>(Arrays.asList(configClass.getAnnotations())));
}
protected void addIndirectlyInheritedMetaData(Class configClass, Set<Annotation> annotations)
{
for (Annotation annotation : annotations)
{
if (annotation.annotationType().equals(View.class))
{
for (Class<? extends ViewConfig> viewConfigRef : ((View) annotation).config())
{
ViewConfigNode viewConfigNode = findNode(viewConfigRef);
if (viewConfigNode == null)
{
addPageDefinition(viewConfigRef);
viewConfigNode = findNode(viewConfigRef);
if (viewConfigNode == null)
{
}
}
viewConfigNode.getInheritedMetaData().add(new PageBeanLiteral(configClass, null));
}
break;
}
}
ViewConfigRoot viewConfigRoot = (ViewConfigRoot) annotation;
.getConstructor(new Class[]{
ViewConfigNode.class, ConfigNodeConverter.class, ViewConfigInheritanceStrategy.class});
import org.apache.deltaspike.core.api.config.view.View;
@View(config = SimplePageConfig.class)
Map<String, Class<? extends ViewConfig>> foundViewIds = new HashMap<String, Class<? extends ViewConfig>>();
if (foundViewIds.containsKey(currentViewConfigDescriptor.getViewId()))
{
foundViewIds.get(currentViewConfigDescriptor.getViewId()).getName());
}
else
{
foundViewIds.put(
currentViewConfigDescriptor.getViewId(), currentViewConfigDescriptor.getViewConfig());
}
if (this.defaultErrorView == null)
else if (DefaultErrorView.class.isAssignableFrom(currentViewConfigDescriptor.getViewConfig()))
{
throw new IllegalStateException("It isn't allowed to configure multiple default-error-views. "
currentViewConfigDescriptor.getViewConfig().getName());
}
if (DefaultErrorView.class.equals(viewDefinitionClass))
{
return getDefaultErrorViewConfigDescriptor();
}
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
import org.apache.deltaspike.core.api.config.view.ViewConfig;
@Nonbinding
Class<? extends ViewConfig> errorView() default DefaultErrorView.class;
Map<String, ContextualStorage> oldWindowContextStorages = windowBeanHolder.forceNewStorage();
for (ContextualStorage contextualStorage : oldWindowContextStorages.values())
public Map<String, ContextualStorage> forceNewStorage()
package org.apache.deltaspike.test.core.api.util.context;
package org.apache.deltaspike.test.core.api.util.context;
package org.apache.deltaspike.test.core.api.util.context;
package org.apache.deltaspike.test.core.api.util.context;
import org.apache.deltaspike.test.core.api.util.context.DummyContext;
import org.apache.deltaspike.test.core.api.util.context.DummyScopeExtension;
import org.apache.deltaspike.test.core.api.util.context.DummyScoped;
@Secures
@CustomSecurityBinding
public boolean doSecuredCheck(@MockParamBinding MockObject2 obj)
{
return obj.isValue();
}
import javax.enterprise.inject.spi.AnnotatedParameter;
private Set<AuthorizationParameter> authorizationParameters = new HashSet<AuthorizationParameter>();
for (AnnotatedParameter<?> annotatedParameter : boundAuthorizerMethod.getParameters())
{
Set<Annotation> securityParameterBindings = null;
for (Annotation annotation : annotatedParameter.getAnnotations())
{
if (SecurityUtils.isMetaAnnotatedWithSecurityParameterBinding(annotation))
{
if (securityParameterBindings == null)
{
securityParameterBindings = new HashSet<Annotation>();
}
securityParameterBindings.add(annotation);
}
}
if (securityParameterBindings != null)
{
AuthorizationParameter authorizationParameter
= new AuthorizationParameter(annotatedParameter.getBaseType(), securityParameterBindings);
authorizationParameters.add(authorizationParameter);
}
}
boolean matchesBindings(Annotation annotation, Set<AuthorizationParameter> parameterBindings)
for (AuthorizationParameter authorizationParameter : authorizationParameters)
{
boolean found = false;
for (AuthorizationParameter parameterBinding : parameterBindings)
{
if (parameterBinding.matches(authorizationParameter))
{
found = true;
}
}
if (!found)
{
return false;
}
}
import java.util.Collections;
if (auth.matchesBindings(annotation, Collections.<AuthorizationParameter> emptySet()))
Set<AuthorizationParameter> parameterBindings = new HashSet<AuthorizationParameter>();
Class<?>[] parameterTypes = targetMethod.getParameterTypes();
Annotation[][] parameterAnnotations = targetMethod.getParameterAnnotations();
{
Set<Annotation> securityBindings = null;
for (final Annotation parameterAnnotation : parameterAnnotations[i])
{
if (SecurityUtils.isMetaAnnotatedWithSecurityParameterBinding(parameterAnnotation))
{
if (securityBindings == null)
{
securityBindings = new HashSet<Annotation>();
}
securityBindings.add(parameterAnnotation);
}
}
if (securityBindings != null)
{
parameterBindings.add(new AuthorizationParameter(parameterTypes[i], securityBindings));
}
}
if (authorizer.matchesBindings(binding, parameterBindings))
if (a.matchesBindings(binding, parameterBindings))
import org.apache.deltaspike.security.api.authorization.annotation.SecurityParameterBinding;
public static boolean isMetaAnnotatedWithSecurityParameterBinding(Annotation annotation)
{
if (annotation.annotationType().isAnnotationPresent(SecurityParameterBinding.class))
{
return true;
}
List<Annotation> result = getAllAnnotations(annotation.annotationType().getAnnotations());
for (Annotation foundAnnotation : result)
{
if (SecurityParameterBinding.class.isAssignableFrom(foundAnnotation.annotationType()))
{
return true;
}
}
return false;
}
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.enterprise.inject.spi.AnnotatedParameter;
getMetaDataStorage().addSecuredType(type);
getMetaDataStorage().addSecuredMethod(m);
metaDataStorage.registerSecuredMethods();
for (final AnnotatedMethod<?> method : metaDataStorage.getSecuredMethods())
Class<?> targetClass = method.getDeclaringType().getJavaClass();
Method targetMethod = method.getJavaMember();
for (final Annotation annotation : SecurityUtils.getSecurityBindingTypes(targetClass, targetMethod))
Set<AuthorizationParameter> authorizationParameters = new HashSet<AuthorizationParameter>();
for (AnnotatedParameter<?> parameter : (List<AnnotatedParameter<?>>) (List<?>) method.getParameters())
Set<Annotation> securityParameterBindings = null;
for (Annotation a : parameter.getAnnotations())
if (SecurityUtils.isMetaAnnotatedWithSecurityParameterBinding(a))
if (securityParameterBindings == null)
{
securityParameterBindings = new HashSet<Annotation>();
}
securityParameterBindings.add(a);
if (securityParameterBindings != null)
{
AuthorizationParameter authorizationParameter
= new AuthorizationParameter(parameter.getBaseType(), securityParameterBindings);
authorizationParameters.add(authorizationParameter);
}
}
for (Authorizer auth : metaDataStorage.getAuthorizers())
{
if (auth.matchesBindings(annotation, authorizationParameters))
{
found = true;
break;
}
}
if (!found)
{
event.addDefinitionError(new SecurityDefinitionException("Secured type "
method.getDeclaringType().getJavaClass().getName()
" has no matching authorizer method for security binding @"
annotation.annotationType().getName()));
for (final Annotation annotation : method.getAnnotations())
if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
metaDataStorage.registerSecuredMethod(targetClass, targetMethod);
break;
metaDataStorage.resetSecuredMethods();
import javax.enterprise.inject.spi.AnnotatedMethod;
import javax.enterprise.inject.spi.AnnotatedType;
private Set<AnnotatedMethod<?>> securedMethods = new HashSet<AnnotatedMethod<?>>();
for (AnnotatedMethod<?> securedMethod : annotatedType.getMethods())
{
addSecuredMethod(securedMethod);
}
void addSecuredMethod(AnnotatedMethod<?> annotatedMethod)
securedMethods.add(annotatedMethod);
Set<AnnotatedMethod<?>> getSecuredMethods()
return securedMethods;
}
void resetSecuredMethods()
{
securedMethods = null;
void registerSecuredMethods()
{
for (AnnotatedMethod<?> method : securedMethods)
{
registerSecuredMethod(method.getDeclaringType().getJavaClass(), method.getJavaMember());
}
}
synchronized <T> void registerSecuredMethod(Class<T> targetClass, Method targetMethod)
for (Annotation binding : SecurityUtils.getSecurityBindingTypes(targetClass, targetMethod))
import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.Set;
public static Set<Annotation> getSecurityBindingTypes(Class<?> targetClass, Method targetMethod)
{
Set<Annotation> securityBindingTypes = new HashSet<Annotation>();
Class<?> cls = targetClass;
while (!cls.equals(Object.class))
{
for (final Annotation annotation : cls.getAnnotations())
{
if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
{
securityBindingTypes.add(annotation);
}
}
cls = cls.getSuperclass();
}
for (final Annotation annotation : targetMethod.getAnnotations())
{
if (SecurityUtils.isMetaAnnotatedWithSecurityBindingType(annotation))
{
securityBindingTypes.add(annotation);
}
}
return securityBindingTypes;
}
public boolean getResult(@MockParamBinding MockObject mockObject)
public boolean getResult(@MockParamBinding MockObject2 mockObject)
package org.apache.deltaspike.core.impl.jmx;
package org.apache.deltaspike.core.impl.jmx;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import javax.enterprise.inject.spi.*;
public class MBeanExtension implements Extension, Deactivatable
private Boolean isActivated = true;
protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
isActivated = ClassDeactivationUtils.isActivated(getClass());
}
protected void processBean(@Observes final ProcessManagedBean<?> bean, final BeanManager bm) throws Exception
{
if (!isActivated)
{
return;
}
protected void shutdown(@Observes final BeforeShutdown shutdown) throws Exception
if (!isActivated)
{
return;
}
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.TYPE;
@Target({ CONSTRUCTOR, FIELD, METHOD, PARAMETER, TYPE })
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
@Retention(RUNTIME)
@Target(TYPE)
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
@Retention(RUNTIME)
@Target(METHOD)
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
@Retention(RUNTIME)
@Target(METHOD)
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
@Target(TYPE)
@Retention(RUNTIME)
@Target(TYPE)
@Retention(RUNTIME)
static @interface List
{
NotificationInfo[] value();
}
final NotificationInfo.List notifications = annotatedMBean.getAnnotation(NotificationInfo.List.class);
import org.apache.deltaspike.core.api.config.ConfigResolver;
final String description =
getDescription(annotatedMBean.getAnnotation(Description.class), annotatedMBean.getName());
notificationInfos.add(getNotificationInfo(notification, annotatedMBean.getName()));
if (notifications != null)
for (NotificationInfo notificationInfo : notifications.value())
notificationInfos.add(getNotificationInfo(notificationInfo, annotatedMBean.getName()));
for (Method method : annotatedMBean.getMethods())
final int modifiers = method.getModifiers();
if (method.getDeclaringClass().equals(Object.class)
if (method.getAnnotation(ManagedAttribute.class) != null)
final String methodName = method.getName();
if (isAccessor(method))
getters.put(attrName, method);
setters.put(attrName, method);
else if (method.getAnnotation(ManagedOperation.class) != null)
operations.put(method.getName(), method);
String operationDescr = getDescription(method.getAnnotation(Description.class),
operationInfos.add(new MBeanOperationInfo(operationDescr, method));
for (Map.Entry<String, Method> methodEntry : getters.entrySet())
final String key = methodEntry.getKey();
final Method method = methodEntry.getValue();
String attrDescr = getDescription(method.getAnnotation(Description.class),
attributeInfos.add(new MBeanAttributeInfo(key, attrDescr, method, setters.get(key)));
private MBeanNotificationInfo getNotificationInfo(final NotificationInfo n, String sourceInfo)
n.notificationClass().getName(), getDescription(n.description(), sourceInfo),
private String getDescription(final Description description, String defaultDescription)
if (description == null)
return defaultDescription;
String descriptionValue = description.value().trim();
if (descriptionValue.startsWith("{") && descriptionValue.endsWith("}"))
{
if (description.annotationType().getEnclosingMethod() != null)
{
defaultDescription = description.annotationType().getEnclosingMethod().getName();
}
else if (description.annotationType().getEnclosingClass() != null)
{
defaultDescription = description.annotationType().getEnclosingClass().getName();
}
return ConfigResolver.getPropertyValue(
descriptionValue.substring(1, descriptionValue.length() - 1), defaultDescription);
}
return description.value();
if (description == null || "".equals(description.value()))
@Target({ FIELD, METHOD, TYPE })
public @interface JmxDescription
import static java.lang.annotation.ElementType.FIELD;
@Target({ FIELD, METHOD })
public @interface JmxManaged
JmxDescription description() default @JmxDescription("");
import org.apache.deltaspike.core.api.jmx.annotation.JmxDescription;
import org.apache.deltaspike.core.api.jmx.annotation.JmxManaged;
import java.lang.reflect.Field;
private final Map<String, FieldInfo> fields = new HashMap<String, FieldInfo>();
getDescription(annotatedMBean.getAnnotation(JmxDescription.class), annotatedMBean.getName());
|| Modifier.isAbstract(modifiers)
|| Modifier.isStatic(modifiers)
|| method.getAnnotation(JmxManaged.class) == null)
operations.put(method.getName(), method);
String operationDescr = getDescription(method.getAnnotation(JmxDescription.class),
operationInfos.add(new MBeanOperationInfo(operationDescr, method));
Class<?> clazz = annotatedMBean;
while (!Object.class.equals(clazz) && clazz != null) {
for (Field field : clazz.getDeclaredFields()) {
final JmxManaged annotation = field.getAnnotation(JmxManaged.class);
if (annotation != null) {
field.setAccessible(true);
final String name = field.getName();
final String fieldDescription = getDescription(field.getAnnotation(JmxDescription.class),
final Class<?> type = field.getType();
final String javaMtdName;
if (name.length() > 1) {
} else {
}
Method setter = null;
Method getter = null;
try {
} catch (NoSuchMethodException e1) {
} catch (NoSuchMethodException e2) {
}
}
try {
} catch (NoSuchMethodException e) {
}
attributeInfos.add(new MBeanAttributeInfo(name, type.getName(),
fieldDescription, getter != null, setter != null, false));
fields.put(name, new FieldInfo(field, getter, setter));
}
clazz = clazz.getSuperclass();
private String getDescription(final JmxDescription description, String defaultDescription)
if (fields.containsKey(attribute))
return fields.get(attribute).get(instance());
if (fields.containsKey(attribute.getName()))
fields.get(attribute.getName()).set(instance(), attribute.getValue());
} finally
String description() default "";
String description() default "";
String description() default "";
import org.apache.deltaspike.core.api.jmx.annotation.MBean;
getDescription(annotatedMBean.getAnnotation(MBean.class).description(), annotatedMBean.getName());
final JmxManaged annotation = method.getAnnotation(JmxManaged.class);
|| annotation == null)
String operationDescr = getDescription(annotation.description(),
final String fieldDescription = getDescription(annotation.description(),
private String getDescription(final String description, String defaultDescription)
if (description.isEmpty())
String descriptionValue = description.trim();
return description;
public DynamicMBeanWrapper(final Class<?> annotatedMBean,
final boolean normalScope,
final Annotation[] qualifiers,
final MBean mBeanAnnotation)
getDescription(mBeanAnnotation.description(), annotatedMBean.getName());
while (!Object.class.equals(clazz) && clazz != null)
{
for (Field field : clazz.getDeclaredFields())
{
if (annotation != null)
{
if (name.length() > 1)
{
}
else
{
try
{
}
catch (NoSuchMethodException e1)
{
try
}
catch (NoSuchMethodException e2)
{
try
{
}
catch (NoSuchMethodException e)
{
private MBeanNotificationInfo getNotificationInfo(final NotificationInfo notificationInfo, String sourceInfo)
return new MBeanNotificationInfo(
notificationInfo.types(),
notificationInfo.notificationClass().getName(),
getDescription(notificationInfo.description(), sourceInfo),
new ImmutableDescriptor(notificationInfo.descriptorFields()));
}
finally
public class FieldInfo
{
if (getter == null)
{
if (setter == null)
{
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import javax.enterprise.inject.spi.BeforeShutdown;
import javax.enterprise.inject.spi.Extension;
import javax.enterprise.inject.spi.ProcessManagedBean;
MBean mBeanAnnotation = bean.getAnnotated().getAnnotation(MBean.class);
if (mBeanAnnotation != null)
registerObject(bean, mBeanAnnotation, bm);
private void registerObject(final ProcessManagedBean<?> bean,
final MBean mBeanAnnotation,
final BeanManager bm) throws Exception
String on = mBeanAnnotation.objectName();
boolean normalScoped = isNormalScope(bean.getAnnotated().getAnnotations(), bm);
Annotation[] qualifiers = qualifiers(bean.getAnnotatedBeanClass(), bm);
mBeanServer().registerMBean(
new DynamicMBeanWrapper(clazz, normalScoped, qualifiers, mBeanAnnotation), objectName);
objectNames.add(objectName);
private boolean isNormalScope(final Set<Annotation> annotations, final BeanManager bm)
import org.apache.deltaspike.core.api.jmx.JmxBroadcaster;
import javax.management.Notification;
import javax.management.NotificationBroadcasterSupport;
public class DynamicMBeanWrapper extends NotificationBroadcasterSupport implements DynamicMBean, JmxBroadcaster
fields.put(name, new FieldInfo(getter, setter));
@Override
public void send(final Notification notification)
{
sendNotification(notification);
}
public FieldInfo(final Method get, final Method set)
import org.apache.deltaspike.core.util.BeanUtils;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
private final Map<Class<?>, DynamicMBeanWrapper> wrappers = new ConcurrentHashMap<Class<?>, DynamicMBeanWrapper>();
final boolean normalScoped = isNormalScope(bean.getAnnotated().getAnnotations(), bm);
final Annotation[] qualifiers = qualifiers(bean.getAnnotatedBeanClass(), bm);
final DynamicMBeanWrapper mbean = new DynamicMBeanWrapper(clazz, normalScoped, qualifiers, mBeanAnnotation);
mBeanServer().registerMBean(mbean, objectName);
wrappers.put(clazz, mbean);
mBeanServer().registerMBean(mbean, objectName);
final Set<Annotation> qualifiers = BeanUtils.getQualifiers(bm, annotatedBeanClass.getAnnotations());
public DynamicMBeanWrapper getWrapperFor(final Class<?> clazz)
{
return wrappers.get(clazz);
}
String operationDescr = getDescription(annotation.description(), method.getName());
final String fieldName = field.getName();
final String fieldDescription = getDescription(annotation.description(), fieldName);
final String methodName;
if (fieldName.length() > 1)
{
attributeInfos.add(new MBeanAttributeInfo(
fieldName, type.getName(), fieldDescription, getter != null, setter != null, false));
fields.put(fieldName, new FieldInfo(getter, setter));
public class AttributeAccessor
public AttributeAccessor(final Method get, final Method set)
import javax.enterprise.context.Dependent;
@Dependent
private final Map<String, AttributeAccessor> fields = new HashMap<String, AttributeAccessor>();
fields.put(fieldName, new AttributeAccessor(getter, setter));
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
public JmxBroadcaster jmxBroadcaster(final InjectionPoint ip)
final JmxBroadcaster broadcaster = extension.getBroadcasterFor(declaringClass);
if (broadcaster == null)
return broadcaster;
import org.apache.deltaspike.core.api.jmx.JmxBroadcaster;
public JmxBroadcaster getBroadcasterFor(final Class<?> clazz)
import org.apache.deltaspike.core.api.jmx.annotation.MBean;
MBean.class.getName());
JmxBroadcaster getBroadcasterFor(final Class<?> clazz)
String category() default "org.apache.deltaspike";
String name() default "";
String objectNameValue = mBeanAnnotation.objectName();
if (objectNameValue.isEmpty())
String name = mBeanAnnotation.name();
if (name.isEmpty())
{
name = clazz.getName();
}
final ObjectName objectName = new ObjectName(objectNameValue);
String category() default "{org.apache.deltaspike.mbean.category}";
import org.apache.deltaspike.core.api.config.ConfigResolver;
String category = mBeanAnnotation.category().trim();
if (category.startsWith("{") && category.endsWith("}"))
{
category = ConfigResolver.getPropertyValue(
category.substring(1, category.length() - 1), "org.apache.deltaspike");
}
final Annotation[] qualifiers)
getDescription(annotatedMBean.getAnnotation(MBean.class).description(), annotatedMBean.getName());
final DynamicMBeanWrapper mbean = new DynamicMBeanWrapper(clazz, normalScoped, qualifiers);
import org.apache.deltaspike.core.api.literal.AnyLiteral;
if (lhs.getExceptionType().equals(rhs.getExceptionType()) && lhs.getQualifiers().equals(rhs.getQualifiers()))
final int precedenceReturnValue = comparePrecedence(lhs.getOrdinal(), rhs.getOrdinal(),
if (precedenceReturnValue == 0)
return precedenceReturnValue;
if (lhs.getExceptionType().equals(rhs.getExceptionType())
&& !lhs.getQualifiers().equals(rhs.getQualifiers()))
{
if (lhs.getQualifiers().contains(new AnyLiteral()))
{
}
return 1;
}
private int comparePrecedence(final int lhs, final int rhs, final boolean isLhsBefore)
if (!isLhsBefore)
public Method getJavaMethod()
{
return handler.getJavaMember();
}
if (!handlerQualifiers.isEmpty() && handlerQualifiers.equals(handler.getQualifiers()))
if (!handlerQualifiers.isEmpty() && handlerQualifiers.equals(handler.getQualifiers()))
public void npeHandlerNoDefQualifier(@Handles ExceptionEvent<NullPointerException> event)
{
}
public void npeHandlerDefQualifier(@Handles @CatchQualifier ExceptionEvent<NullPointerException> event)
{
}
import org.apache.deltaspike.security.api.authorization.annotation.SecuredReturn;
private Object result;
public SecurityParameterValueRedefiner(CreationalContext<?> creationalContext,
InvocationContext invocation,
Object result)
this.invocation = invocation;
this.result = result;
else if (value.getInjectionPoint().getAnnotated().isAnnotationPresent(SecuredReturn.class))
{
return result;
}
import org.apache.deltaspike.security.api.authorization.annotation.SecuredReturn;
private Class<?> securedReturnType;
private volatile AnnotatedMethod<?> boundAuthorizerMethod;
Class<?> securedReturnType = null;
if (annotation.annotationType().equals(SecuredReturn.class))
{
securedReturnType
= boundAuthorizerMethod.getJavaMember().getParameterTypes()[annotatedParameter.getPosition()];
}
if (securityParameterBindings != null && securedReturnType != null)
{
StringBuilder errorMessage = new StringBuilder();
errorMessage.append("@SecurityParameterBinding annotations must not occure ");
errorMessage.append("at the same parameter with @Result annotation, but parameter ");
errorMessage.append(annotatedParameter.getPosition()).append(" of method ");
errorMessage.append(boundAuthorizerMethod.getJavaMember()).append(" is annotated with @Result and ");
boolean first = true;
for (Annotation securityParameterBinding : securityParameterBindings)
{
if (first)
{
first = false;
}
else
{
errorMessage.append(" and ");
}
errorMessage.append(securityParameterBinding);
}
if (securityParameterBindings.size() == 1)
{
errorMessage.append(", which is a @SecurityParameterBinding annotation");
}
else
{
errorMessage.append(", which are @SecurityParameterBinding annotations");
}
throw new SecurityDefinitionException(errorMessage.toString());
}
else if (securityParameterBindings != null)
else if (securedReturnType != null)
{
if (this.securedReturnType != null
&& !this.securedReturnType.equals(securedReturnType))
{
throw new SecurityDefinitionException("More than one parameter of "
boundAuthorizerMethod.getJavaMember()
" is annotated with @Result");
}
this.securedReturnType = securedReturnType;
}
boolean isBeforeMethodInvocationAuthorizer()
{
return securedReturnType == null;
}
boolean isAfterMethodInvocationAuthorizer()
{
return securedReturnType != null;
}
void authorize(final InvocationContext ic, final Object returnValue, BeanManager beanManager)
new SecurityParameterValueRedefiner(creationalContext, ic, returnValue));
boolean matchesBindings(Annotation annotation, Set<AuthorizationParameter> parameterBindings, Class<?> returnType)
if (!matches(returnType))
{
return false;
}
private boolean matches(Class<?> returnType)
{
if (securedReturnType == null)
{
return true;
}
if (securedReturnType.isAssignableFrom(returnType))
{
return true;
}
if (securedReturnType.equals(Void.class) && returnType.equals(Void.TYPE))
{
return true;
}
return false;
}
if (authorizer.isBeforeMethodInvocationAuthorizer())
{
authorizer.authorize(invocationContext, null, this.beanManager);
}
Object result = invocationContext.proceed();
for (Authorizer authorizer : metaDataStorage.getAuthorizers(invocationContext.getTarget().getClass(), method))
{
if (authorizer.isAfterMethodInvocationAuthorizer())
{
authorizer.authorize(invocationContext, result, this.beanManager);
}
}
return result;
if (auth.matchesBindings(annotation, authorizationParameters, targetMethod.getReturnType()))
if (authorizer.matchesBindings(binding, parameterBindings, targetMethod.getReturnType()))
if (a.matchesBindings(binding, parameterBindings, targetMethod.getReturnType()))
import org.apache.deltaspike.security.api.authorization.annotation.SecuredReturn;
@Secures
@CustomSecurityBinding
public boolean doSecuredCheckAfterMethodInvocation(@SecuredReturn MockObject obj)
{
return obj.isValue();
}
@Secures
@CustomSecurityBinding
public boolean doSecuredCheckAfterMethodInvocationWithVoidMethod(@SecuredReturn Void result) {
return false;
}
public MockObject getResult(boolean value) {
return new MockObject(value);
}
@CustomSecurityBinding
public void securityCheckAfterMethodInvocation(MethodInvocationParameter parameter) {
parameter.setMethodInvoked(true);
}
@CustomSecurityBinding
public Void securityCheckAfterMethodInvocationWithVoidResult(MethodInvocationParameter parameter) {
parameter.setMethodInvoked(true);
return null;
}
H handlerInstance = (H) ((PartialBeanMethodHandler)((ProxyObject) instance).getHandler()).getHandlerInstance();
this.handlerInjectionTarget.preDestroy(handlerInstance);
private boolean intercepted;
}
public void setIntercepted(boolean intercepted)
{
this.intercepted = intercepted;
private String value;
import javax.enterprise.context.NormalScope;
import java.util.Set;
public <X> void findInvocationHandlerBindings(@Observes ProcessAnnotatedType<X> pat, BeanManager beanManager)
validateInvocationHandler(
beanClass, bindingAnnotationClass, pat.getAnnotatedType().getAnnotations(), beanManager);
protected <X> void validateInvocationHandler(Class<X> beanClass,
Class<? extends Annotation> bindingAnnotationClass,
Set<Annotation> annotations,
BeanManager beanManager)
for (Annotation annotation : annotations)
{
if (beanManager.isNormalScope(annotation.annotationType()))
{
return;
}
}
import org.apache.deltaspike.core.api.provider.BeanProvider;
private final Class<H> handlerClass;
this.handlerClass = handlerClass;
H handlerInstance = BeanProvider.getContextualReference(this.handlerClass);
import javax.enterprise.context.RequestScoped;
@RequestScoped
public abstract class CallbackDescriptor
protected List<CallbackEntry> callbacks = new ArrayList<CallbackEntry>();
protected Class<? extends Annotation> callbackType;
protected static class CallbackEntry
public List<Method> getCallbackMethods()
{
return callbackMethods;
}
public Class getTargetBeanClass()
{
return targetBeanClass;
}
CallbackDescriptor getCallbackDescriptor(Class<? extends Annotation> metaDataType);
<T extends ExecutableCallbackDescriptor> T getExecutableCallbackDescriptor(Class<? extends Annotation> metaDataType,
Class<? extends T> executorType);
<T extends ExecutableCallbackDescriptor> T getExecutableCallbackDescriptor(Class<? extends Annotation> metaDataType,
Class<? extends Annotation> callbackType,
Class<? extends T> executorType);
import org.apache.deltaspike.core.api.config.view.metadata.SimpleCallbackDescriptor;
private class ViewControllerDescriptor extends SimpleCallbackDescriptor<Void>
protected ViewControllerDescriptor(Class beanClass, Class<? extends Annotation> callbackType)
super(beanClass, callbackType);
import org.apache.deltaspike.core.api.config.view.metadata.ExecutableCallbackDescriptor;
public CallbackDescriptor getCallbackDescriptor(Class<? extends Annotation> metaDataType)
return getCallbackDescriptor(metaDataType, DefaultCallback.class);
public CallbackDescriptor getCallbackDescriptor(Class<? extends Annotation> metaDataType,
Class<? extends Annotation> callbackType)
{
return findCallbackDescriptor(metaDataType, callbackType);
}
@Override
public <T extends ExecutableCallbackDescriptor> T getExecutableCallbackDescriptor(
Class<? extends Annotation> metaDataType,
Class<? extends T> executorType)
{
return getExecutableCallbackDescriptor(metaDataType, DefaultCallback.class, executorType);
}
@Override
public <T extends ExecutableCallbackDescriptor> T getExecutableCallbackDescriptor(
Class<? extends Annotation> metaDataType,
Class<? extends Annotation> callbackType,
Class<? extends T> executorType)
{
return findCallbackDescriptor(metaDataType, callbackType);
}
private <T extends CallbackDescriptor> T findCallbackDescriptor(Class<? extends Annotation> metaDataType,
Class<? extends Annotation> callbackType)
import org.apache.deltaspike.core.api.config.view.metadata.ExecutableCallbackDescriptor;
import org.apache.deltaspike.security.api.authorization.AccessDecisionVoterContext;
import java.util.List;
viewConfigNode.registerCallbackDescriptors(Secured.class, new SecuredDescriptor(metaData.value()));
static class SecuredDescriptor extends ExecutableCallbackDescriptor<Set<SecurityViolation>>
public SecuredDescriptor(Class<? extends AccessDecisionVoter>[] accessDecisionVoterBeanClasses)
super(accessDecisionVoterBeanClasses, DefaultCallback.class);
}
public List<Set<SecurityViolation>> execute(AccessDecisionVoterContext accessDecisionVoterContext)
{
return super.execute(accessDecisionVoterContext);
import org.apache.deltaspike.core.api.config.view.metadata.ViewConfigResolver;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.jsf.api.navigation.PageParameterContext;
import javax.faces.context.ExternalContext;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
public static Set<RequestParameter> getViewConfigPageParameters()
{
ExternalContext externalContext = FacesContext.getCurrentInstance().getExternalContext();
Set<RequestParameter> result = new HashSet<RequestParameter>();
externalContext.getRequestParameterValuesMap() == null || externalContext.getRequest() == null)
{
return result;
}
PageParameterContext pageParameterContext = BeanProvider.getContextualReference(PageParameterContext.class);
for (Map.Entry<String, String> entry : pageParameterContext.getPageParameters().entrySet())
{
result.add(new RequestParameter(entry.getKey(), new String[]{entry.getValue()}));
}
return result;
}
public static String addPageParameters(ExternalContext externalContext, String url, boolean encodeValues)
{
StringBuilder finalUrl = new StringBuilder(url);
boolean existingParameters = url.contains("?");
for (RequestParameter requestParam : getViewConfigPageParameters())
{
String key = requestParam.getKey();
for (String parameterValue : requestParam.getValues())
{
{
if (!existingParameters)
{
finalUrl.append("?");
existingParameters = true;
}
else
{
finalUrl.append("&");
}
finalUrl.append(key);
finalUrl.append("=");
if (encodeValues)
{
finalUrl.append(JsfUtils.encodeURLParameterValue(parameterValue, externalContext));
}
else
{
finalUrl.append(parameterValue);
}
}
}
}
return finalUrl.toString();
}
public static String encodeURLParameterValue(String value, ExternalContext externalContext)
{
try
{
return URLEncoder.encode(value, externalContext.getResponseCharacterEncoding());
}
catch (UnsupportedEncodingException e)
{
throw new UnsupportedOperationException("Encoding type="
}
}
public static ViewConfigResolver getViewConfigResolver()
{
return BeanProvider.getContextualReference(ViewConfigResolver.class);
}
import java.util.HashSet;
String name() default ".";
@Override
public String toString()
{
return this.viewId;
}
import org.apache.deltaspike.core.api.config.view.metadata.ConfigDescriptor;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
ConfigDescriptor configDescriptor = this.viewConfigResolver.getViewConfigDescriptor(viewId);
Stack<ConfigDescriptor> configDescriptorStack = new Stack<ConfigDescriptor>();
if (configDescriptor != null)
{
configDescriptorStack.push(configDescriptor);
}
List<String> parentPathList = new ArrayList<String>();
createPathList(viewId, parentPathList);
List<ConfigDescriptor> folderConfigDescriptors = this.viewConfigResolver.getConfigDescriptors();
for (String path : parentPathList)
{
for (ConfigDescriptor pathDescriptor : folderConfigDescriptors)
{
if (path.equals(pathDescriptor.toString()))
{
configDescriptorStack.push(pathDescriptor);
break;
}
}
}
for (ConfigDescriptor currentConfigDescriptor : configDescriptorStack)
{
SecurityUtils.invokeVoters(this.accessDecisionVoterContext, currentConfigDescriptor);
}
}
private void createPathList(String currentPath, List<String> pathList)
{
if (!currentPath.contains("/"))
{
return;
}
String parentFolder = currentPath.substring(0, currentPath.lastIndexOf("/"));
createPathList(parentFolder, pathList);
import org.apache.deltaspike.core.api.config.view.metadata.ConfigDescriptor;
ConfigDescriptor viewConfigDescriptor)
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
public static JavaArchive[] getDeltaSpikeSecurityArchive()
String[] excludedFiles;
excludedFiles = new String[]{"META-INF.apache-deltaspike.properties"};
return ShrinkWrapArchiveUtil.getArchives(null,
"META-INF/beans.xml",
new String[]{"org.apache.deltaspike.security"}, excludedFiles);
void notify(ExceptionEvent<T> event, BeanManager beanManager) throws Exception;
import java.lang.reflect.InvocationTargetException;
throws InvocationTargetException, IllegalAccessException, IllegalArgumentException
import java.lang.reflect.InvocationTargetException;
throws InvocationTargetException, IllegalAccessException, IllegalArgumentException
throws InvocationTargetException, IllegalAccessException, IllegalArgumentException
public void notify(final ExceptionEvent<T> event, BeanManager beanManager) throws Exception
import org.apache.deltaspike.core.util.ExceptionUtils;
throws InvocationTargetException, IllegalAccessException, IllegalArgumentException
Object result = null;
try
{
result = boundAuthorizerMethodProxy.invoke(reference, creationalContext,
new SecurityParameterValueRedefiner(creationalContext, ic, returnValue));
}
catch (InvocationTargetException e)
{
ExceptionUtils.throwAsRuntimeException(e.getCause());
}
if (Boolean.FALSE.equals(result))
Object... args) throws IllegalAccessException, IllegalArgumentException
catch (InvocationTargetException e)
{
ExceptionUtils.throwAsRuntimeException(e.getCause());
return null;
}
throws IllegalAccessException, IllegalArgumentException
throws IllegalAccessException, IllegalArgumentException
throws IllegalAccessException, IllegalArgumentException
Object result = boundAuthorizerMethodProxy.invoke(reference, creationalContext,
new SecurityParameterValueRedefiner(creationalContext, ic, returnValue));
ConfigDescriptor getConfigDescriptor(String path);
private Map<String, ConfigDescriptor> folderPathToViewDefinitionEntryMapping;
initCaches();
public ConfigDescriptor getConfigDescriptor(String path)
{
if (path == null)
{
return null;
}
ConfigDescriptor result = this.folderPathToViewDefinitionEntryMapping.get(path);
if (result == null)
{
}
return result;
}
@Override
return this.viewIdToViewDefinitionEntryMapping.get(viewId);
protected void initCaches()
{
Map<String, ConfigDescriptor> folderPathMapping = new HashMap<String, ConfigDescriptor>();
for (ConfigDescriptor configDescriptor : this.folderDefinitionToViewDefinitionEntryMapping.values())
{
if (folderPathMapping.containsKey(configDescriptor.toString()))
{
throw new IllegalStateException("Duplicated config for the same folder configured. See: "
folderPathMapping.get(
configDescriptor.toString()).getConfigClass().getName()
}
folderPathMapping.put(configDescriptor.toString(), configDescriptor);
}
this.folderPathToViewDefinitionEntryMapping = Collections.unmodifiableMap(folderPathMapping);
for (ViewConfigDescriptor viewConfigDescriptor : this.viewDefinitionToViewDefinitionEntryMapping.values())
{
if (viewIdToViewDefinitionEntryMapping.containsKey(viewConfigDescriptor.getViewId()))
{
throw new IllegalStateException("Duplicated config for the same page configured. See: "
viewIdToViewDefinitionEntryMapping.get(
viewConfigDescriptor.getViewId()).getConfigClass().getName()
}
this.viewIdToViewDefinitionEntryMapping.put(viewConfigDescriptor.getViewId(), viewConfigDescriptor);
}
}
ConfigDescriptor pathDescriptor;
pathDescriptor = this.viewConfigResolver.getConfigDescriptor(path);
if (pathDescriptor != null)
configDescriptorStack.push(pathDescriptor);
if (isBeforeHandler() != that.isBeforeHandler())
{
return false;
}
if (isAlternativeBeanImplementation && alternativeBeanClass.equals(currentBean))
if (isAlternativeBeanImplementation && alternativeBeanClass.equals(currentBean))
import java.util.concurrent.ConcurrentMap;
private final Map<Object, ContextualInstanceInfo<?>> contextualInstances;
private final BeanManager beanManager;
private final boolean concurrent;
private final boolean passivationCapable;
ConcurrentMap<Object, ContextualInstanceInfo<?>> concurrentMap
private final boolean passivatingScope;
@SuppressWarnings("unchecked")
final T instance =  (T) contextualInstanceInfo.getContextualInstance();
if (instance != null)
{
return instance;
}
private static Boolean isWeldDetected = false;
isWeldDetected = isWeld();
if (isWeldDetected)
private boolean isWeld()
if (element.toString().contains("org.jboss.weld"))
TransactionBeanStorage transactionBeanStorage = TransactionBeanStorage.getInstance();
TransactionBeanStorage.close();
private static ThreadLocal<TransactionBeanStorage> transactionBeanStorage =
new ThreadLocal<TransactionBeanStorage>();
private TransactionBeanStorage()
{
}
public static TransactionBeanStorage getInstance()
{
TransactionBeanStorage result = transactionBeanStorage.get();
if (result == null)
{
result = new TransactionBeanStorage();
transactionBeanStorage.set(result);
}
return result;
}
public static void close()
{
TransactionBeanStorage currentStorage = transactionBeanStorage.get();
if (currentStorage != null)
{
currentStorage.endAllTransactionScopes();
transactionBeanStorage.set(null);
transactionBeanStorage.remove();
}
}
public static boolean isOpen()
{
return transactionBeanStorage.get() != null;
}
Map<Contextual, TransactionBeanEntry> transactionBeanEntryMap =
TransactionBeanStorage.getInstance().getActiveTransactionContext();
TransactionBeanStorage.close();
Map<Contextual, TransactionBeanEntry> transactionBeanEntryMap =
TransactionBeanStorage.getInstance().getActiveTransactionContext();
TransactionBeanStorage.close();
return TransactionBeanStorage.isOpen() &&
TransactionBeanStorage.getInstance().getActiveTransactionContext() != null;
return this.handlerInstance.invoke(target, method, arguments);
import org.apache.deltaspike.security.spi.authorization.EditableAccessDecisionVoterContext;
import java.util.logging.Logger;
private Boolean securityModuleActivated;
if (this.securityModuleActivated == null)
{
lazyInit();
}
if (!this.securityModuleActivated)
{
return;
}
private synchronized void lazyInit()
{
this.securityModuleActivated =
BeanProvider.getContextualReference(EditableAccessDecisionVoterContext.class, true) != null;
if (!this.securityModuleActivated)
{
"#checkSecuredView gets deactivated");
}
}
import org.apache.deltaspike.security.spi.authorization.EditableAccessDecisionVoterContext;
import java.util.logging.Logger;
private Boolean securityModuleActivated;
if (this.securityModuleActivated == null)
{
lazyInit();
}
if (!this.securityModuleActivated)
{
return result;
}
private synchronized void lazyInit()
{
this.securityModuleActivated =
BeanProvider.getContextualReference(EditableAccessDecisionVoterContext.class, true) != null;
if (!this.securityModuleActivated)
{
}
}
import org.apache.deltaspike.core.api.provider.BeanProvider;
EditableAccessDecisionVoterContext accessDecisionVoterContext =
BeanProvider.getContextualReference(EditableAccessDecisionVoterContext.class, false);
SecurityUtils.invokeVoters(accessDecisionVoterContext, currentConfigDescriptor);
public @interface NavigationParameter
@Nonbinding NavigationParameter[] value();
import org.apache.deltaspike.jsf.api.config.view.NavigationParameter;
NavigationParameter navigationParameter = viewConfigClass.getAnnotation(NavigationParameter.class);
if (navigationParameter != null)
addConfiguredPageParameter(navigationParameter);
NavigationParameter.List pageParameterList =
viewConfigClass.getAnnotation(NavigationParameter.List.class);
for (NavigationParameter currentNavigationParameter : pageParameterList.value())
addConfiguredPageParameter(currentNavigationParameter);
private void addConfiguredPageParameter(NavigationParameter viewParameter)
import org.apache.deltaspike.jsf.api.config.view.NavigationParameter;
@NavigationParameter(key = "param1", value = "staticMarker")
@NavigationParameter.List({
@NavigationParameter(key = "param1", value = "staticMarker1"),
@NavigationParameter(key = "param2", value = "staticMarker2")
import org.apache.deltaspike.jsf.api.config.view.NavigationParameter;
@NavigationParameter(key = "param1", value = "#{pageBean003.nextValue}")
import org.apache.deltaspike.jsf.api.config.view.NavigationParameter;
@NavigationParameter(key = "param1", value = "staticValue2")
@NavigationParameter.List({
@NavigationParameter(key = "param1", value = "staticValue2"),
@NavigationParameter(key = "param2", value = "#{pageBean005.currentValue}")
public interface NavigationParameterContext
import org.apache.deltaspike.jsf.api.navigation.NavigationParameterContext;
public class DefaultNavigationParameterContext implements NavigationParameterContext
protected DefaultNavigationParameterContext()
import org.apache.deltaspike.jsf.api.navigation.NavigationParameterContext;
private NavigationParameterContext navigationParameterContext;
if (this.navigationParameterContext != null)
this.navigationParameterContext.addPageParameter(viewParameter.key(), viewParameter.value());
this.navigationParameterContext =
BeanProvider.getContextualReference(NavigationParameterContext.class);
import org.apache.deltaspike.jsf.api.navigation.NavigationParameterContext;
NavigationParameterContext navigationParameterContext =
BeanProvider.getContextualReference(NavigationParameterContext.class);
for (Map.Entry<String, String> entry : navigationParameterContext.getPageParameters().entrySet())
import org.apache.deltaspike.jsf.api.navigation.NavigationParameterContext;
private NavigationParameterContext navigationParameterContext;
Class<? extends ViewConfig>[] value() default ViewRef.Manual.class;
public @interface ViewRef
import org.apache.deltaspike.core.api.config.view.ViewRef;
if (annotation.annotationType().equals(ViewRef.class))
for (Class<? extends ViewConfig> viewConfigRef : ((ViewRef) annotation).config())
import org.apache.deltaspike.core.api.config.view.ViewRef;
@ViewRef(config = SimplePageConfig.class)
import org.apache.deltaspike.jsf.api.literal.ViewLiteral;
import static org.apache.deltaspike.jsf.api.config.view.View.Extension.XHTML;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.FORWARD;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.EXCLUDE;
@ViewMetaData(preProcessor = View.ViewConfigPreProcessor.class)
public @interface View
static class ViewConfigPreProcessor implements ConfigPreProcessor<View>
public View beforeAddToConfig(View view, ViewConfigNode viewConfigNode)
String basePath = view.basePath();
String name = view.name();
String extension = view.extension();
View.NavigationMode navigation = view.navigation();
View.ViewParameterMode viewParams = view.viewParams();
if (View.Extension.DEFAULT.equals(extension) || extension == null)
if (View.NavigationMode.DEFAULT.equals(navigation) || navigation == null)
if (View.ViewParameterMode.DEFAULT.equals(viewParams) || viewParams == null)
return new ViewLiteral(basePath, name, extension, navigation, viewParams);
return view;
private boolean isView(Class source)
import org.apache.deltaspike.jsf.api.config.view.View;
public class ViewLiteral extends AnnotationLiteral<View> implements View
public ViewLiteral(boolean virtual)
public ViewLiteral(String basePath,
ViewLiteral that = (ViewLiteral) o;
import org.apache.deltaspike.jsf.api.config.view.View;
View viewAnnotation = findMetaDataByType(mergedMetaData, View.class);
import org.apache.deltaspike.jsf.api.config.view.View;
import org.apache.deltaspike.jsf.api.literal.ViewLiteral;
if (annotation.annotationType().equals(View.class))
currentNode.getMetaData().add(new ViewLiteral(true));
import org.apache.deltaspike.jsf.api.config.view.View;
View.NavigationMode navigationMode = entry.getMetaData(View.class).iterator().next().navigation();
View.NavigationMode.REDIRECT.equals(navigationMode),
import org.apache.deltaspike.jsf.api.config.view.View;
View viewMetaData = entry.getMetaData(View.class).iterator().next();
includeParameters = View.ViewParameterMode.INCLUDE
.equals(viewMetaData.viewParams());
View.NavigationMode.REDIRECT.equals(viewMetaData.navigation()),
import org.apache.deltaspike.jsf.api.config.view.View;
if (loadedClass.getAnnotation(View.class) == null &&
loadedClass.getSuperclass().getAnnotation(View.class) != null)
View viewMetaData = entry.getMetaData(View.class).iterator().next();
boolean performRedirect = View.NavigationMode.REDIRECT.equals(viewMetaData.navigation());
boolean includeViewParameters = View.ViewParameterMode.INCLUDE.equals(viewMetaData.viewParams());
import org.apache.deltaspike.jsf.api.config.view.View;
if (errorViewDescriptor != null && View.NavigationMode.REDIRECT ==
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.FORWARD;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.REDIRECT;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.INCLUDE;
@View(navigation = REDIRECT)
@View(viewParams = INCLUDE)
@View(navigation = FORWARD)
import org.apache.deltaspike.jsf.api.config.view.View;
@View(name = "index")
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.FORWARD;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.REDIRECT;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.INCLUDE;
@View(navigation = REDIRECT)
@View(viewParams = INCLUDE)
@View(navigation = FORWARD)
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.REDIRECT;
@View(navigation = REDIRECT)
return ViewConfigForIncludeViewParams.class;
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.INCLUDE;
@View(viewParams = INCLUDE)
public class ViewConfigForIncludeViewParams implements ViewConfig
import org.apache.deltaspike.jsf.api.config.view.View;
@View
class SimplePageConfig002 implements ViewConfig
import org.apache.deltaspike.jsf.api.config.view.View;
@View
class Home implements ViewConfig
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.Extension.JSP;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.FORWARD;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.REDIRECT;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.INCLUDE;
@View(name = "home", extension = JSP) class Index implements ViewConfig
@View(navigation = REDIRECT, viewParams = INCLUDE)
@View
class Index implements ViewConfig
@View(navigation = FORWARD)
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.FORWARD;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.REDIRECT;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.INCLUDE;
@View(navigation = REDIRECT)
@View(viewParams = INCLUDE)
@View
class Index implements Statistics
@View
class Index implements Admin
@View(navigation = FORWARD)
import org.apache.deltaspike.jsf.api.config.view.View;
import static org.apache.deltaspike.jsf.api.config.view.View.Extension.FACES;
import static org.apache.deltaspike.jsf.api.config.view.View.Extension.JSF;
import static org.apache.deltaspike.jsf.api.config.view.View.Extension.XHTML;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.FORWARD;
import static org.apache.deltaspike.jsf.api.config.view.View.NavigationMode.REDIRECT;
import static org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode.INCLUDE;
@View(navigation = REDIRECT, extension = JSF)
@View(viewParams = INCLUDE, extension = FACES)
@View
class Index implements Statistics
@View(extension = XHTML) class Index implements Admin
@View(navigation = FORWARD) class Home implements Admin
@ViewMetaData(preProcessor = ViewControllerBean.ViewControllerBeanConfigPreProcessor.class)
public @interface ViewControllerBean
public class ViewControllerBeanConfigPreProcessor implements ConfigPreProcessor<ViewControllerBean>
public ViewControllerBean beforeAddToConfig(ViewControllerBean metaData, ViewConfigNode viewConfigNode)
ViewControllerBean.class, new ViewControllerDescriptor(metaData.value(), InitView.class));
ViewControllerBean.class, new ViewControllerDescriptor(metaData.value(), PrePageAction.class));
ViewControllerBean.class, new ViewControllerDescriptor(metaData.value(), PreRenderView.class));
ViewControllerBean.class, new ViewControllerDescriptor(metaData.value(), PostRenderView.class));
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerBean;
public class ViewControllerBeanLiteral extends AnnotationLiteral<ViewControllerBean> implements ViewControllerBean
public ViewControllerBeanLiteral(Class value, String name)
import org.apache.deltaspike.jsf.api.literal.ViewControllerBeanLiteral;
viewConfigNode.getInheritedMetaData().add(new ViewControllerBeanLiteral(configClass, null));
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerBean;
@ViewControllerBean(PageBean001.class)
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerBean;
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerBean;
@ViewControllerBean(PageBean004.class)
public @interface PreViewAction
ViewControllerBean.class, new ViewControllerDescriptor(metaData.value(), PreViewAction.class));
import org.apache.deltaspike.jsf.api.config.view.controller.PreViewAction;
@PreViewAction
private static String testName;
public static String getTestName()
{
StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
String testName = "unknown";
for (StackTraceElement ste : stackTraceElements)
{
if (ste.getClassName().contains("Test"))
{
testName = ste.getClassName();
break;
}
}
return testName;
}
import java.util.logging.Logger;
private static final Logger LOG = Logger.getLogger(OpenWebBeansContainerControl.class.getName());
BeanManager beanManager = getBeanManager();
if (beanManager == null)
{
LOG.warning("If the CDI-container was started by the environment, you can't use this helper."
"Instead you can resolve ContextControl manually "
"(e.g. via BeanProvider.getContextualReference(ContextControl.class) ). "
"If the container wasn't started already, you have to use CdiContainer#boot before.");
return null;
}
ctxCtrlBean = (Bean<ContextControl>) beanManager.resolve(beans);
import java.util.logging.Logger;
private static final Logger LOG = Logger.getLogger(WeldContainerControl.class.getName());
BeanManager beanManager = getBeanManager();
if (beanManager == null)
{
LOG.warning("If the CDI-container was started by the environment, you can't use this helper."
"Instead you can resolve ContextControl manually "
"(e.g. via BeanProvider.getContextualReference(ContextControl.class) ). "
"If the container wasn't started already, you have to use CdiContainer#boot before.");
return null;
}
ctxCtrlBean = (Bean<ContextControl>) beanManager.resolve(beans);
@Retention(value = RetentionPolicy.RUNTIME)
package org.apache.deltaspike.jpa.api.entitymanager;
package org.apache.deltaspike.jpa.spi.entitymanager;
import org.apache.deltaspike.jpa.spi.entitymanager.PersistenceConfigurationProvider;
import org.apache.deltaspike.jpa.api.entitymanager.PersistenceUnitName;
@Inject
private PersistenceConfigurationProvider persistenceConfigurationProvider;
import org.apache.deltaspike.jpa.spi.entitymanager.PersistenceConfigurationProvider;
import org.apache.deltaspike.jpa.api.entitymanager.PersistenceUnitName;
import javax.annotation.ManagedBean;
import java.util.HashMap;
import java.util.Map;
import org.apache.openejb.OpenEjbContainer;
openEjbContainer = EJBContainer.createEJBContainer(getConfiguration());
protected Map<?,?> getConfiguration()
{
Map<String, String> config = new HashMap<String, String>();
config.put(OpenEjbContainer.Provider.OPENEJB_ADDITIONNAL_CALLERS_KEY, "");
return config;
}
import org.apache.deltaspike.jpa.api.entitymanager.PersistenceUnitName;
import org.apache.deltaspike.test.jpa.api.shared.TestEntityManager;
return (TestEntityManager)emf.createEntityManager();
public void closeEm(@Disposes @SampleDb TestEntityManager em)
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import javax.enterprise.context.Dependent;
import java.util.Set;
private CreationalContext<?> creationalContextOfDependentHandler;
H handlerInstance = createHandlerInstance();
private H createHandlerInstance()
{
Set<Bean<H>> handlerBeans = BeanProvider.getBeanDefinitions(this.handlerClass, false, true);
if (handlerBeans.size() != 1)
{
}
Bean<H> handlerBean = handlerBeans.iterator().next();
BeanManager beanManager = BeanManagerProvider.getInstance().getBeanManager();
CreationalContext<?> creationalContextOfHandler = beanManager.createCreationalContext(handlerBean);
H handlerInstance = (H)beanManager.getReference(handlerBean, this.handlerClass, creationalContextOfHandler);
if (handlerBean.getScope().equals(Dependent.class))
{
this.creationalContextOfDependentHandler = creationalContextOfHandler;
}
return handlerInstance;
}
if (this.creationalContextOfDependentHandler != null)
{
this.creationalContextOfDependentHandler.release();
}
import javax.enterprise.context.Dependent;
public <M> JsfMessage<M> createJsfMessage(InjectionPoint injectionPoint)
if (!(injectionPoint.getType() instanceof ParameterizedType))
try
{
@SuppressWarnings("unchecked")
Class<M> type = (Class<M>) actualTypes[0];
return createJsfMessageFor(injectionPoint, type);
}
catch (ClassCastException e)
{
throw new IllegalArgumentException("Incorrect class found when trying to convert to parameterized type",e);
}
private <M> JsfMessage<M> createJsfMessageFor(InjectionPoint injectionPoint, Class<M> rawType)
return new DefaultJsfMessage<M>(rawType, null);
import java.lang.annotation.Annotation;
private static final long serialVersionUID = -6272327391611428125L;
if (emQualifiers.isEmpty())
{
emQualifiers.add(Default.class);
}
if (arguments != null)
{
Collections.addAll(this.arguments, arguments);
}
import java.util.Collection;
Message argumentArray(Serializable[] arguments);
Message argument(Collection<Serializable> arguments);
import java.util.Collection;
@Override
public Message argumentArray(Serializable[] arguments)
{
if (arguments != null)
{
return argument(Arrays.asList(arguments));
}
return this;
}
@Override
public Message argument(Collection<Serializable> arguments)
{
if (arguments != null)
{
this.arguments.addAll(arguments);
}
return this;
}
final MBeanServer server = mBeanServer();
if (server.isRegistered(objectName)
&& "true".equals(ConfigResolver.getPropertyValue("deltaspike.mbean.auto-unregister", "true")))
{
server.unregisterMBean(objectName);
}
server.registerMBean(mbean, objectName);
import java.util.HashMap;
import javax.enterprise.inject.Typed;
import org.apache.deltaspike.core.util.ClassUtils;
public static Map<String, String> getAllProperties()
{
List<ConfigSource> appConfigSources =
sortAscending(new ArrayList<ConfigSource>(Arrays.asList(getConfigSources())));
Map<String, String> result = new HashMap<String, String>();
for (ConfigSource configSource : appConfigSources)
{
result.putAll(configSource.getProperties());
}
return Collections.unmodifiableMap(result);
}
import java.util.Map;
Map<String, String> getProperties();
class EnvironmentPropertyConfigSource extends MapConfigSource
super(System.getenv());
import java.util.HashMap;
import java.util.Map;
import org.apache.deltaspike.core.impl.util.JndiUtils;
return JndiUtils.lookup(getJndiKey(key), String.class);
private String getJndiKey(String key)
{
if (key.startsWith("java:comp/env"))
{
return key;
}
}
@Override
public Map<String, String> getProperties()
{
Map<String, String> result = new HashMap<String, String>();
result.putAll(JndiUtils.list(BASE_NAME, String.class));
result.putAll(JndiUtils.list("java:comp/env", String.class));
return result;
}
import org.apache.deltaspike.core.util.PropertyFileUtils;
class PropertyFileConfigSource extends PropertiesConfigSource
super(PropertyFileUtils.loadProperties(propertyFileUrl));
class SystemPropertyConfigSource extends PropertiesConfigSource
super(System.getProperties());
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.naming.Name;
import javax.naming.NameClassPair;
import javax.naming.NameParser;
import javax.naming.NamingEnumeration;
import org.apache.deltaspike.core.util.ClassUtils;
public static <T> T lookup(Name name, Class<? extends T> targetType)
return verifyLookupResult(initialContext.lookup(name), name.toString(), targetType);
public static <T> T lookup(String name, Class<? extends T> targetType)
{
try
{
return verifyLookupResult(initialContext.lookup(name), name, targetType);
}
catch (NamingException e)
{
}
}
@SuppressWarnings("unchecked")
private static <T> T verifyLookupResult(Object result, String name, Class<? extends T> targetType)
{
if (result != null)
{
if (targetType.isAssignableFrom(result.getClass()))
{
return (T) result;
}
{
try
{
Class<?> classOfResult = ClassUtils.loadClassForName((String) result);
if (targetType.isAssignableFrom(classOfResult))
{
try
{
return (T) classOfResult.newInstance();
}
catch (Exception e)
{
}
}
else
{
" which does not implement/extend the expected class"
targetType.getName());
}
}
catch (ClassNotFoundException cnfe)
{
}
}
else
{
}
}
return null;
}
public static <T> Map<String, T> list(String name, Class<T> type)
{
try
{
Map<String, T> result = new HashMap<String, T>();
NameParser nameParser = initialContext.getNameParser(name);
NamingEnumeration<NameClassPair> enumeration = initialContext.list(name);
while (enumeration.hasMoreElements())
{
NameClassPair binding = enumeration.nextElement();
Name bindingName = nameParser.parse(name).add(binding.getName());
result.put(binding.getName(), lookup(bindingName, type));
}
return result;
}
catch (NamingException e)
{
}
}
@ViewMetaData(preProcessor = ViewControllerBean.AnnotationPreProcessor.class)
class AnnotationPreProcessor implements ConfigPreProcessor<ViewControllerBean>
ViewControllerBean.class, new Descriptor(metaData.value(), InitView.class));
ViewControllerBean.class, new Descriptor(metaData.value(), PreViewAction.class));
ViewControllerBean.class, new Descriptor(metaData.value(), PreRenderView.class));
ViewControllerBean.class, new Descriptor(metaData.value(), PostRenderView.class));
}
static class Descriptor extends SimpleCallbackDescriptor<Void>
{
protected Descriptor(Class beanClass, Class<? extends Annotation> callbackType)
super(beanClass, callbackType);
import java.io.Serializable;
public interface NavigationParameterContext extends Serializable
for (Annotation inheritedAnnotation : inheritedMetaData)
ViewMetaData viewMetaData = inheritedAnnotation.annotationType().getAnnotation(ViewMetaData.class);
Aggregated aggregated = inheritedAnnotation.annotationType().getAnnotation(Aggregated.class);
mergedResult.add(inheritedAnnotation);
Annotation currentNodeMetaData = findInResult(nodeViewMetaData, inheritedAnnotation);
if (currentNodeMetaData == null)
Annotation mergedMetaData = findInResult(mergedResult, inheritedAnnotation);
mergedResult.add(inheritedAnnotation);
Annotation mergedAnnotation = mergeAnnotationInstance(mergedMetaData, inheritedAnnotation);
Annotation mergedAnnotation = mergeAnnotationInstance(currentNodeMetaData, inheritedAnnotation);
private static final long serialVersionUID = 6027959542775130265L;
Secured.Descriptor securedDescriptor = viewConfigDescriptor
.getExecutableCallbackDescriptor(Secured.class, Secured.Descriptor.class);
@ViewMetaData(preProcessor = Secured.AnnotationPreProcessor.class)
class AnnotationPreProcessor implements ConfigPreProcessor<Secured>
viewConfigNode.registerCallbackDescriptors(Secured.class, new Descriptor(metaData.value()));
static class Descriptor extends ExecutableCallbackDescriptor<Set<SecurityViolation>>
public Descriptor(Class<? extends AccessDecisionVoter>[] accessDecisionVoterBeanClasses)
.passivationCapable(true)
}
if (configSource.isScannable())
{
result.putAll(configSource.getProperties());
}
boolean isScannable();
@Override
public boolean isScannable()
{
return true;
}
@Override
public boolean isScannable()
{
return true;
}
@Override
public boolean isScannable()
{
return true;
}
package org.apache.deltaspike.partialbean.api.annotation;
public @interface PartialBeanBinding
package org.apache.deltaspike.partialbean.impl;
import org.apache.deltaspike.partialbean.api.annotation.PartialBeanBinding;
public class PartialBeanBindingExtension implements Extension, Deactivatable
private static final Logger LOG = Logger.getLogger(PartialBeanBindingExtension.class.getName());
if (annotation.annotationType().isAnnotationPresent(PartialBeanBinding.class))
package org.apache.deltaspike.partialbean.impl;
package org.apache.deltaspike.partialbean.impl;
package org.apache.deltaspike.test.core.api.partialbean.shared;
package org.apache.deltaspike.test.core.api.partialbean.shared;
package org.apache.deltaspike.test.core.api.partialbean.uc001;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
@TestPartialBeanBinding
package org.apache.deltaspike.test.core.api.partialbean.uc002;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestBean;
@TestPartialBeanBinding
package org.apache.deltaspike.test.core.api.partialbean.uc003;
import org.apache.deltaspike.test.core.api.partialbean.shared.CustomInterceptor;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestInterceptorAware;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestBean;
@TestPartialBeanBinding
@ViewMetaData(preProcessor = ViewControllerRef.AnnotationPreProcessor.class)
public @interface ViewControllerRef
class AnnotationPreProcessor implements ConfigPreProcessor<ViewControllerRef>
public ViewControllerRef beforeAddToConfig(ViewControllerRef metaData, ViewConfigNode viewConfigNode)
ViewControllerRef.class, new Descriptor(metaData.value(), InitView.class));
ViewControllerRef.class, new Descriptor(metaData.value(), PreViewAction.class));
ViewControllerRef.class, new Descriptor(metaData.value(), PreRenderView.class));
ViewControllerRef.class, new Descriptor(metaData.value(), PostRenderView.class));
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerRef;
public class ViewControllerRefLiteral extends AnnotationLiteral<ViewControllerRef> implements ViewControllerRef
public ViewControllerRefLiteral(Class value, String name)
import org.apache.deltaspike.jsf.api.literal.ViewControllerRefLiteral;
viewConfigNode.getInheritedMetaData().add(new ViewControllerRefLiteral(configClass, null));
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerRef;
@ViewControllerRef(PageBean001.class)
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerRef;
import org.apache.deltaspike.jsf.api.config.view.controller.ViewControllerRef;
@ViewControllerRef(PageBean004.class)
package org.apache.deltaspike.core.api.config.view.navigation;
package org.apache.deltaspike.core.api.config.view.navigation;
package org.apache.deltaspike.core.api.config.view.navigation;
package org.apache.deltaspike.core.api.config.view.navigation.event;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameterContext;
import org.apache.deltaspike.core.api.config.view.navigation.ViewNavigationHandler;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameter;
import org.apache.deltaspike.core.api.config.view.navigation.event.PreViewConfigNavigateEvent;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameterContext;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameterContext;
import org.apache.deltaspike.core.api.config.view.navigation.ViewNavigationHandler;
import org.apache.deltaspike.core.api.config.view.navigation.event.PreViewConfigNavigateEvent;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameter;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameter;
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameterContext;
import java.io.Serializable;
public class PageBean004 implements Serializable
import org.apache.deltaspike.core.api.config.view.navigation.NavigationParameter;
import org.apache.deltaspike.core.api.config.view.navigation.ViewNavigationHandler;
package org.apache.deltaspike.jsf.impl.config.view.navigation;
package org.apache.deltaspike.jsf.impl.config.view.navigation;
package org.apache.deltaspike.jsf.impl.config.view.navigation;
public class NavigationCaseMapWrapper implements Map<String, Set<NavigationCase>>
package org.apache.deltaspike.jsf.impl.config.view.navigation;
public class ViewConfigAwareNavigationHandler extends NavigationHandler
import org.apache.deltaspike.jsf.impl.config.view.navigation.NavigationCaseMapWrapper;
import org.apache.deltaspike.jsf.impl.config.view.navigation.ViewConfigAwareNavigationHandler;
import org.apache.deltaspike.core.api.config.view.metadata.ViewConfigResolver;
import org.apache.deltaspike.jsf.impl.config.view.DefaultErrorViewAwareExceptionHandlerWrapper;
import javax.faces.context.ExceptionHandler;
private boolean defaultErrorViewExceptionHandlerActivated;
@Override
public ExceptionHandler getExceptionHandler()
{
lazyInit();
ExceptionHandler exceptionHandler = this.wrappedFacesContext.getExceptionHandler();
if (this.defaultErrorViewExceptionHandlerActivated)
{
exceptionHandler = new DefaultErrorViewAwareExceptionHandlerWrapper(exceptionHandler);
}
return exceptionHandler;
}
ViewConfigResolver viewConfigResolver = BeanProvider.getContextualReference(ViewConfigResolver.class);
this.defaultErrorViewExceptionHandlerActivated =
viewConfigResolver.getDefaultErrorViewConfigDescriptor() != null &&
ClassDeactivationUtils.isActivated(DefaultErrorViewAwareExceptionHandlerWrapper.class);
Class<? extends CT> getConfigClass();
public interface ViewConfigDescriptor extends ConfigDescriptor<ViewConfig>
ConfigDescriptor<?> getConfigDescriptor(String path);
ConfigDescriptor<?> getConfigDescriptor(Class configClass);
List<ConfigDescriptor<?>> getConfigDescriptors();
abstract class AbstractPathConfigDescriptor<CT> implements ConfigDescriptor<CT>
private final Class<? extends CT> source;
AbstractPathConfigDescriptor(Class<? extends CT> configClass,
public Class<? extends CT> getConfigClass()
class DefaultFolderConfigDescriptor extends AbstractPathConfigDescriptor<Object>
currentViewConfigDescriptor.getViewId(), currentViewConfigDescriptor.getConfigClass());
if (DefaultErrorView.class.isAssignableFrom(currentViewConfigDescriptor.getConfigClass()))
else if (DefaultErrorView.class.isAssignableFrom(currentViewConfigDescriptor.getConfigClass()))
currentViewConfigDescriptor.getConfigClass().getName());
if (!viewConfigs.containsKey(currentViewConfigDescriptor.getConfigClass()))
viewConfigs.put(currentViewConfigDescriptor.getConfigClass(), currentViewConfigDescriptor);
public ConfigDescriptor<?> getConfigDescriptor(String path)
public ConfigDescriptor<?> getConfigDescriptor(Class configClass)
public List<ConfigDescriptor<?>> getConfigDescriptors()
ConfigDescriptor<?>[] result = this.folderDefinitionToViewDefinitionEntryMapping.values()
.toArray(new ConfigDescriptor<?>[this.folderDefinitionToViewDefinitionEntryMapping.size()]);
return new ArrayList<ConfigDescriptor<?>>(Arrays.asList(result));
class DefaultViewPathConfigDescriptor
extends AbstractPathConfigDescriptor<ViewConfig>
implements ViewConfigDescriptor
addConfiguredViewParameters(entry.getConfigClass());
if (navigateEvent.getToView().equals(viewConfigDescriptor.getConfigClass()))
oldViewConfigDescriptor.getConfigClass(), newViewConfigDescriptor.getConfigClass());
errorView = errorViewDescriptor.getConfigClass();
ConfigDescriptor<?> viewConfigDescriptor)
errorView = errorPageDescriptor.getConfigClass();
String getPath();
@Override
public String toString()
{
return getPath();
}
public String getPath()
public String getPath()
public String getViewId()
private Map<String, ViewConfigDescriptor> viewPathToViewDefinitionEntryMapping;
return this.viewPathToViewDefinitionEntryMapping.get(viewId);
ConfigDescriptor<?>[] folderResult = this.folderDefinitionToViewDefinitionEntryMapping.values()
ConfigDescriptor<?>[] viewResult = this.viewDefinitionToViewDefinitionEntryMapping.values()
.toArray(new ConfigDescriptor<?>[this.viewDefinitionToViewDefinitionEntryMapping.size()]);
List<ConfigDescriptor<?>> result = new ArrayList<ConfigDescriptor<?>>();
result.addAll(Arrays.asList(folderResult));
result.addAll(Arrays.asList(viewResult));
return result;
for (ConfigDescriptor folderConfigDescriptor : this.folderDefinitionToViewDefinitionEntryMapping.values())
if (folderPathMapping.containsKey(folderConfigDescriptor.toString()))
folderConfigDescriptor.toString()).getConfigClass().getName()
folderPathMapping.put(folderConfigDescriptor.getPath(), folderConfigDescriptor);
Map<String, ViewConfigDescriptor> viewPathMapping = new HashMap<String, ViewConfigDescriptor>();
for (ViewConfigDescriptor pageConfigDescriptor : this.viewDefinitionToViewDefinitionEntryMapping.values())
if (viewPathMapping.containsKey(pageConfigDescriptor.getViewId()))
viewPathMapping.get(
pageConfigDescriptor.getViewId()).getConfigClass().getName()
viewPathMapping.put(pageConfigDescriptor.getPath(), pageConfigDescriptor);
this.viewPathToViewDefinitionEntryMapping = Collections.unmodifiableMap(viewPathMapping);
package org.apache.deltaspike.core.api.config;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
package org.apache.deltaspike.core.api.config.view.metadata;
package org.apache.deltaspike.core.api.config.view.metadata;
package org.apache.deltaspike.core.api.config.view.metadata;
import org.apache.deltaspike.core.api.config.view.metadata.Aggregated;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.DefaultCallback;
import org.apache.deltaspike.core.api.config.view.metadata.Aggregated;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import org.apache.deltaspike.core.api.config.view.metadata.DefaultCallback;
import org.apache.deltaspike.core.api.config.view.metadata.DefaultCallback;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
package org.apache.deltaspike.core.api.exception.control;
package org.apache.deltaspike.core.api.exception.control;
package org.apache.deltaspike.core.api.exception.control;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
import org.apache.deltaspike.core.api.exception.control.BeforeHandles;
import org.apache.deltaspike.core.api.exception.control.ExceptionHandler;
import org.apache.deltaspike.core.api.exception.control.Handles;
package org.apache.deltaspike.core.api.exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
import org.apache.deltaspike.core.api.exclude.Exclude;
package org.apache.deltaspike.core.api.jmx;
package org.apache.deltaspike.core.api.jmx;
package org.apache.deltaspike.core.api.jmx;
import org.apache.deltaspike.core.api.jmx.MBean;
import org.apache.deltaspike.core.api.jmx.JmxManaged;
import org.apache.deltaspike.core.api.jmx.MBean;
import org.apache.deltaspike.core.api.jmx.NotificationInfo;
import org.apache.deltaspike.core.api.jmx.MBean;
import org.apache.deltaspike.core.api.jmx.JmxManaged;
import org.apache.deltaspike.core.api.jmx.MBean;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
package org.apache.deltaspike.core.api.message;
package org.apache.deltaspike.core.api.message;
package org.apache.deltaspike.core.api.message;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageContextConfig;
package org.apache.deltaspike.partialbean.api;
import org.apache.deltaspike.partialbean.api.PartialBeanBinding;
import org.apache.deltaspike.security.api.authorization.Secured;
package org.apache.deltaspike.security.api.authorization;
package org.apache.deltaspike.security.api.authorization;
package org.apache.deltaspike.security.api.authorization;
package org.apache.deltaspike.security.api.authorization;
package org.apache.deltaspike.security.api.authorization;
import org.apache.deltaspike.security.api.authorization.Secured;
import org.apache.deltaspike.security.api.authorization.Secures;
@Secures
@Secured({ })
import org.apache.deltaspike.security.api.authorization.SecuredReturn;
import org.apache.deltaspike.security.api.authorization.SecurityParameterBinding;
import org.apache.deltaspike.security.api.authorization.SecurityBindingType;
import org.apache.deltaspike.security.api.authorization.SecuredReturn;
import org.apache.deltaspike.security.api.authorization.Secures;
if (m.isAnnotationPresent(Secures.class))
import org.apache.deltaspike.security.api.authorization.SecurityBindingType;
import org.apache.deltaspike.security.api.authorization.SecurityParameterBinding;
import org.apache.deltaspike.security.api.authorization.Secured;
import org.apache.deltaspike.security.api.authorization.Secured;
import org.apache.deltaspike.security.api.authorization.Secured;
import org.apache.deltaspike.security.api.authorization.Secures;
import org.apache.deltaspike.security.api.authorization.SecurityBindingType;
import org.apache.deltaspike.security.api.authorization.SecuredReturn;
import org.apache.deltaspike.security.api.authorization.Secures;
import org.apache.deltaspike.security.api.authorization.SecurityBindingType;
import org.apache.deltaspike.security.api.authorization.SecurityParameterBinding;
import org.apache.deltaspike.core.api.config.view.controller.literal.ViewControllerRefLiteral;
import org.apache.deltaspike.core.api.config.view.metadata.InlineViewMetaData;
import org.apache.deltaspike.core.spi.config.view.InlineMetaDataTransformer;
import org.apache.deltaspike.core.spi.config.view.TargetViewConfigProvider;
import org.apache.deltaspike.core.api.config.view.controller.ViewControllerRef;
import javax.inject.Named;
@InlineViewMetaData(
targetViewConfigProvider = ViewRef.ViewRefTargetViewConfigProvider.class,
inlineMetaDataTransformer = ViewRef.ViewRefInlineMetaDataTransformer.class)
class ViewRefTargetViewConfigProvider implements TargetViewConfigProvider<ViewRef>
{
@Override
public Class<? extends ViewConfig>[] getTarget(ViewRef inlineMetaData)
{
return inlineMetaData.config();
}
}
class ViewRefInlineMetaDataTransformer implements InlineMetaDataTransformer<ViewRef, ViewControllerRef>
{
@Override
public ViewControllerRef convertToViewMetaData(ViewRef inlineMetaData, Class<?> sourceClass)
{
String beanName = null;
Named named = sourceClass.getAnnotation(Named.class);
if (named != null)
{
beanName = named.value();
}
return new ViewControllerRefLiteral(sourceClass, beanName);
}
}
package org.apache.deltaspike.core.api.config.view.controller;
package org.apache.deltaspike.core.api.config.view.controller;
package org.apache.deltaspike.core.api.config.view.controller;
package org.apache.deltaspike.core.api.config.view.controller;
package org.apache.deltaspike.core.api.config.view.controller;
package org.apache.deltaspike.core.api.config.view.controller.literal;
import org.apache.deltaspike.core.api.config.view.controller.ViewControllerRef;
package org.apache.deltaspike.core.api.config.view.metadata;
import org.apache.deltaspike.core.spi.config.view.InlineMetaDataTransformer;
import org.apache.deltaspike.core.spi.config.view.TargetViewConfigProvider;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
@Target({ ANNOTATION_TYPE })
public @interface InlineViewMetaData
Class<? extends TargetViewConfigProvider> targetViewConfigProvider();
Class<? extends InlineMetaDataTransformer> inlineMetaDataTransformer() default InlineMetaDataTransformer.class;
import org.apache.deltaspike.core.api.config.view.metadata.InlineViewMetaData;
import org.apache.deltaspike.core.spi.config.view.InlineMetaDataTransformer;
import org.apache.deltaspike.core.spi.config.view.TargetViewConfigProvider;
import org.apache.deltaspike.core.util.ClassUtils;
InlineViewMetaData inlineViewMetaData = annotation.annotationType().getAnnotation(InlineViewMetaData.class);
if (inlineViewMetaData != null)
Class<? extends TargetViewConfigProvider> targetViewConfigProviderClass =
inlineViewMetaData.targetViewConfigProvider();
TargetViewConfigProvider targetViewConfigProvider =
ClassUtils.tryToInstantiateClass(targetViewConfigProviderClass);
for (Class<? extends ViewConfig> viewConfigRef : targetViewConfigProvider.getTarget(annotation))
Class<? extends InlineMetaDataTransformer> inlineNodeTransformerClass =
inlineViewMetaData.inlineMetaDataTransformer();
if (!InlineMetaDataTransformer.class.equals(inlineNodeTransformerClass))
{
InlineMetaDataTransformer inlineMetaDataTransformer =
ClassUtils.tryToInstantiateClass(inlineNodeTransformerClass);
viewConfigNode.getInheritedMetaData().add(
inlineMetaDataTransformer.convertToViewMetaData(annotation, configClass));
}
{
viewConfigNode.getInheritedMetaData().add(annotation);
}
import org.apache.deltaspike.core.api.config.view.controller.PreRenderView;
import org.apache.deltaspike.core.api.config.view.controller.ViewControllerRef;
import org.apache.deltaspike.core.api.config.view.controller.PostRenderView;
import org.apache.deltaspike.core.api.config.view.controller.ViewControllerRef;
import org.apache.deltaspike.core.api.config.view.controller.InitView;
import org.apache.deltaspike.core.api.config.view.controller.PreViewAction;
import org.apache.deltaspike.core.api.config.view.controller.PreRenderView;
import org.apache.deltaspike.core.api.config.view.controller.PreRenderView;
import org.apache.deltaspike.core.api.config.view.controller.ViewControllerRef;
import org.apache.deltaspike.core.util.ClassUtils;
import java.lang.reflect.Proxy;
private final boolean isInterfaceMode;
this.isInterfaceMode = true;
this.partialBeanProxyClass = partialBeanClass;
this.isInterfaceMode = false;
try
{
Object proxyFactory = ClassUtils.tryToInstantiateClassForName("javassist.util.proxy.ProxyFactory");
Method setSuperclassMethod = proxyFactory.getClass().getDeclaredMethod("setSuperclass", Class.class);
setSuperclassMethod.invoke(proxyFactory, partialBeanClass);
Method createClassMethod = proxyFactory.getClass().getDeclaredMethod("createClass");
this.partialBeanProxyClass =
((Class<?>) createClassMethod.invoke(proxyFactory)).asSubclass(partialBeanClass);
}
catch (Exception e)
{
throw ExceptionUtils.throwAsRuntimeException(e);
}
T instance = createPartialBeanProxyInstance(handlerInstance);
private T createPartialBeanProxyInstance(H handlerInstance) throws Exception
{
T instance;
if (this.isInterfaceMode)
{
instance = (T) Proxy.newProxyInstance(
ClassUtils.getClassLoader(this), new Class[]{this.partialBeanProxyClass}, handlerInstance);
}
{
instance = this.partialBeanProxyClass.newInstance();
Class methodHandlerClass = ClassUtils.tryToLoadClassForName("javassist.util.proxy.MethodHandler");
Method setHandlerMethod = ClassUtils.tryToLoadClassForName("javassist.util.proxy.ProxyObject")
.getDeclaredMethod("setHandler", methodHandlerClass);
MethodHandlerProxy methodHandlerProxy = new MethodHandlerProxy();
methodHandlerProxy.setPartialBeanMethodHandler(new PartialBeanMethodHandler<H>(handlerInstance));
Object methodHandler = Proxy.newProxyInstance(
ClassUtils.getClassLoader(this), new Class[]{methodHandlerClass}, methodHandlerProxy);
setHandlerMethod.invoke(instance, methodHandler);
}
return instance;
}
class PartialBeanMethodHandler<T extends InvocationHandler>
private PartialBeanAbstractMethodHandler partialBeanMethodHandler;
void setPartialBeanMethodHandler(PartialBeanAbstractMethodHandler partialBeanMethodHandler)
class PartialBeanAbstractMethodHandler<T extends InvocationHandler>
PartialBeanAbstractMethodHandler(T handlerInstance)
methodHandlerProxy.setPartialBeanMethodHandler(new PartialBeanAbstractMethodHandler<H>(handlerInstance));
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.util.ClassUtils;
Class<? extends NameBuilder> folderNameBuilder() default DefaultFolderNameBuilder.class;
NameBuilder folderNameBuilder = getFolderNameBuilder(folder);
String name = folderNameBuilder.build(folder, viewConfigNode);
if (folderNameBuilder.isDefaultValueReplaced())
return new FolderLiteral(name, folder.folderNameBuilder());
private NameBuilder getFolderNameBuilder(Folder folder)
{
NameBuilder folderNameBuilder;
if (DefaultFolderNameBuilder.class.equals(folder.folderNameBuilder()))
{
String customDefaultFolderNameBuilderClassName =
ConfigResolver.getPropertyValue(DefaultFolderNameBuilder.class.getName(), null);
if (customDefaultFolderNameBuilderClassName != null)
{
folderNameBuilder =
(NameBuilder) ClassUtils.tryToInstantiateClassForName(customDefaultFolderNameBuilderClassName);
}
else
{
folderNameBuilder = new DefaultFolderNameBuilder();
}
}
else
{
folderNameBuilder = ClassUtils.tryToInstantiateClass(folder.folderNameBuilder());
}
return folderNameBuilder;
}
}
interface NameBuilder
{
String build(Folder folder, ViewConfigNode viewConfigNode);
boolean isDefaultValueReplaced();
}
class DefaultFolderNameBuilder implements NameBuilder
{
private boolean defaultValueReplaced = false;
@Override
public String build(Folder folder, ViewConfigNode viewConfigNode)
{
String name = folder.name();
{
this.defaultValueReplaced = true;
name = NamingConventionUtils.toPath(viewConfigNode);
}
if (name != null && name.startsWith("."))
{
this.defaultValueReplaced = true;
}
if (name != null && name.contains("//"))
{
name = name.replace("//", "/");
this.defaultValueReplaced = true;
}
return name;
}
public boolean isDefaultValueReplaced()
{
return defaultValueReplaced;
}
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.util.ClassUtils;
Class<? extends NameBuilder> basePathBuilder() default DefaultBasePathBuilder.class;
Class<? extends NameBuilder> fileNameBuilder() default DefaultFileNameBuilder.class;
Class<? extends NameBuilder> extensionBuilder() default DefaultExtensionBuilder.class;
interface Extension
enum NavigationMode
enum ViewParameterMode
NameBuilder basePathBuilder = getBasePathBuilder(view);
String basePath = basePathBuilder.build(view, viewConfigNode);
if (basePathBuilder.isDefaultValueReplaced())
NameBuilder fileNameBuilder = getFileNameBuilder(view);
String name = fileNameBuilder.build(view, viewConfigNode);
if (fileNameBuilder.isDefaultValueReplaced())
NameBuilder extensionBuilder = getExtensionBuilder(view);
String extension = extensionBuilder.build(view, viewConfigNode);
if (extensionBuilder.isDefaultValueReplaced())
return new ViewLiteral(basePath, name, extension, navigation, viewParams,
view.basePathBuilder(), view.fileNameBuilder(), view.extensionBuilder());
private NameBuilder getBasePathBuilder(View view)
{
NameBuilder basePathBuilder;
if (DefaultBasePathBuilder.class.equals(view.basePathBuilder()))
{
String customDefaultBasePathBuilderClassName =
ConfigResolver.getPropertyValue(DefaultBasePathBuilder.class.getName(), null);
if (customDefaultBasePathBuilderClassName != null)
{
basePathBuilder =
(NameBuilder)ClassUtils.tryToInstantiateClassForName(customDefaultBasePathBuilderClassName);
}
else
{
basePathBuilder = new DefaultBasePathBuilder();
}
}
else
{
basePathBuilder = ClassUtils.tryToInstantiateClass(view.basePathBuilder());
}
return basePathBuilder;
}
private NameBuilder getFileNameBuilder(View view)
{
NameBuilder fileNameBuilder;
if (DefaultFileNameBuilder.class.equals(view.fileNameBuilder()))
{
String customDefaultFileNameBuilderClassName =
ConfigResolver.getPropertyValue(DefaultFileNameBuilder.class.getName(), null);
if (customDefaultFileNameBuilderClassName != null)
{
fileNameBuilder =
(NameBuilder)ClassUtils.tryToInstantiateClassForName(customDefaultFileNameBuilderClassName);
}
else
{
fileNameBuilder = new DefaultFileNameBuilder();
}
}
else
{
fileNameBuilder = ClassUtils.tryToInstantiateClass(view.fileNameBuilder());
}
return fileNameBuilder;
}
private NameBuilder getExtensionBuilder(View view)
{
NameBuilder extensionBuilder;
if (DefaultExtensionBuilder.class.equals(view.extensionBuilder()))
{
String customDefaultExtensionBuilderClassName =
ConfigResolver.getPropertyValue(DefaultExtensionBuilder.class.getName(), null);
if (customDefaultExtensionBuilderClassName != null)
{
extensionBuilder =
(NameBuilder)ClassUtils.tryToInstantiateClassForName(customDefaultExtensionBuilderClassName);
}
else
{
extensionBuilder = new DefaultExtensionBuilder();
}
}
else
{
extensionBuilder = ClassUtils.tryToInstantiateClass(view.extensionBuilder());
}
return extensionBuilder;
}
private static boolean isView(Class source)
interface NameBuilder
{
String build(View view, ViewConfigNode viewConfigNode);
boolean isDefaultValueReplaced();
}
abstract class AbstractNameBuilder implements NameBuilder
{
protected boolean defaultValueReplaced = false;
public boolean isDefaultValueReplaced()
{
return defaultValueReplaced;
}
}
class DefaultBasePathBuilder extends AbstractNameBuilder
{
@Override
public String build(View view, ViewConfigNode viewConfigNode)
{
String basePath = view.basePath();
Class source = viewConfigNode.getSource();
if (("".equals(basePath) || basePath == null) &&
{
this.defaultValueReplaced = true;
basePath = NamingConventionUtils.toPath(viewConfigNode.getParent());
}
if (basePath != null && basePath.startsWith("."))
{
this.defaultValueReplaced = true;
}
if (basePath != null && basePath.contains("//"))
{
basePath = basePath.replace("//", "/");
this.defaultValueReplaced = true;
}
return basePath;
}
}
class DefaultFileNameBuilder extends AbstractNameBuilder
{
@Override
public String build(View view, ViewConfigNode viewConfigNode)
{
String name = view.name();
Class source = viewConfigNode.getSource();
if (("".equals(name) || name == null) &&
{
this.defaultValueReplaced = true;
String className = viewConfigNode.getSource().getSimpleName();
}
return name;
}
}
class DefaultExtensionBuilder extends AbstractNameBuilder
{
@Override
public String build(View view, ViewConfigNode viewConfigNode)
{
String extension = view.extension();
if (View.Extension.DEFAULT.equals(extension) || extension == null)
{
defaultValueReplaced = true;
extension = XHTML;
}
return extension;
}
}
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.util.ClassUtils;
private final Class<? extends NameBuilder> folderNameBuilder;
final String customDefaultFolderNameBuilderClassName =
ConfigResolver.getPropertyValue(Folder.DefaultFolderNameBuilder.class.getName(), null);
if (customDefaultFolderNameBuilderClassName != null)
{
this.folderNameBuilder = ClassUtils.tryToLoadClassForName(customDefaultFolderNameBuilderClassName);
}
else
{
this.folderNameBuilder = DefaultFolderNameBuilder.class;
}
public FolderLiteral(String name, Class<? extends NameBuilder> folderNameBuilder)
this.folderNameBuilder = folderNameBuilder;
@Override
public Class<? extends NameBuilder> folderNameBuilder()
{
return this.folderNameBuilder;
}
if (!(o instanceof FolderLiteral))
{
return false;
}
if (!folderNameBuilder.equals(that.folderNameBuilder))
{
return false;
}
int result = name != null ? name.hashCode() : 0;
return result;
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.util.ClassUtils;
private final Class<? extends NameBuilder> basePathBuilder;
private final Class<? extends NameBuilder> fileNameBuilder;
private final Class<? extends NameBuilder> extensionBuilder;
final String customDefaultBasePathBuilderClassName =
ConfigResolver.getPropertyValue(DefaultBasePathBuilder.class.getName(), null);
if (customDefaultBasePathBuilderClassName != null)
{
this.basePathBuilder = ClassUtils.tryToLoadClassForName(customDefaultBasePathBuilderClassName);
}
else
{
this.basePathBuilder = DefaultBasePathBuilder.class;
}
final String customDefaultFileNameBuilderClassName =
ConfigResolver.getPropertyValue(DefaultFileNameBuilder.class.getName(), null);
if (customDefaultFileNameBuilderClassName != null)
{
this.fileNameBuilder = ClassUtils.tryToLoadClassForName(customDefaultFileNameBuilderClassName);
}
else
{
this.fileNameBuilder = DefaultFileNameBuilder.class;
}
final String customDefaultExtensionBuilderClassName =
ConfigResolver.getPropertyValue(DefaultExtensionBuilder.class.getName(), null);
if (customDefaultExtensionBuilderClassName != null)
{
this.extensionBuilder = ClassUtils.tryToLoadClassForName(customDefaultExtensionBuilderClassName);
}
else
{
this.extensionBuilder = DefaultExtensionBuilder.class;
}
ViewParameterMode viewParams,
Class<? extends NameBuilder> basePathBuilder,
Class<? extends NameBuilder> fileNameBuilder,
Class<? extends NameBuilder> extensionBuilder)
this.basePathBuilder = basePathBuilder;
this.fileNameBuilder = fileNameBuilder;
this.extensionBuilder = extensionBuilder;
@Override
public Class<? extends NameBuilder> basePathBuilder()
{
return this.basePathBuilder;
}
@Override
public Class<? extends NameBuilder> fileNameBuilder()
{
return this.fileNameBuilder;
}
@Override
public Class<? extends NameBuilder> extensionBuilder()
{
return this.extensionBuilder;
}
if (!(o instanceof ViewLiteral))
{
return false;
}
if (!basePathBuilder.equals(that.basePathBuilder))
{
return false;
}
if (!extensionBuilder.equals(that.extensionBuilder))
{
return false;
}
if (!fileNameBuilder.equals(that.fileNameBuilder))
{
return false;
}
import org.apache.deltaspike.jsf.api.config.view.Folder;
import java.lang.annotation.Annotation;
Folder folderMetaData = null;
for (Annotation nodeMetaData : node.getMetaData())
{
if (Folder.class.isAssignableFrom(nodeMetaData.annotationType()))
{
folderMetaData = (Folder)nodeMetaData;
}
}
String folderName = null;
if (folderMetaData != null)
{
folderName = folderMetaData.name();
}
if (folderName == null)
{
folderName = node.getSource().getSimpleName();
}
if (folderMetaData != null && !folderName.startsWith("."))
{
return folderName;
}
import javax.enterprise.context.RequestScoped;
@RequestScoped
import org.apache.deltaspike.jsf.api.config.view.Folder;
Class beanClass = pat.getAnnotatedType().getJavaClass();
if (ViewConfig.class.isAssignableFrom(beanClass))
if (beanClass.isAnnotationPresent(Folder.class))
{
addPageDefinition(pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations());
pat.veto();
}
else
{
addIndirectlyInheritedMetaData(
pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations());
}
addConfigClass(pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations());
if (ViewConfigUtils.isFolderConfig(beanClass) && beanClass.isAnnotationPresent(Folder.class))
addConfigClass(pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations());
addConfigClass(viewConfigClass, new HashSet<Annotation>(Arrays.asList(viewConfigClass.getAnnotations())));
public void addFolderDefinition(Class configClass)
{
if (ViewConfigUtils.isFolderConfig(configClass))
{
addConfigClass(configClass, new HashSet<Annotation>(Arrays.asList(configClass.getAnnotations())));
}
else
{
throw new IllegalArgumentException(configClass != null ? configClass.getName() : "null"
" is an invalid config for folders");
}
}
protected void addConfigClass(Class viewConfigClass, Set<Annotation> viewConfigAnnotations)
import org.apache.deltaspike.core.api.config.view.ViewConfig;
import org.apache.deltaspike.jsf.api.config.view.Folder;
return configClass != null && (
(ViewConfig.class.isAssignableFrom(configClass) &&
Modifier.isAbstract(configClass.getModifiers()) ||
Modifier.isInterface(configClass.getModifiers())
) ||
configClass.isAnnotationPresent(Folder.class));
PreViewConfigNavigateEvent navigateEvent;
navigateEvent = new PreViewConfigNavigateEvent(
else
{
navigateEvent = new PreViewConfigNavigateEvent(null, newViewConfigDescriptor.getConfigClass());
}
this.beanManager.fireEvent(navigateEvent);
return navigateEvent;
private List<String> checkedViewIds = new ArrayList<String>();
this.checkedViewIds.add(viewId);
return viewId != null && !this.checkedViewIds.contains(viewId);
import org.apache.deltaspike.core.api.config.view.ViewRef;
navigateEvent = new PreViewConfigNavigateEvent(
ViewRef.Manual.class, newViewConfigDescriptor.getConfigClass());
import org.apache.deltaspike.core.util.ExceptionUtils;
throw ExceptionUtils.throwAsRuntimeException(e);
throw ExceptionUtils.throwAsRuntimeException(e);
Map<String, T> result = new HashMap<String, T>();
LOG.log(Level.SEVERE, "InitialContext#list failed!", e);
return result;
import javax.enterprise.context.RequestScoped;
@RequestScoped
import org.apache.deltaspike.core.util.ExceptionUtils;
throw ExceptionUtils.throwAsRuntimeException(e);
throw ExceptionUtils.throwAsRuntimeException(e);
return getContextualReference(beanManager, type, optional, qualifiers);
}
public static <T> T getContextualReference(BeanManager beanManager,
Class<T> type,
boolean optional,
Annotation... qualifiers)
{
import javax.enterprise.inject.spi.AfterDeploymentValidation;
import javax.enterprise.inject.spi.Extension;
import org.apache.deltaspike.core.api.provider.BeanProvider;
public class DeltaSpikeContextExtension implements Extension
private WindowContextImpl windowContext;
windowContext = new WindowContextImpl(beanManager);
public void initializeDeltaSpikeContexts(@Observes AfterDeploymentValidation adv, BeanManager beanManager)
{
WindowBeanHolder windowBeanHolder
= BeanProvider.getContextualReference(beanManager, WindowBeanHolder.class, false);
WindowIdHolder windowIdHolder
= BeanProvider.getContextualReference(beanManager, WindowIdHolder.class, false);
windowContext.initWindowContext(windowBeanHolder, windowIdHolder);
}
public WindowContextImpl getWindowContext()
{
return windowContext;
}
import javax.enterprise.inject.Typed;
@Typed()
public class WindowContextImpl extends AbstractContext implements WindowContext
public WindowContextImpl(BeanManager beanManager)
void initWindowContext(WindowBeanHolder windowBeanHolder, WindowIdHolder windowIdHolder)
{
this.windowBeanHolder = windowBeanHolder;
this.windowIdHolder = windowIdHolder;
}
void activateWindow(String windowId);
boolean closeWindow(String windowId);
public static void destroyAllActive(ContextualStorage storage)
import javax.annotation.PreDestroy;
import org.apache.deltaspike.core.util.context.AbstractContext;
@PreDestroy
public void destroyBeans()
{
Map<String, ContextualStorage> oldWindowContextStorages = forceNewStorage();
for (ContextualStorage contextualStorage : oldWindowContextStorages.values())
{
AbstractContext.destroyAllActive(contextualStorage);
}
}
void initWindowContext(WindowBeanHolder windowBeanHolder, WindowIdHolder windowIdHolder)
{
this.windowBeanHolder = windowBeanHolder;
this.windowIdHolder = windowIdHolder;
}
public void activateWindow(String windowId)
public boolean closeWindow(String windowId)
ContextualStorage windowStorage = windowBeanHolder.getContextualStorage(beanManager, windowId);
if (windowStorage == null)
package org.apache.deltaspike.jsf.spi.scope.window;
LAZY,
CUSTOM
package org.apache.deltaspike.jsf.spi.scope.window;
private Map<String, ContextualStorage> storageMap = new ConcurrentHashMap<String, ContextualStorage>();
public Map<String, ContextualStorage> getStorageMap()
{
return storageMap;
}
import org.apache.deltaspike.core.spi.scope.window.WindowContext;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
private ClientWindow clientWindow;
private WindowContext windowContext;
lazyInit();
String windowId = clientWindow.getWindowId(facesContext);
if (windowId != null)
{
windowContext.activateWindow(windowId);
}
if (initialized == null)
beforeAfterJsfRequestBroadcaster =
clientWindow =
BeanProvider.getContextualReference(ClientWindow.class, true);
windowContext =
BeanProvider.getContextualReference(WindowContext.class, true);
initialized = true;
import javax.faces.FacesException;
import javax.faces.context.ExternalContext;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.OutputStream;
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
private static final String WINDOW_ID_COOKIE_PREFIX = "dsWindowId-";
private static final String DELTASPIKE_REQUEST_TOKEN = "dsRid";
private static final String UNINITIALIZED_WINDOW_ID_VALUE = "uninitializedWindowId";
private static final String WINDOW_ID_REPLACE_PATTERN = "$$windowIdValue$$";
private static final String NOSCRIPT_URL_REPLACE_PATTERN = "$$noscriptUrl$$";
private static final String NOSCRIPT_PARAMETER = "mfDirect";
private static final String DEFAULT_WINDOW_ID = "default";
return DEFAULT_WINDOW_ID;
ExternalContext externalContext = facesContext.getExternalContext();
if (isNoscriptRequest(externalContext))
{
clientWindowConfig.setJavaScriptEnabled(false);
return DEFAULT_WINDOW_ID;
}
String windowId = getVerifiedWindowIdFromCookie(externalContext);
if (windowId == null)
{
sendWindowHandlerHtml(externalContext, null);
facesContext.responseComplete();
}
private boolean isNoscriptRequest(ExternalContext externalContext)
{
String noscript = externalContext.getRequestParameterMap().get(NOSCRIPT_PARAMETER);
return (noscript != null && "true".equals(noscript));
}
private void sendWindowHandlerHtml(ExternalContext externalContext, String windowId)
{
HttpServletResponse httpResponse = (HttpServletResponse) externalContext.getResponse();
try
{
httpResponse.setStatus(HttpServletResponse.SC_OK);
httpResponse.setContentType("text/html");
String windowHandlerHtml = clientWindowConfig.getClientWindowHtml();
if (windowId == null)
{
windowId = UNINITIALIZED_WINDOW_ID_VALUE;
}
windowHandlerHtml = windowHandlerHtml.replace(WINDOW_ID_REPLACE_PATTERN, windowId);
windowHandlerHtml =
windowHandlerHtml.replace(NOSCRIPT_URL_REPLACE_PATTERN, getNoscriptUrl(externalContext));
OutputStream os = httpResponse.getOutputStream();
try
{
os.write(windowHandlerHtml.getBytes());
}
finally
{
os.close();
}
}
catch (IOException ioe)
{
throw new FacesException(ioe);
}
}
private String getNoscriptUrl(ExternalContext externalContext)
{
String url = externalContext.getRequestPathInfo();
if (url == null)
{
url = "";
}
int lastSlash = url.lastIndexOf('/');
if (lastSlash != -1)
{
}
url = JsfUtils.addPageParameters(externalContext, url, true);
if (url.contains("?"))
{
}
else
{
}
url = url.replace("\"", "");
url = url.replace("\'", "");
return url;
}
private String getVerifiedWindowIdFromCookie(ExternalContext externalContext)
{
Cookie cookie = (Cookie) externalContext.getRequestCookieMap().get(cookieName);
if (cookie != null)
{
cookie.setMaxAge(0);
return cookie.getValue();
}
return null;
}
private String getRequestToken(ExternalContext externalContext)
{
String requestToken = externalContext.getRequestParameterMap().get(DELTASPIKE_REQUEST_TOKEN);
if (requestToken != null)
{
return requestToken;
}
return "";
}
import org.apache.deltaspike.core.api.config.view.controller.InitView;
import org.apache.deltaspike.core.api.config.view.controller.PostRenderView;
import org.apache.deltaspike.core.api.config.view.controller.PreRenderView;
import org.apache.deltaspike.core.api.config.view.metadata.ViewConfigDescriptor;
import org.apache.deltaspike.core.api.config.view.metadata.ViewConfigResolver;
import org.apache.deltaspike.jsf.impl.util.ViewControllerUtils;
import javax.enterprise.context.ContextNotActiveException;
import javax.faces.component.UIViewRoot;
private ViewConfigResolver viewConfigResolver;
if (this.viewConfigResolver == null)
{
lazyInit();
}
processInitView(phaseEvent);
processPreRenderView(facesContext);
if (this.viewConfigResolver == null)
lazyInit();
}
processInitView(phaseEvent);
if (PhaseId.RENDER_RESPONSE.equals(phaseEvent.getPhaseId()))
{
onAfterRenderResponse(phaseEvent.getFacesContext());
private void onAfterRenderResponse(FacesContext facesContext)
processPostRenderView(facesContext);
this.viewConfigResolver = BeanProvider.getContextualReference(ViewConfigResolver.class);
private void processInitView(PhaseEvent event)
{
if (event.getPhaseId().equals(PhaseId.RESTORE_VIEW) && !isRedirectRequest(event.getFacesContext()))
{
return;
}
{
return;
}
FacesContext facesContext = event.getFacesContext();
if (facesContext.getViewRoot() != null && facesContext.getViewRoot().getViewId() != null)
{
processInitView(event.getFacesContext().getViewRoot().getViewId());
}
}
private void processInitView(String viewId)
{
try
{
WindowMetaData windowMetaData = BeanProvider.getContextualReference(WindowMetaData.class);
if (viewId.equals(windowMetaData.getInitializedViewId()))
{
return;
}
windowMetaData.setInitializedViewId(viewId);
ViewConfigDescriptor viewDefinitionEntry = this.viewConfigResolver.getViewConfigDescriptor(viewId);
if (viewDefinitionEntry == null)
{
return;
}
ViewControllerUtils.executeViewControllerCallback(viewDefinitionEntry, InitView.class);
}
catch (ContextNotActiveException e)
{
}
}
private void processPreRenderView(FacesContext facesContext)
{
UIViewRoot uiViewRoot = facesContext.getViewRoot();
if (uiViewRoot != null)
{
ViewConfigDescriptor viewDefinitionEntry =
this.viewConfigResolver.getViewConfigDescriptor(uiViewRoot.getViewId());
ViewControllerUtils.executeViewControllerCallback(viewDefinitionEntry, PreRenderView.class);
}
}
private void processPostRenderView(FacesContext facesContext)
{
UIViewRoot uiViewRoot = facesContext.getViewRoot();
if (uiViewRoot != null)
{
ViewConfigDescriptor viewDefinitionEntry =
this.viewConfigResolver.getViewConfigDescriptor(uiViewRoot.getViewId());
ViewControllerUtils.executeViewControllerCallback(viewDefinitionEntry, PostRenderView.class);
}
}
private boolean isRedirectRequest(FacesContext facesContext)
{
return facesContext.getResponseComplete();
}
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
private final boolean addViewConfigsAsNavigationCase;
this.addViewConfigsAsNavigationCase = this.activated && isAddViewConfigsAsNavigationCaseActivated();
if (!this.addViewConfigsAsNavigationCase)
private boolean isAddViewConfigsAsNavigationCaseActivated()
{
JsfModuleConfig config = BeanProvider.getContextualReference(JsfModuleConfig.class);
return config.isUseViewConfigsAsNavigationCasesEnabled();
}
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
BeanProvider.getContextualReference(JsfModuleConfig.class)
.isAlwaysUseNavigationHandlerOnSecurityViolation())
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
if (PhaseId.RESTORE_VIEW.equals(phaseEvent.getPhaseId()))
{
onAfterRestoreView(phaseEvent.getFacesContext());
}
else if (PhaseId.RENDER_RESPONSE.equals(phaseEvent.getPhaseId()))
private void onAfterRestoreView(FacesContext facesContext)
{
JsfUtils.tryToRestoreMessages(facesContext);
}
import org.apache.deltaspike.jsf.impl.message.FacesMessageEntry;
import java.util.List;
private List<FacesMessageEntry> facesMessageEntryList;
public void setFacesMessageEntryList(List<FacesMessageEntry> facesMessageEntryList)
{
this.facesMessageEntryList = facesMessageEntryList;
}
public List<FacesMessageEntry> getFacesMessageEntryList()
{
return facesMessageEntryList;
}
import org.apache.deltaspike.jsf.impl.message.FacesMessageEntry;
import javax.faces.application.FacesMessage;
import javax.faces.context.ExternalContext;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
private ExternalContext wrappedExternalContext;
if (ClassDeactivationUtils.isActivated(DeltaSpikeExternalContextWrapper.class))
{
this.wrappedExternalContext =
new DeltaSpikeExternalContextWrapper(wrappedFacesContext.getExternalContext());
}
else
{
this.wrappedExternalContext = wrappedFacesContext.getExternalContext();
}
@Override
public void addMessage(String componentId, FacesMessage facesMessage)
{
this.wrappedFacesContext.addMessage(componentId, facesMessage);
Map<String, Object> requestMap = getExternalContext().getRequestMap();
@SuppressWarnings({ "unchecked" })
List<FacesMessageEntry> facesMessageEntryList =
(List<FacesMessageEntry>)requestMap.get(FacesMessageEntry.class.getName());
if (facesMessageEntryList == null)
{
facesMessageEntryList = new CopyOnWriteArrayList<FacesMessageEntry>();
requestMap.put(FacesMessageEntry.class.getName(), facesMessageEntryList);
}
facesMessageEntryList.add(new FacesMessageEntry(componentId, facesMessage));
}
@Override
public ExternalContext getExternalContext()
{
return this.wrappedExternalContext;
}
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
import org.apache.deltaspike.jsf.impl.listener.phase.WindowMetaData;
import org.apache.deltaspike.jsf.impl.message.FacesMessageEntry;
import javax.enterprise.context.ContextNotActiveException;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
public static void saveFacesMessages(ExternalContext externalContext)
{
JsfModuleConfig jsfModuleConfig = BeanProvider.getContextualReference(JsfModuleConfig.class);
if (!jsfModuleConfig.isAlwaysKeepMessages())
{
return;
}
try
{
WindowMetaData windowMetaData = BeanProvider.getContextualReference(WindowMetaData.class);
Map<String, Object> requestMap = externalContext.getRequestMap();
@SuppressWarnings({ "unchecked" })
List<FacesMessageEntry> facesMessageEntryList =
(List<FacesMessageEntry>)requestMap.get(FacesMessageEntry.class.getName());
if (facesMessageEntryList == null)
{
facesMessageEntryList = new CopyOnWriteArrayList<FacesMessageEntry>();
}
windowMetaData.setFacesMessageEntryList(facesMessageEntryList);
}
catch (ContextNotActiveException e)
{
FacesContext.getCurrentInstance().getExternalContext().getFlash().setKeepMessages(true);
}
}
public static void tryToRestoreMessages(FacesContext facesContext)
{
JsfModuleConfig jsfModuleConfig = BeanProvider.getContextualReference(JsfModuleConfig.class);
if (!jsfModuleConfig.isAlwaysKeepMessages())
{
return;
}
try
{
WindowMetaData windowMetaData = BeanProvider.getContextualReference(WindowMetaData.class);
@SuppressWarnings({ "unchecked" })
List<FacesMessageEntry> facesMessageEntryList = windowMetaData.getFacesMessageEntryList();
if (facesMessageEntryList != null)
{
for (FacesMessageEntry facesMessageEntry : facesMessageEntryList)
{
facesContext.addMessage(facesMessageEntry.getComponentId(), facesMessageEntry.getFacesMessage());
}
facesMessageEntryList.clear();
}
}
catch (ContextNotActiveException e)
{
}
}
package org.apache.deltaspike.jsf.impl.component.window;
import javax.faces.component.FacesComponent;
@FacesComponent(WindowIdHolderComponent.COMPONENT_TYPE)
public static final String COMPONENT_TYPE = "org.apache.deltaspike.WindowIdHolder";
import java.util.Map;
import java.util.Random;
public static final String AUTOMATED_ENTRY_POINT_PARAMETER_KEY = "automatedEntryPoint";
public static final String DELTASPIKE_WINDOW_ID_PARAM = "windowId";
public static final String DELTASPIKE_WINDOW_ID_POST_PARAM = "dsPostWindowId";
boolean newWindowIdRequested = false;
if (AUTOMATED_ENTRY_POINT_PARAMETER_KEY.equals(windowId))
{
windowId = generateNewWindowId();
newWindowIdRequested = true;
}
if (windowId == null || newWindowIdRequested)
sendWindowHandlerHtml(externalContext, windowId);
private String generateNewWindowId()
{
}
Map<String, String> requestParams = facesContext.getExternalContext().getRequestParameterMap();
String windowId = requestParams.get(DELTASPIKE_WINDOW_ID_POST_PARAM);
return windowId;
@ResourceDependency(library = "deltaspike", name = "windowhandler.js", target = "head"),
if (!FacesContext.getCurrentInstance().getResponseComplete())
{
this.wrapped.execute(facesContext);
}
return "page2?faces-redirect=true";
import org.apache.deltaspike.core.api.config.DeltaSpikeConfig;
public class JsfModuleConfig implements DeltaSpikeConfig
private static final long serialVersionUID = -487295181899986237L;
import org.apache.deltaspike.core.api.config.view.metadata.ViewMetaData;
import javax.enterprise.inject.Stereotype;
inheritedAnnotations.addAll(addViewMetaData(currentClass));
inheritedAnnotations.addAll(addViewMetaData(viewConfigNode.getSource()));
private List<Annotation> addViewMetaData(Class currentClass)
{
List<Annotation> result = new ArrayList<Annotation>();
for (Annotation annotation : currentClass.getAnnotations())
{
Class<? extends Annotation> annotationClass = annotation.annotationType();
if (annotationClass.getName().startsWith("java"))
{
continue;
}
if (annotationClass.isAnnotationPresent(ViewMetaData.class))
{
result.add(annotation);
}
else if (annotationClass.isAnnotationPresent(Stereotype.class))
{
for (Annotation inheritedViaStereotype : annotationClass.getAnnotations())
{
if (inheritedViaStereotype.annotationType().isAnnotationPresent(ViewMetaData.class))
{
result.add(inheritedViaStereotype);
}
}
}
}
return result;
}
import java.net.URL;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
private static Boolean isWeld1Detected = false;
protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery, BeanManager beanManager)
isWeld1Detected = isWeld1(beanManager);
if (isGlobalAlternativeActivated && isWeld1Detected)
activateGlobalAlternativesWeld1(processAnnotatedType, beanManager);
private void activateGlobalAlternativesWeld1(ProcessAnnotatedType processAnnotatedType,
BeanManager beanManager)
private boolean isWeld1(BeanManager beanManager)
if (beanManager.getClass().getName().startsWith("org.apache"))
return false;
}
if (beanManager.getClass().getName().startsWith("org.jboss.weld"))
{
String version = getJarVersion(beanManager.getClass());
if (version != null && version.startsWith("1."))
private static String getJarVersion(Class targetClass)
{
String manifestFileLocation = getManifestFileLocationOfClass(targetClass);
try
{
return new Manifest(new URL(manifestFileLocation).openStream())
.getMainAttributes().getValue(Attributes.Name.SPECIFICATION_VERSION);
}
catch (Exception e)
{
return null;
}
}
private static String getManifestFileLocationOfClass(Class targetClass)
{
String manifestFileLocation;
try
{
manifestFileLocation = getManifestLocation(targetClass);
}
catch (Exception e)
{
manifestFileLocation = getManifestLocation(targetClass.getSuperclass());
}
return manifestFileLocation;
}
private static String getManifestLocation(Class targetClass)
{
String manifestFilePath = "/META-INF/MANIFEST.MF";
}
import javax.enterprise.context.Dependent;
import javax.inject.Inject;
@Dependent
@Typed(MessageContext.class)
@Inject
@Inject
@Inject
import javax.enterprise.context.Dependent;
import javax.inject.Inject;
@Dependent
@Inject
private MessageContext baseMessageContext = null;
messageContext = baseMessageContext.clone();
import javax.enterprise.context.Dependent;
@Dependent
Object produceTypedMessageBundle(InjectionPoint injectionPoint, MessageBundleInvocationHandler handler)
return createMessageBundleProxy(ReflectionUtils.getRawType(injectionPoint.getType()), handler);
private <T> T createMessageBundleProxy(Class<T> type, MessageBundleInvocationHandler handler)
new Class<?>[]{type}, handler));
Class<? extends ConfigDescriptorValidator>[] configDescriptorValidators()
default { };
import org.apache.deltaspike.core.spi.config.view.ConfigDescriptorValidator;
ViewConfigInheritanceStrategy inheritanceStrategy,
List<ConfigDescriptorValidator> configDescriptorValidators)
for (ConfigDescriptorValidator validator : configDescriptorValidators)
{
if (!validator.isValid(currentConfigDescriptor))
{
}
}
import org.apache.deltaspike.core.spi.config.view.ConfigDescriptorValidator;
import java.util.ArrayList;
List<ConfigDescriptorValidator> configDescriptorValidators = new ArrayList<ConfigDescriptorValidator>();
configDescriptorValidators = createCustomConfigDescriptorValidators(viewConfigRoot);
this.viewConfigResolver = createCustomViewConfigResolver(
viewConfigRoot, configNodeConverter, inheritanceStrategy, configDescriptorValidators);
this.rootViewConfigNode, configNodeConverter, inheritanceStrategy, configDescriptorValidators);
ViewConfigInheritanceStrategy inheritanceStrategy,
List<ConfigDescriptorValidator> validators)
ViewConfigNode.class,
ConfigNodeConverter.class,
ViewConfigInheritanceStrategy.class,
List.class});
.newInstance(this.rootViewConfigNode, configNodeConverter, inheritanceStrategy, validators);
throw ExceptionUtils.throwAsRuntimeException(e);
throw ExceptionUtils.throwAsRuntimeException(e);
throw ExceptionUtils.throwAsRuntimeException(e);
private List<ConfigDescriptorValidator> createCustomConfigDescriptorValidators(ViewConfigRoot viewConfigRoot)
{
List<ConfigDescriptorValidator> result = new ArrayList<ConfigDescriptorValidator>();
for (Class<? extends ConfigDescriptorValidator> validatorClass : viewConfigRoot.configDescriptorValidators())
{
try
{
ConfigDescriptorValidator validator = validatorClass.newInstance();
result.add(validator);
}
catch (Exception e)
{
throw ExceptionUtils.throwAsRuntimeException(e);
}
}
return result;
}
import org.apache.deltaspike.core.spi.config.view.ConfigDescriptorValidator;
import java.util.ArrayList;
new FolderConfigNode(
null, null, new HashSet<Annotation>()), null, null, new ArrayList<ConfigDescriptorValidator>());
if (i == 0 && arg != null && MessageContext.class.isAssignableFrom(arg.getClass()))
if (arg == null)
{
arguments.add("'null'");
}
else if (arg instanceof Serializable)
if (args != null && args.length > 0 &&  args[0] != null &&
if (bmpSingleton == null)
{
return;
}
import org.apache.deltaspike.core.impl.message.MessageBundleInvocationHandler;
private final String clientId;
private final Class<T> type;
private final MessageBundleInvocationHandler invocationHandler;
public DefaultJsfMessage(Class<T> type, String clientId, MessageBundleInvocationHandler invocationHandler)
this.invocationHandler = invocationHandler;
return new DefaultJsfMessage<T>(type, clientId, invocationHandler);
new Class<?>[]{type}, new JsfMessageBundleInvocationHandler(severity, clientId, invocationHandler)));
import javax.enterprise.inject.Typed;
import java.lang.reflect.InvocationHandler;
@Typed()
public class JsfMessageBundleInvocationHandler implements InvocationHandler
private final FacesMessage.Severity severity;
private final String clientId;
private final MessageBundleInvocationHandler invocationHandler;
public JsfMessageBundleInvocationHandler(FacesMessage.Severity severity, String clientId,
MessageBundleInvocationHandler invocationHandler)
this.invocationHandler = invocationHandler;
Object message = invocationHandler.invoke(proxy, method, args);
import org.apache.deltaspike.core.impl.message.MessageBundleInvocationHandler;
public <M> JsfMessage<M> createJsfMessage(InjectionPoint injectionPoint,
MessageBundleInvocationHandler invocationHandler)
return createJsfMessageFor(injectionPoint, type, invocationHandler);
private <M> JsfMessage<M> createJsfMessageFor(InjectionPoint injectionPoint, Class<M> rawType,
MessageBundleInvocationHandler invocationHandler)
return new DefaultJsfMessage<M>(rawType, null, invocationHandler);
import java.util.Map;
void boot(Map<?,?> properties);
boot(null);
}
@Override
public synchronized void boot(Map<?, ?> properties)
{
openEjbContainer = EJBContainer.createEJBContainer(properties);
import java.util.Map;
public void boot(Map<?, ?> properties)
{
boot();
}
@Override
import java.util.Map;
public void boot(Map<?, ?> properties)
{
boot();
}
@Override
import org.apache.deltaspike.cdise.api.CdiContainer;
import org.apache.deltaspike.cdise.api.ContextControl;
import org.apache.openejb.OpenEjbContainer;
import org.apache.openejb.core.LocalInitialContext;
import org.apache.openejb.core.LocalInitialContextFactory;
import org.apache.webbeans.config.WebBeansContext;
import javax.naming.Context;
import javax.naming.InitialContext;
import java.util.Properties;
private static final Properties PROPERTIES = new Properties();
static
{
PROPERTIES.setProperty(Context.INITIAL_CONTEXT_FACTORY, LocalInitialContextFactory.class.getName());
PROPERTIES.setProperty(LocalInitialContext.ON_CLOSE, LocalInitialContext.Close.DESTROY.name());
try
{
OpenEjbContainerControl.class.getClassLoader().loadClass("org.apache.openejb.server.ServiceManager");
PROPERTIES.setProperty(OpenEjbContainer.OPENEJB_EMBEDDED_REMOTABLE, "true");
}
catch (final Exception e)
{
}
}
private Context context = null;
if (context == null)
final Properties p = new Properties();
p.putAll(PROPERTIES);
{
p.putAll(properties);
}
context = new InitialContext(p);
catch (final NamingException e)
throw new RuntimeException(e);
beanManager = WebBeansContext.currentInstance().getBeanManagerImpl();
if (context != null)
try
{
context.close();
}
catch (final NamingException e)
{
}
context = null;
import java.util.HashMap;
import java.util.Map;
private static final String GLOBAL_ALTERNATIVES = "globalAlternatives.";
private static final Logger LOG = Logger.getLogger(ExcludeExtension.class.getName());
private Map<String, String> globalAlternatives = new HashMap<String, String>();
isGlobalAlternativeActivated =
ClassDeactivationUtils.isActivated(GlobalAlternative.class);
if (isGlobalAlternativeActivated)
{
Map<String, String> allProperties = ConfigResolver.getAllProperties();
for (Map.Entry<String, String> property : allProperties.entrySet())
{
if (property.getKey().startsWith(GLOBAL_ALTERNATIVES))
{
String interfaceName = property.getKey().substring(GLOBAL_ALTERNATIVES.length());
String implementation = property.getValue();
if (LOG.isLoggable(Level.FINE))
{
}
globalAlternatives.put(interfaceName, implementation);
}
}
if (globalAlternatives.isEmpty())
{
isGlobalAlternativeActivated = false;
}
}
if (isGlobalAlternativeActivated)
activateGlobalAlternatives(processAnnotatedType, beanManager);
private void activateGlobalAlternatives(ProcessAnnotatedType processAnnotatedType,
BeanManager beanManager)
configuredBeanName = globalAlternatives.get(currentType.getName());
return false;
try
{
NameClassPair binding = enumeration.nextElement();
Name bindingName = nameParser.parse(name).add(binding.getName());
result.put(binding.getName(), lookup(bindingName, type));
}
catch (NamingException e)
{
if (LOG.isLoggable(Level.FINEST))
{
LOG.log(Level.FINEST, "InitialContext#list failed!", e);
}
}
" or failuring listing pairs.",e);
import org.apache.deltaspike.core.api.projectstage.ProjectStage;
import org.apache.deltaspike.core.util.ProjectStageProducer;
private static volatile ProjectStage projectStage = null;
public static String getProjectStageAwarePropertyValue(String key, String defaultValue)
{
ProjectStage ps = getProjectStage();
if (value == null)
{
value = getPropertyValue(key, defaultValue);
}
return value;
}
private static ProjectStage getProjectStage()
{
if (projectStage == null)
{
synchronized (ConfigResolver.class)
{
projectStage = ProjectStageProducer.getInstance().getProjectStage();
}
}
return projectStage;
}
public static String getProjectStageAwarePropertyValue(String key)
{
ProjectStage ps = getProjectStage();
if (value == null)
{
value = getPropertyValue(key);
}
return value;
}
String value = getProjectStageAwarePropertyValue(key);
if (value == null || value.length() == 0)
{
value = defaultValue;
}
return value;
}
public static String getPropertyAwarePropertyValue(String key, String property)
{
String propertyValue = getProjectStageAwarePropertyValue(property);
String value = null;
if (propertyValue != null && propertyValue.length() > 0)
{
}
value = getProjectStageAwarePropertyValue(key);
}
return value;
}
public static String getPropertyAwarePropertyValue(String key, String property, String defaultValue)
{
String value = getPropertyAwarePropertyValue(key, property);
if (value == null || value.length() == 0)
{
value = defaultValue;
validateInvocationHandler(beanClass, bindingAnnotationClass);
Bean partialBean = createPartialBean(
partialBeanEntry.getKey(), partialBeanEntry.getValue(), afterBeanDiscovery, beanManager);
AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
afterBeanDiscovery.addDefinitionError(new IllegalStateException("A class which implements "
PartialBeanLifecycle beanLifecycle =
new PartialBeanLifecycle(beanClass, invocationHandlerClass, afterBeanDiscovery, beanManager);
if (!beanLifecycle.isValid())
{
return null;
}
.beanLifecycle(beanLifecycle);
Class<? extends Annotation> bindingAnnotationClass)
import javax.enterprise.inject.spi.AfterBeanDiscovery;
private final boolean valid;
PartialBeanLifecycle(Class<T> partialBeanClass, Class<H> handlerClass,
AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
if (proxyFactory == null)
{
afterBeanDiscovery.addDefinitionError(new IllegalStateException(
"For using abstract classes as partial beans,"
"it's needed to add the lib 'javassist' to the classpath."));
partialBeanProxyClass = null;
this.valid = false;
return;
}
this.valid = true;
boolean isValid()
{
return valid;
}
public class ServletEventBridgeFilter extends EventEmitter implements Filter
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
public class ServletEventBridgeListener extends EventEmitter implements ServletContextListener, HttpSessionListener
public void contextInitialized(ServletContextEvent sce)
{
fireEvent(sce.getServletContext(), WebLiteral.INSTANCE, InitializedLiteral.INSTANCE);
}
@Override
public void contextDestroyed(ServletContextEvent sce)
{
fireEvent(sce.getServletContext(), WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
}
@Override
package org.apache.deltaspike.test.servlet.impl.event.request;
public class RequestResponseEventsObserver
RequestResponseHolder.bind(request, response);
fireEvent(request, WebLiteral.INSTANCE, InitializedLiteral.INSTANCE);
fireEvent(response, WebLiteral.INSTANCE, InitializedLiteral.INSTANCE);
try
{
chain.doFilter(request, response);
}
finally
{
fireEvent(request, WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
fireEvent(response, WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
}
RequestResponseHolder.release();
ServletContextHolder.bind(sce.getServletContext());
try
{
fireEvent(sce.getServletContext(), WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
}
finally
{
ServletContextHolder.release();
}
import javax.servlet.ServletContext;
public ServletContext getServletContext()
{
return ServletContextHolder.get();
}
@Produces
@Web
package org.apache.deltaspike.servlet.impl.event;
public class EventBridgeContextListener extends EventEmitter implements ServletContextListener
fireEvent(sce.getServletContext(), WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
package org.apache.deltaspike.servlet.impl.event;
public class EventBridgeFilter extends EventEmitter implements Filter
fireEvent(request, WebLiteral.INSTANCE, InitializedLiteral.INSTANCE);
fireEvent(response, WebLiteral.INSTANCE, InitializedLiteral.INSTANCE);
chain.doFilter(request, response);
fireEvent(request, WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
fireEvent(response, WebLiteral.INSTANCE, DestroyedLiteral.INSTANCE);
package org.apache.deltaspike.servlet.impl.event;
public class EventBridgeSessionListener extends EventEmitter implements HttpSessionListener
package org.apache.deltaspike.servlet.impl.event;
package org.apache.deltaspike.servlet.impl.produce;
package org.apache.deltaspike.servlet.impl.produce;
package org.apache.deltaspike.servlet.impl.produce;
public class RequestResponseHolderFilter implements Filter
chain.doFilter(request, response);
package org.apache.deltaspike.servlet.impl.produce;
package org.apache.deltaspike.servlet.impl.produce;
fireEvent(sce.getServletContext(), InitializedLiteral.INSTANCE);
fireEvent(sce.getServletContext(), DestroyedLiteral.INSTANCE);
fireEvent(request, InitializedLiteral.INSTANCE);
fireEvent(response, InitializedLiteral.INSTANCE);
fireEvent(request, DestroyedLiteral.INSTANCE);
fireEvent(response, DestroyedLiteral.INSTANCE);
fireEvent(se.getSession(), InitializedLiteral.INSTANCE);
fireEvent(se.getSession(), DestroyedLiteral.INSTANCE);
public void contextInitialized(@Observes @Initialized ServletContext context)
public void contextDestroyed(@Observes @Destroyed ServletContext context)
public void requestInitialized(@Observes @Initialized HttpServletRequest request)
public void responseInitialized(@Observes @Initialized HttpServletResponse response)
public void requestDestroyed(@Observes @Destroyed HttpServletRequest request)
public void responseDestroyed(@Observes @Destroyed HttpServletResponse response)
public void sessionInitialized(@Observes @Initialized HttpSession session)
public void sessionDestroyed(@Observes @Destroyed HttpSession session)
resolvedInst = BeanProvider.getContextualReference(validatorClass,true);
String value = getPropertyValue(key);
return fallbackToDefaultIfEmpty(key, value, defaultValue);
return fallbackToDefaultIfEmpty(key, value, defaultValue);
return fallbackToDefaultIfEmpty(key, value, defaultValue);
private static String fallbackToDefaultIfEmpty(String key, String value, String defaultValue)
{
if (value == null || value.length() == 0)
{
LOG.log(Level.FINE, "no configured value found for key {0}, using default value {1}.",
new Object[]{key, defaultValue});
return defaultValue;
}
return value;
}
configuredValue = ConfigResolver.getProjectStageAwarePropertyValue(propertyName);
configuredValue = ConfigResolver.getProjectStageAwarePropertyValue(propertyName, defaultValue);
return ConfigResolver.getProjectStageAwarePropertyValue(key);
import javax.enterprise.inject.spi.BeanManager;
private volatile BeanManager beanManager;
getBeanManager().fireEvent(event, qualifier);
}
protected BeanManager getBeanManager()
{
if (beanManager == null)
{
synchronized (this)
{
if (beanManager == null)
{
beanManager = BeanManagerProvider.getInstance().getBeanManager();
}
}
}
return beanManager;
import org.apache.deltaspike.core.util.ClassUtils;
ClassLoader classLoader = ClassUtils.getClassLoader(null);
ClassLoader classLoader = ClassUtils.getClassLoader(null);
ClassLoader classLoader = ClassUtils.getClassLoader(null);
import org.apache.deltaspike.core.spi.config.ConfigFilter;
private static Map<ClassLoader, List<ConfigFilter>> configFilters
= new ConcurrentHashMap<ClassLoader, List<ConfigFilter>>();
public static void addConfigFilter(ConfigFilter configFilter)
{
List<ConfigFilter> currentConfigFilters = getConfigFilters();
currentConfigFilters.add(configFilter);
}
public static List<ConfigFilter> getConfigFilters()
{
ClassLoader cl = ClassUtils.getClassLoader(null);
List<ConfigFilter> currentConfigFilters = configFilters.get(cl);
if (currentConfigFilters == null)
{
currentConfigFilters = new ArrayList<ConfigFilter>();
configFilters.put(cl, currentConfigFilters);
}
return currentConfigFilters;
}
new Object[]{filterConfigValueForLog(key, value), key, configSource.getConfigName()});
return filterConfigValue(key, value);
if (value != null)
value = filterConfigValue(key, value);
if (!result.contains(value))
{
result.add(value);
}
private static String filterConfigValue(String key, String value)
{
List<ConfigFilter> currentConfigFilters = getConfigFilters();
String filteredValue = value;
for (ConfigFilter filter : currentConfigFilters)
{
filteredValue = filter.filterValue(key, filteredValue);
}
return filteredValue;
}
private static String filterConfigValueForLog(String key, String value)
{
List<ConfigFilter> currentConfigFilters = getConfigFilters();
String logValue = value;
for (ConfigFilter filter : currentConfigFilters)
{
logValue = filter.filterValueForLog(key, logValue);
}
return logValue;
}
return ResourceBundle.getBundle(bundleName, locale, ClassUtils.getClassLoader(null));
}
import javax.inject.Inject;
@Inject
private ExceptionControlExtension exceptionControlExtension;
package org.apache.deltaspike.beanValidation.impl;
package org.apache.deltaspike.beanValidation.test;
package org.apache.deltaspike.beanValidation.test;
package org.apache.deltaspike.beanValidation.test;
package org.apache.deltaspike.beanValidation.test;
package org.apache.deltaspike.beanValidation.test;
while (nodeClass != null)
treePath.add(0, nodeClass);
nodeClass = nodeClass.getEnclosingClass();
import org.apache.deltaspike.core.api.config.ConfigResolver;
String customPreProcessorClassName = ConfigResolver.getPropertyValue(preProcessorClass.getName(), null);
if (customPreProcessorClassName != null)
{
Class<? extends ConfigPreProcessor> customPreProcessorClass =
ClassUtils.tryToLoadClassForName(customPreProcessorClassName, ConfigPreProcessor.class);
if (customPreProcessorClass != null)
{
preProcessorClass = customPreProcessorClass;
}
else
{
}
}
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
if (method.getDeclaringClass().equals(Object.class))
{
if ("hashCode".equals(method.getName()))
{
return proxy.getClass().hashCode();
}
if ("toString".equals(method.getName()))
{
return proxy.getClass().toString();
}
if ("equals".equals(method.getName()))
{
return proxy.getClass().equals(args[0].getClass());
}
return null;
}
public static <T> DependentProvider<T> getDependent(Class<T> type, Annotation... qualifiers)
{
BeanManager beanManager = getBeanManager();
Set<Bean<?>> beans = beanManager.getBeans(type, qualifiers);
Bean<?> bean = beanManager.resolve(beans);
return createDependentProvider(beanManager, type, (Bean<T>) bean);
}
public static <T> DependentProvider<T> getDependent(String name)
{
BeanManager beanManager = getBeanManager();
Set<Bean<?>> beans = beanManager.getBeans(name);
Bean<?> bean = beanManager.resolve(beans);
Class beanClass = bean.getBeanClass();
return createDependentProvider(beanManager, (Class<T>) beanClass, (Bean<T>) bean);
}
private static <T> DependentProvider<T> createDependentProvider(BeanManager beanManager, Class<T> type,
Bean<T> bean)
{
CreationalContext<T> cc = beanManager.createCreationalContext(bean);
T instance = (T) beanManager.getReference(bean, type, cc);
return new DependentProvider<T>(bean, cc, instance);
}
if (!isParentBeanManagerBooted())
{
LOG.warning("When using the BeanManager to retrieve Beans before the Container is started,"
" non-portable behaviour results!");
bmi.booted = true;
}
synchronized (bmi)
private boolean isParentBeanManagerBooted()
{
ClassLoader classLoader = ClassUtils.getClassLoader(null);
BeanManagerInfo parentBmi = getParentBeanManagerInfo(classLoader);
return parentBmi != null && parentBmi.booted;
}
private BeanManagerInfo getParentBeanManagerInfo(ClassLoader classLoader)
{
ClassLoader parentClassLoader = classLoader.getParent();
if (parentClassLoader.equals(ClassLoader.getSystemClassLoader()))
{
return null;
}
BeanManagerInfo bmi = getBeanManagerInfo(parentClassLoader);
if (bmi == null)
{
bmi = getParentBeanManagerInfo(parentClassLoader);
}
return bmi;
}
private <T> Bean<T> createMessageBundleBean(Bean<Object> delegate,
AnnotatedType<T> annotatedType,
BeanManager beanManager)
beanBuilder.passivationCapable(true);
import javax.enterprise.inject.spi.PassivationCapable;
import java.io.IOException;
import java.io.NotSerializableException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
public class DependentProvider<T> implements Provider<T>, Serializable
private static final long serialVersionUID = 23423413412001L;
private transient Bean<T> bean;
private void writeObject(ObjectOutputStream out) throws IOException
{
if (!(bean instanceof PassivationCapable))
{
}
String passivationId = ((PassivationCapable) bean).getId();
if (passivationId == null)
{
throw new NotSerializableException(bean.toString());
}
out.writeLong(serialVersionUID);
out.writeObject(passivationId);
out.writeObject(instance);
out.writeObject(creationalContext);
}
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
{
long oldSerialId = in.readLong();
if (oldSerialId != serialVersionUID)
{
}
String passivationId = (String) in.readObject();
bean = (Bean<T>) BeanManagerProvider.getInstance().getBeanManager().getPassivationCapableBean(passivationId);
instance = (T) in.readObject();
creationalContext = (CreationalContext<T>) in.readObject();
}
package org.apache.deltaspike.test.utils;
import javax.enterprise.inject.Typed;
@Typed
public JsfMessage createJsfMessage(InjectionPoint injectionPoint,
MessageBundleInvocationHandler invocationHandler)
Class<?> type = (Class<?>) actualTypes[0];
.addPackages(true, "org.apache.deltaspike.test.category")
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class EventBridgeContextListener extends EventEmitter implements ServletContextListener, Deactivatable
private final boolean activated;
public EventBridgeContextListener()
{
this.activated = ClassDeactivationUtils.isActivated(getClass());
}
if (activated)
{
fireEvent(sce.getServletContext(), InitializedLiteral.INSTANCE);
}
if (activated)
{
fireEvent(sce.getServletContext(), DestroyedLiteral.INSTANCE);
}
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class EventBridgeFilter extends EventEmitter implements Filter, Deactivatable
private final boolean activated;
public EventBridgeFilter()
{
this.activated = ClassDeactivationUtils.isActivated(getClass());
}
if (activated)
{
fireEvent(request, InitializedLiteral.INSTANCE);
fireEvent(response, InitializedLiteral.INSTANCE);
}
if (activated)
{
fireEvent(request, DestroyedLiteral.INSTANCE);
fireEvent(response, DestroyedLiteral.INSTANCE);
}
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class EventBridgeSessionListener extends EventEmitter implements HttpSessionListener, Deactivatable
private final boolean activated;
public EventBridgeSessionListener()
{
this.activated = ClassDeactivationUtils.isActivated(getClass());
}
if (activated)
{
fireEvent(se.getSession(), InitializedLiteral.INSTANCE);
}
if (activated)
{
fireEvent(se.getSession(), DestroyedLiteral.INSTANCE);
}
public <M> JsfMessage<M> createJsfMessage(InjectionPoint injectionPoint,
Class<M> type = (Class<M>) actualTypes[0];
public class EventBridgeContextListener extends EventEmitter implements ServletContextListener
if (isActivated())
if (isActivated())
public class EventBridgeFilter extends EventEmitter implements Filter
if (isActivated())
if (isActivated())
public class EventBridgeSessionListener extends EventEmitter implements HttpSessionListener
if (isActivated())
if (isActivated())
import javax.enterprise.inject.spi.BeanManager;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
abstract class EventEmitter implements Deactivatable
private final boolean activated;
public EventEmitter()
{
this.activated = ClassDeactivationUtils.isActivated(getClass());
}
protected boolean isActivated()
{
return activated;
}
import java.util.Set;
import javax.enterprise.context.Dependent;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.data.impl.util.bean.BeanDestroyable;
private BeanManager beanManager;
DelegateQueryHandler delegate = selectDelegate(context);
private DelegateQueryHandler selectDelegate(CdiQueryInvocationContext context)
Set<Bean<DelegateQueryHandler>> beans = BeanProvider
.getBeanDefinitions(DelegateQueryHandler.class, true, true);
for (Bean<DelegateQueryHandler> bean : beans)
if (contains(bean.getBeanClass(), context.getMethod()))
if (bean.getScope().equals(Dependent.class))
{
CreationalContext<DelegateQueryHandler> cc = beanManager.createCreationalContext(bean);
DelegateQueryHandler instance = (DelegateQueryHandler) beanManager.getReference(
bean, DelegateQueryHandler.class, cc);
context.addDestroyable(new BeanDestroyable<DelegateQueryHandler>(bean, instance, cc));
return instance;
}
return (DelegateQueryHandler) BeanProvider.getContextualReference(bean.getBeanClass());
private boolean contains(Class<?> obj, Method method)
private Method extract(Class<?> obj, Method method)
return obj != null ? obj.getMethod(name, method.getParameterTypes()) : null;
Method extract = extract(target.getClass(), method);
import static org.apache.deltaspike.data.impl.meta.MethodType.ANNOTATED;
import static org.apache.deltaspike.data.impl.meta.MethodType.DELEGATE;
import static org.apache.deltaspike.data.impl.meta.MethodType.PARSE;
import java.util.HashMap;
import java.util.Map;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.api.provider.DependentProvider;
import org.apache.deltaspike.data.impl.handler.CdiQueryInvocationContext;
import org.apache.deltaspike.data.impl.meta.MethodType;
import org.apache.deltaspike.data.impl.meta.RepositoryMethod;
import org.apache.deltaspike.data.impl.util.bean.DependentProviderDestroyable;
private static final Map<MethodType, QueryInvocationLiteral> LITERALS =
new HashMap<MethodType, QueryInvocationLiteral>()
{
{
put(ANNOTATED, new QueryInvocationLiteral(ANNOTATED));
put(DELEGATE, new QueryInvocationLiteral(DELEGATE));
put(PARSE, new QueryInvocationLiteral(PARSE));
}
};
public QueryBuilder build(RepositoryMethod method, CdiQueryInvocationContext context)
DependentProvider<QueryBuilder> builder = BeanProvider.getDependent(
QueryBuilder.class, LITERALS.get(method.getMethodType()));
context.addDestroyable(new DependentProviderDestroyable(builder));
return new WrappedQueryBuilder(builder.get());
return builder.get();
context.get().cleanup();
import org.apache.deltaspike.data.impl.util.bean.Destroyable;
private final List<Destroyable> cleanup;
this.cleanup = new LinkedList<Destroyable>();
public void addDestroyable(Destroyable destroyable)
{
cleanup.add(destroyable);
}
public void cleanup()
{
for (Destroyable destroy : cleanup)
{
destroy.destroy();
}
cleanup.clear();
}
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.api.provider.DependentProvider;
DependentProvider<? extends EntityManagerResolver> resolver =
lookupResolver(repository.getEntityManagerResolverClass());
EntityManager result = resolver.get().resolveEntityManager();
resolver.destroy();
private DependentProvider<? extends EntityManagerResolver> lookupResolver(
DependentProvider<? extends EntityManagerResolver> resolver = BeanProvider.getDependent(resolverClass);
return resolver;
QueryBuilder builder = queryBuilder.build(repoMethod, queryContext);
EntityManager result = null;
result = resolver.get().resolveEntityManager();
else
{
result = entityManager.get();
}
if (repository.hasEntityManagerFlushMode())
{
result.setFlushMode(repository.getEntityManagerFlushMode());
}
return result;
public boolean hasEntityManagerFlushMode()
{
return entityManagerFlushMode != null;
}
CdiQueryInvocationContext ctx = context.get();
if (ctx != null)
{
ctx.cleanup();
}
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
result = entityManager.select(new DefaultLiteral()).get();
@EntityManagerConfig(entityManagerResolver = SimplisticEntityManagerResolver.class)
public abstract class SimpleRepositoryWithEntityManagerResolver extends AbstractEntityRepository<Simple, Long>
break;
if (".".equals(folderName))
{
}
filterInheritedFolderMetaData(mergedMetaData), node.getCallbackDescriptors());
private List<Annotation> filterInheritedFolderMetaData(List<Annotation> mergedMetaData)
{
List<Annotation> result = new ArrayList<Annotation>();
for (Annotation metaData : mergedMetaData)
{
if (!Folder.class.equals(metaData.annotationType()))
{
result.add(metaData);
}
}
return result;
}
RepositoryComponentsFactory.instance().add(repoClass, beanManager);
public EntityManager lookupFor(final RepositoryComponent repository)
final Class<? extends EntityManagerResolver> emrc = repository.getEntityManagerResolverClass();
if (!repository.isEntityManagerResolverIsNormalScope())
{
final DependentProvider<? extends EntityManagerResolver> resolver = lookupResolver(emrc);
result = resolver.get().resolveEntityManager();
resolver.destroy();
}
else
{
result = BeanProvider.getContextualReference(emrc).resolveEntityManager();
}
return BeanProvider.getDependent(resolverClass);
import java.lang.annotation.Annotation;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
private final boolean entityManagerResolverIsNormalScope;
public RepositoryComponent(Class<?> repoClass, RepositoryEntity entityClass, BeanManager beanManager)
if (entityManagerResolver != null && beanManager != null)
{
final Set<Bean<?>> beans = beanManager.getBeans(entityManagerResolver);
final Class<? extends Annotation> scope = beanManager.resolve(beans).getScope();
entityManagerResolverIsNormalScope = beanManager.isNormalScope(scope);
}
else
{
entityManagerResolverIsNormalScope = false;
}
public boolean isEntityManagerResolverIsNormalScope()
{
return entityManagerResolverIsNormalScope;
}
import org.apache.deltaspike.data.impl.RepositoryDefinitionException;
import org.apache.deltaspike.data.impl.meta.extractor.AnnotationMetadataExtractor;
import org.apache.deltaspike.data.impl.meta.extractor.MetadataExtractor;
import org.apache.deltaspike.data.impl.meta.extractor.TypeMetadataExtractor;
import javax.enterprise.inject.spi.BeanManager;
public void add(Class<?> repoClass, BeanManager bm)
RepositoryComponent repo = new RepositoryComponent(repoClass, entityClass, bm);
if (!BeanManagerProvider.getInstance().getBeanManager().isNormalScope(bean.getScope()))
{
bean.destroy(instance, creationalContext);
}
public boolean isContainerManagedConvertersEnabled()
{
return true;
}
public boolean isContainerManagedValidatorsEnabled()
{
return true;
}
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
import org.apache.deltaspike.jsf.impl.injection.InjectionAwareApplicationWrapper;
import javax.faces.application.Application;
private JsfModuleConfig jsfModuleConfig;
public Application getApplication()
{
if (this.jsfModuleConfig == null)
{
this.jsfModuleConfig = BeanProvider.getContextualReference(JsfModuleConfig.class);
}
return new InjectionAwareApplicationWrapper(this.wrappedFacesContext.getApplication(), this.jsfModuleConfig);
}
@Override
Set<Bean<?>> beans = beanManager.getBeans(ContextControl.class);
package org.apache.deltaspike.jsf.api.literal;
import javax.enterprise.util.AnnotationLiteral;
public class ViewScopedLiteral extends AnnotationLiteral<ViewScoped> implements ViewScoped
private static final long serialVersionUID = -6260027440277811767L;
import javax.enterprise.inject.Typed;
@Typed()
return BeanProvider.getContextualReference(converterClass);
return BeanProvider.getContextualReference(validatorClass);
import javax.enterprise.inject.Typed;
@Typed()
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import javax.enterprise.context.Dependent;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import java.io.Serializable;
import java.util.Set;
return getContextualReference(BeanManagerProvider.getInstance().getBeanManager(), converterClass);
return getContextualReference(BeanManagerProvider.getInstance().getBeanManager(), validatorClass);
}
private static <T> T getContextualReference(BeanManager beanManager, Class<T> type)
{
Set<Bean<?>> beans = beanManager.getBeans(type);
if (beans == null || beans.isEmpty())
{
return null;
}
Bean<?> bean = beanManager.resolve(beans);
CreationalContext<?> creationalContext = beanManager.createCreationalContext(bean);
@SuppressWarnings({ "unchecked", "UnnecessaryLocalVariable" })
T result = (T) beanManager.getReference(bean, type, creationalContext);
if (bean.getScope().equals(Dependent.class))
{
AbstractBeanStorage beanStorage;
if (Serializable.class.isAssignableFrom(bean.getBeanClass()))
{
beanStorage = BeanProvider.getContextualReference(ViewDependentBeanStorage.class);
}
else
{
beanStorage = BeanProvider.getContextualReference(RequestDependentBeanStorage.class);
}
beanStorage.add(new DependentBeanEntry(result, bean, creationalContext));
}
return result;
package org.apache.deltaspike.jsf.impl.injection;
import javax.enterprise.context.RequestScoped;
@RequestScoped
public class RequestDependentBeanStorage extends AbstractBeanStorage
package org.apache.deltaspike.jsf.impl.injection;
import java.io.Serializable;
@ViewScoped
public class ViewDependentBeanStorage extends AbstractBeanStorage implements Serializable
private static final long serialVersionUID = 4500399024267716556L;
AbstractBeanStorage beanStorage = BeanProvider.getContextualReference(RequestDependentBeanStorage.class);
AbstractBeanStorage beanStorage = BeanProvider.getContextualReference(RequestDependentBeanStorage.class);
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.jpa.api.transaction.TransactionConfig;
private transient TransactionConfig transactionConfig;
if (this.transactionConfig == null)
{
lazyInit();
}
return transactionConfig.getUserTransactionTimeoutInSeconds();
}
protected synchronized void lazyInit()
{
if (this.transactionConfig != null)
{
return;
}
this.transactionConfig = BeanProvider.getContextualReference(TransactionConfig.class, true);
if (this.transactionConfig == null)
{
this.transactionConfig = createDefaultTransactionConfig();
}
}
protected TransactionConfig createDefaultTransactionConfig()
{
return new TransactionConfig()
{
private static final long serialVersionUID = -3915439087580270117L;
@Override
public Integer getUserTransactionTimeoutInSeconds()
{
return null;
}
};
import java.util.Collections;
import java.util.Comparator;
sortDescending(this.phaseListeners);
}
private static void sortDescending(List<PhaseListener> phaseListeners)
{
Collections.sort(phaseListeners, new Comparator<PhaseListener>()
{
@Override
public int compare(PhaseListener phaseListener1, PhaseListener phaseListener2)
{
return (phaseListener1.getClass().getAnnotation(JsfPhaseListener.class).ordinal() >
phaseListener2.getClass().getAnnotation(JsfPhaseListener.class).ordinal()) ? -1 : 1;
}
});
import org.apache.deltaspike.core.util.ClassUtils;
import javax.faces.context.FacesContext;
public static final String CLIENT_WINDOW_CONFIG_KEY = "javax.faces.CLIENT_WINDOW_MODE";
public static final String CLIENT_WINDOW_CLASS_NAME = "javax.faces.lifecycle.ClientWindow";
public boolean isDelegatedWindowHandlingEnabled()
{
if (ClassUtils.tryToLoadClassForName(CLIENT_WINDOW_CLASS_NAME) == null)
{
return false;
}
String configuredWindowHandling = FacesContext.getCurrentInstance().getExternalContext()
.getInitParameter(CLIENT_WINDOW_CONFIG_KEY);
return !(configuredWindowHandling == null || "none".equalsIgnoreCase(configuredWindowHandling.trim()));
}
DELEGATED,
import javax.annotation.PostConstruct;
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
private static final long serialVersionUID = -708423418378550210L;
private JsfModuleConfig jsfModuleConfig;
@Inject
private boolean useDelegatedWindowHandling;
@PostConstruct
protected void init()
{
this.useDelegatedWindowHandling = this.jsfModuleConfig.isDelegatedWindowHandlingEnabled();
}
if (this.useDelegatedWindowHandling)
{
return ClientWindowRenderMode.DELEGATED;
}
if (this.useDelegatedWindowHandling)
{
return ClientWindowRenderMode.DELEGATED;
}
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.ExceptionUtils;
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
private final boolean jsfVersionWithClientWindowDetected;
this.jsfVersionWithClientWindowDetected =
ClassUtils.tryToLoadClassForName(JsfModuleConfig.CLIENT_WINDOW_CLASS_NAME) != null;
if (this.jsfVersionWithClientWindowDetected)
{
Class<? extends Lifecycle> lifecycleWrapperClass = ClassUtils.tryToLoadClassForName(
"org.apache.deltaspike.jsf.impl.listener.request.JsfClientWindowAwareLifecycleWrapper");
try
{
return lifecycleWrapperClass.getConstructor(new Class[] { Lifecycle.class })
.newInstance(new DeltaSpikeLifecycleWrapper(result));
}
catch (Exception e)
{
throw ExceptionUtils.throwAsRuntimeException(e);
}
}
Lifecycle getWrapped()
{
return wrapped;
}
if (facesContext.getResponseComplete())
{
return;
}
public static final String JSF_WINDOW_ID_POST_PARAM = "javax.faces.ClientWindow";
ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(facesContext);
if (ClientWindowRenderMode.NONE.equals(clientWindowRenderMode))
if (ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))
{
return ClientWindowAdapter.getWindowIdFromJsf(facesContext);
}
if (windowId == null)
{
windowId = requestParams.get(JSF_WINDOW_ID_POST_PARAM);
}
<X> void processAnnotatedType(@Observes ProcessAnnotatedType<X> event)
RepositoryComponentsFactory.instance().add(repoClass);
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
private volatile Boolean entityManagerResolverIsNormalScope;
public RepositoryComponent(Class<?> repoClass, RepositoryEntity entityClass)
}
private void lazyInit()
{
if (entityManagerResolverIsNormalScope == null)
{
init(BeanManagerProvider.getInstance().getBeanManager());
}
}
private synchronized void init(BeanManager beanManager)
{
if (entityManagerResolverIsNormalScope != null)
{
return;
}
lazyInit();
lazyInit();
public void add(Class<?> repoClass)
RepositoryComponent repo = new RepositoryComponent(repoClass, entityClass);
import java.lang.annotation.Annotation;
import java.util.Iterator;
import java.util.Set;
Folder result = new FolderLiteral(name, folder.folderNameBuilder());
updateNodeMetaData(viewConfigNode, result);
return result;
private void updateNodeMetaData(ViewConfigNode viewConfigNode, Folder folder)
{
Set<Annotation> metaData = viewConfigNode.getMetaData();
Iterator<? extends Annotation> metaDataIterator = metaData.iterator();
while (metaDataIterator.hasNext())
{
if (Folder.class.equals(metaDataIterator.next().annotationType()))
{
metaDataIterator.remove();
break;
}
}
metaData.add(folder);
}
this.defaultValueReplaced = true;
if (name != null && !name.startsWith(".") && !name.startsWith("/"))
{
this.defaultValueReplaced = true;
}
if (name != null && !name.endsWith("/"))
{
this.defaultValueReplaced = true;
}
import java.lang.annotation.Annotation;
import java.util.Iterator;
import java.util.Set;
View result = new ViewLiteral(basePath, name, extension, navigation, viewParams,
updateNodeMetaData(viewConfigNode, result);
return result;
private void updateNodeMetaData(ViewConfigNode viewConfigNode, View view)
{
Set<Annotation> metaData = viewConfigNode.getMetaData();
Iterator<? extends Annotation> metaDataIterator = metaData.iterator();
while (metaDataIterator.hasNext())
{
if (View.class.equals(metaDataIterator.next().annotationType()))
{
metaDataIterator.remove();
break;
}
}
metaData.add(view);
}
if (basePath != null && !basePath.startsWith(".") && !basePath.startsWith("/"))
{
this.defaultValueReplaced = true;
}
if (basePath != null && !basePath.endsWith("/"))
{
this.defaultValueReplaced = true;
}
@View(basePath = "w1b")
class Step7 implements ViewConfig
{
}
@View(basePath = "w2b")
class Step7 implements ViewConfig
{
}
@View(basePath = "/")
class Step2 implements ViewConfig
{
}
@View(basePath = "/")
class Step2 implements ViewConfig
{
}
@View(basePath = "w11b")
class Step7 implements ViewConfig
{
}
@View(basePath = "w12b")
class Step7 implements ViewConfig
{
}
@View(basePath = "w13b")
class Step7 implements ViewConfig
{
}
String className = viewConfigClass.getName();
if (!className.contains("."))
{
if (className.contains("$"))
{
className = className.substring(0, className.indexOf("$"));
}
}
class SimpleSecurityViolation implements SecurityViolation
private static final long serialVersionUID = -5017812464381395966L;
private final String reason;
SimpleSecurityViolation(String reason)
import org.apache.deltaspike.core.api.config.PropertyLoader;
if (unitProperties == null)
{
unitProperties = new Properties();
}
import org.apache.deltaspike.data.api.QueryResult;
import org.apache.deltaspike.data.api.mapping.QueryInOutMapper;
@SuppressWarnings("unchecked")
public Object executeQuery(CdiQueryInvocationContext context)
{
Object result = execute(context);
if (!isUnmappableResult(result) && context.hasQueryInOutMapper())
{
QueryInOutMapper<Object> mapper = (QueryInOutMapper<Object>)
context.getQueryInOutMapper();
if (result instanceof List)
{
return mapper.mapResultList((List<Object>) result);
}
return mapper.mapResult(result);
}
return result;
}
protected abstract Object execute(CdiQueryInvocationContext ctx);
private boolean isUnmappableResult(Object result)
{
return result instanceof QueryResult ||
result instanceof Query;
}
return ((Query) builder.executeQuery(context)).getResultList();
return (T) ((Query) builder.executeQuery(context)).getSingleResult();
Long result = (Long) ((Query) builder.executeQuery(context)).getSingleResult();
import org.apache.deltaspike.data.api.mapping.QueryInOutMapper;
public void init()
{
if (hasQueryInOutMapper())
{
QueryInOutMapper<?> mapper = getQueryInOutMapper();
params.applyMapper(mapper);
{
if (mapper.mapsParameter(args[i]))
{
args[i] = mapper.mapParameter(args[i]);
}
}
}
}
public boolean hasQueryInOutMapper()
{
return repoMethod.hasQueryInOutMapper();
}
public QueryInOutMapper<?> getQueryInOutMapper()
{
return repoMethod.getQueryInOutMapperInstance(this);
}
Object result = builder.executeQuery(queryContext);
queryContext.init();
import java.lang.annotation.Annotation;
import java.util.Set;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.api.provider.DependentProvider;
import org.apache.deltaspike.data.api.mapping.MappingConfig;
import org.apache.deltaspike.data.api.mapping.QueryInOutMapper;
import org.apache.deltaspike.data.impl.handler.CdiQueryInvocationContext;
import org.apache.deltaspike.data.impl.util.bean.DependentProviderDestroyable;
private final Class<? extends QueryInOutMapper> mapper;
private volatile Boolean queryInOutMapperIsNormalScope;
this.mapper = extractMapper(method, repo);
public QueryInOutMapper<?> getQueryInOutMapperInstance(CdiQueryInvocationContext context)
{
if (!hasQueryInOutMapper())
{
return null;
}
QueryInOutMapper<?> result = null;
lazyInit();
if (!queryInOutMapperIsNormalScope)
{
final DependentProvider<? extends QueryInOutMapper> mappedProvider = BeanProvider.getDependent(mapper);
result = mappedProvider.get();
context.addDestroyable(new DependentProviderDestroyable(mappedProvider));
}
else
{
result = BeanProvider.getContextualReference(mapper);
}
return result;
}
private Class<? extends QueryInOutMapper> extractMapper(Method queryMethod, RepositoryComponent repoComponent)
{
if (queryMethod.isAnnotationPresent(MappingConfig.class))
{
return queryMethod.getAnnotation(MappingConfig.class).value();
}
if (repoComponent.getRepositoryClass().isAnnotationPresent(MappingConfig.class))
{
return repoComponent.getRepositoryClass().getAnnotation(MappingConfig.class).value();
}
return null;
}
private void lazyInit()
{
if (queryInOutMapperIsNormalScope == null)
{
init(BeanManagerProvider.getInstance().getBeanManager());
}
}
private synchronized void init(BeanManager beanManager)
{
if (queryInOutMapperIsNormalScope != null)
{
return;
}
if (queryInOutMapperIsNormalScope != null && beanManager != null)
{
final Set<Bean<?>> beans = beanManager.getBeans(mapper);
final Class<? extends Annotation> scope = beanManager.resolve(beans).getScope();
queryInOutMapperIsNormalScope = beanManager.isNormalScope(scope);
}
else
{
queryInOutMapperIsNormalScope = false;
}
}
public boolean hasQueryInOutMapper()
{
return mapper != null;
}
query.setParameter(index, queryValue());
query.setParameter(name, queryValue());
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.deltaspike.data.api.mapping.QueryInOutMapper;
private static final Logger LOG = Logger.getLogger(Parameter.class.getName());
protected Object mappedValue = null;
public void applyMapper(QueryInOutMapper<?> mapper)
{
if (mapper.mapsParameter(value))
{
mappedValue = mapper.mapParameter(value);
LOG.log(Level.FINE, "Converting param {0} to {1}", new Object[] { value, mappedValue });
}
}
protected Object queryValue()
{
return mappedValue != null ? mappedValue : value;
}
import org.apache.deltaspike.data.api.mapping.QueryInOutMapper;
public void applyMapper(QueryInOutMapper<?> mapper)
{
for (Parameter param : parameterList)
{
param.applyMapper(mapper);
}
}
@Override
public String toString()
{
}
private Long teeSetId;
private Long holeId;
private Long teeSetId;
private Long holeId;
public static final String[] CONFIG_SETTING_KEYS =
{
"org.apache.deltaspike.ProjectStage",
"javax.faces.PROJECT_STAGE",
"faces.PROJECT_STAGE"
};
for (String configLocation : CONFIG_SETTING_KEYS)
String stageName = ConfigResolver.getPropertyValue(configLocation);
if (stageName != null && !stageName.isEmpty())
{
return ProjectStage.valueOf(stageName);
}
{
"org.apache.deltaspike.ProjectStage",
"javax.faces.PROJECT_STAGE",
"faces.PROJECT_STAGE"
};
SingleResultType singleResult() default SingleResultType.JPA;
E getOptionalResult();
E getAnyResult();
String methodPrefix() default "";
R getOptionalResult();
R getAnyResult();
import org.apache.deltaspike.data.impl.meta.MethodPrefix;
public static final QueryRoot UNKNOWN_ROOT = new QueryRoot("null-object", new MethodPrefix("", null));
private final MethodPrefix methodPrefix;
protected QueryRoot(String entityName, MethodPrefix methodPrefix)
this.methodPrefix = methodPrefix;
public static QueryRoot create(String method, RepositoryComponent repo, MethodPrefix prefix)
QueryRoot root = new QueryRoot(repo.getEntityName(), prefix);
return !methodPrefix.getPrefix().equals(orderByParts[0]);
return methodPrefix.removePrefix(queryPart);
import javax.persistence.NoResultException;
public T getOptionalResult()
{
try
{
return getSingleResult();
}
catch (NoResultException e)
{
return null;
}
}
@Override
public T getAnyResult()
{
List<T> queryResult = getResultList();
return queryResult.size() > 0 ? queryResult.get(0) : null;
}
@Override
import org.apache.deltaspike.data.impl.handler.CdiQueryInvocationContext;
Object executeQuery(Query query, CdiQueryInvocationContext context);
import javax.persistence.NoResultException;
import org.apache.deltaspike.data.api.SingleResultType;
import org.apache.deltaspike.data.impl.handler.CdiQueryInvocationContext;
public Object executeQuery(Query query, CdiQueryInvocationContext context)
public Object executeQuery(Query query, CdiQueryInvocationContext context)
public Object executeQuery(Query query, CdiQueryInvocationContext context)
SingleResultType style = context.getSingleResultStyle();
switch (style)
{
case JPA:
return query.getSingleResult();
case OPTIONAL:
try
{
return query.getSingleResult();
}
catch (NoResultException e)
{
return null;
}
default:
List<Object> queryResult = query.getResultList();
return queryResult.size() > 0 ? queryResult.get(0) : null;
}
public Object executeQuery(Query query, CdiQueryInvocationContext context)
import javax.persistence.NoResultException;
public R getOptionalResult()
{
try
{
return getSingleResult();
}
catch (NoResultException e)
{
return null;
}
}
@Override
public R getAnyResult()
{
List<R> queryResult = getResultList();
return queryResult.size() > 0 ? queryResult.get(0) : null;
}
@Override
import org.apache.deltaspike.data.api.SingleResultType;
return repoMethod.getQueryProcessor().executeQuery(jpaQuery, this);
public SingleResultType getSingleResultStyle()
{
return repoMethod.getSingleResultStyle();
}
import javax.persistence.PersistenceException;
import org.apache.deltaspike.data.api.QueryInvocationException;
catch (PersistenceException e)
{
throw e;
}
log.log(Level.FINEST, "Query execution error", e);
public String getCustomMethodPrefix()
{
return repoClass.getAnnotation(Repository.class).methodPrefix();
}
import org.apache.deltaspike.data.api.SingleResultType;
private final MethodPrefix methodPrefix;
this.methodPrefix = new MethodPrefix(repo.getCustomMethodPrefix(), method.getName());
return QueryRoot.create(method.getName(), repo, methodPrefix);
QueryRoot.create(method.getName(), repo, methodPrefix);
public SingleResultType getSingleResultStyle()
{
if (method.isAnnotationPresent(Query.class))
{
return method.getAnnotation(Query.class).singleResult();
}
return methodPrefix.getSingleResultStyle();
}
public Simple queryOptional(String name)
{
return criteria()
.eq(Simple_.name, name)
.getOptionalResult();
}
public Simple queryAny(String name)
{
return criteria()
.eq(Simple_.name, name)
.getAnyResult();
}
import static javax.persistence.LockModeType.PESSIMISTIC_WRITE;
import static org.apache.deltaspike.data.api.SingleResultType.ANY;
import static org.apache.deltaspike.data.api.SingleResultType.OPTIONAL;
@Query(named = Simple.BY_NAME_LIKE, singleResult = OPTIONAL)
public abstract Simple findByNameOptional(String name);
@Query(named = Simple.BY_NAME_LIKE, singleResult = ANY)
public abstract Simple findByNameAny(String name);
@Query(named = Simple.BY_ID, lock = PESSIMISTIC_WRITE)
public abstract Simple findOptionalByName(String name);
public abstract Simple findAnyByName(String name);
package org.apache.deltaspike.data.api;
import org.apache.deltaspike.data.spi.QueryInvocationContext;
public QueryInvocationException(Throwable t, QueryInvocationContext context)
public QueryInvocationException(String message, QueryInvocationContext context)
private static String createMessage(QueryInvocationContext context)
builder.append("Repository=").append(context.getRepositoryClass().getName()).append(",");
private static String createMessage(QueryInvocationContext context, Throwable t)
private static String createMessage(Class<?> repoClass, Method method, Throwable t)
builder.append("Repository=").append(repoClass).append(",");
import java.lang.reflect.Method;
Class<?> getRepositoryClass();
Method getMethod();
import javax.persistence.PersistenceException;
import org.apache.deltaspike.data.api.QueryInvocationException;
catch (PersistenceException e)
{
throw e;
}
if (e.getCause() != null && e.getCause() instanceof PersistenceException)
{
throw (PersistenceException) e.getCause();
}
throw new QueryInvocationException(e, context);
@Override
public Class<?> getRepositoryClass()
{
return repoMethod.getRepository().getRepositoryClass();
}
@Override
import org.apache.deltaspike.core.api.literal.ViewControllerRefLiteral;
package org.apache.deltaspike.core.api.literal;
import javax.annotation.Resource;
@Resource
private UserTransaction userTransaction;
if (userTransaction != null)
{
return userTransaction;
}
import org.apache.deltaspike.core.api.config.view.metadata.SkipMetaDataMerge;
@SkipMetaDataMerge
import org.apache.deltaspike.core.api.config.view.metadata.SkipMetaDataMerge;
@SkipMetaDataMerge
@SkipMetaDataMerge
import org.apache.deltaspike.core.api.config.view.metadata.SkipMetaDataMerge;
inheritedValue.equals(defaultValue) ||
annotationMethod.isAnnotationPresent(SkipMetaDataMerge.class))
import java.lang.annotation.Annotation;
accessDecisionVoterContext.addMetaData(ViewConfig.class.getName(), viewConfigDescriptor.getConfigClass());
for (Annotation viewMetaData : viewConfigDescriptor.getMetaData())
{
if (!viewMetaData.annotationType().equals(Secured.class))
{
accessDecisionVoterContext.addMetaData(viewMetaData.annotationType().getName(), viewMetaData);
}
}
boolean outermostTransactionAlreadyExisted = false;
else if (isOutermostInterceptor)
{
outermostTransactionAlreadyExisted = true;
}
if (!outermostTransactionAlreadyExisted)
rollbackAllTransactions(entityManagerEntryList);
if (!outermostTransactionAlreadyExisted)
if (firstException == null)
Set<EntityManagerEntry> entityManagerEntryList =
transactionBeanStorage.getUsedEntityManagerEntries();
boolean rollbackOnly = false;
for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
{
EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
if (transaction != null && transaction.isActive())
{
try
{
if (!commitFailed)
currentEntityManagerEntry.getEntityManager().flush();
if (!rollbackOnly && transaction.getRollbackOnly())
{
rollbackOnly = true;
}
catch (Exception e)
{
firstException = e;
commitFailed = true;
break;
}
if (rollbackOnly)
commitFailed = true;
}
for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
{
EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
if (transaction != null && transaction.isActive())
try
if (commitFailed || transaction.getRollbackOnly())
{
transaction.rollback();
}
else
{
transaction.commit();
}
catch (Exception e)
firstException = e;
commitFailed = true;
private void rollbackAllTransactions(Set<EntityManagerEntry> entityManagerEntryList)
{
for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
{
EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
if (transaction != null && transaction.isActive())
{
try
{
transaction.rollback();
}
catch (Exception eRollback)
{
if (LOGGER.isLoggable(Level.SEVERE))
{
LOGGER.log(Level.SEVERE,
"Got additional Exception while subsequently "
"rolling back other SQL transactions", eRollback);
}
}
}
}
}
import org.apache.deltaspike.core.api.config.view.metadata.CallbackDescriptor;
import java.util.List;
import java.util.Map;
getChildren().addAll(nodeToCopy.getChildren());
for (Map.Entry<Class<? extends Annotation>, List<CallbackDescriptor>> callbackDescriptorEntry :
nodeToCopy.getCallbackDescriptors().entrySet())
{
for (CallbackDescriptor callbackDescriptor : callbackDescriptorEntry.getValue())
{
registerCallbackDescriptors(callbackDescriptorEntry.getKey(), callbackDescriptor);
}
}
public class JsfSystemEventBroadcaster implements SystemEventListener, Deactivatable
public JsfSystemEventBroadcaster()
protected List<Annotation> addViewMetaData(Class currentClass)
addViewMetaData(annotation, result);
protected void addViewMetaData(Annotation currentAnnotation, List<Annotation> metaDataList)
{
Class<? extends Annotation> annotationClass = currentAnnotation.annotationType();
if (annotationClass.isAnnotationPresent(ViewMetaData.class))
{
metaDataList.add(currentAnnotation);
}
else if (annotationClass.isAnnotationPresent(Stereotype.class))
{
for (Annotation inheritedViaStereotype : annotationClass.getAnnotations())
{
if (inheritedViaStereotype.annotationType().isAnnotationPresent(ViewMetaData.class))
{
metaDataList.add(inheritedViaStereotype);
}
}
}
}
protected void addInterfaces(Set<Class> processedTypes, Stack<Class> classesToAnalyze, Class nextClass)
import java.lang.annotation.Annotation;
void startScope(Class<? extends Annotation> scopeClass);
void stopScope(Class<? extends Annotation> scopeClass);
public class EventBridgeContextListener extends EventBroadcaster implements ServletContextListener
public class EventBridgeFilter extends EventBroadcaster implements Filter
public class EventBridgeSessionListener extends EventBroadcaster implements HttpSessionListener
abstract class EventBroadcaster implements Deactivatable
public EventBroadcaster()
import javax.faces.application.ConfigurableNavigationHandler;
import javax.faces.application.NavigationHandler;
import java.util.logging.Logger;
private static final Logger LOG = Logger.getLogger(NavigationCaseMapWrapper.class.getName());
private final NavigationHandler wrapped;
public NavigationCaseMapWrapper(Map<String, Set<NavigationCase>> navigationCases, NavigationHandler wrapped)
this.wrapped = wrapped;
Map<String, Set<NavigationCase>> result;
if (this.wrapped instanceof ConfigurableNavigationHandler)
{
result = new DelegatingMap((ConfigurableNavigationHandler)this.wrapped);
}
else
{
LOG.warning("the wrapped navigation-handler doesn't extend "
ConfigurableNavigationHandler.class.getName()
". therefore std. navigation-rules might not work correctly with mojarra");
result = new HashMap<String, Set<NavigationCase>>();
}
private class DelegatingMap extends HashMap<String, Set<NavigationCase>>
{
private static final long serialVersionUID = -955468874397821639L;
private final ConfigurableNavigationHandler wrapped;
private DelegatingMap(ConfigurableNavigationHandler wrapped)
{
this.wrapped = wrapped;
}
@Override
public Set<NavigationCase> put(String key, Set<NavigationCase> value)
{
return this.wrapped.getNavigationCases().put(key, value);
}
@Override
public Set<NavigationCase> get(Object key)
{
Set<NavigationCase> navigationCases = super.get(key);
if (navigationCases == null)
{
navigationCases = new HashSet<NavigationCase>();
put((String)key, navigationCases);
}
return new DelegatingSet(navigationCases, this.wrapped, (String)key);
}
}
private class DelegatingSet extends HashSet<NavigationCase>
{
private static final long serialVersionUID = -7040572530963900394L;
private final ConfigurableNavigationHandler wrapped;
private String navigationCaseKey;
private DelegatingSet(Collection<? extends NavigationCase> c,
ConfigurableNavigationHandler wrapped,
String navigationCaseKey)
{
super(c);
this.wrapped = wrapped;
this.navigationCaseKey = navigationCaseKey;
}
@Override
public boolean add(NavigationCase navigationCase)
{
Set<NavigationCase> navigationCases = this.wrapped.getNavigationCases().get(this.navigationCaseKey);
if (navigationCases == null)
{
navigationCases = new HashSet<NavigationCase>();
this.wrapped.getNavigationCases().put(this.navigationCaseKey, navigationCases);
}
return navigationCases.add(navigationCase);
}
}
return new NavigationCaseMapWrapper(result, this.wrapped);
if (value == null)
{
return null;
}
Set<NavigationCase> result = new HashSet<NavigationCase>();
for (NavigationCase navigationCase : value)
{
if (!(navigationCase.getFromOutcome() == null && navigationCase.getFromAction() == null))
{
result.add(navigationCase);
}
}
return this.wrapped.getNavigationCases().put(key, result);
package org.apache.deltaspike.core.api.resoureloader;
package org.apache.deltaspike.core.api.resoureloader;
package org.apache.deltaspike.core.api.resoureloader;
package org.apache.deltaspike.core.spi.resourceloader;
import org.apache.deltaspike.core.api.resoureloader.ExternalResource;
package org.apache.deltaspike.core.impl.resourceloader;
import org.apache.deltaspike.core.api.resoureloader.ExternalResource;
import org.apache.deltaspike.core.spi.resourceloader.ExternalResourceProvider;
package org.apache.deltaspike.core.impl.resourceloader;
import org.apache.deltaspike.core.api.resoureloader.ExternalResource;
import org.apache.deltaspike.core.api.resoureloader.XMLProperties;
import org.apache.deltaspike.core.spi.resourceloader.ExternalResourceProvider;
package org.apache.deltaspike.core.impl.resourceloader;
import org.apache.deltaspike.core.spi.resourceloader.ExternalResourceProvider;
package org.apache.deltaspike.core.impl.resourceloader;
import org.apache.deltaspike.core.api.resoureloader.ExternalResource;
import org.apache.deltaspike.core.spi.resourceloader.ExternalResourceProvider;
package org.apache.deltaspike.core.impl.resourceloader;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import java.util.logging.Logger;
private static final Logger LOG = Logger.getLogger(ServiceUtils.class.getName());
return loadServiceImplementations(serviceType, false);
}
public static <T> List<T> loadServiceImplementations(Class<T> serviceType,
boolean ignoreServicesWithMissingDependencies)
{
try
{
T service = servicesIterator.next();
if (service instanceof Deactivatable &&
!ClassDeactivationUtils.isActivated((Class<? extends Deactivatable>) service.getClass()))
{
continue;
}
result.add(service);
}
catch (Throwable t)
{
if (!ignoreServicesWithMissingDependencies)
{
throw ExceptionUtils.throwAsRuntimeException(t);
}
else
{
}
}
public void jobToBeExecuted(JobExecutionContext jobExecutionContext)
Scheduled scheduled = jobExecutionContext.getJobInstance().getClass().getAnnotation(Scheduled.class);
if (!this.scopes.isEmpty())
this.contextControl = BeanProvider.getContextualReference(ContextControl.class);
for (Class<? extends Annotation> scopeAnnotation : this.scopes)
{
contextControl.startContext(scopeAnnotation);
}
BeanProvider.injectFields(jobExecutionContext.getJobInstance());
private static final Logger logger = Logger.getLogger(ClasspathResourceProvider.class.getName());
private static final Logger logger = Logger.getLogger(ExternalResourceProducer.class.getName());
package org.apache.deltaspike.core.api.literal;
import org.apache.deltaspike.core.api.resoureloader.ExternalResource;
public static final String JOB_CLASS_CONFIG_KEY = "deltaspike.scheduler.job-class";
String jobClassName = ConfigResolver.getPropertyValue(JOB_CLASS_CONFIG_KEY, "org.quartz.Job");
new String[]{"org.apache.deltaspike.core",
"org.apache.deltaspike.test.category",
"org.apache.deltaspike.scheduler"},
new String[]{"org.apache.deltaspike.core",
"org.apache.deltaspike.test.category",
"org.apache.deltaspike.partialbean"}, excludedFiles);
new String[]{"org.apache.deltaspike.core",
"org.apache.deltaspike.test.category",
"org.apache.deltaspike.security"}, excludedFiles);
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
import org.apache.deltaspike.core.api.config.view.ViewRef;
if (isInternal(viewConfigClass))
{
return;
}
private boolean isInternal(Class configClass)
{
return ViewConfig.class.equals(configClass) ||
DefaultErrorView.class.equals(configClass) ||
ViewRef.Manual.class.equals(configClass);
}
catch (Exception e)
private String storage;
private String location;
public ExternalResourceLiteral(final String storage, final String location)
this.storage = storage;
this.location = location;
public String location()
return this.location;
}
@Override
public String storage()
{
return this.storage;
String storage();
@Nonbinding
String location() default "";
package org.apache.deltaspike.core.spi.literal;
import org.apache.deltaspike.core.spi.resourceloader.StorageType;
import javax.enterprise.util.AnnotationLiteral;
public class StorageTypeLiteral extends AnnotationLiteral<StorageType> implements StorageType
private String value;
public StorageTypeLiteral(String value)
this.value = value;
}
@Override
public String value()
{
return this.value;
import java.util.Properties;
InputStream readStream(final ExternalResource externalResource);
Properties readProperties(final ExternalResource externalResource);
import org.apache.deltaspike.core.spi.resourceloader.StorageType;
@StorageType(StorageType.CLASSPATH)
public class ClasspathResourceProvider extends BaseResourceProvider
public InputStream readStream(final ExternalResource externalResource)
return readClassPath(externalResource.location());
import org.apache.deltaspike.core.spi.literal.StorageTypeLiteral;
import org.apache.deltaspike.core.spi.resourceloader.StorageType;
import java.lang.annotation.Annotation;
private ExternalResourceProvider getProvider(String storageTypeName)
{
StorageType storageType = new StorageTypeLiteral(storageTypeName);
ExternalResourceProvider provider = resourceProviders.select(storageType).get();
return provider;
}
@ExternalResource(storage = "",location = "")
ExternalResource externalResource = getAnnotation(injectionPoint);
ExternalResourceProvider provider = getProvider(externalResource.storage());
final InputStream is = provider.readStream(externalResource);
@ExternalResource(storage = "",location = "")
ExternalResource externalResource = getAnnotation(injectionPoint);
ExternalResourceProvider provider = getProvider(externalResource.storage());
final Properties properties = provider.readProperties(externalResource);
return properties;
public void closeInputStream(@Disposes @ExternalResource(storage = "",location = "") InputStream inputStream)
for (Annotation annotation : injectionPoint.getQualifiers())
if (annotation instanceof ExternalResource)
return (ExternalResource)annotation;
import org.apache.deltaspike.core.spi.resourceloader.StorageType;
import java.util.logging.Level;
import java.util.logging.Logger;
@StorageType(StorageType.FILE)
public class FileResourceProvider extends BaseResourceProvider
private static final Logger logger = Logger.getLogger(FileResourceProvider.class.getName());
logger.log(Level.SEVERE, "Problem reading resource.", e);
@Override
public InputStream readStream(ExternalResource externalResource)
{
return readFile(externalResource.location());
}
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
import org.apache.deltaspike.core.api.config.view.ViewRef;
if (isInternal(viewConfigClass))
{
return;
}
private boolean isInternal(Class configClass)
{
return ViewConfig.class.equals(configClass) ||
DefaultErrorView.class.equals(configClass) ||
ViewRef.Manual.class.equals(configClass);
}
new String[]{"org.apache.deltaspike.core",
"org.apache.deltaspike.test.category",
"org.apache.deltaspike.partialbean"}, excludedFiles);
public static final String JOB_CLASS_CONFIG_KEY = "deltaspike.scheduler.job-class";
String jobClassName = ConfigResolver.getPropertyValue(JOB_CLASS_CONFIG_KEY, "org.quartz.Job");
new String[]{"org.apache.deltaspike.core",
"org.apache.deltaspike.test.category",
"org.apache.deltaspike.security"}, excludedFiles);
import org.apache.deltaspike.core.api.resoureloader.ExternalResourceStorage;
private Class<? extends ExternalResourceStorage> storage;
public ExternalResourceLiteral(final Class<? extends ExternalResourceStorage> storage, final String location)
public Class<? extends ExternalResourceStorage> storage()
public interface ClasspathStorage extends ExternalResourceStorage
Class<? extends ExternalResourceStorage> storage();
public interface ExternalResourceStorage
public interface FileSystemStorage extends ExternalResourceStorage
import org.apache.deltaspike.core.api.resoureloader.ExternalResourceStorage;
private Class<? extends ExternalResourceStorage> value;
public StorageTypeLiteral(Class<? extends ExternalResourceStorage> value)
public Class<? extends ExternalResourceStorage> value()
import org.apache.deltaspike.core.api.resoureloader.ExternalResourceStorage;
Class<? extends ExternalResourceStorage> value();
protected boolean isXml(String fileName)
return fileName.endsWith(".xml");
boolean isXml = this.isXml(name);
import org.apache.deltaspike.core.api.resoureloader.ClasspathStorage;
@StorageType(ClasspathStorage.class)
import org.apache.deltaspike.core.api.resoureloader.ExternalResourceStorage;
private ExternalResourceProvider getProvider(Class<? extends ExternalResourceStorage> storageTypeClass)
StorageType storageType = new StorageTypeLiteral(storageTypeClass);
@ExternalResource(storage = ExternalResourceStorage.class,location = "")
@ExternalResource(storage = ExternalResourceStorage.class,location = "")
public void closeInputStream(@Disposes @ExternalResource(storage = ExternalResourceStorage.class,location = "")
InputStream inputStream)
import org.apache.deltaspike.core.api.resoureloader.FileSystemStorage;
@StorageType(FileSystemStorage.class)
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceStorage;
package org.apache.deltaspike.core.api.resourceloader;
package org.apache.deltaspike.core.api.resourceloader;
package org.apache.deltaspike.core.api.resourceloader;
package org.apache.deltaspike.core.api.resourceloader;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceStorage;
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceStorage;
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.ClasspathStorage;
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceStorage;
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.FileSystemStorage;
import java.util.logging.Level;
if (logger.isLoggable(Level.FINE))
{
logger.log(Level.FINE,"Unable to close input stream ",e);
}
import java.util.ArrayList;
import java.util.List;
InputStream result = null;
URL firstURL = null;
if (firstURL != null)
{
}
firstURL = url;
result = is;
return result;
if (result != null)
{
result.close();
}
is.close();
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import javax.enterprise.inject.spi.Extension;
try
finally
{
is.close();
}
import java.util.List;
List<InputStream> readStreams(final ExternalResource externalResource);
import java.util.Collections;
import java.util.List;
@Override
public List<InputStream> readStreams(ExternalResource externalResource)
{
return Collections.singletonList(this.readStream(externalResource));
}
import java.util.ArrayList;
import java.util.List;
List<InputStream> matchedStreams = this.readClassPath(externalResource.location(),true);
return matchedStreams.get(0);
@Override
public List<InputStream> readStreams(ExternalResource externalResource)
{
try
{
return readClassPath(externalResource.location(),false);
}
catch (IOException e)
{
throw new IllegalStateException("Error while trying to load resources from classpath ",e);
}
}
private List<InputStream> readClassPath(final String name, final boolean requireUnique)
throws IllegalStateException,IOException
List<URL> urlList = new ArrayList<URL>();
List<InputStream> results = new ArrayList<InputStream>();
results.add(is);
urlList.add(url);
if (requireUnique && results.size() != 1)
{
String msg = urlsToString(urlList,name);
for (InputStream is : results)
{
try
{
is.close();
}
catch (IOException e)
{
if (logger.isLoggable(Level.FINE))
{
logger.log(Level.FINE,"Unable to close stream",e);
}
}
}
throw new IllegalStateException(msg);
}
return results;
}
private String urlsToString(List<URL> urls, String name)
{
if (urls.size() == 0)
{
return String.format("No resources found for '%s'",name);
}
else
{
StringBuilder sb = new StringBuilder();
sb.append(String.format("multiple resources found for '%s'",name));
for (URL u : urls)
{
sb.append(" Match : ").append(u.toExternalForm());
}
return sb.toString();
}
import java.util.List;
public List<InputStream> getInputStreams(final InjectionPoint injectionPoint)
{
ExternalResource externalResource = getAnnotation(injectionPoint);
ExternalResourceProvider provider = getProvider(externalResource.storage());
return provider.readStreams(externalResource);
}
@Produces
@ExternalResource(storage = ExternalResourceStorage.class,location = "")
import java.util.List;
@Override
public List<InputStream> getInputStreams()
{
throw new UnsupportedOperationException();
}
import javax.enterprise.context.Dependent;
import java.util.List;
@Dependent
@ExternalResource(storage = ClasspathStorage.class,location="META-INF/beans.xml")
private List<InputStream> inputStreams;
@Inject
@Override
public List<InputStream> getInputStreams() {
return inputStreams;
}
Class<? extends ExternalResourceStorage> storage() default ClasspathStorage.class;
private static final long serialVersionUID = 1705986508118055892L;
private static final long serialVersionUID = 9066640252429716441L;
private static final long serialVersionUID = 6313493410718133308L;
public ContextualStorage getContextualStorage(BeanManager beanManager, String windowId, boolean createIfNotExist)
{
ContextualStorage contextualStorage = storageMap.get(windowId);
if (contextualStorage == null && createIfNotExist)
{
contextualStorage = createContextualStorage(beanManager, windowId);
}
return contextualStorage;
}
private synchronized ContextualStorage createContextualStorage(BeanManager beanManager, String windowId)
contextualStorage = new ContextualStorage(beanManager, true, true);
storageMap.put(windowId, contextualStorage);
ContextualStorage windowStorage = windowBeanHolder.getContextualStorage(beanManager, windowId, false);
return windowStorage != null;
return windowBeanHolder.getContextualStorage(beanManager, windowId, createIfNotExist);
import java.util.HashMap;
ContextualInstanceInfo<?> contextualInstanceInfo = storage.getStorage().remove(storage.getBeanKey(bean));
Map<Object, ContextualInstanceInfo<?>> contextMap =
new HashMap<Object, ContextualInstanceInfo<?>>(storage.getStorage());
storage.getStorage().clear();
import java.io.Serializable;
public interface WindowContext extends Serializable
return new InjectableWindowContext(deltaSpikeContextExtension.getWindowContext());
public static Map<Object, ContextualInstanceInfo<?>> destroyAllActive(ContextualStorage storage)
return contextMap;
private static final long serialVersionUID = 6384932199958645324L;
package org.apache.deltaspike.core.impl.scope;
import org.apache.deltaspike.core.impl.scope.conversation.ConversationBeanHolder;
import org.apache.deltaspike.core.impl.scope.conversation.GroupedConversationContext;
import org.apache.deltaspike.core.impl.scope.window.WindowBeanHolder;
import org.apache.deltaspike.core.impl.scope.window.WindowContextImpl;
import org.apache.deltaspike.core.impl.scope.window.WindowIdHolder;
private GroupedConversationContext conversationContext;
conversationContext = new GroupedConversationContext(beanManager, windowContext);
afterBeanDiscovery.addContext(conversationContext);
WindowBeanHolder windowBeanHolder =
BeanProvider.getContextualReference(beanManager, WindowBeanHolder.class, false);
WindowIdHolder windowIdHolder =
BeanProvider.getContextualReference(beanManager, WindowIdHolder.class, false);
windowContext.init(windowBeanHolder, windowIdHolder);
ConversationBeanHolder conversationBeanHolder =
BeanProvider.getContextualReference(beanManager, ConversationBeanHolder.class, false);
conversationContext.init(conversationBeanHolder);
public GroupedConversationContext getConversationContext()
{
return conversationContext;
}
import org.apache.deltaspike.core.impl.scope.DeltaSpikeContextExtension;
import org.apache.deltaspike.core.impl.scope.AbstractBeanHolder;
import javax.enterprise.context.SessionScoped;
public class WindowBeanHolder extends AbstractBeanHolder<String>
public void init(WindowBeanHolder windowBeanHolder, WindowIdHolder windowIdHolder)
import org.apache.deltaspike.core.impl.scope.DeltaSpikeContextExtension;
import java.util.ArrayList;
import java.util.List;
protected abstract ContextualStorage getContextualStorage(Contextual<?> contextual, boolean createIfNotExist);
protected List<ContextualStorage> getActiveContextualStorages()
{
List<ContextualStorage> result = new ArrayList<ContextualStorage>();
result.add(getContextualStorage(null, false));
return result;
}
ContextualStorage storage = getContextualStorage(bean, false);
ContextualStorage storage = getContextualStorage(bean, true);
ContextualStorage storage = getContextualStorage(bean, false);
List<ContextualStorage> storages = getActiveContextualStorages();
if (storages == null)
for (ContextualStorage storage : storages)
{
destroyAllActive(storage);
}
import java.util.ArrayList;
import java.util.List;
protected ContextualStorage getContextualStorage(Contextual<?> contextual, boolean createIfNotExist)
ConversationKey conversationKey = ConversationUtils.convertToConversationKey(contextual);
protected List<ContextualStorage> getActiveContextualStorages()
{
List<ContextualStorage> result = new ArrayList<ContextualStorage>();
result.addAll(this.conversationBeanHolder.getStorageMap().values());
return result;
}
@Override
import javax.enterprise.context.spi.Contextual;
protected ContextualStorage getContextualStorage(Contextual<?> contextual, boolean createIfNotExist)
import javax.enterprise.context.spi.Contextual;
protected ContextualStorage getContextualStorage(Contextual<?> contextual, boolean createIfNotExists)
protected ContextualStorage getContextualStorage(Contextual<?> contextual, boolean createIfNotExists)
ContextualStorage windowStorage = windowBeanHolder.getStorageMap().remove(windowId);
if (windowStorage != null)
{
AbstractContext.destroyAllActive(windowStorage);
}
return this.conversationBeanHolder.getContextualStorage(this.beanManager, conversationKey, createIfNotExist);
if (windowId.equals(this.windowIdHolder.getWindowId()))
{
this.windowIdHolder.setWindowId(null);
}
import javax.inject.Named;
@Named("dsWindowContext")
@FacesRenderer(componentFamily = WindowIdComponent.COMPONENT_FAMILY, rendererType = WindowIdComponent.COMPONENT_TYPE)
public class WindowIdHtmlRenderer extends Renderer
import javax.enterprise.inject.spi.BeanManager;
public GroupedConversation getGroupedConversation(InjectionPoint injectionPoint, BeanManager beanManager)
ConversationKey conversationKey =
ConversationUtils.convertToConversationKey(injectionPoint.getBean(), beanManager);
ConversationKey conversationKey = ConversationUtils.convertToConversationKey(contextual, this.beanManager);
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.PassivationCapable;
return convertToConversationKey(contextual, BeanManagerProvider.getInstance().getBeanManager());
}
public static ConversationKey convertToConversationKey(Contextual<?> contextual, BeanManager beanManager)
{
if (contextual instanceof PassivationCapable)
{
contextual = BeanManagerProvider.getInstance().getBeanManager()
.getPassivationCapableBean(((PassivationCapable) contextual).getId());
}
else
{
throw new IllegalArgumentException(
}
contextual = beanManager.getPassivationCapableBean(((PassivationCapable) contextual).getId());
destroyBean(bean, contextualInstanceInfo);
destroyBean(bean, contextualInstanceInfo);
public static void destroyBean(Contextual bean, ContextualInstanceInfo<?> contextualInstanceInfo)
{
bean.destroy(contextualInstanceInfo.getContextualInstance(), contextualInstanceInfo.getCreationalContext());
}
import org.apache.deltaspike.core.api.scope.ConversationSubGroup;
import org.apache.deltaspike.core.util.context.ContextualInstanceInfo;
import java.util.Collections;
ConversationSubGroup conversationSubGroup = conversationGroup.getAnnotation(ConversationSubGroup.class);
Set<Class<?>> subGroups = null;
if (conversationSubGroup != null)
{
conversationGroup = ConversationUtils.getDeclaredConversationGroup(conversationGroup);
subGroups = new HashSet<Class<?>>(conversationSubGroup.subGroup().length);
Collections.addAll(subGroups, conversationSubGroup.subGroup());
}
if (subGroups == null)
{
AbstractContext.destroyAllActive(entry.getValue());
result.add(entry.getValue());
}
else
{
tryToDestroySubGroup(subGroups, entry);
if (entry.getValue().getStorage().isEmpty())
{
}
}
private void tryToDestroySubGroup(Set<Class<?>> subGroups, Map.Entry<ConversationKey, ContextualStorage> entry)
{
ContextualStorage storage = entry.getValue();
for (Map.Entry<Object, ContextualInstanceInfo<?>> storageEntry : storage.getStorage().entrySet())
{
for (Class<?> subGroup : subGroups)
{
Class classOfEntry = storageEntry.getValue().getContextualInstance().getClass();
if (subGroup.equals(classOfEntry) ||
(subGroup.isInterface() && subGroup.isAssignableFrom(classOfEntry)))
{
Contextual bean = storage.getBean(storageEntry.getKey());
AbstractContext.destroyBean(bean, storageEntry.getValue());
break;
}
}
}
}
import org.apache.deltaspike.core.api.scope.ConversationSubGroup;
public static Class<?> getDeclaredConversationGroup(Class<?> conversationGroup)
{
ConversationSubGroup conversationSubGroup = conversationGroup.getAnnotation(ConversationSubGroup.class);
if (conversationSubGroup == null)
{
return conversationGroup;
}
Class<?> result = conversationSubGroup.of();
if (!ConversationSubGroup.class.equals(result))
{
return result;
}
result = conversationGroup.getSuperclass();
if ((result == null || Object.class.getName().equals(result.getName())) &&
conversationGroup.getInterfaces().length == 1)
{
return conversationGroup.getInterfaces()[0];
}
if (result == null)
{
ConversationSubGroup.class.getName());
}
return result;
}
package org.apache.deltaspike.test.core.api.scope.conversation.grouped.explicit;
package org.apache.deltaspike.test.core.api.scope.conversation.grouped.explicit;
package org.apache.deltaspike.test.core.api.scope.conversation.grouped.implicit;
import java.util.Map;
public abstract class ClientWindow
private static final String PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY =
public abstract String getWindowId(FacesContext facesContext);
public void disableClientWindowRenderMode(FacesContext context)
{
Map<Object, Object> attrMap = context.getAttributes();
attrMap.put(PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY, Boolean.TRUE);
}
public void enableClientWindowRenderMode(FacesContext context)
{
Map<Object, Object> attrMap = context.getAttributes();
attrMap.remove(PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY);
}
public boolean isClientWindowRenderModeEnabled(FacesContext context)
{
Map<Object, Object> attrMap = context.getAttributes();
boolean result = !attrMap.containsKey(PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY);
return result;
}
public abstract Map<String, String> getQueryURLParameters(FacesContext context);
URL,
import javax.faces.context.FacesContext;
import org.apache.deltaspike.jsf.impl.scope.window.ClientWindowHelper;
this.wrapped.redirect(ClientWindowHelper.appendWindowId(FacesContext.getCurrentInstance(), url));
import java.util.HashMap;
public class DefaultClientWindow extends ClientWindow
public static final String DELTASPIKE_WINDOW_ID_URL_PARAM = "dswid";
if (ClientWindowRenderMode.URL.equals(clientWindowRenderMode))
{
ExternalContext externalContext = facesContext.getExternalContext();
if (facesContext.getAttributes().containsKey(NEW_WINDOW_ID))
{
return (String) facesContext.getAttributes().get(NEW_WINDOW_ID);
}
else if (externalContext.getRequestParameterMap().containsKey(DELTASPIKE_WINDOW_ID_URL_PARAM))
{
return externalContext.getRequestParameterMap().get(DELTASPIKE_WINDOW_ID_URL_PARAM);
}
else
{
facesContext.getAttributes().put(NEW_WINDOW_ID, generateNewWindowId());
ClientWindowHelper.handleInitialRedirect(facesContext);
facesContext.responseComplete();
return null;
}
}
url = JsfUtils.addParameter(externalContext, url, false, NOSCRIPT_PARAMETER, "true");
@Override
public void disableClientWindowRenderMode(FacesContext context)
{
ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(context);
if (ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))
{
context.getExternalContext().getClientWindow().disableClientWindowRenderMode(context);
}
else if (ClientWindowRenderMode.URL.equals(clientWindowRenderMode))
{
super.disableClientWindowRenderMode(context);
}
}
@Override
public void enableClientWindowRenderMode(FacesContext context)
{
ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(context);
if (ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))
{
context.getExternalContext().getClientWindow().enableClientWindowRenderMode(context);
}
else if (ClientWindowRenderMode.URL.equals(clientWindowRenderMode))
{
super.enableClientWindowRenderMode(context);
}
}
@Override
public boolean isClientWindowRenderModeEnabled(FacesContext context)
{
ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(context);
if (ClientWindowRenderMode.URL.equals(clientWindowRenderMode))
{
return super.isClientWindowRenderModeEnabled(context);
}
return false;
}
@Override
public Map<String, String> getQueryURLParameters(FacesContext context)
{
ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(context);
if (ClientWindowRenderMode.URL.equals(clientWindowRenderMode))
{
String windowId = getWindowId(context);
if (windowId != null)
{
Map<String, String> params = new HashMap<String, String>();
params.put(DELTASPIKE_WINDOW_ID_URL_PARAM, getWindowId(context));
return params;
}
}
return null;
}
public static String addParameter(ExternalContext externalContext, String url, boolean encodeValues,
String name, String value)
{
{
return url;
}
StringBuilder finalUrl = new StringBuilder(url);
if (url.contains("?"))
{
finalUrl.append("&");
}
else
{
finalUrl.append("?");
}
finalUrl.append(name);
finalUrl.append("=");
if (encodeValues)
{
finalUrl.append(JsfUtils.encodeURLParameterValue(value, externalContext));
}
else
{
finalUrl.append(value);
}
return finalUrl.toString();
}
public static String addRequestParameters(ExternalContext externalContext, String url, boolean encodeValues)
{
StringBuilder finalUrl = new StringBuilder(url);
boolean existingParameters = url.contains("?");
for (Map.Entry<String, String[]> entry : externalContext.getRequestParameterValuesMap().entrySet())
{
for (String value : entry.getValue())
{
{
if (!existingParameters)
{
finalUrl.append("?");
existingParameters = true;
}
else
{
finalUrl.append("&");
}
finalUrl.append(entry.getKey());
finalUrl.append("=");
if (encodeValues)
{
finalUrl.append(JsfUtils.encodeURLParameterValue(value, externalContext));
}
else
{
finalUrl.append(value);
}
}
}
}
return finalUrl.toString();
}
import org.apache.deltaspike.jsf.impl.scope.window.ClientWindowHelper;
public String getActionURL(FacesContext context, String viewId)
{
return ClientWindowHelper.appendWindowId(context, this.wrapped.getActionURL(context, viewId));
}
@Override
import org.apache.deltaspike.jsf.impl.util.ClientWindowHelper;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
private final ClientWindow clientWindow;
DeltaSpikeExternalContextWrapper(ExternalContext wrapped, ClientWindow clientWindow)
this.clientWindow = clientWindow;
String targetURL = ClientWindowHelper.appendWindowId(FacesContext.getCurrentInstance(),
url, this.clientWindow);
this.wrapped.redirect(targetURL);
@Override
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
private final ClientWindow clientWindow;
this.clientWindow = BeanProvider.getContextualReference(ClientWindow.class, true);
return new DeltaSpikeFacesContextWrapper(facesContext, clientWindow);
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
private volatile Boolean initialized;
DeltaSpikeFacesContextWrapper(FacesContext wrappedFacesContext, ClientWindow clientWindow)
new DeltaSpikeExternalContextWrapper(wrappedFacesContext.getExternalContext(), clientWindow);
if (this.initialized == null)
{
init();
}
}
private synchronized void init()
{
if (initialized == null)
clientWindow = BeanProvider.getContextualReference(ClientWindow.class, true);
windowContext = BeanProvider.getContextualReference(WindowContext.class, true);
delegateWindowHandling =
BeanProvider.getContextualReference(JsfModuleConfig.class).isDelegatedWindowHandlingEnabled();
import org.apache.deltaspike.jsf.impl.util.ClientWindowHelper;
String windowId = (String) facesContext.getAttributes().get(NEW_WINDOW_ID);
if (windowId == null)
windowId = externalContext.getRequestParameterMap().get(DELTASPIKE_WINDOW_ID_URL_PARAM);
if (windowId == null)
return windowId;
package org.apache.deltaspike.jsf.impl.util;
import javax.enterprise.inject.Typed;
@Typed()
public abstract class ClientWindowHelper
public static String appendWindowId(FacesContext facesContext, String url, ClientWindow clientWindow)
if (clientWindow != null && clientWindow.isClientWindowRenderModeEnabled(facesContext))
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.jsf.impl.util.ClientWindowHelper;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
private final ClientWindow clientWindow;
this.clientWindow = BeanProvider.getContextualReference(ClientWindow.class, true);
String actionURL = this.wrapped.getActionURL(context, viewId);
return ClientWindowHelper.appendWindowId(context, actionURL, clientWindow);
if (storage != null)
{
destroyAllActive(storage);
}
FacesContext facesContext = FacesContext.getCurrentInstance();
if (!ClientWindowHelper.isInitialRedirect(facesContext))
{
JsfUtils.saveFacesMessages(this.wrapped);
}
String targetURL = ClientWindowHelper.appendWindowId(facesContext, url, this.clientWindow);
String windowId = (String) ClientWindowHelper.getInitialRedirectWindowId(facesContext);
ClientWindowHelper.handleInitialRedirect(facesContext, generateNewWindowId());
public static final String INITIAL_REDIRECT_WINDOW_ID = ClientWindowHelper.class.getName()
".INITIAL_REDIRECT_WINDOW_ID";
public static void handleInitialRedirect(FacesContext facesContext, String newWindowId)
facesContext.getAttributes().put(INITIAL_REDIRECT_WINDOW_ID, newWindowId);
public static boolean isInitialRedirect(FacesContext facesContext)
{
return facesContext.getAttributes().containsKey(INITIAL_REDIRECT_WINDOW_ID);
}
public static String getInitialRedirectWindowId(FacesContext facesContext)
{
return (String) facesContext.getAttributes().get(INITIAL_REDIRECT_WINDOW_ID);
}
public interface ClientWindow
String getWindowId(FacesContext facesContext);
void disableClientWindowRenderMode(FacesContext facesContext);
void enableClientWindowRenderMode(FacesContext facesContext);
boolean isClientWindowRenderModeEnabled(FacesContext facesContext);
Map<String, String> getQueryURLParameters(FacesContext facesContext);
import org.apache.deltaspike.core.spi.scope.window.WindowContext;
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindowConfig;
public class DefaultClientWindow implements ClientWindow
private static final String PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY =
public void disableClientWindowRenderMode(FacesContext facesContext)
ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(facesContext);
facesContext.getExternalContext().getClientWindow().disableClientWindowRenderMode(facesContext);
Map<Object, Object> attrMap = facesContext.getAttributes();
attrMap.put(PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY, Boolean.TRUE);
public void enableClientWindowRenderMode(FacesContext facesContext)
ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(facesContext);
facesContext.getExternalContext().getClientWindow().enableClientWindowRenderMode(facesContext);
Map<Object, Object> attrMap = facesContext.getAttributes();
attrMap.remove(PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY);
public boolean isClientWindowRenderModeEnabled(FacesContext facesContext)
ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(facesContext);
Map<Object, Object> attrMap = facesContext.getAttributes();
return  !attrMap.containsKey(PER_USE_CLIENT_WINDOW_URL_QUERY_PARAMETER_DISABLED_KEY);
public Map<String, String> getQueryURLParameters(FacesContext facesContext)
ClientWindowRenderMode clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(facesContext);
String windowId = getWindowId(facesContext);
params.put(DELTASPIKE_WINDOW_ID_URL_PARAM, getWindowId(facesContext));
public class InjectableWindowContext implements WindowContext
if (ClientWindowRenderMode.LAZY.equals(clientWindowRenderMode))
else if (ClientWindowRenderMode.LAZY.equals(clientWindowRenderMode))
else if (ClientWindowRenderMode.LAZY.equals(clientWindowRenderMode))
if (ClientWindowRenderMode.LAZY.equals(clientWindowRenderMode))
if (ClientWindowRenderMode.LAZY.equals(clientWindowRenderMode))
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindowConfig;
private volatile ClientWindowConfig clientWindowConfig;
String mode = getClientWindowConfig().getClientWindowRenderMode(context).name();
private ClientWindowConfig getClientWindowConfig()
{
if (clientWindowConfig == null)
{
synchronized (this)
{
if (clientWindowConfig == null)
{
clientWindowConfig = BeanProvider.getContextualReference(ClientWindowConfig.class);
}
}
}
return clientWindowConfig;
}
import org.apache.deltaspike.core.util.StringUtils;
if (StringUtils.isEmpty(windowId))
if (StringUtils.isEmpty(windowId))
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindowConfig;
public ClientWindowConfig.ClientWindowRenderMode getDefaultWindowMode()
{
if (isDelegatedWindowHandlingEnabled())
{
return ClientWindowConfig.ClientWindowRenderMode.DELEGATED;
}
return null;
}
protected boolean isDelegatedWindowHandlingEnabled()
private ClientWindowRenderMode defaultClientWindowRenderMode;
this.defaultClientWindowRenderMode = this.jsfModuleConfig.getDefaultWindowMode();
if (this.defaultClientWindowRenderMode != null)
return this.defaultClientWindowRenderMode;
if (this.defaultClientWindowRenderMode != null)
return this.defaultClientWindowRenderMode;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindowConfig;
delegateWindowHandling = ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(
BeanProvider.getContextualReference(JsfModuleConfig.class).getDefaultWindowMode());
return ClientWindowRenderMode.LAZY;
String windowId = ClientWindowHelper.getInitialRedirectWindowId(facesContext);
return true;
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
private JsfModuleConfig jsfModuleConfig;
@Inject
if (this.jsfModuleConfig.isInitialRedirectEnabled())
{
ClientWindowHelper.handleInitialRedirect(facesContext, generateNewWindowId());
facesContext.responseComplete();
return null;
}
else
{
return generateNewWindowId();
}
import javax.transaction.TransactionSynchronizationRegistry;
protected static final String TRANSACTION_SYNC_REGISTRY_JNDI_NAME = "java:comp/TransactionSynchronizationRegistry";
if (userTransaction == null)
{
return;
}
if (userTransaction.getStatus() != Status.STATUS_ACTIVE)
{
userTransaction.setTransactionTimeout(transactionTimeout);
}
try
{
return JndiUtils.lookup(USER_TRANSACTION_JNDI_NAME, UserTransaction.class);
}
catch (Exception ne)
{
return null;
}
}
protected TransactionSynchronizationRegistry resolveTransactionRegistry()
{
return JndiUtils.lookup(TRANSACTION_SYNC_REGISTRY_JNDI_NAME, TransactionSynchronizationRegistry.class);
private TransactionSynchronizationRegistry transactionSynchronizationRegistry = null;
if (this.userTransaction == null)
{
transactionSynchronizationRegistry = resolveTransactionRegistry();
if (transactionSynchronizationRegistry.getTransactionStatus() != Status.STATUS_ACTIVE)
{
throw new RuntimeException("invalid state/badly configured JTA datasource");
}
}
if (this.userTransaction == null)
{
throw new IllegalStateException("cannot begin UserTransaction in CMT environment");
}
if (this.userTransaction == null)
{
throw new IllegalStateException("cannot commit UserTransaction in CMT environment");
}
if (this.userTransaction == null)
{
throw new IllegalStateException("cannot rollback UserTransaction in CMT environment");
}
if (this.userTransaction != null)
{
this.userTransaction.setRollbackOnly();
}
else
{
this.transactionSynchronizationRegistry.setRollbackOnly();
}
return this.getStatus() == Status.STATUS_MARKED_ROLLBACK;
return this.getStatus() != Status.STATUS_NO_TRANSACTION &&
return this.getStatus() != Status.STATUS_COMMITTED &&
this.getStatus() != Status.STATUS_NO_TRANSACTION &&
this.getStatus() != Status.STATUS_UNKNOWN;
return this.getStatus() == Status.STATUS_ACTIVE ||
this.getStatus() == Status.STATUS_PREPARING ||
this.getStatus() == Status.STATUS_PREPARED;
}
protected int getStatus() throws SystemException
{
if (this.userTransaction != null)
{
return this.userTransaction.getStatus();
}
else
{
return this.transactionSynchronizationRegistry.getTransactionStatus();
}
if (userTransaction != null && userTransaction.getStatus() != Status.STATUS_ACTIVE)
catch (Exception e)
private final TransactionSynchronizationRegistry transactionSynchronizationRegistry;
this.transactionSynchronizationRegistry = resolveTransactionRegistry();
if (this.transactionSynchronizationRegistry.getTransactionStatus() != Status.STATUS_ACTIVE)
throw new IllegalStateException(
"The CMT is not active. Please check the config of the Data-Source.");
else
{
this.transactionSynchronizationRegistry = null;
}
throw new UnsupportedOperationException("A CMT is active. This operation is only supported with BMT.");
throw new UnsupportedOperationException("A CMT is active. This operation is only supported with BMT.");
throw new UnsupportedOperationException("A CMT is active. This operation is only supported with BMT.");
return getTransactionStatus() == Status.STATUS_MARKED_ROLLBACK;
return this.getTransactionStatus() != Status.STATUS_NO_TRANSACTION &&
return this.getTransactionStatus() != Status.STATUS_COMMITTED &&
this.getTransactionStatus() != Status.STATUS_NO_TRANSACTION &&
this.getTransactionStatus() != Status.STATUS_UNKNOWN;
return getTransactionStatus() == Status.STATUS_ACTIVE ||
getTransactionStatus() == Status.STATUS_PREPARING ||
getTransactionStatus() == Status.STATUS_PREPARED;
protected int getTransactionStatus() throws SystemException
private static final String WINDOW_ID_REQUEST_MAP_KEY =
ExternalContext externalContext = facesContext.getExternalContext();
Map<String, Object> requestMap = externalContext.getRequestMap();
String windowId = (String) requestMap.get(WINDOW_ID_REQUEST_MAP_KEY);
if (windowId != null)
{
return windowId;
}
windowId = DEFAULT_WINDOW_ID;
else if (ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))
windowId = ClientWindowAdapter.getWindowIdFromJsf(facesContext);
else if (ClientWindowRenderMode.LAZY.equals(clientWindowRenderMode))
windowId = ClientWindowHelper.getInitialRedirectWindowId(facesContext);
windowId = null;
windowId = generateNewWindowId();
else if (ClientWindowRenderMode.CLIENTWINDOW.equals(clientWindowRenderMode))
if (facesContext.isPostback())
{
windowId = getPostBackWindowId(facesContext);
}
else if (isNoscriptRequest(externalContext))
{
clientWindowConfig.setJavaScriptEnabled(false);
windowId = DEFAULT_WINDOW_ID;
}
else
{
windowId = getVerifiedWindowIdFromCookie(externalContext);
boolean newWindowIdRequested = false;
if (AUTOMATED_ENTRY_POINT_PARAMETER_KEY.equals(windowId))
{
windowId = generateNewWindowId();
newWindowIdRequested = true;
}
if (windowId == null || newWindowIdRequested)
{
sendWindowHandlerHtml(externalContext, windowId);
facesContext.responseComplete();
}
}
if (windowId != null)
{
requestMap.put(WINDOW_ID_REQUEST_MAP_KEY, windowId);
}
import java.io.IOException;
import javax.faces.FacesException;
String url = externalContext.getRequestScheme()
externalContext.getRequestContextPath()
externalContext.getRequestServletPath();
url = JsfUtils.addRequestParameters(externalContext, url, true);
try
{
externalContext.redirect(url);
}
catch (IOException e)
{
throw new FacesException("Could not send initial redirect!", e);
}
if (externalContext.getRequestParameterValuesMap().isEmpty())
{
return url;
}
else
{
getWrappedNavigationHandler().handleNavigation(context, fromAction, outcome);
}
"]. Did you add a corresponding producer?");
if (externalContext.getRequestPathInfo() != null)
{
}
String named = factory.extract(namedQuery);
return factory.extract(query);
public String extractFrom(Object query)
public String extractFrom(Object query)
public String extractFrom(Object query)
String extractFrom(Object query);
private final QueryStringExtractor[] extractors = new QueryStringExtractor[]
new HibernateQueryStringExtractor(),
new EclipseLinkEjbQueryStringExtractor(),
new OpenJpaQueryStringExtractor()
};
public String extract(final Query query)
{
for (final QueryStringExtractor extractor : extractors)
final String compare = extractor.getClass().getAnnotation(ProviderSpecific.class).value();
final Object implQuery = toImplQuery(compare, query);
if (implQuery != null)
return extractor.extractFrom(implQuery);
private static Object toImplQuery(final String clazzName, final Query query)
try
{
return query.unwrap(toClass);
}
catch (Exception e)
{
toClass.cast(query);
return query;
}
return null;
validateViewMetaData(view, viewConfigNode);
protected void validateViewMetaData(View view, ViewConfigNode viewConfigNode)
{
String basePath = view.basePath();
if (viewConfigNode.getSource().isInterface() && !"".equals(basePath) && basePath != null)
{
" or a class instead of the interface for page-nodes.");
}
}
import org.apache.deltaspike.jsf.api.config.view.Folder;
private static final Logger LOGGER = Logger.getLogger(ViewConfigPathValidator.class.getName());
if (configDescriptor instanceof DefaultFolderConfigDescriptor &&
!configDescriptor.getConfigClass().isAnnotationPresent(Folder.class))
{
continue;
}
import org.apache.deltaspike.core.util.ProxyUtils;
transactionalAnnotation, targetClass);
import org.apache.deltaspike.core.util.ProxyUtils;
transactionalAnnotation = extractTransactionalAnnotation(targetClass.getAnnotations());
import org.apache.deltaspike.core.util.ProxyUtils;
for (Authorizer authorizer : metaDataStorage.getAuthorizers(targetClass, method))
for (Authorizer authorizer : metaDataStorage.getAuthorizers(targetClass, method))
import java.lang.annotation.Annotation;
import javax.enterprise.inject.Default;
public Class<? extends Annotation> getExceptionQualifier()
{
return Default.class;
}
import java.lang.annotation.Annotation;
private final Annotation exceptionQualifier;
this.exceptionQualifier = AnnotationInstanceProvider.of(
BeanProvider.getContextualReference(JsfModuleConfig.class).getExceptionQualifier());
ExceptionToCatchEvent event = new ExceptionToCatchEvent(rootCause, exceptionQualifier);
import org.apache.deltaspike.jsf.impl.security.SecurityAwareViewHandler;
import javax.faces.context.FacesContext;
import javax.faces.event.PreDestroyViewMapEvent;
import javax.faces.event.SystemEvent;
private final boolean preDestroyViewMapEventFilterMode;
public InjectionAwareApplicationWrapper(
Application wrapped, JsfModuleConfig jsfModuleConfig, boolean preDestroyViewMapEventFilterMode)
this.preDestroyViewMapEventFilterMode = preDestroyViewMapEventFilterMode;
public void publishEvent(FacesContext facesContext, Class<? extends SystemEvent> systemEventClass, Object source)
{
if (!PreDestroyViewMapEvent.class.isAssignableFrom(systemEventClass) ||
isPreDestroyViewMapEventAllowed(facesContext))
{
super.publishEvent(facesContext, systemEventClass, source);
}
}
private boolean isPreDestroyViewMapEventAllowed(FacesContext facesContext)
{
return !this.preDestroyViewMapEventFilterMode ||
!Boolean.TRUE.equals(facesContext.getExternalContext().getRequestMap().get(
SecurityAwareViewHandler.PRE_DESTROY_VIEW_MAP_EVENT_FILTER_ENABLED));
}
@Override
import org.apache.deltaspike.jsf.impl.security.SecurityAwareViewHandler;
private boolean preDestroyViewMapEventFilterMode;
if (this.initialized == null)
this.jsfModuleConfig = BeanProvider.getContextualReference(JsfModuleConfig.class);
this.preDestroyViewMapEventFilterMode = ClassDeactivationUtils.isActivated(SecurityAwareViewHandler.class);
this.initialized = true;
lazyInit();
return new InjectionAwareApplicationWrapper(
this.wrappedFacesContext.getApplication(), this.jsfModuleConfig, this.preDestroyViewMapEventFilterMode);
import java.util.HashMap;
import java.util.Map;
public  static final String PRE_DESTROY_VIEW_MAP_EVENT_FILTER_ENABLED =
Map<String, Object> viewMap = null;
if (originalViewRoot != null)
{
Map<String, Object> originalViewMap = originalViewRoot.getViewMap(false);
if (originalViewMap != null && !originalViewMap.isEmpty())
{
viewMap = new HashMap<String, Object>();
viewMap.putAll(originalViewMap);
}
}
deactivatePreDestroyViewMapEvent(context);
activatePreDestroyViewMapEvent(context);
if (viewMap != null)
{
originalViewRoot.getViewMap().putAll(viewMap);
}
private void deactivatePreDestroyViewMapEvent(FacesContext facesContext)
{
facesContext.getExternalContext().getRequestMap().put(PRE_DESTROY_VIEW_MAP_EVENT_FILTER_ENABLED, Boolean.TRUE);
}
private void activatePreDestroyViewMapEvent(FacesContext facesContext)
{
facesContext.getExternalContext().getRequestMap().put(PRE_DESTROY_VIEW_MAP_EVENT_FILTER_ENABLED, Boolean.FALSE);
}
package org.apache.deltaspike.core.api.lifecycle;
package org.apache.deltaspike.core.api.lifecycle;
package org.apache.deltaspike.core.api.literal;
import org.apache.deltaspike.core.api.lifecycle.Destroyed;
package org.apache.deltaspike.core.api.literal;
import org.apache.deltaspike.core.api.lifecycle.Initialized;
import org.apache.deltaspike.core.api.lifecycle.Initialized;
import org.apache.deltaspike.core.api.lifecycle.Initialized;
private JsfRequestBroadcaster jsfRequestBroadcaster;
broadcastDestroyedJsfRequestEvent();
private void broadcastDestroyedJsfRequestEvent()
if (this.jsfRequestBroadcaster != null)
this.jsfRequestBroadcaster.broadcastDestroyedJsfRequestEvent(this);
if (ClassDeactivationUtils.isActivated(JsfRequestBroadcaster.class))
this.jsfRequestBroadcaster =
BeanProvider.getContextualReference(JsfRequestBroadcaster.class, true);
private JsfRequestBroadcaster jsfRequestBroadcaster;
broadcastInitializedJsfRequestEvent(facesContext);
private void broadcastInitializedJsfRequestEvent(FacesContext facesContext)
if (this.jsfRequestBroadcaster != null)
this.jsfRequestBroadcaster.broadcastInitializedJsfRequestEvent(facesContext);
if (this.initialized == null)
if (ClassDeactivationUtils.isActivated(JsfRequestBroadcaster.class))
this.jsfRequestBroadcaster =
BeanProvider.getContextualReference(JsfRequestBroadcaster.class, true);
this.initialized = true;
import org.apache.deltaspike.core.api.literal.DestroyedLiteral;
import org.apache.deltaspike.core.api.literal.InitializedLiteral;
import org.apache.deltaspike.core.api.literal.DestroyedLiteral;
import org.apache.deltaspike.core.api.literal.InitializedLiteral;
import org.apache.deltaspike.core.api.literal.DestroyedLiteral;
import org.apache.deltaspike.core.api.literal.InitializedLiteral;
import org.apache.deltaspike.core.api.lifecycle.Destroyed;
import org.apache.deltaspike.core.api.lifecycle.Initialized;
import org.apache.deltaspike.core.api.lifecycle.Destroyed;
import org.apache.deltaspike.core.api.lifecycle.Initialized;
import org.apache.deltaspike.core.api.lifecycle.Destroyed;
import org.apache.deltaspike.core.api.lifecycle.Initialized;
import java.beans.Introspector;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Set;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.spi.PassivationCapable;
import javax.inject.Named;
import org.apache.deltaspike.core.api.literal.AnyLiteral;
import org.apache.deltaspike.core.util.bean.ImmutableBeanWrapper;
import org.apache.deltaspike.core.util.bean.ImmutablePassivationCapableBeanWrapper;
private Bean<Object> namedBundleProducerBean;
private NamedTypedMessageBundle namedTypedMessageBundle = new NamedTypedMessageBundleLiteral();
private boolean elSupportEnabled;
elSupportEnabled = ClassDeactivationUtils.isActivated(NamedMessageBundleInvocationHandler.class);
else if (method.isAnnotationPresent(NamedTypedMessageBundle.class))
{
namedBundleProducerBean = (Bean<Object>)bean;
}
if (this.elSupportEnabled)
{
Bean<?> namedBean = createNamedMessageBundleBean(namedBundleProducerBean, type, beanManager);
if (namedBean.getName() != null)
{
abd.addBean(namedBean);
}
}
if (this.elSupportEnabled)
{
beanBuilder.name(null);
}
private <T> Bean<T> createNamedMessageBundleBean(Bean<Object> delegate,
AnnotatedType<T> annotatedType,
BeanManager beanManager)
{
WrappingBeanBuilder<T> beanBuilder = new WrappingBeanBuilder<T>(delegate, beanManager) {
@Override
public ImmutableBeanWrapper<T> create()
{
final ImmutableBeanWrapper<T> result = super.create();
String beanName = createBeanName(result.getTypes());
Set<Annotation> qualifiers = new HashSet<Annotation>();
qualifiers.add(new AnyLiteral());
qualifiers.add(namedTypedMessageBundle);
if (isPassivationCapable())
{
return new ImmutablePassivationCapableBeanWrapper<T>(result,
beanName, qualifiers, result.getScope(),
result.getStereotypes(), result.getTypes(), result.isAlternative(),
result.isNullable(), result.toString(), ((PassivationCapable)result).getId()) {
@Override
public T create(CreationalContext<T> creationalContext)
{
MessageBundleContext.setBean(result);
try
{
return super.create(creationalContext);
}
finally
{
MessageBundleContext.reset();
}
}
};
}
else
{
return new ImmutableBeanWrapper<T>(result,
beanName, qualifiers, result.getScope(),
result.getStereotypes(), result.getTypes(), result.isAlternative(),
result.isNullable(), result.toString()) {
@Override
public T create(CreationalContext<T> creationalContext)
{
MessageBundleContext.setBean(result);
try
{
return super.create(creationalContext);
}
finally
{
MessageBundleContext.reset();
}
}
};
}
}
private String createBeanName(Set<Type> types)
{
for (Object type : types)
{
if (type instanceof Class)
{
Named namedAnnotation = ((Class<?>) type).getAnnotation(Named.class);
if (namedAnnotation == null)
{
continue;
}
String result = namedAnnotation.value();
if (!"".equals(result))
{
return result;
}
return Introspector.decapitalize(((Class<?>) type).getSimpleName());
}
}
return null;
}
};
beanBuilder.readFromType(annotatedType);
beanBuilder.types(annotatedType.getJavaClass(), Object.class, Serializable.class);
beanBuilder.passivationCapable(true);
return beanBuilder.create();
}
import javax.enterprise.inject.Typed;
@Typed(MessageBundleInvocationHandler.class)
private static final long serialVersionUID = -8980912335543392357L;
import javax.enterprise.inject.spi.Bean;
private static final String JAVA_PACKAGE = "java.";
@Produces
@Dependent
@NamedTypedMessageBundle
@SuppressWarnings("UnusedDeclaration")
Object produceTypedMessageBundle(NamedMessageBundleInvocationHandler handler)
{
Bean currentMessageBundleContextBean = MessageBundleContext.getCurrentMessageBundleBean();
Class<?> type = extractCustomType(currentMessageBundleContextBean);
handler.setTargetType(type);
return createMessageBundleProxy(type, handler);
}
private Class<?> extractCustomType(Bean currentMessageBundleBean)
{
for (Object type : currentMessageBundleBean.getTypes())
{
if (type instanceof Class && !((Class)type).getName().startsWith(JAVA_PACKAGE))
{
return (Class)type;
}
}
}
@Named
String text();
private volatile Boolean initialized;
private Annotation exceptionQualifier;
init();
private synchronized void init()
{
if (this.initialized == null)
{
this.exceptionQualifier = AnnotationInstanceProvider.of(
BeanProvider.getContextualReference(JsfModuleConfig.class).getExceptionQualifier());
this.initialized = true;
}
}
applicationContext.invalidate();
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
private static ThreadLocal<Boolean> preDestroyCalled = new ThreadLocal<Boolean>();
@PostConstruct
protected void onPostConstruct()
{
preDestroyCalled.remove();
preDestroyCalled.set(false);
}
@PreDestroy
protected void onPreDestroy()
{
preDestroyCalled.set(true);
}
public static boolean isPreDestroyCalled()
return preDestroyCalled.get();
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
private static ThreadLocal<Boolean> preDestroyCalled = new ThreadLocal<Boolean>();
@PostConstruct
protected void onPostConstruct()
{
preDestroyCalled.remove();
preDestroyCalled.set(false);
}
@PreDestroy
protected void onPreDestroy()
{
preDestroyCalled.set(true);
}
public static boolean isPreDestroyCalled()
return preDestroyCalled.get();
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class DeltaSpikeContextExtension implements Extension, Deactivatable
private Boolean isActivated = true;
protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
{
isActivated = ClassDeactivationUtils.isActivated(getClass());
}
if (!isActivated)
{
return;
}
if (!isActivated)
{
return;
}
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class RepositoryExtension implements Extension, Deactivatable
private Boolean isActivated = true;
isActivated = ClassDeactivationUtils.isActivated(getClass());
if (!isActivated)
{
return;
}
if (!isActivated)
{
return;
}
if (!isActivated)
{
return;
}
import static org.apache.deltaspike.data.impl.util.ClassUtils.contains;
import static org.apache.deltaspike.data.impl.util.ClassUtils.extract;
public Object getProxy()
{
return proxy;
}
import org.apache.deltaspike.data.impl.meta.RequiresTransaction;
@RequiresTransaction
@RequiresTransaction
@RequiresTransaction
@RequiresTransaction
@RequiresTransaction
@RequiresTransaction
@RequiresTransaction
import static org.apache.deltaspike.data.impl.util.ProxyUtils.extractFromProxy;
@Inject
private QueryRunner runner;
Object result = runner.executeQuery(builder, queryContext);
import javax.persistence.LockModeType;
import org.apache.deltaspike.data.api.Modifying;
public boolean requiresTransaction()
{
boolean hasLockMode = false;
if (method.isAnnotationPresent(Query.class))
{
hasLockMode = !method.getAnnotation(Query.class).lock().equals(LockModeType.NONE);
}
return hasLockMode || method.isAnnotationPresent(Modifying.class);
}
import static javax.persistence.LockModeType.PESSIMISTIC_READ;
import org.apache.deltaspike.data.api.Modifying;
import org.apache.deltaspike.data.api.Query;
@Query(lock = PESSIMISTIC_READ)
Simple findByName(String name);
@Query(named = Simple.BY_NAME_LIKE)
Simple findByNameNoLock(String name);
@Modifying @Query("delete from Simple")
int deleteAll();
import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.enterprise.inject.Default;
import org.apache.deltaspike.core.api.literal.AnyLiteral;
import org.apache.deltaspike.core.util.ProxyUtils;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.impl.entitymanager.EntityManagerHolder;
import org.apache.deltaspike.jpa.impl.transaction.context.EntityManagerEntry;
import org.apache.deltaspike.jpa.impl.transaction.context.TransactionBeanStorage;
import org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy;
@Inject
private EntityManagerHolder emHolder;
@Override
Set<Class<? extends Annotation>> emQualifiers = emHolder.isSet() ?
new HashSet<Class<? extends Annotation>>(Arrays.asList(Default.class)) :
transactionHelper.resolveEntityManagerQualifiers(transactionalAnnotation, targetClass);
if (emHolder.isSet())
{
return emHolder.get();
}
lazyInit();
private void lazyInit()
{
if (this.initialized == null)
{
init();
}
}
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessScopedBeanHistory;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessScopedBeanHolder;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessContext;
private ViewAccessContext viewAccessScopedContext;
viewAccessScopedContext = new ViewAccessContext(beanManager, windowContext);
afterBeanDiscovery.addContext(viewAccessScopedContext);
ViewAccessScopedBeanHolder viewAccessScopedBeanHolder =
BeanProvider.getContextualReference(beanManager, ViewAccessScopedBeanHolder.class, false);
ViewAccessScopedBeanHistory viewAccessScopedBeanHistory =
BeanProvider.getContextualReference(beanManager, ViewAccessScopedBeanHistory.class, false);
viewAccessScopedContext.init(viewAccessScopedBeanHolder, windowIdHolder, viewAccessScopedBeanHistory);
public ViewAccessContext getViewAccessScopedContext()
{
return viewAccessScopedContext;
}
import org.apache.deltaspike.core.impl.scope.DeltaSpikeContextExtension;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessContext;
private DeltaSpikeContextExtension contextExtension;
if (!facesContext.isPostback() && facesContext.getViewRoot() != null)
{
ViewAccessContext viewAccessContext = contextExtension.getViewAccessScopedContext();
if (viewAccessContext != null)
{
viewAccessContext.onRenderingFinished(facesContext.getViewRoot().getViewId());
}
}
contextExtension = BeanProvider.getContextualReference(DeltaSpikeContextExtension.class, true);
viewAccessScopedBeanHistory.getAccessedBeans().clear();
if (!viewAccessScopedBeanHistory.getAccessedBeans().contains((String) storageEntry.getKey()))
if (facesContext.getViewRoot() != null)
import java.util.ArrayList;
import java.util.List;
List<String> lastAccessedBeans = viewAccessScopedBeanHistory.getLastAccessedBeans();
lastAccessedBeans.clear();
viewAccessScopedBeanHistory.setLastAccessedBeans(viewAccessScopedBeanHistory.getAccessedBeans());
viewAccessScopedBeanHistory.setAccessedBeans(lastAccessedBeans);
List<String> usedBeans = new ArrayList<String>();
usedBeans.addAll(viewAccessScopedBeanHistory.getAccessedBeans());
usedBeans.addAll(viewAccessScopedBeanHistory.getLastAccessedBeans());
if (!usedBeans.contains((String) storageEntry.getKey()))
private List<String> lastAccessedBeans;
lastAccessedBeans = new ArrayList<String>();
public List<String> getLastAccessedBeans()
{
return lastAccessedBeans;
}
public void setLastAccessedBeans(List<String> lastAccessedBeans)
{
this.lastAccessedBeans = lastAccessedBeans;
}
if (!facesContext.isPostback() && facesContext.getViewRoot() != null)
package org.apache.deltaspike.jsf.impl.listener.request;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.spi.scope.window.WindowContext;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
import javax.faces.context.FacesContext;
import javax.faces.event.PhaseListener;
import javax.faces.lifecycle.Lifecycle;
import org.apache.deltaspike.core.impl.scope.DeltaSpikeContextExtension;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessContext;
class DeltaSpikeLifecycleWrapper extends Lifecycle
private final Lifecycle wrapped;
private JsfRequestBroadcaster jsfRequestBroadcaster;
private ClientWindow clientWindow;
private WindowContext windowContext;
private DeltaSpikeContextExtension contextExtension;
private volatile Boolean initialized;
DeltaSpikeLifecycleWrapper(Lifecycle wrapped)
this.wrapped = wrapped;
}
Lifecycle getWrapped()
{
return wrapped;
}
@Override
public void addPhaseListener(PhaseListener phaseListener)
{
this.wrapped.addPhaseListener(phaseListener);
@Override
public void execute(FacesContext facesContext)
if (facesContext.getResponseComplete())
lazyInit();
broadcastInitializedJsfRequestEvent(facesContext);
String windowId = clientWindow.getWindowId(facesContext);
if (windowId != null)
windowContext.activateWindow(windowId);
if (!FacesContext.getCurrentInstance().getResponseComplete())
{
this.wrapped.execute(facesContext);
}
@Override
public PhaseListener[] getPhaseListeners()
return this.wrapped.getPhaseListeners();
}
@Override
public void removePhaseListener(PhaseListener phaseListener)
{
this.wrapped.removePhaseListener(phaseListener);
@Override
public void render(FacesContext facesContext)
this.wrapped.render(facesContext);
if (facesContext.getViewRoot() != null)
ViewAccessContext viewAccessContext = contextExtension.getViewAccessScopedContext();
if (viewAccessContext != null)
{
viewAccessContext.onRenderingFinished(facesContext.getViewRoot().getViewId());
}
private void broadcastInitializedJsfRequestEvent(FacesContext facesContext)
if (this.jsfRequestBroadcaster != null)
this.jsfRequestBroadcaster.broadcastInitializedJsfRequestEvent(facesContext);
}
private void lazyInit()
{
if (this.initialized == null)
{
init();
}
}
private synchronized void init()
{
if (this.initialized == null)
{
if (ClassDeactivationUtils.isActivated(JsfRequestBroadcaster.class))
{
this.jsfRequestBroadcaster =
BeanProvider.getContextualReference(JsfRequestBroadcaster.class, true);
}
clientWindow = BeanProvider.getContextualReference(ClientWindow.class, true);
windowContext = BeanProvider.getContextualReference(WindowContext.class, true);
contextExtension = BeanProvider.getContextualReference(DeltaSpikeContextExtension.class, true);
this.initialized = true;
}
viewAccessScopedBeanHistory.getAccessedBeans().clear();
if (!viewAccessScopedBeanHistory.getAccessedBeans().contains((String) storageEntry.getKey()))
package org.apache.deltaspike.core.util;
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.spi.activation.ClassDeactivator;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import javax.enterprise.inject.Typed;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;
@Typed()
public abstract class ClassDeactivationUtils
private static final Logger LOG = Logger.getLogger(ClassDeactivationUtils.class.getName());
private static Map<ClassLoader, List<ClassDeactivator>> classDeactivatorMap
= new ConcurrentHashMap<ClassLoader, List<ClassDeactivator>>();
private static Map<Class<? extends Deactivatable>, Boolean> activationStatusCache
= new ConcurrentHashMap<Class<? extends Deactivatable>, Boolean>();
private ClassDeactivationUtils()
public static boolean isActivated(Class<? extends Deactivatable> targetClass)
Boolean activatedClassCacheEntry = activationStatusCache.get(targetClass);
if (activatedClassCacheEntry == null)
{
initDeactivatableCacheFor(targetClass);
activatedClassCacheEntry = activationStatusCache.get(targetClass);
}
return activatedClassCacheEntry;
}
private static synchronized void initDeactivatableCacheFor(Class<? extends Deactivatable> targetClass)
{
Boolean activatedClassCacheEntry = activationStatusCache.get(targetClass);
List<ClassDeactivator> classDeactivators = getClassDeactivators();
Boolean isActivated = Boolean.TRUE;
Class<? extends ClassDeactivator> deactivatedBy = null;
for (ClassDeactivator classDeactivator : classDeactivators)
Boolean isLocallyActivated = classDeactivator.isActivated(targetClass);
if (isLocallyActivated != null)
{
isActivated = isLocallyActivated;
if (!isActivated)
{
deactivatedBy = classDeactivator.getClass();
}
else if (deactivatedBy != null)
{
classDeactivator.getClass().getName()
"If that isn't the intended behaviour, you have to use a higher ordinal for "
deactivatedBy.getName());
}
}
cacheResult(targetClass, isActivated);
private static void cacheResult(Class<? extends Deactivatable> targetClass, Boolean activated)
activationStatusCache.put(targetClass, activated);
private static List<ClassDeactivator> getClassDeactivators()
ClassLoader classLoader = ClassUtils.getClassLoader(null);
List<ClassDeactivator> classDeactivators = classDeactivatorMap.get(classLoader);
if (classDeactivators == null)
return initConfiguredClassDeactivators(classLoader);
}
return classDeactivators;
}
private static List<ClassDeactivator> initConfiguredClassDeactivators(ClassLoader classLoader)
{
List<String> classDeactivatorClassNames = ConfigResolver.getAllPropertyValues(ClassDeactivator.class.getName());
List<ClassDeactivator> classDeactivators = new ArrayList<ClassDeactivator>();
for (String classDeactivatorClassName : classDeactivatorClassNames)
{
try
ClassDeactivator currentClassDeactivator =
(ClassDeactivator) ClassUtils.instantiateClassForName(classDeactivatorClassName);
classDeactivators.add(currentClassDeactivator);
}
catch (Exception e)
{
throw new IllegalStateException(e);
classDeactivatorMap.put(classLoader, classDeactivators);
return classDeactivators;
if (facesContext.getViewRoot() != null)
try
{
return super.get(bean);
}
finally
{
if (bean instanceof PassivationCapable)
{
PassivationCapable pc = (PassivationCapable) bean;
viewAccessScopedBeanHistory.getAccessedBeans().add(pc.getId());
}
}
try
{
return super.get(bean, creationalContext);
}
finally
{
if (bean instanceof PassivationCapable)
{
PassivationCapable pc = (PassivationCapable) bean;
viewAccessScopedBeanHistory.getAccessedBeans().add(pc.getId());
}
}
viewAccessScopedBeanHistory.getAccessedBeans().clear();
private List<String> accessedBeans = new ArrayList<String>();
package org.apache.deltaspike.playground;
package org.apache.deltaspike.playground;
import org.apache.deltaspike.playground.exception.Jsf;
package org.apache.deltaspike.playground.exception;
if (facesContext.getViewRoot() != null && facesContext.getViewRoot().getViewId() != null)
package org.apache.deltaspike.test.jsf.impl.scope.viewaccess.beans;
import java.io.Serializable;
import org.apache.deltaspike.core.api.scope.ViewAccessScoped;
@ViewAccessScoped
public class ViewAccessScopedBeanX implements Serializable
private String value;
public String getValue()
return value;
}
public void setValue(String value)
{
this.value = value;
package org.apache.deltaspike.test.jsf.impl.scope.viewaccess.beans;
import java.io.Serializable;
import org.apache.deltaspike.core.api.scope.ViewAccessScoped;
@ViewAccessScoped
public class ViewAccessScopedBeanY implements Serializable
private String value;
public String getValue()
return value;
}
public void setValue(String value)
{
this.value = value;
viewAccessScopedContext.init(viewAccessScopedBeanHolder, viewAccessScopedBeanHistory);
public void init(ViewAccessScopedBeanHolder viewAccessScopedBeanHolder,
return this.viewAccessScopedBeanHolder.getContextualStorage(this.beanManager, KEY, createIfNotExist);
ContextualStorage storage = viewAccessScopedBeanHolder.getContextualStorage(beanManager, KEY, false);
public void onProcessingViewFinished(String view)
viewAccessContext.onProcessingViewFinished(facesContext.getViewRoot().getViewId());
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.impl.scope.DeltaSpikeContextExtension;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessContext;
private volatile Boolean initialized;
private DeltaSpikeContextExtension contextExtension;
lazyInit();
if (context.getViewRoot() != null && context.getViewRoot().getViewId() != null)
{
ViewAccessContext viewAccessContext = contextExtension.getViewAccessScopedContext();
if (viewAccessContext != null)
{
viewAccessContext.onProcessingViewFinished(context.getViewRoot().getViewId());
}
}
private void lazyInit()
{
if (this.initialized == null)
{
init();
}
}
private synchronized void init()
{
if (this.initialized == null)
{
contextExtension = BeanProvider.getContextualReference(DeltaSpikeContextExtension.class, true);
this.initialized = true;
}
}
import org.apache.deltaspike.jsf.impl.scope.viewaccess.ViewAccessScopedAwareNavigationHandler;
return new ViewAccessScopedAwareNavigationHandler(viewConfigAwareNavigationHandler);
private final boolean vasnhActivated;
this.vasnhActivated = ClassDeactivationUtils.isActivated(ViewAccessScopedAwareNavigationHandler.class);
NavigationHandler navigationHandler = new ViewConfigAwareNavigationHandler(this.wrapped);
if (vasnhActivated)
{
navigationHandler = new ViewAccessScopedAwareNavigationHandler(navigationHandler);
}
return navigationHandler;
if (context.getViewRoot() != null)
if (viewId != null)
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessBeanAccessHistory;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessBeanHolder;
import org.apache.deltaspike.core.impl.scope.viewaccess.ViewAccessViewHistory;
ViewAccessBeanHolder viewAccessBeanHolder =
BeanProvider.getContextualReference(beanManager, ViewAccessBeanHolder.class, false);
ViewAccessBeanAccessHistory viewAccessBeanAccessHistory =
BeanProvider.getContextualReference(beanManager, ViewAccessBeanAccessHistory.class, false);
ViewAccessViewHistory viewAccessViewHistory =
BeanProvider.getContextualReference(beanManager, ViewAccessViewHistory.class, false);
viewAccessScopedContext.init(viewAccessBeanHolder, viewAccessBeanAccessHistory, viewAccessViewHistory);
import java.util.ArrayList;
import java.util.List;
import javax.enterprise.context.RequestScoped;
@RequestScoped
public class ViewAccessBeanAccessHistory
{
private final List<String> accessedBeans = new ArrayList<String>();
public List<String> getAccessedBeans()
{
return accessedBeans;
}
public class ViewAccessBeanHolder extends AbstractBeanHolder<String>
private ViewAccessBeanHolder viewAccessBeanHolder;
private ViewAccessBeanAccessHistory viewAccessBeanAccessHistory;
private ViewAccessViewHistory viewAccessViewHistory;
public void init(ViewAccessBeanHolder viewAccessBeanHolder,
ViewAccessBeanAccessHistory viewAccessBeanAccessHistory,
ViewAccessViewHistory viewAccessViewHistory)
this.viewAccessBeanHolder = viewAccessBeanHolder;
this.viewAccessBeanAccessHistory = viewAccessBeanAccessHistory;
this.viewAccessViewHistory = viewAccessViewHistory;
viewAccessBeanAccessHistory.getAccessedBeans().add(pc.getId());
viewAccessBeanAccessHistory.getAccessedBeans().add(pc.getId());
return this.viewAccessBeanHolder.getContextualStorage(this.beanManager, KEY, createIfNotExist);
if (!view.equals(viewAccessViewHistory.getLastView()))
viewAccessViewHistory.setLastView(view);
viewAccessBeanAccessHistory.getAccessedBeans().clear();
ContextualStorage storage = viewAccessBeanHolder.getContextualStorage(beanManager, KEY, false);
if (!viewAccessBeanAccessHistory.getAccessedBeans().contains((String) storageEntry.getKey()))
public class ViewAccessViewHistory implements Serializable
private static final long serialVersionUID = 8917607910721148527L;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceProvider;
private final Class<? extends ExternalResourceProvider> resourceProvider;
private final String location;
public ExternalResourceLiteral(Class<? extends ExternalResourceProvider> resourceProvider, String location)
this.resourceProvider = resourceProvider;
public Class<? extends ExternalResourceProvider> resourceProvider()
return this.resourceProvider;
package org.apache.deltaspike.core.api.resourceloader;
package org.apache.deltaspike.core.api.resourceloader;
Class<? extends ExternalResourceProvider> resourceProvider() default ClasspathResourceProvider.class;
package org.apache.deltaspike.core.api.resourceloader;
import org.apache.deltaspike.core.api.provider.BeanProvider;
@ExternalResource(resourceProvider = ExternalResourceProvider.class,location = "")
ExternalResourceProvider provider = BeanProvider.getContextualReference(externalResource.resourceProvider());
@ExternalResource(resourceProvider = ExternalResourceProvider.class,location = "")
ExternalResourceProvider provider = BeanProvider.getContextualReference(externalResource.resourceProvider());
@ExternalResource(resourceProvider = ExternalResourceProvider.class,location = "")
ExternalResourceProvider provider = BeanProvider.getContextualReference(externalResource.resourceProvider());
public void closeInputStream(@Disposes
@ExternalResource(resourceProvider = ExternalResourceProvider.class, location = "")
package org.apache.deltaspike.core.api.resourceloader;
package org.apache.deltaspike.core.api.resourceloader;
import org.apache.deltaspike.core.api.resourceloader.ClasspathResourceProvider;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceProducer;
import org.apache.deltaspike.core.api.resourceloader.FileResourceProvider;
package org.apache.deltaspike.servlet.api.resourceloader;
import org.apache.deltaspike.core.api.resourceloader.BaseResourceProvider;
package org.apache.deltaspike.core.impl.resourceloader;
import org.apache.deltaspike.core.api.resourceloader.ExternalResource;
import org.apache.deltaspike.core.api.resourceloader.ExternalResourceProvider;
public interface EntityManagerHolder
void set(EntityManager entityManager);
boolean isSet();
EntityManager get();
void dispose();
import org.apache.deltaspike.jpa.spi.entitymanager.ActiveEntityManagerHolder;
private ActiveEntityManagerHolder activeEntityManagerHolder;
activeEntityManagerHolder.set(context.getEntityManager());
activeEntityManagerHolder.dispose();
package org.apache.deltaspike.jpa.spi.entitymanager;
public interface ActiveEntityManagerHolder
import org.apache.deltaspike.jpa.spi.entitymanager.ActiveEntityManagerHolder;
public class DefaultEntityManagerHolder implements ActiveEntityManagerHolder
import org.apache.deltaspike.jpa.spi.entitymanager.ActiveEntityManagerHolder;
private ActiveEntityManagerHolder emHolder;
package org.apache.deltaspike.core.spi.exception.control.event;
import org.apache.deltaspike.core.spi.exception.control.event.IntrospectiveExceptionEvent;
public class ExceptionHandlerBroadcaster
private static final Logger LOG = Logger.getLogger(ExceptionHandlerBroadcaster.class.getName());
LOG.entering(
ExceptionHandlerBroadcaster.class.getName(), "executeHandlers", exceptionEventEvent.getException());
LOG.exiting(ExceptionHandlerBroadcaster.class.getName(), "executeHandlers",
private volatile Boolean initialized;
private ClientWindow clientWindow;
lazyInit();
private void lazyInit()
{
if (this.initialized == null)
{
init();
}
}
private synchronized void init()
{
if (this.initialized == null)
{
this.clientWindow = BeanProvider.getContextualReference(ClientWindow.class, true);
this.initialized = true;
}
}
private volatile Boolean initialized;
private ViewHandler securityAwareViewHandler;
private ClientWindow clientWindow;
lazyInit();
lazyInit();
private void lazyInit()
{
if (this.initialized == null)
{
init();
}
}
private synchronized void init()
{
if (this.initialized == null)
{
if (ClassDeactivationUtils.isActivated(getClass()))
{
this.securityAwareViewHandler = createSecurityAwareViewHandler();
}
else
{
this.securityAwareViewHandler = null;
}
this.clientWindow = BeanProvider.getContextualReference(ClientWindow.class, true);
this.initialized = true;
}
}
import org.apache.deltaspike.core.api.resourceloader.InjectableResource;
import org.apache.deltaspike.core.api.resourceloader.InjectableResourceProvider;
public class InjectableResourceLiteral extends AnnotationLiteral<InjectableResource> implements InjectableResource
private final Class<? extends InjectableResourceProvider> resourceProvider;
public InjectableResourceLiteral(Class<? extends InjectableResourceProvider> resourceProvider, String location)
public Class<? extends InjectableResourceProvider> resourceProvider()
public abstract class AbstractResourceProvider implements InjectableResourceProvider
private static final Logger logger = Logger.getLogger(AbstractResourceProvider.class.getName());
public Properties readProperties(InjectableResource injectableResource)
final String name = injectableResource.location();
final InputStream inputStream = this.readStream(injectableResource);
public List<InputStream> readStreams(InjectableResource injectableResource)
return Collections.singletonList(this.readStream(injectableResource));
public class ClasspathResourceProvider extends AbstractResourceProvider
public InputStream readStream(final InjectableResource injectableResource)
List<InputStream> matchedStreams = this.readClassPath(injectableResource.location(),true);
public List<InputStream> readStreams(InjectableResource injectableResource)
return readClassPath(injectableResource.location(),false);
public class FileResourceProvider extends AbstractResourceProvider
public InputStream readStream(InjectableResource injectableResource)
return readFile(injectableResource.location());
public @interface InjectableResource
Class<? extends InjectableResourceProvider> resourceProvider() default ClasspathResourceProvider.class;
public interface InjectableResourceProvider
InputStream readStream(final InjectableResource injectableResource);
List<InputStream> readStreams(final InjectableResource injectableResource);
Properties readProperties(final InjectableResource injectableResource);
beforeBeanDiscovery.addAnnotatedType(this.createAnnotatedType(InjectableResourceProducer.class,beanManager));
import org.apache.deltaspike.core.api.resourceloader.AbstractResourceProvider;
import org.apache.deltaspike.core.api.resourceloader.InjectableResource;
public class WebResourceProvider extends AbstractResourceProvider
public InputStream readStream(InjectableResource injectableResource)
String path = injectableResource.location();
import org.apache.deltaspike.core.api.common.DeltaSpike;
@DeltaSpike
import org.apache.deltaspike.core.api.common.DeltaSpike;
@DeltaSpike
@DeltaSpike
@DeltaSpike
@DeltaSpike
@DeltaSpike
@DeltaSpike
@DeltaSpike
import org.apache.deltaspike.core.api.common.DeltaSpike;
@DeltaSpike
@DeltaSpike
@DeltaSpike
@DeltaSpike
@DeltaSpike
@DeltaSpike
class RequestResponseHolder<Type>
static final RequestResponseHolder<ServletRequest> REQUEST = new RequestResponseHolder<ServletRequest>();
static final RequestResponseHolder<ServletResponse> RESPONSE = new RequestResponseHolder<ServletResponse>();
private final ThreadLocal<Type> threadLocal = new ThreadLocal<Type>();
void bind(Type instance)
if (isBound())
{
throw new IllegalStateException("There is already an instance bound to this thread.");
}
threadLocal.set(instance);
}
boolean isBound()
{
return threadLocal.get() != null;
}
void release()
{
threadLocal.remove();
}
Type get()
{
Type instance = threadLocal.get();
if (instance == null)
return instance;
RequestResponseHolder.REQUEST.bind(request);
RequestResponseHolder.RESPONSE.bind(response);
RequestResponseHolder.REQUEST.release();
RequestResponseHolder.RESPONSE.release();
return RequestResponseHolder.REQUEST.get();
ServletRequest request = RequestResponseHolder.REQUEST.get();
return RequestResponseHolder.RESPONSE.get();
ServletResponse response = RequestResponseHolder.RESPONSE.get();
ServletRequest request = RequestResponseHolder.REQUEST.get();
final boolean alreadyBound = RequestResponseHolder.REQUEST.isBound();
if (!alreadyBound)
{
RequestResponseHolder.REQUEST.bind(request);
}
RequestResponseHolder.RESPONSE.bind(response);
try
{
chain.doFilter(request, response);
}
finally
{
RequestResponseHolder.RESPONSE.release();
}
if (!alreadyBound)
{
RequestResponseHolder.REQUEST.release();
}
public boolean isFullStateSavingFallbackEnabled()
{
return true;
}
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
private transient Boolean fullStateSavingFallbackEnabled;
protected AbstractContextualReferenceWrapper()
{
}
protected AbstractContextualReferenceWrapper(T wrapped, boolean fullStateSavingFallbackEnabled)
this.fullStateSavingFallbackEnabled = fullStateSavingFallbackEnabled;
Object[] result = new Object[2];
if (this.fullStateSavingFallbackEnabled == null)
{
this.fullStateSavingFallbackEnabled =
BeanProvider.getContextualReference(JsfModuleConfig.class).isFullStateSavingFallbackEnabled();
}
if (this.fullStateSavingFallbackEnabled)
{
result[0] = this.getWrapped().getClass().getName();
}
result[1] = ((StateHolder)wrapped).saveState(context);
return result;
Object[] wrappedState = (Object[]) state;
{
this.wrapped = (T)ClassUtils.tryToInstantiateClassForName((String)wrappedState[0]);
}
((StateHolder) this.wrapped).restoreState(context, wrappedState[1]);
public ConverterWrapper()
}
public ConverterWrapper(Converter wrapped, boolean fullStateSavingFallbackEnabled)
{
super(wrapped, fullStateSavingFallbackEnabled);
private final boolean fullStateSavingFallbackEnabled;
this.fullStateSavingFallbackEnabled = jsfModuleConfig.isFullStateSavingFallbackEnabled();
return new ConverterWrapper(result, this.fullStateSavingFallbackEnabled);
return new ValidatorWrapper(result, this.fullStateSavingFallbackEnabled);
public ValidatorWrapper()
}
public ValidatorWrapper(Validator wrapped, boolean fullStateSavingFallbackEnabled)
{
super(wrapped, fullStateSavingFallbackEnabled);
if (this.fullStateSavingFallbackEnabled == null)
{
this.fullStateSavingFallbackEnabled =
BeanProvider.getContextualReference(JsfModuleConfig.class).isFullStateSavingFallbackEnabled();
}
if (this.fullStateSavingFallbackEnabled)
{
Object[] result = new Object[1];
result[0] = this.getWrapped().getClass().getName();
return result;
}
Class wrappedClass = ClassUtils.tryToLoadClassForName((String)wrappedState[0]);
T resolvedInstance = resolveInstanceForClass(context, wrappedClass);
if (resolvedInstance instanceof AbstractContextualReferenceWrapper)
{
resolvedInstance = ((AbstractContextualReferenceWrapper<T>)resolvedInstance).getWrapped();
}
this.wrapped = resolvedInstance;
if (this.wrapped == null)
{
this.wrapped = (T)ClassUtils.tryToInstantiateClassForName((String)wrappedState[0]);
BeanProvider.injectFields(this.wrapped);
}
protected abstract T resolveInstanceForClass(FacesContext facesContext, Class<?> wrappedClass);
import javax.faces.convert.FacesConverter;
@Override
protected Converter resolveInstanceForClass(FacesContext facesContext, Class<?> wrappedClass)
{
FacesConverter facesConverter = wrappedClass.getAnnotation(FacesConverter.class);
if (facesConverter == null)
{
return null;
}
if (!"".equals(facesConverter.value()))
{
return facesContext.getApplication().createConverter(facesConverter.value());
}
return facesContext.getApplication().createConverter(facesConverter.forClass());
}
import javax.faces.validator.FacesValidator;
@Override
protected Validator resolveInstanceForClass(FacesContext facesContext, Class<?> wrappedClass)
{
FacesValidator facesValidator = wrappedClass.getAnnotation(FacesValidator.class);
if (facesValidator == null)
{
return null;
}
return facesContext.getApplication().createValidator(facesValidator.value());
}
import java.util.List;
import java.util.logging.Logger;
protected org.quartz.Scheduler scheduler;
JobDetail jobDetail = this.scheduler.getJobDetail(jobKey);
Trigger trigger;
if (jobDetail == null)
{
jobDetail = JobBuilder.newJob(jobClass)
.withDescription(description)
.withIdentity(jobKey)
.build();
trigger = TriggerBuilder.newTrigger()
.withSchedule(CronScheduleBuilder.cronSchedule(scheduled.cronExpression()))
.build();
this.scheduler.scheduleJob(jobDetail, trigger);
}
else if (scheduled.overrideOnStartup())
{
List<? extends Trigger> existingTriggers = this.scheduler.getTriggersOfJob(jobKey);
if (existingTriggers == null || existingTriggers.isEmpty())
{
trigger = TriggerBuilder.newTrigger()
.withSchedule(CronScheduleBuilder.cronSchedule(scheduled.cronExpression()))
.build();
this.scheduler.scheduleJob(jobDetail, trigger);
return;
}
if (existingTriggers.size() > 1)
{
}
trigger = existingTriggers.iterator().next();
trigger = TriggerBuilder.newTrigger()
.withIdentity(trigger.getKey())
.withSchedule(CronScheduleBuilder.cronSchedule(scheduled.cronExpression()))
.build();
this.scheduler.rescheduleJob(trigger.getKey(), trigger);
}
else
{
}
import javax.el.ELException;
@Override
public Throwable getRootCause(Throwable throwable)
{
while ((ELException.class.isInstance(throwable) || FacesException.class.isInstance(throwable))
&& throwable.getCause() != null)
{
throwable = throwable.getCause();
}
return throwable;
}
if (creationalContext == null)
{
return null;
}
if (currentClass == null || currentClass.getSuperclass() == null)
{
return false;
}
if (!this.activated)
{
return ((ConfigurableNavigationHandler)this.wrapped).getNavigationCase(context, action, outcome);
}
if (!this.activated)
{
return result;
}
<S> S unwrap(Class<? extends S> schedulerClass);
@Override
public <S> S unwrap(Class<? extends S> schedulerClass)
{
if (schedulerClass.isAssignableFrom(this.scheduler.getClass()))
{
return (S)this.scheduler;
}
throw new IllegalArgumentException(schedulerClass.getName()
}
@Override
public <S> S unwrap(Class<? extends S> schedulerClass)
{
if (schedulerClass.isAssignableFrom(TestJobManager.getInstance().getClass()))
{
return (S)TestJobManager.getInstance();
}
throw new IllegalArgumentException(schedulerClass.getName()
}
public void add(DependentBeanEntry dependentBeanEntry)
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import org.apache.deltaspike.core.util.ProxyUtils;
Class phaseListenerClass;
phaseListenerClass = ProxyUtils.getUnproxiedClass(currentPhaseListener.getClass());
if (phaseListenerClass.isAnnotationPresent(JsfPhaseListener.class))
if (Deactivatable.class.isAssignableFrom(phaseListenerClass) &&
!ClassDeactivationUtils.isActivated(phaseListenerClass))
{
continue;
}
import java.lang.annotation.Annotation;
import org.apache.deltaspike.core.util.metadata.AnnotationInstanceProvider;
import org.apache.deltaspike.jsf.impl.exception.control.BridgeExceptionHandlerWrapper;
private boolean bridgeExceptionHandlerActivated;
private Annotation bridgeExceptionQualifier;
if (this.bridgeExceptionHandlerActivated)
{
exceptionHandler = new BridgeExceptionHandlerWrapper(exceptionHandler, this.bridgeExceptionQualifier);
}
this.bridgeExceptionHandlerActivated =
ClassDeactivationUtils.isActivated(BridgeExceptionHandlerWrapper.class);
this.bridgeExceptionQualifier = AnnotationInstanceProvider.of(jsfModuleConfig.getExceptionQualifier());
if (!windowContext.isActive())
{
return;
}
public boolean isAllowPostRequestWithoutDoubleSubmitPrevention()
{
return true;
}
import javax.interceptor.InterceptorBinding;
@InterceptorBinding
@InterceptorBinding
private static final long serialVersionUID = -436742087379474804L;
private int currentValue = -2;
this.navigationParameterContext.addPageParameter("cv", this.currentValue);
import org.jboss.shrinkwrap.api.asset.Asset;
import org.jboss.shrinkwrap.api.asset.StringAsset;
public static Asset getBeansXml()
{
Asset beansXml = new StringAsset(
"<beans>"
"<interceptors>"
"<class>org.apache.deltaspike.jsf.impl.config.view.navigation.NavigationParameterInterceptor</class>"
"<class>org.apache.deltaspike.jsf.impl.config.view.navigation.NavigationParameterListInterceptor</class>"
"</interceptors>"
"</beans>"
);
return beansXml;
}
public static final String DELTASPIKE_WINDOW_ID_POST_PARAM = "dspwid";
private static final String DELTASPIKE_REQUEST_TOKEN = "dsrid";
import org.apache.deltaspike.core.api.projectstage.ProjectStage;
import org.apache.deltaspike.core.util.ProjectStageProducer;
&& ProjectStageProducer.getInstance().getProjectStage() == ProjectStage.Development)
&& LIBRARY.equals(libraryName)
&& libraryName.equals(LIBRARY)
&& LIBRARY.equals(libraryName)
import org.apache.deltaspike.core.util.ClassUtils;
private final String version;
version = ClassUtils.getJarVersion(this.getClass());
if (resource != null && libraryName != null && LIBRARY.equals(libraryName))
if (ProjectStageProducer.getInstance().getProjectStage() == ProjectStage.Development)
{
resource = wrapped.createResource(resourceName, LIBRARY_UNCOMPRESSED);
}
resource = new DeltaSpikeResource(resource, version);
import java.lang.reflect.InvocationTargetException;
import javax.faces.event.AbortProcessingException;
import javax.faces.event.PhaseId;
import javax.faces.event.SystemEvent;
private final BeanManager beanManager;
public BridgeExceptionHandlerWrapper(ExceptionHandler wrapped,
BeanManager beanManager,
Annotation exceptionQualifier)
this.beanManager = beanManager;
while ((ELException.class.isInstance(throwable) || FacesException.class.isInstance(throwable) ||
InvocationTargetException.class.isInstance(throwable)) && throwable.getCause() != null)
@Override
public void processEvent(SystemEvent event) throws AbortProcessingException
{
if (event instanceof ExceptionQueuedEvent)
{
ExceptionQueuedEvent exceptionQueuedEvent = (ExceptionQueuedEvent)event;
FacesContext facesContext = exceptionQueuedEvent.getContext().getContext();
if (facesContext.getCurrentPhaseId() == PhaseId.RENDER_RESPONSE &&
exceptionQueuedEvent.getContext().inBeforePhase())
{
Throwable exception = getRootCause(exceptionQueuedEvent.getContext().getException());
ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(exception);
this.beanManager.fireEvent(exceptionToCatchEvent);
if (exceptionToCatchEvent.isHandled())
{
return;
}
}
}
super.processEvent(event);
}
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import javax.enterprise.inject.spi.BeanManager;
private BeanManager beanManager;
exceptionHandler = new BridgeExceptionHandlerWrapper(
exceptionHandler, this.beanManager, this.bridgeExceptionQualifier);
this.beanManager = BeanManagerProvider.getInstance().getBeanManager();
this.jsfModuleConfig = BeanProvider.getContextualReference(this.beanManager, JsfModuleConfig.class, false);
import org.apache.deltaspike.core.util.AnnotationUtils;
return AnnotationUtils
.extractAnnotationFromMethodOrClass(this.beanManager, context.getMethod(), Transactional.class);
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
public static List<Class<?>> getProxyAndBaseTypes(Class<?> proxyClass)
{
List<Class<?>> result = new ArrayList<Class<?>>();
result.add(proxyClass);
if (isInterfaceProxy(proxyClass))
{
result.addAll(Arrays.asList(proxyClass.getInterfaces()));
}
else
{
result.add(proxyClass.getSuperclass());
}
return result;
}
public static boolean isInterfaceProxy(Class<?> proxyClass)
{
Class<?>[] interfaces = proxyClass.getInterfaces();
return Proxy.class.equals(proxyClass.getSuperclass()) &&
interfaces != null && interfaces.length > 0;
}
import org.apache.deltaspike.core.util.ProxyUtils;
List<Class<?>> candidates = ProxyUtils.getProxyAndBaseTypes(proxy.getClass());
boolean clientWindowRenderModeEnabled = getClientWindow().isClientWindowRenderModeEnabled(context);
try
{
getClientWindow().disableClientWindowRenderMode(context);
super.encodeChildren(context, component);
}
finally
{
if (clientWindowRenderModeEnabled)
if (clientWindowRenderModeEnabled)
{
getClientWindow().disableClientWindowRenderMode(context);
}
@RequestScoped
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
import javax.enterprise.inject.spi.BeanManager;
@Inject
private BeanManager beanManager;
AccessDeniedException accessDeniedException = new AccessDeniedException(violations);
ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(accessDeniedException);
this.beanManager.fireEvent(exceptionToCatchEvent);
if (!exceptionToCatchEvent.isHandled())
{
throw accessDeniedException;
}
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
import org.apache.deltaspike.core.api.config.view.ViewConfig;
import org.apache.deltaspike.core.api.config.view.navigation.event.PreViewConfigNavigateEvent;
import org.apache.deltaspike.test.jsf.impl.config.view.navigation.event.uc001.Pages.CustomErrorPage;
if (navigateEvent.getToView().equals(CustomErrorPage.class))
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
class CustomErrorPage extends DefaultErrorView
{
}
import javax.enterprise.inject.Model;
import org.apache.deltaspike.jsf.api.config.view.View;
import org.apache.deltaspike.jsf.api.config.view.View.NavigationMode;
import org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode;
@View(navigation = NavigationMode.REDIRECT, viewParams = ViewParameterMode.INCLUDE)
import org.apache.deltaspike.jsf.api.config.view.View;
import org.apache.deltaspike.jsf.api.config.view.View.NavigationMode;
import org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode;
@View(navigation = NavigationMode.REDIRECT, viewParams = ViewParameterMode.INCLUDE)
private String currentValue = "aValue";
public String getCurrentValue()
import org.apache.deltaspike.jsf.api.config.view.View;
import org.apache.deltaspike.jsf.api.config.view.View.NavigationMode;
import org.apache.deltaspike.jsf.api.config.view.View.ViewParameterMode;
@View(navigation = NavigationMode.REDIRECT, viewParams = ViewParameterMode.INCLUDE)
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
import org.apache.deltaspike.core.api.config.view.ViewConfig;
import org.apache.deltaspike.jsf.api.config.view.View;
public interface Pages extends ViewConfig
public class CustomErrorPage extends DefaultErrorView implements Pages
{
}
import java.lang.reflect.Constructor;
public Constructor<?> getConstructor()
{
return null;
}
initialize();
import static org.apache.deltaspike.data.impl.util.QueryUtils.isNotEmpty;
import static org.apache.deltaspike.data.impl.util.QueryUtils.nullSafeValue;
if (isNotEmpty(context.getQueryString()))
return new StringBuilder()
.append("select count(")
.append(nullSafeValue(select, entityName))
.append(") ")
.append(from)
.append(nullSafeValue(where))
.toString();
public static String nullSafeValue(String value)
{
return nullSafeValue(value, null);
}
public static String nullSafeValue(String value, String fallback)
{
return value != null ? value : (fallback != null ? fallback : "");
}
@Query("select s from Simple s")
public abstract QueryResult<Simple> queryAll();
private boolean optional;
this.optional = false;
this.qualifiers = Collections.emptySet();
this.optional = false;
public boolean isOptional()
{
return optional;
}
public void setOptional(boolean optional)
{
this.optional = optional;
}
if (!exceptionEventEvent.isHandled() && throwException == null && !exceptionEventEvent.isOptional())
event.setOptional(true);
exceptionToCatchEvent.setOptional(true);
Typed typed = mockClass.getAnnotation(Typed.class);
if (typed == null || typed.value().length == 0)
{
typed = beanClass.getAnnotation(Typed.class);
}
excludedPackagesOrFiles,
"ds-core");
null,
"ds-core");
null,
"ds-core_and_jpa");
, excludedFiles,
"ds-core_and_jsf");
new String[]{"org.apache.deltaspike.security"}, excludedFiles,
"ds-security");
"org.apache.deltaspike.partialbean"}, excludedFiles,
"ds-core_and_partial-bean");
null,
"ds-core_and_scheduler");
"org.apache.deltaspike.security"}, excludedFiles,
"ds-core_and_security");
"org.apache.deltaspike.servlet"}, null,
"ds-core_and_servlet");
import java.util.UUID;
String[] excludeIfPackageExists,
String archiveName)
= createArchive(foundFile, markerFile, includeIfPackageExists, excludeIfPackageExists, archiveName);
String[] includeIfPackageExists,
String[] excludeIfPackageExists,
String archiveName)
return addFileArchive(f, includeIfPackageExists, excludeIfPackageExists, archiveName);
String[] excludeIfPackageExists,
String archiveName)
if (archiveName == null)
{
archiveName = UUID.randomUUID().toString();
}
exceptionToCatchEvent.setOptional(true);
private static final String DS_BASE_PACKAGE = "org.apache.deltaspike.";
return packageName.startsWith(OWB_BASE_PACKAGE) || packageName.startsWith(WELD_BASE_PACKAGE) ||
isDeltaSpikePackage(packageName);
}
protected boolean isDeltaSpikePackage(String packageName)
{
return packageName.startsWith(DS_BASE_PACKAGE);
import org.apache.deltaspike.core.util.metadata.AnnotationInstanceProvider;
import org.apache.myfaces.mc.test.core.annotation.TestConfig;
import javax.el.ExpressionFactory;
import java.util.HashMap;
import java.util.Map;
private static final TestConfig DEFAULT_TEST_CONFIG_LITERAL = AnnotationInstanceProvider.of(TestConfig.class);
protected MyFacesContainer mockedMyFacesTestContainer;
protected Class testClass;
protected Map<String, String> containerConfig = new HashMap<String, String>();
TestConfig testConfig = testClass.getJavaClass().getAnnotation(TestConfig.class);
if (testConfig == null || DEFAULT_TEST_CONFIG_LITERAL.webappResourcePath().equals(
testConfig.webappResourcePath()))
{
return ConfigResolver.getPropertyValue("deltaspike.testcontrol.mf.test.webapp_resource_path", "");
}
return testConfig.webappResourcePath();
@Override
protected void setUpWebConfigParams()
{
servletContext.addInitParameter("org.apache.myfaces.config.annotation.LifecycleProvider",
"org.apache.myfaces.config.annotation.NoInjectionAnnotationLifecycleProvider");
servletContext.addInitParameter("org.apache.myfaces.CHECKED_VIEWID_CACHE_ENABLED", "false");
servletContext.addInitParameter(ExpressionFactory.class.getName(),
"org.apache.el.ExpressionFactoryImpl");
super.setUpWebConfigParams();
initContainerConfig();
for (Map.Entry<String, String> entry : containerConfig.entrySet())
{
servletContext.addInitParameter(entry.getKey(), entry.getValue());
}
}
protected void initContainerConfig()
{
containerConfig = new HashMap<String, String>();
for (Map.Entry<String, String> entry : ConfigResolver.getAllProperties().entrySet())
{
if (entry.getKey().startsWith("org.apache.myfaces.") || entry.getKey().startsWith("javax.faces.") ||
entry.getKey().startsWith("facelets."))
{
containerConfig.put(entry.getKey(), entry.getValue());
}
}
}
ViewConfigResolver viewConfigResolver;
try
{
viewConfigResolver = BeanProvider.getContextualReference(ViewConfigResolver.class);
}
catch (Exception e)
{
LOGGER.log(Level.WARNING, "Container issue detected -> can't validate view-configs.", e);
return;
}
LOGGER.log(Level.SEVERE, "invalid view-config found", e);
import org.apache.deltaspike.testcontrol.impl.request.ManuallyHandledRequestEvent;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import javax.enterprise.event.Reception;
@ApplicationScoped
public void onManuallyHandledRequest(
@Observes(notifyObserver = Reception.IF_EXISTS) ManuallyHandledRequestEvent manuallyHandledRequestEvent)
{
switch (manuallyHandledRequestEvent.getManualAction())
{
case STARTED:
startScope(RequestScoped.class);
break;
case STOPPED:
stopScope(RequestScoped.class);
break;
default:
throw new IllegalArgumentException("unsupported action: "
manuallyHandledRequestEvent.getManualAction().name());
}
}
import org.apache.deltaspike.testcontrol.spi.ExternalContainer;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.context.ConversationScoped;
import javax.enterprise.context.SessionScoped;
import javax.inject.Singleton;
if (isManualScopeHandling())
{
for (ExternalContainer externalContainer : CdiTestRunner.getActiveExternalContainers())
{
externalContainer.startScope(Singleton.class);
externalContainer.startScope(ApplicationScoped.class);
externalContainer.startScope(RequestScoped.class);
externalContainer.startScope(SessionScoped.class);
externalContainer.startScope(ConversationScoped.class);
}
}
if (isManualScopeHandling())
{
for (ExternalContainer externalContainer : CdiTestRunner.getActiveExternalContainers())
{
externalContainer.stopScope(ConversationScoped.class);
externalContainer.stopScope(SessionScoped.class);
externalContainer.stopScope(RequestScoped.class);
externalContainer.stopScope(ApplicationScoped.class);
externalContainer.stopScope(Singleton.class);
}
}
for (ExternalContainer externalContainer : CdiTestRunner.getActiveExternalContainers())
{
externalContainer.startScope(scopeClass);
}
for (ExternalContainer externalContainer : CdiTestRunner.getActiveExternalContainers())
{
externalContainer.stopScope(scopeClass);
}
return RequestScoped.class.equals(scopeClass) && isManualScopeHandling();
}
private boolean isManualScopeHandling()
{
return !Boolean.TRUE.equals(CdiTestRunner.isAutomaticScopeHandlingActive());
import javax.enterprise.inject.spi.BeanManager;
boolean isMockedImplementationSupported(BeanManager beanManager, Annotated annotated);
import javax.enterprise.inject.spi.BeanManager;
import java.lang.annotation.Annotation;
import java.lang.reflect.Member;
import java.util.Set;
import java.util.logging.Logger;
private static final Logger LOG = Logger.getLogger(DefaultMockFilter.class.getName());
private static final String JAVA_BASE_PACKAGE = "java.";
private static final String JAVAX_BASE_PACKAGE = "javax.";
public boolean isMockedImplementationSupported(BeanManager beanManager, Annotated annotated)
Class origin = null;
origin = ((AnnotatedType)annotated).getJavaClass();
if (isAnnotatedTypeWithInterceptorAnnotation(beanManager, annotated.getAnnotations(), origin.getName()))
{
return false;
}
Member member = ((AnnotatedMember)annotated).getJavaMember();
origin = member.getDeclaringClass();
if (isAnnotatedTypeWithInterceptorAnnotation(beanManager, annotated.getAnnotations(), member.toString()))
{
return false;
}
return origin != null && !isInternalPackage(origin.getPackage().getName());
}
protected boolean isAnnotatedTypeWithInterceptorAnnotation(BeanManager beanManager,
Set<Annotation> annotations,
String origin)
{
for (Annotation annotation : annotations)
{
if (isStandardAnnotation(annotation))
{
continue;
}
if (beanManager.isInterceptorBinding(annotation.annotationType()) ||
(beanManager.isStereotype(annotation.annotationType()) &&
isStereotypeWithInterceptor(annotation, beanManager)))
{
return true;
}
}
return false;
}
protected boolean isStereotypeWithInterceptor(Annotation stereotypeAnnotation, BeanManager beanManager)
{
for (Annotation annotation : stereotypeAnnotation.annotationType().getAnnotations())
{
if (isStandardAnnotation(annotation))
{
continue;
}
if (beanManager.isInterceptorBinding(annotation.annotationType()) ||
isStereotypeWithInterceptor(annotation, beanManager))
{
return true;
}
}
return false;
}
protected boolean isStandardAnnotation(Annotation annotation)
{
return annotation.annotationType().getName().startsWith(JAVA_BASE_PACKAGE) ||
annotation.annotationType().getName().startsWith(JAVAX_BASE_PACKAGE);
if (!mockFilter.isMockedImplementationSupported(beanManager, processInjectionTarget.getAnnotatedType()))
if (!mockFilter.isMockedImplementationSupported(beanManager, processProducer.getAnnotatedMember()))
private static final String EJB_BASE_PACKAGE = "javax.ejb.";
if (isEjbOrAnnotatedTypeWithInterceptorAnnotation(
beanManager, annotated.getAnnotations(), origin.getName()))
if (isEjbOrAnnotatedTypeWithInterceptorAnnotation(
beanManager, annotated.getAnnotations(), member.toString()))
protected boolean isEjbOrAnnotatedTypeWithInterceptorAnnotation(BeanManager beanManager,
Set<Annotation> annotations,
String origin)
if (annotation.annotationType().getName().startsWith(EJB_BASE_PACKAGE))
{
return true;
}
(beanManager.isStereotype(annotation.annotationType()) &&
isStereotypeWithInterceptor(annotation, beanManager)))
isStereotypeWithInterceptor(annotation, beanManager))
annotation.annotationType().getName().startsWith(JAVAX_BASE_PACKAGE);
boolean readOnly() default false;
boolean rollbackOnly = isRollbackOnly(transactionalAnnotation);
if (!rollbackOnly)
{
for (EntityManagerEntry currentEntityManagerEntry : entityManagerEntryList)
{
EntityTransaction transaction = getTransaction(currentEntityManagerEntry);
if (transaction != null && transaction.isActive())
{
try
{
if (!commitFailed)
currentEntityManagerEntry.getEntityManager().flush();
if (!rollbackOnly && transaction.getRollbackOnly())
{
rollbackOnly = true;
}
catch (Exception e)
{
firstException = e;
commitFailed = true;
break;
}
protected boolean isRollbackOnly(Transactional transactionalAnnotation)
{
return transactionalAnnotation != null && transactionalAnnotation.readOnly();
}
BeanManager beanManager, Method targetMethod, Class targetClass, Class<T> targetAnnotationType)
Class unproxiedTargetClass = ProxyUtils.getUnproxiedClass(targetClass);
result = findAnnotation(beanManager, unproxiedTargetClass.getAnnotations(), targetAnnotationType);
Class targetClass = context.getTarget() != null ? context.getTarget().getClass() :
context.getMethod().getDeclaringClass();
.extractAnnotationFromMethodOrClass(beanManager, context.getMethod(), targetClass, Transactional.class);
import java.lang.reflect.Modifier;
Exclude exclude = extractExcludeAnnotation(processAnnotatedType.getAnnotatedType().getJavaClass());
if (exclude == null)
protected Exclude extractExcludeAnnotation(Class<?> currentClass)
{
Exclude result = currentClass.getAnnotation(Exclude.class);
if (result != null)
{
return result;
}
currentClass = currentClass.getSuperclass();
while (!Object.class.equals(currentClass) && currentClass != null)
{
if (Modifier.isAbstract(currentClass.getModifiers()))
{
result = currentClass.getAnnotation(Exclude.class);
}
if (result != null)
{
return result;
}
currentClass = currentClass.getSuperclass();
}
return null;
}
import org.apache.deltaspike.data.api.EntityManagerDelegate;
public interface ExtendedRepositoryInterface extends EntityRepository<Simple, Long>, EntityManagerDelegate<Simple>
import java.lang.reflect.Constructor;
import javax.inject.Inject;
import org.apache.deltaspike.data.spi.QueryInvocationContext;
@Inject
private QueryInvocationContext context;
protected abstract Object getPrimaryKey(Dto dto);
protected abstract Entity toEntity(Entity entity, Dto dto);
Dto dto = (Dto) parameter;
Object primaryKey = getPrimaryKey(dto);
if (primaryKey != null)
{
Entity entity = findEntity(primaryKey);
return toEntity(entity, dto);
}
return toEntity(newEntity(), dto);
}
protected Entity newEntity()
{
try
{
Class<?> entityClass = context.getEntityClass();
Constructor<?> constructor = entityClass.getDeclaredConstructor();
constructor.setAccessible(true);
return (Entity) constructor.newInstance();
}
catch (Exception e)
{
throw new RuntimeException("Failed instantiating new Entity", e);
}
}
protected Entity findEntity(Object primaryKey)
{
return (Entity) context.getEntityManager().find(context.getEntityClass(), primaryKey);
public void initMapper()
queryContext.initMapper();
protected Simple()
Simple simple = new Simple(dto.getName());
import javax.inject.Named;
import java.beans.Introspector;
return BeanProvider.getContextualReference(targetType, true);
}
protected Object getTargetObjectByName(String beanName)
{
return BeanProvider.getContextualReference(beanName, true);
private final Class<?> targetBeanClass;
private final String beanName;
Named named = this.targetBeanClass.getAnnotation(Named.class);
if (named != null && !"".equals(named.value()))
{
this.beanName = named.value();
}
else
{
this.beanName = Introspector.decapitalize(targetBeanClass.getSimpleName());
}
public Class<?> getTargetBeanClass()
public String getBeanName()
{
return beanName;
}
Class<?> targetBeanClass = callbackEntry.getTargetBeanClass();
Object bean = getTargetObject(targetBeanClass);
if (bean == null)
{
String beanName = callbackEntry.getBeanName();
bean = getTargetObjectByName(beanName);
if (bean == null)
{
}
}
import javax.persistence.TypedQuery;
protected abstract TypedQuery<E> typedQuery(String qlString);
public TypedQuery<E> typedQuery(String qlString)
{
return entityManager().createQuery(qlString, entityClass());
}
return typedQuery(query)
import org.apache.deltaspike.core.util.metadata.AnnotationInstanceProvider;
private static final Scheduled DEFAULT_SCHEDULED_LITERAL = AnnotationInstanceProvider.of(Scheduled.class);
if (scheduled == null)
{
scheduled = DEFAULT_SCHEDULED_LITERAL;
}
OWB11 ("org.apache.webbeans.container.BeanManagerImpl", "[1.1,1.2)"),
OWB12 ("org.apache.webbeans.container.BeanManagerImpl", "[1.2,1.3)"),
WELD11("org.jboss.weld.manager.BeanManagerImpl", "[1.1,1.2)"),
WELD12("org.jboss.weld.manager.BeanManagerImpl", "[1.2,1.3)"),
WELD20("org.jboss.weld.manager.BeanManagerImpl", "[2.0,2.1)");
private final String versionRange;
CdiImplementation(String implementationClassName, String versionRange)
this.versionRange = versionRange;
public String getVersionRange()
return versionRange;
package org.apache.deltaspike.beanvalidation.impl;
package org.apache.deltaspike.beanvalidation.test;
package org.apache.deltaspike.beanvalidation.test;
package org.apache.deltaspike.beanvalidation.test;
package org.apache.deltaspike.beanvalidation.test;
package org.apache.deltaspike.beanvalidation.test;
import org.apache.deltaspike.jsf.impl.navigation.NavigationHandlerAwareApplication;
private volatile Boolean isNavigationAwareApplicationWrapperActivated;
this.isNavigationAwareApplicationWrapperActivated =
ClassDeactivationUtils.isActivated(NavigationHandlerAwareApplication.class);
Application wrappedApplication = this.wrappedFacesContext.getApplication();
if (this.isNavigationAwareApplicationWrapperActivated)
{
wrappedApplication = new NavigationHandlerAwareApplication(wrappedApplication);
}
wrappedApplication, this.jsfModuleConfig, this.preDestroyViewMapEventFilterMode);
import org.apache.deltaspike.core.spi.activation.Deactivatable;
public class NavigationHandlerAwareApplication extends ApplicationWrapper implements Deactivatable
private static Boolean manualNavigationHandlerWrapperMode;
private static Class navigationHandlerWrapperClass;
public NavigationHandler getNavigationHandler()
return wrapNavigationHandler(this.wrapped.getNavigationHandler());
}
private NavigationHandler wrapNavigationHandler(NavigationHandler handler)
{
NavigationHandler result = null;
if (manualNavigationHandlerWrapperMode == null)
{
lazyInit();
}
if (!manualNavigationHandlerWrapperMode)
result = wrapNavigationHandlerWithNewWrapper(handler);
}
if (result != null)
{
return result;
return new DeltaSpikeNavigationHandler(handler);
}
private static synchronized void lazyInit()
{
if (manualNavigationHandlerWrapperMode != null)
{
return;
}
Class wrapperClass = ClassUtils
.tryToLoadClassForName("javax.faces.application.ConfigurableNavigationHandlerWrapper");
if (wrapperClass != null)
{
navigationHandlerWrapperClass =
ClassUtils.tryToLoadClassForName(
"org.apache.deltaspike.jsf.impl.navigation.DeltaSpikeNavigationHandlerWrapper");
manualNavigationHandlerWrapperMode = false;
}
else
{
manualNavigationHandlerWrapperMode = true;
}
}
private NavigationHandler wrapNavigationHandlerWithNewWrapper(NavigationHandler handler)
{
if (ConfigurableNavigationHandler.class.isAssignableFrom(handler.getClass()))
{
try
{
Constructor deltaSpikeNavigationHandlerWrapperConstructor =
this.navigationHandlerWrapperClass.getConstructor(ConfigurableNavigationHandler.class);
NavigationHandler navigationHandlerWrapper =
(NavigationHandler)deltaSpikeNavigationHandlerWrapperConstructor.newInstance(handler);
return  navigationHandlerWrapper;
}
catch (Exception e)
{
throw ExceptionUtils.throwAsRuntimeException(e);
}
}
return null;
List<String> messageSources = getMessageSources(messageContext);
protected List<String> getMessageSources(MessageContext messageContext)
{
return messageContext.getMessageSources();
}
import javax.enterprise.inject.Specializes;
@Specializes
public class JsfAwareLocaleResolver extends DefaultLocaleResolver
private static final long serialVersionUID = -8776583393262804931L;
}
result = facesContext.getApplication().getDefaultLocale();
if (result != null)
{
return result;
boolean supportedLocaleConfigured = false;
supportedLocaleConfigured = true;
if (!supportedLocaleConfigured)
{
return result;
}
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.PropertyFileUtils;
import org.apache.deltaspike.core.util.ProxyUtils;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.logging.Level;
private static final Logger LOG = Logger.getLogger(QuartzScheduler.class.getName());
SchedulerFactory schedulerFactory = null;
Properties properties = new Properties();
properties.put(StdSchedulerFactory.PROP_SCHED_JOB_FACTORY_CLASS, CdiAwareJobFactory.class.getName());
try
{
ResourceBundle config = loadCustomQuartzConfig();
Enumeration<String> keys = config.getKeys();
String key;
while (keys.hasMoreElements())
{
key = keys.nextElement();
properties.put(key, config.getString(key));
}
}
catch (Exception e1)
{
LOG.info("no custom quartz-config file found. falling back to the default config provided by quartz.");
InputStream inputStream = null;
try
{
inputStream = ClassUtils.getClassLoader(null).getResourceAsStream("org/quartz/quartz.properties");
properties.load(inputStream);
}
catch (Exception e2)
{
LOG.warning("failed to load quartz default-config");
schedulerFactory = new StdSchedulerFactory();
}
finally
{
if (inputStream != null)
{
inputStream.close();
}
}
}
if (schedulerFactory == null)
{
schedulerFactory = new StdSchedulerFactory(properties);
}
catch (Exception e)
LOG.log(Level.WARNING, "fallback to default scheduler-factory", e);
protected ResourceBundle loadCustomQuartzConfig()
{
String configFile =
ConfigResolver.getPropertyValue("deltaspike.scheduler.quartz_config-file", "quartz.properties");
return PropertyFileUtils.getResourceBundle(configFile);
}
Class<?> jobClass = ProxyUtils.getUnproxiedClass(jobExecutionContext.getJobInstance().getClass());
Scheduled scheduled = jobClass.getAnnotation(Scheduled.class);
boolean jobInstanceIsBean;
try
{
jobInstanceIsBean =
Boolean.TRUE.equals(jobExecutionContext.getScheduler().getContext().get(jobClass.getName()));
}
catch (SchedulerException e)
{
jobInstanceIsBean = false;
}
if (!jobInstanceIsBean)
{
BeanProvider.injectFields(jobExecutionContext.getJobInstance());
}
private boolean called = false;
called = true;
}
public boolean getCalled()
{
return called;
private boolean called = false;
called = true;
}
public boolean getCalled()
{
return called;
private boolean called = false;
called = true;
@View(name = "home")
class Step1 implements ViewConfig
String url = externalContext.getRequestContextPath()
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class DeltaSpikeResourceHandler extends ResourceHandlerWrapper implements Deactivatable
private final boolean activated;
activated = ClassDeactivationUtils.isActivated(this.getClass());
if (activated && resource != null && libraryName != null && LIBRARY.equals(libraryName))
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
AccessDeniedException accessDeniedException = new AccessDeniedException(violations);
ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(accessDeniedException);
exceptionToCatchEvent.setOptional(true);
beanManager.fireEvent(exceptionToCatchEvent);
if (!exceptionToCatchEvent.isHandled())
{
throw accessDeniedException;
}
throw new AccessDeniedException(violations);
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
import org.apache.deltaspike.security.api.authorization.AccessDeniedException;
import java.util.Set;
Set<Authorizer> authorizers = metaDataStorage.getAuthorizers(targetClass, method);
Object result = null;
if (invokeBeforeMethodInvocationAuthorizers(invocationContext, authorizers))
result = invocationContext.proceed();
invokeAfterMethodInvocationAuthorizers(invocationContext, authorizers, result);
private boolean invokeBeforeMethodInvocationAuthorizers(InvocationContext invocationContext,
Set<Authorizer> authorizers) throws IllegalAccessException
{
try
{
for (Authorizer authorizer : authorizers)
{
if (authorizer.isBeforeMethodInvocationAuthorizer())
{
authorizer.authorize(invocationContext, null, this.beanManager);
}
}
}
catch (AccessDeniedException ade)
{
return handleAccessDeniedException(ade);
}
return true;
}
private boolean invokeAfterMethodInvocationAuthorizers(InvocationContext invocationContext,
Set<Authorizer> authorizers, Object result) throws IllegalAccessException
{
try
{
for (Authorizer authorizer : authorizers)
{
if (authorizer.isAfterMethodInvocationAuthorizer())
{
authorizer.authorize(invocationContext, result, this.beanManager);
}
}
}
catch (AccessDeniedException ade)
{
return handleAccessDeniedException(ade);
}
return true;
}
private boolean handleAccessDeniedException(AccessDeniedException ade) throws AccessDeniedException
{
ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(ade);
exceptionToCatchEvent.setOptional(true);
beanManager.fireEvent(exceptionToCatchEvent);
if (!exceptionToCatchEvent.isHandled())
{
throw ade;
}
return false;
}
try
this.beanManager.fireEvent(exceptionToCatchEvent);
}
catch (AccessDeniedException e)
{
throw new SkipInternalProcessingException(accessDeniedException);
}
import org.apache.deltaspike.security.impl.authorization.SkipInternalProcessingException;
invokeBeforeMethodInvocationAuthorizers(invocationContext, authorizers);
Object result = invocationContext.proceed();
invokeAfterMethodInvocationAuthorizers(invocationContext, authorizers, result);
protected void invokeBeforeMethodInvocationAuthorizers(
InvocationContext invocationContext, Set<Authorizer> authorizers) throws IllegalAccessException
catch (SkipInternalProcessingException e)
throw e.getAccessDeniedException();
catch (AccessDeniedException e)
{
RuntimeException exceptionToThrow = handleAccessDeniedException(e);
if (exceptionToThrow != null)
{
throw exceptionToThrow;
}
}
protected void invokeAfterMethodInvocationAuthorizers(InvocationContext invocationContext,
catch (AccessDeniedException e)
RuntimeException exceptionToThrow = handleAccessDeniedException(e);
if (exceptionToThrow != null)
{
throw exceptionToThrow;
}
protected RuntimeException handleAccessDeniedException(AccessDeniedException originalException)
ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(originalException);
this.beanManager.fireEvent(exceptionToCatchEvent);
throw originalException;
return null;
}
QuerySelection<E, Long> count(SingularAttribute<E, ?> attribute);
QuerySelection<E, Long> countDistinct(SingularAttribute<E, ?> attribute);
CriteriaQuery<?> query = createCriteriaQuery(builder);
return (TypedQuery<R>) entityManager.createQuery(query);
void applyProcessors(CriteriaQuery<?> query, CriteriaBuilder builder, From<C, C> from)
private Selection<?>[] prepareSelections(CriteriaQuery<?> query, CriteriaBuilder builder, From<C, C> root)
private CriteriaQuery<?> createCriteriaQuery(CriteriaBuilder builder)
{
if (resultClass.getName().startsWith("java.lang"))
{
return builder.createQuery();
}
else
{
return builder.createQuery(resultClass);
}
}
import org.apache.deltaspike.data.api.criteria.QuerySelection;
public class Count<P> implements QuerySelection<P, Long>
private final SingularAttribute<P, ?> attribute;
public Count(SingularAttribute<P, ?> attribute)
this.attribute = attribute;
public <R> Selection<Long> toSelection(CriteriaQuery<R> query, CriteriaBuilder builder, Path<? extends P> path)
return builder.count(path.get(attribute));
import org.apache.deltaspike.data.impl.criteria.selection.numeric.CountDistinct;
public QuerySelection<E, Long> count(SingularAttribute<E, ?> attribute)
return new Count<E>(attribute);
}
@Override
public QuerySelection<E, Long> countDistinct(SingularAttribute<E, ?> attribute)
{
return new CountDistinct<E>(attribute);
public Long criteriaCount(String name)
{
return criteria()
.select(Long.class, countDistinct(Simple_.name))
.eq(Simple_.name, name)
.getSingleResult();
}
static boolean iaeHandlerCalled = false;
public void handleInbound(@Handles ExceptionEvent<IllegalArgumentException> event)
{
iaeHandlerCalled = true;
}
public static boolean isIaeHandlerCalled()
{
return iaeHandlerCalled;
}
ExceptionHandlerBroadcaster.class.getName(), "executeHandlers", exceptionEventEvent.getException());
inbound_cause:
throw exceptionEventEvent.getException();
throw callbackEvent.getThrowNewException();
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.event.Observes;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.spi.BeanManager;
import org.apache.deltaspike.core.api.exception.control.HandlerMethod;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionStackEvent;
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
import org.apache.deltaspike.core.api.provider.BeanProvider;
final BeanManager beanManager) throws Throwable
inbound_cause:
public static final String START_SCOPES_KEY = "deltaspike.scheduler.start_scopes_for_jobs";
final String startScopes = ConfigResolver
.getPropertyValue(START_SCOPES_KEY, "true");
if ("true".equalsIgnoreCase(startScopes))
{
this.scheduler.getListenerManager().addJobListener(new InjectionAwareJobListener());
}
import org.apache.deltaspike.core.util.ProxyUtils;
import org.apache.deltaspike.jsf.impl.injection.proxy.ProxyMarker;
if (result instanceof ProxyMarker || ProxyUtils.isProxiedClass(result.getClass()))
{
return result;
}
if (result instanceof ProxyMarker || ProxyUtils.isProxiedClass(result.getClass()))
{
return result;
}
import java.lang.annotation.Annotation;
@Observes ProcessAnnotatedType<X> pat, BeanManager beanManager)
Bean<X> bean = new BeanBuilder<X>(beanManager).readFromType(pat.getAnnotatedType()).create();
if (!hasInjectionPoints(bean) && !hasNormalScopeAnnotation(bean, beanManager))
{
pat.veto();
return;
}
protected <X> boolean hasInjectionPoints(Bean<X> bean)
{
return !bean.getInjectionPoints().isEmpty();
}
protected <X> boolean hasNormalScopeAnnotation(Bean<X> bean, BeanManager beanManager)
{
Class<? extends Annotation> scopeAnnotationClass = bean.getScope();
return  scopeAnnotationClass != null && beanManager.isNormalScope(scopeAnnotationClass);
}
private static ThreadLocal<JobListenerContext> currentJobListenerContext = new ThreadLocal<JobListenerContext>();
JobListenerContext jobListenerContext = new JobListenerContext();
currentJobListenerContext.set(jobListenerContext);
jobListenerContext.startContexts(scheduled);
JobListenerContext jobListenerContext = currentJobListenerContext.get();
if (jobListenerContext != null)
{
jobListenerContext.stopStartedScopes();
currentJobListenerContext.set(null);
currentJobListenerContext.remove();
}
}
}
private class JobListenerContext
{
private Stack<Class<? extends Annotation>> scopes = new Stack<Class<? extends Annotation>>();
private ContextControl contextControl;
public void startContexts(Scheduled scheduled)
{
Collections.addAll(this.scopes, scheduled.startScopes());
if (!this.scopes.isEmpty())
{
this.contextControl = BeanProvider.getContextualReference(ContextControl.class);
for (Class<? extends Annotation> scopeAnnotation : this.scopes)
{
contextControl.startContext(scopeAnnotation);
}
}
}
private void stopStartedScopes()
{
if (annotationClass.isAnnotationPresent(Stereotype.class))
public abstract class ApplicationScopedPartialBean
public abstract class DependentScopedPartialBean
import javax.enterprise.context.ApplicationScoped;
protected void buildViewConfigMetaDataTree(@Observes final ProcessAnnotatedType pat)
buildViewConfigMetaDataTreeFor(
pat.getAnnotatedType().getJavaClass(), pat.getAnnotatedType().getAnnotations(), new VetoCallback() {
@Override
public void veto()
{
pat.veto();
}
});
}
protected void buildViewConfigMetaDataTreeFor(Class beanClass,
Set<Annotation> annotations,
VetoCallback vetoCallback)
{
addConfigClass(beanClass, annotations);
vetoCallback.veto();
addConfigClass(beanClass, annotations);
vetoCallback.veto();
addIndirectlyInheritedMetaData(beanClass, annotations);
if (viewConfigClass.getAnnotation(ApplicationScoped.class) != null)
{
Set<Class> manuallyDiscoveredViewConfigs = new HashSet<Class>();
findNestedClasses(viewConfigClass, manuallyDiscoveredViewConfigs);
for (Class foundClass : manuallyDiscoveredViewConfigs)
{
buildViewConfigMetaDataTreeFor(
foundClass,
new HashSet<Annotation>(Arrays.asList(foundClass.getAnnotations())),
new VetoCallback() {
@Override
public void veto()
{
}
});
}
}
private void findNestedClasses(Class viewConfigClass, Set<Class> nestedClasses)
{
for (Class nestedClass : viewConfigClass.getDeclaredClasses())
{
nestedClasses.add(nestedClass);
findNestedClasses(nestedClass, nestedClasses);
}
}
interface VetoCallback
{
void veto();
}
ConfigResolver.getPropertyValue("deltaspike.scheduler.quartz_config-file", "quartz");
private AccessDeniedExceptionBroadcaster exceptionBroadcaster;
this.exceptionBroadcaster.broadcastAccessDeniedException(new AccessDeniedException(violations));
private static final long serialVersionUID = 3585306529694592791L;
ClassLoader currentClassLoader = ConfigResolver.class.getClassLoader();
configSources.remove(ConfigResolver.class.getClassLoader());
ClassLoader cl = ConfigResolver.class.getClassLoader();
ClassLoader currentClassLoader = ConfigResolver.class.getClassLoader();
import org.apache.deltaspike.jsf.impl.message.JsfMessageResolver;
public class CustomMessageResolver extends JsfMessageResolver
private static final long serialVersionUID = -7566133260553818285L;
import javax.faces.application.FacesMessage;
import java.util.ArrayList;
List<FacesMessage> originalMessageList = new ArrayList<FacesMessage>(facesContext.getMessageList());
for (FacesMessageEntry messageEntry : facesMessageEntryList)
if (isNewMessage(originalMessageList, messageEntry.getFacesMessage()))
{
facesContext.addMessage(messageEntry.getComponentId(), messageEntry.getFacesMessage());
}
public static boolean isNewMessage(List<FacesMessage> facesMessages, FacesMessage messageToCheck)
{
for (FacesMessage facesMessage : facesMessages)
{
if ((facesMessage.getSummary() != null && facesMessage.getSummary().equals(messageToCheck.getSummary()) ||
facesMessage.getSummary() == null && messageToCheck.getSummary() == null) &&
(facesMessage.getDetail() != null && facesMessage.getDetail().equals(messageToCheck.getDetail()) ||
facesMessage.getDetail() == null && messageToCheck.getDetail() == null))
{
return false;
}
}
return true;
}
if (parentClassLoader == null || parentClassLoader.equals(ClassLoader.getSystemClassLoader()))
import javax.inject.Inject;
import org.apache.deltaspike.core.api.common.DeltaSpike;
@Inject
@DeltaSpike
private ServletContext servletContext;
if (servletContext != null)
{
eventLog.add("ServletContext was injected");
}
StringBuilder finalUrl = SharedStringBuilder.get(SB_ADD_PARAMETER);
finalUrl.append(url);
private static final String CACHE_QUERY_URL_PARAMETERS =
if (!facesContext.getAttributes().containsKey(CACHE_QUERY_URL_PARAMETERS))
String windowId = getWindowId(facesContext);
if (windowId == null)
{
return null;
}
params.put(DELTASPIKE_WINDOW_ID_URL_PARAM, windowId);
facesContext.getAttributes().put(CACHE_QUERY_URL_PARAMETERS, params);
return (Map<String, String>) facesContext.getAttributes().get(CACHE_QUERY_URL_PARAMETERS);
return originalException;
ContextControl createContextControl();
import java.util.logging.Logger;
private static final Logger LOG = Logger.getLogger(OpenEjbContainerControl.class.getName());
@Override
public ContextControl createContextControl()
{
BeanManager beanManager = getBeanManager();
if (beanManager == null)
{
LOG.warning("If the CDI-container was started by the environment, you can't use this helper."
"Instead you can resolve ContextControl manually "
"(e.g. via BeanProvider.getContextualReference(ContextControl.class) ). "
"If the container wasn't started already, you have to use CdiContainer#boot before.");
return null;
}
Set<Bean<?>> beans = beanManager.getBeans(ContextControl.class);
Bean<ContextControl> depCtxCtrlBean = (Bean<ContextControl>) beanManager.resolve(beans);
CreationalContext<ContextControl> depCtxCtrlCreationalContext = getBeanManager()
.createCreationalContext(ctxCtrlBean);
return (ContextControl)
getBeanManager().getReference(depCtxCtrlBean, ContextControl.class, depCtxCtrlCreationalContext);
}
@Override
public ContextControl createContextControl()
{
BeanManager beanManager = getBeanManager();
if (beanManager == null)
{
LOG.warning("If the CDI-container was started by the environment, you can't use this helper."
"Instead you can resolve ContextControl manually "
"(e.g. via BeanProvider.getContextualReference(ContextControl.class) ). "
"If the container wasn't started already, you have to use CdiContainer#boot before.");
return null;
}
Set<Bean<?>> beans = beanManager.getBeans(ContextControl.class);
Bean<ContextControl> depCtxCtrlBean = (Bean<ContextControl>) beanManager.resolve(beans);
CreationalContext<ContextControl> depCtxCtrlCreationalContext = getBeanManager()
.createCreationalContext(ctxCtrlBean);
return (ContextControl)
getBeanManager().getReference(depCtxCtrlBean, ContextControl.class, depCtxCtrlCreationalContext);
}
@Override
public ContextControl createContextControl()
{
BeanManager beanManager = getBeanManager();
if (beanManager == null)
{
LOG.warning("If the CDI-container was started by the environment, you can't use this helper."
"Instead you can resolve ContextControl manually "
"(e.g. via BeanProvider.getContextualReference(ContextControl.class) ). "
"If the container wasn't started already, you have to use CdiContainer#boot before.");
return null;
}
Set<Bean<?>> beans = beanManager.getBeans(ContextControl.class);
Bean<ContextControl> depCtxCtrlBean = (Bean<ContextControl>) beanManager.resolve(beans);
CreationalContext<ContextControl> depCtxCtrlCreationalContext = getBeanManager()
.createCreationalContext(ctxCtrlBean);
return (ContextControl)
getBeanManager().getReference(depCtxCtrlBean, ContextControl.class, depCtxCtrlCreationalContext);
}
BeanManager beanManager = getBeanManager();
if (beanManager == null)
{
LOG.warning("If the CDI-container was started by the environment, you can't use this helper."
"Instead you can resolve ContextControl manually "
"(e.g. via BeanProvider.getContextualReference(ContextControl.class) ). "
"If the container wasn't started already, you have to use CdiContainer#boot before.");
return null;
}
Set<Bean<?>> beans = beanManager.getBeans(ContextControl.class);
ctxCtrlBean = (Bean<ContextControl>) beanManager.resolve(beans);
ctxCtrlCreationalContext = getBeanManager()
.createCreationalContext(ctxCtrlBean);
Set<Bean<?>> beans = beanManager.getBeans(ContextControl.class);
ctxCtrl.stopContexts();
ctxCtrl.stopContexts();
ctxCtrl.stopContexts();
try
{
ctxCtrl.stopContexts();
}
catch (Exception e)
{
}
try
{
ctxCtrl.stopContexts();
}
catch (Exception e)
{
}
try
{
ctxCtrl.stopContexts();
ctxCtrlBean.destroy(ctxCtrl, ctxCtrlCreationalContext);
}
catch (Exception e)
{
}
try
{
weld.shutdown();
}
catch (Exception e)
{
}
if (context == null || context.getResponseComplete())
import org.apache.deltaspike.core.api.config.view.DefaultErrorView;
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
import org.apache.deltaspike.jsf.impl.util.SecurityUtils;
import org.apache.deltaspike.security.api.authorization.AccessDeniedException;
import org.apache.deltaspike.security.api.authorization.ErrorViewAwareAccessDeniedException;
if (rootCause instanceof AccessDeniedException)
processAccessDeniedException(rootCause);
continue;
}
else
{
ExceptionToCatchEvent event = new ExceptionToCatchEvent(rootCause, exceptionQualifier);
event.setOptional(true);
beanManager.fireEvent(event);
if (event.isHandled())
{
iterator.remove();
}
return JsfUtils.getRootCause(throwable);
if (exception instanceof AccessDeniedException)
processAccessDeniedException(exception);
}
else
{
ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(exception);
exceptionToCatchEvent.setOptional(true);
this.beanManager.fireEvent(exceptionToCatchEvent);
if (exceptionToCatchEvent.isHandled())
{
return;
}
private void processAccessDeniedException(Throwable throwable)
{
if (throwable instanceof ErrorViewAwareAccessDeniedException)
{
SecurityUtils.handleSecurityViolationWithoutNavigation((AccessDeniedException) throwable);
}
else
{
ErrorViewAwareAccessDeniedException securityException =
new ErrorViewAwareAccessDeniedException(
((AccessDeniedException)throwable).getViolations(), DefaultErrorView.class);
SecurityUtils.handleSecurityViolationWithoutNavigation(securityException);
}
}
import org.apache.deltaspike.core.util.ExceptionUtils;
broadcastAccessDeniedException(accessDeniedException);
protected void broadcastAccessDeniedException(ErrorViewAwareAccessDeniedException accessDeniedException)
{
AccessDeniedExceptionBroadcaster exceptionBroadcaster =
BeanProvider.getContextualReference(AccessDeniedExceptionBroadcaster.class);
Throwable broadcastResult = exceptionBroadcaster.broadcastAccessDeniedException(accessDeniedException);
if (broadcastResult != null)
{
throw ExceptionUtils.throwAsRuntimeException(broadcastResult);
}
}
import javax.el.ELException;
import javax.faces.FacesException;
import java.lang.reflect.InvocationTargetException;
public static Throwable getRootCause(Throwable throwable)
{
while ((ELException.class.isInstance(throwable) || FacesException.class.isInstance(throwable) ||
InvocationTargetException.class.isInstance(throwable)) && throwable.getCause() != null)
{
throwable = throwable.getCause();
}
return throwable;
}
import org.apache.deltaspike.data.api.AbstractEntityRepository;
if (isVetoed(event.getAnnotatedType()))
{
event.veto();
}
else if (isRepository(event.getAnnotatedType()))
private <X> boolean isVetoed(AnnotatedType<X> annotated)
{
return annotated.getJavaClass().equals(AbstractEntityRepository.class);
}
if (cl.getParent() != null)
{
bmpSingleton.bmInfos.put(cl.getParent(), bmi);
}
<P extends Comparable<? super P>> Criteria<C, R> lt(SingularAttribute<? super C, P> att, P value);
<P extends Comparable<? super P>> Criteria<C, R> gt(SingularAttribute<? super C, P> att, P value);
public <P extends Comparable<? super P>> Criteria<C, R> lt(SingularAttribute<? super C, P> att, P value)
public <P extends Comparable<? super P>> Criteria<C, R> gt(SingularAttribute<? super C, P> att, P value)
public class GreaterThan<E, V extends Comparable<? super V>> extends SingleValueBuilder<E, V>
return Arrays.asList(builder.greaterThan(path.get(getAtt()), getValue()));
public class LessThan<E, V extends Comparable<? super V>> extends SingleValueBuilder<E, V>
return Arrays.asList(builder.lessThan(path.get(getAtt()), getValue()));
import java.util.Date;
public List<Simple> findByTimeBetween(Date from, Date to) {
return criteria()
.gt(Simple_.temporal, from)
.lt(Simple_.temporal, to)
.getResultList();
}
<X> QuerySelection<E, X> attribute(SingularAttribute<? super E, X> attribute);
<N extends Number> QuerySelection<E, N> abs(SingularAttribute<? super E, N> attribute);
<N extends Number> QuerySelection<E, N> avg(SingularAttribute<? super E, N> attribute);
QuerySelection<E, Long> count(SingularAttribute<? super E, ?> attribute);
QuerySelection<E, Long> countDistinct(SingularAttribute<? super E, ?> attribute);
<N extends Number> QuerySelection<E, N> max(SingularAttribute<? super E, N> attribute);
<N extends Number> QuerySelection<E, N> min(SingularAttribute<? super E, N> attribute);
<N extends Number> QuerySelection<E, N> neg(SingularAttribute<? super E, N> attribute);
<N extends Number> QuerySelection<E, N> sum(SingularAttribute<? super E, N> attribute);
QuerySelection<E, Integer> modulo(SingularAttribute<? super E, Integer> attribute, Integer modulo);
QuerySelection<E, String> upper(SingularAttribute<? super E, String> attribute);
QuerySelection<E, String> lower(SingularAttribute<? super E, String> attribute);
QuerySelection<E, String> substring(SingularAttribute<? super E, String> attribute, int from);
QuerySelection<E, String> substring(SingularAttribute<? super E, String> attribute, int from, int length);
public AttributeQuerySelection(SingularAttribute<? super P, X> attribute)
protected final SingularAttribute<? super P, X> attribute;
public SingularAttributeSelection(SingularAttribute<? super P, X> attribute)
public SingularAttribute<? super P, X> getAttribute()
public Abs(SingularAttribute<? super P, X> attribute)
public Avg(SingularAttribute<? super P, X> attribute)
private final SingularAttribute<? super P, ?> attribute;
public Count(SingularAttribute<? super P, ?> attribute)
private final SingularAttribute<? super P, ?> attribute;
public CountDistinct(SingularAttribute<? super P, ?> attribute)
public Max(SingularAttribute<? super P, X> attribute)
public Min(SingularAttribute<? super P, X> attribute)
public Modulo(SingularAttribute<? super P, Integer> attribute, Integer modulo)
public Neg(SingularAttribute<? super P, X> attribute)
public Sum(SingularAttribute<? super P, X> attribute)
public Lower(SingularAttribute<? super P, String> attribute)
public SubstringFrom(SingularAttribute<? super P, String> attribute, int from)
public SubstringFromTo(SingularAttribute<? super P, String> attribute, int from, int length)
public Upper(SingularAttribute<? super P, String> attribute)
public <X> QuerySelection<E, X> attribute(SingularAttribute<? super E, X> attribute)
public <N extends Number> QuerySelection<E, N> abs(SingularAttribute<? super E, N> attribute)
public <N extends Number> QuerySelection<E, N> avg(SingularAttribute<? super E, N> attribute)
public QuerySelection<E, Long> count(SingularAttribute<? super E, ?> attribute)
public QuerySelection<E, Long> countDistinct(SingularAttribute<? super E, ?> attribute)
public <N extends Number> QuerySelection<E, N> max(SingularAttribute<? super E, N> attribute)
public <N extends Number> QuerySelection<E, N> min(SingularAttribute<? super E, N> attribute)
public <N extends Number> QuerySelection<E, N> neg(SingularAttribute<? super E, N> attribute)
public <N extends Number> QuerySelection<E, N> sum(SingularAttribute<? super E, N> attribute)
public QuerySelection<E, Integer> modulo(SingularAttribute<? super E, Integer> attribute, Integer modulo)
public QuerySelection<E, String> upper(SingularAttribute<? super E, String> attribute)
public QuerySelection<E, String> lower(SingularAttribute<? super E, String> attribute)
public QuerySelection<E, String> substring(SingularAttribute<? super E, String> attribute, int from)
public QuerySelection<E, String> substring(SingularAttribute<? super E, String> attribute, int from, int length)
public class Simple extends SuperSimple
import org.apache.deltaspike.data.test.domain.SuperSimple_;
public Simple findBySuperName(String superName) {
return criteria()
.eq(SuperSimple_.superName, superName)
.getSingleResult();
}
try
{
if (errorViewDescriptor != null && View.NavigationMode.REDIRECT ==
.isAlwaysUseNavigationHandlerOnSecurityViolation())
{
SecurityUtils.tryToHandleSecurityViolation(accessDeniedException);
errorView = errorViewDescriptor.getConfigClass();
}
else
{
errorView = SecurityUtils.handleSecurityViolationWithoutNavigation(accessDeniedException);
}
finally
broadcastAccessDeniedException(accessDeniedException);
import java.util.Date;
private Date lastTimeLinkAction;
public Date getLastTimeLinkAction()
{
return lastTimeLinkAction;
}
public void linkAction()
{
FacesContext context = FacesContext.getCurrentInstance();
lastTimeLinkAction = new Date();
}
import javax.faces.FacesException;
import java.lang.reflect.InvocationTargetException;
try
if (proceedMethod != null)
{
return proceedMethod.invoke(target, arguments);
}
return this.handlerInstance.invoke(target, method, arguments);
catch (InvocationTargetException e)
{
if (e.getCause() instanceof FacesException)
{
throw e.getCause();
}
throw e;
}
import javax.enterprise.inject.Stereotype;
List<Annotation> viewMetaDataFromStereotype = new ArrayList<Annotation>();
if (annotation.annotationType().isAnnotationPresent(Stereotype.class))
{
for (Annotation metaAnnotation : annotation.annotationType().getAnnotations())
{
if (metaAnnotation.annotationType().isAnnotationPresent(ViewMetaData.class))
{
viewMetaDataFromStereotype.add(metaAnnotation);
}
}
}
List<Annotation> result = mergeAnnotationInstances(viewMetaDataFromStereotype, nodeViewMetaData);
if (inheritedMetaData != null && !inheritedMetaData.isEmpty())
result = mergeAnnotationInstances(inheritedMetaData, result);
return result;
}
private List<Annotation> mergeAnnotationInstances(List<Annotation> inheritedMetaData, List<Annotation> nodeMetaData)
{
Annotation currentNodeMetaData = findInResult(nodeMetaData, inheritedAnnotation);
mergedResult.addAll(0, nodeMetaData);
import javax.servlet.http.Cookie;
import org.apache.deltaspike.jsf.impl.util.ClientWindowHelper;
Object cookie = ClientWindowHelper.getRequestWindowIdCookie(context, windowId);
if (cookie != null && cookie instanceof Cookie)
{
Cookie servletCookie = (Cookie) cookie;
ClientWindowHelper.removeRequestWindowIdCookie(context, servletCookie);
}
import java.util.HashMap;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletResponse;
{
public static final String REQUEST_WINDOW_ID_COOKIE_PREFIX = "dsrwid-";
addRequestWindowIdCookie(facesContext, newWindowId);
public static void addRequestWindowIdCookie(FacesContext context, String windowId)
{
Map<String, Object> properties = new HashMap();
properties.put("path", "/");
properties.put("maxAge", 30);
context.getExternalContext().addResponseCookie(
}
public static Object getRequestWindowIdCookie(FacesContext context, String windowId)
{
Map<String, Object> cookieMap = context.getExternalContext().getRequestCookieMap();
{
}
return null;
}
public static void removeRequestWindowIdCookie(FacesContext context, Cookie cookie)
{
cookie.setMaxAge(0);
((HttpServletResponse) context.getExternalContext().getResponse()).addCookie(cookie);
}
List<Class<? extends AccessDecisionVoter>> voterClasses = new ArrayList<Class<? extends AccessDecisionVoter>>();
voterClasses.addAll(Arrays.asList(((Secured) annotation).value()));
invokeVoters(invocationContext, voterClasses);
if (accessDecisionVoters.isEmpty())
import javax.enterprise.inject.spi.AnnotatedMethod;
import java.util.HashSet;
Set<Annotation> annotations = new HashSet<Annotation>();
annotations.addAll(annotated.getAnnotations());
for (AnnotatedMethod annotatedMethod :
(Set<javax.enterprise.inject.spi.AnnotatedMethod>)((AnnotatedType) annotated).getMethods())
{
annotations.addAll(annotatedMethod.getAnnotations());
}
beanManager, annotations, origin.getName()))
while (cls != null && !cls.equals(Object.class))
import javax.enterprise.inject.Typed;
if (type.isAnnotationPresent(Typed.class))
Typed typed = type.getAnnotation(Typed.class);
this.types.addAll(Arrays.asList(typed.value()));
else
for (Class<?> c = type.getJavaClass(); c != Object.class && c != null; c = c.getSuperclass())
{
this.types.add(c);
}
for (Class<?> i : type.getJavaClass().getInterfaces())
{
this.types.add(i);
}
}
List<ConfigSource> appConfigSources = sortAscending(Arrays.<ConfigSource> asList(getConfigSources()));
String value = configSource.getPropertyValue(key);
List<ConfigSource> appConfigSources = sortAscending(Arrays.<ConfigSource> asList(getConfigSources()));
if (value == null || value.isEmpty())
for (Map.Entry<?, ?> entry : p.entrySet())
if (!ConfigSource.DELTASPIKE_ORDINAL.equals(key))
String beanName = named == null ? null : named.value();
Class<?> value();
protected Descriptor(Class<?> beanClass, Class<? extends Annotation> callbackType)
protected CallbackDescriptor(Class<?> beanClass, Class<? extends Annotation> callbackMarker)
protected CallbackDescriptor(Class<?>[] beanClasses, Class<? extends Annotation> callbackMarker)
protected void init(Class<?>[] targetBeanClasses, Class<? extends Annotation> callbackMarker)
for (Class<?> targetBeanClass : targetBeanClasses)
public Map<Class<?>, List<Method>> getCallbackMethods()
Map<Class<?>, List<Method>> result = new HashMap<Class<?>, List<Method>>(this.callbacks.size());
protected <T> T getTargetObject(Class<T> targetType)
private CallbackEntry(Class<?> beanClass, Class<? extends Annotation> callbackMarker)
Class<?> classToAnalyze,
Class<?> currentClass = classToAnalyze;
for (Class<?> interfaceClass : currentClass.getInterfaces())
@SuppressWarnings("rawtypes")
@SuppressWarnings("rawtypes")
protected ExecutableCallbackDescriptor(Class<?> beanClass, Class<? extends Annotation> callbackMarker)
protected ExecutableCallbackDescriptor(Class<?>[] beanClasses, Class<? extends Annotation> callbackMarker)
@SuppressWarnings("unchecked")
Class<? extends TargetViewConfigProvider<?>> targetViewConfigProvider();
@SuppressWarnings("rawtypes")
protected SimpleCallbackDescriptor(Class<?> beanClass, Class<? extends Annotation> callbackMarker)
protected SimpleCallbackDescriptor(Class<?>[] beanClasses, Class<? extends Annotation> callbackMarker)
ConfigDescriptor<?> getConfigDescriptor(Class<?> configClass);
@SuppressWarnings("rawtypes")
@SuppressWarnings("rawtypes")
private static BeanManagerProvider bmpSingleton;
private BeanManager loadTimeBm;
private BeanManager finalBm;
private boolean booted;
bmi.loadTimeBm = beanManager;
bmpSingleton.bmInfos.remove(ClassUtils.getClassLoader(null));
BeanManagerInfo parentBmi = getParentBeanManagerInfo(ClassUtils.getClassLoader(null));
private static final boolean LOG_DEPENDENT_WARNINGS =
Arrays.asList(ProjectStage.Development, ProjectStage.UnitTest).contains(
ProjectStageProducer.getInstance().getProjectStage());
return getContextualReference(type, beanManager, Collections.<Bean<?>> singleton(bean));
@SuppressWarnings("unchecked")
Bean<T> bean = (Bean<T>) beanManager.resolve(beans);
return createDependentProvider(beanManager, type, bean);
@SuppressWarnings("unchecked")
Bean<T> bean = (Bean<T>) beanManager.resolve(beans);
@SuppressWarnings("unchecked")
Class<T> beanClass = (Class<T>) bean.getBeanClass();
return createDependentProvider(beanManager, beanClass, bean);
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
Bean<T> beanT = (Bean<T>) bean;
result.add(beanT);
CreationalContext<T> creationalContext = beanManager.createCreationalContext(null);
AnnotatedType<T> annotatedType = beanManager.createAnnotatedType((Class<T>) instance.getClass());
InjectionTarget<T> injectionTarget = beanManager.createInjectionTarget(annotatedType);
for (Bean<?> currentBean : beans)
@SuppressWarnings("unchecked")
String beanName;
if (named == null)
{
beanName = null;
}
else
{
beanName = named.value();
}
private static final boolean LOG_DEPENDENT_WARNINGS;
static
{
LOG_DEPENDENT_WARNINGS =
Arrays.asList(ProjectStage.Development, ProjectStage.UnitTest).contains(
ProjectStageProducer.getInstance().getProjectStage());
}
List<ConfigSource> appConfigSources = sortAscending(new ArrayList<ConfigSource>(
Arrays.<ConfigSource> asList(getConfigSources())));
List<ConfigSource> appConfigSources = sortAscending(new ArrayList<ConfigSource>(
Arrays.<ConfigSource> asList(getConfigSources())));
interface RedirectedPages extends ViewConfig
interface SecuredPages extends ViewConfig
interface ViewConfigFolder extends ViewConfig
class RedirectedPage implements RedirectedPages
class ViewConfigPage implements RedirectedPages
class NavigationParameterPage implements RedirectedPages
class SecuredPage implements SecuredPages
class AllowedPage implements ViewConfig
.addPackages(true, "javassist")
@Override
public String toString()
{
return "MockHttpSession{"
'}';
}
ctxCtrl = null;
import java.util.WeakHashMap;
import java.util.concurrent.atomic.AtomicInteger;
private static WeakHashMap<ContextsService, AtomicInteger> sessionRefCounters
= new WeakHashMap<ContextsService, AtomicInteger>();
incrementSessionRefCount(contextsService);
if (decrementSessionRefCount(contextsService))
{
contextsService.endContext(SessionScoped.class, mockSession);
}
private synchronized void incrementSessionRefCount(ContextsService contextsService)
{
AtomicInteger sessionRefCounter = sessionRefCounters.get(contextsService);
if (sessionRefCounter == null)
{
sessionRefCounter = new AtomicInteger(1);
sessionRefCounters.put(contextsService, sessionRefCounter);
}
else
{
sessionRefCounter.incrementAndGet();
}
}
private synchronized boolean decrementSessionRefCount(ContextsService contextsService)
{
AtomicInteger sessionRefCounter = sessionRefCounters.get(contextsService);
if (sessionRefCounter == null)
{
return false;
}
return sessionRefCounter.decrementAndGet() <= 0;
}
import javax.enterprise.inject.Instance;
import java.util.concurrent.atomic.AtomicInteger;
private static ThreadLocal<RequestContextHolder> requestContexts = new ThreadLocal<RequestContextHolder>();
private Instance<BoundRequestContext> requestContextFactory;
private AtomicInteger sessionRefCounter = new AtomicInteger(0);
synchronized void startSessionScope()
sessionRefCounter.incrementAndGet();
synchronized void stopSessionScope()
if (sessionRefCounter.decrementAndGet() <= 0)
{
sessionMap = null;
}
synchronized void startConversationScope(String cid)
RequestContextHolder rcHolder = requestContexts.get();
if (rcHolder == null)
{
startRequestScope();
rcHolder = requestContexts.get();
}
conversationContext.associate(new MutableBoundRequest(rcHolder.requestMap, sessionMap));
synchronized void stopConversationScope()
RequestContextHolder rcHolder = requestContexts.get();
if (rcHolder == null)
{
startRequestScope();
rcHolder = requestContexts.get();
}
conversationContext.dissociate(new MutableBoundRequest(rcHolder.getRequestMap(), sessionMap));
synchronized void startRequestScope()
RequestContextHolder rcHolder = requestContexts.get();
if (rcHolder == null)
rcHolder = new RequestContextHolder(requestContextFactory.get(), new HashMap<String, Object>());
requestContexts.set(rcHolder);
rcHolder.getBoundRequestContext().associate(rcHolder.getRequestMap());
rcHolder.getBoundRequestContext().activate();
synchronized void stopRequestScope()
RequestContextHolder rcHolder = requestContexts.get();
if (rcHolder != null && rcHolder.getBoundRequestContext().isActive())
rcHolder.getBoundRequestContext().invalidate();
rcHolder.getBoundRequestContext().deactivate();
rcHolder.getBoundRequestContext().dissociate(rcHolder.getRequestMap());
requestContexts.set(null);
requestContexts.remove();
}
}
private static class RequestContextHolder
{
private final BoundRequestContext boundRequestContext;
private final Map<String, Object> requestMap;
private RequestContextHolder(BoundRequestContext boundRequestContext, Map<String, Object> requestMap)
{
this.boundRequestContext = boundRequestContext;
this.requestMap = requestMap;
}
public BoundRequestContext getBoundRequestContext()
{
return boundRequestContext;
}
public Map<String, Object> getRequestMap()
{
return requestMap;
getContextController().startApplicationScope();
getContextController().startSessionScope();
getContextController().startConversationScope(null);
getContextController().startRequestScope();
getContextController().stopApplicationScope();
getContextController().stopSessionScope();
getContextController().stopConversationScope();
getContextController().stopRequestScope();
getContextController().stopSingletonScope();
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.spi.scope.window.WindowContextQuotaHandler;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import org.apache.deltaspike.core.util.ProxyUtils;
import org.apache.deltaspike.core.util.context.ContextualStorage;
import javax.annotation.PostConstruct;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
@Inject
private WindowContextQuotaHandler windowContextQuotaHandler;
private boolean windowContextQuotaHandlerEnabled;
@PostConstruct
protected void init()
{
Class<? extends Deactivatable> windowContextQuotaHandlerClass =
ProxyUtils.getUnproxiedClass(windowContextQuotaHandler.getClass());
this.windowContextQuotaHandlerEnabled = ClassDeactivationUtils.isActivated(windowContextQuotaHandlerClass);
}
@Override
public ContextualStorage getContextualStorage(BeanManager beanManager, String key, boolean createIfNotExist)
{
ContextualStorage result = super.getContextualStorage(beanManager, key, createIfNotExist);
if (this.windowContextQuotaHandlerEnabled)
{
this.windowContextQuotaHandler.checkWindowContextQuota(key);
}
return result;
}
int getMaxWindowContextCount();
import org.apache.deltaspike.core.api.config.ConfigResolver;
private int maxWindowContextCount;
this.maxWindowContextCount = Integer.parseInt(maxCount);
@Override
public int getMaxWindowContextCount()
{
return this.maxWindowContextCount;
}
import org.apache.deltaspike.core.spi.scope.viewaccess.ViewAccessContextManager;
import javax.enterprise.context.spi.Contextual;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.Typed;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.PassivationCapable;
import java.lang.annotation.Annotation;
import java.util.Map;
@Typed()
public class ViewAccessContext extends AbstractContext implements ViewAccessContextManager
close(view, false);
}
public void close(String view, boolean force)
{
if (force || !view.equals(viewAccessViewHistory.getLastView()))
destroyExpiredBeans(force);
private void destroyExpiredBeans(boolean force)
if (force || !viewAccessBeanAccessHistory.getAccessedBeans().contains((String) storageEntry.getKey()))
@Override
public void close()
{
close(null, true);
}
private static final int SECURE_ID_LENGTH = 10;
String windowId = getOrCreateWindowId(facesContext);
if (windowId != null && windowId.length() > SECURE_ID_LENGTH)
{
windowId = windowId.substring(0, SECURE_ID_LENGTH);
}
return windowId;
}
protected String getOrCreateWindowId(FacesContext facesContext)
{
import org.apache.deltaspike.jsf.impl.scope.window.DefaultClientWindow;
if (windowId != null && windowId.length() > DefaultClientWindow.SECURE_ID_LENGTH)
{
windowId = windowId.substring(0, DefaultClientWindow.SECURE_ID_LENGTH);
}
public static final int SECURE_ID_LENGTH = 10;
private ViewConfigResolver viewConfigResolver;
lazyInit();
entry = this.viewConfigResolver.getDefaultErrorViewConfigDescriptor();
entry = this.viewConfigResolver
return this.viewConfigResolver.getViewConfigDescriptor(navigateEvent.getToView());
ViewConfigDescriptor oldViewConfigDescriptor = this.viewConfigResolver.getViewConfigDescriptor(oldViewId);
private void lazyInit()
{
if (this.beanManager == null)
{
init();
}
}
private synchronized void init()
this.viewConfigResolver =
BeanProvider.getContextualReference(ViewConfigResolver.class);
if (targetUrl.contains("dswid=&"))
{
targetUrl = targetUrl.replace("dswid=&", "");
}
url = facesContext.getExternalContext().encodeActionURL(url);
url = facesContext.getExternalContext().encodeResourceURL(url);
private int maxWindowIdCount = 10;
if (windowId != null && windowId.length() > this.maxWindowIdCount)
windowId = windowId.substring(0, this.maxWindowIdCount);
maxWindowIdCount = ClientWindowHelper.getMaxWindowIdLength();
import javax.annotation.PostConstruct;
private int maxWindowIdCount = 10;
@PostConstruct
protected void init()
{
this.maxWindowIdCount = ClientWindowHelper.getMaxWindowIdLength();
}
if (windowId != null && windowId.length() > this.maxWindowIdCount)
windowId = windowId.substring(0, this.maxWindowIdCount);
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.deltaspike.core.api.config.ConfigResolver;
{
private static final Logger LOG = Logger.getLogger(ClientWindowHelper.class.getName());
public static int getMaxWindowIdLength()
{
if (result > 10)
{
if (LOG.isLoggable(Level.WARNING))
{
LOG.warning("ATTENTION: if you change this value to be significant longer than 10, "
"you can introduce a security issue in WindowIdHtmlRenderer. "
"If you increase it because window.name contains a value already, "
"please revisit that usage or "
"create shorter unique ids since they just need to be unique within the user-session.");
}
}
return result;
}
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.deltaspike.data.impl.util.cl.AggregatedClassLoader;
private static final Logger log = Logger.getLogger(DescriptorReader.class.getName());
try
{
result.add(readFromUrl(u));
}
catch (Exception e)
{
}
catch (Exception e)
return AggregatedClassLoader.newInstance();
catch (Exception e)
return container.getContextControl();
private static ThreadLocal<Object> mockSessions = new ThreadLocal<Object>();
mockSession = mockSessions.get();
if (mockSession == null)
{
mockSession = OwbHelper.getMockSession(Thread.currentThread().getName());
mockSessions.set(mockSession);
}
mockSession = mockSessions.get();
mockSessions.set(null);
mockSessions.remove();
contextsService.endContext(SessionScoped.class, mockSession);
public static Object getMockSession(String sessionId)
return new MockHttpSession(sessionId);
import javax.enterprise.inject.Instance;
import java.util.HashMap;
import java.util.Map;
import org.jboss.weld.context.AbstractSharedContext;
import org.jboss.weld.context.ApplicationContext;
import org.jboss.weld.context.bound.BoundConversationContext;
import org.jboss.weld.context.bound.BoundRequestContext;
import org.jboss.weld.context.bound.BoundSessionContext;
import org.jboss.weld.context.bound.MutableBoundRequest;
private static ThreadLocal<RequestContextHolder> requestContexts = new ThreadLocal<RequestContextHolder>();
private static ThreadLocal<Map<String, Object>> sessionMaps = new ThreadLocal<Map<String, Object>>();
private ApplicationContext applicationContext;
@Inject
private BoundSessionContext sessionContext;
@Inject
private Instance<BoundRequestContext> requestContextFactory;
@Inject
private BoundConversationContext conversationContext;
startConversationScope(null);
startConversationScope(null);
}
private void stopApplicationScope()
{
if (applicationContext.isActive())
{
applicationContext.invalidate();
if (applicationContext instanceof AbstractSharedContext)
{
((AbstractSharedContext) applicationContext).getBeanStore().clear();
}
}
}
void startRequestScope()
{
RequestContextHolder rcHolder = requestContexts.get();
if (rcHolder == null)
{
rcHolder = new RequestContextHolder(requestContextFactory.get(), new HashMap<String, Object>());
requestContexts.set(rcHolder);
}
else
{
}
rcHolder.getBoundRequestContext().associate(rcHolder.getRequestMap());
rcHolder.getBoundRequestContext().activate();
}
void stopRequestScope()
{
RequestContextHolder rcHolder = requestContexts.get();
if (rcHolder != null && rcHolder.getBoundRequestContext().isActive())
{
rcHolder.getBoundRequestContext().invalidate();
rcHolder.getBoundRequestContext().deactivate();
rcHolder.getBoundRequestContext().dissociate(rcHolder.getRequestMap());
requestContexts.set(null);
requestContexts.remove();
}
Map<String, Object> sessionMap = sessionMaps.get();
if (sessionMap == null)
{
sessionMap = new HashMap<String, Object>();
sessionMaps.set(sessionMap);
}
sessionContext.associate(sessionMap);
sessionContext.activate();
if (sessionContext.isActive())
sessionContext.invalidate();
sessionContext.deactivate();
sessionContext.dissociate(sessionMaps.get());
sessionMaps.set(null);
sessionMaps.remove();
}
}
void startConversationScope(String cid)
{
RequestContextHolder rcHolder = requestContexts.get();
if (rcHolder == null)
{
startRequestScope();
rcHolder = requestContexts.get();
}
conversationContext.associate(new MutableBoundRequest(rcHolder.requestMap, sessionMaps.get()));
conversationContext.activate(cid);
}
void stopConversationScope()
{
RequestContextHolder rcHolder = requestContexts.get();
if (rcHolder == null)
{
startRequestScope();
rcHolder = requestContexts.get();
}
if (conversationContext.isActive())
{
conversationContext.invalidate();
conversationContext.deactivate();
conversationContext.dissociate(new MutableBoundRequest(rcHolder.getRequestMap(), sessionMaps.get()));
}
}
private static class RequestContextHolder
{
private final BoundRequestContext boundRequestContext;
private final Map<String, Object> requestMap;
private RequestContextHolder(BoundRequestContext boundRequestContext, Map<String, Object> requestMap)
{
this.boundRequestContext = boundRequestContext;
this.requestMap = requestMap;
public BoundRequestContext getBoundRequestContext()
{
return boundRequestContext;
}
public Map<String, Object> getRequestMap()
{
return requestMap;
}
import org.apache.deltaspike.core.api.config.ConfigResolver;
import javax.enterprise.inject.Produces;
import javax.enterprise.inject.spi.AnnotatedField;
if (!isMockSupportEnabled(annotated))
{
return false;
}
protected boolean isMockSupportEnabled(Annotated annotated)
{
if ((annotated instanceof AnnotatedMethod || annotated instanceof AnnotatedField) &&
annotated.getAnnotation(Produces.class) != null)
{
return Boolean.parseBoolean(ConfigResolver.getPropertyValue(
"deltaspike.testcontrol.mock-support.allow_mocked_producers", Boolean.FALSE.toString()));
}
return true;
}
else
{
return Boolean.parseBoolean(ConfigResolver.getPropertyValue(
"deltaspike.testcontrol.mock-support.allow_mocked_beans", Boolean.FALSE.toString()));
}
import org.apache.deltaspike.core.api.config.ConfigResolver;
if (!Boolean.parseBoolean(ConfigResolver.getPropertyValue(
"deltaspike.testcontrol.mock-support.allow_mocked_beans", Boolean.FALSE.toString())) &&
!Boolean.parseBoolean(ConfigResolver.getPropertyValue(
"deltaspike.testcontrol.mock-support.allow_mocked_producers", Boolean.FALSE.toString())))
{
throw new IllegalStateException("The support for mocked CDI-Beans is disabled "
"due to a reduced portability across different CDI-implementations. "
"Please set 'deltaspike.testcontrol.mock-support.allow_mocked_beans' and/or "
"'deltaspike.testcontrol.mock-support.allow_mocked_producers' to 'true' "
"(in 'META-INF/apache-deltaspike.properties') on your test-classpath.");
}
try
{
shutdown();
}
finally
{
}
return getContextualReference(getBeanManager(), name, optional, type);
}
public static <T> T getContextualReference(BeanManager beanManager, String name, boolean optional, Class<T> type)
{
if (cl.getParent() != null && !bmpSingleton.bmInfos.containsKey(cl.getParent()))
import java.lang.reflect.Method;
import java.util.logging.Level;
import org.apache.deltaspike.core.api.config.ConfigResolver;
private static final Method CDI_CURRENT_METHOD;
private static final Method CDI_CURRENT_BEAN_MANAGER_METHOD;
static
{
Class cdiClass = ClassUtils.tryToLoadClassForName("javax.enterprise.inject.spi.CDI");
Method resolvedCdiCurrentMethod = null;
Method resolvedCdiBeanManagerMethod = null;
if (cdiClass != null && !"false".equalsIgnoreCase(
ConfigResolver.getPropertyValue("deltaspike.bean-manager.delegate_to_container", Boolean.TRUE.toString())))
{
try
{
resolvedCdiCurrentMethod = cdiClass.getDeclaredMethod("current");
resolvedCdiBeanManagerMethod = cdiClass.getDeclaredMethod("getBeanManager");
}
catch (Exception e)
{
}
}
CDI_CURRENT_METHOD = resolvedCdiCurrentMethod;
CDI_CURRENT_BEAN_MANAGER_METHOD = resolvedCdiBeanManagerMethod;
}
BeanManager result = resolveBeanManagerViaStaticHelper();
if (result != null)
{
return result;
}
result = bmi.finalBm;
private BeanManager resolveBeanManagerViaStaticHelper()
{
if (CDI_CURRENT_METHOD != null && CDI_CURRENT_BEAN_MANAGER_METHOD != null)
{
try
{
Object cdiCurrentObject = CDI_CURRENT_METHOD.invoke(null);
return (BeanManager) CDI_CURRENT_BEAN_MANAGER_METHOD.invoke(cdiCurrentObject);
}
catch (Throwable t)
{
LOG.log(Level.FINEST, "failed to delegate bean-manager lookup -> fallback to default.", t);
}
}
return null;
}
ConfigResolver.getPropertyValue("deltaspike.bean-manager.delegate_to_container", Boolean.FALSE.toString())))
ConfigResolver.getPropertyValue("deltaspike.bean-manager.delegate_to_container", Boolean.TRUE.toString())))
BeanManager result = bmi.finalBm;
if (result == null)
{
result = resolveBeanManagerViaStaticHelper();
}
ConfigResolver.getPropertyValue("deltaspike.bean-manager.delegate_lookup", Boolean.TRUE.toString())))
FacesContext facesContext = FacesContext.getCurrentInstance();
{
return false;
}
String configuredWindowHandling = facesContext.getExternalContext()
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
if (JsfUtils.isViewScopeDelegationEnabled())
{
this.mappedJsfScopes.put(javax.faces.bean.ViewScoped.class,
ClassUtils.tryToLoadClassForName("javax.faces.view.ViewScoped"));
}
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
if (isActivated)
{
isActivated = !JsfUtils.isViewScopeDelegationEnabled();
}
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.util.ClassUtils;
public static boolean isViewScopeDelegationEnabled()
{
return ClassUtils.tryToLoadClassForName("javax.faces.view.ViewScoped") != null && !"false".equalsIgnoreCase(
ConfigResolver.getPropertyValue("deltaspike.scope.view.delegate", Boolean.TRUE.toString()));
}
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
boolean jsfVersionWithClientWindowDetected =
ClassUtils.tryToLoadClassForName(JsfModuleConfig.CLIENT_WINDOW_CLASS_NAME) != null;
if (jsfVersionWithClientWindowDetected && ClassUtils.tryToLoadClassForName(
"org.apache.deltaspike.jsf.impl.listener.request.JsfClientWindowAwareLifecycleWrapper") == null)
{
jsfVersionWithClientWindowDetected = false;
JsfUtils.logWrongModuleUsage(getClass().getName());
}
this.jsfVersionWithClientWindowDetected = jsfVersionWithClientWindowDetected;
return (Lifecycle) lifecycleWrapperClass.getConstructor(new Class[] { Lifecycle.class })
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
if (navigationHandlerWrapperClass != null)
{
manualNavigationHandlerWrapperMode = false;
}
else
{
JsfUtils.logWrongModuleUsage(NavigationHandlerAwareApplication.class.getName());
manualNavigationHandlerWrapperMode = true;
}
import java.util.logging.Level;
import java.util.logging.Logger;
public static void logWrongModuleUsage(String name)
{
Logger.getLogger(name).log(
"might cause issues in your application in different areas. Please upgrade "
"org.apache.deltaspike.modules:deltaspike-jsf-module-impl-ee6 to "
"org.apache.deltaspike.modules:deltaspike-jsf-module-impl");
}
@Target({ ANNOTATION_TYPE })
public interface ConfigDescriptor<CT>
public @interface DefaultCallback
import javax.interceptor.InvocationContext;
protected void beforeProceed(InvocationContext invocationContext,
EntityManagerEntry entityManagerEntry,
EntityTransaction transaction)
import javax.interceptor.InvocationContext;
protected void beforeProceed(InvocationContext invocationContext,
EntityManagerEntry entityManagerEntry,
EntityTransaction transaction)
super.beforeProceed(invocationContext, entityManagerEntry, transaction);
beforeBegin(invocationContext, entityManagerEntry, transaction);
beforeProceed(invocationContext, entityManagerEntry, transaction);
beforeRollback(invocationContext, currentEntityManagerEntry, transaction);
beforeCommit(invocationContext, currentEntityManagerEntry, transaction);
finally
{
afterProceed(invocationContext,currentEntityManagerEntry, firstException);
}
throwException(firstException);
protected void beforeBegin(InvocationContext invocationContext,
EntityManagerEntry entityManagerEntry,
EntityTransaction transaction)
{
}
protected void beforeProceed(InvocationContext invocationContext,
EntityManagerEntry entityManagerEntry,
EntityTransaction transaction)
{
}
protected void beforeCommit(InvocationContext invocationContext,
EntityManagerEntry entityManagerEntry,
EntityTransaction transaction)
{
}
protected void beforeRollback(InvocationContext invocationContext,
EntityManagerEntry entityManagerEntry,
EntityTransaction transaction)
{
}
protected void afterProceed(InvocationContext invocationContext,
EntityManagerEntry entityManagerEntry,
Exception exception)
{
}
protected void throwException(Exception exception) throws Exception
{
throw exception;
}
import org.apache.deltaspike.core.api.config.ConfigResolver;
int priorityValue = Integer.parseInt(
ConfigResolver.getPropertyValue("deltaspike.interceptor.priority", "0"));
defaultValueMap.put("value", priorityValue);
rcHolder.getBoundRequestContext().associate(rcHolder.getRequestMap());
rcHolder.getBoundRequestContext().activate();
LOG.warning("When using the BeanManager to retrieve Beans before the Container is started,"
" non-portable behaviour results!");
if (bmi.loadTimeBm == null)
{
BeanManagerInfo parentBmi = getParentBeanManagerInfo(ClassUtils.getClassLoader(null));
if (parentBmi != null)
{
bmi.loadTimeBm = parentBmi.loadTimeBm;
}
if (parentClassLoader == null)
import java.lang.annotation.Annotation;
if (!m.getDeclaringClass().equals(Object.class) && !m.getDeclaringClass().equals(Annotation.class))
boolean isOptional();
String fileName = "";
fileName = propertyFileConfig.getPropertyFileName();
= new EnvironmentPropertyConfigSourceProvider(fileName, propertyFileConfig.isOptional());
catch (IllegalStateException e)
{
throw new IllegalStateException(
}
EnvironmentPropertyConfigSourceProvider epcsp =
new EnvironmentPropertyConfigSourceProvider(PROPERTY_FILE_NAME, true);
EnvironmentPropertyConfigSourceProvider(String propertyFileName, boolean optional)
if (!optional && !propertyFileUrls.hasMoreElements())
{
}
@Override
public boolean isOptional()
{
return false;
}
@Override
public boolean isOptional()
{
return false;
}
import java.io.Serializable;
public interface ClientWindowConfig extends Serializable
public class DefaultClientWindowConfig implements ClientWindowConfig
protected Boolean delegatedWindowHandlingEnabled;
if (this.delegatedWindowHandlingEnabled == null)
{
lazyInitDelegatedWindowHandlingEnabled();
}
if (this.delegatedWindowHandlingEnabled)
protected synchronized void lazyInitDelegatedWindowHandlingEnabled()
{
if (this.delegatedWindowHandlingEnabled != null)
{
return;
}
this.delegatedWindowHandlingEnabled = isDelegatedWindowHandlingEnabled();
}
import org.apache.deltaspike.core.spi.activation.Deactivatable;
public interface EntityRepository<E, PK extends Serializable> extends Deactivatable
@SuppressWarnings("unchecked")
if (Deactivatable.class.isAssignableFrom(repoClass)
&& !ClassDeactivationUtils.isActivated((Class<? extends Deactivatable>) repoClass))
{
log.log(Level.FINER, "Class {0} is Deactivated", repoClass);
return;
}
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
if (cdiClass != null && !CoreBaseConfig.BeanManager.DELEGATE_LOOKUP.getValue())
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
int priorityValue = CoreBaseConfig.Interceptor.PRIORITY.getValue();
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
if (server.isRegistered(objectName) && CoreBaseConfig.MBean.AUTO_UNREGISTER.getValue())
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
this.maxWindowContextCount = CoreBaseConfig.Scope.Window.MAX_COUNT.getValue();
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER.getValue();
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_BASE_PATH_BUILDER.getValue();
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FILE_NAME_BUILDER.getValue();
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_EXTENSION_BUILDER.getValue();
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER.getValue();
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_BASE_PATH_BUILDER.getValue();
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FILE_NAME_BUILDER.getValue();
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_EXTENSION_BUILDER.getValue();
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
this.maxWindowContextCount = JsfBaseConfig.Scope.Window.MAX_COUNT.getValue();
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
int result = JsfBaseConfig.Scope.Window.ID_MAX_LENGTH.getValue();
if (result > JsfBaseConfig.Scope.Window.ID_MAX_LENGTH.getDefaultValue())
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
return ClassUtils.tryToLoadClassForName("javax.faces.view.ViewScoped") != null &&
JsfBaseConfig.Scope.View.DELEGATE_TO_JSF.getValue();
String defaultJobFactoryName = SchedulerBaseConfig.Job.DEFAULT_JOB_FACTORY_CLASS_NAME.getValue();
if (SchedulerBaseConfig.Lifecycle.START_SCOPES_PER_JOB.getValue())
this.scheduler.startDelayed(SchedulerBaseConfig.Lifecycle.DELAYED_START_IN_SECONDS.getValue());
String configFile = SchedulerBaseConfig.SCHEDULER_CONFIG_FILE.getValue();
this.scheduler.shutdown(SchedulerBaseConfig.Lifecycle.FORCE_STOP.getValue());
String jobClassName = SchedulerBaseConfig.Job.JOB_CLASS_NAME.getValue();
import org.apache.deltaspike.scheduler.impl.SchedulerBaseConfig;
put(SchedulerBaseConfig.Job.JOB_CLASS_NAME.getKey(), CustomJob.class.getName());
import org.apache.deltaspike.scheduler.impl.SchedulerBaseConfig;
put(SchedulerBaseConfig.Job.JOB_CLASS_NAME.getKey(), CustomJob.class.getName());
put(SchedulerBaseConfig.Lifecycle.START_SCOPES_PER_JOB.getKey(), Boolean.FALSE.toString());
}};
return MyFacesTestBaseConfig.WEBAPP_RESOURCE_PATH.getValue();
import org.apache.deltaspike.testcontrol.api.junit.TestBaseConfig;
if (!TestBaseConfig.Mock.ALLOW_MOCKED_BEANS.getValue() &&
!TestBaseConfig.Mock.ALLOW_MOCKED_PRODUCERS.getValue())
import org.apache.deltaspike.testcontrol.api.junit.TestBaseConfig;
return TestBaseConfig.Mock.ALLOW_MOCKED_PRODUCERS.getValue();
return TestBaseConfig.Mock.ALLOW_MOCKED_BEANS.getValue();
import javax.enterprise.util.Nonbinding;
import java.lang.reflect.Type;
import java.util.Arrays;
public static int getQualifierHashCode(Annotation annotation)
{
Class annotationClass = annotation.annotationType();
int hashCode = getTypeHashCode(annotationClass);
for (Method member : annotationClass.getDeclaredMethods())
{
if (member.isAnnotationPresent(Nonbinding.class))
{
continue;
}
final Object annotationMemberValue;
try
{
annotationMemberValue = ReflectionUtils.invokeMethod(annotation, member, Object.class, true);
}
catch (IllegalAccessException e)
{
throw ExceptionUtils.throwAsRuntimeException(e);
}
final int arrayValue;
if (annotationMemberValue.getClass().isArray())
{
Class<?> annotationMemberType = annotationMemberValue.getClass().getComponentType();
if (annotationMemberType.isPrimitive())
{
if (Long.TYPE == annotationMemberType)
{
arrayValue = Arrays.hashCode((long[]) annotationMemberValue);
}
else if (Integer.TYPE == annotationMemberType)
{
arrayValue = Arrays.hashCode((int[]) annotationMemberValue);
}
else if (Short.TYPE == annotationMemberType)
{
arrayValue = Arrays.hashCode((short[]) annotationMemberValue);
}
else if (Double.TYPE == annotationMemberType)
{
arrayValue = Arrays.hashCode((double[]) annotationMemberValue);
}
else if (Float.TYPE == annotationMemberType)
{
arrayValue = Arrays.hashCode((float[]) annotationMemberValue);
}
else if (Boolean.TYPE == annotationMemberType)
{
arrayValue = Arrays.hashCode((boolean[]) annotationMemberValue);
}
else if (Byte.TYPE == annotationMemberType)
{
arrayValue = Arrays.hashCode((byte[]) annotationMemberValue);
}
else if (Character.TYPE == annotationMemberType)
{
arrayValue = Arrays.hashCode((char[]) annotationMemberValue);
}
else
{
arrayValue = 0;
}
}
else
{
arrayValue = Arrays.hashCode((Object[]) annotationMemberValue);
}
}
else
{
arrayValue = annotationMemberValue.hashCode();
}
}
return hashCode;
}
private static int getTypeHashCode(Type type)
{
int typeHash = type.hashCode();
if (typeHash == 0 && type instanceof Class)
{
return ((Class)type).getName().hashCode();
}
return typeHash;
}
import org.apache.deltaspike.core.util.AnnotationUtils;
Set<Integer> hashCodesOfBusinessParameterAnnotations =
new HashSet<Integer>(businessParameterAnnotations.size());
for (Annotation annotation : businessParameterAnnotations)
{
hashCodesOfBusinessParameterAnnotations.add(
AnnotationUtils.getQualifierHashCode(annotation));
}
for (Annotation annotation : requiredBindingAnnotations)
{
if (hashCodesOfBusinessParameterAnnotations.contains(
AnnotationUtils.getQualifierHashCode(annotation)))
{
return invocation.getParameters()[i];
}
}
import org.apache.deltaspike.core.util.metadata.InjectionPointWrapper;
final HashSet<InjectionPoint> ips = new HashSet<InjectionPoint>(injectionPoints.size());
for (InjectionPoint ip : injectionPoints)
{
if (ip.getBean() == null)
{
ips.add(new InjectionPointWrapper(ip, this));
}
else
{
ips.add(ip);
}
}
this.injectionPoints = ips;
package org.apache.deltaspike.test.jsf.impl.scope.viewaccess.beans;
import java.io.Serializable;
import javax.inject.Named;
import org.apache.deltaspike.core.api.scope.ViewAccessScoped;
@Named
@ViewAccessScoped
public class ViewAccessScopedBeanX implements Serializable
{
private String value;
public String getValue()
{
return value;
}
public void setValue(String value)
{
this.value = value;
}
public void viewAction()
{
}
}
import java.util.logging.Logger;
private static final Logger LOG = Logger.getLogger(ViewConfigResolverProducer.class.getName());
return createEmptyDefaultViewConfigResolver();
ViewConfigResolver viewConfigResolver = viewConfigExtension.getViewConfigResolver();
if (viewConfigResolver == null)
{
LOG.warning("It wasn't possible to create a ViewConfigResolver");
viewConfigResolver = createEmptyDefaultViewConfigResolver();
}
return viewConfigResolver;
}
private DefaultViewConfigResolver createEmptyDefaultViewConfigResolver()
{
return new DefaultViewConfigResolver(
new FolderConfigNode(
null, null, new HashSet<Annotation>()), null, null, new ArrayList<ConfigDescriptorValidator>());
import java.util.Stack;
private final ThreadLocal<Stack<CdiQueryInvocationContext>> contextStack =
new ThreadLocal<Stack<CdiQueryInvocationContext>>();
if (contextStack.get() == null)
{
contextStack.set(new Stack<CdiQueryInvocationContext>());
}
contextStack.get().push(context);
if (contextStack.get() != null && !contextStack.get().isEmpty())
{
return contextStack.get().peek();
}
return null;
if (contextStack.get() != null && !contextStack.get().isEmpty())
CdiQueryInvocationContext ctx = contextStack.get().pop();
if (contextStack.get() != null && contextStack.get().isEmpty())
{
contextStack.remove();
}
int orderByIndex = lower.indexOf("order by");
if (orderByIndex > 0)
{
where = where.substring(0, orderByIndex - whereIndex);
}
@Query("select s from Simple s where s.name = ?1 order by s.counter desc")
public abstract QueryResult<Simple> findByQueryWithOrderBy(String name);
import java.util.*;
result.addAll(SecurityUtils.getAllAnnotations(method.getAnnotations(),
new HashSet<Class<? extends Annotation>>()));
result.addAll(SecurityUtils.getAllAnnotations(method.getDeclaringClass().getAnnotations(),
new HashSet<Class<? extends Annotation>>()));
List<Annotation> result = getAllAnnotations(annotation.annotationType().getAnnotations(),
new HashSet<Class<? extends Annotation>>());
List<Annotation> result = getAllAnnotations(annotation.annotationType().getAnnotations(),
new HashSet<Class<? extends Annotation>>());
List<Annotation> result = getAllAnnotations(annotation.annotationType().getAnnotations(),
new HashSet<Class<? extends Annotation>>());
public static List<Annotation> getAllAnnotations(Annotation[] annotations,
Set<Class<? extends Annotation>> annotationPath)
if (!annotationPath.contains(annotation.annotationType()))
{
annotationPath.add(annotation.annotationType());
result.addAll(getAllAnnotations(annotation.annotationType().getAnnotations(), annotationPath));
}
annotationMemberValue = ReflectionUtils.invokeMethod(annotation, member, Object.class, true);
import javax.enterprise.util.Nonbinding;
import java.lang.annotation.Annotation;
import java.util.Arrays;
private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
Object... args)
public static int calculateHashCodeOfAnnotation(Annotation annotation, boolean ignoreNonbindingMembers)
{
Class annotationClass = annotation.annotationType();
if (annotationClass == null)
{
return calculateHashCodeOfType(annotation.annotationType());
}
int hashCode = calculateHashCodeOfType(annotationClass);
final Method[] members = annotationClass.getDeclaredMethods();
for (Method member : members)
{
if (ignoreNonbindingMembers && member.isAnnotationPresent(Nonbinding.class))
{
continue;
}
final Object object = invokeMethod(annotation, member, Object.class, true, EMPTY_OBJECT_ARRAY);
final int value;
if (object.getClass().isArray())
{
Class<?> type = object.getClass().getComponentType();
if (type.isPrimitive())
{
if (Long.TYPE == type)
{
value = Arrays.hashCode((long[]) object);
}
else if (Integer.TYPE == type)
{
value = Arrays.hashCode((int[])object);
}
else if (Short.TYPE == type)
{
value = Arrays.hashCode((short[])object);
}
else if (Double.TYPE == type)
{
value = Arrays.hashCode((double[])object);
}
else if (Float.TYPE == type)
{
value = Arrays.hashCode((float[])object);
}
else if (Boolean.TYPE == type)
{
value = Arrays.hashCode((boolean[])object);
}
else if (Byte.TYPE == type)
{
value = Arrays.hashCode((byte[])object);
}
else if (Character.TYPE == type)
{
value = Arrays.hashCode((char[])object);
}
else
{
value = 0;
}
}
else
{
value = Arrays.hashCode((Object[])object);
}
}
else
{
value = object.hashCode();
}
}
return hashCode;
}
public static int calculateHashCodeOfType(Type type)
{
int typeHash = type.hashCode();
if (typeHash == 0 && type instanceof Class)
{
return ((Class)type).getName().hashCode();
}
return typeHash;
}
new HashSet<Integer>()));
new HashSet<Integer>()));
import org.apache.deltaspike.core.util.ReflectionUtils;
new HashSet<Integer>());
new HashSet<Integer>());
new HashSet<Integer>());
public static List<Annotation> getAllAnnotations(Annotation[] annotations, Set<Integer> annotationPath)
int annotationHashCode = hashCodeOfAnnotation(annotation);
if (!annotationPath.contains(annotationHashCode))
result.add(annotation);
annotationPath.add(annotationHashCode);
private static int hashCodeOfAnnotation(Annotation annotation)
{
return ReflectionUtils.calculateHashCodeOfAnnotation(annotation, false);
}
import org.apache.deltaspike.core.util.ReflectionUtils;
int computedHashCode = 31 * ReflectionUtils.calculateHashCodeOfType(type);
return ReflectionUtils.calculateHashCodeOfAnnotation(a, true);
final Object value1 = ReflectionUtils.invokeMethod(annotation1, member1[i], Object.class, true);
final Object value2 = ReflectionUtils.invokeMethod(annotation2, member2[j], Object.class, true);
public static int calculateHashCodeOfAnnotation(Annotation annotation, boolean skipNonbindingMembers)
if (skipNonbindingMembers && member.isAnnotationPresent(Nonbinding.class))
import org.apache.deltaspike.core.util.ClassUtils;
ClassLoader currentClassLoader = ClassUtils.getClassLoader(null);
configSources.remove(ClassUtils.getClassLoader(null));
ClassLoader cl = ClassUtils.getClassLoader(null);
ClassLoader currentClassLoader = ClassUtils.getClassLoader(null);
return get(bean);
@Override
public String toString()
{
return "OpenWebBeansContainerControl";
}
import org.jboss.weld.Container;
import org.jboss.weld.util.reflection.Formats;
@Override
public String toString()
{
}
if (origin != null && origin.getPackage() == null)
{
return true;
}
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.deltaspike.core.util.ClassUtils;
private static Map<ClassLoader, List<Class<? extends PropertyFileConfig>>> detectedParentPropertyFileConfigs
= new ConcurrentHashMap<ClassLoader, List<Class<? extends PropertyFileConfig>>>();
private List<Class<? extends PropertyFileConfig>> propertyFileConfigClasses
propertyFileConfigClasses.add(pcsClass);
Set<Class<? extends PropertyFileConfig>> allPropertyFileConfigClasses
= new HashSet<Class<? extends PropertyFileConfig>>(this.propertyFileConfigClasses);
ClassLoader currentClassLoader = ClassUtils.getClassLoader(null);
addParentPropertyFileConfigs(currentClassLoader, allPropertyFileConfigClasses);
if (!this.propertyFileConfigClasses.isEmpty())
{
detectedParentPropertyFileConfigs.put(currentClassLoader, this.propertyFileConfigClasses);
}
List<ConfigSource> configSources = new ArrayList<ConfigSource>();
for (Class<? extends PropertyFileConfig> propertyFileConfigClass : allPropertyFileConfigClasses)
private void addParentPropertyFileConfigs(ClassLoader currentClassLoader,
Set<Class<? extends PropertyFileConfig>> propertyFileConfigClasses)
{
if (currentClassLoader.getParent() == null)
{
return;
}
for (Map.Entry<ClassLoader, List<Class<? extends PropertyFileConfig>>> classLoaderListEntry :
detectedParentPropertyFileConfigs.entrySet())
{
if (currentClassLoader.getParent().equals(classLoaderListEntry.getKey()))
{
propertyFileConfigClasses.addAll(classLoaderListEntry.getValue());
addParentPropertyFileConfigs(classLoaderListEntry.getKey(), propertyFileConfigClasses);
return;
}
}
}
detectedParentPropertyFileConfigs.remove(ClassUtils.getClassLoader(null));
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import org.apache.deltaspike.core.util.ServiceUtils;
import org.apache.deltaspike.core.util.bean.BeanBuilder;
import org.apache.deltaspike.core.util.metadata.builder.AnnotatedTypeBuilder;
import org.apache.deltaspike.partialbean.api.PartialBeanBinding;
import org.apache.deltaspike.partialbean.spi.PartialBeanDescriptor;
import org.apache.deltaspike.partialbean.spi.PartialBeanProvider;
private final Map<Class<? extends Annotation>, PartialBeanDescriptor> descriptors =
new HashMap<Class<? extends Annotation>, PartialBeanDescriptor>();
private final List<Class<?>> alreadyProxied = new ArrayList<Class<?>>();
if (!this.isActivated)
{
return;
}
List<PartialBeanProvider> providers = ServiceUtils.loadServiceImplementations(PartialBeanProvider.class);
for (PartialBeanProvider provider : providers)
{
for (PartialBeanDescriptor descriptor : provider.get())
{
if (descriptors.containsKey(descriptor.getBinding()))
{
PartialBeanDescriptor existingDescriptor = descriptors.get(descriptor.getBinding());
if ((descriptor.getHandler() != null
&& descriptor.getHandler().equals(existingDescriptor.getHandler()))
|| (existingDescriptor.getHandler() != null
&& existingDescriptor.getHandler().equals(descriptor.getHandler())))
{
this.definitionError = new IllegalStateException("Multiple handlers found for "
return;
}
if (existingDescriptor.getClasses() == null)
{
existingDescriptor.setClasses(new ArrayList<Class<?>>());
}
if (descriptor.getClasses() != null && descriptor.getClasses().size() > 0)
{
existingDescriptor.getClasses().addAll(descriptor.getClasses());
}
}
else
{
descriptors.put(descriptor.getBinding(), descriptor);
}
}
}
for (Map.Entry<Class<? extends Annotation>, PartialBeanDescriptor> entry : this.descriptors.entrySet())
{
PartialBeanDescriptor descriptor = entry.getValue();
if (descriptor.getClasses() != null)
{
for (Class<?> partialBeanClass : descriptor.getClasses())
{
if (alreadyProxied.contains(partialBeanClass))
{
continue;
}
if (descriptor.getHandler() == null)
{
continue;
}
Class<?> partialBeanProxyClass =
PartialBeanProxyFactory.getProxyClass(partialBeanClass, descriptor.getHandler());
AnnotatedType<?> annotatedType =
new AnnotatedTypeBuilder().readFromType(partialBeanProxyClass).create();
beforeBeanDiscovery.addAnnotatedType(annotatedType);
alreadyProxied.add(partialBeanClass);
}
}
}
if (PartialBeanProxyFactory.isProxyClass(beanClass))
Class<? extends Annotation> bindingClass = extractBindingClass(pat);
if (bindingClass == null)
return;
}
if (beanClass.isInterface() || Modifier.isAbstract(beanClass.getModifiers()))
{
pat.veto();
if (alreadyProxied.contains(beanClass))
{
return;
}
PartialBeanDescriptor descriptor = descriptors.get(bindingClass);
if (descriptor == null)
{
descriptor = new PartialBeanDescriptor(bindingClass);
}
if (descriptor.getClasses() == null)
{
descriptor.setClasses(new ArrayList<Class<?>>());
}
if (!descriptor.getClasses().contains(beanClass))
{
descriptor.getClasses().add(beanClass);
descriptors.put(bindingClass, descriptor);
}
PartialBeanDescriptor descriptor = descriptors.get(bindingClass);
if (descriptor == null)
{
descriptor = new PartialBeanDescriptor(bindingClass, (Class<? extends InvocationHandler>) beanClass);
descriptors.put(bindingClass, descriptor);
}
else
{
if (descriptor.getHandler() == null)
{
descriptor.setHandler((Class<? extends InvocationHandler>) beanClass);
}
else if (!descriptor.getHandler().equals(beanClass))
{
this.definitionError = new IllegalStateException("Multiple handlers found for "
descriptor.getHandler().getName()
}
}
for (Map.Entry<Class<? extends Annotation>, PartialBeanDescriptor> entry : this.descriptors.entrySet())
PartialBeanDescriptor descriptor = entry.getValue();
if (descriptor.getClasses() != null)
for (Class partialBeanClass : descriptor.getClasses())
{
if (alreadyProxied.contains(partialBeanClass))
{
continue;
}
Bean partialBean = createPartialBean(partialBeanClass, descriptor, afterBeanDiscovery, beanManager);
if (partialBean != null)
{
afterBeanDiscovery.addBean(partialBean);
alreadyProxied.add(partialBeanClass);
}
}
this.descriptors.clear();
protected <T> Bean<T> createPartialBean(Class<T> beanClass, PartialBeanDescriptor descriptor,
AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
{
if (descriptor.getHandler() == null)
afterBeanDiscovery.addDefinitionError(new IllegalStateException("A class which implements "
InvocationHandler.class.getName()
new PartialBeanLifecycle(beanClass, descriptor.getHandler(), beanManager);
protected <X> Class<? extends Annotation> extractBindingClass(ProcessAnnotatedType<X> pat)
import javax.enterprise.context.Dependent;
import javax.enterprise.inject.spi.AnnotatedType;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import org.apache.deltaspike.core.api.provider.BeanProvider;
private final Class<T> proxyClass;
private final Class<T> partialBeanClass;
private InjectionTarget<T> injectionTarget;
PartialBeanLifecycle(Class<T> partialBeanClass, Class<H> handlerClass, BeanManager beanManager)
this.partialBeanClass = partialBeanClass;
this.proxyClass = PartialBeanProxyFactory.getProxyClass(partialBeanClass, handlerClass);
if (!partialBeanClass.isInterface())
AnnotatedType<T> annotatedType = beanManager.createAnnotatedType(this.partialBeanClass);
this.injectionTarget = beanManager.createInjectionTarget(annotatedType);
@Override
T instance = proxyClass.newInstance();
((PartialBeanProxy) instance).setHandler(createHandlerInstance());
if (this.injectionTarget != null)
this.injectionTarget.inject(instance, creationalContext);
this.injectionTarget.postConstruct(instance);
@Override
public void destroy(Bean<T> bean, T instance, CreationalContext<T> creationalContext)
if (this.injectionTarget != null)
this.injectionTarget.preDestroy(instance);
if (this.creationalContextOfDependentHandler != null)
this.creationalContextOfDependentHandler.release();
creationalContext.release();
CreationalContext<?> creationalContext = beanManager.createCreationalContext(handlerBean);
H handlerInstance = (H) beanManager.getReference(handlerBean, this.handlerClass, creationalContext);
this.creationalContextOfDependentHandler = creationalContext;
public abstract class ApplicationScopedPartialBean extends AbstractSuper
}
import java.util.ArrayList;
import java.util.Arrays;
ArrayList<JavaArchive> result = new ArrayList<JavaArchive>();
JavaArchive[] temp;
temp = ShrinkWrapArchiveUtil.getArchives(null,
new String[] { "org.apache.deltaspike.core",
"org.apache.deltaspike.partialbean" },
new String[] { "META-INF.apache-deltaspike.properties" },
result.addAll(Arrays.asList(temp));
temp = ShrinkWrapArchiveUtil.getArchives(null,
"META-INF/MANIFEST.MF",
new String[] { "org.objectweb.asm" },
new String[] { },
"asm");
result.addAll(Arrays.asList(temp));
return result.toArray(new JavaArchive[result.size()]);
mg.push(proxyType);
ArrayList<Method> duplicates = new ArrayList<Method>();
for (Method outer : methods)
{
for (Method inner : methods)
{
if (inner != outer
&& hasSameSignature(outer, inner)
&& !(duplicates.contains(outer) || duplicates.contains(inner)))
{
duplicates.add(inner);
}
}
}
methods.removeAll(duplicates);
private static boolean hasSameSignature(Method a, Method b)
{
return a.getName().equals(b.getName())
&& a.getReturnType().equals(b.getReturnType())
&& Arrays.equals(a.getParameterTypes(), b.getParameterTypes());
}
mg.push(Type.getType(method.getDeclaringClass()));
Class unproxiedClass = currentClass;
while (isProxiedClass(unproxiedClass))
unproxiedClass = unproxiedClass.getSuperclass();
return unproxiedClass;
Class unproxiedClass = proxyClass.getSuperclass();
result.add(unproxiedClass);
while (isProxiedClass(unproxiedClass))
{
unproxiedClass = unproxiedClass.getSuperclass();
result.add(unproxiedClass);
}
if (Proxy.class.equals(proxyClass.getSuperclass()) &&
interfaces != null && interfaces.length > 0)
{
return true;
}
if (proxyClass.getName().contains("$$"))
{
for (Class<?> iface : interfaces)
{
if (proxyClass.getName().startsWith(iface.getName()))
{
return true;
}
}
}
return false;
List<Method> methods = new ArrayList<Method>();
if (!containsMethodWithSameSignature(method, methods))
{
methods.add(method);
}
}
for (Method method : clazz.getMethods())
{
if (!containsMethodWithSameSignature(method, methods))
for (Method method : currentSuperClass.getDeclaredMethods())
if (!containsMethodWithSameSignature(method, methods))
for (Method method : currentSuperClass.getMethods())
if (!containsMethodWithSameSignature(method, methods))
private static boolean containsMethodWithSameSignature(Method method, List<Method> methods)
{
for (Method currentMethod : methods)
{
if (hasSameSignature(currentMethod, method))
{
return true;
}
}
return false;
}
if (methods.contains(method))
{
return true;
}
for (Class<?> currentInterface : proxyClass.getInterfaces())
{
if (proxyClass.getName().startsWith(iface.getName()))
{
result.add(currentInterface);
}
}
for (Class<?> currentInterface : interfaces)
if (proxyClass.getName().startsWith(currentInterface.getName()))
if (proxyClass.getName().startsWith(currentInterface.getName()))
if (proxyClass.getSuperclass() != null && !proxyClass.getSuperclass().equals(Object.class))
{
return false;
}
return getDependent(beanManager, type, qualifiers);
}
public static <T> DependentProvider<T> getDependent(BeanManager beanManager, Class<T> type,
Annotation... qualifiers)
{
return getDependent(beanManager, name);
}
public static <T> DependentProvider<T> getDependent(BeanManager beanManager, String name)
{
import java.beans.Introspector;
protected final BeanManager beanManager;
protected Class<?> beanClass;
protected String name;
protected Set<Annotation> qualifiers;
protected Class<? extends Annotation> scope = Dependent.class;
protected Set<Class<? extends Annotation>> stereotypes;
protected Set<Type> types;
protected Set<InjectionPoint> injectionPoints;
protected boolean alternative;
protected boolean nullable;
protected ContextualLifecycle<T> beanLifecycle;
protected boolean passivationCapable;
protected String id;
protected String toString;
if (beanLifecycle == null)
setDefaultBeanLifecycle(type);
if (name == null || name.length() == 0)
{
name = createDefaultBeanName(type);
}
private String createDefaultBeanName(AnnotatedType<T> type)
{
Class<T> javaClass = type.getJavaClass();
return Introspector.decapitalize(javaClass.getSimpleName());
}
protected void setDefaultBeanLifecycle(AnnotatedType<T> type)
{
InjectionTarget<T> injectionTarget;
if (!type.getJavaClass().isInterface())
{
injectionTarget = beanManager.createInjectionTarget(type);
}
else
{
injectionTarget = new DummyInjectionTarget<T>();
}
this.beanLifecycle = new DelegatingContextualLifecycle<T>(injectionTarget);
this.injectionPoints = injectionTarget.getInjectionPoints();
}
public class WrappingBeanBuilder<T> extends BeanBuilder<T>
super(beanManager);
protected void setDefaultBeanLifecycle(AnnotatedType<T> type)
public Bean<T> create()
private final InjectionPoint wrapped;
private final Bean<?> newBean;
import java.lang.reflect.Proxy;
import javax.enterprise.inject.spi.*;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.api.provider.DependentProvider;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.bean.BeanBuilder;
import org.apache.deltaspike.core.util.metadata.builder.ContextualLifecycle;
abd.addBean(createMessageBundleBean(type, beanManager));
private <T> Bean<T> createMessageBundleBean(AnnotatedType<T> annotatedType,
BeanBuilder<T> beanBuilder = new BeanBuilder<T>(beanManager).readFromType(annotatedType);
beanBuilder.beanLifecycle(new MessageBundleLifecycle<T>(beanManager));
private static class MessageBundleLifecycle<T> implements ContextualLifecycle<T>
{
private final BeanManager beanManager;
private DependentProvider<MessageBundleInvocationHandler> invocationHandlerProvider;
private MessageBundleLifecycle(BeanManager beanManager)
{
this.beanManager = beanManager;
}
@Override
public T create(Bean<T> bean, CreationalContext<T> creationalContext)
{
invocationHandlerProvider = BeanProvider.getDependent(beanManager, MessageBundleInvocationHandler.class);
return createMessageBundleProxy((Class<T>) bean.getBeanClass(), invocationHandlerProvider.get());
}
@Override
public void destroy(Bean<T> bean, T instance, CreationalContext<T> creationalContext)
{
invocationHandlerProvider.destroy();
}
private <T> T createMessageBundleProxy(Class<T> type, MessageBundleInvocationHandler handler)
{
return type.cast(Proxy.newProxyInstance(ClassUtils.getClassLoader(null),
new Class<?>[]{type}, handler));
}
}
import javax.inject.Named;
@Named
import javax.enterprise.context.ApplicationScoped;
new Class<?>[]{type, Serializable.class}, handler));
import org.apache.deltaspike.core.util.ClassUtils;
if (ClassUtils.tryToLoadClassForName(
"org.apache.deltaspike.test.core.api.partialbean.uc007.PartialBean") != null)
Object target = invocationContext.getTarget();
if (target instanceof TestInterceptorAware)
{
((TestInterceptorAware)target).setIntercepted(true);
}
import javax.inject.Inject;
@Inject
private TestInterceptedBeanProcessor testInterceptedBeanProcessor;
return this.testInterceptedBeanProcessor.process(invocationContext);
import org.apache.deltaspike.core.util.ClassUtils;
if (ClassUtils.tryToLoadClassForName(
"org.apache.deltaspike.test.core.api.partialbean.uc007.PartialBean") != null)
{
Object target = invocationContext.getTarget();
if (target instanceof TestInterceptorAware)
{
((TestInterceptorAware)target).setIntercepted(true);
}
}
return invocationContext.proceed();
import org.apache.deltaspike.test.core.api.partialbean.shared.CustomInterceptor;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.InjectionTarget;
import javax.enterprise.inject.spi.PassivationCapable;
StringBuilder beanInfo = new StringBuilder();
for (Bean<H> bean : handlerBeans)
{
if (beanInfo.length() != 0)
{
beanInfo.append(", ");
}
beanInfo.append(bean);
if (bean instanceof PassivationCapable)
{
beanInfo.append(" bean-id: ").append(((PassivationCapable)bean).getId());
}
}
package org.apache.deltaspike.test.core.impl.custom.spi;
package org.apache.deltaspike.test.core.impl.custom.spi;
import org.apache.deltaspike.core.api.exclude.Exclude;
if (pat.getAnnotatedType().isAnnotationPresent(Exclude.class))
{
return;
}
import org.apache.deltaspike.core.api.config.PropertyFileConfig;
import org.apache.deltaspike.core.util.ServiceUtils;
registerPropertyFileConfigs();
}
private void registerPropertyFileConfigs()
{
List<? extends PropertyFileConfig> propertyFileConfigs =
ServiceUtils.loadServiceImplementations(PropertyFileConfig.class);
for (PropertyFileConfig propertyFileConfig : propertyFileConfigs)
{
EnvironmentPropertyConfigSourceProvider environmentPropertyConfigSourceProvider
= new EnvironmentPropertyConfigSourceProvider(propertyFileConfig.getPropertyFileName(),
propertyFileConfig.isOptional());
configSources.addAll(environmentPropertyConfigSourceProvider.getConfigSources());
}
params.updateValues(root.getParameterUpdates());
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import org.apache.deltaspike.data.impl.param.ParameterUpdate;
private final List<ParameterUpdate> paramUpdates;
this.paramUpdates = new LinkedList<ParameterUpdate>();
public void addParameterUpdate(ParameterUpdate update)
{
paramUpdates.add(update);
}
public List<ParameterUpdate> getParameterUpdates()
{
return Collections.unmodifiableList(paramUpdates);
}
LikeIgnoreCase("LikeIgnoreCase", "upper({0}) like {1}", true),
NotEqualIgnoreCase("NotEqualIgnoreCase", "upper({0}) <> upper({1})"),
EqualIgnoreCase("EqualIgnoreCase", "upper({0}) = upper({1})"),
IgnoreCase("IgnoreCase", "upper({0}) = upper({1})"),
private final boolean caseInsensitive;
private QueryOperator(String expression, String jpql, boolean caseInsensitive)
{
this(expression, jpql, 1, caseInsensitive);
}
this(expression, jpql, paramNum, false);
}
private QueryOperator(String expression, String jpql, int paramNum, boolean caseInsensitive)
{
this.caseInsensitive = caseInsensitive;
public boolean isCaseInsensitive()
{
return caseInsensitive;
}
import org.apache.deltaspike.data.impl.param.ToUpperStringParameterUpdate;
if (comparator.isCaseInsensitive() && args.length >= 1)
{
ctx.addParameterUpdate(new ToUpperStringParameterUpdate(args[1].substring(1)));
}
import java.util.List;
import org.apache.deltaspike.data.impl.param.ParameterUpdate;
private List<ParameterUpdate> paramUpdates;
public List<ParameterUpdate> getParameterUpdates()
{
return paramUpdates;
}
paramUpdates = ctx.getParameterUpdates();
public IndexedParameter(int index, Object value)
super(value);
@Override
public boolean is(String ident)
{
try
{
return Integer.valueOf(ident).intValue() == index;
}
catch (NumberFormatException e)
{
return false;
}
}
public NamedParameter(String name, Object value)
super(value);
@Override
public boolean is(String ident)
{
return ident != null && ident.equals(name);
}
protected Object value;
public Parameter(Object value)
public abstract boolean is(String ident);
public void updateValue(Object newValue)
{
if (mappedValue != null)
{
mappedValue = newValue;
}
else
{
value = newValue;
}
}
result.add(new NamedParameter(qpAnnotation.value(), parameters[i]));
public void updateValues(List<ParameterUpdate> updates)
{
for (ParameterUpdate update : updates)
{
for (Parameter param : parameterList)
{
if (param.is(update.forParamWithId()))
{
param.updateValue(update.newParamValue(param.queryValue()));
}
}
}
}
public abstract Simple findByNameLikeIgnoreCase(String name);
public abstract Simple findByNameIgnoreCase(String name);
import java.util.HashSet;
import java.util.Set;
private Set<Class> foundManagedJobClasses = new HashSet<Class>();
import org.apache.deltaspike.partialbean.impl.proxy.PartialBeanProxyFactory;
this.isActivated = ClassDeactivationUtils.isActivated(getClass());
package org.apache.deltaspike.partialbean.impl;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
public class PartialBeanDescriptor
{
private Class<? extends Annotation> binding;
private Class<? extends InvocationHandler> handler;
private List<Class<?>> classes;
public PartialBeanDescriptor(Class<? extends Annotation> binding)
{
this.binding = binding;
}
public PartialBeanDescriptor(Class<? extends Annotation> binding,
Class<? extends InvocationHandler> handler)
{
this.binding = binding;
this.handler = handler;
}
public PartialBeanDescriptor(Class<? extends Annotation> binding,
Class<? extends InvocationHandler> handler,
Class<?>... classes)
{
this.binding = binding;
this.handler = handler;
this.classes = new ArrayList<Class<?>>();
if (classes.length > 0)
{
this.classes.addAll(Arrays.asList(classes));
}
}
public PartialBeanDescriptor(Class<? extends Annotation> binding,
Class<? extends InvocationHandler> handler,
List<Class<?>> classes)
{
this.binding = binding;
this.handler = handler;
this.classes = classes;
}
public Class<? extends Annotation> getBinding()
{
return binding;
}
public void setBinding(Class<? extends Annotation> binding)
{
this.binding = binding;
}
public Class<? extends InvocationHandler> getHandler()
{
return handler;
}
public void setHandler(Class<? extends InvocationHandler> handler)
{
this.handler = handler;
}
public List<Class<?>> getClasses()
{
return classes;
}
public void setClasses(List<Class<?>> classes)
{
this.classes = classes;
}
}
import org.apache.deltaspike.partialbean.impl.proxy.PartialBeanProxyFactory;
import org.apache.deltaspike.partialbean.impl.proxy.PartialBeanProxy;
((PartialBeanProxy) instance).setRedirectInvocationHandler(createHandlerInstance());
package org.apache.deltaspike.partialbean.impl.interception;
public class ManualInvocationThrowableWrapperException extends RuntimeException
{
public ManualInvocationThrowableWrapperException(Throwable e)
{
super(e);
}
}
package org.apache.deltaspike.partialbean.impl.interception;
import java.io.Serializable;
public class ProceedOriginalMethodException extends RuntimeException implements Serializable
{
}
package org.apache.deltaspike.partialbean.impl.proxy;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.Arrays;
import javax.enterprise.inject.Typed;
import org.apache.deltaspike.partialbean.impl.interception.ManualInvocationHandler;
import org.apache.deltaspike.partialbean.impl.interception.ProceedOriginalMethodException;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.objectweb.asm.commons.Method;
@Typed
public abstract class AsmProxyClassGenerator
{
private static final String FIELDNAME_HANDLER = "__handler";
private static final Type TYPE_CLASS = Type.getType(Class.class);
private static final Type TYPE_OBJECT = Type.getType(Object.class);
private AsmProxyClassGenerator()
{
}
public static <T> Class<T> generateProxyClass(ClassLoader classLoader,
Class<T> targetClass,
Class<? extends InvocationHandler> invocationHandlerClass,
String suffix,
java.lang.reflect.Method[] redirectMethods,
java.lang.reflect.Method[] interceptionMethods)
{
String classFileName = proxyName.replace('.', '/');
byte[] proxyBytes = generateProxyClassBytes(targetClass, invocationHandlerClass,
classFileName, redirectMethods, interceptionMethods);
Class<T> proxyClass = (Class<T>) loadClass(classLoader, proxyName, proxyBytes);
return proxyClass;
}
private static byte[] generateProxyClassBytes(Class<?> targetClass,
Class<? extends InvocationHandler> invocationHandlerClass,
String proxyName,
java.lang.reflect.Method[] redirectMethods,
java.lang.reflect.Method[] interceptionMethods)
{
Class<?> superClass = targetClass;
String[] interfaces = new String[] { };
if (targetClass.isInterface())
{
superClass = Object.class;
interfaces = new String[] { Type.getInternalName(targetClass) };
}
interfaces[interfaces.length - 1] = Type.getInternalName(PartialBeanProxy.class);
Type superType = Type.getType(superClass);
Type proxyType = Type.getObjectType(proxyName);
Type invocationHandlerType = Type.getType(invocationHandlerClass);
ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
superType.getInternalName(), interfaces);
for (Annotation annotation : targetClass.getDeclaredAnnotations())
{
cw.visitAnnotation(Type.getDescriptor(annotation.annotationType()), true).visitEnd();
}
defineInvocationHandlerField(cw, invocationHandlerType);
defineConstructor(cw, proxyType, superType);
definePartialBeanProxyMethods(cw, proxyType, invocationHandlerType);
for (java.lang.reflect.Method method : redirectMethods)
{
defineMethod(cw, method, proxyType, invocationHandlerType, superType, true);
}
for (java.lang.reflect.Method method : interceptionMethods)
{
defineMethod(cw, method, proxyType, invocationHandlerType, superType, false);
}
return cw.toByteArray();
}
private static void defineInvocationHandlerField(ClassWriter cw, Type invocationHandlerType)
{
cw.visitField(Opcodes.ACC_PRIVATE, FIELDNAME_HANDLER, invocationHandlerType.getDescriptor(), null, null)
.visitEnd();
}
private static void defineConstructor(ClassWriter cw, Type proxyType, Type superType)
{
GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC,
new Method("<init>", Type.VOID_TYPE, new Type[]{ }),
null,
null,
cw);
mg.visitCode();
mg.loadThis();
mg.invokeConstructor(superType, Method.getMethod("void <init> ()"));
mg.returnValue();
mg.endMethod();
mg.visitEnd();
}
private static void definePartialBeanProxyMethods(ClassWriter cw, Type proxyType, Type invocationHandlerType)
{
try
{
Method asmMethod = Method.getMethod(
PartialBeanProxy.class.getDeclaredMethod("setRedirectInvocationHandler",
InvocationHandler.class));
GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC, asmMethod, null, null, cw);
mg.visitCode();
mg.loadThis();
mg.loadArg(0);
mg.checkCast(invocationHandlerType);
mg.putField(proxyType, FIELDNAME_HANDLER, invocationHandlerType);
mg.returnValue();
mg.visitMaxs(2, 1);
mg.visitEnd();
asmMethod = Method.getMethod(PartialBeanProxy.class.getDeclaredMethod("getRedirectInvocationHandler"));
mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC, asmMethod, null, null, cw);
mg.visitCode();
mg.loadThis();
mg.getField(proxyType, FIELDNAME_HANDLER, invocationHandlerType);
mg.returnValue();
mg.visitMaxs(2, 1);
mg.visitEnd();
}
catch (NoSuchMethodException e)
{
}
}
private static void defineMethod(ClassWriter cw, java.lang.reflect.Method method, Type proxyType,
Type invocationHandlerType, Type superType, boolean callInvocationHandler)
{
Type methodType = Type.getType(method);
Type[] exceptionTypes = getTypes(method.getExceptionTypes());
int modifiers = (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED) & method.getModifiers();
Method asmMethod = Method.getMethod(method);
GeneratorAdapter mg = new GeneratorAdapter(modifiers, asmMethod, null, exceptionTypes, cw);
for (Annotation annotation : method.getDeclaredAnnotations())
{
mg.visitAnnotation(Type.getDescriptor(annotation.annotationType()), true).visitEnd();
}
mg.visitCode();
Label tryBlockStart = mg.mark();
mg.loadThis();
loadCurrentMethod(mg, method, methodType);
loadArguments(mg, method, methodType);
mg.invokeStatic(Type.getType(ManualInvocationHandler.class),
Method.getMethod("Object staticInvoke(Object, java.lang.reflect.Method, Object[])"));
mg.unbox(methodType.getReturnType());
Label tryBlockEnd = mg.mark();
mg.returnValue();
boolean throwableCatched = false;
Label proceedOriginal = mg.mark();
if (callInvocationHandler)
{
mg.loadThis();
mg.getField(proxyType, FIELDNAME_HANDLER, invocationHandlerType);
mg.loadThis();
loadCurrentMethod(mg, method, methodType);
loadArguments(mg, method, methodType);
mg.invokeVirtual(invocationHandlerType,
Method.getMethod("Object invoke(Object, java.lang.reflect.Method, Object[])"));
mg.unbox(methodType.getReturnType());
mg.returnValue();
}
else
{
mg.loadThis();
mg.loadArgs();
mg.visitMethodInsn(Opcodes.INVOKESPECIAL,
superType.getInternalName(),
method.getName(),
Type.getMethodDescriptor(method),
false);
mg.returnValue();
}
mg.visitTryCatchBlock(tryBlockStart, tryBlockEnd, proceedOriginal,
Type.getInternalName(ProceedOriginalMethodException.class));
if (exceptionTypes.length > 0)
{
Label rethrow = mg.mark();
mg.visitVarInsn(Opcodes.ASTORE, 1);
mg.visitVarInsn(Opcodes.ALOAD, 1);
mg.throwException();
for (Type exceptionType : exceptionTypes)
{
if (exceptionType.getClassName().equals(Throwable.class.getName()))
{
throwableCatched = true;
}
mg.visitTryCatchBlock(tryBlockStart, tryBlockEnd, rethrow, exceptionType.getInternalName());
}
}
if (!throwableCatched)
{
Type uteType = Type.getType(UndeclaredThrowableException.class);
Label wrapAndRethrow = mg.mark();
mg.visitVarInsn(Opcodes.ASTORE, 1);
mg.newInstance(uteType);
mg.dup();
mg.visitVarInsn(Opcodes.ALOAD, 1);
mg.invokeConstructor(uteType,
Method.getMethod("void <init>(java.lang.Throwable)"));
mg.throwException();
mg.visitTryCatchBlock(tryBlockStart, tryBlockEnd, wrapAndRethrow, Type.getInternalName(Throwable.class));
}
mg.endMethod();
mg.visitMaxs(10, 10);
mg.visitEnd();
}
private static void loadCurrentMethod(GeneratorAdapter mg, java.lang.reflect.Method method, Type methodType)
{
mg.push(Type.getType(method.getDeclaringClass()));
mg.push(method.getName());
mg.push(methodType.getArgumentTypes().length);
mg.newArray(TYPE_CLASS);
{
mg.dup();
mg.push(i);
mg.push(methodType.getArgumentTypes()[i]);
mg.arrayStore(TYPE_CLASS);
}
mg.invokeVirtual(TYPE_CLASS, Method.getMethod("java.lang.reflect.Method getDeclaredMethod(String, Class[])"));
}
private static void loadArguments(GeneratorAdapter mg, java.lang.reflect.Method method, Type methodType)
{
mg.push(methodType.getArgumentTypes().length);
mg.newArray(TYPE_OBJECT);
{
mg.dup();
mg.push(i);
mg.loadArg(i);
mg.valueOf(methodType.getArgumentTypes()[i]);
mg.arrayStore(TYPE_OBJECT);
}
}
private static Type[] getTypes(Class<?>... src)
{
Type[] result = new Type[src.length];
{
result[i] = Type.getType(src[i]);
}
return result;
}
private static Class<?> loadClass(ClassLoader loader, String className, byte[] b)
{
try
{
java.lang.reflect.Method method = ClassLoader.class.getDeclaredMethod(
"defineClass", String.class, byte[].class, int.class, int.class);
boolean accessible = method.isAccessible();
if (!accessible)
{
method.setAccessible(true);
}
try
{
return (Class<?>) method.invoke(loader, className, b, Integer.valueOf(0), Integer.valueOf(b.length));
}
finally
{
if (!accessible)
{
method.setAccessible(false);
}
}
}
catch (Exception e)
{
throw e instanceof RuntimeException ? ((RuntimeException) e) : new RuntimeException(e);
}
}
}
package org.apache.deltaspike.partialbean.impl.proxy;
void setRedirectInvocationHandler(InvocationHandler redirectInvocationHandler);
InvocationHandler getRedirectInvocationHandler();
}
package org.apache.deltaspike.partialbean.impl.proxy;
ArrayList<Method> redirectMethods = new ArrayList<Method>();
ArrayList<Method> interceptionMethods = new ArrayList<Method>();
collectMethods(targetClass, redirectMethods, interceptionMethods);
proxyClass = AsmProxyClassGenerator.generateProxyClass(classLoader,
redirectMethods.toArray(new Method[redirectMethods.size()]),
interceptionMethods.toArray(new Method[interceptionMethods.size()]));
private static void collectMethods(Class<?> clazz,
ArrayList<Method> redirectMethods,
ArrayList<Method> interceptionMethods)
if (!ignoreMethod(method, methods))
if (!ignoreMethod(method, methods))
if (!ignoreMethod(method, methods))
if (!ignoreMethod(method, methods))
if (Modifier.isAbstract(method.getModifiers()))
try
Method foundMethod = currentClass.getMethod(method.getName(), method.getParameterTypes());
if (foundMethod != null && !Modifier.isAbstract(foundMethod.getModifiers()))
{
methodIterator.remove();
}
catch (Exception e)
{
}
Iterator<Method> it = methods.iterator();
while (it.hasNext())
{
Method method = it.next();
if (Modifier.isAbstract(method.getModifiers()))
{
redirectMethods.add(method);
}
else if (Modifier.isPublic(method.getModifiers()) && !Modifier.isFinal(method.getModifiers()))
{
interceptionMethods.add(method);
}
}
private static boolean ignoreMethod(Method method, List<Method> methods)
if (method.isBridge())
{
return true;
}
if ("finalize".equals(method.getName()))
{
return true;
}
}
import static java.lang.annotation.ElementType.METHOD;
@Target({ TYPE, METHOD })
}
import java.io.Serializable;
import javax.inject.Inject;
@Inject private CustomInterceptorState interceptionStateHolder;
interceptionStateHolder.setIntercepted(true);
}
package org.apache.deltaspike.test.core.api.partialbean.shared;
import javax.enterprise.context.RequestScoped;
@RequestScoped
public class CustomInterceptorState
private boolean intercepted;
public boolean isIntercepted()
{
return intercepted;
}
public void setIntercepted(boolean intercepted)
{
this.intercepted = intercepted;
}
}
package org.apache.deltaspike.test.core.api.partialbean.uc001;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
import javax.enterprise.context.RequestScoped;
@TestPartialBeanBinding
@RequestScoped
public interface PartialBean
{
String getResult();
package org.apache.deltaspike.test.core.api.partialbean.uc002;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestBean;
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
@TestPartialBeanBinding
@RequestScoped
public abstract class PartialBean
{
@Inject
private TestBean testBean;
private String value;
public abstract String getResult(String value);
@PostConstruct
protected void onCreate()
{
this.value = "manual";
}
@PreDestroy
protected void onDestroy()
{
}
public String getManualResult()
{
}
}
package org.apache.deltaspike.test.core.api.partialbean.uc003;
import javax.enterprise.context.ApplicationScoped;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
@TestPartialBeanBinding
@ApplicationScoped
public interface PartialBean extends SuperInterface<Object>, SuperInterface2<Object>
{
package org.apache.deltaspike.test.core.api.partialbean.uc003;
public interface SuperInterface<E>
{
E test(E entity);
}
package org.apache.deltaspike.test.core.api.partialbean.uc003;
public interface SuperInterface2<E>
{
E test(E entity);
}
package org.apache.deltaspike.test.core.api.partialbean.uc004;
public abstract class AbstractSuper implements SuperInterface
{
}
package org.apache.deltaspike.test.core.api.partialbean.uc004;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
import javax.enterprise.context.ApplicationScoped;
@TestPartialBeanBinding
@ApplicationScoped
public abstract class ApplicationScopedPartialBean extends AbstractSuper
{
private int count;
public abstract String getResult();
public int getManualResult()
{
}
}
package org.apache.deltaspike.test.core.api.partialbean.uc004;
public interface SuperInterface
{
String willFail();
}
package org.apache.deltaspike.test.core.api.partialbean.uc005;
public abstract class AbstractSuper
{
public abstract String willFail2();
}
package org.apache.deltaspike.test.core.api.partialbean.uc005;
import javax.enterprise.context.ApplicationScoped;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
@TestPartialBeanBinding
@ApplicationScoped
public abstract class ApplicationScopedPartialBean extends AbstractSuper implements SuperInterface
{
private int count;
public abstract String getResult();
public int getManualResult()
{
}
}
package org.apache.deltaspike.test.core.api.partialbean.uc005;
public interface SuperInterface
{
String willFail();
}
package org.apache.deltaspike.test.core.api.partialbean.uc006;
public abstract class AbstractSuper<T> extends AbstractSuperSuper
{
public abstract T willFail2() throws Throwable;
@Override
public String willFail3() throws ClassNotFoundException, NoSuchMethodException, NoSuchFieldException
{
return "willFail3";
}
}
package org.apache.deltaspike.test.core.api.partialbean.uc006;
public abstract class AbstractSuperSuper
{
public abstract String willFail3() throws Throwable;
}
package org.apache.deltaspike.test.core.api.partialbean.uc006;
import org.apache.deltaspike.test.core.api.partialbean.shared.ThrowExceptionPartialBeanBinding;
import javax.enterprise.context.ApplicationScoped;
@ThrowExceptionPartialBeanBinding
@ApplicationScoped
public abstract class ApplicationScopedPartialBean extends AbstractSuper<String>
{
private int count;
public abstract String getResult();
public int getManualResult()
{
}
}
package org.apache.deltaspike.test.core.api.partialbean.uc007;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
import javax.enterprise.context.RequestScoped;
import org.apache.deltaspike.test.core.api.partialbean.shared.CustomInterceptor;
@TestPartialBeanBinding
@RequestScoped
public abstract class PartialBean
{
@CustomInterceptor
public abstract String getResult();
@CustomInterceptor
public void doSomething()
{
}
package org.apache.deltaspike.test.core.api.partialbean.uc008;
import org.apache.deltaspike.test.core.api.partialbean.shared.CustomInterceptor;
import org.apache.deltaspike.test.core.api.partialbean.shared.TestPartialBeanBinding;
import javax.enterprise.context.RequestScoped;
@CustomInterceptor
@TestPartialBeanBinding
@RequestScoped
public abstract class PartialBean
{
public abstract String getResult();
public String getManualResult()
{
return "manual";
}
}
import java.util.concurrent.CopyOnWriteArrayList;
List<ConfigFilter> currentConfigFilters = getInternalConfigFilters();
return Collections.unmodifiableList(getInternalConfigFilters());
}
private static List<ConfigFilter> getInternalConfigFilters()
{
currentConfigFilters = new CopyOnWriteArrayList<ConfigFilter>();
List<ConfigFilter> currentConfigFilters = getInternalConfigFilters();
List<ConfigFilter> currentConfigFilters = getInternalConfigFilters();
public static synchronized ConfigSource[] getConfigSources()
public static String filterConfigValue(String key, String value)
public static String filterConfigValueForLog(String key, String value)
List<? extends ConfigFilter> configFilters = ServiceUtils.loadServiceImplementations(ConfigFilter.class);
for (ConfigFilter configFilter : configFilters)
{
addConfigFilter(configFilter);
}
ClassLoader classLoader = ClassUtils.getClassLoader(null);
configSources.remove(classLoader);
configFilters.remove(classLoader);
descriptor = new PartialBeanDescriptor(bindingClass, null, beanClass);
descriptors.put(bindingClass, descriptor);
else if (!descriptor.getClasses().contains(beanClass))
import java.util.HashSet;
import java.util.Set;
private Set<Class<?>> classes;
this.classes = new HashSet<Class<?>>();
this(binding);
Class<?> clazz)
this(binding, handler);
this.classes.add(clazz);
public Set<Class<?>> getClasses()
public void setClasses(Set<Class<?>> classes)
return manualInvocationHandler.proceedOriginal(target, method, parameters);
Object value = manualInvocationHandler.proceedOriginal(target, method, parameters);
return value;
ManualInvocationContext invocationContext =
new ManualInvocationContext(this, interceptors, proxy, method, parameters, null);
return invocationContext.proceed();
protected Object proceedOriginal(Object proxy, Method method, Object[] parameters) throws Exception
InputStream inputStream = null;
try
{
inputStream = this.readStream(injectableResource);
this.loadInputStreamToProperties(inputStream, properties, name);
return properties;
}
finally
{
if (inputStream != null)
{
try
{
inputStream.close();
}
catch (IOException e)
{
if (logger.isLoggable(Level.FINE))
{
logger.log(Level.FINE, "Problem closing resource.", e);
}
}
}
}
import javax.enterprise.inject.spi.BeanManager;
protected BeanManager beanManager;
protected boolean proceedOriginal;
if (proceedOriginal)
{
return null;
}
if (beanManager == null)
beanManager = BeanManagerProvider.getInstance().getBeanManager();
creationalContext = beanManager.createCreationalContext(interceptor);
interceptorInstance = interceptor.create(creationalContext);
return interceptor.intercept(InterceptionType.AROUND_INVOKE, interceptorInstance, this);
proceedOriginal = true;
return manualInvocationHandler.proceedOriginal(target, method, parameters);
public boolean isProceedOriginal()
{
return proceedOriginal;
}
public static final Object PROCEED_ORIGINAL = new Object();
Object returnValue = invocationContext.proceed();
if (invocationContext.isProceedOriginal())
{
return proceedOriginal(proxy, method, parameters);
}
return returnValue;
return PROCEED_ORIGINAL;
int manualInvocationHandlerReturnValue = mg.newLocal(TYPE_OBJECT);
mg.storeLocal(manualInvocationHandlerReturnValue);
Label proceedOriginalStart = new Label();
mg.getStatic(Type.getType(ManualInvocationHandler.class), "PROCEED_ORIGINAL", TYPE_OBJECT);
mg.loadLocal(manualInvocationHandlerReturnValue);
mg.ifCmp(TYPE_OBJECT, GeneratorAdapter.EQ, proceedOriginalStart);
mg.loadLocal(manualInvocationHandlerReturnValue);
mg.mark(proceedOriginalStart);
boolean throwableCatched = false;
package org.apache.deltaspike.partialbean.impl.interception;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import javax.enterprise.inject.Typed;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.InterceptionType;
import javax.enterprise.inject.spi.Interceptor;
import javax.interceptor.InterceptorBinding;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
@Typed
public abstract class AbstractManualInvocationHandler implements InvocationHandler
{
@Override
public Object invoke(Object proxy, Method method, Object[] parameters) throws Throwable
{
List<Interceptor<?>> interceptors = resolveInterceptors(proxy, method);
if (interceptors != null && interceptors.size() > 0)
{
try
{
ManualInvocationContext invocationContext =
new ManualInvocationContext(this, interceptors, proxy, method, parameters, null);
Object returnValue = invocationContext.proceed();
if (invocationContext.isProceedOriginal())
{
return invocationContext.getProceedOriginalReturnValue();
}
return returnValue;
}
catch (ManualInvocationThrowableWrapperException e)
{
throw e.getCause();
}
}
return proceedOriginal(proxy, method, parameters);
}
protected abstract Object proceedOriginal(Object proxy, Method method, Object[] parameters) throws Throwable;
protected List<Interceptor<?>> resolveInterceptors(Object instance, Method method)
{
Annotation[] interceptorBindings = extractInterceptorBindings(instance, method);
if (interceptorBindings.length > 0)
{
BeanManager beanManager = BeanManagerProvider.getInstance().getBeanManager();
return beanManager.resolveInterceptors(InterceptionType.AROUND_INVOKE, interceptorBindings);
}
return null;
}
protected Annotation[] extractInterceptorBindings(Object instance, Method method)
{
ArrayList<Annotation> bindings = new ArrayList<Annotation>();
for (Annotation annotation : instance.getClass().getDeclaredAnnotations())
{
if (annotation.annotationType().isAnnotationPresent(InterceptorBinding.class)
&& !bindings.contains(annotation))
{
bindings.add(annotation);
}
}
for (Annotation annotation : method.getDeclaredAnnotations())
{
if (annotation.annotationType().isAnnotationPresent(InterceptorBinding.class)
&& !bindings.contains(annotation))
{
bindings.add(annotation);
}
}
return bindings.toArray(new Annotation[bindings.size()]);
}
}
package org.apache.deltaspike.partialbean.impl.interception;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.Typed;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.InterceptionType;
import javax.enterprise.inject.spi.Interceptor;
import javax.interceptor.InvocationContext;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
@Typed
public class ManualInvocationContext<T, H> implements InvocationContext
{
protected List<Interceptor<H>> interceptors;
protected int interceptorIndex;
protected T target;
protected Method method;
protected Object[] parameters;
protected Map<String, Object> contextData;
protected Object timer;
protected AbstractManualInvocationHandler manualInvocationHandler;
protected BeanManager beanManager;
protected boolean proceedOriginal;
protected Object proceedOriginalReturnValue;
public ManualInvocationContext(AbstractManualInvocationHandler manualInvocationHandler,
List<Interceptor<H>> interceptors, T target, Method method, Object[] parameters, Object timer)
{
this.manualInvocationHandler = manualInvocationHandler;
this.interceptors = interceptors;
this.target = target;
this.method = method;
this.parameters = parameters;
this.timer = timer;
this.interceptorIndex = 0;
}
@Override
public Object getTarget()
{
return target;
}
@Override
public Method getMethod()
{
return method;
}
@Override
public Object[] getParameters()
{
return parameters;
}
@Override
public void setParameters(Object[] os)
{
parameters = os;
}
@Override
public Map<String, Object> getContextData()
{
if (contextData == null)
{
contextData = new HashMap<String, Object>();
}
return contextData;
}
@Override
public Object proceed() throws Exception
{
if (proceedOriginal)
{
return null;
}
if (interceptors.size() > interceptorIndex)
{
Interceptor<H> interceptor = null;
CreationalContext<H> creationalContext = null;
H interceptorInstance = null;
try
{
if (beanManager == null)
{
beanManager = BeanManagerProvider.getInstance().getBeanManager();
}
creationalContext = beanManager.createCreationalContext(interceptor);
interceptorInstance = interceptor.create(creationalContext);
return interceptor.intercept(InterceptionType.AROUND_INVOKE, interceptorInstance, this);
}
finally
{
if (creationalContext != null)
{
if (interceptorInstance != null && interceptor != null)
{
interceptor.destroy(interceptorInstance, creationalContext);
}
creationalContext.release();
}
}
}
try
{
proceedOriginal = true;
proceedOriginalReturnValue = manualInvocationHandler.proceedOriginal(target, method, parameters);
}
catch (Exception e)
{
throw e;
}
catch (Throwable e)
{
throw new ManualInvocationThrowableWrapperException(e);
}
return null;
}
@Override
public Object getTimer()
{
return timer;
}
public Constructor getConstructor()
{
return null;
}
public boolean isProceedOriginal()
{
return proceedOriginal;
}
public Object getProceedOriginalReturnValue()
{
return proceedOriginalReturnValue;
}
public void setProceedOriginalReturnValue(Object proceedOriginalReturnValue)
{
this.proceedOriginalReturnValue = proceedOriginalReturnValue;
}
}
package org.apache.deltaspike.partialbean.impl.proxy;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.Arrays;
import javax.enterprise.inject.Typed;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.objectweb.asm.commons.Method;
@Typed
public abstract class AsmProxyClassGenerator
{
private static final String FIELDNAME_HANDLER = "__handler";
private static final Type TYPE_CLASS = Type.getType(Class.class);
private static final Type TYPE_OBJECT = Type.getType(Object.class);
private AsmProxyClassGenerator()
{
}
public static <T> Class<T> generateProxyClass(ClassLoader classLoader,
Class<T> targetClass,
Class<? extends InvocationHandler> invocationHandlerClass,
String suffix,
String superAccessorMethodSuffix,
java.lang.reflect.Method[] redirectMethods,
java.lang.reflect.Method[] interceptionMethods)
{
String classFileName = proxyName.replace('.', '/');
byte[] proxyBytes = generateProxyClassBytes(targetClass, invocationHandlerClass,
classFileName, superAccessorMethodSuffix, redirectMethods, interceptionMethods);
Class<T> proxyClass = (Class<T>) loadClass(classLoader, proxyName, proxyBytes);
return proxyClass;
}
private static byte[] generateProxyClassBytes(Class<?> targetClass,
Class<? extends InvocationHandler> invocationHandlerClass,
String proxyName,
String superAccessorMethodSuffix,
java.lang.reflect.Method[] redirectMethods,
java.lang.reflect.Method[] interceptionMethods)
{
Class<?> superClass = targetClass;
String[] interfaces = new String[] { };
if (targetClass.isInterface())
{
superClass = Object.class;
interfaces = new String[] { Type.getInternalName(targetClass) };
}
interfaces[interfaces.length - 1] = Type.getInternalName(PartialBeanProxy.class);
Type superType = Type.getType(superClass);
Type proxyType = Type.getObjectType(proxyName);
Type invocationHandlerType = Type.getType(invocationHandlerClass);
ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
superType.getInternalName(), interfaces);
for (Annotation annotation : targetClass.getDeclaredAnnotations())
{
cw.visitAnnotation(Type.getDescriptor(annotation.annotationType()), true).visitEnd();
}
defineInvocationHandlerField(cw, invocationHandlerType);
defineConstructor(cw, proxyType, superType);
definePartialBeanProxyMethods(cw, proxyType, invocationHandlerType);
for (java.lang.reflect.Method method : redirectMethods)
{
defineMethod(cw, method, RedirectManualInvocationHandler.class);
}
for (java.lang.reflect.Method method : interceptionMethods)
{
defineSuperAccessorMethod(cw, method, superType, superAccessorMethodSuffix);
defineMethod(cw, method, CallSuperManualInvocationHandler.class);
}
return cw.toByteArray();
}
private static void defineInvocationHandlerField(ClassWriter cw, Type invocationHandlerType)
{
cw.visitField(Opcodes.ACC_PRIVATE, FIELDNAME_HANDLER, invocationHandlerType.getDescriptor(), null, null)
.visitEnd();
}
private static void defineConstructor(ClassWriter cw, Type proxyType, Type superType)
{
GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC,
new Method("<init>", Type.VOID_TYPE, new Type[]{ }),
null,
null,
cw);
mg.visitCode();
mg.loadThis();
mg.invokeConstructor(superType, Method.getMethod("void <init> ()"));
mg.returnValue();
mg.endMethod();
mg.visitEnd();
}
private static void definePartialBeanProxyMethods(ClassWriter cw, Type proxyType, Type invocationHandlerType)
{
try
{
Method asmMethod = Method.getMethod(PartialBeanProxy.class.getDeclaredMethod(
"setRedirectInvocationHandler", InvocationHandler.class));
GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC, asmMethod, null, null, cw);
mg.visitCode();
mg.loadThis();
mg.loadArg(0);
mg.checkCast(invocationHandlerType);
mg.putField(proxyType, FIELDNAME_HANDLER, invocationHandlerType);
mg.returnValue();
mg.visitMaxs(2, 1);
mg.visitEnd();
asmMethod = Method.getMethod(PartialBeanProxy.class.getDeclaredMethod("getRedirectInvocationHandler"));
mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC, asmMethod, null, null, cw);
mg.visitCode();
mg.loadThis();
mg.getField(proxyType, FIELDNAME_HANDLER, invocationHandlerType);
mg.returnValue();
mg.visitMaxs(2, 1);
mg.visitEnd();
}
catch (NoSuchMethodException e)
{
}
}
private static void defineSuperAccessorMethod(ClassWriter cw, java.lang.reflect.Method method, Type superType,
String superAccessorMethodSuffix)
{
Method originalAsmMethod = Method.getMethod(method);
originalAsmMethod.getReturnType(),
originalAsmMethod.getArgumentTypes());
GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC, newAsmMethod, null, null, cw);
mg.visitCode();
mg.loadThis();
mg.loadArgs();
mg.visitMethodInsn(Opcodes.INVOKESPECIAL,
superType.getInternalName(),
method.getName(),
Type.getMethodDescriptor(method),
false);
mg.returnValue();
mg.endMethod();
mg.visitMaxs(10, 10);
mg.visitEnd();
}
private static void defineMethod(ClassWriter cw, java.lang.reflect.Method method,
Class manualInvocationHandlerClass)
{
Type methodType = Type.getType(method);
Type[] exceptionTypes = getTypes(method.getExceptionTypes());
int modifiers = (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED) & method.getModifiers();
Method asmMethod = Method.getMethod(method);
GeneratorAdapter mg = new GeneratorAdapter(modifiers, asmMethod, null, exceptionTypes, cw);
for (Annotation annotation : method.getDeclaredAnnotations())
{
mg.visitAnnotation(Type.getDescriptor(annotation.annotationType()), true).visitEnd();
}
mg.visitCode();
Label tryBlockStart = mg.mark();
mg.loadThis();
loadCurrentMethod(mg, method, methodType);
loadArguments(mg, method, methodType);
mg.invokeStatic(Type.getType(manualInvocationHandlerClass),
Method.getMethod("Object staticInvoke(Object, java.lang.reflect.Method, Object[])"));
mg.unbox(methodType.getReturnType());
mg.returnValue();
Label tryBlockEnd = mg.mark();
boolean throwableCatched = false;
if (exceptionTypes.length > 0)
{
Label rethrow = mg.mark();
mg.visitVarInsn(Opcodes.ASTORE, 1);
mg.visitVarInsn(Opcodes.ALOAD, 1);
mg.throwException();
for (Type exceptionType : exceptionTypes)
{
if (exceptionType.getClassName().equals(Throwable.class.getName()))
{
throwableCatched = true;
}
mg.visitTryCatchBlock(tryBlockStart, tryBlockEnd, rethrow, exceptionType.getInternalName());
}
}
if (!throwableCatched)
{
Type uteType = Type.getType(UndeclaredThrowableException.class);
Label wrapAndRethrow = mg.mark();
mg.visitVarInsn(Opcodes.ASTORE, 1);
mg.newInstance(uteType);
mg.dup();
mg.visitVarInsn(Opcodes.ALOAD, 1);
mg.invokeConstructor(uteType,
Method.getMethod("void <init>(java.lang.Throwable)"));
mg.throwException();
mg.visitTryCatchBlock(tryBlockStart, tryBlockEnd, wrapAndRethrow, Type.getInternalName(Throwable.class));
}
mg.endMethod();
mg.visitMaxs(10, 10);
mg.visitEnd();
}
private static void loadCurrentMethod(GeneratorAdapter mg, java.lang.reflect.Method method, Type methodType)
{
mg.push(Type.getType(method.getDeclaringClass()));
mg.push(method.getName());
mg.push(methodType.getArgumentTypes().length);
mg.newArray(TYPE_CLASS);
{
mg.dup();
mg.push(i);
mg.push(methodType.getArgumentTypes()[i]);
mg.arrayStore(TYPE_CLASS);
}
mg.invokeVirtual(TYPE_CLASS, Method.getMethod("java.lang.reflect.Method getDeclaredMethod(String, Class[])"));
}
private static void loadArguments(GeneratorAdapter mg, java.lang.reflect.Method method, Type methodType)
{
mg.push(methodType.getArgumentTypes().length);
mg.newArray(TYPE_OBJECT);
{
mg.dup();
mg.push(i);
mg.loadArg(i);
mg.valueOf(methodType.getArgumentTypes()[i]);
mg.arrayStore(TYPE_OBJECT);
}
}
private static Type[] getTypes(Class<?>... src)
{
Type[] result = new Type[src.length];
{
result[i] = Type.getType(src[i]);
}
return result;
}
private static Class<?> loadClass(ClassLoader loader, String className, byte[] b)
{
try
{
java.lang.reflect.Method method = ClassLoader.class.getDeclaredMethod(
"defineClass", String.class, byte[].class, int.class, int.class);
boolean accessible = method.isAccessible();
if (!accessible)
{
method.setAccessible(true);
}
try
{
return (Class<?>) method.invoke(loader, className, b, Integer.valueOf(0), Integer.valueOf(b.length));
}
finally
{
if (!accessible)
{
method.setAccessible(false);
}
}
}
catch (Exception e)
{
throw e instanceof RuntimeException ? ((RuntimeException) e) : new RuntimeException(e);
}
}
}
private static final String SUPER_ACCESSOR_METHOD_SUFFIX = "$super";
SUPER_ACCESSOR_METHOD_SUFFIX,
private static String constructSuperAccessorMethodName(Method method)
{
}
public static Method getSuperAccessorMethod(Object proxy, Method method) throws NoSuchMethodException
{
return proxy.getClass().getMethod(
constructSuperAccessorMethodName(method),
method.getParameterTypes());
}
}
String a = "test";
import java.util.ArrayList;
ArrayList<Type> exceptionsToCatch = new ArrayList<Type>();
for (Class<?> exception : method.getExceptionTypes())
{
if (!RuntimeException.class.isAssignableFrom(exception))
{
exceptionsToCatch.add(Type.getType(exception));
}
}
GeneratorAdapter mg = new GeneratorAdapter(modifiers,
asmMethod,
null,
getTypes(method.getExceptionTypes()),
cw);
Label tryBlockEnd = mg.mark();
Label rethrow = mg.mark();
mg.visitVarInsn(Opcodes.ASTORE, 1);
mg.visitVarInsn(Opcodes.ALOAD, 1);
mg.throwException();
mg.visitTryCatchBlock(tryBlockStart, tryBlockEnd, rethrow, Type.getInternalName(RuntimeException.class));
boolean throwableCatched = false;
if (exceptionsToCatch.size() > 0)
rethrow = mg.mark();
for (Type exceptionType : exceptionsToCatch)
import java.lang.reflect.InvocationTargetException;
try
{
Method superAccessorMethod = PartialBeanProxyFactory.getSuperAccessorMethod(proxy, method);
return superAccessorMethod.invoke(proxy, parameters);
}
catch (InvocationTargetException e)
{
throw e.getCause();
}
public String willFail3() throws RuntimeException, ClassNotFoundException, NoSuchMethodException, NoSuchFieldException
import java.lang.annotation.Annotation;
import javax.interceptor.InterceptorBinding;
if (!containsInterceptorBinding(targetClass.getDeclaredAnnotations()))
{
Iterator<Method> iterator = interceptionMethods.iterator();
while (iterator.hasNext())
{
Method method = iterator.next();
if (!containsInterceptorBinding(method.getDeclaredAnnotations()))
{
iterator.remove();
}
}
}
private static boolean containsInterceptorBinding(Annotation[] annotations)
{
for (Annotation annotation : annotations)
{
if (annotation.annotationType().isAnnotationPresent(InterceptorBinding.class))
{
return true;
}
}
return false;
}
package org.apache.deltaspike.core.util.invocation;
package org.apache.deltaspike.core.util.invocation;
package org.apache.deltaspike.core.util.invocation;
package org.apache.deltaspike.core.util.proxy;
import org.apache.deltaspike.core.util.proxy.invocation.InterceptManualInvocationHandler;
import org.apache.deltaspike.core.util.proxy.invocation.DelegateManualInvocationHandler;
private static final String FIELDNAME_DELEGATE_INVOCATION_HANDLER = "delegateInvocationHandler";
Class<?>[] additionalInterfaces,
java.lang.reflect.Method[] delegateMethods,
java.lang.reflect.Method[] interceptMethods)
classFileName, superAccessorMethodSuffix, additionalInterfaces, delegateMethods, interceptMethods);
Class<?>[] additionalInterfaces,
java.lang.reflect.Method[] delegateMethods,
java.lang.reflect.Method[] interceptMethods)
interfaces[interfaces.length - 1] = Type.getInternalName(DeltaSpikeProxy.class);
if (additionalInterfaces != null && additionalInterfaces.length > 0)
{
{
}
}
defineDeltaSpikeProxyMethods(cw, proxyType, invocationHandlerType);
for (java.lang.reflect.Method method : delegateMethods)
defineMethod(cw, method, DelegateManualInvocationHandler.class);
for (java.lang.reflect.Method method : interceptMethods)
defineMethod(cw, method, InterceptManualInvocationHandler.class);
cw.visitField(Opcodes.ACC_PRIVATE, FIELDNAME_DELEGATE_INVOCATION_HANDLER,
invocationHandlerType.getDescriptor(), null, null).visitEnd();
private static void defineDeltaSpikeProxyMethods(ClassWriter cw, Type proxyType, Type invocationHandlerType)
Method asmMethod = Method.getMethod(DeltaSpikeProxy.class.getDeclaredMethod(
"setDelegateInvocationHandler", InvocationHandler.class));
mg.putField(proxyType, FIELDNAME_DELEGATE_INVOCATION_HANDLER, invocationHandlerType);
asmMethod = Method.getMethod(DeltaSpikeProxy.class.getDeclaredMethod("getDelegateInvocationHandler"));
mg.getField(proxyType, FIELDNAME_DELEGATE_INVOCATION_HANDLER, invocationHandlerType);
package org.apache.deltaspike.core.util.proxy;
public interface DeltaSpikeProxy
void setDelegateInvocationHandler(InvocationHandler redirectInvocationHandler);
InvocationHandler getDelegateInvocationHandler();
}
package org.apache.deltaspike.core.util.proxy;
import javax.enterprise.context.spi.CreationalContext;
import org.apache.deltaspike.core.util.ExceptionUtils;
import org.apache.deltaspike.core.util.metadata.builder.ContextualLifecycle;
public class DeltaSpikeProxyContextualLifecycle<T, H extends InvocationHandler> implements ContextualLifecycle<T>
private final Class<H> delegateInvocationHandlerClass;
private final Class<T> targetClass;
public DeltaSpikeProxyContextualLifecycle(Class<T> targetClass, Class<H> delegateInvocationHandlerClass,
DeltaSpikeProxyFactory proxyFactory, BeanManager beanManager)
this.targetClass = targetClass;
this.delegateInvocationHandlerClass = delegateInvocationHandlerClass;
this.proxyClass = proxyFactory.getProxyClass(targetClass, delegateInvocationHandlerClass);
if (!targetClass.isInterface())
AnnotatedType<T> annotatedType = beanManager.createAnnotatedType(this.targetClass);
if (delegateInvocationHandlerClass != null)
{
H delegateInvocationHandler = instantiateDelegateInvocationHandler();
((DeltaSpikeProxy) instance).setDelegateInvocationHandler(delegateInvocationHandler);
}
protected H instantiateDelegateInvocationHandler()
Set<Bean<H>> handlerBeans = BeanProvider.getBeanDefinitions(this.delegateInvocationHandlerClass, false, true);
H handlerInstance = (H) beanManager.getReference(handlerBean,
this.delegateInvocationHandlerClass, creationalContext);
package org.apache.deltaspike.core.util.proxy;
public abstract class DeltaSpikeProxyFactory
public <T> Class<T> getProxyClass(Class<T> targetClass,
private synchronized <T> Class<T> createProxyClass(ClassLoader classLoader, Class<T> targetClass,
ArrayList<Method> allMethods = collectAllMethods(targetClass);
ArrayList<Method> interceptMethods = filterInterceptMethods(targetClass, allMethods);
ArrayList<Method> delegateMethods = getDelegateMethods(targetClass, allMethods);
if (delegateMethods != null
&& interceptMethods.size() > 0
&& !containsInterceptorBinding(targetClass.getDeclaredAnnotations()))
Iterator<Method> iterator = interceptMethods.iterator();
getProxyClassSuffix(),
getAdditionalInterfacesToImplement(targetClass),
delegateMethods == null ? new Method[0]
: delegateMethods.toArray(new Method[delegateMethods.size()]),
interceptMethods == null ? new Method[0]
: interceptMethods.toArray(new Method[interceptMethods.size()]));
protected boolean containsInterceptorBinding(Annotation[] annotations)
protected String constructProxyClassName(Class<?> clazz)
protected static String constructSuperAccessorMethodName(Method method)
public boolean isProxyClass(Class<?> clazz)
return clazz.getName().endsWith(getProxyClassSuffix());
protected boolean hasSameSignature(Method a, Method b)
return a.getName().equals(b.getName())
&& a.getReturnType().equals(b.getReturnType())
&& Arrays.equals(a.getParameterTypes(), b.getParameterTypes());
}
protected boolean ignoreMethod(Method method, List<Method> methods)
{
if (method.isBridge())
{
return true;
}
if ("finalize".equals(method.getName()))
{
return true;
}
if (methods.contains(method))
{
return true;
}
for (Method currentMethod : methods)
{
if (hasSameSignature(currentMethod, method))
{
return true;
}
}
return false;
}
protected ArrayList<Method> collectAllMethods(Class<?> clazz)
{
ArrayList<Method> methods = new ArrayList<Method>();
return methods;
}
protected ArrayList<Method> filterInterceptMethods(Class<?> targetClass, ArrayList<Method> allMethods)
{
ArrayList<Method> methods = new ArrayList<Method>();
Iterator<Method> it = allMethods.iterator();
if (Modifier.isPublic(method.getModifiers())
&& !Modifier.isFinal(method.getModifiers())
&& !Modifier.isAbstract(method.getModifiers()))
methods.add(method);
return methods;
protected Class<?>[] getAdditionalInterfacesToImplement(Class<?> targetClass)
return null;
protected abstract ArrayList<Method> getDelegateMethods(Class<?> targetClass, ArrayList<Method> allMethods);
protected abstract String getProxyClassSuffix();
package org.apache.deltaspike.core.util.proxy.invocation;
import org.apache.deltaspike.core.util.invocation.AbstractManualInvocationHandler;
import org.apache.deltaspike.core.util.proxy.DeltaSpikeProxy;
public class DelegateManualInvocationHandler extends AbstractManualInvocationHandler
private static final DelegateManualInvocationHandler INSTANCE = new DelegateManualInvocationHandler();
InvocationHandler delegateInvocationHandler = ((DeltaSpikeProxy) proxy).getDelegateInvocationHandler();
return delegateInvocationHandler.invoke(proxy, method, parameters);
package org.apache.deltaspike.core.util.proxy.invocation;
import org.apache.deltaspike.core.util.invocation.AbstractManualInvocationHandler;
import org.apache.deltaspike.core.util.proxy.DeltaSpikeProxyFactory;
public class InterceptManualInvocationHandler extends AbstractManualInvocationHandler
private static final InterceptManualInvocationHandler INSTANCE = new InterceptManualInvocationHandler();
Method superAccessorMethod = DeltaSpikeProxyFactory.getSuperAccessorMethod(proxy, method);
import org.apache.deltaspike.core.util.proxy.DeltaSpikeProxy;
if (result instanceof DeltaSpikeProxy || ProxyUtils.isProxiedClass(result.getClass()))
if (result instanceof DeltaSpikeProxy || ProxyUtils.isProxiedClass(result.getClass()))
import org.apache.deltaspike.core.util.proxy.DeltaSpikeProxyContextualLifecycle;
DeltaSpikeProxyContextualLifecycle lifecycle = new DeltaSpikeProxyContextualLifecycle(beanClass,
invocationHandlerClass, ConverterAndValidatorProxyFactory.getInstance(), beanManager);
.beanLifecycle(lifecycle);
return method.invoke(defaultPartialStateHolder, args);
@Override
@Override
@Override
return method.invoke(defaultPartialStateHolder, args);
import org.apache.deltaspike.core.util.proxy.DeltaSpikeProxyContextualLifecycle;
DeltaSpikeProxyContextualLifecycle lifecycle = new DeltaSpikeProxyContextualLifecycle(beanClass,
descriptor.getHandler(),
PartialBeanProxyFactory.getInstance(),
beanManager);
.beanLifecycle(lifecycle);
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
beanBuilder.addQualifier(new DefaultLiteral());
interface BeanManagerDelegation
interface WindowRestriction
if (cdiClass != null && !CoreBaseConfig.BeanManagerDelegation.DELEGATE_LOOKUP.getValue())
this.maxWindowContextCount = CoreBaseConfig.Scope.WindowRestriction.MAX_COUNT.getValue();
interface WindowRestriction
new TypedConfig<Integer>(CoreBaseConfig.Scope.WindowRestriction.MAX_COUNT.getKey(), 64);
interface ViewDelegation
this.maxWindowContextCount = JsfBaseConfig.Scope.WindowRestriction.MAX_COUNT.getValue();
int result = JsfBaseConfig.Scope.WindowRestriction.ID_MAX_LENGTH.getValue();
if (result > JsfBaseConfig.Scope.WindowRestriction.ID_MAX_LENGTH.getDefaultValue())
JsfBaseConfig.Scope.ViewDelegation.DELEGATE_TO_JSF.getValue();
String defaultJobFactoryName = SchedulerBaseConfig.JobCustomization.DEFAULT_JOB_FACTORY_CLASS_NAME.getValue();
interface JobCustomization
String jobClassName = SchedulerBaseConfig.JobCustomization.JOB_CLASS_NAME.getValue();
put(SchedulerBaseConfig.JobCustomization.JOB_CLASS_NAME.getKey(), CustomJob.class.getName());
put(SchedulerBaseConfig.JobCustomization.JOB_CLASS_NAME.getKey(), CustomJob.class.getName());
if (!TestBaseConfig.MockIntegration.ALLOW_MOCKED_BEANS.getValue() &&
!TestBaseConfig.MockIntegration.ALLOW_MOCKED_PRODUCERS.getValue())
return TestBaseConfig.MockIntegration.ALLOW_MOCKED_PRODUCERS.getValue();
return TestBaseConfig.MockIntegration.ALLOW_MOCKED_BEANS.getValue();
defineDefaultConstructor(cw, proxyType, superType);
defineDelegateInvocationHandlerConstructor(cw, proxyType, superType, invocationHandlerType);
private static void defineDefaultConstructor(ClassWriter cw, Type proxyType, Type superType)
private static void defineDelegateInvocationHandlerConstructor(ClassWriter cw, Type proxyType, Type superType,
Type invocationHandlerType)
{
GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC,
new Method("<init>", Type.VOID_TYPE, new Type[] { invocationHandlerType }),
null,
null,
cw);
mg.visitCode();
mg.loadThis();
mg.invokeConstructor(superType, Method.getMethod("void <init> ()"));
mg.loadThis();
mg.loadArg(0);
mg.putField(proxyType, FIELDNAME_DELEGATE_INVOCATION_HANDLER, invocationHandlerType);
mg.returnValue();
mg.endMethod();
mg.visitEnd();
}
import java.lang.reflect.Constructor;
T instance;
if (delegateInvocationHandlerClass == null)
{
instance = proxyClass.newInstance();
}
else
Constructor<T> constructor = proxyClass.getConstructor(delegateInvocationHandlerClass);
instance = constructor.newInstance(delegateInvocationHandler);
if (!StateHolder.class.isAssignableFrom(targetClass))
{
ArrayList<Method> delegateMethods = new ArrayList<Method>();
delegateMethods.addAll(Arrays.asList(StateHolder.class.getDeclaredMethods()));
delegateMethods.addAll(Arrays.asList(PartialStateHolder.class.getDeclaredMethods()));
return delegateMethods;
}
if (!PartialStateHolder.class.isAssignableFrom(targetClass))
import java.security.ProtectionDomain;
Class<T> proxyClass = (Class<T>) loadClass(classLoader, proxyName, proxyBytes,
targetClass.getProtectionDomain());
private static Class<?> loadClass(ClassLoader loader, String className, byte[] b,
ProtectionDomain protectionDomain)
"defineClass", String.class, byte[].class, int.class, int.class, ProtectionDomain.class);
return (Class<?>) method.invoke(loader, className, b, Integer.valueOf(0), Integer.valueOf(b.length),
protectionDomain);
import org.apache.deltaspike.core.api.literal.DestroyedLiteral;
import org.apache.deltaspike.core.api.literal.InitializedLiteral;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.metadata.AnnotationInstanceProvider;
import javax.annotation.PostConstruct;
import javax.faces.bean.RequestScoped;
import java.lang.annotation.Annotation;
import java.util.HashMap;
import java.util.Map;
private Event<FacesContext> jsfRequestEvent;
private Annotation initializedAnnotationInstance;
private Annotation destroyedAnnotationInstance;
@PostConstruct
protected void init()
{
Map<String, Class> values = new HashMap<String, Class>();
values.put("value", RequestScoped.class);
Class<? extends Annotation> initializedAnnotationClass =
ClassUtils.tryToLoadClassForName("javax.enterprise.context.Initialized");
if (initializedAnnotationClass != null)
{
this.initializedAnnotationInstance = AnnotationInstanceProvider.of(initializedAnnotationClass, values);
}
Class<? extends Annotation> destroyedAnnotationClass =
ClassUtils.tryToLoadClassForName("javax.enterprise.context.Destroyed");
if (destroyedAnnotationClass != null)
{
this.destroyedAnnotationInstance = AnnotationInstanceProvider.of(destroyedAnnotationClass, values);
}
}
this.jsfRequestEvent.select(new InitializedLiteral()).fire(facesContext);
if (this.initializedAnnotationInstance != null)
{
this.jsfRequestEvent.select(this.initializedAnnotationInstance).fire(facesContext);
}
this.jsfRequestEvent.select(new DestroyedLiteral()).fire(facesContext);
if (this.destroyedAnnotationInstance != null)
{
this.jsfRequestEvent.select(this.destroyedAnnotationInstance).fire(facesContext);
}
final Object annotationMemberValue = ReflectionUtils.invokeMethod(annotation, member, Object.class, true);
{
arrayValue = 0;
}
else if (annotationMemberValue.getClass().isArray())
import org.apache.deltaspike.core.util.AnnotationUtils;
import java.util.Collection;
import java.util.Iterator;
Annotation resultToAdd = preProcessor.beforeAddToConfig(annotation, node);
{
validateAnnotationChange(annotation);
rewriteMetaDataOfNode(node.getMetaData(), annotation, resultToAdd);
rewriteMetaDataOfNode(node.getInheritedMetaData(), annotation, resultToAdd);
}
result.add(resultToAdd);
protected void validateAnnotationChange(Annotation annotation)
{
Class<? extends Annotation> annotationType = annotation.annotationType();
if (Folder.class.equals(annotationType) || View.class.equals(annotationType))
{
return;
}
ViewMetaData viewMetaData = annotationType.getAnnotation(ViewMetaData.class);
if (viewMetaData == null)
{
return;
}
Aggregated aggregated = viewMetaData.annotationType().getAnnotation(Aggregated.class);
if (aggregated != null && aggregated.value())
{
throw new IllegalStateException("it isn't supported to change aggregated meta-data,"
"because inheritance won't work correctly");
}
}
protected void rewriteMetaDataOfNode(Collection<Annotation> metaData,
Annotation oldMetaData, Annotation newMetaData)
{
Iterator<Annotation> metaDataIterator = metaData.iterator();
while (metaDataIterator.hasNext())
{
Annotation currentMetaData = metaDataIterator.next();
if (AnnotationUtils.getQualifierHashCode(currentMetaData) ==
AnnotationUtils.getQualifierHashCode(oldMetaData))
{
metaDataIterator.remove();
metaData.add(newMetaData);
break;
}
}
}
import org.apache.deltaspike.core.api.config.view.metadata.Aggregated;
import org.apache.deltaspike.jsf.api.config.view.Folder;
import org.apache.deltaspike.jsf.api.config.view.View;
import java.util.Collections;
inheritedAnnotations.addAll(findViewMetaData(currentClass, viewConfigNode));
inheritedAnnotations.addAll(findViewMetaData(viewConfigNode.getSource(), viewConfigNode));
protected List<Annotation> findViewMetaData(Class currentClass, ViewConfigNode viewConfigNode)
if (currentClass.equals(viewConfigNode.getSource()))
{
return Collections.emptyList();
}
result = tryToReplaceWithMergedMetaDataFromAncestor(currentClass, viewConfigNode.getParent(), result);
protected List<Annotation> tryToReplaceWithMergedMetaDataFromAncestor(
Class currentClass, ViewConfigNode parentViewConfigNode, List<Annotation> foundResult)
{
ViewConfigNode ancestorNode = findNodeWithClass(currentClass, parentViewConfigNode);
if (ancestorNode == null)
{
return foundResult;
}
List<Annotation> result = new ArrayList<Annotation>(foundResult.size());
for (Annotation annotation : foundResult)
{
Annotation finalMetaData = getFinalMetaDataFromNode(ancestorNode, annotation);
result.add(finalMetaData);
}
return result;
}
private Annotation getFinalMetaDataFromNode(ViewConfigNode viewConfigNode, Annotation annotation)
{
Class<? extends Annotation> targetType = annotation.annotationType();
if (View.class.equals(targetType) || Folder.class.equals(targetType))
{
return annotation;
}
ViewMetaData viewMetaData = annotation.annotationType().getAnnotation(ViewMetaData.class);
if (viewMetaData == null)
{
return annotation;
}
Aggregated aggregated = viewMetaData.annotationType().getAnnotation(Aggregated.class);
if (aggregated == null || aggregated.value())
{
return annotation;
}
for (Annotation nodeMetaData : viewConfigNode.getMetaData())
{
if (targetType.equals(nodeMetaData.annotationType()))
{
return nodeMetaData;
}
}
return annotation;
}
private ViewConfigNode findNodeWithClass(Class nodeClass, ViewConfigNode viewConfigNode)
{
if (viewConfigNode == null || nodeClass == null)
{
return null;
}
if (nodeClass.equals(viewConfigNode.getSource()))
{
return viewConfigNode;
}
return findNodeWithClass(nodeClass, viewConfigNode.getParent());
}
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
import org.apache.deltaspike.core.impl.util.AnnotationInstanceUtils;
private Annotation priorityAnnotationInstance;
if (isGlobalAlternativeActivated)
{
int priorityValue = CoreBaseConfig.Interceptor.PRIORITY.getValue();
priorityAnnotationInstance = AnnotationInstanceUtils.getPriorityAnnotationInstance(priorityValue);
}
if (!doQualifiersMatch(qualifiersOfCurrentBean, qualifiersOfConfiguredBean))
{
continue;
}
if (priorityAnnotationInstance == null)
else
{
AnnotatedTypeBuilder<Object> annotatedTypeBuilder
= new AnnotatedTypeBuilder<Object>().readFromType(processAnnotatedType.getAnnotatedType());
annotatedTypeBuilder.addToClass(priorityAnnotationInstance);
processAnnotatedType.setAnnotatedType(annotatedTypeBuilder.create());
return;
}
if (priorityAnnotationInstance == null)
import org.apache.deltaspike.core.impl.util.AnnotationInstanceUtils;
int priorityValue = CoreBaseConfig.Interceptor.PRIORITY.getValue();
priorityAnnotationInstance = AnnotationInstanceUtils.getPriorityAnnotationInstance(priorityValue);
this.jsfRequestLifecyclePhaseListener.beforePhase(phaseEvent);
if (StringUtils.isEmpty(windowId) && facesContext.isPostback())
{
windowId = getPostBackWindowId(facesContext);
}
if (this.jsfModuleConfig.isInitialRedirectEnabled() && !facesContext.isPostback())
collectClasses(repoClass, result);
private void collectClasses(Class<?> cls, Set<Class<?>> result)
{
if (cls == null || cls == Object.class)
{
return;
}
result.add(cls);
for (Class<?> child : cls.getInterfaces())
{
collectClasses(child, result);
}
collectClasses(cls.getSuperclass(), result);
}
<P> Criteria<C, R> eqIgnoreCase(SingularAttribute<? super C, String> att, String value);
<P> Criteria<C, R> notEqIgnoreCase(SingularAttribute<? super C, String> att, String value);
<P> Criteria<C, R> likeIgnoreCase(SingularAttribute<? super C, String> att, String value);
<P> Criteria<C, R> notLikeIgnoreCase(SingularAttribute<? super C, String> att, String value);
import org.apache.deltaspike.data.impl.criteria.predicate.EqIgnoreCase;
import org.apache.deltaspike.data.impl.criteria.predicate.NotEqIgnoreCase;
public <P> Criteria<C, R> eqIgnoreCase(SingularAttribute<? super C, String> att, String value)
{
add(new EqIgnoreCase<C>(att, value), value);
return this;
}
@Override
public <P> Criteria<C, R> notEqIgnoreCase(SingularAttribute<? super C, String> att, String value)
{
add(new NotEqIgnoreCase<C>(att, value), value);
return this;
}
@Override
public <P> Criteria<C, R> likeIgnoreCase(SingularAttribute<? super C, String> att, String value)
{
add(new Like<C>(att, value, true), value);
return this;
}
@Override
public <P> Criteria<C, R> notLikeIgnoreCase(SingularAttribute<? super C, String> att, String value)
{
add(new NotLike<C>(att, value, true), value);
return this;
}
@Override
private final boolean caseInsensitive;
this(att, value, false);
}
public Like(SingularAttribute<? super E, String> att, String value, boolean caseInsensitive)
{
this.caseInsensitive = caseInsensitive;
return Arrays.asList(builder.like(
caseInsensitive ? builder.upper(path.<String>get(getAtt())) : path.get(getAtt()),
caseInsensitive ? getValue().toUpperCase() : getValue()));
private final boolean caseInsensitive;
this(att, value, false);
}
public NotLike(SingularAttribute<? super E, String> att, String value, boolean caseInsensitive)
{
this.caseInsensitive = caseInsensitive;
return Arrays.asList(builder.notLike(
caseInsensitive ? builder.upper(path.<String>get(getAtt())) : path.get(getAtt()),
caseInsensitive ? getValue().toUpperCase() : getValue()));
@SuppressWarnings("unchecked")
public List<Simple> queryByIgnoreCase(String name, String nameLike)
{
return criteria()
.or(
criteria()
.eqIgnoreCase(Simple_.name, name)
.notEqIgnoreCase(Simple_.name, nameLike),
criteria()
.likeIgnoreCase(Simple_.name, nameLike)
.notLikeIgnoreCase(Simple_.name, name)
)
.getResultList();
}
if (errorViewDescriptor == null && errorView != null)
{
errorViewDescriptor = viewConfigResolver.getViewConfigDescriptor(errorView);
}
if (errorViewDescriptor != null)
{
return this.wrapped.createView(context, errorViewDescriptor.getViewId());
}
else
{
if (!context.isPostback() && context.getViewRoot() != null)
{
context.getViewRoot().setViewId(null);
}
}
if (errorView == null && allowNavigation)
if (!isMessageAddedAlready(message))
{
FacesMessage facesMessage = new FacesMessage(FacesMessage.SEVERITY_ERROR, message, message);
FacesContext.getCurrentInstance().addMessage(null, facesMessage);
}
private static boolean isMessageAddedAlready(String message)
{
FacesContext facesContext = FacesContext.getCurrentInstance();
if (facesContext == null || message == null)
{
return false;
}
List<FacesMessage> existingMessages = facesContext.getMessageList();
if (existingMessages == null)
{
return false;
}
for (FacesMessage facesMessage : existingMessages)
{
if (message.equals(facesMessage.getSummary()))
{
return true;
}
}
return false;
}
SecurityUtils.handleSecurityViolationWithoutNavigation(accessDeniedException);
public static void handleSecurityViolationWithoutNavigation(RuntimeException exception)
tryToHandleSecurityViolation(exception, false);
private static void tryToHandleSecurityViolation(RuntimeException runtimeException,
boolean allowNavigation)
import java.lang.reflect.InvocationTargetException;
if (e instanceof InvocationTargetException)
{
ExceptionUtils.throwAsRuntimeException(e.getCause());
}
boolean deleteJob(Class<? extends T> jobClass);
public boolean deleteJob(Class<? extends Job> jobClass)
{
try
{
return this.scheduler.deleteJob(createJobKey(jobClass));
}
catch (SchedulerException e)
{
throw ExceptionUtils.throwAsRuntimeException(e);
}
}
@Override
public boolean deleteJob(Class<? extends CustomJob> jobClass) {
return TestJobManager.getInstance().deleteJob(jobClass);
}
public interface PropertyFileConfig
import org.apache.deltaspike.proxy.util.DeltaSpikeProxy;
import org.apache.deltaspike.proxy.util.DeltaSpikeProxyContextualLifecycle;
@Observes ProcessAnnotatedType<X> pat, BeanManager beanManager)
"you they aren't allowed to be 'final'.");
return scopeAnnotationClass != null && beanManager.isNormalScope(scopeAnnotationClass);
&& currentMethod.getParameterTypes().length == 1 &&
hasGetterMethod(beanClass, currentMethod.getName().substring(3)))
Converter.class.isAssignableFrom(beanClass) ?
ConverterInvocationHandler.class : ValidatorInvocationHandler.class;
.readFromType(annotatedType)
.passivationCapable(true)
.beanLifecycle(lifecycle);
import org.apache.deltaspike.proxy.util.DeltaSpikeProxyFactory;
import org.apache.deltaspike.proxy.util.DeltaSpikeProxyContextualLifecycle;
import org.apache.deltaspike.proxy.util.DeltaSpikeProxyFactory;
package org.apache.deltaspike.proxy.invocation;
package org.apache.deltaspike.proxy.invocation;
import org.apache.deltaspike.proxy.util.DeltaSpikeProxy;
package org.apache.deltaspike.proxy.invocation;
import org.apache.deltaspike.proxy.util.DeltaSpikeProxyFactory;
package org.apache.deltaspike.proxy.invocation;
package org.apache.deltaspike.proxy.invocation;
package org.apache.deltaspike.proxy.util;
import org.apache.deltaspike.proxy.invocation.DelegateManualInvocationHandler;
import org.apache.deltaspike.proxy.invocation.InterceptManualInvocationHandler;
package org.apache.deltaspike.proxy.util;
package org.apache.deltaspike.proxy.util;
package org.apache.deltaspike.proxy.util;
, new String[]{ "org.apache.deltaspike.core",
"org.apache.deltaspike.proxy",
"org.apache.deltaspike.jsf" }
"ds-core_proxy_jsf");
"org.apache.deltaspike.proxy",
"ds-core_proxy_and_partial-bean");
Class<? extends InvocationHandler> delegateInvocationHandlerClass,
byte[] proxyBytes = generateProxyClassBytes(targetClass, delegateInvocationHandlerClass,
Class<? extends InvocationHandler> delegateInvocationHandlerClass,
Type delegateInvocationHandlerType = Type.getType(delegateInvocationHandlerClass);
defineInvocationHandlerField(cw, delegateInvocationHandlerType);
defineDelegateInvocationHandlerConstructor(cw, proxyType, superType, delegateInvocationHandlerType);
defineDeltaSpikeProxyMethods(cw, proxyType, delegateInvocationHandlerType);
private static void defineInvocationHandlerField(ClassWriter cw, Type delegateInvocationHandlerType)
delegateInvocationHandlerType.getDescriptor(), null, null).visitEnd();
Type delegateInvocationHandlerType)
new Method("<init>", Type.VOID_TYPE, new Type[] { delegateInvocationHandlerType }),
mg.putField(proxyType, FIELDNAME_DELEGATE_INVOCATION_HANDLER, delegateInvocationHandlerType);
private static void defineDeltaSpikeProxyMethods(ClassWriter cw, Type proxyType, Type delegateInvocationHandlerType)
mg.checkCast(delegateInvocationHandlerType);
mg.putField(proxyType, FIELDNAME_DELEGATE_INVOCATION_HANDLER, delegateInvocationHandlerType);
mg.getField(proxyType, FIELDNAME_DELEGATE_INVOCATION_HANDLER, delegateInvocationHandlerType);
void setDelegateInvocationHandler(InvocationHandler delegateInvocationHandler);
Class<? extends InvocationHandler> delegateInvocationHandlerClass)
proxyClass = createProxyClass(targetClass.getClassLoader(), targetClass, delegateInvocationHandlerClass);
Class<? extends InvocationHandler> delegateInvocationHandlerClass)
delegateInvocationHandlerClass,
@Nonbinding
boolean projectStageAware() default true;
@Nonbinding
String parameterizedBy() default NULL;
import org.apache.deltaspike.core.util.ExceptionUtils;
private static <T> T fallbackToDefaultIfEmpty(String key, T value, T defaultValue)
if (value == null || (value instanceof String && ((String)value).isEmpty()))
public interface Converter<T>
{
T convert(String value);
}
public interface TypedResolver<T>
{
TypedResolver<T> parameterizedBy(String propertyName);
TypedResolver<T> withCurrentProjectStage(boolean with);
TypedResolver<T> strictly(boolean strictly);
TypedResolver<T> withDefault(T value);
TypedResolver<T> withStringDefault(String value);
T getValue();
String getKey();
String getResolvedKey();
T getDefaultValue();
}
public interface UntypedResolver<T> extends TypedResolver<T>
{
<N> TypedResolver<N> as(Class<N> clazz);
<N> TypedResolver<N> as(Class<N> clazz, Converter<N> converter);
}
public static UntypedResolver<String> resolve(String name)
{
return new PropertyBuilder<String>(name);
}
private static class PropertyBuilder<T> implements UntypedResolver<T>
{
private String keyOriginal;
private String keyResolved;
private Class<?> configEntryType = String.class;
private T defaultValue;
private boolean projectStageAware = true;
private String propertyParameter;
private String parameterValue;
private boolean strictly = false;
private Converter<?> converter;
private PropertyBuilder()
{
}
protected PropertyBuilder(String propertyName)
{
this.keyOriginal = propertyName;
}
@Override
@SuppressWarnings("unchecked")
public <N> TypedResolver<N> as(Class<N> clazz)
{
configEntryType = clazz;
return (TypedResolver<N>) this;
}
@Override
@SuppressWarnings("unchecked")
public <N> TypedResolver<N> as(Class<N> clazz, Converter<N> converter)
{
configEntryType = clazz;
this.converter = converter;
return (TypedResolver<N>) this;
}
@Override
public TypedResolver<T> withDefault(T value)
{
defaultValue = value;
return this;
}
@Override
public TypedResolver<T> withStringDefault(String value)
{
if (value == null || value.isEmpty())
{
throw new RuntimeException("Empty String or null supplied as string-default value for property "
keyOriginal);
}
defaultValue = convert(value);
return this;
}
@Override
public TypedResolver<T> parameterizedBy(String propertyName)
{
this.propertyParameter = propertyName;
if (propertyParameter != null && !propertyParameter.isEmpty())
{
String parameterValue = ConfigResolver
.resolve(propertyParameter)
.withCurrentProjectStage(projectStageAware)
.getValue();
if (parameterValue != null && !parameterValue.isEmpty())
{
this.parameterValue = parameterValue;
}
}
return this;
}
@Override
public TypedResolver<T> withCurrentProjectStage(boolean with)
{
this.projectStageAware = with;
return this;
}
@Override
public TypedResolver<T> strictly(boolean strictly)
{
this.strictly = strictly;
return this;
}
@Override
public T getValue()
{
String valueStr = resolveStringValue();
T value = convert(valueStr);
return fallbackToDefaultIfEmpty(keyResolved, value, defaultValue);
}
@Override
public String getKey()
{
return keyOriginal;
}
@Override
public String getResolvedKey()
{
return keyResolved;
}
@Override
public T getDefaultValue()
{
return defaultValue;
}
private String resolveStringValue()
{
ProjectStage ps = null;
String value = null;
keyResolved = keyOriginal;
int keySuffices = 0;
if (propertyParameter != null && !propertyParameter.isEmpty())
{
if (parameterValue != null && !parameterValue.isEmpty())
{
}
else if (strictly)
{
return null;
}
}
if (projectStageAware)
{
ps = getProjectStage();
}
value = getPropertyValue(keyResolved);
if (value == null && !strictly)
{
switch (keySuffices)
{
case 2:
value = getPropertyValue(keyResolved);
if (value != null)
{
return value;
}
ps = getProjectStage();
value = getPropertyValue(keyResolved);
if (value != null)
{
return value;
}
case 1:
keyResolved = keyOriginal;
value = getPropertyValue(keyResolved);
return value;
default:
return null;
}
}
return value;
}
private T convert(String value)
{
if (value == null)
{
return null;
}
Object result = null;
if (this.converter != null)
{
try
{
result = converter.convert(value);
}
catch (Exception e)
{
throw ExceptionUtils.throwAsRuntimeException(e);
}
}
else if (String.class.equals(configEntryType))
{
result = value;
}
else if (Class.class.equals(configEntryType))
{
result = ClassUtils.tryToLoadClassForName(value);
}
else if (Boolean.class.equals(configEntryType))
{
Boolean isTrue = "TRUE".equalsIgnoreCase(value);
isTrue |= "1".equalsIgnoreCase(value);
isTrue |= "YES".equalsIgnoreCase(value);
isTrue |= "Y".equalsIgnoreCase(value);
isTrue |= "JA".equalsIgnoreCase(value);
isTrue |= "J".equalsIgnoreCase(value);
isTrue |= "OUI".equalsIgnoreCase(value);
result = isTrue;
}
else if (Integer.class.equals(configEntryType))
{
result = Integer.parseInt(value);
}
else if (Long.class.equals(configEntryType))
{
result = Long.parseLong(value);
}
else if (Float.class.equals(configEntryType))
{
result = Float.parseFloat(value);
}
else if (Double.class.equals(configEntryType))
{
result = Double.parseDouble(value);
}
return (T) result;
}
}
import org.apache.deltaspike.core.api.config.ConfigResolver;
Boolean DELEGATE_LOOKUP =
ConfigResolver.resolve("deltaspike.bean-manager.delegate_lookup")
.as(Boolean.class)
.withCurrentProjectStage(true)
.withDefault(Boolean.TRUE)
.getValue();
Integer PRIORITY =
ConfigResolver.resolve("deltaspike.interceptor.priority")
.as(Integer.class)
.withCurrentProjectStage(true)
.withDefault(0)
.getValue();
Boolean AUTO_UNREGISTER =
ConfigResolver.resolve("deltaspike.mbean.auto-unregister")
.as(Boolean.class)
.withCurrentProjectStage(true)
.withDefault(Boolean.TRUE)
.getValue();
String MAX_COUNT_KEY = "deltaspike.scope.window.max-count";
Integer MAX_COUNT =
ConfigResolver.resolve(MAX_COUNT_KEY)
.as(Integer.class)
.withCurrentProjectStage(true)
.withDefault(1024)
.getValue();
if (cdiClass != null && !CoreBaseConfig.BeanManagerDelegation.DELEGATE_LOOKUP)
return getPropertyValue(injectionPoint, String.class);
}
protected <T> T getPropertyValue(InjectionPoint injectionPoint, Class<T> ipCls)
{
ConfigProperty configProperty = getAnnotation(injectionPoint, ConfigProperty.class);
if (configProperty == null)
{
throw new IllegalStateException("producer method called without @ConfigProperty being present!");
}
ConfigResolver.TypedResolver<T> resolver = ConfigResolver.resolve(configProperty.name())
.as(ipCls)
.withCurrentProjectStage(configProperty.projectStageAware());
String stringDefault = configProperty.defaultValue();
if (!ConfigProperty.NULL.equals(stringDefault))
{
resolver.withStringDefault(stringDefault);
}
String parameterizedBy = configProperty.parameterizedBy();
if (!ConfigProperty.NULL.equals(parameterizedBy))
{
resolver.parameterizedBy(parameterizedBy);
}
return resolver.getValue();
public Class produceClassConfiguration(InjectionPoint injectionPoint)
return getPropertyWithException(injectionPoint, Class.class);
return getPropertyWithException(injectionPoint, Boolean.class);
}
@Produces
@Dependent
public Integer produceIntegerConfiguration(InjectionPoint injectionPoint)
{
return getPropertyWithException(injectionPoint, Integer.class);
}
@Produces
@Dependent
public Long produceLongConfiguration(InjectionPoint injectionPoint)
{
return getPropertyWithException(injectionPoint, Long.class);
return getPropertyWithException(injectionPoint, Float.class);
}
@Produces
@Dependent
public Double produceDoubleConfiguration(InjectionPoint injectionPoint)
{
return getPropertyWithException(injectionPoint, Double.class);
}
private <T> T getPropertyWithException(InjectionPoint ip, Class<T> ipCls)
{
return getPropertyValue(ip, ipCls);
catch (RuntimeException rte)
ConfigProperty configProperty = getAnnotation(ip, ConfigProperty.class);
int priorityValue = CoreBaseConfig.Interceptor.PRIORITY;
int priorityValue = CoreBaseConfig.Interceptor.PRIORITY;
if (server.isRegistered(objectName) && CoreBaseConfig.MBean.AUTO_UNREGISTER)
this.maxWindowContextCount = CoreBaseConfig.Scope.WindowRestriction.MAX_COUNT;
@ConfigProperty(name = "configproperty.test.string")
private String stringConfig;
@Inject
@ConfigProperty(name = "INVALIDKEY", defaultValue = "DEFAULT")
private String stringConfigWithDefault;
@Inject
@ConfigProperty(name = "configproperty.test.string", projectStageAware = false)
private String stringConfigWithoutProjectStage;
@Inject
@ConfigProperty(name = "configproperty.test.string", projectStageAware = true,
parameterizedBy = "configproperty.test.param")
private String stringConfigParameterized;
@Inject
@ConfigProperty(name = "configproperty.test.boolean")
private Boolean booleanConfig;
@Inject
@ConfigProperty(name = "configproperty.test.class")
private Class classConfig;
@Inject
@ConfigProperty(name = "configproperty.test.int")
private Integer intConfig;
@Inject
@ConfigProperty(name = "configproperty.test.long")
private Long longConfig;
@Inject
@ConfigProperty(name = "configproperty.test.float")
private Float floatConfig;
@Inject
@ConfigProperty(name = "configproperty.test.double")
private Double doubleConfig;
public String getStringConfig()
return stringConfig;
public String getStringConfigWithDefault()
{
return stringConfigWithDefault;
}
public String getStringConfigWithoutProjectStage()
{
return stringConfigWithoutProjectStage;
}
public String getStringConfigParameterized()
{
return stringConfigParameterized;
}
public boolean getBooleanConfig()
{
return booleanConfig;
}
public Class getClassConfig()
{
return classConfig;
}
public int getIntConfig()
{
return intConfig;
}
public long getLongConfig()
{
return longConfig;
}
public float getFloatConfig()
{
return floatConfig;
}
public double getDoubleConfig()
{
return doubleConfig;
}
import org.apache.deltaspike.core.api.config.ConfigResolver;
String CUSTOM_DEFAULT_BASE_PATH_BUILDER = ConfigResolver.resolve(View.DefaultBasePathBuilder.class.getName())
.withCurrentProjectStage(true)
.getValue();
String CUSTOM_DEFAULT_FILE_NAME_BUILDER = ConfigResolver.resolve(View.DefaultFileNameBuilder.class.getName())
.withCurrentProjectStage(true)
.getValue();
String CUSTOM_DEFAULT_EXTENSION_BUILDER = ConfigResolver.resolve(View.DefaultExtensionBuilder.class.getName())
.withCurrentProjectStage(true)
.getValue();
String CUSTOM_DEFAULT_FOLDER_NAME_BUILDER = ConfigResolver
.resolve(Folder.DefaultFolderNameBuilder.class.getName())
.withCurrentProjectStage(true)
.getValue();
int ID_MAX_LENGTH_DEFAULT = 10;
Integer MAX_COUNT = ConfigResolver.resolve(CoreBaseConfig.Scope.WindowRestriction.MAX_COUNT_KEY)
.as(Integer.class)
.withCurrentProjectStage(true)
.withDefault(64)
.getValue();
Integer ID_MAX_LENGTH = ConfigResolver.resolve("deltaspike.window-id.max_length")
.as(Integer.class)
.withCurrentProjectStage(true)
.withDefault(ID_MAX_LENGTH_DEFAULT)
.getValue();
Boolean DELEGATE_TO_JSF = ConfigResolver.resolve("deltaspike.scope.view.delegate")
.as(Boolean.class)
.withCurrentProjectStage(true)
.withDefault(Boolean.TRUE)
.getValue();
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER;
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_BASE_PATH_BUILDER;
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FILE_NAME_BUILDER;
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_EXTENSION_BUILDER;
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER;
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_BASE_PATH_BUILDER;
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_FILE_NAME_BUILDER;
JsfBaseConfig.ViewConfig.CUSTOM_DEFAULT_EXTENSION_BUILDER;
this.maxWindowContextCount = JsfBaseConfig.Scope.WindowRestriction.MAX_COUNT;
int result = JsfBaseConfig.Scope.WindowRestriction.ID_MAX_LENGTH;
if (result > JsfBaseConfig.Scope.WindowRestriction.ID_MAX_LENGTH_DEFAULT)
JsfBaseConfig.Scope.ViewDelegation.DELEGATE_TO_JSF;
String defaultJobFactoryName = SchedulerBaseConfig.JobCustomization.DEFAULT_JOB_FACTORY_CLASS_NAME;
if (SchedulerBaseConfig.Lifecycle.START_SCOPES_PER_JOB)
this.scheduler.startDelayed(SchedulerBaseConfig.Lifecycle.DELAYED_START_IN_SECONDS);
String configFile = SchedulerBaseConfig.SCHEDULER_CONFIG_FILE;
this.scheduler.shutdown(SchedulerBaseConfig.Lifecycle.FORCE_STOP);
import org.apache.deltaspike.core.api.config.ConfigResolver;
String JOB_CLASS_NAME_KEY = "deltaspike.scheduler.job-class";
String DEFAULT_JOB_FACTORY_CLASS_NAME = ConfigResolver.resolve("deltaspike.scheduler.DefaultJobFactory")
.withCurrentProjectStage(true)
.withDefault("org.quartz.simpl.PropertySettingJobFactory")
.getValue();
String JOB_CLASS_NAME = ConfigResolver.resolve(JOB_CLASS_NAME_KEY)
.withCurrentProjectStage(true)
.withDefault("org.quartz.Job")
.getValue();
String SCHEDULER_CONFIG_FILE = ConfigResolver.resolve("deltaspike.scheduler.quartz_config-file")
.withCurrentProjectStage(true)
.withDefault("quartz")
.getValue();
String START_SCOPES_PER_JOB_KEY = "deltaspike.scheduler.start_scopes_for_jobs";
Boolean START_SCOPES_PER_JOB = ConfigResolver.resolve(START_SCOPES_PER_JOB_KEY)
.as(Boolean.class)
.withCurrentProjectStage(true)
.withDefault(Boolean.TRUE)
.getValue();
Boolean FORCE_STOP = ConfigResolver.resolve("deltaspike.scheduler.force_stop")
.as(Boolean.class)
.withCurrentProjectStage(true)
.withDefault(Boolean.TRUE)
.getValue();
Integer DELAYED_START_IN_SECONDS = ConfigResolver.resolve("deltaspike.scheduler.delayed_start_in_seconds")
.as(Integer.class)
.withCurrentProjectStage(true)
.withDefault(1)
.getValue();
String jobClassName = SchedulerBaseConfig.JobCustomization.JOB_CLASS_NAME;
put(SchedulerBaseConfig.JobCustomization.JOB_CLASS_NAME_KEY, CustomJob.class.getName());
put(SchedulerBaseConfig.JobCustomization.JOB_CLASS_NAME_KEY, CustomJob.class.getName());
put(SchedulerBaseConfig.Lifecycle.START_SCOPES_PER_JOB_KEY, Boolean.FALSE.toString());
return MyFacesTestBaseConfig.WEBAPP_RESOURCE_PATH;
if (!TestBaseConfig.MockIntegration.ALLOW_MOCKED_BEANS &&
!TestBaseConfig.MockIntegration.ALLOW_MOCKED_PRODUCERS)
return TestBaseConfig.MockIntegration.ALLOW_MOCKED_PRODUCERS;
return TestBaseConfig.MockIntegration.ALLOW_MOCKED_BEANS;
public interface CoreBaseConfig extends DeltaSpikeBaseConfig
import org.apache.deltaspike.core.api.config.base.DeltaSpikeBaseConfig;
public interface JsfBaseConfig extends DeltaSpikeBaseConfig
import org.apache.deltaspike.core.api.config.base.DeltaSpikeBaseConfig;
public interface SchedulerBaseConfig extends DeltaSpikeBaseConfig
import org.apache.deltaspike.proxy.spi.DeltaSpikeProxy;
import org.apache.deltaspike.proxy.api.DeltaSpikeProxyContextualLifecycle;
import org.apache.deltaspike.proxy.api.DeltaSpikeProxyFactory;
import org.apache.deltaspike.proxy.api.DeltaSpikeProxyContextualLifecycle;
import org.apache.deltaspike.proxy.api.DeltaSpikeProxyFactory;
package org.apache.deltaspike.proxy.api;
public DeltaSpikeProxyContextualLifecycle(Class<T> targetClass,
Class<H> delegateInvocationHandlerClass,
DeltaSpikeProxyFactory proxyFactory,
BeanManager beanManager)
package org.apache.deltaspike.proxy.api;
import org.apache.deltaspike.core.util.ServiceUtils;
import org.apache.deltaspike.proxy.spi.ProxyClassGenerator;
List<ProxyClassGenerator> proxyClassGeneratorList =
ServiceUtils.loadServiceImplementations(ProxyClassGenerator.class);
if (proxyClassGeneratorList.size() != 1)
{
throw new IllegalStateException(proxyClassGeneratorList.size()
" found. It's just allowed to use one implementation.");
}
proxyClass = proxyClassGeneratorList.iterator().next().generateProxyClass(classLoader,
package org.apache.deltaspike.proxy.spi;
package org.apache.deltaspike.proxy.impl;
import org.apache.deltaspike.proxy.spi.DeltaSpikeProxy;
import org.apache.deltaspike.proxy.impl.invocation.DelegateManualInvocationHandler;
import org.apache.deltaspike.proxy.impl.invocation.InterceptManualInvocationHandler;
import org.apache.deltaspike.proxy.spi.ProxyClassGenerator;
public class AsmProxyClassGenerator implements ProxyClassGenerator
public <T> Class<T> generateProxyClass(ClassLoader classLoader,
package org.apache.deltaspike.proxy.impl.invocation;
package org.apache.deltaspike.proxy.impl.invocation;
import org.apache.deltaspike.proxy.spi.DeltaSpikeProxy;
package org.apache.deltaspike.proxy.impl.invocation;
import org.apache.deltaspike.proxy.api.DeltaSpikeProxyFactory;
package org.apache.deltaspike.proxy.impl.invocation;
package org.apache.deltaspike.proxy.impl.invocation;
import javax.servlet.http.HttpServletRequest;
boolean post = isPost(facesContext);
if (StringUtils.isEmpty(windowId) && post)
if (this.jsfModuleConfig.isInitialRedirectEnabled() && !post)
boolean post = isPost(facesContext);
if (post)
private boolean isPost(FacesContext context)
{
if (context.isPostback())
{
return true;
}
Object request = context.getExternalContext().getRequest();
if (request instanceof HttpServletRequest)
{
if ("POST".equals(((HttpServletRequest) request).getMethod()))
{
return true;
}
}
return false;
}
import org.apache.deltaspike.core.spi.activation.ClassDeactivator;
LOGGER.log(Level.WARNING, "Container issue detected -> can't validate view-configs. "
"This exception is usually the effect (but not the reason) of a failed startup. "
interface BeanManagerIntegration
interface InterceptorCustomization
interface MBeanIntegration
interface ScopeCustomization
if (cdiClass != null && !CoreBaseConfig.BeanManagerIntegration.DELEGATE_LOOKUP)
int priorityValue = CoreBaseConfig.InterceptorCustomization.PRIORITY;
int priorityValue = CoreBaseConfig.InterceptorCustomization.PRIORITY;
if (server.isRegistered(objectName) && CoreBaseConfig.MBeanIntegration.AUTO_UNREGISTER)
this.maxWindowContextCount = CoreBaseConfig.ScopeCustomization.WindowRestriction.MAX_COUNT;
interface ViewConfigCustomization
interface ScopeCustomization
Integer MAX_COUNT =
ConfigResolver.resolve(CoreBaseConfig.ScopeCustomization.WindowRestriction.MAX_COUNT_KEY)
JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER;
JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_BASE_PATH_BUILDER;
JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_FILE_NAME_BUILDER;
JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_EXTENSION_BUILDER;
JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_FOLDER_NAME_BUILDER;
JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_BASE_PATH_BUILDER;
JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_FILE_NAME_BUILDER;
JsfBaseConfig.ViewConfigCustomization.CUSTOM_DEFAULT_EXTENSION_BUILDER;
this.maxWindowContextCount = JsfBaseConfig.ScopeCustomization.WindowRestriction.MAX_COUNT;
int result = JsfBaseConfig.ScopeCustomization.WindowRestriction.ID_MAX_LENGTH;
if (result > JsfBaseConfig.ScopeCustomization.WindowRestriction.ID_MAX_LENGTH_DEFAULT)
JsfBaseConfig.ScopeCustomization.ViewDelegation.DELEGATE_TO_JSF;
if (SchedulerBaseConfig.LifecycleIntegration.START_SCOPES_PER_JOB)
this.scheduler.startDelayed(SchedulerBaseConfig.LifecycleIntegration.DELAYED_START_IN_SECONDS);
this.scheduler.shutdown(SchedulerBaseConfig.LifecycleIntegration.FORCE_STOP);
interface LifecycleIntegration
put(SchedulerBaseConfig.LifecycleIntegration.START_SCOPES_PER_JOB_KEY, Boolean.FALSE.toString());
public class AuthenticationListener
{
public void handleLoggedIn(@Observes UserEvent.LoggedIn event)
{
}
private LoginController loginController;
public void create()
{
{
public void create()
import org.apache.deltaspike.data.test.domain.SimpleStringId;
@Query(named = SimpleStringId.FIND_ALL_ORDER_BY_ID)
public abstract QueryResult<SimpleStringId> findAllOrderByIdPaginate(@FirstResult int start, @MaxResults int pageSize);
public static final String QUERY_DELETE = "delete from {0} e";
public static String deleteQuery(String entityName)
{
return MessageFormat.format(QUERY_DELETE, entityName);
}
if (methodPrefix.isDelete())
{
ctx.append(QueryBuilder.deleteQuery(entityName));
}
else
{
ctx.append(QueryBuilder.selectQuery(entityName));
}
import org.apache.deltaspike.data.impl.meta.MethodPrefix;
private final MethodPrefix methodPrefix;
this.methodPrefix = new MethodPrefix("", method.getName());
}
private QueryProcessorFactory(Method method, MethodPrefix methodPrefix)
{
this.method = method;
this.methodPrefix = methodPrefix;
public static QueryProcessorFactory newInstance(Method method, MethodPrefix methodPrefix)
{
return new QueryProcessorFactory(method, methodPrefix);
}
return (method.isAnnotationPresent(Modifying.class) && matchesType) || methodPrefix.isDelete();
public static final String DEFAULT_DELETE_PREFIX = "deleteBy";
public boolean isDelete()
{
return this.getPrefix().equalsIgnoreCase(DEFAULT_DELETE_PREFIX);
}
},
DELETE_DEFAULT(DEFAULT_DELETE_PREFIX)
{
@Override
public SingleResultType getStyle()
{
return SingleResultType.ANY;
}
this.queryProcessor = QueryProcessorFactory.newInstance(method, methodPrefix).build();
public abstract void deleteByName(String name);
public abstract void deleteByNameAndEnabled(String name, boolean enable);
import org.apache.deltaspike.core.api.provider.DependentProvider;
private DependentProvider<ContextControl> contextControl;
this.contextControl = BeanProvider.getDependent(ContextControl.class);
contextControl.get().startContext(scopeAnnotation);
this.contextControl.get().stopContext(this.scopes.pop());
this.contextControl.destroy();
ProxyClassGenerator proxyClassGenerator = ProxyClassGeneratorLookup.lookupService();
proxyClass = proxyClassGenerator.generateProxyClass(classLoader,
private final OrderBy orderByProcessor = new OrderBy();
addOrderBy(att, OrderDirection.ASC);
addOrderBy(att, OrderDirection.DESC);
orderByProcessor.process(query, builder, from);
private void addOrderBy(SingularAttribute<? super C, ?> att, OrderDirection orderDirection)
{
orderByProcessor.add(att, orderDirection);
}
import javax.persistence.criteria.Order;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
private final List<OrderByDefinition> orderByDefinitions = new ArrayList<OrderByDefinition>();
public void add(SingularAttribute<? super P, V> att, OrderDirection dir)
orderByDefinitions.add(new OrderByDefinition(att, dir));
List<Order> orders = new ArrayList<Order>();
Iterator<OrderByDefinition> iterator = orderByDefinitions.iterator();
while (iterator.hasNext())
OrderByDefinition orderByDefinition = iterator.next();
switch (orderByDefinition.getDir())
{
case ASC:
orders.add(builder.asc(path.get(orderByDefinition.getAtt())));
break;
default:
orders.add(builder.desc(path.get(orderByDefinition.getAtt())));
}
query.orderBy(orders);
private class OrderByDefinition
{
private final SingularAttribute<? super P, V> att;
private final OrderDirection dir;
public OrderByDefinition(SingularAttribute<? super P, V> att, OrderDirection dir)
{
this.att = att;
this.dir = dir;
}
public SingularAttribute<? super P, V> getAtt()
{
return att;
}
public OrderDirection getDir()
{
return dir;
}
@Override
public boolean equals(Object o)
{
if (this == o)
{
return true;
}
if (o == null || getClass() != o.getClass())
{
return false;
}
OrderByDefinition that = (OrderByDefinition) o;
if (att != null ? !att.equals(that.att) : that.att != null)
{
return false;
}
return dir == that.dir;
}
@Override
public int hashCode()
{
int result = att != null ? att.hashCode() : 0;
return result;
}
}
public List<Simple> findOrderByNameAndCounter() {
return criteria()
.orderDesc(Simple_.counter)
.orderAsc(Simple_.name)
.getResultList();
}
@Nonbinding boolean readOnly() default false;
import org.apache.deltaspike.core.api.provider.DependentProvider;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
@Inject
private BeanManager beanManager;
private transient TransactionConfig transactionConfig;
DependentProvider<UserTransactionResolver> provider =
BeanProvider.getDependent(this.beanManager, UserTransactionResolver.class);
UserTransaction userTransaction = provider.get().resolveUserTransaction();
provider.destroy();
return userTransaction;
import org.apache.deltaspike.core.util.ServiceUtils;
private static ProxyClassGenerator generator;
private static ProxyClassGenerator lookupService()
{
if (generator == null)
{
List<ProxyClassGenerator> proxyClassGeneratorList = ServiceUtils
.loadServiceImplementations(ProxyClassGenerator.class);
if (proxyClassGeneratorList.size() != 1)
{
throw new IllegalStateException(proxyClassGeneratorList.size()
" found. Expected exactly one implementation.");
}
generator = proxyClassGeneratorList.get(0);
}
return generator;
}
public void setGenerator(ProxyClassGenerator generator)
{
DeltaSpikeProxyFactory.generator = generator;
}
ProxyClassGenerator proxyClassGenerator = lookupService();
public static class GeneratorHolder
{
private static ProxyClassGenerator generator;
public void setGenerator(ProxyClassGenerator generator)
{
GeneratorHolder.generator = generator;
}
}
if (GeneratorHolder.generator == null)
GeneratorHolder.generator = proxyClassGeneratorList.get(0);
return GeneratorHolder.generator;
void attachAndRemove(E entity);
public void attachAndRemove(E entity)
{
if (!entityManager().contains(entity))
{
entity = entityManager().merge(entity);
}
remove(entity);
}
@Override
@RequiresTransaction
boolean useLikeOperator)
.addCriteria(new NamedPropertyCriteria(names.toArray(new String[]{}))).getResultList();
SingularAttribute<E, ?>... attributes)
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.JoinType;
import javax.persistence.metamodel.SingularAttribute;
QuerySelection<E, String> trim(SingularAttribute<? super E, String> attribute);
QuerySelection<E, String> trim(CriteriaBuilder.Trimspec trimspec, SingularAttribute<? super E, String> attribute);
import javax.persistence.criteria.CriteriaBuilder;
import org.apache.deltaspike.data.impl.criteria.selection.strings.Trim;
@Override
public QuerySelection<E, String> trim(SingularAttribute<? super E, String> attribute)
{
return new Trim<E>(attribute);
}
@Override
public QuerySelection<E, String> trim(CriteriaBuilder.Trimspec trimspec,
SingularAttribute<? super E, String> attribute)
{
return new Trim<E>(trimspec, attribute);
}
import javax.persistence.criteria.CriteriaBuilder;
criteria()
.eqIgnoreCase(Simple_.name, name)
.notEqIgnoreCase(Simple_.name, nameLike),
criteria()
.likeIgnoreCase(Simple_.name, nameLike)
.notLikeIgnoreCase(Simple_.name, name)
)
public List<Simple> findByTimeBetween(Date from, Date to)
{
.gt(Simple_.temporal, from)
.lt(Simple_.temporal, to)
.getResultList();
public Simple findBySuperName(String superName)
{
.eq(SuperSimple_.superName, superName)
.getSingleResult();
public List<Simple> findOrderByNameAndCounter()
{
return criteria()
.orderDesc(Simple_.counter)
.orderAsc(Simple_.name)
.getResultList();
}
public Object[] queryWithSelectAttributesAndTrim(String name)
{
return criteria()
.select(attribute(Simple_.name), trim(Simple_.name),
trim(CriteriaBuilder.Trimspec.LEADING, Simple_.name))
.eq(Simple_.name, name)
.createQuery()
.getSingleResult();
}
import org.apache.deltaspike.jsf.impl.util.JsfUtils;
JsfUtils.addStaticNavigationParameter(
this.navigationParameterContext, currentParameter.key(), currentParameter.value());
JsfUtils.addStaticNavigationParameter(
this.navigationParameterContext, viewParameter.key(), viewParameter.value());
public static void addStaticNavigationParameter(
NavigationParameterContext navigationParameterContext, String key, String value)
{
Map<String, String> existingParameters = navigationParameterContext.getPageParameters();
String existingValue = existingParameters.get(key);
{
return;
}
navigationParameterContext.addPageParameter(key, value);
}
import org.apache.deltaspike.data.impl.meta.RepositoryComponents;
private RepositoryComponents components = new RepositoryComponents();
components.add(repoClass);
public RepositoryComponents getComponents()
{
return components;
}
import javax.inject.Inject;
import org.apache.deltaspike.core.api.lifecycle.Initialized;
import org.apache.deltaspike.data.impl.RepositoryExtension;
@Inject
private RepositoryExtension extension;
return extension.getComponents();
protected abstract String tableName();
import java.util.Stack;
import org.apache.deltaspike.core.util.StringUtils;
import org.apache.deltaspike.data.api.EntityRepository;
import org.apache.deltaspike.data.impl.builder.QueryBuilder;
import org.apache.deltaspike.data.impl.meta.RequiresTransaction;
import org.apache.deltaspike.data.impl.meta.unit.PersistenceUnits;
import org.apache.deltaspike.data.impl.property.Property;
import org.apache.deltaspike.data.impl.property.query.NamedPropertyCriteria;
import org.apache.deltaspike.data.impl.property.query.PropertyQueries;
import org.apache.deltaspike.data.spi.DelegateQueryHandler;
import org.apache.deltaspike.data.spi.QueryInvocationContext;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.Table;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.metamodel.EntityType;
import javax.persistence.metamodel.SingularAttribute;
import static org.apache.deltaspike.data.impl.util.EntityUtils.entityName;
import static org.apache.deltaspike.data.impl.util.QueryUtils.isEmpty;
import static org.apache.deltaspike.data.impl.util.QueryUtils.isString;
public String tableName()
{
final Class<?> entityClass = context.getEntityClass();
final String tableName = PersistenceUnits.instance().entityTableName(entityClass);
if (StringUtils.isEmpty(tableName))
{
final EntityType<?> entityType = entityManager().getMetamodel().entity(entityClass);
Table tableAnnotation = entityClass.getAnnotation(Table.class);
return (tableAnnotation == null)
? entityType.getName()
: tableAnnotation.name();
}
return tableName;
}
import static org.apache.deltaspike.data.impl.util.QueryUtils.isEmpty;
protected final String tableName;
EntityDescriptor(String name, String packageName, String className, String idClass, String id, String tableName)
this.tableName = tableName;
public String getTableName()
{
return tableName;
}
.append(", tableName=").append(tableName)
return new MappingFile(Collections.<EntityDescriptor>emptyList(),
Collections.<MappedSuperclassDescriptor>emptyList());
protected EntityDescriptor instance(String name, String packageName, String className,
String idClass, String id, String tableName)
return new EntityDescriptor(name, packageName, className, idClass, id, tableName);
protected String tagName()
List<MappedSuperclassDescriptor> superClasses = new MappedSuperClassBuilder<MappedSuperclassDescriptor>()
protected MappedSuperclassDescriptor instance(String name, String packageName, String className,
String idClass, String id)
protected String tagName()
private abstract class PersistenceBuilder<T extends PersistentClassDescriptor>
protected List<T> result;
protected String packageName;
protected String name;
protected String className;
protected String idClass;
protected String id;
protected String embeddedId;
this.result = new LinkedList<T>();
this.packageName = extractNodeContent(doc.getDocumentElement(), "package");
this.name = extractAttribute(mappings.item(i), "name");
this.className = extractAttribute(mappings.item(i), "class");
this.idClass = extractNodeAttribute((Element) mappings.item(i), "id-class", "class");
this.id = extractNodeAttribute((Element) mappings.item(i), "id", "name");
this.embeddedId = extractNodeAttribute((Element) mappings.item(i), "embedded-id", "name");
addFields((Element) mappings.item(i));
addInResult();
return this.result;
protected abstract String tagName();
protected abstract void addInResult();
protected abstract void addFields(Element element);
}
private abstract class MappedSuperClassBuilder<T extends PersistentClassDescriptor> extends PersistenceBuilder
{
protected abstract T instance(String name, String packageName, String className, String idClass, String id);
protected abstract String tagName();
@Override
protected void addInResult()
{
result.add(instance(name, packageName, className, idClass, id != null ? id : embeddedId));
}
@Override
protected void addFields(Element element)
{
}
}
private abstract class EntityBuilder<T extends PersistentClassDescriptor> extends PersistenceBuilder
{
protected String tableName;
protected abstract T instance(String name, String packageName, String className, String idClass, String id,
String tableName);
protected abstract String tagName();
@Override
protected void addInResult()
{
result.add(instance(name, packageName, className, idClass, id != null ? id : embeddedId, tableName));
}
@Override
protected void addFields(Element element)
{
this.tableName = extractNodeAttribute(element, "table", "name");
}
public String entityTableName(Class<?> entityClass)
{
EntityDescriptor entity = find(entityClass);
if (entity != null)
{
return entity.getTableName();
}
return null;
}
protected abstract String entityName();
import org.apache.deltaspike.data.impl.util.EntityUtils;
public String entityName()
{
return EntityUtils.entityName(entityClass());
}
return QueryBuilder.selectQuery(entityName());
return QueryBuilder.countQuery(entityName());
public String getEntityName()
{
return entityName();
}
public String getEntityName()
{
return entityName();
}
int numArchives = 0;
String suffix = (numArchives == 0) ? "" : Integer.toString(numArchives);
= createArchive(foundFile, markerFile, includeIfPackageExists, excludeIfPackageExists,
return Collections.emptyList();
public SimpleStringId()
{
}
import java.lang.reflect.Method;
import javax.persistence.EntityManager;
import java.lang.reflect.Method;
import static org.apache.deltaspike.data.impl.util.QueryUtils.isNotEmpty;
return context.applyRestrictions(result);
return context.applyRestrictions(result);
import javax.persistence.Query;
import java.lang.reflect.Method;
import java.text.MessageFormat;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.Query;
import javax.persistence.QueryHint;
import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.List;
EntityManager entityManager)
this.args = args == null ? new Object[]{} : args;
public Query applyRestrictions(Query query)
{
Parameters params = getParams();
Method method = getMethod();
if (params.hasSizeRestriction())
{
query.setMaxResults(params.getSizeRestriciton());
}
if (params.hasFirstResult())
{
query.setFirstResult(params.getFirstResult());
}
if (hasLockMode(method))
{
query.setLockMode(extractLockMode(method));
}
if (hasQueryHints(method))
{
QueryHint[] hints = extractQueryHints(method);
for (QueryHint hint : hints)
{
query.setHint(hint.name(), hint.value());
}
}
query = applyJpaQueryPostProcessors(query);
return query;
}
private boolean hasLockMode(Method method)
{
return extractLockMode(method) != null;
}
private LockModeType extractLockMode(Method method)
{
Class<org.apache.deltaspike.data.api.Query> query = org.apache.deltaspike.data.api.Query.class;
if (method.isAnnotationPresent(query) &&
method.getAnnotation(query).lock() != LockModeType.NONE)
{
return method.getAnnotation(query).lock();
}
return null;
}
private QueryHint[] extractQueryHints(Method method)
{
Class<org.apache.deltaspike.data.api.Query> query = org.apache.deltaspike.data.api.Query.class;
if (method.isAnnotationPresent(query) &&
method.getAnnotation(query).hints().length > 0)
{
return method.getAnnotation(query).hints();
}
return null;
}
private boolean hasQueryHints(Method method)
{
return extractQueryHints(method) != null;
}
private CdiQueryInvocationContext context;
return context.applyRestrictions(entityManager().createQuery(allQuery(), entityClass())).getResultList();
return context.applyRestrictions(query).getResultList();
return (Long) context.applyRestrictions(entityManager().createQuery(countQuery(), Long.class))
.getSingleResult();
context.applyRestrictions(query);
context.applyRestrictions(query);
PK getPrimaryKey(E example);
import org.apache.deltaspike.data.impl.util.jpa.PersistenceUnitUtilDelegateFactory;
import javax.persistence.PersistenceUnitUtil;
public PK getPrimaryKey(E entity)
{
return (PK) persistenceUnitUtil().getIdentifier(entity);
}
@Override
private PersistenceUnitUtil persistenceUnitUtil()
{
return PersistenceUnitUtilDelegateFactory.get(entityManager());
}
import org.apache.deltaspike.data.impl.util.jpa.PersistenceUnitUtilDelegateFactory;
return PersistenceUnitUtilDelegateFactory.get(entityManager).getIdentifier(entity) == null;
import org.apache.deltaspike.data.impl.util.EntityUtils;
private final EntityManager entityManager;
this.entityManager = entityManager;
try
if (!entityManager.contains(entity))
entity = entityManager.getReference(entity.getClass(), EntityUtils.primaryKeyValue(entity));
}
final Object identifier = persistenceUnitUtil.getIdentifier(entity);
if (identifier != null)
{
final Method method;
}
catch (NoSuchMethodException e)
{
throw new RuntimeException(e);
}
catch (InvocationTargetException e)
{
throw new RuntimeException(e);
}
catch (IllegalAccessException e)
{
throw new RuntimeException(e);
}
catch (IllegalStateException e)
{
return null;
import org.apache.deltaspike.jsf.impl.scope.window.strategy.ClientSideWindowStrategy;
import org.apache.deltaspike.jsf.impl.scope.window.strategy.DelegatedWindowStrategy;
import org.apache.deltaspike.jsf.impl.scope.window.strategy.LazyWindowStrategy;
import org.apache.deltaspike.jsf.impl.scope.window.strategy.NoneWindowStrategy;
private ClientSideWindowStrategy clientSideWindowStrategy;
private DelegatedWindowStrategy delegatedWindowStrategy;
@Inject
private LazyWindowStrategy lazyWindowStrategy;
@Inject
private NoneWindowStrategy noneWindowStrategy;
return getClientWindow(facesContext).getWindowId(facesContext);
getClientWindow(facesContext).disableClientWindowRenderMode(facesContext);
getClientWindow(facesContext).enableClientWindowRenderMode(facesContext);
return getClientWindow(facesContext).isClientWindowRenderModeEnabled(facesContext);
return getClientWindow(facesContext).getQueryURLParameters(facesContext);
}
protected ClientWindow getClientWindow(FacesContext facesContext)
{
switch (clientWindowRenderMode)
case CLIENTWINDOW:
return clientSideWindowStrategy;
case CUSTOM:
return null;
case DELEGATED:
return delegatedWindowStrategy;
case LAZY:
return lazyWindowStrategy;
case NONE:
return noneWindowStrategy;
default:
return null;
package org.apache.deltaspike.jsf.impl.util;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.enterprise.inject.Typed;
import javax.faces.FacesException;
import javax.faces.context.ExternalContext;
import javax.faces.context.FacesContext;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletResponse;
import org.apache.deltaspike.jsf.api.config.base.JsfBaseConfig;
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
@Typed()
public abstract class ClientWindowHelper
{
private static final Logger LOG = Logger.getLogger(ClientWindowHelper.class.getName());
private static final String INITIAL_REDIRECT_WINDOW_ID = ClientWindowHelper.class.getName()
".INITIAL_REDIRECT_WINDOW_ID";
public abstract class RequestParameters
{
public static final String POST_WINDOW_ID = "dspwid";
public static final String JSF_POST_WINDOW_ID = "javax.faces.ClientWindow";
public static final String GET_WINDOW_ID = "dswid";
public static final String REQUEST_TOKEN = "dsrid";
}
public abstract class Cookies
{
public static final String REQUEST_WINDOW_ID_PREFIX = "dsrwid-";
public static final String WINDOW_ID_PREFIX = "dsWindowId-";
}
public static void handleInitialRedirect(FacesContext facesContext, String newWindowId)
{
facesContext.getAttributes().put(INITIAL_REDIRECT_WINDOW_ID, newWindowId);
ExternalContext externalContext = facesContext.getExternalContext();
String url = externalContext.getRequestContextPath()
externalContext.getRequestServletPath();
if (externalContext.getRequestPathInfo() != null)
{
}
url = JsfUtils.addRequestParameters(externalContext, url, true);
url = facesContext.getExternalContext().encodeResourceURL(url);
addRequestWindowIdCookie(facesContext, newWindowId);
try
{
externalContext.redirect(url);
}
catch (IOException e)
{
throw new FacesException("Could not send initial redirect!", e);
}
}
public static boolean isInitialRedirect(FacesContext facesContext)
{
return facesContext.getAttributes().containsKey(INITIAL_REDIRECT_WINDOW_ID);
}
public static String getInitialRedirectWindowId(FacesContext facesContext)
{
return (String) facesContext.getAttributes().get(INITIAL_REDIRECT_WINDOW_ID);
}
public static String appendWindowId(FacesContext facesContext, String url, ClientWindow clientWindow)
{
if (clientWindow != null && clientWindow.isClientWindowRenderModeEnabled(facesContext))
{
Map<String, String> parameters = clientWindow.getQueryURLParameters(facesContext);
if (parameters != null && !parameters.isEmpty())
{
String targetUrl = url;
for (Entry<String, String> entry : parameters.entrySet())
{
targetUrl = JsfUtils.addParameter(facesContext.getExternalContext(),
targetUrl,
true,
entry.getKey(),
entry.getValue());
if (targetUrl.contains(emptyParameter))
{
targetUrl = targetUrl.replace(emptyParameter, "");
}
}
return targetUrl;
}
}
return url;
}
public static void addRequestWindowIdCookie(FacesContext context, String windowId)
{
Map<String, Object> properties = new HashMap();
properties.put("path", "/");
properties.put("maxAge", 30);
context.getExternalContext().addResponseCookie(
}
public static Object getRequestWindowIdCookie(FacesContext context, String windowId)
{
Map<String, Object> cookieMap = context.getExternalContext().getRequestCookieMap();
{
}
return null;
}
public static void removeRequestWindowIdCookie(FacesContext context, Cookie cookie)
{
cookie.setMaxAge(0);
((HttpServletResponse) context.getExternalContext().getResponse()).addCookie(cookie);
}
public static int getMaxWindowIdLength()
{
int result = JsfBaseConfig.ScopeCustomization.WindowRestriction.ID_MAX_LENGTH;
if (result > JsfBaseConfig.ScopeCustomization.WindowRestriction.ID_MAX_LENGTH_DEFAULT)
{
if (LOG.isLoggable(Level.WARNING))
{
LOG.warning("ATTENTION: if you change this value to be significant longer than 10, "
"you can introduce a security issue in WindowIdHtmlRenderer. "
"If you increase it because window.name contains a value already, "
"please revisit that usage or "
"create shorter unique ids since they just need to be unique within the user-session.");
}
}
return result;
}
}
import javax.servlet.http.HttpServletResponse;
servletCookie.setMaxAge(0);
((HttpServletResponse) context.getExternalContext().getResponse()).addCookie(servletCookie);
if (windowId != null)
if (windowId.length() > this.maxWindowIdCount)
{
windowId = windowId.substring(0, this.maxWindowIdCount);
}
protected String getWindowIdPostParameter(FacesContext facesContext)
protected String getWindowIdParameter(FacesContext facesContext)
{
Map<String, String> requestParameters = facesContext.getExternalContext().getRequestParameterMap();
return requestParameters.get(ClientWindowHelper.RequestParameters.GET_WINDOW_ID);
}
windowId = getWindowIdPostParameter(facesContext);
String cookieName =
protected String getRequestTokenParameter(ExternalContext externalContext)
windowId = getWindowIdParameter(facesContext);
windowId = getWindowIdPostParameter(facesContext);
addRequestWindowIdCookie(facesContext, newWindowId, newWindowId);
public static void addRequestWindowIdCookie(FacesContext context, String requestToken, String windowId)
public static Object getRequestWindowIdCookie(FacesContext context, String requestToken)
boolean isInitialRedirectSupported(FacesContext facesContext);
import org.apache.deltaspike.jsf.spi.scope.window.ClientWindow;
private volatile ClientWindow clientWindow;
lazyInit();
String windowId = clientWindow.getWindowId(context);
String clientWindowRenderMode = clientWindowConfig.getClientWindowRenderMode(context).name();
if (clientWindow.isInitialRedirectSupported(context))
Object cookie = ClientWindowHelper.getRequestWindowIdCookie(context, windowId);
if (cookie != null && cookie instanceof Cookie)
{
Cookie servletCookie = (Cookie) cookie;
servletCookie.setMaxAge(0);
((HttpServletResponse) context.getExternalContext().getResponse()).addCookie(servletCookie);
}
private void lazyInit()
if (clientWindow == null)
if (clientWindow == null)
clientWindowConfig = BeanProvider.getContextualReference(ClientWindowConfig.class);
clientWindow = BeanProvider.getContextualReference(ClientWindow.class);
@Override
public boolean isInitialRedirectSupported(FacesContext facesContext)
{
return getClientWindow(facesContext).isInitialRedirectSupported(facesContext);
}
public boolean isInitialRedirectSupported(FacesContext facesContext)
{
return false;
}
@Override
@Override
protected boolean isSupportClientWindowRenderingMode()
{
return true;
}
@Override
public boolean isInitialRedirectSupported(FacesContext facesContext)
{
return true;
}
@Override
public boolean isClientWindowRenderModeEnabled(FacesContext facesContext)
{
return facesContext.getExternalContext().getClientWindow().isClientWindowRenderModeEnabled(facesContext);
}
private volatile Boolean initialized;
private boolean delegatedWindowHandlingEnabled;
private boolean jsf22Available;
lazyInit();
public boolean isJsf22Available()
lazyInit();
return this.jsf22Available;
}
public boolean isDelegatedWindowHandlingEnabled()
{
lazyInit();
return this.delegatedWindowHandlingEnabled;
}
private void lazyInit()
{
if (this.initialized == null)
init();
}
protected synchronized void init()
{
if (this.initialized == null)
this.jsf22Available = ClassUtils.tryToLoadClassForName(CLIENT_WINDOW_CLASS_NAME) != null;
if (!this.jsf22Available)
{
this.delegatedWindowHandlingEnabled = false;
}
else
{
FacesContext facesContext = FacesContext.getCurrentInstance();
if (facesContext == null)
{
this.delegatedWindowHandlingEnabled = false;
}
else
{
String initParam = facesContext.getExternalContext().getInitParameter(CLIENT_WINDOW_CONFIG_KEY);
this.delegatedWindowHandlingEnabled =
!(initParam == null || "none".equalsIgnoreCase(initParam.trim()));
}
}
this.initialized = true;
}
import org.apache.deltaspike.jsf.api.config.JsfModuleConfig;
import org.apache.deltaspike.jsf.impl.scope.window.ClientWindowAdapter;
private volatile Boolean initialized;
private ClientWindow clientWindow;
private JsfModuleConfig jsfModuleConfig;
lazyInit();
boolean clientWindowRenderModeEnabled = clientWindow.isClientWindowRenderModeEnabled(context);
if (jsfModuleConfig.isJsf22Available())
{
Boolean jsfClientWindowRenderModeEnabled =
ClientWindowAdapter.isJsf22ClientWindowRenderModeEnabled(context);
if (jsfClientWindowRenderModeEnabled != null)
{
clientWindowRenderModeEnabled = clientWindowRenderModeEnabled || jsfClientWindowRenderModeEnabled;
}
}
clientWindow.disableClientWindowRenderMode(context);
clientWindow.enableClientWindowRenderMode(context);
private void lazyInit()
if (this.initialized == null)
init();
}
protected synchronized void init()
{
if (this.initialized == null)
{
clientWindow = BeanProvider.getContextualReference(ClientWindow.class);
jsfModuleConfig = BeanProvider.getContextualReference(JsfModuleConfig.class);
}
facesContext.getExternalContext().setClientWindow(
new ClientWindowAdapter(clientWindow, delegateWindowHandling));
private final boolean delegateWindowHandling;
public ClientWindowAdapter(org.apache.deltaspike.jsf.spi.scope.window.ClientWindow window,
boolean delegateWindowHandling)
this.delegateWindowHandling = delegateWindowHandling;
public static Boolean isJsf22ClientWindowRenderModeEnabled(FacesContext context)
ClientWindow clientWindow = context.getExternalContext().getClientWindow();
if (clientWindow instanceof ClientWindowAdapter)
{
ClientWindowAdapter clientWindowAdapter = (ClientWindowAdapter) clientWindow;
return clientWindowAdapter.isOriginalClientWindowRenderModeEnabled(context);
}
else
{
return clientWindow.isClientWindowRenderModeEnabled(context);
}
@Override
public boolean isClientWindowRenderModeEnabled(FacesContext context)
{
if (!delegateWindowHandling)
{
return false;
}
return super.isClientWindowRenderModeEnabled(context);
}
protected boolean isOriginalClientWindowRenderModeEnabled(FacesContext context)
{
return super.isClientWindowRenderModeEnabled(context);
}
import org.apache.deltaspike.jsf.impl.scope.window.ClientWindowAdapter;
if (jsfModuleConfig.isJsf22Available())
{
if (facesContext.getExternalContext().getClientWindow() != null)
{
facesContext.getExternalContext().getClientWindow().disableClientWindowRenderMode(facesContext);
}
}
if (jsfModuleConfig.isJsf22Available())
{
if (facesContext.getExternalContext().getClientWindow() != null)
{
facesContext.getExternalContext().getClientWindow().enableClientWindowRenderMode(facesContext);
}
}
if (jsfModuleConfig.isJsf22Available())
{
if (ClientWindowAdapter.isJsf22ClientWindowRenderModeEnabled(facesContext) == false)
{
return false;
}
}
if (facesContext.getExternalContext().getClientWindow() != null)
{
return facesContext.getExternalContext().getClientWindow().getId();
}
return null;
boolean dsClientWindowRenderModeEnabled = clientWindow.isClientWindowRenderModeEnabled(context);
boolean jsfClientWindowRenderModeEnabled = false;
if (context.getExternalContext().getClientWindow() != null)
jsfClientWindowRenderModeEnabled =
context.getExternalContext().getClientWindow().isClientWindowRenderModeEnabled(context);
if (dsClientWindowRenderModeEnabled)
if (jsfClientWindowRenderModeEnabled)
{
context.getExternalContext().getClientWindow().disableClientWindowRenderMode(context);
}
if (dsClientWindowRenderModeEnabled)
if (jsfClientWindowRenderModeEnabled)
{
context.getExternalContext().getClientWindow().enableClientWindowRenderMode(context);
}
import javax.faces.FacesException;
@Override
lazyInit();
facesContext.getExternalContext().setClientWindow(new ClientWindowAdapter(clientWindow));
@Override
public void render(FacesContext context) throws FacesException
{
lazyInit();
if (!delegateWindowHandling && context.getExternalContext().getClientWindow() != null)
{
context.getExternalContext().getClientWindow().disableClientWindowRenderMode(context);
}
super.render(context);
}
if (this.initialized == null)
this.delegateWindowHandling = ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(
this.initialized = true;
public ClientWindowAdapter(org.apache.deltaspike.jsf.spi.scope.window.ClientWindow window)
private ClientWindowConfig clientWindowConfig;
boolean delegateWindowHandling = ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(
clientWindowConfig.getClientWindowRenderMode(facesContext));
if (delegateWindowHandling)
public void render(FacesContext facesContext) throws FacesException
boolean delegateWindowHandling = ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(
clientWindowConfig.getClientWindowRenderMode(facesContext));
if (!delegateWindowHandling && facesContext.getExternalContext().getClientWindow() != null)
facesContext.getExternalContext().getClientWindow().disableClientWindowRenderMode(facesContext);
super.render(facesContext);
this.clientWindowConfig = BeanProvider.getContextualReference(ClientWindowConfig.class);
import org.apache.deltaspike.data.impl.util.EntityUtils;
if (EntityUtils.primaryKeyValue(entity) == null)
{
return true;
}
if (!entityManager.contains(entity) && countCheck(entity))
{
return true;
}
return false;
private boolean countCheck(Object entity)
{
sql.append("WHERE e.");
sql.append(EntityUtils.primaryKey(getEntityClass()).getName());
final Query query = entityManager.createQuery(sql.toString());
final Long result = (Long) query.getSingleResult();
if (Long.valueOf(0).equals(result))
{
return true;
}
return false;
}
public static Property<Serializable> primaryKey(Class<?> entityClass)
@CustomInterceptorStereotype
public void doSomething2()
{
String a = "test2";
}
this.proxyClass = proxyFactory.getProxyClass(beanManager, targetClass, delegateInvocationHandlerClass);
import javax.enterprise.inject.spi.BeanManager;
public <T> Class<T> getProxyClass(BeanManager beanManager, Class<T> targetClass,
proxyClass = createProxyClass(beanManager, targetClass.getClassLoader(), targetClass,
delegateInvocationHandlerClass);
private synchronized <T> Class<T> createProxyClass(BeanManager beanManager, ClassLoader classLoader,
Class<T> targetClass, Class<? extends InvocationHandler> delegateInvocationHandlerClass)
&& !containsInterceptorBinding(beanManager, targetClass.getDeclaredAnnotations()))
if (!containsInterceptorBinding(beanManager, method.getDeclaredAnnotations()))
protected boolean containsInterceptorBinding(BeanManager beanManager, Annotation[] annotations)
{
Class<? extends Annotation> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(InterceptorBinding.class))
if (beanManager.isStereotype(annotationType))
{
boolean containsInterceptorBinding = containsInterceptorBinding(
beanManager,
annotationType.getDeclaredAnnotations());
if (containsInterceptorBinding)
{
return true;
}
}
BeanManager beanManager = BeanManagerProvider.getInstance().getBeanManager();
Annotation[] interceptorBindings = extractInterceptorBindings(beanManager, instance, method);
protected Annotation[] extractInterceptorBindings(BeanManager beanManager, Object instance, Method method)
addInterceptorBindings(beanManager, bindings, instance.getClass().getDeclaredAnnotations());
addInterceptorBindings(beanManager, bindings, method.getDeclaredAnnotations());
protected void addInterceptorBindings(BeanManager beanManager, ArrayList<Annotation> bindings,
Annotation[] declaredAnnotations)
{
for (Annotation annotation : declaredAnnotations)
{
if (bindings.contains(annotation))
{
continue;
}
Class<? extends Annotation> annotationType = annotation.annotationType();
if (annotationType.isAnnotationPresent(InterceptorBinding.class))
{
bindings.add(annotation);
}
if (beanManager.isStereotype(annotationType))
{
for (Annotation subAnnotation : annotationType.getDeclaredAnnotations())
{
if (bindings.contains(subAnnotation))
{
continue;
}
if (subAnnotation.annotationType().isAnnotationPresent(InterceptorBinding.class))
{
bindings.add(subAnnotation);
}
}
}
}
}
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
public class RequestResponseHolderListener implements ServletRequestListener, Deactivatable
private final boolean activated;
public RequestResponseHolderListener()
{
this.activated = ClassDeactivationUtils.isActivated(this.getClass());
}
if (activated)
{
RequestResponseHolder.REQUEST.bind(sre.getServletRequest());
}
if (activated)
{
RequestResponseHolder.REQUEST.release();
}
if (!RequestResponseHolder.REQUEST.isBound())
{
RequestResponseHolder.REQUEST.bind(sre.getServletRequest());
}
writer.write(");");
writer.write("(function(){");
writer.write("})();");
boolean isClientWindowStoreWindowTreeEnabled();
@Override
public boolean isClientWindowStoreWindowTreeEnabled()
{
return true;
}
writer.write("});");
@Override
public boolean isClientWindowRenderModeEnabled(FacesContext context)
{
return false;
}
ClientWindowConfig.ClientWindowRenderMode clientWindowRenderMode =
clientWindowConfig.getClientWindowRenderMode(context);
if (!ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))
if (windowId != null && windowId.length() > this.maxWindowIdCount)
{
windowId = windowId.substring(0, this.maxWindowIdCount);
}
ClientWindowConfig.ClientWindowRenderMode clientWindowRenderMode =
clientWindowConfig.getClientWindowRenderMode(facesContext);
if (!ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))
if (windowId.length() > this.maxWindowIdCount)
{
windowId = windowId.substring(0, this.maxWindowIdCount);
}
boolean delegatedWindowMode =
ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode);
if (!delegatedWindowMode)
windowId = secureWindowId(windowId);
if (!delegatedWindowMode && clientWindow.isInitialRedirectSupported(context))
protected String secureWindowId(String windowId)
{
if (windowId != null && windowId.length() > this.maxWindowIdCount)
{
windowId = windowId.substring(0, this.maxWindowIdCount);
}
return windowId;
}
if (encodeValues)
{
finalUrl.append(JsfUtils.encodeURLParameterValue(key, externalContext));
}
else
{
finalUrl.append(key);
}
if (encodeValues)
{
finalUrl.append(JsfUtils.encodeURLParameterValue(name, externalContext));
}
else
{
finalUrl.append(name);
}
if (encodeValues)
{
finalUrl.append(JsfUtils.encodeURLParameterValue(entry.getKey(), externalContext));
}
else
{
finalUrl.append(entry.getKey());
}
appendUrlParameter(finalUrl, key, parameterValue, encodeValues, externalContext);
appendUrlParameter(finalUrl, name, value, encodeValues, externalContext);
appendUrlParameter(finalUrl, entry.getKey(), value, encodeValues, externalContext);
protected static void appendUrlParameter(StringBuilder url, String name, String value, boolean encode, ExternalContext externalContext)
{
if (encode)
{
url.append(encodeURLParameterValue(name, externalContext));
}
else
{
url.append(name);
}
url.append("=");
if (encode)
{
url.append(encodeURLParameterValue(value, externalContext));
}
else
{
url.append(value);
}
}
protected static void appendUrlParameter(StringBuilder url, String name, String value, boolean encode,
ExternalContext externalContext)
boolean isClientWindowStoreWindowTreeEnabled();
boolean isClientWindowTokenizedRedirectEnabled();
@Override
public boolean isClientWindowTokenizedRedirectEnabled()
{
return false;
}
jpql.append("WHERE e.");
jpql.append(EntityUtils.primaryKey(getEntityClass()).getName());
jpql.append(" = :id");
final Query query = entityManager.createQuery(jpql.toString());
query.setParameter("id", EntityUtils.primaryKeyValue(entity));
import javax.enterprise.inject.Stereotype;
@Stereotype
import javax.enterprise.inject.Typed;
@Typed()
@Typed()
@Typed()
@Typed()
@Typed()
@Typed()
import javax.enterprise.inject.Typed;
@Typed()
import javax.enterprise.inject.Stereotype;
@Stereotype
import org.apache.deltaspike.jsf.util.ValueExpressionEvaluationInputStream;
is = new ValueExpressionEvaluationInputStream(FacesContext.getCurrentInstance(), is);
interface Validation
{
ViolationMode VIOLATION_MODE =
ConfigResolver.resolve("deltaspike.validation.violation-mode")
.as(ViolationMode.class, new ConfigResolver.Converter<ViolationMode>()
{
@Override
public ViolationMode convert(String value)
{
return ViolationMode.valueOf(value);
}
})
.withCurrentProjectStage(true)
.withDefault(ViolationMode.FAIL)
.getValue();
enum ViolationMode
{
IGNORE, WARN, FAIL
}
}
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
if (!ServiceUtils.loadServiceImplementations(ClassDeactivator.class).isEmpty())
{
CoreBaseConfig.Validation.ViolationMode violationMode = CoreBaseConfig.Validation.VIOLATION_MODE;
" via the std. service-loader config. "
"Please configure it via the DeltaSpike-Config (e.g. META-INF/apache-deltaspike.properties).";
if (violationMode == CoreBaseConfig.Validation.ViolationMode.FAIL)
{
throw new IllegalStateException(message);
}
else if (violationMode == CoreBaseConfig.Validation.ViolationMode.WARN)
{
LOG.warning(message);
}
}
import java.io.IOException;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
List<EntityDescriptor> entities = extractMappings((Element) node, baseUrl, unitName);
private List<EntityDescriptor> extractMappings(Element element, String baseUrl, String unitName)
readMappingFiles(baseUrl, unitName, reader, entities, superClasses, list);
private void readMappingFiles(String baseUrl, String unitName, EntityDescriptorReader reader,
List<EntityDescriptor> entities, List<MappedSuperclassDescriptor> superClasses,
NodeList list)
{
{
String resource = list.item(i).getTextContent();
try
{
MappingFile mappings = reader.readAll(baseUrl, resource);
entities.addAll(mappings.getEntities());
superClasses.addAll(mappings.getSuperClasses());
}
catch (Exception e)
{
}
}
}
import javax.enterprise.inject.Stereotype;
@Stereotype
import javax.enterprise.inject.Stereotype;
@Stereotype
writer.write("<script type=\"text/javascript\">");
writer.write("</script>");
private DependentProvider<? extends EntityManagerResolver> dependentResolverProvider;
dependentResolverProvider = resolver;
public void release()
{
if (dependentResolverProvider != null)
{
dependentResolverProvider.destroy();
}
}
entityManagerLookup.release();
boolean isClientWindowStoreWindowTreeEnabledOnLinkClick();
boolean isClientWindowStoreWindowTreeEnabledOnAjaxRequest();
boolean isClientWindowStoreWindowTreeEnabledOnButtonClick();
public boolean isClientWindowStoreWindowTreeEnabledOnLinkClick()
@Override
public boolean isClientWindowStoreWindowTreeEnabledOnAjaxRequest()
{
return false;
}
@Override
public boolean isClientWindowStoreWindowTreeEnabledOnButtonClick()
{
return false;
}
writer.write(",'storeWindowTreeOnLinkClick':"
clientWindowConfig.isClientWindowStoreWindowTreeEnabledOnLinkClick());
writer.write(",'storeWindowTreeOnButtonClick':"
clientWindowConfig.isClientWindowStoreWindowTreeEnabledOnButtonClick());
writer.write(",'storeWindowTreeOnAjaxRequest':"
clientWindowConfig.isClientWindowStoreWindowTreeEnabledOnAjaxRequest());
import org.apache.deltaspike.jpa.api.config.base.JpaBaseConfig;
return JpaBaseConfig.UserTransaction.TIMEOUT_IN_SECONDS;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.api.provider.DependentProvider;
import org.apache.deltaspike.jpa.api.config.base.JpaBaseConfig;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
@Inject
private BeanManager beanManager;
UserTransaction userTransaction;
try
{
DependentProvider<ManagedUserTransactionResolver> provider =
BeanProvider.getDependent(this.beanManager, ManagedUserTransactionResolver.class);
userTransaction = provider.get().resolveUserTransaction();
provider.destroy();
}
catch (Throwable t)
{
userTransaction = null;
}
String jndiName = JpaBaseConfig.UserTransaction.JNDI_NAME;
String[] jndiNames = jndiName.split(",");
for (String currentJndiName : jndiNames)
try
{
userTransaction = JndiUtils.lookup(currentJndiName, UserTransaction.class);
if (userTransaction != null)
{
break;
}
}
catch (Exception e)
{
userTransaction = null;
}
return userTransaction;
import org.apache.deltaspike.core.util.ExceptionUtils;
catch (Exception e)
throw ExceptionUtils.throwAsRuntimeException(e);
@Override
import org.apache.deltaspike.data.impl.property.Property;
import java.io.Serializable;
Property<Serializable> versionProperty = EntityUtils.getVersionProperty(entity);
if (versionProperty != null)
{
return versionProperty.getValue(entity) == null;
}
EntityDescriptor(String name, String packageName, String className, String idClass, String id,
String version, String tableName)
super(name, packageName, className, idClass, id, version);
String idClass, String id, String version, String tableName)
return new EntityDescriptor(name, packageName, className, idClass, id, version, tableName);
String idClass, String id, String version)
return new MappedSuperclassDescriptor(name, packageName, className, idClass, id, version);
protected String version;
this.version = extractNodeAttribute((Element) mappings.item(i), "version", "name");
protected abstract T instance(String name, String packageName, String className, String idClass, String id,
String version);
result.add(instance(name, packageName, className, idClass, id != null ? id : embeddedId, version));
String version, String tableName);
result.add(instance(name, packageName, className, idClass, id != null ? id : embeddedId,
version, tableName));
MappedSuperclassDescriptor(String name, String packageName, String className, String idClass, String id,
String version)
super(name, packageName, className, idClass, id, version);
public String versionField(Class<?> entityClass)
{
EntityDescriptor entity = find(entityClass);
if (entity != null)
{
return entity.getVersion();
}
return null;
}
protected final String version;
PersistentClassDescriptor(String name, String packageName, String className, String idClass, String id,
String version)
this.version = version;
public String getVersion()
{
return version;
}
import javax.persistence.Version;
public static Property<Serializable> getVersionProperty(Object entity)
{
Class<?> entityClass = entity.getClass();
List<PropertyCriteria> criteriaList = new LinkedList<PropertyCriteria>();
criteriaList.add(new AnnotatedPropertyCriteria(Version.class));
String fromMappingFiles = PersistenceUnits.instance().versionField(entityClass);
if (fromMappingFiles != null)
{
criteriaList.add(new NamedPropertyCriteria(fromMappingFiles));
}
for (PropertyCriteria criteria : criteriaList)
{
PropertyQuery<Serializable> query =
PropertyQueries.<Serializable> createQuery(entityClass).addCriteria(criteria);
Property<Serializable> result = query.getFirstResult();
if (result != null)
{
return result;
}
}
return null;
}
import java.util.Collections;
Collections.addAll(this.types, type.getJavaClass().getInterfaces());
this.types.add(Object.class);
import java.lang.reflect.Method;
import org.apache.deltaspike.core.util.ReflectionUtils;
private static final String RELEASE_INSTANCE_METHOD_NAME = "releaseInstance";
private static Boolean releaseInstanceMethodFound;
private static Method releaseInstanceMethod;
T resolvedInst = BeanProvider.getContextualReference(validatorClass, true);
public void releaseInstance(ConstraintValidator<?, ?> constraintValidator)
{
if (releaseInstanceMethodFound == null)
{
lazyInit();
}
if (Boolean.TRUE.equals(releaseInstanceMethodFound))
{
ReflectionUtils.invokeMethod(this.delegate, releaseInstanceMethod, Void.class, true, constraintValidator);
}
}
private synchronized void lazyInit()
{
if (releaseInstanceMethodFound != null)
{
return;
}
Class<?> currentClass = delegate.getClass();
while (currentClass != null && !Object.class.getName().equals(currentClass.getName()))
{
for (Method currentMethod : currentClass.getDeclaredMethods())
{
if (RELEASE_INSTANCE_METHOD_NAME.equals(currentMethod.getName()) &&
currentMethod.getParameterTypes().length == 1 &&
currentMethod.getParameterTypes()[0].equals(ConstraintValidator.class))
{
releaseInstanceMethod = currentMethod;
releaseInstanceMethodFound = true;
return;
}
}
currentClass = currentClass.getSuperclass();
}
releaseInstanceMethodFound = false;
}
result = params.applyTo(entityManager.createNativeQuery(jpqlQuery, context.getEntityClass()));
if (invocationHandlerProvider != null)
{
invocationHandlerProvider.destroy();
}
"org.apache.deltaspike.scheduler",
"org.quartz"},
"org.apache.deltaspike.scheduler"},
import org.apache.deltaspike.core.api.projectstage.ProjectStage;
import org.apache.deltaspike.core.util.activation.BaseClassDeactivationController;
import org.apache.deltaspike.core.util.activation.CachingClassDeactivationController;
import org.apache.deltaspike.core.util.activation.NonCachingClassDeactivationController;
import java.util.Arrays;
private static final List<ProjectStage> NON_CACHING_PROJECT_STAGES =
Arrays.asList(ProjectStage.Development,ProjectStage.UnitTest);
private static BaseClassDeactivationController classDeactivationController = null;
return getController().isActivated(targetClass);
private static BaseClassDeactivationController getController()
if (classDeactivationController == null)
classDeactivationController = calculateControllerToUse();
return classDeactivationController;
private static BaseClassDeactivationController calculateControllerToUse()
ProjectStage currentProjectStage = ProjectStageProducer.getInstance().getProjectStage();
if (NON_CACHING_PROJECT_STAGES.contains(currentProjectStage))
return new NonCachingClassDeactivationController();
else
return new CachingClassDeactivationController();
if (this.contextControl != null)
{
this.contextControl.destroy();
}
if (this.contextControl == null)
{
return;
}
this.contextControl.destroy();
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
import org.apache.deltaspike.core.spi.activation.ClassDeactivator;
import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;
private static final Logger LOG = Logger.getLogger(ClassDeactivationUtils.class.getName());
private static Map<ClassLoader, List<ClassDeactivator>> classDeactivatorMap
= new ConcurrentHashMap<ClassLoader, List<ClassDeactivator>>();
private static Map<Class<? extends Deactivatable>, Boolean> activationStatusCache
= new ConcurrentHashMap<Class<? extends Deactivatable>, Boolean>();
Boolean activatedClassCacheEntry = activationStatusCache.get(targetClass);
if (activatedClassCacheEntry == null)
{
initDeactivatableCacheFor(targetClass);
activatedClassCacheEntry = activationStatusCache.get(targetClass);
}
return activatedClassCacheEntry;
private static synchronized void initDeactivatableCacheFor(Class<? extends Deactivatable> targetClass)
Boolean activatedClassCacheEntry = activationStatusCache.get(targetClass);
return;
List<ClassDeactivator> classDeactivators = getClassDeactivators();
Boolean isActivated = Boolean.TRUE;
Class<? extends ClassDeactivator> deactivatedBy = null;
for (ClassDeactivator classDeactivator : classDeactivators)
{
Boolean isLocallyActivated = classDeactivator.isActivated(targetClass);
if (isLocallyActivated != null)
{
isActivated = isLocallyActivated;
if (!isActivated)
{
deactivatedBy = classDeactivator.getClass();
}
else if (deactivatedBy != null)
{
classDeactivator.getClass().getName()
"If that isn't the intended behaviour, you have to use a higher ordinal for "
deactivatedBy.getName());
}
}
}
cacheResult(targetClass, isActivated);
private static void cacheResult(Class<? extends Deactivatable> targetClass, Boolean activated)
activationStatusCache.put(targetClass, activated);
}
private static List<ClassDeactivator> getClassDeactivators()
{
ClassLoader classLoader = ClassUtils.getClassLoader(null);
List<ClassDeactivator> classDeactivators = classDeactivatorMap.get(classLoader);
if (classDeactivators == null)
return initConfiguredClassDeactivators(classLoader);
return classDeactivators;
}
private static List<ClassDeactivator> initConfiguredClassDeactivators(ClassLoader classLoader)
{
if (!ServiceUtils.loadServiceImplementations(ClassDeactivator.class).isEmpty())
CoreBaseConfig.Validation.ViolationMode violationMode = CoreBaseConfig.Validation.VIOLATION_MODE;
" via the std. service-loader config. "
"Please configure it via the DeltaSpike-Config (e.g. META-INF/apache-deltaspike.properties).";
if (violationMode == CoreBaseConfig.Validation.ViolationMode.FAIL)
{
throw new IllegalStateException(message);
}
else if (violationMode == CoreBaseConfig.Validation.ViolationMode.WARN)
{
LOG.warning(message);
}
List<String> classDeactivatorClassNames = ConfigResolver.getAllPropertyValues(ClassDeactivator.class.getName());
List<ClassDeactivator> classDeactivators = new ArrayList<ClassDeactivator>();
for (String classDeactivatorClassName : classDeactivatorClassNames)
{
try
{
ClassDeactivator currentClassDeactivator =
(ClassDeactivator) ClassUtils.instantiateClassForName(classDeactivatorClassName);
classDeactivators.add(currentClassDeactivator);
}
catch (Exception e)
{
throw new IllegalStateException(e);
}
}
classDeactivatorMap.put(classLoader, classDeactivators);
return classDeactivators;
import org.apache.deltaspike.core.api.projectstage.ProjectStage;
private static ProjectStage previouslyDetectedProjectStage;
performProjectStageDependentCleanup();
Map<Class<? extends Deactivatable>, Boolean> activeCache = activationStatusCache;
Boolean activatedClassCacheEntry = activeCache.get(targetClass);
initDeactivatableCacheFor(targetClass, activeCache);
activatedClassCacheEntry = activeCache.get(targetClass);
private static void performProjectStageDependentCleanup()
ProjectStage currentProjectStage = ProjectStageProducer.getInstance().getProjectStage();
if (previouslyDetectedProjectStage != currentProjectStage)
{
previouslyDetectedProjectStage = currentProjectStage;
activationStatusCache = new ConcurrentHashMap<Class<? extends Deactivatable>, Boolean>();
classDeactivatorMap.clear();
}
else if (currentProjectStage == ProjectStage.UnitTest || currentProjectStage == ProjectStage.Development)
{
activationStatusCache = new ConcurrentHashMap<Class<? extends Deactivatable>, Boolean>();
}
}
private static synchronized void initDeactivatableCacheFor(Class<? extends Deactivatable> targetClass,
Map<Class<? extends Deactivatable>, Boolean> activeCache)
{
Boolean activatedClassCacheEntry = activeCache.get(targetClass);
cacheResult(targetClass, isActivated, activeCache);
private static void cacheResult(Class<? extends Deactivatable> targetClass, Boolean activated,
Map<Class<? extends Deactivatable>, Boolean> activeCache)
activeCache.put(targetClass, activated);
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import javax.enterprise.context.Dependent;
import javax.enterprise.inject.Produces;
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
import org.apache.deltaspike.core.util.AnnotationUtils;
import org.apache.deltaspike.core.util.BeanUtils;
List<Bean> partialProducerBeans =
createPartialProducersDefinedIn(partialBean, afterBeanDiscovery, beanManager);
for (Bean partialProducerBean : partialProducerBeans)
{
afterBeanDiscovery.addBean(partialProducerBean);
}
protected List<Bean> createPartialProducersDefinedIn(
Bean partialBean, AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager)
{
Class currentClass = partialBean.getBeanClass();
return createPartialProducersDefinedIn(partialBean, afterBeanDiscovery, beanManager, currentClass);
}
private List<Bean> createPartialProducersDefinedIn(
Bean partialBean, AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager, Class currentClass)
{
List<Bean> result = new ArrayList<Bean>();
while (currentClass != null && !Object.class.getName().equals(currentClass.getName()))
{
for (Class interfaceClass : currentClass.getInterfaces())
{
if (interfaceClass.getName().startsWith("java.") || interfaceClass.getName().startsWith("javax."))
{
continue;
}
result.addAll(
createPartialProducersDefinedIn(partialBean, afterBeanDiscovery, beanManager, interfaceClass));
}
for (Method currentMethod : currentClass.getDeclaredMethods())
{
if (currentMethod.isAnnotationPresent(Produces.class))
{
if (currentMethod.getParameterTypes().length > 0)
{
afterBeanDiscovery.addDefinitionError(
new IllegalStateException(
"Producer-methods in partial-beans currently don't support injection-points. "
"Please remove the parameters from "
}
DeltaSpikePartialProducerLifecycle lifecycle =
new DeltaSpikePartialProducerLifecycle(partialBean.getBeanClass(), currentMethod);
Class<? extends Annotation> scopeClass =
extractScope(currentMethod.getDeclaredAnnotations(), beanManager);
Class<?> producerResultType = currentMethod.getReturnType();
boolean passivationCapable =
Serializable.class.isAssignableFrom(producerResultType) || producerResultType.isPrimitive();
Set<Annotation> qualifiers = extractQualifiers(currentMethod.getDeclaredAnnotations(), beanManager);
BeanBuilder<?> beanBuilder = new BeanBuilder(beanManager)
.beanClass(producerResultType)
.types(Object.class, producerResultType)
.qualifiers(qualifiers)
.passivationCapable(passivationCapable)
.scope(scopeClass)
.id(createPartialProducerId(currentClass, currentMethod, qualifiers))
.beanLifecycle(lifecycle);
result.add(beanBuilder.create());
}
}
currentClass = currentClass.getSuperclass();
}
return result;
}
private Set<Annotation> extractQualifiers(Annotation[] annotations, BeanManager beanManager)
{
Set<Annotation> result = BeanUtils.getQualifiers(beanManager, annotations);
if (result.isEmpty())
{
result.add(new DefaultLiteral());
}
return result;
}
private Class<? extends Annotation> extractScope(Annotation[] annotations, BeanManager beanManager)
{
for (Annotation annotation : annotations)
{
if (beanManager.isScope(annotation.annotationType()))
{
return annotation.annotationType();
}
}
return Dependent.class;
}
private String createPartialProducerId(Class currentClass, Method currentMethod, Set<Annotation> qualifiers)
{
int qualifierHashCode = 0;
for (Annotation qualifier : qualifiers)
{
}
}
import org.apache.deltaspike.core.util.AbstractInvocationContext;
public abstract class InvocationContextWrapper extends AbstractInvocationContext<Object>
super(context.getProxy(), context.getMethod(), context.getMethodParameters(), null);
import org.apache.deltaspike.core.util.AbstractInvocationContext;
public class ManualInvocationContext<T, H> extends AbstractInvocationContext<T>
super(target, method, parameters, timer);
import javax.enterprise.inject.spi.BeanManager;
import org.apache.deltaspike.core.util.AbstractInvocationContext;
import org.apache.deltaspike.core.util.AnnotationUtils;
import org.apache.deltaspike.core.util.ExceptionUtils;
import org.apache.deltaspike.jpa.api.transaction.Transactional;
import org.apache.deltaspike.jpa.spi.transaction.TransactionStrategy;
@Inject
private BeanManager beanManager;
@Inject
private TransactionStrategy transactionStrategy;
public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable
{
Transactional transactionalAnnotation =
AnnotationUtils.extractAnnotationFromMethodOrClass(
this.beanManager, method, proxy.getClass(), Transactional.class);
if (transactionalAnnotation != null)
{
return transactionStrategy.execute(
new AbstractInvocationContext<Object>(proxy, method, args, null)
{
@Override
public Object proceed() throws Exception
{
try
{
return process(proxy, method, args);
}
catch (Throwable t)
{
throw ExceptionUtils.throwAsRuntimeException(t);
}
}
});
}
else
{
return process(proxy, method, args);
}
}
public Object process(Object proxy, Method method, Object[] args) throws Throwable
package org.apache.deltaspike.core.util.interceptor;
import org.apache.deltaspike.core.util.interceptor.AbstractInvocationContext;
import org.apache.deltaspike.core.util.interceptor.AbstractInvocationContext;
import org.apache.deltaspike.core.util.interceptor.AbstractInvocationContext;
String type() default "";
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
final String type = getConfigurableAttribute(mBeanAnnotation.type(), "MBeans");
final String category = getConfigurableAttribute(mBeanAnnotation.category(), "org.apache.deltaspike");
private String getConfigurableAttribute(final String annotationAttributeValue, final String defaultValue)
{
String val = annotationAttributeValue.trim();
if (val.startsWith("{") && val.endsWith("}"))
{
val = ConfigResolver.getPropertyValue(val.substring(1, val.length() - 1), defaultValue);
}
return val == null || val.isEmpty() ? defaultValue : val;
}
String properties() default "";
private static final String DEFAULT_TYPE = "MBeans";
private static final String DEFAULT_CATEGORY = "org.apache.deltaspike";
final String type = getConfigurableAttribute(mBeanAnnotation.type(), DEFAULT_TYPE);
final String category = getConfigurableAttribute(mBeanAnnotation.category(), DEFAULT_CATEGORY);
final String properties = getConfigurableAttribute(mBeanAnnotation.properties(), "");
final String name = mBeanAnnotation.name();
final StringBuilder builder = new StringBuilder(category).append(':');
if (!properties.contains("type="))
builder.append("type=").append(type);
else if (!DEFAULT_TYPE.equals(type))
{
}
if (!properties.contains("name="))
{
if (!name.isEmpty() || properties.isEmpty())
{
builder.append(",name=");
if (name.isEmpty())
{
builder.append(clazz.getName());
}
else
{
builder.append(name);
}
}
if (!properties.isEmpty())
{
builder.append(',').append(properties);
}
objectNameValue = builder.toString();
result.addAll(SecurityUtils.getAllAnnotations(method.getAnnotations(),
new HashSet<Integer>()));
import org.apache.deltaspike.core.spi.config.ConfigValidator;
import org.apache.deltaspike.core.util.ServiceUtils;
processConfigurationValidation(adv);
protected void processConfigurationValidation(AfterDeploymentValidation adv)
{
for (ConfigValidator configValidator : ServiceUtils.loadServiceImplementations(ConfigValidator.class))
{
Set<String> violations = configValidator.processValidation();
if (violations == null)
{
continue;
}
for (String violation : violations)
{
adv.addDeploymentProblem(new IllegalStateException(violation));
}
}
}
import javax.enterprise.inject.spi.BeforeShutdown;
private static RepositoryComponents staticComponents = new RepositoryComponents();
staticComponents.add(repoClass);
RepositoryComponents result = new RepositoryComponents();
if (components.getRepositories().isEmpty() && !staticComponents.getRepositories().isEmpty())
{
result.addAll(staticComponents.getRepositories());
}
if (!components.getRepositories().isEmpty())
{
result.addAll(components.getRepositories());
}
return result;
protected void cleanup(@Observes BeforeShutdown beforeShutdown)
{
staticComponents.getRepositories().clear();
}
import java.util.concurrent.ConcurrentHashMap;
private final Map<Class<?>, RepositoryComponent> repos = new ConcurrentHashMap<Class<?>, RepositoryComponent>();
public Map<Class<?>, RepositoryComponent> getRepositories()
{
return repos;
}
public void addAll(Map<Class<?>, RepositoryComponent> repositories)
{
this.repos.putAll(repositories);
}
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
package org.apache.deltaspike.core.impl.message;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.event.Observes;
import javax.enterprise.inject.spi.AfterBeanDiscovery;
import javax.enterprise.inject.spi.AfterDeploymentValidation;
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import javax.enterprise.inject.spi.Extension;
import javax.enterprise.inject.spi.ProcessAnnotatedType;
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
import org.apache.deltaspike.core.api.message.Message;
import org.apache.deltaspike.core.api.message.MessageBundle;
import org.apache.deltaspike.core.api.message.MessageTemplate;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.api.provider.DependentProvider;
import org.apache.deltaspike.core.util.ClassUtils;
import org.apache.deltaspike.core.util.ParentExtensionStorage;
import org.apache.deltaspike.core.util.bean.BeanBuilder;
import org.apache.deltaspike.core.spi.activation.Deactivatable;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import org.apache.deltaspike.core.util.metadata.builder.ContextualLifecycle;
public class MessageBundleExtension implements Extension, Deactivatable
{
private final Collection<AnnotatedType<?>> messageBundleTypes = new HashSet<AnnotatedType<?>>();
private List<String> deploymentErrors = new ArrayList<String>();
private Boolean isActivated = true;
@SuppressWarnings("UnusedDeclaration")
protected void init(@Observes BeforeBeanDiscovery beforeBeanDiscovery)
{
isActivated = ClassDeactivationUtils.isActivated(getClass());
ParentExtensionStorage.addExtension(this);
}
@SuppressWarnings("UnusedDeclaration")
protected void detectInterfaces(@Observes ProcessAnnotatedType processAnnotatedType)
{
if (!isActivated)
{
return;
}
AnnotatedType<?> type = processAnnotatedType.getAnnotatedType();
if (type.isAnnotationPresent(MessageBundle.class))
{
if (validateMessageBundle(type.getJavaClass()))
{
messageBundleTypes.add(type);
}
}
}
private boolean validateMessageBundle(Class<?> currentClass)
{
boolean ok = true;
if (!currentClass.isInterface())
{
deploymentErrors.add("@MessageBundle must only be used on Interfaces, but got used on class "
currentClass.getName());
return false;
}
for (Method currentMethod : currentClass.getDeclaredMethods())
{
if (!currentMethod.isAnnotationPresent(MessageTemplate.class))
{
continue;
}
if (String.class.isAssignableFrom(currentMethod.getReturnType()))
{
continue;
}
if (Message.class.isAssignableFrom(currentMethod.getReturnType()))
{
continue;
}
ok = false;
}
return ok;
}
@SuppressWarnings("UnusedDeclaration")
protected void installMessageBundleProducerBeans(@Observes AfterBeanDiscovery abd, BeanManager beanManager)
{
if (!deploymentErrors.isEmpty())
{
abd.addDefinitionError(new IllegalArgumentException("The following MessageBundle problems where found: "
Arrays.toString(deploymentErrors.toArray())));
return;
}
MessageBundleExtension parentExtension = ParentExtensionStorage.getParentExtension(this);
if (parentExtension != null)
{
messageBundleTypes.addAll(parentExtension.messageBundleTypes);
}
for (AnnotatedType<?> type : messageBundleTypes)
{
abd.addBean(createMessageBundleBean(type, beanManager));
}
}
private <T> Bean<T> createMessageBundleBean(AnnotatedType<T> annotatedType,
BeanManager beanManager)
{
BeanBuilder<T> beanBuilder = new BeanBuilder<T>(beanManager).readFromType(annotatedType);
beanBuilder.beanLifecycle(new MessageBundleLifecycle<T>(beanManager));
beanBuilder.types(annotatedType.getJavaClass(), Object.class, Serializable.class);
beanBuilder.addQualifier(new DefaultLiteral());
beanBuilder.passivationCapable(true);
return beanBuilder.create();
}
@SuppressWarnings("UnusedDeclaration")
protected void cleanup(@Observes AfterDeploymentValidation afterDeploymentValidation)
{
messageBundleTypes.clear();
}
private static class MessageBundleLifecycle<T> implements ContextualLifecycle<T>
{
private final BeanManager beanManager;
private DependentProvider<MessageBundleInvocationHandler> invocationHandlerProvider;
private MessageBundleLifecycle(BeanManager beanManager)
{
this.beanManager = beanManager;
}
@Override
public T create(Bean<T> bean, CreationalContext<T> creationalContext)
{
invocationHandlerProvider = BeanProvider.getDependent(beanManager, MessageBundleInvocationHandler.class);
return createMessageBundleProxy((Class<T>) bean.getBeanClass(), invocationHandlerProvider.get());
}
@Override
public void destroy(Bean<T> bean, T instance, CreationalContext<T> creationalContext)
{
if (invocationHandlerProvider != null)
{
invocationHandlerProvider.destroy();
}
}
private <T> T createMessageBundleProxy(Class<T> type, MessageBundleInvocationHandler handler)
{
return type.cast(Proxy.newProxyInstance(ClassUtils.getClassLoader(null),
new Class<?>[]{type, Serializable.class}, handler));
}
}
}
import org.apache.deltaspike.core.util.ParentExtensionStorage;
ParentExtensionStorage.addExtension(this);
SecurityExtension parentExtension = ParentExtensionStorage.getParentExtension(this);
if (parentExtension != null)
{
Set<Authorizer> parentAuthorizers = parentExtension.getMetaDataStorage().getAuthorizers();
for (Authorizer parentAuthorizer : parentAuthorizers)
{
metaDataStorage.addAuthorizer(parentAuthorizer);
}
}
String interceptRedirect(FacesContext facesContext, String url);
import javax.faces.context.PartialViewContext;
import org.apache.deltaspike.jsf.impl.navigation.DeltaSpikePartialViewContext;
public PartialViewContext getPartialViewContext()
{
PartialViewContext partialViewContext = getWrapped().getPartialViewContext();
return new DeltaSpikePartialViewContext(partialViewContext);
}
@Override
@Override
public String interceptRedirect(FacesContext facesContext, String url)
{
return getClientWindow(facesContext).interceptRedirect(facesContext, url);
}
@Override
public String interceptRedirect(FacesContext facesContext, String url)
{
return url;
}
@Override
public String interceptRedirect(FacesContext facesContext, String url)
{
if (facesContext.getPartialViewContext().isAjaxRequest())
{
String requestToken = newRequestToken();
String windowId = getWindowId(facesContext);
ClientWindowHelper.addRequestWindowIdCookie(facesContext,
requestToken,
windowId);
url = JsfUtils.addParameter(facesContext.getExternalContext(),
url,
true,
ClientWindowHelper.RequestParameters.GET_WINDOW_ID,
windowId);
url = JsfUtils.addParameter(facesContext.getExternalContext(),
url,
true,
ClientWindowHelper.RequestParameters.REQUEST_TOKEN,
requestToken);
return url;
}
return url;
}
protected String newRequestToken()
{
}
if (clientWindow != null)
{
url = clientWindow.interceptRedirect(facesContext, url);
}
this.wrapped.redirect(url);
protected String generateNewRequestToken()
{
}
return ClientWindowHelper.appendWindowId(facesContext, url, this);
String requestToken = generateNewRequestToken();
boolean ajax = facesContext.getPartialViewContext().isAjaxRequest();
boolean post = isPost(facesContext);
boolean get = !post;
if ((!ajax && get) || (ajax && post))
import java.io.Serializable;
public interface ActiveEntityManagerHolder extends Serializable
import java.util.Map;
public class PersistenceUnit
private final Map<String, String> properties;
PersistenceUnit(String unitName, List<EntityDescriptor> entities, Map<String, String> properties)
this.properties = properties;
public Map<String, String> getProperties()
{
return properties;
}
import java.util.HashMap;
import java.util.Map;
Map<String, String> properties = extractProperties((Element) node);
result.add(new PersistenceUnit(unitName, entities, properties));
private Map<String, String> extractProperties(Element element)
{
Map<String, String> propertiesMap = new HashMap<String, String>();
Node propertiesNode = element.getElementsByTagName("properties").item(0);
if (propertiesNode != null)
{
NodeList propertyNodes = propertiesNode.getChildNodes();
{
if ("property".equals(propertyNodes.item(i).getNodeName()))
{
Element propertyNode = (Element) propertyNodes.item(i);
propertiesMap.put(propertyNode.getAttribute("name"), propertyNode.getAttribute("value"));
}
}
}
return Collections.unmodifiableMap(propertiesMap);
}
public PersistenceUnit get(String name)
{
for (PersistenceUnit unit : persistenceUnits)
{
if (name.equalsIgnoreCase(unit.getUnitName()))
{
return unit;
}
}
return null;
}
import java.util.logging.Level;
if (LOG.isLoggable(Level.FINE))
{
}
public static <T> Class<T> tryToLoadClassForName(String name, Class<T> targetType, ClassLoader classLoader)
{
return (Class<T>) tryToLoadClassForName(name, classLoader);
}
public static Class tryToLoadClassForName(String name, ClassLoader classLoader)
{
try
{
return classLoader.loadClass(name);
}
catch (ClassNotFoundException e)
{
return null;
}
}
public <T> Class<T> resolveAlreadyDefinedProxyClass(Class<T> targetClass)
{
Class<T> proxyClass = ClassUtils.tryToLoadClassForName(constructProxyClassName(targetClass),
targetClass,
targetClass.getClassLoader());
return proxyClass;
}
Class<T> proxyClass = resolveAlreadyDefinedProxyClass(targetClass);
Class<T> proxyClass = resolveAlreadyDefinedProxyClass(targetClass);
import java.util.logging.Level;
if (LOG.isLoggable(Level.FINE))
{
}
public static <T> Class<T> tryToLoadClassForName(String name, Class<T> targetType, ClassLoader classLoader)
{
return (Class<T>) tryToLoadClassForName(name, classLoader);
}
public static Class tryToLoadClassForName(String name, ClassLoader classLoader)
{
try
{
return classLoader.loadClass(name);
}
catch (ClassNotFoundException e)
{
return null;
}
}
public <T> Class<T> resolveAlreadyDefinedProxyClass(Class<T> targetClass)
{
Class<T> proxyClass = ClassUtils.tryToLoadClassForName(constructProxyClassName(targetClass),
targetClass,
targetClass.getClassLoader());
return proxyClass;
}
Class<T> proxyClass = resolveAlreadyDefinedProxyClass(targetClass);
Class<T> proxyClass = resolveAlreadyDefinedProxyClass(targetClass);
private static final String REQUEST_URL_REPLACE_PATTERN = "$$requestUrl$$";
windowHandlerHtml = windowHandlerHtml.replace(WINDOW_ID_REPLACE_PATTERN,
windowId);
windowHandlerHtml = windowHandlerHtml.replace(REQUEST_URL_REPLACE_PATTERN,
ClientWindowHelper.constructRequestUrl(externalContext));
public static String constructRequestUrl(ExternalContext externalContext)
{
String url = externalContext.getRequestContextPath()
externalContext.getRequestServletPath();
if (externalContext.getRequestPathInfo() != null)
{
}
url = JsfUtils.addRequestParameters(externalContext, url, true);
url = externalContext.encodeResourceURL(url);
return url;
}
String url = constructRequestUrl(externalContext);
import org.apache.deltaspike.core.util.StringUtils;
if (StringUtils.isEmpty(entry.getKey()) && StringUtils.isEmpty(value))
{
continue;
}
import org.apache.deltaspike.data.api.AbstractFullEntityRepository;
Class<X> javaClass = annotated.getJavaClass();
return javaClass.equals(AbstractEntityRepository.class) ||
javaClass.equals(AbstractFullEntityRepository.class);
import java.io.Serializable;
public class EmbeddedSimple implements Serializable
private static final long serialVersionUID = 1L;
private static final long serialVersionUID = 1L;
import java.io.Serializable;
public class SuperSimple implements Serializable
private static final long serialVersionUID = 1L;
public interface JtaTransactionalRepositoryInterface extends EntityRepository<Simple, Long>
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
private static final long serialVersionUID = 1L;
@SuppressWarnings("unchecked")
if (getClass() != o.getClass())
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
private final Class<? extends QueryInOutMapper<?>> mapper;
final DependentProvider<? extends QueryInOutMapper<?>> mappedProvider = BeanProvider.getDependent(mapper);
private Class<? extends QueryInOutMapper<?>> extractMapper(Method queryMethod, RepositoryComponent repoComponent)
EntityBuilder<EntityDescriptor> entityDescriptorBuilder = new EntityBuilder<EntityDescriptor>()
};
MappedSuperClassBuilder<MappedSuperclassDescriptor> superClassBuilder =
new MappedSuperClassBuilder<MappedSuperclassDescriptor>()
@Override
protected MappedSuperclassDescriptor instance(String name, String packageName, String className,
String idClass, String id, String version)
{
return new MappedSuperclassDescriptor(name, packageName, className, idClass, id, version);
}
@Override
protected String tagName()
{
return "mapped-superclass";
}
};
return new MappingFile(entityDescriptorBuilder.build(doc), superClassBuilder.build(doc));
private abstract class MappedSuperClassBuilder<T extends PersistentClassDescriptor> extends PersistenceBuilder<T>
private abstract class EntityBuilder<T extends PersistentClassDescriptor> extends PersistenceBuilder<T>
private static final long serialVersionUID = 1L;
method = identifier.getClass().getMethod(methodName);
return method.invoke(identifier);
public interface EntityRepository<E, PK extends Serializable>
{
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.LinkedList;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.Query;
import javax.persistence.QueryHint;
import org.apache.deltaspike.data.api.EntityGraph;
import org.apache.deltaspike.data.impl.graph.EntityGraphHelper;
applyEntityGraph(query, method);
private void applyEntityGraph(Query query, Method method)
{
EntityGraph entityGraphAnn = method.getAnnotation(EntityGraph.class);
if (entityGraphAnn == null)
{
return;
}
String graphName = entityGraphAnn.value();
Object graph = EntityGraphHelper.getEntityGraph(getEntityManager(), graphName);
query.setHint(entityGraphAnn.type().getHintName(), graph);
}
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
private static final Class<?> SUBGRAPH_CLASS;
private static final Method ADD_ATTRIBUTE_NODES;
private static final Method ADD_SUBGRAPH;
private static final Method SUBGRAPH_ADD_ATTRIBUTE_NODES;
SUBGRAPH_CLASS = ClassUtils.tryToLoadClassForName("javax.persistence.Subgraph");
if (ENTITY_GRAPH_CLASS == null)
{
ADD_ATTRIBUTE_NODES = null;
ADD_SUBGRAPH = null;
SUBGRAPH_ADD_ATTRIBUTE_NODES = null;
}
else
{
try
{
ADD_ATTRIBUTE_NODES = ENTITY_GRAPH_CLASS.getMethod("addAttributeNodes",
String[].class);
ADD_SUBGRAPH = ENTITY_GRAPH_CLASS.getMethod("addSubgraph", String.class);
SUBGRAPH_ADD_ATTRIBUTE_NODES = SUBGRAPH_CLASS.getMethod("addAttributeNodes",
String[].class);
}
catch (NoSuchMethodException e)
{
throw new EntityGraphException(e.getMessage(), e.getCause());
}
catch (SecurityException e)
{
throw new EntityGraphException(e.getMessage(), e.getCause());
}
}
public static Object createEntityGraph(EntityManager em, Class<?> entityClass)
{
ensureAvailable();
try
{
Method method = EntityManager.class.getMethod("createEntityGraph", Class.class);
return method.invoke(em, entityClass);
}
catch (NoSuchMethodException e)
{
throw new EntityGraphException("no method EntityManager.createEntityGraph()", e);
}
catch (SecurityException e)
{
throw new EntityGraphException("no access to method EntityManager.createEntityGraph()",
e);
}
catch (IllegalAccessException e)
{
throw new EntityGraphException("no access to method EntityManager.createEntityGraph()",
e);
}
catch (InvocationTargetException e)
{
throw new EntityGraphException(e.getCause().getMessage(), e.getCause());
}
}
throw new EntityGraphException("Class java.persistence.EntityGraph is not available. "
public static Object addSubgraph(Object entityGraph, String attributeName)
{
try
{
return ADD_SUBGRAPH.invoke(entityGraph, attributeName);
}
catch (IllegalAccessException e)
{
throw new EntityGraphException("no access to method EntityGraph.addSubgraph()", e);
}
catch (InvocationTargetException e)
{
throw new EntityGraphException(e.getCause().getMessage(), e.getCause());
}
}
public static void addAttributeNodes(Object graph, String attributeName)
{
try
{
if (ENTITY_GRAPH_CLASS.isInstance(graph))
{
ADD_ATTRIBUTE_NODES.invoke(graph, new Object[] { new String[] { attributeName } });
}
else if (SUBGRAPH_CLASS.isInstance(graph))
{
SUBGRAPH_ADD_ATTRIBUTE_NODES.invoke(graph,
new Object[] { new String[] { attributeName } });
}
}
catch (IllegalAccessException e)
{
throw new EntityGraphException("no access to method addAttributeNodes()", e);
}
catch (InvocationTargetException e)
{
throw new EntityGraphException(e.getCause().getMessage(), e.getCause());
}
}
public static Object buildEntityGraph(EntityManager em, Class<?> entityClass,
String[] attributePaths)
{
Object graph = createEntityGraph(em, entityClass);
List<String> paths = new ArrayList<String>(Arrays.asList(attributePaths));
Collections.sort(paths);
Collections.reverse(paths);
for (String path : attributePaths)
{
if (path.contains("."))
{
String[] segments = path.split("\\.");
Object parent = addSubgraph(graph, segments[0]);
{
addSubgraph(parent, segments[i]);
}
addAttributeNodes(parent, segments[segments.length - 1]);
}
else
{
addAttributeNodes(graph, path);
}
}
return graph;
}
Object graph;
if (graphName.isEmpty())
{
graph = EntityGraphHelper.buildEntityGraph(getEntityManager(), entityClass, entityGraphAnn.paths());
}
else
{
graph = EntityGraphHelper.getEntityGraph(getEntityManager(), graphName);
}
import java.util.ArrayList;
import java.util.List;
import javax.persistence.CascadeType;
import javax.persistence.OneToMany;
import javax.persistence.OrderColumn;
@OneToMany(mappedBy = "flat", cascade = CascadeType.ALL)
@OrderColumn
private List<Tenant> tenants = new ArrayList<Tenant>();
public List<Tenant> getTenants()
{
return tenants;
}
public void setTenants(List<Tenant> tenants)
{
this.tenants = tenants;
}
import javax.persistence.OrderColumn;
@OrderColumn
@OrderColumn
@Query("select h from House h where h.name = ?1")
@EntityGraph(paths = {"flats", "garages"})
House fetchByNameWithDynamicGraph(String name);
@Query("select h from House h where h.name = ?1")
@EntityGraph(paths = {"flats.tenants", "garages"})
House fetchByNameWithFlatTenants(String name);
import org.apache.deltaspike.data.api.criteria.CriteriaSupport;
public abstract class AbstractFullEntityRepository<E, PK extends Serializable> extends
AbstractEntityRepository<E, PK> implements EntityManagerDelegate<E>, CriteriaSupport<E>
import org.apache.deltaspike.data.api.criteria.CriteriaSupport;
extends EntityRepository<E, PK>, EntityManagerDelegate<E>, CriteriaSupport<E>
import org.apache.deltaspike.data.test.domain.Simple_;
public Simple fetchByName(String name)
{
return criteria().eq(Simple_.name, name).getOptionalResult();
}
import org.apache.deltaspike.core.util.ExceptionUtils;
import org.apache.deltaspike.data.api.EntityGraph;
private static final Method EG_ADD_ATTRIBUTE_NODES;
private static final Method EG_ADD_SUBGRAPH;
private static final Method SUBGRAPH_ADD_SUBGRAPH;
private static final Method EM_GET_ENTITY_GRAPH;
private static final Method EM_CREATE_ENTITY_GRAPH;
EG_ADD_ATTRIBUTE_NODES = null;
EG_ADD_SUBGRAPH = null;
SUBGRAPH_ADD_SUBGRAPH = null;
EM_GET_ENTITY_GRAPH = null;
EM_CREATE_ENTITY_GRAPH = null;
EG_ADD_ATTRIBUTE_NODES = ENTITY_GRAPH_CLASS.getMethod("addAttributeNodes",
EG_ADD_SUBGRAPH = ENTITY_GRAPH_CLASS.getMethod("addSubgraph", String.class);
SUBGRAPH_ADD_SUBGRAPH = SUBGRAPH_CLASS.getMethod("addSubgraph", String.class);
EM_GET_ENTITY_GRAPH = EntityManager.class.getMethod("getEntityGraph", String.class);
EM_CREATE_ENTITY_GRAPH = EntityManager.class.getMethod("createEntityGraph",
Class.class);
throw ExceptionUtils.throwAsRuntimeException(e);
private static Object uncheckedInvoke(Method method, Object target, Object... args)
return method.invoke(target, args);
throw ExceptionUtils.throwAsRuntimeException(e);
throw ExceptionUtils.throwAsRuntimeException(e.getCause());
public static Object getEntityGraph(EntityManager em, Class<?> entityClass, EntityGraph entityGraphAnn)
String graphName = entityGraphAnn.value();
if (graphName.isEmpty())
return buildEntityGraph(em, entityClass, entityGraphAnn.paths());
else
return uncheckedInvoke(EM_GET_ENTITY_GRAPH, em, graphName);
}
private static Object createEntityGraph(EntityManager em, Class<?> entityClass)
{
return uncheckedInvoke(EM_CREATE_ENTITY_GRAPH, em, entityClass);
private static Object addSubgraph(Object graph, String attributeName)
if (ENTITY_GRAPH_CLASS.isInstance(graph))
return uncheckedInvoke(EG_ADD_SUBGRAPH, graph, attributeName);
else if (SUBGRAPH_CLASS.isInstance(graph))
return uncheckedInvoke(SUBGRAPH_ADD_SUBGRAPH, graph, attributeName);
return null;
}
private static void addAttributeNodes(Object graph, String attributeName)
{
if (ENTITY_GRAPH_CLASS.isInstance(graph))
uncheckedInvoke(EG_ADD_ATTRIBUTE_NODES, graph,
new Object[] { new String[] { attributeName } });
}
else if (SUBGRAPH_CLASS.isInstance(graph))
{
uncheckedInvoke(SUBGRAPH_ADD_ATTRIBUTE_NODES, graph,
new Object[] { new String[] { attributeName } });
private static Object buildEntityGraph(EntityManager em, Class<?> entityClass,
Object graph = EntityGraphHelper.getEntityGraph(getEntityManager(), entityClass, entityGraphAnn);
public abstract class AbstractQuartzScheduler<T> implements Scheduler<T>
private static final Logger LOG = Logger.getLogger(AbstractQuartzScheduler.class.getName());
public void registerNewJob(Class<? extends T> jobClass)
Class<? extends Job> jobClassToAdd = createFinalJobClass(jobClass);
jobDetail = JobBuilder.newJob(jobClassToAdd)
Logger.getLogger(AbstractQuartzScheduler.class.getName()).info(
protected abstract Class<? extends Job> createFinalJobClass(Class<? extends T> jobClass);
public void startJobManually(Class<? extends T> jobClass)
public void interruptJob(Class<? extends T> jobClass)
public boolean deleteJob(Class<? extends T> jobClass)
public void pauseJob(Class<? extends T> jobClass)
public void resumeJob(Class<? extends T> jobClass)
public boolean isExecutingJob(Class<? extends T> jobClass)
private JobKey createJobKey(Class<?> jobClass)
String jobName = getJobName(jobClass);
protected String getJobName(Class<?> jobClass)
{
return jobClass.getSimpleName();
}
private static class JobListenerContext
if (scheduler.getClass().getGenericSuperclass() instanceof ParameterizedType)
{
ParameterizedType parameterizedType = (ParameterizedType) scheduler.getClass().getGenericSuperclass();
for (Type typeArgument : parameterizedType.getActualTypeArguments())
{
if (jobClass.isAssignableFrom((Class)typeArgument))
{
return scheduler;
}
}
}
return !"QuartzScheduler".equals(targetClass.getSimpleName()) &&
!"RunnableQuartzScheduler".equals(targetClass.getSimpleName());
import org.apache.deltaspike.core.util.ClassUtils;
private Class<? extends Job> runnableAdapter;
@Override
public void start()
{
String configuredAdapterClassName = SchedulerBaseConfig.JobCustomization.RUNNABLE_ADAPTER_CLASS_NAME;
this.runnableAdapter = ClassUtils.tryToLoadClassForName(configuredAdapterClassName, Job.class);
super.start();
}
return runnableAdapter;
String RUNNABLE_ADAPTER_CLASS_NAME_KEY = "deltaspike.scheduler.runnable-adapter-class";
String RUNNABLE_ADAPTER_CLASS_NAME = ConfigResolver.resolve(RUNNABLE_ADAPTER_CLASS_NAME_KEY)
.withCurrentProjectStage(true)
.withDefault("org.apache.deltaspike.scheduler.impl.JobRunnableAdapter")
.getValue();
private final OrderBy<C> orderByProcessor = new OrderBy<C>();
CriteriaQuery<R> query = createCriteriaQuery(builder);
private <P> void addOrderBy(SingularAttribute<? super C, P> att, OrderDirection orderDirection)
@SuppressWarnings("unchecked")
private CriteriaQuery<R> createCriteriaQuery(CriteriaBuilder builder)
return (CriteriaQuery<R>) builder.createQuery();
public class OrderBy<P> implements QueryProcessor<P>
private final List<OrderByDefinition<?>> orderByDefinitions = new ArrayList<OrderByDefinition<?>>();
public <V> void add(SingularAttribute<? super P, V> att, OrderDirection dir)
orderByDefinitions.add(new OrderByDefinition<V>(att, dir));
Iterator<OrderByDefinition<?>> iterator = orderByDefinitions.iterator();
OrderByDefinition<?> orderByDefinition = iterator.next();
private class OrderByDefinition<V>
OrderByDefinition<V> that = (OrderByDefinition<V>) o;
return builder.createQuery(resultClass);
LOG.info(processAnnotatedType.getAnnotatedType().getJavaClass().getName()
" is configured as global-alternative");
import org.apache.deltaspike.core.api.exception.control.event.ExceptionToCatchEvent;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
@Inject
private BeanManager beanManager;
try
{
runnableBean.run();
}
catch (Throwable t)
{
this.beanManager.fireEvent(new ExceptionToCatchEvent(t));
}
if (!jobClass.isAssignableFrom(beanClass) && !Runnable.class.isAssignableFrom(beanClass))
Class configuredJobClass = this.jobClass;
this.jobClass = resolveFinalJobType();
if (this.jobClass == null)
{
afterBeanDiscovery.addDefinitionError(new IllegalStateException("Please only annotate classes with @"
return;
}
protected Class resolveFinalJobType()
{
Set<Class> foundTypes = new HashSet<Class>();
for (Class foundJobClass : this.foundManagedJobClasses)
{
if (jobClass.isAssignableFrom(foundJobClass))
{
foundTypes.add(jobClass);
}
else if (Runnable.class.isAssignableFrom(foundJobClass))
{
foundTypes.add(Runnable.class);
}
}
if (foundTypes.size() > 1)
{
return null;
}
else if (foundTypes.size() == 1)
{
return foundTypes.iterator().next();
}
else
{
return jobClass;
}
}
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
if (delegateMethods != null)
for (java.lang.reflect.Method method : delegateMethods)
{
defineMethod(cw, method, DelegateManualInvocationHandler.class);
}
if (interceptMethods != null)
for (java.lang.reflect.Method method : interceptMethods)
{
defineSuperAccessorMethod(cw, method, superType, superAccessorMethodSuffix);
defineMethod(cw, method, InterceptManualInvocationHandler.class);
}
}
try
{
ClassVisitor cv = new ClassVisitor(Opcodes.ASM5)
{
@Override
public AnnotationVisitor visitAnnotation(String desc, boolean visible)
{
return new CopyAnnotationVisitorAdapter(
super.visitAnnotation(desc, visible),
cw.visitAnnotation(desc, visible));
}
};
ClassReader cr = new ClassReader(targetClass.getClassLoader().getResourceAsStream(sourceClassFilename));
cr.accept(cv, 0);
}
catch (Exception e)
{
throw new RuntimeException(e);
import org.apache.deltaspike.jpa.spi.entitymanager.ActiveEntityManagerHolder;
@Inject
private ActiveEntityManagerHolder activeEntityManagerHolder;
if (activeEntityManagerHolder.isSet())
{
return activeEntityManagerHolder.get();
}
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.util.interceptor.AbstractInvocationContext;
import org.apache.deltaspike.core.util.metadata.AnnotationInstanceProvider;
import org.apache.deltaspike.jpa.spi.entitymanager.ActiveEntityManagerHolder;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceException;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
@Inject
private ActiveEntityManagerHolder activeEntityManagerHolder;
if (transactionalAnnotation.qualifier().length > 1)
{
}
Class<? extends Annotation> qualifier = transactionalAnnotation.qualifier()[0];
if (!Any.class.equals(qualifier))
{
EntityManager entityManager = BeanProvider.getContextualReference(
EntityManager.class, false, AnnotationInstanceProvider.of(qualifier));
activeEntityManagerHolder.set(entityManager);
}
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
public class QueryBuilderFactory
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
public class RepositoryComponents
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
private EntityManagerRefLookup entityManagerRefLookup;
EntityManagerRef entityManagerRef = null;
entityManagerRef = entityManagerRefLookup.lookupReference(repo);
queryContext = createContext(proxy, method, args, entityManagerRef.getEntityManager(), repoMethod);
if (entityManagerRef != null && entityManagerRef.getEntityManagerResolverDependentProvider() != null)
{
entityManagerRef.getEntityManagerResolverDependentProvider().destroy();
}
Object[] args, EntityManager entityManager, RepositoryMethod repoMethod)
entityManager);
public void release()
{
if (entityManagerResolverDependentProvider != null)
{
entityManagerResolverDependentProvider.destroy();
}
}
if (entityManagerRef != null)
entityManagerRef.release();
public static boolean isEmpty(Object[] array)
{
return array == null || array.length == 0;
}
public static boolean isNotEmpty(String text)
{
return !isEmpty(text);
}
import static org.apache.deltaspike.core.util.StringUtils.isNotEmpty;
import static org.apache.deltaspike.core.util.StringUtils.isNotEmpty;
import static org.apache.deltaspike.core.util.StringUtils.isNotEmpty;
import static org.apache.deltaspike.core.util.ArraysUtils.isEmpty;
import static org.apache.deltaspike.core.util.StringUtils.isNotEmpty;
import static org.apache.deltaspike.core.util.StringUtils.isEmpty;
import org.apache.deltaspike.core.util.StringUtils;
if (StringUtils.isEmpty(id) && getParent() != null)
import org.apache.deltaspike.core.util.StringUtils;
if (StringUtils.isEmpty(value))
if (instance instanceof ServletRequest)
{
ServletRequest servletRequest = (ServletRequest) instance;
if (servletRequest.getAttribute("javax.servlet.forward.request_uri") != null)
{
return;
}
}
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.util.ClassDeactivationUtils;
import java.util.Arrays;
import java.util.UUID;
scheduleNewJob(scheduled, jobKey, jobDetail);
scheduleNewJob(scheduled, jobKey, jobDetail);
if (scheduled.cronExpression().startsWith("{") && scheduled.cronExpression().endsWith("}"))
{
this.scheduler.unscheduleJobs(Arrays.asList(trigger.getKey()));
scheduleNewJob(scheduled, jobKey, jobDetail);
}
else
{
trigger = TriggerBuilder.newTrigger()
.withIdentity(trigger.getKey())
.withSchedule(CronScheduleBuilder.cronSchedule(scheduled.cronExpression()))
.build();
this.scheduler.rescheduleJob(trigger.getKey(), trigger);
}
private void scheduleNewJob(Scheduled scheduled, JobKey jobKey, JobDetail jobDetail) throws SchedulerException
{
String cronExpression = evaluateExpression(scheduled);
this.scheduler.scheduleJob(jobDetail, createTrigger(scheduled, jobKey, cronExpression));
}
private Trigger createTrigger(Scheduled scheduled, JobKey jobKey, String cronExpression) throws SchedulerException
{
UUID triggerKey = UUID.randomUUID();
if (!scheduled.cronExpression().endsWith(cronExpression))
{
createExpressionObserverJob(jobKey, triggerKey, scheduled.cronExpression(), cronExpression);
}
Trigger trigger = TriggerBuilder.newTrigger()
.forJob(jobKey)
.withIdentity(triggerKey.toString())
.withSchedule(CronScheduleBuilder.cronSchedule(cronExpression))
.build();
return trigger;
}
private void createExpressionObserverJob(
JobKey jobKey, UUID triggerKey, String configExpression, String cronExpression) throws SchedulerException
{
if (!ClassDeactivationUtils.isActivated(DynamicExpressionObserverJob.class))
{
return;
}
JobKey observerJobKey =
JobDetail jobDetail  = JobBuilder.newJob(DynamicExpressionObserverJob.class)
.usingJobData(DynamicExpressionObserverJob.CONFIG_EXPRESSION_KEY, configExpression)
.usingJobData(DynamicExpressionObserverJob.TRIGGER_ID_KEY, triggerKey.toString())
.usingJobData(DynamicExpressionObserverJob.ACTIVE_CRON_EXPRESSION_KEY, cronExpression)
.withIdentity(observerJobKey)
.build();
Trigger trigger = TriggerBuilder.newTrigger()
.forJob(observerJobKey)
.withSchedule(CronScheduleBuilder.cronSchedule(
SchedulerBaseConfig.JobCustomization.DYNAMIC_EXPRESSION_OBSERVER_INTERVAL))
.build();
this.scheduler.scheduleJob(jobDetail, trigger);
}
private String evaluateExpression(Scheduled scheduled)
{
String expression = scheduled.cronExpression();
if (expression.startsWith("{") && expression.endsWith("}"))
{
String configKey = expression.substring(1, expression.length() - 1);
expression = ConfigResolver.getProjectStageAwarePropertyValue(configKey, null);
if (expression == null)
{
}
}
return expression;
}
String DYNAMIC_EXPRESSION_OBSERVER_INTERVAL_KEY =
"deltaspike.scheduler.dynamic-expression.observer-interval";
String DYNAMIC_EXPRESSION_OBSERVER_INTERVAL =
ConfigResolver.resolve(DYNAMIC_EXPRESSION_OBSERVER_INTERVAL_KEY)
.withCurrentProjectStage(true)
.withDefault("0 0/1 * * * ?")
.getValue();
private static Set<String> classNamesToVeto = new HashSet<String>();
public SchedulerExtension()
{
classNamesToVeto.add("org.apache.deltaspike.scheduler.impl.DynamicExpressionObserverJob");
}
if (Scheduler.class.isAssignableFrom(beanClass) || isInternalUnmanagedClass(beanClass))
private <X> boolean isInternalUnmanagedClass(Class<X> beanClass)
{
return classNamesToVeto.contains(beanClass.getName());
}
@Override
public String getPropertyValue(String key)
{
String val = super.getPropertyValue(key);
if (val == null || val.isEmpty())
{
val = super.getPropertyValue(key.replace('.', '_'));
}
return val;
}
@Override
public boolean isScannable()
{
return false;
}
Property<Serializable> versionProperty =
repoMethod.getRepository().getRepositoryEntity().getVersionProperty();
Property<Serializable> primaryKeyProperty =
repoMethod.getRepository().getRepositoryEntity().getPrimaryKeyProperty();
if (EntityUtils.primaryKeyValue(entity, primaryKeyProperty) == null)
if (!entityManager.contains(entity) && countCheck(entity, primaryKeyProperty))
private boolean countCheck(Object entity, Property<Serializable> primaryKeyProperty)
jpql.append(primaryKeyProperty.getName());
query.setParameter("id", EntityUtils.primaryKeyValue(entity, primaryKeyProperty));
return EntityUtils.tableName(context.getEntityClass(), entityManager());
return context.getRepositoryMethod().getRepository().getRepositoryEntity().getEntityName();
private final RepositoryEntity repositoryEntity;
public RepositoryComponent(Class<?> repoClass, RepositoryEntity repositoryEntity)
if (repositoryEntity == null)
throw new IllegalArgumentException("repositoryEntity cannot be null");
this.repositoryEntity = repositoryEntity;
return repositoryEntity.getEntityName();
return repositoryEntity.getEntityClass();
return repositoryEntity.getPrimaryKeyClass();
public RepositoryEntity getRepositoryEntity()
{
return repositoryEntity;
}
import org.apache.deltaspike.data.impl.property.Property;
import org.apache.deltaspike.data.impl.util.EntityUtils;
private Class<? extends Serializable> primaryKeyClass;
private Property<Serializable> primaryKeyProperty;
private Property<Serializable> versionProperty;
private String entityName;
this.primaryKeyClass = primaryClass;
this.primaryKeyProperty = EntityUtils.primaryKeyProperty(entityClass);
this.versionProperty = EntityUtils.getVersionProperty(entityClass);
this.entityName = EntityUtils.entityName(entityClass);
public Class<? extends Serializable> getPrimaryKeyClass()
return primaryKeyClass;
public void setPrimaryKeyClass(Class<? extends Serializable> primaryKeyClass)
this.primaryKeyClass = primaryKeyClass;
public Property<Serializable> getVersionProperty()
{
return versionProperty;
}
public void setVersionProperty(Property<Serializable> versionProperty)
{
this.versionProperty = versionProperty;
}
public String getEntityName()
{
return entityName;
}
public void setEntityName(String entityName)
{
this.entityName = entityName;
}
public Property<Serializable> getPrimaryKeyProperty()
{
return primaryKeyProperty;
}
public void setPrimaryKeyProperty(Property<Serializable> primaryKeyProperty)
{
this.primaryKeyProperty = primaryKeyProperty;
}
result.setPrimaryKeyClass((Class<? extends Serializable>) genericType);
import javax.persistence.EntityManager;
import javax.persistence.Table;
import javax.persistence.metamodel.EntityType;
import org.apache.deltaspike.core.util.StringUtils;
Property<Serializable> property = primaryKeyProperty(entityClass);
Property<Serializable> property = primaryKeyProperty(entity.getClass());
return primaryKeyValue(entity, property);
public static Object primaryKeyValue(Object entity, Property<Serializable> primaryKeyProperty)
{
return primaryKeyProperty.getValue(entity);
}
public static String tableName(Class<?> entityClass, EntityManager entityManager)
{
String tableName = PersistenceUnits.instance().entityTableName(entityClass);
if (StringUtils.isEmpty(tableName))
{
EntityType<?> entityType = entityManager.getMetamodel().entity(entityClass);
Table tableAnnotation = entityClass.getAnnotation(Table.class);
return tableAnnotation == null ? entityType.getName() : tableAnnotation.name();
}
return tableName;
}
public static Property<Serializable> primaryKeyProperty(Class<?> entityClass)
public static Property<Serializable> getVersionProperty(Class<?> entityClass)
@Override
import java.lang.reflect.Method;
public static boolean containsMethod(Class<?> targetClass, Method method)
{
return extractMethod(targetClass, method) != null;
}
public static Method extractMethod(Class<?> clazz, Method sourceMethod)
{
try
{
String name = sourceMethod.getName();
return clazz != null ? clazz.getMethod(name, sourceMethod.getParameterTypes()) : null;
}
catch (NoSuchMethodException e)
{
return null;
}
}
import org.apache.deltaspike.core.util.ClassUtils;
if (ClassUtils.containsMethod(bean.getBeanClass(), context.getMethod()))
Method extract = ClassUtils.extractMethod(target.getClass(), method);
import org.apache.deltaspike.core.util.ClassUtils;
if (ClassUtils.containsMethod(EntityRepositoryHandler.class, method))
Method executed = ClassUtils.extractMethod(EntityRepositoryHandler.class, method);
if (!Future.class.isAssignableFrom(returnType) &&
(COMPLETION_STAGE == null || !COMPLETION_STAGE.isAssignableFrom(returnType)))
final Future<?> future = COMPLETION_STAGE == null || !COMPLETION_STAGE.isInstance(proceed) ?
package org.apache.deltaspike.core.util;
import org.apache.deltaspike.jpa.spi.descriptor.xml.PersistenceUnitDescriptorProvider;
PersistenceUnitDescriptorProvider.getInstance().init();
Type genericType = genericTypes[i];
import org.apache.deltaspike.jpa.spi.descriptor.xml.PersistenceUnitDescriptorProvider;
return entity.isAnnotationPresent(Entity.class)
|| PersistenceUnitDescriptorProvider.getInstance().isEntity(entity);
import org.apache.deltaspike.jpa.spi.descriptor.xml.PersistenceUnitDescriptorProvider;
Class clazz = PersistenceUnitDescriptorProvider.getInstance().primaryKeyIdClass(entityClass);
result = PersistenceUnitDescriptorProvider.getInstance().entityName(entityClass);
String tableName = PersistenceUnitDescriptorProvider.getInstance().entityTableName(entityClass);
for (PropertyCriteria c : primaryKeyPropertyCriteriaList(entityClass))
private static List<PropertyCriteria> primaryKeyPropertyCriteriaList(Class<?> entityClass)
String[] fromMappingFiles = PersistenceUnitDescriptorProvider.getInstance().primaryKeyFields(entityClass);
for (String id : fromMappingFiles)
{
criteria.add(new NamedPropertyCriteria(id));
}
String fromMappingFiles = PersistenceUnitDescriptorProvider.getInstance().versionField(entityClass);
package org.apache.deltaspike.jpa.spi.descriptor.xml;
public final class AbstractEntityHierarchyBuilder
private AbstractEntityHierarchyBuilder()
public static void buildHierarchy(List<EntityDescriptor> entities, List<MappedSuperclassDescriptor> superClasses)
buildHierarchy(descriptor, entities, superClasses);
protected static void buildHierarchy(AbstractEntityDescriptor descriptor,
List<EntityDescriptor> entities, List<MappedSuperclassDescriptor> superClasses)
AbstractEntityDescriptor superDescriptor =
findPersistentClassDescriptor(superClass, entities, superClasses);
buildHierarchy(superDescriptor, entities, superClasses);
protected static AbstractEntityDescriptor findPersistentClassDescriptor(Class<?> superClass,
List<EntityDescriptor> entities, List<MappedSuperclassDescriptor> superClasses)
package org.apache.deltaspike.jpa.spi.descriptor.xml;
public class Descriptor
package org.apache.deltaspike.jpa.spi.descriptor.xml;
import org.apache.deltaspike.core.util.AggregatedClassLoader;
private static final Logger LOG = Logger.getLogger(DescriptorReader.class.getName());
protected List<Descriptor> readAllFromClassPath(String resource) throws IOException
protected Descriptor readFromClassPath(String resource) throws IOException
protected Descriptor readFromUrl(URL url) throws IOException
protected Descriptor read(String baseUrl, String resource) throws IOException
protected String extractBaseUrl(URL fileUrl, String resource)
protected ClassLoader classLoader()
package org.apache.deltaspike.jpa.spi.descriptor.xml;
import javax.enterprise.inject.Typed;
@Typed
public class PersistenceUnitDescriptorParser extends DescriptorReader
public static final String RESOURCE_PATH = "META-INF/persistence.xml";
private final EntityMappingsDescriptorParser entityMappingsDescriptorParser
= new EntityMappingsDescriptorParser();
public List<PersistenceUnitDescriptor> readAll() throws IOException
List<PersistenceUnitDescriptor> result = new LinkedList<PersistenceUnitDescriptor>();
List<Descriptor> persistenceXmls = readAllFromClassPath(RESOURCE_PATH);
protected List<PersistenceUnitDescriptor> lookupUnits(Descriptor descriptor)
List<PersistenceUnitDescriptor> result = new LinkedList<PersistenceUnitDescriptor>();
String baseUrl = extractBaseUrl(descriptor.getUrl(), RESOURCE_PATH);
result.add(new PersistenceUnitDescriptor(unitName, entities, properties));
protected List<EntityDescriptor> extractMappings(Element element, String baseUrl, String unitName)
readMappingFiles(baseUrl, unitName, entities, superClasses, list);
EntityMappingsDescriptor mappings = entityMappingsDescriptorParser.readDefaultOrm(baseUrl);
entities.addAll(mappings.getEntityDescriptors());
superClasses.addAll(mappings.getMappedSuperclassDescriptors());
AbstractEntityHierarchyBuilder.buildHierarchy(entities, superClasses);
protected void readMappingFiles(String baseUrl, String unitName,
EntityMappingsDescriptor mappings = entityMappingsDescriptorParser.readAll(baseUrl, resource);
entities.addAll(mappings.getEntityDescriptors());
superClasses.addAll(mappings.getMappedSuperclassDescriptors());
protected String extractUnitName(Node node)
protected Map<String, String> extractProperties(Element element)
package org.apache.deltaspike.test.jpa.spi.descriptor.xml;
public class MappedId
private Long id;
public Long getId()
return id;
public void setId(Long id)
this.id = id;
package org.apache.deltaspike.test.jpa.spi.descriptor.xml;
public class MappedOne
private Long id;
private String name;
public MappedOne()
public MappedOne(String name)
this.name = name;
public Long getId()
return id;
}
public void setId(Long id)
{
this.id = id;
}
public String getName()
{
return name;
}
public void setName(String name)
{
this.name = name;
package org.apache.deltaspike.test.jpa.spi.descriptor.xml;
public class MappedSuperclass extends MappedId
private Long counter;
public Long getCounter()
return counter;
public void setCounter(Long id)
this.counter = id;
package org.apache.deltaspike.test.jpa.spi.descriptor.xml;
public class MappedThree extends MappedSuperclass
private String name;
public String getName()
return name;
public void setName(String name)
this.name = name;
import javax.faces.application.ProjectStage;
private final ProjectStage projectStage;
Application wrapped, JsfModuleConfig jsfModuleConfig, boolean preDestroyViewMapEventFilterMode,
ProjectStage projectStage)
this.projectStage = projectStage;
@Override
public ProjectStage getProjectStage()
{
if (this.projectStage == null)
{
return getWrapped().getProjectStage();
}
return this.projectStage;
}
import org.apache.deltaspike.core.api.projectstage.TestStage;
import org.apache.deltaspike.core.util.ProjectStageProducer;
import javax.faces.application.ProjectStage;
private ProjectStage projectStage;
org.apache.deltaspike.core.api.projectstage.ProjectStage dsProjectStage =
ProjectStageProducer.getInstance().getProjectStage();
for (ProjectStage ps : ProjectStage.values())
{
if (ps.name().equals(dsProjectStage.getClass().getSimpleName()))
{
this.projectStage = ps;
break;
}
}
if (this.projectStage == null && dsProjectStage instanceof TestStage)
{
this.projectStage = ProjectStage.Development;
}
if (this.projectStage == null)
{
this.projectStage = ProjectStage.Production;
}
wrappedApplication, this.jsfModuleConfig, this.preDestroyViewMapEventFilterMode, this.projectStage);
if (this.projectStage == ProjectStage.Production)
import org.apache.deltaspike.proxy.spi.DummyInvocationHandler;
public <T> Class<T> getProxyClass(BeanManager beanManager, Class<T> targetClass)
{
return getProxyClass(beanManager, targetClass, DummyInvocationHandler.class);
}
if (interceptMethods != null
public @interface EnableInterceptors
package org.apache.deltaspike.proxy.spi;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
public class EnableInterceptorsDelegate implements InvocationHandler, Serializable
private final Object instance;
public EnableInterceptorsDelegate(Object instance)
this.instance = instance;
}
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
{
return method.invoke(instance, args);
import java.lang.reflect.Constructor;
import org.apache.deltaspike.proxy.api.EnableInterceptors;
@EnableInterceptors
public class EnableInterceptorsInterceptor implements Serializable
EnableInterceptors.class.getSimpleName()
Class proxyClass = EnableInterceptorsProxyFactory.getInstance().getProxyClass(beanManager,
beanCandidate.getClass(), EnableInterceptorsDelegate.class);
Constructor constructor = proxyClass.getConstructor(EnableInterceptorsDelegate.class);
return constructor.newInstance(new EnableInterceptorsDelegate(beanCandidate));
package org.apache.deltaspike.proxy.impl.enableinterceptors;
package org.apache.deltaspike.proxy.impl.enableinterceptors;
package org.apache.deltaspike.proxy.impl.enableinterceptors;
package org.apache.deltaspike.proxy.impl.enableinterceptors;
import org.apache.deltaspike.proxy.api.EnableInterceptors;
@EnableInterceptors
MyBean myBean = new MyBean();
return myBean;
Object producerResult = invocationContext.proceed();
return EnableInterceptorsProxyFactory.wrap(producerResult, beanManager);
import java.lang.reflect.Constructor;
import javax.enterprise.inject.spi.BeanManager;
public static <T> T wrap(T obj, BeanManager beanManager)
if (obj == null)
throw new IllegalArgumentException("obj must not be null!");
Class proxyClass = EnableInterceptorsProxyFactory.getInstance().getProxyClass(beanManager,
obj.getClass(), EnableInterceptorsDelegate.class);
EnableInterceptorsDelegate delegate = new EnableInterceptorsDelegate(obj);
try
{
Constructor constructor = proxyClass.getConstructor(EnableInterceptorsDelegate.class);
return (T) constructor.newInstance(delegate);
}
catch (Exception e)
{
}
protected ArrayList<Method> getDelegateMethods(Class<?> targetClass, ArrayList<Method> allMethods)
{
ArrayList<Method> delegateMethods = super.filterInterceptMethods(targetClass, allMethods);
return delegateMethods;
}
@Override
public void somethingNotIntercepted()
{
methodCalled = true;
}
import org.jboss.shrinkwrap.api.ShrinkWrap;
"org.apache.deltaspike.test.category"},
result.add(ShrinkWrap.create(JavaArchive.class, "ds-asm.jar")
.addPackages(true, "org.objectweb.asm"));
private static class DummyInvocationHandler implements InvocationHandler
{
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
{
return null;
}
}
package org.apache.deltaspike.proxy.util;
package org.apache.deltaspike.proxy.util;
import java.io.Serializable;
import java.lang.reflect.InvocationHandler;
private EnableInterceptorsProxyFactory()
Class proxyClass = INSTANCE.getProxyClass(beanManager, obj.getClass(), EnableInterceptorsDelegate.class);
private static class EnableInterceptorsDelegate implements InvocationHandler, Serializable
{
private final Object instance;
public EnableInterceptorsDelegate(Object instance)
{
this.instance = instance;
}
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
{
return method.invoke(instance, args);
}
}
import org.apache.deltaspike.core.impl.util.AnnotatedMethods;
final AnnotatedMethod<?> annotatedMethod = AnnotatedMethods.findMethod(annotatedType, method);
import org.apache.deltaspike.core.impl.util.AnnotatedMethods;
final AnnotatedMethod<?> annotatedMethod = AnnotatedMethods.findMethod(annotatedType, method);
public static final String DEFAULT_REMOVE_PREFIX = "removeBy";
return this.getPrefix().equalsIgnoreCase(DEFAULT_DELETE_PREFIX) ||
this.getPrefix().equalsIgnoreCase(DEFAULT_REMOVE_PREFIX);
},
REMOVE_DEFAULT(DEFAULT_REMOVE_PREFIX)
{
@Override
public SingleResultType getStyle()
{
return SingleResultType.ANY;
}
public abstract void removeByName(String name);
public abstract void removeByNameAndEnabled(String name, Boolean aTrue);
<X> QueryResult<E> orderAsc(SingularAttribute<E, X> attribute, boolean appendEntityName);
QueryResult<E> orderAsc(String attribute, boolean appendEntityName);
<X> QueryResult<E> orderDesc(SingularAttribute<E, X> attribute, boolean appendEntityName);
QueryResult<E> orderDesc(String attribute, boolean appendEntityName);
private boolean appendEntityName;
public OrderByQueryStringPostProcessor(SingularAttribute<?, ?> attribute, OrderDirection direction,
boolean appendEntityName)
this.appendEntityName = appendEntityName;
public OrderByQueryStringPostProcessor(String attribute, OrderDirection direction, boolean appendEntityName)
this.appendEntityName = appendEntityName;
if (appendEntityName)
{
builder.append(QueryBuilder.ENTITY_NAME)
.append(".");
}
return builder
.append(attribute)
return orderAsc(attribute, true);
}
@Override
public <X> QueryResult<T> orderAsc(SingularAttribute<T, X> attribute, boolean appendEntityName)
{
context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.ASC,
appendEntityName));
return orderAsc(attribute, true);
}
@Override
public QueryResult<T> orderAsc(String attribute, boolean appendEntityName)
{
context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.ASC,
appendEntityName));
return orderDesc(attribute, true);
}
@Override
public <X> QueryResult<T> orderDesc(SingularAttribute<T, X> attribute, boolean appendEntityName)
{
context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.DESC,
appendEntityName));
return orderDesc(attribute, true);
}
@Override
public QueryResult<T> orderDesc(String attribute, boolean appendEntityName)
{
context.addQueryStringPostProcessor(new OrderByQueryStringPostProcessor(attribute, OrderDirection.DESC,
appendEntityName));
import java.util.concurrent.TimeUnit;
TypedResolver<T> cacheFor(TimeUnit timeUnit, long value);
private long cacheTimeMs = -1;
private volatile long reloadAfter = -1;
private T lastValue = null;
public TypedResolver<T> cacheFor(TimeUnit timeUnit, long value)
{
this.cacheTimeMs = timeUnit.toMillis(value);
return this;
}
@Override
if (cacheTimeMs > 0)
{
long now = System.currentTimeMillis();
if (now <= reloadAfter)
{
return lastValue;
}
}
value = fallbackToDefaultIfEmpty(keyResolved, value, defaultValue);
if (cacheTimeMs > 0)
{
lastValue = value;
}
return value;
if (scheduled == null && !jobClass.equals(DynamicExpressionObserverJob.class))
if (scheduled == null)
{
return;
}
import org.apache.deltaspike.core.api.config.ConfigResolver;
public static final String CONFIG_ENABLE_PARENT_EXTENSION = "deltaspike.parent.extension.enabled";
if (usingParentExtension())
{
removeAbandonedExtensions();
ClassLoader classLoader = ClassUtils.getClassLoader(null);
extensionStorage.add(new ExtensionStorageInfo(classLoader, extension));
}
private static boolean usingParentExtension()
{
final boolean usingParentExtension =
Boolean.parseBoolean(ConfigResolver.getPropertyValue(CONFIG_ENABLE_PARENT_EXTENSION));
return usingParentExtension;
}
if (usingParentExtension())
ClassLoader parentClassLoader = ClassUtils.getClassLoader(null).getParent();
Iterator<ExtensionStorageInfo> extIt = extensionStorage.iterator();
while (extIt.hasNext())
ExtensionStorageInfo extensionInfo = extIt.next();
extension.getClass().equals(extensionInfo.getExtension().getClass()) &&
extensionInfo.getClassLoader().equals(parentClassLoader))
{
return (T) extensionInfo.getExtension();
}
public static String getPropertyValue(String key, String defaultValue, boolean evaluateVariables)
{
String value = getPropertyValue(key, defaultValue);
if (value != null && evaluateVariables)
{
int startVar = 0;
while ((startVar = value.indexOf("${", startVar)) >= 0)
{
int endVar = value.indexOf("}", startVar);
if (endVar <= 0)
{
break;
}
if (variable.isEmpty())
{
break;
}
String variableValue = getPropertyValue(variable, null, true);
if (variableValue != null)
{
}
}
}
return value;
}
TypedResolver<T> evaluateVariables(boolean evaluateVariables);
private boolean evaluateVariables = false;
public TypedResolver<T> evaluateVariables(boolean evaluateVariables)
{
this.evaluateVariables = evaluateVariables;
return this;
}
@Override
value = getPropertyValue(keyResolved, null, evaluateVariables);
value = getPropertyValue(keyResolved, null, evaluateVariables);
value = getPropertyValue(keyResolved, null, evaluateVariables);
value = getPropertyValue(keyResolved, null, evaluateVariables);
import org.apache.deltaspike.core.spi.throttling.ThrottledStrategy;
private ThrottledStrategy throttledStrategy;
return throttledStrategy.execute(ic);
import org.apache.deltaspike.core.spi.future.FutureableStrategy;
@Futureable
private FutureableStrategy futureableStrategy;
return futureableStrategy.execute(ic);
import org.apache.deltaspike.core.spi.lock.LockedStrategy;
private LockedStrategy lockedStrategy;
return lockedStrategy.execute(ic);
TypedResolver<T> logChanges(boolean logChanges);
private boolean logChanges = false;
public TypedResolver<T> logChanges(boolean logChanges)
{
this.logChanges = logChanges;
return this;
}
@Override
if (logChanges && (value != null && lastValue == null || !value.equals(lastValue)) )
{
LOG.log(Level.INFO, "New value {0} for key {1}.",
new Object[]{filterConfigValueForLog(keyOriginal, valueStr), keyOriginal});
}
@Nonbinding
boolean evaluateVariables() default true;
resolver.evaluateVariables(configProperty.evaluateVariables());
@Inject
@ConfigProperty(name = "testDbConfig")
private String dbConfig;
public String getDbConfig()
{
return dbConfig;
}
if (delegatedWindowMode)
return;
String windowId = clientWindow.getWindowId(context);
windowId = secureWindowId(windowId);
import java.util.concurrent.TimeUnit;
interface TimeoutCustomization
{
Integer FUTUREABLE_TERMINATION_TIMEOUT_IN_MILLISECONDS =
ConfigResolver.resolve("deltaspike.futureable.termination-timeout_in_milliseconds")
.as(Integer.class)
.withCurrentProjectStage(true)
.withDefault((int) TimeUnit.MINUTES.toMillis(1))
.getValue();
}
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
final long timeout = CoreBaseConfig.TimeoutCustomization.FUTUREABLE_TERMINATION_TIMEOUT_IN_MILLISECONDS;
return getPropertyValue(key, defaultValue, true);
String value = getPropertyValue(key, evaluateVariables);
return fallbackToDefaultIfEmpty(key, value, defaultValue);
return getPropertyValue(key, true);
}
public static String getPropertyValue(String key, boolean evaluateVariables)
{
if (evaluateVariables)
{
int startVar = 0;
while ((startVar = value.indexOf("${", startVar)) >= 0)
{
int endVar = value.indexOf("}", startVar);
if (endVar <= 0)
{
break;
}
if (varName.isEmpty())
{
break;
}
String variableValue = getPropertyValue(varName, true);
if (variableValue != null)
{
}
}
}
interface ParentExtensionCustomization
{
Boolean PARENT_EXTENSION_ENABLED =
ConfigResolver.resolve("deltaspike.parent.extension.enabled")
.as(Boolean.class)
.withCurrentProjectStage(true)
.withDefault(Boolean.FALSE)
.getValue();
}
import org.apache.deltaspike.core.api.config.base.CoreBaseConfig;
return CoreBaseConfig.ParentExtensionCustomization.PARENT_EXTENSION_ENABLED;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
private Map<String, Object> sessionMap = new ConcurrentHashMap<String, Object>();
return this.sessionMap.get(name);
return getAttribute(name);
this.sessionMap.put(name, value);
setAttribute(name, value);
this.sessionMap.remove(name);
removeAttribute(name);
this.sessionMap.clear();
if (facesContext != null && facesContext.getCurrentPhaseId() != null)
if (facesContext == null || facesContext.getCurrentPhaseId() == null)
long now = -1;
now = System.currentTimeMillis();
import java.util.Arrays;
import java.util.LinkedList;
private static final boolean IS_WELD1;
private static final ThreadLocal<LinkedList<CallKey>> STACK = new ThreadLocal<LinkedList<CallKey>>()
{
@Override
protected LinkedList<CallKey> initialValue()
{
return new LinkedList<CallKey>();
}
};
boolean weld1 = false;
try
{
final Class<?> impl = Thread.currentThread().getContextClassLoader()
.loadClass("org.jboss.weld.manager.BeanManagerImpl");
final Package pck = impl.getPackage();
weld1 = "Weld Implementation".equals(pck.getImplementationTitle())
&& pck.getSpecificationVersion() != null && pck.getSpecificationVersion().startsWith("1.1.");
}
catch (final Throwable cnfe)
{
}
IS_WELD1 = weld1;
}
final CallKey invocationKey;
if (IS_WELD1)
{
invocationKey = new CallKey(ic);
final LinkedList<CallKey> stack = STACK.get();
if (!stack.isEmpty() && stack.getLast().equals(invocationKey))
{
try
{
return ic.proceed();
}
finally
{
if (stack.isEmpty())
{
STACK.remove();
}
}
}
}
}
else
{
invocationKey = null;
}
final LinkedList<CallKey> callStack;
if (IS_WELD1)
{
callStack = STACK.get();
callStack.add(invocationKey);
}
else
{
callStack = null;
}
finally
{
if (IS_WELD1)
{
callStack.removeLast();
if (callStack.isEmpty())
{
STACK.remove();
}
}
}
private static final class CallKey
{
private final InvocationContext ic;
private final int hash;
private CallKey(final InvocationContext ic)
{
this.ic = ic;
final Object[] parameters = ic.getParameters();
}
@Override
public boolean equals(final Object o)
{
return this == o || !(o == null || getClass() != o.getClass()) && equals(ic, CallKey.class.cast(o).ic);
}
@Override
public int hashCode()
{
return hash;
}
private boolean equals(final InvocationContext ic1, final InvocationContext ic2)
{
final Object[] parameters1 = ic1.getParameters();
final Object[] parameters2 = ic2.getParameters();
return ic2.getMethod().equals(ic1.getMethod()) &&
(parameters1 == parameters2 ||
(parameters1 != null && parameters2 != null && Arrays.equals(parameters1, ic2.getParameters())));
}
}
if (logChanges && (value != null && !value.equals(lastValue) || (value == null && lastValue != null)) )
lastValue = value;
entityManager.getTransaction();
private int maxWindowIdLength = 10;
if (windowId != null && windowId.length() > this.maxWindowIdLength)
windowId = windowId.substring(0, this.maxWindowIdLength);
maxWindowIdLength = ClientWindowHelper.getMaxWindowIdLength();
private boolean withDefault = false;
withDefault = true;
withDefault = true;
if (withDefault)
{
value = fallbackToDefaultIfEmpty(keyResolved, value, defaultValue);
}
value = getPropertyValue(keyResolved, evaluateVariables);
this.params = Parameters.create(method, this.args, repoMethod);
import java.util.regex.Matcher;
import java.util.regex.Pattern;
private int definedMaxResults = 0;
if (this.methodName != null)
{
this.parseMaxResults();
}
public int getDefinedMaxResults()
return definedMaxResults;
}
private void parseMaxResults()
{
if (this.methodName.matches(FIND_FIRST_PREFIX_PATTERN))
{
Matcher matcher = DIGIT_PATTERN.matcher(this.methodName);
if (matcher.find())
{
this.definedMaxResults = Integer.parseInt(matcher.group());
}
}
}
private enum KnownQueryPrefix
{
DEFAULT(DEFAULT_PREFIX, SingleResultType.JPA),
FIND_FIRST(FIND_FIRST_PREFIX, SingleResultType.JPA)
public String removePrefix(String queryPart)
return queryPart.replaceFirst(FIND_FIRST_PREFIX,"");
OPTIONAL(DEFAULT_OPT_PREFIX,SingleResultType.OPTIONAL),
ANY(DEFAULT_ANY_PREFIX, SingleResultType.ANY),
DELETE_DEFAULT(DEFAULT_DELETE_PREFIX, SingleResultType.ANY),
REMOVE_DEFAULT(DEFAULT_REMOVE_PREFIX, SingleResultType.ANY);
private final SingleResultType singleResultType;
KnownQueryPrefix(String prefix, SingleResultType singleResultType)
this.singleResultType = singleResultType;
public SingleResultType getStyle()
{
return this.singleResultType;
}
if (name.matches(FIND_FIRST_PREFIX_PATTERN))
{
return FIND_FIRST;
}
public int getDefinedMaxResults()
{
return this.methodPrefix.getDefinedMaxResults();
}
import org.apache.deltaspike.data.impl.meta.RepositoryMethod;
public static Parameters create(Method method, Object[] parameters, RepositoryMethod repositoryMethod)
int max = extractSizeRestriction(method, repositoryMethod);
private static int extractSizeRestriction(Method method, RepositoryMethod repositoryMethod)
return repositoryMethod.getDefinedMaxResults();
public abstract List<Simple> findFirst2ByName(String name);
public abstract List<Simple> findTop2ByName(String name);
String orderByPart = orderByParts[0];
String prefix = methodPrefix.getPrefix();
return !prefix.equals(orderByPart) && !orderByPart.matches(prefix);
private static final String FIND_ALL_PREFIX = "findAll";
int getDefinedMaxResults()
ALL(FIND_ALL_PREFIX, SingleResultType.JPA),
public boolean matches(String name)
{
return name.matches(FIND_FIRST_PREFIX_PATTERN);
}
@Override
public boolean matches(String name)
{
return name.startsWith(getPrefix());
}
if (mapping.matches(name))
public abstract List<Simple> findFirst3OrderByName();
public abstract List<Simple> findAllOrderByName();
boolean isEntityClass = !Object.class.equals(repoEntity) && EntityVerifier.INSTANCE.verify(repoEntity);
public static final EntityVerifier INSTANCE = new EntityVerifier();
return EntityVerifier.INSTANCE.verify(entityClass);
if (tableAnnotation != null && StringUtils.isNotEmpty(tableAnnotation.name()))
{
return tableAnnotation.name();
}
EntityType<?> entityType = entityManager.getMetamodel().entity(entityClass);
return entityType.getName();
boolean isEntityClass = !Object.class.equals(repoEntity) && EntityUtils.isEntityClass(repoEntity);
return entityClass.isAnnotationPresent(Entity.class)
|| PersistenceUnitDescriptorProvider.getInstance().isEntity(entityClass);
import java.lang.annotation.Inherited;
@Inherited
import org.apache.deltaspike.data.api.Query;
import javax.persistence.QueryHint;
import java.util.HashMap;
import java.util.Map;
Query query = context.getMethod().getAnnotation(Query.class);
if (query != null && query.hints().length > 0)
{
Map<String, Object> hints = new HashMap<String, Object>();
for (QueryHint hint : query.hints())
{
hints.put(hint.name(), hint.value());
}
return entityManager().find(entityClass(), primaryKey, hints);
}
else
{
return entityManager().find(entityClass(), primaryKey);
}
public static boolean containsPossiblyGenericMethod(Class<?> targetClass, Method method)
{
return extractPossiblyGenericMethod(targetClass, method) != null;
}
public static Method extractPossiblyGenericMethod(Class<?> clazz, Method sourceMethod)
{
Method exactMethod = extractMethod(clazz, sourceMethod);
if (exactMethod == null)
{
String methodName = sourceMethod.getName();
Class<?>[] parameterTypes = sourceMethod.getParameterTypes();
for (Method method : clazz.getMethods())
{
if (method.getName().equals(methodName) &&
allSameType(method.getParameterTypes(), parameterTypes))
{
return method;
}
}
return null;
}
else
{
return exactMethod;
}
}
private static boolean allSameType(Class<?>[] left, Class<?>[] right)
{
if (left.length != right.length)
{
return false;
}
{
if (!left[p].isAssignableFrom(right[p]))
{
return false;
}
}
return true;
}
if (ClassUtils.containsPossiblyGenericMethod(bean.getBeanClass(), context.getMethod()))
Method extract = ClassUtils.extractPossiblyGenericMethod(target.getClass(), method);
import org.apache.deltaspike.data.api.EntityRepository;
import org.apache.deltaspike.data.api.Query;
import javax.persistence.QueryHint;
public interface SimpleIntermediateRepository extends EntityRepository<Simple, Long>
@Query(hints = {
@QueryHint(name = "openjpa.hint.OptimizeResultCount", value = "some.invalid.value"),
@QueryHint(name = "org.hibernate.comment", value = "I'm a little comment short and stout")
})
Simple findBy(Long id);
boolean returnsEntity() default true;
if (query.returnsEntity())
{
result = params.applyTo(entityManager.createNativeQuery(jpqlQuery, context.getEntityClass()));
}
else
{
result = params.applyTo(entityManager.createNativeQuery(jpqlQuery));
}
import java.util.List;
@Query(value = "select name from simple_table", isNative = true, returnsEntity = false)
List<String> findAllNames();
import org.apache.deltaspike.cdise.api.ContextControl;
import org.apache.deltaspike.test.utils.CdiContainerUnderTest;
import org.jboss.shrinkwrap.api.ShrinkWrap;
public static JavaArchive getContextControlForDeployment()
{
JavaArchive jar = ShrinkWrap.create(JavaArchive.class, "cdi-control.jar")
.addClass(ContextControl.class);
if (CdiContainerUnderTest.is("owb"))
{
jar.addPackage("org.apache.deltaspike.cdise.owb");
}
return jar;
}
private EntityManager entityManager;
BeanProvider.getDependent(ref.getEntityManagerResolverClass()));
ref.setEntityManager(entityManager);
RepositoryMethod repoMethod = components.lookupMethod(repo, method);
public RepositoryMethod lookupMethod(RepositoryComponent component, Method method)
{
return component.lookupMethod(method);
}
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
QueryBuilder builder = BeanProvider.getContextualReference(
return new WrappedQueryBuilder(builder);
return builder;
private QueryBuilderFactory queryBuilderFactory;
QueryBuilder builder = queryBuilderFactory.build(repoMethod, queryContext);
import org.apache.deltaspike.core.util.OptionalUtil;
Object result = null;
result = query.getSingleResult();
break;
result = queryResult.size() > 0 ? queryResult.get(0) : null;
}
if (context.isOptional())
{
return OptionalUtil.wrap(result);
}
else
{
return result;
SingleResultType baseSingleResultType = repoMethod.getSingleResultStyle();
if (repoMethod.isOptional() && baseSingleResultType == SingleResultType.JPA)
{
return SingleResultType.OPTIONAL;
}
else
{
return baseSingleResultType;
}
public boolean isOptional()
{
return this.repoMethod.isOptional();
}
import org.apache.deltaspike.core.util.OptionalUtil;
private final boolean isOptional;
this.isOptional = OptionalUtil.isOptionalReturned(this.method);
public boolean isOptional()
{
return this.isOptional;
}
private DependentProvider<? extends EntityManager> entityManagerDependentProvider;
private Class<? extends EntityManagerResolver> entityManagerResolverClass;
private DependentProvider<? extends EntityManagerResolver> entityManagerResolverDependentProvider;
if (entityManagerDependentProvider != null)
{
entityManagerDependentProvider.destroy();
}
public DependentProvider<? extends EntityManager> getEntityManagerDependentProvider()
{
return entityManagerDependentProvider;
}
public void setEntityManagerDependentProvider(
DependentProvider<? extends EntityManager> entityManagerDependentProvider)
{
this.entityManagerDependentProvider = entityManagerDependentProvider;
}
import java.lang.annotation.Annotation;
import java.util.Set;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
private volatile Boolean globalEntityManagerInitialized;
private boolean globalEntityManagerIsNormalScope;
private EntityManager globalEntityManager;
private void lazyInitGlobalEntityManager()
{
if (this.globalEntityManagerInitialized == null)
{
initGlobalEntityManager();
}
}
private synchronized void initGlobalEntityManager()
{
if (this.globalEntityManagerInitialized == null)
{
this.globalEntityManagerInitialized = true;
BeanManager beanManager = BeanManagerProvider.getInstance().getBeanManager();
Set<Bean<?>> beans = beanManager.getBeans(EntityManager.class);
if (!beans.isEmpty() && beans.size() == 1)
{
Class<? extends Annotation> scope = beanManager.resolve(beans).getScope();
globalEntityManagerIsNormalScope = beanManager.isNormalScope(scope);
if (globalEntityManagerIsNormalScope)
{
Bean<?> bean = beans.iterator().next();
globalEntityManager = (EntityManager) beanManager.getReference(bean,
EntityManager.class,
beanManager.createCreationalContext(bean));
}
}
else
{
throw new IllegalArgumentException(
"None or multiple EntityManager's found with the default qualifier.");
}
}
}
lazyInitGlobalEntityManager();
if (globalEntityManagerIsNormalScope)
{
ref.setEntityManager(globalEntityManager);
}
else
{
ref.setEntityManagerDependentProvider(
BeanProvider.getDependent(EntityManager.class));
ref.setEntityManager(
ref.getEntityManagerDependentProvider().get());
}
Bean<?> bean = beanManager.resolve(beans);
globalEntityManagerIsNormalScope = beanManager.isNormalScope(bean.getScope());
globalEntityManager = (EntityManager) beanManager.getReference(bean,
EntityManager.class,
beanManager.createCreationalContext(bean));
if (bean == null)
{
throw new IllegalStateException("Could not find EntityManager with default qualifier.");
}
if (globalEntityManagerIsNormalScope)
{
globalEntityManager = (EntityManager) beanManager.getReference(bean,
EntityManager.class,
beanManager.createCreationalContext(bean));
}
static
{
return optionalSupported && optionalClass.isAssignableFrom(method.getReturnType());
import java.util.Collection;
import org.apache.deltaspike.core.util.OptionalUtil;
import org.apache.deltaspike.core.util.StreamUtil;
Object result = invoke(delegate, context);
if (result instanceof Collection && StreamUtil.isStreamReturned(context.getMethod()))
{
return StreamUtil.wrap(result);
}
else if (OptionalUtil.isOptionalReturned(context.getMethod()))
{
return OptionalUtil.wrap(result);
}
else
{
return result;
}
import org.apache.deltaspike.core.util.StreamUtil;
if (streams())
{
return new StreamQueryProcessor();
}
private boolean streams()
{
return StreamUtil.isStreamReturned(method);
}
private static final class StreamQueryProcessor implements QueryProcessor
{
@Override
public Object executeQuery(Query query, CdiQueryInvocationContext context)
{
return StreamUtil.wrap(query.getResultList());
}
}
import org.apache.deltaspike.core.util.OptionalUtil;
public Object findOptional(PK primaryKey)
{
Object found = null;
try
{
found = findBy(primaryKey);
}
catch (Exception e)
{
}
return OptionalUtil.wrap(found);
}
import javax.persistence.Entity;
import java.lang.reflect.ParameterizedType;
import java.util.List;
Class<?> resultType = getQueryResultType(context.getMethod());
if (isEntityType(resultType))
result = params.applyTo(entityManager.createNativeQuery(jpqlQuery, resultType));
private boolean isEntityType(Class<?> cls)
{
return cls.getAnnotation(Entity.class) != null;
}
private Class<?> getQueryResultType(Method m)
{
Class<?> rt = m.getReturnType();
if (rt.isAssignableFrom(List.class) && rt != Object.class)
{
ParameterizedType pt = (ParameterizedType) m.getGenericReturnType();
return (Class<?>) pt.getActualTypeArguments()[0];
}
return rt;
}
@Query(value = "select name from simple_table", isNative = true)
import java.util.List;
import org.apache.deltaspike.data.api.Query;
import org.apache.deltaspike.data.test.domain.Simple;
@Query("SELECT s FROM Simple s WHERE s.name = ?1")
Simple findByName(String name);
@Query("SELECT s FROM Simple s WHERE s.name = ?1")
List<Simple> findByName2(String name);
import java.util.stream.Stream;
@Query(value = "select name from simple_table", isNative = true)
Stream<String> findSimpleNames();
import java.util.HashMap;
import java.util.Map;
private final Map<Method, Bean<DelegateQueryHandler>> lookupCache
= new HashMap<Method, Bean<DelegateQueryHandler>>();
DelegateQueryHandler delegate = lookup(context);
private DelegateQueryHandler lookup(CdiQueryInvocationContext context)
Bean<DelegateQueryHandler> selectedBean = lookupCache.get(context.getMethod());
if (selectedBean == null)
Set<Bean<DelegateQueryHandler>> beans = BeanProvider
.getBeanDefinitions(DelegateQueryHandler.class, true, true);
for (Bean<DelegateQueryHandler> bean : beans)
if (ClassUtils.containsPossiblyGenericMethod(bean.getBeanClass(), context.getMethod()))
selectedBean = bean;
if (selectedBean != null)
{
lookupCache.put(context.getMethod(), selectedBean);
}
}
if (selectedBean != null)
{
CreationalContext<DelegateQueryHandler> cc = beanManager.createCreationalContext(selectedBean);
DelegateQueryHandler instance = (DelegateQueryHandler) beanManager.getReference(
selectedBean, DelegateQueryHandler.class, cc);
if (selectedBean.getScope().equals(Dependent.class))
{
context.addDestroyable(new BeanDestroyable<DelegateQueryHandler>(selectedBean, instance, cc));
}
return instance;
Method extract = ClassUtils.extractPossiblyGenericMethod(delegate.getClass(), context.getMethod());
return extract.invoke(delegate, context.getMethodParameters());
this.proxyClass = proxyFactory.getProxyClass(beanManager, targetClass);
Constructor<T> constructor = proxyClass.getConstructor(InvocationHandler.class);
public <T> Class<T> getProxyClass(BeanManager beanManager, Class<T> targetClass)
proxyClass = createProxyClass(beanManager, targetClass.getClassLoader(), targetClass);
Class<T> targetClass)
Class proxyClass = INSTANCE.getProxyClass(beanManager, obj.getClass());
Constructor constructor = proxyClass.getConstructor(InvocationHandler.class);
byte[] proxyBytes = generateProxyClassBytes(targetClass,
Type delegateInvocationHandlerType = Type.getType(InvocationHandler.class);
import org.apache.deltaspike.core.api.provider.BeanProvider;
private volatile Boolean initialized;
private InterceptorLookup interceptorLookup;
lazyInit();
List<Interceptor<?>> interceptors = interceptorLookup.lookup(proxy, method);
private void lazyInit()
if (this.initialized == null)
init();
}
}
private synchronized void init()
{
if (this.initialized == null)
{
this.initialized = true;
this.interceptorLookup = BeanProvider.getContextualReference(InterceptorLookup.class);
public interface EntityRepository<E, PK extends Serializable> extends EntityPersistenceRepository<E, PK>,
EntityCountRepository<E>
import javax.enterprise.context.Dependent;
@Dependent
import org.apache.deltaspike.core.api.provider.BeanProvider;
DelegateManualInvocationHandler handler = BeanProvider.getContextualReference(DelegateManualInvocationHandler.class);
return handler.invoke(proxy, method, parameters);
import org.apache.deltaspike.core.api.provider.BeanProvider;
InterceptManualInvocationHandler handler = BeanProvider.getContextualReference(InterceptManualInvocationHandler.class);
return handler.invoke(proxy, method, parameters);
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
DelegateManualInvocationHandler handler = BeanProvider
.getContextualReference(DelegateManualInvocationHandler.class);
import javax.enterprise.context.ApplicationScoped;
@ApplicationScoped
InterceptManualInvocationHandler handler = BeanProvider
.getContextualReference(InterceptManualInvocationHandler.class);
final List<Object> mapped = new ArrayList<Object>(result.size());
return mapped;
return new ArrayList<Object>();
if (beanManager != null)
if (clientWindow.isInitialRedirectSupported(context))
methodName = Character.toString(Character.toUpperCase(fieldName.charAt(0)));
return Integer.toString((new Random()).nextInt() % 10000);
return Integer.toString((int) Math.floor(Math.random() * 999));
if (urls.isEmpty())
return !queryResult.isEmpty() ? queryResult.get(0) : null;
result = !queryResult.isEmpty() ? queryResult.get(0) : null;
return !queryResult.isEmpty() ? queryResult.get(0) : null;
if (!oldTci.isEmpty())
&& !interceptMethods.isEmpty()
if (!exceptionsToCatch.isEmpty())
if (interceptors != null && !interceptors.isEmpty())
else if (!this.foundManagedJobClasses.isEmpty())
if (violations != null && !violations.isEmpty())
String value = getPropertyValue(
key,
new ConfigResolverContext()
.setEvaluateVariables(evaluateVariables));
return getPropertyValue(
key,
new ConfigResolverContext().setEvaluateVariables(true));
return getPropertyValue(
key,
new ConfigResolverContext()
.setEvaluateVariables(evaluateVariables));
ConfigResolverContext configResolverContext =
new ConfigResolverContext()
.setProjectStageAware(true)
.setEvaluateVariables(true);
configResolverContext.setProjectStageAware(false);
value = getPropertyValue(key, configResolverContext);
private static String getPropertyValue(String key, ConfigResolverContext configResolverContext)
{
ConfigSource[] appConfigSources = getConfigSources();
String value;
for (ConfigSource configSource : appConfigSources)
{
value = configSource.getPropertyValue(key);
if (value != null)
{
LOG.log(Level.FINE, "found value {0} for key {1} in ConfigSource {2}.",
new Object[]{filterConfigValueForLog(key, value), key, configSource.getConfigName()});
if (configResolverContext.isEvaluateVariables())
{
value = resolveVariables(value, configResolverContext);
}
return filterConfigValue(key, value);
}
LOG.log(Level.FINER, "NO value found for key {0} in ConfigSource {1}.",
new Object[]{key, configSource.getConfigName()});
}
return null;
}
private static String resolveVariables(String value, ConfigResolverContext configResolverContext)
{
int startVar = 0;
while ((startVar = value.indexOf("${", startVar)) >= 0)
{
int endVar = value.indexOf("}", startVar);
if (endVar <= 0)
{
break;
}
if (varName.isEmpty())
{
break;
}
String variableValue;
if (configResolverContext.isProjectStageAware())
{
variableValue = getProjectStageAwarePropertyValue(varName);
}
else
{
variableValue = getPropertyValue(varName, true);
}
if (variableValue != null)
{
}
}
return value;
}
import javax.enterprise.inject.spi.Interceptor;
import javax.inject.Inject;
@Inject
new ManualInvocationContext(this, interceptors, proxy, method, parameters, null);
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.management.MBeanParameterInfo;
import org.apache.deltaspike.core.api.config.ConfigResolver;
import org.apache.deltaspike.core.api.jmx.JmxBroadcaster;
import org.apache.deltaspike.core.api.jmx.JmxManaged;
import org.apache.deltaspike.core.api.jmx.JmxParameter;
import org.apache.deltaspike.core.api.jmx.MBean;
import org.apache.deltaspike.core.api.jmx.NotificationInfo;
import org.apache.deltaspike.core.api.provider.BeanManagerProvider;
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.util.ExceptionUtils;
import org.apache.deltaspike.core.util.ParameterUtil;
Annotation[][] parametersAnnotations = method.getParameterAnnotations();
Class<?>[] parameterTypes = method.getParameterTypes();
MBeanParameterInfo[] parameterInfos = new MBeanParameterInfo[parameterTypes.length];
{
String parameterDescription = null;
String java8ParameterName = ParameterUtil.getName(method, i);
if (java8ParameterName != null)
{
parameterName = java8ParameterName;
}
{
if (parametersAnnotations[i][j] instanceof JmxParameter)
{
JmxParameter jmxParameter = (JmxParameter) parametersAnnotations[i][j];
if (!"".equals(jmxParameter.name()))
{
parameterName = jmxParameter.name();
}
if (!"".equals(jmxParameter.description()))
{
parameterDescription = jmxParameter.description();
}
}
}
parameterInfos[i] = new MBeanParameterInfo(parameterName,
parameterTypes[i].getName(),
parameterDescription
);
}
operationInfos.add(new MBeanOperationInfo(method.getName(),
operationDescr,
parameterInfos,
method.getReturnType().getName(),
MBeanOperationInfo.UNKNOWN
));
import org.apache.deltaspike.core.api.jmx.JmxParameter;
public int multiply(@JmxParameter(name = "multiplier", description = "the multiplier") final int n)
!void.class.isAssignableFrom(returnType) &&
throw new IllegalArgumentException("Return type should be a CompletableStage, Future or Void");
if (void.class.isAssignableFrom(returnType))
{
pool.submit(invocation);
return null;
}
import java.util.concurrent.CountDownLatch;
@Futureable
public void thatSLong(final long sleep, CountDownLatch latch) {
try
{
Thread.sleep(sleep);
latch.countDown();
}
catch (final InterruptedException e)
{
Thread.interrupted();
throw new IllegalStateException(e);
}
}
implements EntityRepository<E, PK>, EntityPersistenceRepository<E, PK>,
EntityCountRepository<E>
import javax.enterprise.context.ConversationScoped;
import javax.enterprise.context.RequestScoped;
import javax.enterprise.context.SessionScoped;
ctxCtrl.stopContext(ConversationScoped.class);
ctxCtrl.stopContext(RequestScoped.class);
ctxCtrl.stopContext(SessionScoped.class);
stopApplicationScope();
broadcastInitializedJsfRequestEvent(facesContext);
broadcastInitializedJsfRequestEvent(facesContext);
import org.picketlink.authentication.event.PostLoggedOutEvent;
public void handleLogout(@Observes PostLoggedOutEvent event)
{
this.viewNavigationHandler.navigateTo(Pages.Login.class);
}
}
@Secured(LoggedInAccessDecisionVoter.class)
{
class Test implements ViewConfig
{
}
catch (InvocationTargetException e)
final Throwable cause = e.getCause();
if (cause instanceof Error)
{
throw (Error) cause;
}
if (cause instanceof MBeanException)
{
throw (MBeanException) cause;
}
}
catch (IllegalAccessException e)
{
}
catch (IllegalArgumentException e)
{
AbstractEntityRepository<E, PK> implements FullEntityRepository<E, PK>
@Nonbinding
Class<? extends ConfigResolver.Converter> converter() default ConfigResolver.Converter.class;
import java.lang.reflect.Type;
<N> TypedResolver<N> as(Type type, Converter<N> converter);
private Type configEntryType = String.class;
@SuppressWarnings("unchecked")
public <N> TypedResolver<N> as(Type clazz, Converter<N> converter)
{
configEntryType = clazz;
this.converter = converter;
return (TypedResolver<N>) this;
}
@Override
import java.lang.reflect.Type;
import org.apache.deltaspike.core.api.provider.BeanProvider;
return getUntypedPropertyValue(injectionPoint, ipCls);
}
protected <T> T getUntypedPropertyValue(InjectionPoint injectionPoint, Type ipCls)
{
return readEntry(configProperty.name(), configProperty.defaultValue(), ipCls,
configProperty.converter(), configProperty.parameterizedBy(),
configProperty.projectStageAware(), configProperty.evaluateVariables());
public <T> T readEntry(final String key, final String stringDefault, final Type ipCls,
final Class<? extends ConfigResolver.Converter> converterType,
final String parameterizedBy, final boolean projectStageAware, final boolean evaluate)
{
final ConfigResolver.UntypedResolver<String> untypedResolver = ConfigResolver.resolve(key);
final ConfigResolver.TypedResolver<T> resolver =
(ConfigResolver.Converter.class == converterType ?
untypedResolver.as(Class.class.cast(ipCls)) :
untypedResolver.as(ipCls, BeanProvider.getContextualReference(converterType)))
.withCurrentProjectStage(projectStageAware);
if (!ConfigProperty.NULL.equals(stringDefault))
{
resolver.withStringDefault(stringDefault);
}
if (!ConfigProperty.NULL.equals(parameterizedBy))
{
resolver.parameterizedBy(parameterizedBy);
}
return resolver.evaluateVariables(evaluate).getValue();
}
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.Produces;
import javax.enterprise.inject.Typed;
import javax.enterprise.inject.spi.AfterBeanDiscovery;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.InjectionPoint;
import javax.enterprise.inject.spi.ProcessBean;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import org.apache.deltaspike.core.api.config.ConfigProperty;
import org.apache.deltaspike.core.spi.config.BaseConfigPropertyProducer;
private final Set<Type> dynamicConfigTypes = new HashSet<Type>();
private Bean<DynamicBeanProducer> dynamicProducer;
public void findDynamicProducer(@Observes ProcessBean<DynamicBeanProducer> processBean)
{
dynamicProducer = processBean.getBean();
}
public void collectDynamicTypes(@Observes ProcessBean<?> processBean)
{
for (final InjectionPoint ip : processBean.getBean().getInjectionPoints())
{
final ConfigProperty annotation = ip.getAnnotated().getAnnotation(ConfigProperty.class);
if (annotation == null || annotation.converter() == ConfigResolver.Converter.class)
{
continue;
}
dynamicConfigTypes.add(ip.getType());
}
}
public void addDynamicBean(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager bm)
{
if (dynamicProducer != null && !dynamicConfigTypes.isEmpty())
{
afterBeanDiscovery.addBean(new DynamicBean(dynamicProducer, dynamicConfigTypes));
}
}
@ApplicationScoped
static class DynamicBeanProducer extends BaseConfigPropertyProducer
{
@Produces
@ConfigProperty(name = "ignored")
public Object create(final InjectionPoint ip)
{
return super.getUntypedPropertyValue(ip, ip.getType());
}
}
@Typed
private static final class DynamicBean<T> implements Bean<T>
{
private final Bean<T> producer;
private final Set<Type> types;
private DynamicBean(final Bean<T> producer, final Set<Type> types)
{
this.producer = producer;
this.types = types;
}
@Override
public Set<Type> getTypes()
{
return types;
}
@Override
public Set<Annotation> getQualifiers()
{
return producer.getQualifiers();
}
@Override
public Class<? extends Annotation> getScope()
{
return producer.getScope();
}
@Override
public String getName()
{
return producer.getName();
}
@Override
public boolean isNullable()
{
return producer.isNullable();
}
@Override
public Set<InjectionPoint> getInjectionPoints()
{
return producer.getInjectionPoints();
}
@Override
public Class<?> getBeanClass()
{
return producer.getBeanClass();
}
@Override
public Set<Class<? extends Annotation>> getStereotypes()
{
return producer.getStereotypes();
}
@Override
public boolean isAlternative()
{
return producer.isAlternative();
}
@Override
public T create(final CreationalContext<T> creationalContext)
{
return producer.create(creationalContext);
}
@Override
public void destroy(final T t, final CreationalContext<T> creationalContext)
{
producer.destroy(t, creationalContext);
}
}
import java.lang.reflect.Type;
private <T> T getPropertyWithException(InjectionPoint ip, Type ipCls)
return getUntypedPropertyValue(ip, ipCls);
import org.apache.deltaspike.core.api.config.ConfigResolver;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
@Inject
@ConfigProperty(name = "urlList", converter = UrlList.class, defaultValue = "http://localhost,http://127.0.0.1")
private List<URL> urlList;
@Inject
@ConfigProperty(name = "urlListFromProperties", converter = UrlList.class)
private List<URL> urlListFromProperties;
public List<URL> getUrlList() {
return urlList;
}
public List<URL> getUrlListFromProperties() {
return urlListFromProperties;
}
public static class UrlList implements ConfigResolver.Converter<List<URL>>
{
@Override
public List<URL> convert(final String value)
{
final List<URL> urls = new ArrayList<URL>();
if (value != null)
{
for (final String segment : value.split(","))
{
try
{
urls.add(new URL(segment));
}
catch (final MalformedURLException e)
{
throw new IllegalArgumentException(e);
}
}
}
return urls;
}
}
import org.apache.deltaspike.core.api.provider.BeanProvider;
import org.apache.deltaspike.core.spi.config.ConfigFilter;
private final List<Bean<? extends ConfigSource>> cdiSources = new ArrayList<Bean<? extends ConfigSource>>();
private final List<Bean<? extends ConfigFilter>> cdiFilters = new ArrayList<Bean<? extends ConfigFilter>>();
public void findSources(@Observes ProcessBean<? extends ConfigSource> source)
{
final Class<?> beanClass = source.getBean().getBeanClass();
{
return;
}
cdiSources.add(source.getBean());
}
public void findFilters(@Observes ProcessBean<? extends ConfigFilter> filter)
{
cdiFilters.add(filter.getBean());
}
for (final Bean bean : cdiSources)
{
configSources.add(BeanProvider.getContextualReference(ConfigSource.class, bean));
}
for (final Bean bean : cdiFilters)
{
ConfigResolver.addConfigFilter(BeanProvider.getContextualReference(ConfigFilter.class, bean));
}
@Inject
@ConfigProperty(name = "custom-source.test")
private String customSourceValue;
public String getCustomSourceValue() {
return customSourceValue;
}
import org.apache.deltaspike.core.api.config.Filter;
import org.apache.deltaspike.core.api.config.Source;
if (!source.getAnnotated().isAnnotationPresent(Source.class)) {
if (!filter.getAnnotated().isAnnotationPresent(Filter.class)) {
return;
}
import org.apache.deltaspike.core.api.config.Filter;
@Filter
import org.apache.deltaspike.core.api.config.Source;
@Source
final ConfigResolver.TypedResolver<T> resolver = asResolver(
key, stringDefault, ipCls, converterType, parameterizedBy, projectStageAware, evaluate);
return resolver.getValue();
}
public <T> ConfigResolver.TypedResolver<T> asResolver(final String key, final String stringDefault,
final Type ipCls,
final Class<? extends ConfigResolver.Converter> converterType,
final String parameterizedBy,
final boolean projectStageAware, final boolean evaluate)
{
return resolver.evaluateVariables(evaluate);
import org.apache.deltaspike.core.api.config.Configuration;
import org.apache.deltaspike.core.api.literal.AnyLiteral;
import org.apache.deltaspike.core.api.literal.DefaultLiteral;
import org.apache.deltaspike.core.util.bean.BeanBuilder;
private final List<Class<?>> dynamicConfigurationBeanClasses = new ArrayList<Class<?>>();
public void findDynamicConfigurationBeans(@Observes ProcessAnnotatedType<?> pat)
{
if (!pat.getAnnotatedType().isAnnotationPresent(Configuration.class))
{
return;
}
final Class<?> javaClass = pat.getAnnotatedType().getJavaClass();
if (!javaClass.isInterface())
{
return;
}
dynamicConfigurationBeanClasses.add(javaClass);
}
if (!source.getAnnotated().isAnnotationPresent(Source.class))
{
if (!filter.getAnnotated().isAnnotationPresent(Filter.class))
{
public void addDynamicBeans(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager bm)
for (final Class<?> proxyType : dynamicConfigurationBeanClasses)
{
afterBeanDiscovery.addBean(new BeanBuilder(null)
.types(proxyType, Object.class)
.qualifiers(new DefaultLiteral(), new AnyLiteral())
.beanLifecycle(new ProxyConfigurationLifecycle(proxyType))
.scope(ApplicationScoped.class)
.passivationCapable(true)
.beanClass(proxyType)
.create());
}
String prefix() default "";
new ConfigurationHandler(
cacheFor <= 0 ? -1 : configuration.cacheUnit().toMillis(cacheFor), configuration.prefix()));
private final String prefix;
private ConfigurationHandler(final long cacheMs, final String prefix)
this.prefix = prefix;
import javax.enterprise.inject.Typed;
import javax.enterprise.inject.Typed;
import java.util.EventListener;
import java.util.Map;
import javax.servlet.Filter;
import javax.servlet.FilterRegistration;
import javax.servlet.ServletRegistration;
import javax.servlet.SessionCookieConfig;
import javax.servlet.SessionTrackingMode;
import javax.servlet.descriptor.JspConfigDescriptor;
@Override
public boolean setInitParameter(String name, String value)
{
return false;
}
@Override
public ServletRegistration.Dynamic addServlet(String servletName, String className)
throws IllegalArgumentException, IllegalStateException
{
return null;
}
@Override
public ServletRegistration.Dynamic addServlet(String servletName, Servlet servlet)
throws IllegalArgumentException, IllegalStateException
{
return null;
}
@Override
public ServletRegistration.Dynamic addServlet(String servletName, Class<? extends Servlet> clazz)
throws IllegalArgumentException, IllegalStateException
{
return null;
}
@Override
public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException
{
return null;
}
@Override
public ServletRegistration getServletRegistration(String servletName)
{
return null;
}
@Override
public Map<String, ? extends ServletRegistration> getServletRegistrations()
{
return null;
}
@Override
public FilterRegistration.Dynamic addFilter(String filterName, String className)
throws IllegalArgumentException, IllegalStateException
{
return null;
}
@Override
public FilterRegistration.Dynamic addFilter(String filterName, Filter filter)
throws IllegalArgumentException, IllegalStateException
{
return null;
}
@Override
public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass)
throws IllegalArgumentException, IllegalStateException
{
return null;
}
@Override
public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException
{
return null;
}
@Override
public FilterRegistration getFilterRegistration(String filterName)
{
return null;
}
@Override
public Map<String, ? extends FilterRegistration> getFilterRegistrations()
{
return null;
}
@Override
public void addListener(Class<? extends EventListener> listenerClass)
{
}
@Override
public void addListener(String className)
{
}
@Override
public <T extends EventListener> void addListener(T t)
{
}
@Override
public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException
{
return null;
}
@Override
public void declareRoles(String... roleNames)
{
}
@Override
public SessionCookieConfig getSessionCookieConfig()
{
return null;
}
@Override
public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes)
{
}
@Override
public Set<SessionTrackingMode> getDefaultSessionTrackingModes()
{
return null;
}
@Override
public int getEffectiveMajorVersion() throws UnsupportedOperationException
{
return 0;
}
@Override
public int getEffectiveMinorVersion() throws UnsupportedOperationException
{
return 0;
}
@Override
public Set<SessionTrackingMode> getEffectiveSessionTrackingModes()
{
return null;
}
@Override
public ClassLoader getClassLoader()
{
return null;
}
@Override
public JspConfigDescriptor getJspConfigDescriptor()
{
return null;
}
