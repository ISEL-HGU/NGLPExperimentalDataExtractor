 *
 *
            if (log.isDebugEnabled())
                log.debug("Found "  PERSISTENCE_UTIL_CLASSNAME  " on classpath.");
            if (log.isDebugEnabled())
                log.debug("Cannot find "  PERSISTENCE_UTIL_CLASSNAME 
            if (log.isDebugEnabled())
                log.debug("Instantiated an instance of " 
                    JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME  ".");
            if (log.isDebugEnabled()) log.debug(validationXmlFile  " found.");
            if (log.isDebugEnabled()) {
                log.debug(
 b/bval-core/src/main/java/org/apache/bval/BeanValidationContext.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval;

import org.apache.bval.model.*;

import java.util.IdentityHashMap;

import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.PropertyAccess;

/**
 * Description: Context during validation to help the {@link org.apache.bval.model.Validation}
 * and the {@link BeanValidator} do their jobs.
 * Used to bundle {@link BeanValidationContext} and {@link ValidationListener}
 * together <br/>
 * <b>This class is NOT thread-safe: a new instance will be created for each
 * validation
 * processing per thread.<br/></b>
 * <br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 12:30:01 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class BeanValidationContext<T extends ValidationListener>
      implements ValidationContext<T> {
    /** represent an unknown propertyValue. */
    private static final Object UNKNOWN = new Object();

    /** metainfo of current object. */
    private MetaBean metaBean;
    /** current object. */
    private Object bean;
    /** metainfo of current property. */
    private MetaProperty metaProperty;
    /**
     * cached value of current property.
     * Cached because of potential redundant access for different Validations
     */
    private Object propertyValue = UNKNOWN;

    /** access strategy used for previous access */
    private AccessStrategy access;

    /** set of objects already validated to avoid endless loops. */
    protected IdentityHashMap validatedObjects = new IdentityHashMap();

    /**
     * true when value is fixed, so that it will NOT be dynamically
     * determined from the annotated element or the metaProperty.
     * <b><br>Note: When value is UNKNOWN, it will be determined THE FIRST TIME
     * IT IS ACCESSED.</b>
     */
    private boolean fixed;

    /** listener notified of validation constraint violations. */
    private T listener;

    public BeanValidationContext(T listener) {
        this.listener = listener;
    }

    public T getListener() {
        return listener;
    }

    public void setListener(T listener) {
        this.listener = listener;
    }

    /**
     * add the object to the collection of validated objects to keep
     * track of them to avoid endless loops during validation.
     *
     * @return true when the object was not already validated in this context
     */
    public boolean collectValidated() {
        return validatedObjects.put(getBean(), Boolean.TRUE) == null;
    }

    /** @return true when the object has already been validated in this context */
    public boolean isValidated(Object object) {
        return validatedObjects.containsKey(object);
    }

    /**
     * Clear map of validated objects (invoke when you want to 'reuse' the
     * context for different validations)
     */
    public void resetValidated() {
        validatedObjects.clear();
    }

    public void setBean(Object aBean, MetaBean aMetaBean) {
        bean = aBean;
        metaBean = aMetaBean;
        metaProperty = null;
        unknownValue();
    }

    /**
     * get the cached value or access it somehow (via field or method)<br>
     * <b>you should prefer getPropertyValue(AccessStrategy) instead of this method</b>
     *
     * @return the current value of the property accessed by reflection
     * @throws IllegalArgumentException - error accessing attribute (config error, reflection problem)
     * @throws IllegalStateException    - when no property is currently set in the context (application logic bug)
     */
    public Object getPropertyValue() {
        if (access == null) { // undefined access strategy
            return getPropertyValue(
                  new PropertyAccess(bean.getClass(), metaProperty.getName()));
        } else {
            return getPropertyValue(access);
        }
    }

    /** get the value by using the given access strategy and cache it */
    public Object getPropertyValue(AccessStrategy access)
          throws IllegalArgumentException, IllegalStateException {
        if (propertyValue == UNKNOWN || (this.access != access && !fixed)) {
            propertyValue = access.get(bean);
            this.access = access;
        }
        return propertyValue;
    }

    /**
     * convenience method to access metaProperty.name
     *
     * @return null or the name of the current property
     */
    public String getPropertyName() {
        return metaProperty == null ? null : metaProperty.getName();
    }

    public void setPropertyValue(Object propertyValue) {
        this.propertyValue = propertyValue;
    }

    public void setFixedValue(Object value) {
        setPropertyValue(value);
        fixed = true;
    }

    public boolean isFixed() {
        return fixed;
    }

    public void setFixed(boolean fixed) {
        this.fixed = fixed;
    }

    /**
     * depending on whether we have a metaProperty or not,
     * this returns the metaProperty or otherwise the metaBean.
     * This is used to have a simple way to request features
     * in the Validation for both bean- and property-level validations.
     *
     * @return something that is capable to deliver features
     */
    public FeaturesCapable getMeta() {
        return (metaProperty == null) ? metaBean : metaProperty;
    }

    /**
     * drop cached value.
     * mark the internal cachedValue as UNKNOWN.
     * This forces the BeanValidationContext to recompute the value
     * the next time it is accessed.
     * Use this method inside tests or when the propertyValue has been
     * changed during validation.
     */
    public void unknownValue() {
        propertyValue = UNKNOWN;
        access = null;
    }

    public MetaBean getMetaBean() {
        return metaBean;
    }

    public Object getBean() {
        return bean;
    }

    public MetaProperty getMetaProperty() {
        return metaProperty;
    }

    public void setMetaBean(MetaBean metaBean) {
        this.metaBean = metaBean;
    }

    public void setBean(Object bean) {
        this.bean = bean;
        unknownValue();
    }

    public void setMetaProperty(MetaProperty metaProperty) {
        this.metaProperty = metaProperty;
        unknownValue();
    }

    public String toString() {
        return "BeanValidationContext{ bean="  bean  ", metaProperty="  metaProperty 
              ", propertyValue="  propertyValue  '}';
    }

    public void moveDown(MetaProperty prop, AccessStrategy access) {
        setMetaProperty(prop);
        setBean(getPropertyValue(access), prop.getMetaBean());
    }

    public void moveUp(Object bean, MetaBean aMetaBean) {
        setBean(bean, aMetaBean); // reset context state
    }

    public void setCurrentIndex(int index) {
        // do nothing
    }

    public void setCurrentKey(Object key) {
        // do nothing
    }

}
 b/bval-core/src/main/java/org/apache/bval/BeanValidator.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval;

import org.apache.bval.model.*;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;

import org.apache.bval.model.Features;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.PropertyAccess;

/**
 * Description: Top-Level API-class to validate objects or object-trees.
 * You can invoke, extend or utilize this class if you need other ways to integrate
 * validation in your application.
 * <p/>
 * This class supports cyclic object graphs by keeping track of
 * validated instances in the validation context.<br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 12:28:46 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class BeanValidator<T extends ValidationListener> {
    private boolean treatMapsLikeBeans = false;
    private final MetaBeanFinder metaBeanFinder;

    /**
     * convenience method. Use the global instance of MetaBeanManagerFactory.getFinder().
     */
    public BeanValidator() {
        this(MetaBeanManagerFactory.getFinder());
    }

    public BeanValidator(MetaBeanFinder metaBeanFinder) {
        this.metaBeanFinder = metaBeanFinder;
    }

    /**
     * Behavior configuration -
     * <pre>
     * parameter: treatMapsLikeBeans - true (validate maps like beans, so that
     *                             you can use Maps to validate dynamic classes or
     *                             beans for which you have the MetaBean but no instances)
     *                           - false (default), validate maps like collections
     *                             (validating the values only)
     * </pre>
     * (is still configuration to better in BeanValidationContext?)
     */
    public boolean isTreatMapsLikeBeans() {
        return treatMapsLikeBeans;
    }

    public void setTreatMapsLikeBeans(boolean treatMapsLikeBeans) {
        this.treatMapsLikeBeans = treatMapsLikeBeans;
    }

    /**
     * convenience API. validate a root object with all related objects
     * with its default metaBean definition.
     *
     * @return results - validation results found
     */
    public T validate(Object bean) {
        MetaBean metaBean =
              getMetaBeanFinder().findForClass(bean.getClass());
        return validate(bean, metaBean);
    }

    /**
     * convenience API. validate a root object with all related objects
     * according to the metaBean.
     *
     * @param bean - a single bean or a collection of beans (that share the same metaBean!)
     * @return results - validation results found
     */
    public T validate(Object bean, MetaBean metaBean) {
        ValidationContext<T> context = createContext();
        context.setBean(bean, metaBean);
        validateContext(context);
        return context.getListener();
    }

    /**
     * validate the method parameters based on @Validate annotations.
     * Requirements:
     * Parameter, that are to be validated must be annotated with @Validate
     *
     * @param method     -  a method
     * @param parameters - the parameters suitable to the method
     * @return a validation result or null when there was nothing to validate
     * @see Validate
     */
    public T validateCall(Method method, Object[] parameters) {
        if (parameters.length > 0) {
            // shortcut (for performance!)
            Annotation[][] annotations = method.getParameterAnnotations();
            ValidationContext<T> context = null;
            for (int i = 0; i < parameters.length; i) {
                for (Annotation anno : annotations[i]) {
                    if (anno instanceof Validate) {
                        if(context == null) context = createContext();
                        if (determineMetaBean((Validate) anno, parameters[i], context)) {
                            validateContext(context);
                            break; // next parameter
                        }
                    }
                }
            }
            return context != null ? context.getListener() : null;
        }
        return null;
    }

    /** @return true when validation should happen, false to skip it */
    protected boolean determineMetaBean(Validate validate, Object parameter,
                                        ValidationContext context) {
        if (validate.value().length() == 0) {
            if (parameter == null) return false;
            Class beanClass;
            if (parameter instanceof Collection) {   // do not validate empty collection
                Collection coll = ((Collection) parameter);
                if (coll.isEmpty()) return false;
                beanClass = coll.iterator().next().getClass(); // get first object
            } else if (parameter.getClass().isArray()) {
                beanClass = parameter.getClass().getComponentType();
            } else {
                beanClass = parameter.getClass();
            }
            context.setBean(parameter,getMetaBeanFinder().findForClass(beanClass));
        } else {
            context.setBean(parameter,getMetaBeanFinder().findForId(validate.value()));
        }
        return true;
    }

    /**
     * factory method -
     * overwrite in subclasses
     */
    protected T createResults() {
        return (T) new ValidationResults();
    }

    /**
     * factory method -
     * overwrite in subclasses
     */
    protected ValidationContext<T> createContext() {
        return new BeanValidationContext<T>(createResults());
    }

    /**
     * convenience API. validate a single property.
     *
     * @param bean         - the root object
     * @param metaProperty - metadata for the property
     * @return validation results
     */
    public T validateProperty(Object bean, MetaProperty metaProperty) {
        ValidationContext<T> context = createContext();
        context.setBean(bean);
        context.setMetaProperty(metaProperty);
        validateProperty(context);
        return context.getListener();
    }

    /**
     * validate a single property only. performs all validations
     * for this property.
     */
    public void validateProperty(ValidationContext context) {
        for (Validation validation : context.getMetaProperty().getValidations()) {
            validation.validate(context);
        }
    }

    /**
     * validate a complex 'bean' with related beans according to
     * validation rules in 'metaBean'
     *
     * @param context - the context is initialized with:
     *                <br>&nbsp;&nbsp;bean - the root object start validation at
     *                or a collection of root objects
     *                <br>&nbsp;&nbsp;metaBean - the meta information for the root object(s)
     * @return a new instance of validation results
     */
    public void validateContext(ValidationContext context) {
        if (context.getBean() != null) {
            if (!treatMapsLikeBeans && context.getBean() instanceof Map) {
                validateMapInContext(context);
            } else if (context.getBean() instanceof Iterable) {
                validateIteratableInContext(context);
            } else if (context.getBean() instanceof Object[]) {
                validateArrayInContext(context);
            } else { // to One Bean (or Map like Bean) 
                validateBeanInContext(context);
            }
        }
    }

    private void validateBeanInContext(ValidationContext context) {
        if (getDynamicMetaBean(context) != null) {
            context.setMetaBean(
                  getDynamicMetaBean(context).resolveMetaBean(context.getBean()));
        }
        validateBeanNet(context);
    }

    private void validateArrayInContext(ValidationContext context) {
        int index = 0;
        DynamicMetaBean dyn = getDynamicMetaBean(context);
        for (Object each : ((Object[]) context.getBean())) {
            context.setCurrentIndex(index);
            if (each == null) continue; // or throw IllegalArgumentException? (=> spec)
            if (dyn != null) {
                context.setBean(each, dyn.resolveMetaBean(each));
            } else {
                context.setBean(each);
            }
            validateBeanNet(context);
        }
    }

    private DynamicMetaBean getDynamicMetaBean(ValidationContext context) {
        return context.getMetaBean() instanceof DynamicMetaBean ?
              (DynamicMetaBean) context.getMetaBean() : null;
    }

    /** Any object implementing java.lang.Iterable is supported */
    private void validateIteratableInContext(ValidationContext context) {
        Iterator it = ((Iterable) context.getBean()).iterator();
        int index = 0;
        // jsr303 spec: Each object provided by the iterator is validated.
        final DynamicMetaBean dyn = getDynamicMetaBean(context);
        while (it.hasNext()) { // to Many
            Object each = it.next();
            context.setCurrentIndex(index);
            if (each == null)
                continue; // enhancement: throw IllegalArgumentException? (=> spec)
            if (dyn != null) {
                context.setBean(each, dyn.resolveMetaBean(each));
            } else {
                context.setBean(each);
            }
            validateBeanNet(context);
        }
    }

    private void validateMapInContext(ValidationContext context) {
        // jsr303 spec: For Map, the value of each Map.Entry is validated (key is not validated).
        Iterator<Map.Entry> it = ((Map) context.getBean()).entrySet().iterator();
        final DynamicMetaBean dyn = getDynamicMetaBean(context);
        while (it.hasNext()) { // to Many
            Map.Entry entry = it.next();
            context.setCurrentKey(entry.getKey());
            if (entry.getValue() == null)
                continue; // enhancement: throw IllegalArgumentException? (=> spec)
            if (dyn != null) {
                context.setBean(entry.getValue(), dyn.resolveMetaBean(entry.getValue()));
            } else {
                context.setBean(entry.getValue());
            }
            validateBeanNet(context);
        }
    }

    /** internal validate a bean (=not a collection of beans) and its related beans */
    protected void validateBeanNet(ValidationContext context) {
        if (context.collectValidated()) {
            validateBean(context);
            for (MetaProperty prop : context.getMetaBean().getProperties()) {
                validateRelatedBean(context, prop);
            }
        }
    }

    private void validateRelatedBean(ValidationContext context, MetaProperty prop) {
        AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
        if (access == null && prop.getMetaBean() != null) { // single property access strategy
            // save old values from context
            final Object bean = context.getBean();
            final MetaBean mbean = context.getMetaBean();
            // modify context state for relationship-target bean
            context.moveDown(prop, new PropertyAccess(bean.getClass(), prop.getName()));
            validateContext(context);
            // restore old values in context
            context.moveUp(bean, mbean);
        } else if (access != null) { // different accesses to relation
            // save old values from context
            final Object bean = context.getBean();
            final MetaBean mbean = context.getMetaBean();
            for (AccessStrategy each : access) {
                // modify context state for relationship-target bean
                context.moveDown(prop, each);
                validateContext(context);
                // restore old values in context
                context.moveUp(bean, mbean);
            }
        }
    }

    /** validate a single bean only. no related beans will be validated */
    public void validateBean(ValidationContext context) {
        /**
         * execute all property level validations
         */
        for (MetaProperty prop : context.getMetaBean().getProperties()) {
            context.setMetaProperty(prop);
            validateProperty(context);
        }
        /**
         * execute all bean level validations
         */
        context.setMetaProperty(null);
        for (Validation validation : context.getMetaBean().getValidations()) {
            validation.validate(context);
        }
    }

    /**
     * the metabean finder associated with this validator.
     * @see org.apache.bval.MetaBeanManagerFactory#getFinder() 
     * @return a MetaBeanFinder
     */
    public MetaBeanFinder getMetaBeanFinder() {
        return metaBeanFinder;
    }
}
 b/bval-core/src/main/java/org/apache/bval/DynamicMetaBean.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval;

import org.apache.bval.model.MetaBean;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 28.04.2008 <br/>
 * Time: 11:04:21 <br/>
 * Copyright: Agimatec GmbH
 */
final class DynamicMetaBean extends MetaBean {
    private final MetaBeanFinder finder;

    public DynamicMetaBean(MetaBeanFinder finder) {
        this.finder = finder;
    }

    /**
     * different strategies with hints to find MetaBean of associated object can
     * be implemented here.
     */
    @Override
    public MetaBean resolveMetaBean(Object bean) {
        return bean instanceof Class ?
                finder.findForClass((Class) bean) : finder.findForClass(bean.getClass());
    }
}
 b/bval-core/src/main/java/org/apache/bval/IntrospectorMetaBeanFactory.java
package org.apache.bval;
import static org.apache.bval.model.Features.Property.*;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;

 b/bval-core/src/main/java/org/apache/bval/MetaBeanBuilder.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval;


import org.apache.bval.model.MetaBean;
import org.apache.bval.xml.XMLMetaBean;
import org.apache.bval.xml.XMLMetaBeanFactory;
import org.apache.bval.xml.XMLMetaBeanInfos;
import org.apache.bval.xml.XMLMetaBeanLoader;
import org.apache.commons.lang.ClassUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * Description: internal implementation class to construct metabeans with factories<br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 16:26:30 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class MetaBeanBuilder {
    private static final Log log = LogFactory.getLog(MetaBeanBuilder.class);

    /** here you can install different kinds of factories to create MetaBeans from */
    private MetaBeanFactory[] factories;
    private XMLMetaBeanFactory xmlFactory;

    public MetaBeanBuilder() {
        this(new MetaBeanFactory[]{new IntrospectorMetaBeanFactory(),
              new XMLMetaBeanFactory()});
    }

    public MetaBeanBuilder(MetaBeanFactory[] factories) {
        setFactories(factories);
    }

    private void setFactories(MetaBeanFactory[] factories) {
        this.factories = factories;
        updateXmlFactory();
    }

    private void updateXmlFactory() {
        for (MetaBeanFactory each : factories) {
            if (each instanceof XMLMetaBeanFactory) { // use the first one!
                xmlFactory = (XMLMetaBeanFactory) each;
                return;
            }
        }
        xmlFactory = null; // none
    }

    public XMLMetaBeanFactory getXmlFactory() {
        return xmlFactory;
    }
/*
    *//** convenience method *//*
    public void addLastFactory(MetaBeanFactory metaBeanFactory) {
        if (factories == null) factories = new MetaBeanFactory[1];
        else {
            MetaBeanFactory[] facold = factories;
            factories = new MetaBeanFactory[facold.length  1];
            System.arraycopy(facold, 0, factories, 0, facold.length);
        }
        factories[factories.length - 1] = metaBeanFactory;
        updateXmlFactory();
    }

    *//** convenience method *//*
    public void addFirstFactory(MetaBeanFactory metaBeanFactory) {
        if (factories == null) factories = new MetaBeanFactory[1];
        else {
            MetaBeanFactory[] facold = factories;
            factories = new MetaBeanFactory[facold.length  1];
            System.arraycopy(facold, 0, factories, 1, facold.length);
        }
        factories[0] = metaBeanFactory;
        updateXmlFactory();
    }*/

    public void addLoader(XMLMetaBeanLoader loader) {
        assertXmlFactory();
        xmlFactory.addLoader(loader);
    }

    public Map<String, MetaBean> buildAll() throws Exception {
        final Map<String, MetaBean> all = new HashMap<String, MetaBean>();
        if (xmlFactory != null) {
            xmlFactory.visitXMLBeanMeta(null, new XMLMetaBeanFactory.Visitor() {
                public void visit(XMLMetaBean empty, XMLMetaBeanInfos xmlInfos)
                      throws Exception {
                    if (xmlInfos.getBeans() == null) return; // empty file, ignore
                    XMLMetaBeanFactory.XMLResult carrier =
                          new XMLMetaBeanFactory.XMLResult(null, xmlInfos);

                    for (XMLMetaBean xmlMeta : xmlInfos.getBeans()) {
                        MetaBean meta = all.get(xmlMeta.getId());
                        if (meta == null) {
                            meta = createMetaBean(xmlMeta);
                            all.put(xmlMeta.getId(), meta);
                        }
                        carrier.xmlMeta = xmlMeta;
                        xmlFactory.enrichMetaBean(meta, carrier);
                    }
                }

                public MetaBean getMetaBean() {
                    return null;  // do nothing
                }
            });
        }
        return all;
    }

    public Map<String, MetaBean> enrichCopies(Map<String, MetaBean> all,
                                              XMLMetaBeanInfos... infosArray)
          throws Exception {
        assertXmlFactory();
        final Map<String, MetaBean> copies = new HashMap<String, MetaBean>(all.size());
        boolean nothing = true;
        XMLMetaBeanFactory.XMLResult carrier = new XMLMetaBeanFactory.XMLResult();
        for (XMLMetaBeanInfos xmlMetaBeanInfos : infosArray) {
            carrier.xmlInfos = xmlMetaBeanInfos;
            if (xmlMetaBeanInfos == null) continue;
            try {
                for (XMLMetaBean xmlMeta : xmlMetaBeanInfos.getBeans()) {
                    nothing = false;
                    MetaBean copy = copies.get(xmlMeta.getId());
                    if (copy == null) { // ist noch nicht kopiert
                        MetaBean meta = all.get(xmlMeta.getId());
                        if (meta == null) { // gibt es nicht
                            copy = createMetaBean(xmlMeta);
                        } else { // gibt es, jetzt kopieren
                            copy = meta.copy();
                        }
                        copies.put(xmlMeta.getId(), copy);
                    }
                    carrier.xmlMeta = xmlMeta;
                    xmlFactory.enrichMetaBean(copy, carrier);
                }
            } catch (IOException e) {
                xmlFactory.handleLoadException(xmlMetaBeanInfos, e);
            }
        }
        if (nothing) return all;
        for (Map.Entry<String, MetaBean> entry : all.entrySet()) {
            /*
            * alle unveraenderten werden AUCH KOPIERT (nur zwar nur, wegen
            * potentieller CrossReferenzen durch Relationships)
            */
            if (!copies.containsKey(entry.getKey())) {
                if (entry.getValue().hasRelationships()) {
                    copies.put(entry.getKey(), (MetaBean) entry.getValue().copy());
                } else { // no relationship: do not clone()
                    copies.put(entry.getKey(), entry.getValue());
                }
            }
        }
        return copies;
    }

    private void assertXmlFactory() {
        if (xmlFactory == null) {
            throw new IllegalStateException("no xmlFactory available");
        }
    }

    public MetaBean buildForId(String beanInfoId) throws Exception {
        final XMLMetaBeanFactory.Visitor v;
        assertXmlFactory();
        xmlFactory.visitXMLBeanMeta(beanInfoId, v = new XMLMetaBeanFactory.Visitor() {
            private MetaBean meta;

            public MetaBean getMetaBean() {
                return meta;
            }

            public void visit(XMLMetaBean xmlMeta, XMLMetaBeanInfos xmlInfos)
                  throws Exception {
                if (meta == null) {
                    meta = createMetaBean(xmlMeta);
                }
                xmlFactory.enrichMetaBean(meta,
                      new XMLMetaBeanFactory.XMLResult(xmlMeta, xmlInfos));
            }


        });
        if (v.getMetaBean() == null) {
            throw new IllegalArgumentException("MetaBean "  beanInfoId  " not found");
        }
        return v.getMetaBean();
    }

    private MetaBean createMetaBean(XMLMetaBean xmlMeta) throws Exception {
        return buildForClass(findLocalClass(xmlMeta.getImpl()));
    }

    protected Class findLocalClass(String className) {
        if (className != null) {
            try {
                return ClassUtils.getClass(className);
            } catch (ClassNotFoundException e) {
                log.warn("class not found: "  className, e);
            }
        }
        return null;
    }

    public MetaBean buildForClass(Class clazz) throws Exception {
        MetaBean meta = new MetaBean();
        if (clazz != null) { // local class here?
            meta.setBeanClass(clazz);
            meta.setId(clazz.getName()); // default id = full class name!
        }
        for (MetaBeanFactory factory : factories) {
            factory.buildMetaBean(meta);
        }
        return meta;
    }

 b/bval-core/src/main/java/org/apache/bval/MetaBeanCache.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval;

import org.apache.bval.model.MetaBean;
import org.apache.commons.collections.FastHashMap;

import java.io.Serializable;
import java.util.Map;

/**
 * Description: a cache to hold metabeans by id and by class.<br/>
 * User: roman.stumm <br/>
 * Date: 18.02.2008 <br/>
 * Time: 11:38:53 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class MetaBeanCache implements MetaBeanFinder, Serializable {
    protected final FastHashMap cacheById;
    protected final FastHashMap cacheByClass;

    public MetaBeanCache() {
        this.cacheById = new FastHashMap();
        cacheByClass = new FastHashMap();
        cacheByClass.setFast(true);
        cacheById.setFast(true);
    }

    public MetaBeanCache(Map<String, MetaBean> beans) {
        this();
        for (MetaBean bean : beans.values()) {
            cache(bean);
        }
    }

    public void clear() {
        cacheById.clear();
        cacheByClass.clear();
    }

    public MetaBean findForId(String beanInfoId) {
        return (MetaBean) cacheById.get(beanInfoId);
    }

    public MetaBean findForClass(Class clazz) {
        return (MetaBean) cacheByClass.get(clazz);
    }

    public Map<String, MetaBean> findAll() {
        return cacheById;
    }

    public void cache(MetaBean beanInfo) {
        cacheById.put(beanInfo.getId(), beanInfo);
        if (beanInfo.getBeanClass() != null &&
                beanInfo.getId().equals(beanInfo.getBeanClass().getName())) {
            cacheByClass.put(beanInfo.getBeanClass(), beanInfo);
        }
    }

    public void removeFromCache(MetaBean beanInfo) {
        cacheById.remove(beanInfo.getId());
        if (beanInfo.getBeanClass() != null &&
                beanInfo.getId().equals(beanInfo.getBeanClass().getName())) {
            cacheByClass.remove(beanInfo.getBeanClass());
        }
    }

}
 b/bval-core/src/main/java/org/apache/bval/MetaBeanEnricher.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval;


import java.util.Map;

import org.apache.bval.model.MetaBean;
import org.apache.bval.xml.XMLMetaBeanInfos;

/**
 * Description: Interface to merge meta beans<br/>
 * User: roman.stumm <br/>
 * Date: 14.02.2008 <br/>
 * Time: 11:00:21 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public interface MetaBeanEnricher {

    /**
     * @param infos - the patches to apply
     * @return all MetaBeans for classes that have a xml descriptor and
     *         additional the MetaBeans loaded by the given loaders.
     *         The given loaders may also return patches for MetaBeans that have
     *         also been returned by other loaders. The beans with patches for
     *         references to patched beans will be copied.
     */
    Map<String, MetaBean> enrichCopies(XMLMetaBeanInfos... infos);
}
 b/bval-core/src/main/java/org/apache/bval/MetaBeanFactory.java
package org.apache.bval;
import org.apache.bval.model.MetaBean;
 b/bval-core/src/main/java/org/apache/bval/MetaBeanFinder.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval;


import java.util.Map;

import org.apache.bval.model.MetaBean;

/**
 * Description: Interface to find BeanInfos <br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 16:17:20 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public interface MetaBeanFinder {
    /**
     * @param beanInfoId - symbolic unique name of Meta Info
     * @return BeanInfo
     * @throws IllegalArgumentException - when MetaBean not found
     */
    MetaBean findForId(String beanInfoId);

    /**
     * @param clazz - bean class
     * @return BeanInfo (never null)
     */
    MetaBean findForClass(Class clazz);

    /**
     * @return all MetaBeans for classes that have a xml descriptor:
     *         key = bean.id, value = MetaBean
     */
    public Map<String, MetaBean> findAll();
}
 b/bval-core/src/main/java/org/apache/bval/MetaBeanManager.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval;

import static org.apache.bval.model.Features.Property.*;


import java.util.Map;

import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.util.PrivilegedActions;
import org.apache.bval.xml.XMLMetaBeanInfos;
import org.apache.bval.xml.XMLMetaBeanLoader;
import org.apache.bval.xml.XMLMetaBeanRegistry;
import org.apache.bval.xml.XMLMetaBeanURLLoader;

/**
 * Description: Default implementation for the interface to find, register and
 * create MetaBeans. In most situations a single instance of this class is
 * sufficient and you can get this instance from the {@link MetaBeanManagerFactory}.
 * <br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 16:19:43 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class MetaBeanManager implements MetaBeanFinder, XMLMetaBeanRegistry, MetaBeanEnricher {

    protected final MetaBeanCache cache = new MetaBeanCache();
    protected final MetaBeanBuilder builder;
    private boolean complete = false;

    public MetaBeanManager() {
        builder = new MetaBeanBuilder();
    }

    public MetaBeanManager(MetaBeanBuilder builder) {
        this.builder = builder;
    }

    public void addResourceLoader(String resource) {
        addLoader(new XMLMetaBeanURLLoader(
              PrivilegedActions.getClassLoader(getClass()).getResource(resource)));
    }

    public synchronized void addLoader(XMLMetaBeanLoader loader) {
        builder.addLoader(loader);
        cache.clear(); // clear because new loaders can affect ALL MetaBeans already created!
        complete = false;
    }

    public MetaBeanBuilder getBuilder() {
        return builder;
    }

    public MetaBeanCache getCache() {
        return cache;
    }

    /**
     * @return all MetaBeans for classes that have a xml descriptor:
     *         key = bean.id, value = MetaBean
     */
    public Map<String, MetaBean> findAll() {
        if (!complete) {
            try {
                Map<String, MetaBean> allBuilt = builder.buildAll();
                for (MetaBean meta : allBuilt.values()) {
                    MetaBean cached = cache.findForId(meta.getId());
                    if (cached == null) {
                        cache.cache(meta);
                    }
                }
                Map<String, MetaBean> map = cache.findAll();
                for (Object oentry : map.values()) {
                    MetaBean meta = (MetaBean) oentry;
                    computeRelationships(meta, map);
                }
                complete = true;
                return map;
            } catch (RuntimeException e) {
                throw e; // do not wrap runtime exceptions
            } catch (Exception e) {
                throw new IllegalArgumentException("error creating beanInfos", e);
            }
        } else {
            return cache.findAll();
        }
    }

    /**
     * @param infos - the patches to apply
     * @return all MetaBeans for classes that have a xml descriptor and
     *         additional the MetaBeans loaded by the given loaders.
     *         The given loaders may also return patches for MetaBeans that have
     *         also been returned by other loaders. The beans with patches for
     *         references to patched beans will be copied.
     */
    public Map<String, MetaBean> enrichCopies(XMLMetaBeanInfos... infos) {
        Map<String, MetaBean> cached = findAll();
        try {
            Map<String, MetaBean> patched = builder.enrichCopies(cached, infos);
            for (Object oentry : patched.values()) {
                MetaBean meta = (MetaBean) oentry;
                computeRelationships(meta, patched);
            }
            return patched;
        } catch (RuntimeException e) {
            throw e; // do not wrap runtime exceptions
        } catch (Exception e) {
            throw new IllegalArgumentException("error enriching beanInfos", e);
        }
    }

    public MetaBean findForId(String beanInfoId) {
        MetaBean beanInfo = cache.findForId(beanInfoId);
        if (beanInfo != null) return beanInfo;
        try {
            beanInfo = builder.buildForId(beanInfoId);
            cache.cache(beanInfo);
            computeRelationships(beanInfo);
            return beanInfo;
        } catch (RuntimeException e) {
            throw e; // do not wrap runtime exceptions
        } catch (Exception e) {
            throw new IllegalArgumentException(
                  "error creating beanInfo with id: "  beanInfoId, e);
        }
    }

    public MetaBean findForClass(Class clazz) {
        if (clazz == null) return null;
        MetaBean beanInfo = cache.findForClass(clazz);
        if (beanInfo != null) return beanInfo;
        try {
            beanInfo = builder.buildForClass(clazz);
            cache.cache(beanInfo);
            computeRelationships(beanInfo);
            return beanInfo;
        } catch (RuntimeException e) {
            throw e; // do not wrap runtime exceptions
        } catch (Exception e) {
            throw new IllegalArgumentException("error creating beanInfo for "  clazz, e);
        }
    }

    /**
     * must be called AFTER cache.cache()
     * to avoid endless loop
     */
    protected void computeRelationships(MetaBean beanInfo) {
        for (MetaProperty prop : beanInfo.getProperties()) {
            String beanRef = (String) prop.getFeature(REF_BEAN_ID);
            if (beanRef != null) {
                prop.setMetaBean(findForId(beanRef));
            } else {
                Class beanType = prop.getFeature(REF_BEAN_TYPE);
                if (beanType != null) {
                    prop.setMetaBean(findForClass(beanType));
                } // dynamic type resolution:
                else if (prop.getFeature(REF_CASCADE) != null) {
                    prop.setMetaBean(new DynamicMetaBean(this));
//                            findForClass(prop.getType()));
                }
            }
        }
    }

    private void computeRelationships(MetaBean beanInfo, Map<String, MetaBean> cached) {
        for (MetaProperty prop : beanInfo.getProperties()) {
            String beanRef = (String) prop.getFeature(REF_BEAN_ID);
            if (beanRef != null) {
                prop.setMetaBean(cached.get(beanRef));
            }
        }
    }
}
 b/bval-core/src/main/java/org/apache/bval/MetaBeanManagerFactory.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval;

import org.apache.bval.xml.XMLMetaBeanRegistry;

/**
 * Description: API class to hold a singleton of a {@link MetaBeanManager}
 * that implements the finder and registry interfaces for MetaBeans<br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 16:20:03 <br/>
 * Copyright: Agimatec GmbH 2008
 *
 * @see org.apache.bval.model.MetaBean
 * @see MetaBeanManager
 */
public class MetaBeanManagerFactory {
    private static MetaBeanManager manager = new MetaBeanManager();

    /**
     * global meta bean finder.
     * @return
     */
    public static MetaBeanFinder getFinder() {
        return manager;
    }

    /**
     * global meta bean registry
     * @return
     */
    public static XMLMetaBeanRegistry getRegistry() {
        return manager;
    }

    /**
     * global meta bean enricher
     * @return
     */
    public static MetaBeanEnricher getEnricher() {
        return manager;
    }

    /**
     * set global meta bean manager, that is responsible
     * for finding, caching, xml registry and enrichment algorithm.
     * @param finder
     */
    public static void setManager(MetaBeanManager finder) {
        manager = finder;
    }
}
 b/bval-core/src/main/java/org/apache/bval/Validate.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Description: Annotate an element (parameter) to be validated.
 * <br>
 *
 * Wichtig:<br>
 * Die Methode muss ebenfalls mit Validate annotiert werden, damit
 * die Parameter-Annotations ueberhaupt untersucht und ein BeanValidationContext angelegt wird.
 * <br/>
 * User: roman.stumm <br/>
 * Date: 09.07.2007 <br/>
 * Time: 13:38:24 <br/>
 * Copyright: Agimatec GmbH 2008
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER, ElementType.METHOD})
public @interface Validate {
    /** (optional) the MetaBean.id to use */
    String value() default "";
}
 b/bval-core/src/main/java/org/apache/bval/ValidationResults.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval;


import java.io.Serializable;
import java.util.*;

import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;

/**
 * Description: Implements a contains to hold and transport validation results<br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 12:26:55 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class ValidationResults implements ValidationListener, Serializable {
    private Map<String, List<Error>> errorsByReason;
    private Map<Object, Map<String, List<Error>>> errorsByOwner;


    /**
     * API to add an error to the validation results.
     *
     * @param reason       - Features from {@link org.apache.bval.routines.Reasons}
     *                       or custom reason of validation error
     * @param context        - context information (bean, propertyName, value, ...)
     */
    public void addError(String reason, ValidationContext context) {
        Error error = createError(reason, context.getBean(), context.getPropertyName());
        addError(error, context);
    }


     /**
     * API to add an error to the validation results.
     *
     * @param error       - holding the description of reason and object to describe
      *                     the validation error
     * @param context     - null or the context to provide additional information
     */
    public void addError(Error error, ValidationContext context) {
        if (errorsByReason == null) {
            initialize();
        }
        addToReasonBucket(error);
        addToOwnerBucket(error);
    }

    /**
     * Old API to add an error to the validation results when no context is available.
     *
     * @param reason       - Features from {@link org.apache.bval.routines.Reasons} or custom validation reason
     * @param bean         - (optional) owner bean or null
     * @param propertyName - (optional) propertyName where valiation error occurred or null
     */
    public void addError(String reason, Object bean, String propertyName) {
        addError(createError(reason, bean, propertyName), null);
    }


    protected Error createError(String reason, Object owner, String propertyName) {
        return new Error(reason, owner, propertyName);
    }

    /**
     * initialize the error-buckets now when needed and
     * not on instance creation to save memory garbage.
     */
    protected void initialize() {
        errorsByReason = new LinkedHashMap();
        errorsByOwner = new LinkedHashMap();
    }

    protected void addToReasonBucket(Error error) {
        if (error.getReason() == null) return;

        List<Error> errors = errorsByReason.get(error.getReason());
        if (errors == null) {
            errors = new ArrayList<Error>();
            errorsByReason.put(error.getReason(), errors);
        }
        errors.add(error);
    }

    protected void addToOwnerBucket(Error error) {
        if (error.getOwner() == null) return;

        Map<String, List<Error>> errors = errorsByOwner.get(error.getOwner());
        if (errors == null) {
            errors = new HashMap<String, List<Error>>();
            errorsByOwner.put(error.getOwner(), errors);
        }
        List<Error> list = errors.get(error.getPropertyName());
        if (list == null) {
            list = new ArrayList<Error>();
            errors.put(error.getPropertyName(), list);
        }
        list.add(error);
    }

    /** key = reason, value = list of errors for this reason */
    public Map<String, List<Error>> getErrorsByReason() {
        if (errorsByReason == null) return Collections.emptyMap();
        return errorsByReason;
    }

    /**
     * key = owner, value = map with:<br>
     * &nbsp;&nbsp; key = propertyName, value = list of errors for this owner.propertyName
     */
    public Map<Object, Map<String, List<Error>>> getErrorsByOwner() {
        if (errorsByOwner == null) return Collections.emptyMap();
        return errorsByOwner;
    }

    /** @return true when there are NO errors in this validation result */
    public boolean isEmpty() {
        if (errorsByReason == null ||
              (errorsByReason.isEmpty() && errorsByOwner.isEmpty())) return true;
        for (List<Error> list : errorsByReason.values()) {
            if (!list.isEmpty()) return false;
        }
        for (Map<String, List<Error>> map : errorsByOwner.values()) {
            for (List<Error> list : map.values()) {
                if (!list.isEmpty()) return false;
            }
        }
        return true;
    }

    public boolean hasErrorForReason(String reason) {
        if (errorsByReason == null) return false;
        List<Error> errors = errorsByReason.get(reason);
        return errors != null && !errors.isEmpty();
    }

    /**
     * @param propertyName - may be null: any property is checked
     *                     OR the name of the property to check
     */
    public boolean hasError(Object bean, String propertyName) {
        if (errorsByOwner == null) return false;
        Map<String, List<Error>> errors = errorsByOwner.get(bean);
        if (errors == null) return false;
        if (propertyName != null) {
            List<Error> list = errors.get(propertyName);
            return list != null && !list.isEmpty();
        } else {
            for (List<Error> list : errors.values()) {
                if (!list.isEmpty()) return true;
            }
            return false;
        }
    }

    public String toString() {
        return "ValidationResults{"  errorsByOwner  "}";
    }
}
 b/bval-core/src/main/java/org/apache/bval/integration/ThreadBeanValidator.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.integration;

import org.apache.bval.BeanValidator;
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.model.ValidationContext;


/**
 * Description: Validatator that puts the current validation
 * context into a {@link ThreadLocal} <br/>
 * User: roman.stumm <br/>
 * Date: 09.07.2007 <br/>
 * Time: 13:49:11 <br/>
 * Copyright: Agimatec GmbH 2008
 *
 * @see ThreadValidationContext
 */
public class ThreadBeanValidator extends BeanValidator {
    public ThreadBeanValidator() {
    }

    public ThreadBeanValidator(MetaBeanFinder metaBeanFinder) {
        super(metaBeanFinder);
    }

    @Override
    protected ValidationContext createContext() {
        ThreadValidationContext context = ThreadValidationContext.getCurrent();
        if (context == null) {
            context = new ThreadValidationContext(createResults());
            ThreadValidationContext.setCurrent(context);
        }
        return context;
    }
}
 b/bval-core/src/main/java/org/apache/bval/integration/ThreadValidationContext.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.integration;

import org.apache.bval.BeanValidationContext;
import org.apache.bval.model.ValidationListener;


/**
 * Description: Used to bind the current validation context to the current thread.
 * Use this class when you need to append validation errors in service layers
 * without handing a ValidationContext and/or ValidationResults instance
 * through your method signatures.<br/>
 * User: roman.stumm <br/>
 * Date: 09.07.2007 <br/>
 * Time: 13:41:10 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class ThreadValidationContext extends BeanValidationContext {
    protected static final ThreadLocal<ThreadValidationContext> current =
            new ThreadLocal<ThreadValidationContext>();

    public ThreadValidationContext(ValidationListener listener) {
        super(listener);
    }

    public static ThreadValidationContext getCurrent() {
        return current.get();
    }

    public static void setCurrent(ThreadValidationContext aValidationContext) {
        if (aValidationContext == null) {
            current.remove();
        } else {
            current.set(aValidationContext);
        }
    }
}
 b/bval-core/src/main/java/org/apache/bval/json/JSONGenerator.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.json;

import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;

import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;
import java.util.*;

import org.apache.bval.model.MetaBean;

/**
 * Description: Generate a JSON String for a collection of {@link MetaBean}s.
 * This implementation uses a freemarker template to generate the output.<br/>
 * User: roman.stumm <br/>
 * Date: 09.07.2007 <br/>
 * Time: 17:14:12 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class JSONGenerator {
    private final Template template;

    public JSONGenerator() throws IOException {
        this("bean-infos-json.ftl");
    }

    public JSONGenerator(String templateName) throws IOException {
        Configuration freemarker = new Configuration();
        freemarker.setNumberFormat("0.######");  // prevent locale-sensitive number format
        freemarker.setClassForTemplateLoading(getClass(), "");
        template = freemarker.getTemplate(templateName);
    }

    public JSONGenerator(Template template) {
        this.template = template;
    }

    public String toJSON(MetaBean metaBean) throws IOException, TemplateException {
        List<MetaBean> metaBeans = new ArrayList(1);
        metaBeans.add(metaBean);
        return toJSON(metaBeans);
    }

    public String toJSON(Collection<MetaBean> metaBeans)
            throws IOException, TemplateException {
        final StringWriter out = new StringWriter();
        toJSON(metaBeans, out);
        return out.toString();
    }

    public void toJSON(Collection<MetaBean> metaBeans, Writer out)
            throws IOException, TemplateException {
        Map rootMap = new HashMap();
        rootMap.put("metaBeans", metaBeans);
        rootMap.put("generator", this);
        template.process(rootMap, out);
    }
}
 b/bval-core/src/main/java/org/apache/bval/model/DynaType.java
package org.apache.bval.model;
 b/bval-core/src/main/java/org/apache/bval/model/DynaTypeEnum.java
package org.apache.bval.model;
 b/bval-core/src/main/java/org/apache/bval/model/Features.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.model;

/**
 * Description: Contains key of common feature keys used by standard validators etc.
 * This DOES NOT MEAN that the list of property- or bean-features is closed. You can
 * put anything into the metabean as a feature and use it in your custom validators
 * and other classes that access your metabeans.<br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 17:03:47 <br/>
 * Copyright: Agimatec GmbH 2008
 *
 * @see FeaturesCapable
 */
public interface Features {
    /** Features of {@link MetaBean} */
    public interface Bean {
        /** INFO: String, name of the Property, that is the Primary Key */
        String MAIN_KEY = "mainKey";
        /** INFO: category/domain to which the metaBean belongs to */
        String DOMAIN = "domain";

        //        String DISPLAY_NAME = "displayName";
        String UNIQUE_KEY = "uniqueKey";
    }

    /** Features of {@link MetaProperty} */
    public interface Property {
        /** INFO: possible Enum values */
        String ENUM = "enum";
        /** INFO: Boolean, TRUE if Property is a Unique Key */
        String UNIQUE_KEY = "uniqueKey";
        /** VALIDATION: Boolean, mandatory field? */
        String MANDATORY = "mandatory";
        /** VALIDATION: Integer, max. number of chars/digits / max. cardinality of a to-many relationship */
        String MAX_LENGTH = "maxLen";
        /** VALIDATION: Comparable (e.g. a subclass of Number), max value */
        String MAX_VALUE = "maxValue";
        /** VALIDATION: Integer, min. number of chars/digits / min. cardinality of a to-many relationship */
        String MIN_LENGTH = "minLen";
        /** VALIDATION: Comparable (e.g. a subclass of Number), min value */
        String MIN_VALUE = "minValue";
        /** INFO: String-representation of a default value */
        String DEFAULT_VALUE = "defValue";
        /** SECURITY, INFO: Boolean, is value or relationship unmodifiable */
        String READONLY = "readonly";
        /**
         * SECURITY, INFO: Boolean, Feld accessible?
         * If false, the field must not be displayed, queried, changed.
         */
        String DENIED = "denied";
        /** VALIDATION: String, regular expression to validate the format of input data */
        String REG_EXP = "regExp";
        /**
         * VALIDATION: String, Constraint for time-information of a Date-field:
         * {@link org.apache.bval.xml.XMLMetaValue#TIMELAG_Past}
         * or
         * {@link org.apache.bval.xml.XMLMetaValue#TIMELAG_Future}
         */
        String TIME_LAG = "timeLag";

        /**
         * INFO: Boolean, Feld visible?
         *
         * @see java.beans.PropertyDescriptor#isHidden()
         */
        String HIDDEN = "hidden";
        /**
         * INFO: Boolean
         *
         * @see java.beans.PropertyDescriptor#isPreferred()
         */
        String PREFERRED = "preferred";

        /** INFO: relationship's target metaBean.id * */
        String REF_BEAN_ID = "refBeanId";

        /**
         * INFO: Class<br>
         * Relationship's target metaBean.beanClass.
         * In case of to-many relationships, this feature
         * hold the Bean-type not the Collection-type.
         */
        String REF_BEAN_TYPE = "refBeanType";

        /**
         * INFO: AccessStrategy[]<br>
         * an array of accessStrategies
         * how validation should cascade into relationship target beans<br>
         * null when validation should NOT cascade into relationship target
         * beans<br>
         * <p/>
         * Default: {PropertyAccess(metaProperty.name)},
         * when MetaProperty.metaBean is != null
         */
        String REF_CASCADE = "refCascade";

        /** INFO: an array with the string names of custom java script validation functions */
        String JAVASCRIPT_VALIDATION_FUNCTIONS = "jsFunctions";
    }
}
 b/bval-core/src/main/java/org/apache/bval/model/FeaturesCapable.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.model;

import org.apache.commons.collections.FastHashMap;

import java.io.Serializable;
import java.util.Map;

/**
 * Description: abstract superclass of meta objects that support a map of features.<br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 10:29:57 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public abstract class FeaturesCapable implements Serializable {
    private FastHashMap features = new FastHashMap();
    /** key = validation id, value = the validation */
    private Validation[] validations = new Validation[0];

    public FeaturesCapable() {
        features.setFast(true);
    }

    public Map<String, Object> getFeatures() {
        return features;
    }

    public void optimizeRead(boolean fast) {
        features.setFast(fast);
    }

    public <T> T getFeature(String key) {
        return (T) features.get(key);
    }

    public <T> T getFeature(String key, T defaultValue) {
        final T v = (T) features.get(key);
        if (v == null) {
            return (features.containsKey(key)) ? null : defaultValue;
        } else {
            return v;
        }
    }

    /** convenience method. */
    public <T> void putFeature(String key, T value) {
        features.put(key, value);
    }

    /** create a deep copy! (copy receiver and copy properties) */
    public <T extends FeaturesCapable> T copy() {
        try {
            T self = (T) clone();
            copyInto(self);
            return self;
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException("cannot clone() "  this, e);
        }
    }

    protected <T extends FeaturesCapable> void copyInto(T target) {
        target.features = (FastHashMap) features.clone();
        if (validations != null) {
            target.validations = validations.clone();
        }
    }

    public Validation[] getValidations() {
        return validations;
    }

    public void addValidation(Validation validation) {
        if (validations.length == 0) {
            validations = new Validation[1];
        } else {
            Validation[] newvalidations = new Validation[validations.length  1];
            System.arraycopy(validations, 0, newvalidations, 0, validations.length);
            validations = newvalidations;
        }
        validations[validations.length - 1] = validation;
    }

    public boolean hasValidation(Validation aValidation) {
        if (validations == null) return false;
        for (Validation validation : validations) {
            if (validation.equals(aValidation)) return true;
        }
        return false;
    }
}
 b/bval-core/src/main/java/org/apache/bval/model/MetaBean.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.model;

import org.apache.commons.lang.ArrayUtils;

/**
 * Description: the meta description of a bean or class.
 * the class/bean itself can have a map of features and an array of metaproperties.<br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 09:44:31 <br/>
 * Copyright: Agimatec GmbH 2008
 *
 * @see MetaProperty
 */
public class MetaBean extends FeaturesCapable implements Cloneable, Features.Bean {
    private String id;
    private String name;
    private Class beanClass;
    private MetaProperty[] properties = new MetaProperty[0];

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public Class getBeanClass() {
        return beanClass;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setBeanClass(Class beanClass) {
        this.beanClass = beanClass;
    }

    public MetaProperty[] getProperties() {
        return properties;
    }

    public void setProperties(MetaProperty[] properties) {
        this.properties = properties;
    }

    public MetaProperty getProperty(String name) {
        for (MetaProperty p : properties) {
            if (name.equals(p.getName())) return p;
        }
        return null;
    }

    /** @return true when at least one of the properties is a relationship */
    public boolean hasRelationships() {
        for (MetaProperty p : properties) {
            if (p.isRelationship()) return true;
        }
        return false;
    }

    public boolean hasProperties() {
        return properties.length > 0;
    }

    public void putProperty(String name, MetaProperty property) {
        final MetaProperty oldProperty = getProperty(name);
        if (oldProperty == null) { // add
            if (properties.length == 0) {
                properties = new MetaProperty[1];
            } else {
                MetaProperty[] newproperties = new MetaProperty[properties.length  1];
                System.arraycopy(properties, 0, newproperties, 0, properties.length);
                properties = newproperties;
            }
            properties[properties.length - 1] = property;
        } else { // replace
            int idx = ArrayUtils.indexOf(properties, oldProperty);
            properties[idx] = property;
        }
    }

    public String toString() {
        return "MetaBean{"  "id='"  id  '\''  ", name='"  name  '\''  ", beanClass=" 
                beanClass  '}';
    }

    @Override
    protected <T extends FeaturesCapable> void copyInto(T target) {
        super.copyInto(target);
        final MetaBean copy = (MetaBean) target;
        if (properties != null) {
            copy.properties = properties.clone();
            for (int i = copy.properties.length - 1; i >= 0; i--) {
                copy.properties[i] = copy.properties[i].copy();
            }
        }
    }

    public MetaBean resolveMetaBean(Object bean) {
        return bean == null || bean == beanClass || beanClass.isInstance(bean) ? this : null;
    }

}
 b/bval-core/src/main/java/org/apache/bval/model/MetaProperty.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.model;

import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

/**
 * Description: the meta description of a property of a bean. it supports a map
 * of features and multiple validations<br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 09:58:57 <br/>
 * Copyright: Agimatec GmbH 2008
 *
 * @see Validation
 * @see MetaBean
 */
public class MetaProperty extends FeaturesCapable
      implements Cloneable, Features.Property {
    private String name;

    private Type type;
    private MetaBean metaBean;

    public MetaProperty() {
    }

    /** the meta info of the target bean (mainly for relationships) */
    public MetaBean getMetaBean() {
        return metaBean;
    }

    public void setMetaBean(MetaBean metaBean) {
        this.metaBean = metaBean;
    }

    public boolean isRelationship() {
        return metaBean != null;
    }

    public void setType(Type type) {
        this.type = type;
    }

    public Type getType() {
        return type;
    }

    public Class<?> getTypeClass() {
        return getTypeClass(type);
    }

    private Class<?> getTypeClass(Type rawType) {
        if (rawType instanceof Class) {
            return (Class) rawType;
        } else if (rawType instanceof ParameterizedType) {
            return getTypeClass(((ParameterizedType) rawType).getRawType()); // recursion!
        } else if(rawType instanceof DynaType) {
            return getTypeClass(((DynaType)rawType).getRawType()); // recursion
        } else {
            return null; // class cannot be determined!
        }
    }

    public String getName() {
        return name;
    }

    public boolean isMandatory() {
        return getFeature(MANDATORY, Boolean.FALSE).booleanValue();
    }

    public void setMandatory(boolean mandatory) {
        putFeature(MANDATORY, Boolean.valueOf(mandatory));
    }

    public String[] getJavaScriptValidations() {
        return getFeature(JAVASCRIPT_VALIDATION_FUNCTIONS);
    }

    public void setName(String name) {
        this.name = name;
    }

    public String toString() {
        return "MetaProperty{"  "name='"  name  '\''  ", type="  type  '}';
    }
}
 b/bval-core/src/main/java/org/apache/bval/model/Validation.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.model;

/**
 * Description: Interface for a single validation <br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 10:04:39 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public interface Validation {
    /**
     * Perform a single validation routine.
     * Validate the object or property according to the current ValidationContext.
     *
     * @param context - to access the property, value, constraints
     */
    void validate(ValidationContext context);
}
 b/bval-core/src/main/java/org/apache/bval/model/ValidationContext.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.model;

import org.apache.bval.util.AccessStrategy;

/**
 * Description: Interface of the context that holds all state information
 * during the validation process<br/>
 * User: roman.stumm <br/>
 * Date: 28.04.2008 <br/>
 * Time: 09:36:02 <br/>
 * Copyright: Agimatec GmbH
 */
public interface ValidationContext<T extends ValidationListener> {
    Object getPropertyValue();

    /** get the value by using the given access strategy and cache it */
    Object getPropertyValue(AccessStrategy access);

    String getPropertyName();

    T getListener();

    Object getBean();

    MetaBean getMetaBean();

    void setMetaBean(MetaBean metaBean);

    MetaProperty getMetaProperty();

    void setBean(Object bean);

    boolean collectValidated();

    void setBean(Object aBean, MetaBean aMetaBean);

    void setMetaProperty(MetaProperty metaProperty);

    /** step deeper into association at 'prop' */
    void moveDown(MetaProperty prop, AccessStrategy access);

    /** step out from a validation of associated objects. */
    void moveUp(Object bean, MetaBean metaBean);

    /**
     * set the index of the object currently validated into the context.
     * used to create the propertyPath with [index] information for collections.
     */
    void setCurrentIndex(int index);

    /**
     * set the key of the object in a map currently validated into the context.
     * used to create the propertyPath with [key] information for maps.
     */
    void setCurrentKey(Object key);
}
 b/bval-core/src/main/java/org/apache/bval/model/ValidationListener.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.model;


import java.io.Serializable;

import org.apache.bval.ValidationResults;


/**
 * Description: The interface to collect errors found during validation<br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 13:18:24 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public interface ValidationListener {
    /**
     * Simple API to add an error reason during validation.
     * Error notification added from a {@link Validation} with context information
     * taken from the given {@link ValidationContext}.
     *
     * @param reason  a constant describing the reason. This is normally the key of the
     *                feature that was violated in the object 'owner' for property 'propertyName'
     * @param context - contains
     *                bean =         the object that contains the error (owner)
     *                propertyName = the Name of the attribute that caused the error
     */
    void addError(String reason, ValidationContext context);

    /** Alternative method to add a fully initialized {@link ValidationResults.Error} object. */
    void addError(Error error, ValidationContext context);

    /**
     * an object holding a single validation constraint violation
     * found during the validation process.
     */
    public class Error implements Serializable {
        final String reason;
        final Object owner;
        final String propertyName;

        public Error(String aReason, Object aOwner, String aPropertyName) {
            this.reason = aReason;
            this.owner = aOwner;
            this.propertyName = aPropertyName;
        }

        public String getReason() {
            return reason;
        }

        public Object getOwner() {
            return owner;
        }

        public String getPropertyName() {
            return propertyName;
        }

        public String toString() {
            return "Error{"  "reason='"  reason  '\''  ", propertyName='" 
                  propertyName  '\''  '}';
        }
    }
}
 b/bval-core/src/main/java/org/apache/bval/routines/EMailValidation.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.routines;


import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;

/**
 * Description: example validation for email addresses using a regular expression
 * (taken from hibernate EmailValidator)<br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 16:51:16 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class EMailValidation implements Validation {
    private static String ATOM =
            "[^\\x00-\\x1F^\\(^\\)^\\<^\\>^\\@^\\,^\\;^\\:^\\\\^\\\"^\\.^\\[^\\]^\\s]";
    private static String DOMAIN = "("  ATOM  "(\\."  ATOM  ")*";
    private static String IP_DOMAIN = "\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\]";
    private static final java.util.regex.Pattern DEFAULT_PATTERN;

    static {
        DEFAULT_PATTERN = java.util.regex.Pattern.compile(
                "^"  ATOM  "(\\."  ATOM  ")*@"
                         DOMAIN
                         "|"
                         IP_DOMAIN
                         ")$",
                java.util.regex.Pattern.CASE_INSENSITIVE
        );
    }

    private java.util.regex.Pattern pattern = DEFAULT_PATTERN;

    public void validate(ValidationContext context) {
        if (context.getPropertyValue() == null) return;
        if (!isValid(context.getPropertyValue(), pattern)) {
            context.getListener().addError(Reasons.EMAIL_ADDRESS, context);
        }
    }

    public Pattern getPattern() {
        return pattern;
    }

    public void setPattern(Pattern pattern) {
        this.pattern = pattern;
    }

    public static boolean isValid(Object value) {
        return isValid(value, DEFAULT_PATTERN);
    }

    private static boolean isValid(Object value, Pattern aPattern) {
        if (value == null) return true;
        if (!(value instanceof String)) return false;
        String string = (String) value;
        if (string.length() == 0) return true;
        Matcher m = aPattern.matcher(string);
        return m.matches();
    }

}
 b/bval-core/src/main/java/org/apache/bval/routines/NOPValidation.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.routines;

import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;

/**
 * Description: DO NOTHING VALIDATION (can be used to turn off standard validation)<br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 16:51:28 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class NOPValidation implements Validation {

    public void validate(ValidationContext context) {
        // do nothing
    }
}
 b/bval-core/src/main/java/org/apache/bval/routines/Reasons.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.routines;

import org.apache.bval.model.Features;

/**
 * Description: StandardReasons for validation errors found in
 * {@link org.apache.bval.ValidationResults}<br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 13:20:43 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public interface Reasons extends Features.Property {
    // The reasons inherited from Features are VALIDATION features only.
    // INFO features are not meant to be validated.

    // Add more reasons here.
    String EMAIL_ADDRESS = "emailAddress";
}
 b/bval-core/src/main/java/org/apache/bval/routines/StandardValidation.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.routines;

import static org.apache.bval.routines.Reasons.*;


import java.util.Collection;
import java.util.Date;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.xml.XMLMetaValue;

/**
 * Description: This class implements the standard validations for properties!
 * You can subclass this class and replace the implementation
 * in the beanInfo-xml by providing it a validation "standard"<br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 12:41:06 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class StandardValidation implements Validation {
    /** key for this validation in the validation list of the beanInfos */
    public String getValidationId() {
        return "standard";
    }

    public void validate(ValidationContext context) {
        validateMandatory(context);
        validateMaxLength(context);
        validateMinLength(context);
        validateMaxValue(context);
        validateMinValue(context);
        validateRegExp(context);
        validateTimeLag(context);
    }

    protected void validateTimeLag(ValidationContext context) {
        String lag = (String) context.getMetaProperty().getFeature(TIME_LAG);
        if (lag == null) return;
        if (context.getPropertyValue() == null) return;
        long date = ((Date) context.getPropertyValue()).getTime();
        long now = System.currentTimeMillis();
        if (XMLMetaValue.TIMELAG_Future.equals(lag)) {
            if (date < now) {
                context.getListener().addError(TIME_LAG, context);
            }
        } else if (XMLMetaValue.TIMELAG_Past.equals(lag)) {
            if (date > now) {
                context.getListener().addError(TIME_LAG, context);
            }
        } else {
            throw new IllegalArgumentException("unknown timelag "  lag  " at "  context);
        }
    }

    private static final String REG_EXP_PATTERN = "cachedRegExpPattern";

    protected void validateRegExp(ValidationContext context) {
        final MetaProperty meta = context.getMetaProperty();
        final String regExp = (String) meta.getFeature(REG_EXP);
        if (regExp == null) return;
        if (context.getPropertyValue() == null) return;

        final String value = String.valueOf(context.getPropertyValue());
        try {
            Pattern pattern = (Pattern) meta.getFeature(REG_EXP_PATTERN);
            if (pattern == null) {
                pattern = Pattern.compile(regExp);
                meta.putFeature(REG_EXP_PATTERN, pattern);
            }
            if (!pattern.matcher(value).matches()) {
                context.getListener().addError(REG_EXP, context);
            }
        } catch (PatternSyntaxException e) {
            throw new IllegalArgumentException(
                  "regular expression malformed. regexp "  regExp  " at "  context, e);
        }
    }

    protected void validateMinValue(ValidationContext context) {
        Comparable minValue = (Comparable) context.getMetaProperty().getFeature(MIN_VALUE);
        if (minValue == null || context.getPropertyValue() == null) return;
        if (compare(context, minValue, context.getPropertyValue()) > 0) {
            context.getListener().addError(MIN_VALUE, context);
        }
    }

    protected void validateMaxValue(ValidationContext context) {
        Comparable maxValue = (Comparable) context.getMetaProperty().getFeature(MAX_VALUE);
        if (maxValue == null || context.getPropertyValue() == null) return;
        if (compare(context, maxValue, context.getPropertyValue()) < 0) {
            context.getListener().addError(MAX_VALUE, context);
        }
    }

    private int compare(ValidationContext context, Comparable constraintValue,
                        Object currentValue) {
        int r;
        if (constraintValue.getClass().isAssignableFrom(currentValue.getClass())) {
            r = constraintValue.compareTo(context.getPropertyValue());
        } else if (currentValue instanceof Number) {
            double dv = ((Number) currentValue).doubleValue();
            double mdv = ((Number) constraintValue).doubleValue();
            r = mdv > dv ? 1 : -1;
        } else {
            r = String.valueOf(constraintValue).compareTo(String.valueOf(currentValue));
        }
        return r;
    }

    protected void validateMaxLength(ValidationContext context) {
        Integer maxLength = (Integer) context.getMetaProperty()
              .getFeature(Features.Property.MAX_LENGTH);
        if (maxLength == null) return;
        if (context.getPropertyValue() == null) return;

        final Object value = context.getPropertyValue();
        int length = 0;
        if (value instanceof String) {
            length = ((String) value).length();
        } else if (value instanceof Collection) {
            length = ((Collection) value).size();
        }
        if (length > maxLength) {
            context.getListener().addError(MAX_LENGTH, context);
        }
    }

    protected void validateMinLength(ValidationContext context) {
        Integer maxLength = (Integer) context.getMetaProperty()
              .getFeature(Features.Property.MIN_LENGTH);
        if (maxLength == null) return;
        if (context.getPropertyValue() == null) return;

        final Object value = context.getPropertyValue();
        int length = 0;
        if (value instanceof String) {
            length = ((String) value).length();
        } else if (value instanceof Collection) {
            length = ((Collection) value).size();
        }
        if (length < maxLength) {
            context.getListener().addError(MIN_LENGTH, context);
        }
    }

    protected void validateMandatory(ValidationContext context) {
        if (context.getMetaProperty().isMandatory()) {
            if (context.getPropertyValue() == null) {
                context.getListener().addError(MANDATORY, context);
            }
        }
    }

    public static StandardValidation getInstance() {
        return new StandardValidation();
    }
}
 b/bval-core/src/main/java/org/apache/bval/util/AccessStrategy.java
package org.apache.bval.util;
 b/bval-core/src/main/java/org/apache/bval/util/FieldAccess.java
package org.apache.bval.util;
 b/bval-core/src/main/java/org/apache/bval/util/MethodAccess.java
package org.apache.bval.util;
 b/bval-core/src/main/java/org/apache/bval/util/PrivilegedActions.java
package org.apache.bval.util;
 b/bval-core/src/main/java/org/apache/bval/util/PropertyAccess.java
package org.apache.bval.util;
 b/bval-core/src/main/java/org/apache/bval/xml/XMLFeaturesCapable.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

import com.thoughtworks.xstream.annotations.XStreamImplicit;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import org.apache.bval.model.FeaturesCapable;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 10.07.2007 <br/>
 * Time: 13:11:56 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class XMLFeaturesCapable implements Serializable {
    @XStreamImplicit
    private List<XMLMetaFeature> features;
    @XStreamImplicit(itemFieldName = "validator")
    private List<XMLMetaValidatorReference> validators;

    public List<XMLMetaFeature> getFeatures() {
        return features;
    }

    public void setFeatures(List<XMLMetaFeature> features) {
        this.features = features;
    }

    public void putFeature(String key, Object value) {
        XMLMetaFeature anno = findFeature(key);
        if (features == null) features = new ArrayList<XMLMetaFeature>();
        if (anno == null) {
            features.add(new XMLMetaFeature(key, value));
        } else {
            anno.setValue(value);
        }
    }

    public void removeFeature(String key) {
        XMLMetaFeature anno = findFeature(key);
        if (anno != null) {
            getFeatures().remove(anno);
        }
    }

    public Object getFeature(String key) {
        XMLMetaFeature anno = findFeature(key);
        return anno == null ? null : anno.getValue();
    }

    private XMLMetaFeature findFeature(String key) {
        if (features == null) return null;
        for (XMLMetaFeature anno : features) {
            if (key.equals(anno.getKey())) return anno;
        }
        return null;
    }

    public List<XMLMetaValidatorReference> getValidators() {
        return validators;
    }

    public void setValidators(List<XMLMetaValidatorReference> validators) {
        this.validators = validators;
    }

    public void addValidator(String validatorId) {
        if (validators == null) validators = new ArrayList<XMLMetaValidatorReference>();
        validators.add(new XMLMetaValidatorReference(validatorId));
    }

    public void mergeFeaturesInto(FeaturesCapable fc) {
        if (getFeatures() != null) {
            fc.optimizeRead(false);
            for (XMLMetaFeature each : getFeatures()) {
                fc.putFeature(each.getKey(), each.getValue());
            }
            fc.optimizeRead(true);
        }
    }
}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMapper.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

import com.thoughtworks.xstream.XStream;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 14:54:13 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class XMLMapper {
    private static final XMLMapper instance = new XMLMapper();

    private final XStream xStream;

    private XMLMapper() {
        xStream = new XStream();
        xStream.processAnnotations(new Class[] {XMLFeaturesCapable.class,
                XMLMetaFeature.class, XMLMetaBean.class, XMLMetaBeanInfos.class,
                XMLMetaBeanReference.class, XMLMetaElement.class, XMLMetaProperty.class,
                XMLMetaValidator.class, XMLMetaValidatorReference.class});
        xStream.setMode(XStream.NO_REFERENCES);
    }

    public static XMLMapper getInstance() {
        return instance;
    }

    public XStream getXStream() {
        return xStream;
    }
}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaBean.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import com.thoughtworks.xstream.annotations.XStreamImplicit;

import java.util.ArrayList;
import java.util.List;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 14:25:19 <br/>
 * Copyright: Agimatec GmbH 2008
 */
@XStreamAlias("bean")
public class XMLMetaBean extends XMLFeaturesCapable {
    @XStreamAsAttribute()
    private String id;
    @XStreamAsAttribute()
    private String name;
    @XStreamAsAttribute()
    private String impl;
    @XStreamImplicit
    private List<XMLMetaProperty> properties;
    @XStreamImplicit
    private List<XMLMetaBeanReference> beanRelations;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getImpl() {
        return impl;
    }

    public void setImpl(String impl) {
        this.impl = impl;
    }

    public List<XMLMetaProperty> getProperties() {
        return properties;
    }

    public void setProperties(List<XMLMetaProperty> properties) {
        this.properties = properties;
    }

    public void addProperty(XMLMetaProperty property) {
        if (properties == null) properties = new ArrayList();
        properties.add(property);
    }

    public void putProperty(XMLMetaProperty property) {
        if (property.getName() != null) {
            XMLMetaProperty prop = findProperty(property.getName());
            if (prop != null) {
                properties.remove(prop);
            }
        }
        addProperty(property);
    }

    public XMLMetaProperty removeProperty(String name) {
        XMLMetaProperty prop = findProperty(name);
        if (prop != null) {
            properties.remove(prop);
        }
        return prop;
    }

    public XMLMetaProperty getProperty(String name) {
        return findProperty(name);
    }

    private XMLMetaProperty findProperty(String name) {
        if (properties == null) return null;
        for (XMLMetaProperty prop : properties) {
            if (name.equals(prop.getName())) return prop;
        }
        return null;
    }

    public List<XMLMetaBeanReference> getBeanRefs() {
        return beanRelations;
    }

    public void setBeanRefs(List<XMLMetaBeanReference> beanRelations) {
        this.beanRelations = beanRelations;
    }


    public void addBeanRef(XMLMetaBeanReference beanRelation) {
        if (beanRelations == null) beanRelations = new ArrayList();
        beanRelations.add(beanRelation);
    }

    public void putBeanRef(XMLMetaBeanReference beanRelation) {
        if (beanRelation.getName() != null) {
            XMLMetaBeanReference relation = findBeanRef(beanRelation.getName());
            if (relation != null) {
                beanRelations.remove(relation);
            }
        }
        addBeanRef(beanRelation);
    }

    public XMLMetaBeanReference removeBeanRef(String name) {
        XMLMetaBeanReference relation = findBeanRef(name);
        if (relation != null) {
            beanRelations.remove(relation);
        }
        return relation;
    }

    public XMLMetaBeanReference getBeanRef(String name) {
        return findBeanRef(name);
    }

    private XMLMetaBeanReference findBeanRef(String name) {
        if (beanRelations == null) return null;
        for (XMLMetaBeanReference relation : beanRelations) {
            if (name.equals(relation.getName())) return relation;
        }
        return null;
    }

}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaBeanFactory.java
package org.apache.bval.xml;
import static org.apache.bval.model.Features.Property.JAVASCRIPT_VALIDATION_FUNCTIONS;


import org.apache.bval.MetaBeanFactory;
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.routines.StandardValidation;
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaBeanInfos.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import com.thoughtworks.xstream.annotations.XStreamOmitField;

import org.apache.bval.model.Validation;
import org.apache.commons.collections.FastHashMap;
import org.apache.commons.lang.ClassUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Description: root element of a xml-beanInfos document<br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 14:58:11 <br/>
 * Copyright: Agimatec GmbH 2008
 */
@XStreamAlias("beanInfos")
public class XMLMetaBeanInfos {
    @XStreamAsAttribute
    private String id;
    @XStreamAsAttribute
    private String version;
    @XStreamImplicit
    private List<XMLMetaValidator> validators;
    @XStreamImplicit
    private List<XMLMetaBean> beans;
    @XStreamOmitField
    private Map<String, XMLMetaBean> beanLookup;
    @XStreamOmitField
    private Map<String, XMLMetaValidator> validationLookup;

    /**
     * used for identification, may be empty, if there is no database origin for this object.
     * could also contain a file-name - can be used flexible...
     */
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    /**
     * used for change-detection, when some other component caches MetaBeans based on this
     * object. when the version changes, the cache could compare to its version state and recompute.
     * can be used flexible...
     */
    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    public List<XMLMetaValidator> getValidators() {
        return validators;
    }

    public void setValidators(List<XMLMetaValidator> validators) {
        this.validators = validators;
    }

    public List<XMLMetaBean> getBeans() {
        return beans;
    }

    public void setBeans(List<XMLMetaBean> beans) {
        this.beans = beans;
    }

    public XMLMetaBean getBean(String id) {
        if (beans == null) return null;
        if (beanLookup == null) initBeanLookup();
        return beanLookup.get(id);
    }

    private void initBeanLookup() {
        beanLookup = new FastHashMap();
        for (XMLMetaBean bean : beans) {
            beanLookup.put(bean.getId(), bean);
        }
        ((FastHashMap) beanLookup).setFast(true);
    }

    private void initValidationLookup() throws Exception {
        validationLookup = new FastHashMap();
        for (XMLMetaValidator xv : validators) {
            if (xv.getJava() != null) {
                Validation validation =
                        (Validation) ClassUtils.getClass(xv.getJava()).newInstance();
                xv.setValidation(validation);
                validationLookup.put(xv.getId(), xv);
            }
        }
        ((FastHashMap) validationLookup).setFast(true);
    }

    public void addBean(XMLMetaBean bean) {
        if (beans == null) beans = new ArrayList();
        beans.add(bean);
    }

    public XMLMetaValidator getValidator(String id) throws Exception {
        if (validators == null) return null;
        if (validationLookup == null) initValidationLookup();
        return validationLookup.get(id);
    }

    public void addValidator(XMLMetaValidator validator) {
        if (validators == null) validators = new ArrayList();
        validators.add(validator);
    }
}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaBeanLoader.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

import java.io.IOException;

/**
 * Description: XMLMetaBeanLoader are used to know "locations" where to get BeanInfos from.<br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 16:21:51 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public interface XMLMetaBeanLoader {
    XMLMetaBeanInfos load() throws IOException;
}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaBeanReference.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

import static org.apache.bval.model.Features.Property.REF_BEAN_ID;

import org.apache.bval.model.MetaProperty;

import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 14:48:01 <br/>
 * Copyright: Agimatec GmbH 2008
 */
@XStreamAlias("relationship")
public class XMLMetaBeanReference extends XMLMetaElement {
    @XStreamAsAttribute
    private String beanId;

    public XMLMetaBeanReference(String refId) {
        this.beanId = refId;
    }

    public XMLMetaBeanReference() {
    }

    /** id of referenced target bean of the relationship */
    public String getBeanId() {
        return beanId;
    }

    public void setBeanId(String beanId) {
        this.beanId = beanId;
    }

    @Override
    public void mergeInto(MetaProperty prop) throws ClassNotFoundException {
        super.mergeInto(prop);   // call super!
        if (getBeanId() != null) {
            prop.putFeature(REF_BEAN_ID, getBeanId());
        }
    }
}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaBeanRegistry.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

/**
 * Description: Interface of the object that holds all XMLMetaBeanLoaders <br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 09:21:38 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public interface XMLMetaBeanRegistry {
    /**
     * add a loader for xml bean infos.
     * the registry should use the loader in the sequence they have been added.
     */
    void addLoader(XMLMetaBeanLoader loader);

    /**
     * convenience method to add a loader for a xml file in the classpath
     *
     * @param resource - path of xml file in classpath
     */
    void addResourceLoader(String resource);
}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaBeanURLLoader.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 09:17:30 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class XMLMetaBeanURLLoader implements XMLMetaBeanLoader {
    private final URL url;

    public XMLMetaBeanURLLoader(URL url) {
        if (url == null) throw new NullPointerException("URL required");
        this.url = url;
    }

    public XMLMetaBeanInfos load() throws IOException {
        InputStream stream = url.openStream();
        try {
            XMLMetaBeanInfos beanInfos = (XMLMetaBeanInfos) XMLMapper.getInstance()
                    .getXStream().fromXML(stream);
            beanInfos.setId(url.toExternalForm());
            return beanInfos;
        } finally {
            stream.close();
        }
    }
}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaElement.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

import static org.apache.bval.model.Features.Property.*;

import com.thoughtworks.xstream.annotations.XStreamAsAttribute;

import org.apache.bval.model.MetaProperty;
import org.apache.commons.lang.ClassUtils;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 14:48:36 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class XMLMetaElement extends XMLFeaturesCapable {

    @XStreamAsAttribute()
    private String name;
    @XStreamAsAttribute()
    private String mandatory;

    @XStreamAsAttribute()
    private Integer minLength;
    @XStreamAsAttribute()
    private Integer maxLength;
    @XStreamAsAttribute()
    private Boolean readonly;
    @XStreamAsAttribute()
    private Boolean hidden;
    @XStreamAsAttribute()
    private Boolean denied;
    /**
     * normally the type is determined by the implementation class.
     * in case, no implementation class is given, the xml can
     * contain the type directly.
     */
    @XStreamAsAttribute()
    private String type;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getMandatory() {
        return mandatory;
    }

    public void setMandatory(String mandatory) {
        this.mandatory = mandatory;
    }

    public Integer getMinLength() {
        return minLength;
    }

    public void setMinLength(Integer minLength) {
        this.minLength = minLength;
    }

    public Integer getMaxLength() {
        return maxLength;
    }

    public void setMaxLength(Integer maxLength) {
        this.maxLength = maxLength;
    }

    public Boolean getReadonly() {
        return readonly;
    }

    public void setReadonly(Boolean readonly) {
        this.readonly = readonly;
    }

    public Boolean getDenied() {
        return denied;
    }

    public void setDenied(Boolean denied) {
        this.denied = denied;
    }

    public Boolean getHidden() {
        return hidden;
    }

    public void setHidden(Boolean hidden) {
        this.hidden = hidden;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public void mergeInto(MetaProperty prop) throws ClassNotFoundException {
        mergeFeaturesInto(prop);
        if (getType() != null && getType().length() > 0) {
            prop.setType(ClassUtils.getClass(getType())); // enhancement: or use getGenericType() ?
        }
        if (getHidden() != null) {
            prop.putFeature(HIDDEN, getHidden().booleanValue());
        }
        if (getMandatory() != null) {
            prop.putFeature(MANDATORY, getMandatory().equals("true"));
        }
        if (getMaxLength() != null) {
            prop.putFeature(MAX_LENGTH, getMaxLength());
        }
        if (getMinLength() != null) {
            prop.putFeature(MIN_LENGTH, getMinLength());
        }
        if (getReadonly() != null) {
            prop.putFeature(READONLY, getReadonly());
        }
        if (getDenied() != null) {
            prop.putFeature(DENIED, getDenied());
        }
    }
}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaFeature.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;

import java.io.Serializable;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 15:32:13 <br/>
 * Copyright: Agimatec GmbH 2008
 */
@XStreamAlias("feature")
public class XMLMetaFeature implements Serializable {
    @XStreamAsAttribute
    private String key;
    @XStreamAsAttribute
    private Object value;

    public XMLMetaFeature(String key, Object value) {
        this.key = key;
        this.value = value;
    }

    public XMLMetaFeature() {
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }


    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }
}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaProperty.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

import static org.apache.bval.model.Features.Property.*;

import org.apache.bval.model.MetaProperty;

import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 14:27:30 <br/>
 * Copyright: Agimatec GmbH 2008
 */
@XStreamAlias("property")
public class XMLMetaProperty extends XMLMetaElement {

    /**
     * if you need other types (Long, double, String) for maxValue and
     * minValue, configure via
     * <pre>
     * &lt;feature key="maxValue">
     *   &lt;value class="java.lang.Long">1000&lt;/value>
     * &lt;/feature>
     * </pre>
     * instead with explicit typing.
     */
    @XStreamAsAttribute()
    private Integer maxValue; // XStream requires a non-abstract type to parse XML
    @XStreamAsAttribute()
    private Integer minValue; // XStream requires a non-abstract type to parse XML

    private String regexp;

    @XStreamAsAttribute()
    private String timeLag;


    public Integer getMaxValue() {
        return maxValue;
    }

    public void setMaxValue(Integer maxValue) {
        this.maxValue = maxValue;
    }

    public Integer getMinValue() {
        return minValue;
    }

    public void setMinValue(Integer minValue) {
        this.minValue = minValue;
    }

    public String getRegexp() {
        return regexp;
    }

    public void setRegexp(String regexp) {
        this.regexp = regexp;
    }

    public String getTimeLag() {
        return timeLag;
    }

    public void setTimeLag(String timeLag) {
        this.timeLag = timeLag;
    }

    @Override
    public void mergeInto(MetaProperty prop) throws ClassNotFoundException {
        super.mergeInto(prop);   // call super!
        if (getMaxValue() != null) {
            prop.putFeature(MAX_VALUE, getMaxValue());
        }
        if (getMinValue() != null) {
            prop.putFeature(MIN_VALUE, getMinValue());
        }
        if (getRegexp() != null) {
            prop.putFeature(REG_EXP, getRegexp());
        }
        if (getTimeLag() != null) {
            prop.putFeature(TIME_LAG, getTimeLag());
        }
    }
}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaValidator.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import com.thoughtworks.xstream.annotations.XStreamOmitField;

import java.io.Serializable;

import org.apache.bval.model.Validation;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 14:34:46 <br/>
 * Copyright: Agimatec GmbH 2008
 */
@XStreamAlias("validator")
public class XMLMetaValidator implements Serializable {
    @XStreamAsAttribute
    private String id;
    @XStreamAsAttribute
    private String java;  // implementation of Validation

    @XStreamAsAttribute
    private String jsFunction; // name of java script function

    @XStreamOmitField
    private Validation validation;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getJava() {
        return java;
    }

    public void setJava(String java) {
        this.java = java;
    }

    public void setValidation(Validation validation) {
        this.validation = validation;
    }

    public Validation getValidation() {
        return validation;
    }

    public String getJsFunction() {
        return jsFunction;
    }

    public void setJsFunction(String jsFunction) {
        this.jsFunction = jsFunction;
    }
}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaValidatorReference.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;

import java.io.Serializable;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 15:27:18 <br/>
 * Copyright: Agimatec GmbH 2008
 */
@XStreamAlias("validator-ref")
public class XMLMetaValidatorReference implements Serializable {
    @XStreamAsAttribute
    private String refId;

    public XMLMetaValidatorReference(String id) {
        this.refId = id;
    }

    public XMLMetaValidatorReference() {
    }

    public String getRefId() {
        return refId;
    }

    public void setRefId(String refId) {
        this.refId = refId;
    }
}
 b/bval-core/src/main/java/org/apache/bval/xml/XMLMetaValue.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.xml;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 15:18:17 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public interface XMLMetaValue {
    // keys for Annotations
    public static final String ANNOKEY_Widget = "WIDGET";
    public static final String ANNOKEY_TableColumn = "TABLE_COLUMN";

    // values for TIMELAG
    public static final String TIMELAG_Past = "PAST";
    public static final String TIMELAG_Future = "FUTURE";

    // values for MANDATORY
    public static final String MANDATORY = "true";
    public static final String OPTIONAL = "false";
}
 b/bval-core/src/test/java/org/apache/bval/example/BusinessEnum.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.example;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 10.07.2007 <br/>
 * Time: 16:32:24 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public enum BusinessEnum {
    VALUE1, VALUE2, VALUE3
}
 b/bval-core/src/test/java/org/apache/bval/example/BusinessObject.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.example;

import java.sql.Timestamp;
import java.util.Date;
import java.util.List;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 05.07.2007 <br/>
 * Time: 11:41:34 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class BusinessObject {
    private long userId;
    private int numericValue;
    private String firstName, lastName, title;
    private Date dateBirth;
    private Timestamp validTo;
    private String email;
    private BusinessEnum choice;
    private BusinessObjectAddress address;
    private List<BusinessObjectAddress> addresses;
    private List properties;

    public BusinessEnum getChoice() {
        return choice;
    }

    public void setChoice(BusinessEnum choice) {
        this.choice = choice;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Date getDateBirth() {
        return dateBirth;
    }

    public void setDateBirth(Date dateBirth) {
        this.dateBirth = dateBirth;
    }

    public Timestamp getValidTo() {
        return validTo;
    }

    public void setValidTo(Timestamp validTo) {
        this.validTo = validTo;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public BusinessObjectAddress getAddress() {
        return address;
    }

    public void setAddress(BusinessObjectAddress address) {
        this.address = address;
    }

    public void setNumericValue(int newNumericValue) {
        numericValue = newNumericValue;
    }

    public int getNumericValue() {
        return numericValue;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public long getUserId() {
        return userId;
    }

    public void setUserId(long userId) {
        this.userId = userId;
    }

    public List<BusinessObjectAddress> getAddresses() {
        return addresses;
    }

    public void setAddresses(List<BusinessObjectAddress> addresses) {
        this.addresses = addresses;
    }

    public List getProperties() {
        return properties;
    }

    public void setProperties(List properties) {
        this.properties = properties;
    }
 b/bval-core/src/test/java/org/apache/bval/example/BusinessObjectAddress.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.example;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 06.07.2007 <br/>
 * Time: 09:13:50 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class BusinessObjectAddress {
    private String city, country;
    private BusinessObject owner;

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public BusinessObject getOwner() {
        return owner;
    }

    public void setOwner(BusinessObject owner) {
        this.owner = owner;
    }
}
 b/bval-core/src/test/java/org/apache/bval/example/BusinessObjectBeanInfo.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.example;


import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.beans.SimpleBeanInfo;

import org.apache.bval.model.Features;

/** Copyright: Agimatec GmbH 2008 */
public class BusinessObjectBeanInfo extends SimpleBeanInfo {
    Class targetClass = BusinessObject.class;

    @Override
    public BeanInfo[] getAdditionalBeanInfo() {
        ExplicitBeanInfo bi = new ExplicitBeanInfo();
        bi.setPropertyDescriptors(_getPropertyDescriptors());
        return new BeanInfo[]{bi};
    }

    public PropertyDescriptor[] _getPropertyDescriptors() {
        try {
            PropertyDescriptor numericValue = new PropertyDescriptor("numericValue",
                    targetClass, "getNumericValue", "setNumericValue");
            numericValue.setValue(Features.Property.MAX_VALUE, new Integer(100));
            numericValue.setValue(Features.Property.MIN_VALUE, new Integer(-100));
            return new PropertyDescriptor[]{numericValue};
        } catch (IntrospectionException ex) {
            ex.printStackTrace();
            return null;
        }
    }
}

class ExplicitBeanInfo extends SimpleBeanInfo {
    private PropertyDescriptor[] propertyDescriptors;

    @Override
    public PropertyDescriptor[] getPropertyDescriptors() {
        return propertyDescriptors;
    }

    public void setPropertyDescriptors(PropertyDescriptor[] propertyDescriptors) {
        this.propertyDescriptors = propertyDescriptors;
    }
 b/bval-core/src/test/java/org/apache/bval/example/ExampleBusinessObjectService.java
/**
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.bval.example;


import java.util.List;

import org.apache.bval.Validate;
import org.apache.bval.ValidationResults;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 09.07.2007 <br/>
 * Time: 13:51:59 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public interface ExampleBusinessObjectService {
    /** validated method example */
    @Validate
    public void saveBusinessObject(@Validate BusinessObject object, Object other);

    @Validate
    public void saveBusinessObjects(@Validate BusinessObject[] object);

    /** explicit validation example */
    public ValidationResults validateBusinessObject(
            @Validate("BusinessObject")BusinessObject object);

    /** query by example - example */
    public List<BusinessObject> findBusinessObjects(BusinessObject example);
}
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/AssertFalseValidator.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/AssertTrueValidator.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/DecimalMaxValidatorForNumber.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/DecimalMaxValidatorForString.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/DecimalMinValidatorForNumber.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/DecimalMinValidatorForString.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/DigitsValidatorForNumber.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/DigitsValidatorForString.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/Email.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.constraints;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Documented;
import static java.lang.annotation.ElementType.*;
import java.lang.annotation.Retention;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Target;

/**
 * <p>
 * --
 * This class is NOT part of the bean_validation spec and might disappear
 * as soon as a final version of the specification contains a similar functionality.
 * --
 * </p>
 * Description: annotation to validate an email address (by pattern)<br/>
 * User: roman.stumm <br/>
 * Date: 14.10.2008 <br/>
 * Time: 12:38:10 <br/>
 * Copyright: Agimatec GmbH
 */
@Documented
@Constraint(validatedBy = EmailValidator.class)
@Target({METHOD, FIELD, ANNOTATION_TYPE, PARAMETER})
@Retention(RUNTIME)
public @interface Email {
    Class<?>[] groups() default {};

    String message() default "{org.apache.bval.constraints.Email.message}";

    Class<? extends Payload>[] payload() default {};
}
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/EmailValidator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.constraints;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

import org.apache.bval.routines.EMailValidation;

/**
 * Description: pattern for validation taken from hibernate.<br/>
 * User: roman.stumm <br/>
 * Date: 14.10.2008 <br/>
 * Time: 12:38:37 <br/>
 * Copyright: Agimatec GmbH
 */
public class EmailValidator implements ConstraintValidator<Email, String> {
    protected final EMailValidation validation = new EMailValidation();

    public boolean isValid(String value, ConstraintValidatorContext context) {
        return validation.isValid(value);
    }

    public void initialize(Email parameters) {
        // do nothing (as long as Email has no properties)
    }
}
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/FutureValidatorForCalendar.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/FutureValidatorForDate.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/MaxValidatorForNumber.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/MaxValidatorForString.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/MinValidatorForNumber.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/MinValidatorForString.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/NotEmpty.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.constraints;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Documented;
import static java.lang.annotation.ElementType.*;
import java.lang.annotation.Retention;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Target;

/**
 * <pre>
 * This class is NOT part of the bean_validation spec and might disappear
 * as soon as a final version of the specification contains a similar functionality.
 * </pre>
 */
@Documented
@Constraint(
      validatedBy = {NotEmptyValidatorForCollection.class, NotEmptyValidatorForMap.class,
            NotEmptyValidatorForString.class, NotEmptyValidator.class})
@Target({METHOD, FIELD, ANNOTATION_TYPE, PARAMETER})
@Retention(RUNTIME)
public @interface NotEmpty {
    Class<?>[] groups() default {};

    String message() default "{org.apache.bval.constraints.NotEmpty.message}";

    Class<? extends Payload>[] payload() default {};
}
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/NotEmptyValidator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.constraints;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import java.lang.reflect.Array;
import java.lang.reflect.Method;

/**
 * Description:  Check the non emptyness of an
 * any object that has a public isEmpty():boolean or a valid toString() method
 */
public class NotEmptyValidator implements ConstraintValidator<NotEmpty, Object> {
    public void initialize(NotEmpty constraintAnnotation) {
        // do nothing
    }

    public boolean isValid(Object value, ConstraintValidatorContext context) {
        if (value == null) return true;
        if (value.getClass().isArray()) {
            return Array.getLength(value) > 0;
        } else {
            try {
                Method isEmptyMethod = value.getClass().getMethod("isEmpty");
                if (isEmptyMethod != null) {
                    return !((Boolean) isEmptyMethod.invoke(value)).booleanValue();
                }
            } catch (Exception ex) {
                // do nothing
            }
            return value.toString().length() > 0;
        }
    }
}
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/NotEmptyValidatorForCollection.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/NotEmptyValidatorForMap.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/NotEmptyValidatorForString.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/NotNullValidator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.constraints;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import javax.validation.constraints.NotNull;

/** valid when object is NOT null */
public class NotNullValidator implements ConstraintValidator<NotNull, Object> {
    public void initialize(NotNull constraintAnnotation) {
        // do nothing
    }

    public boolean isValid(Object value, ConstraintValidatorContext context) {
        return value != null;
    }
}
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/NullValidator.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/PastValidatorForCalendar.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/PastValidatorForDate.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/PatternValidator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.constraints;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import javax.validation.constraints.Pattern;
import java.util.regex.PatternSyntaxException;

/**
 * validator using a regular expression,
 * based on the jsr303 Pattern constraint annotation.
 */
public class PatternValidator implements ConstraintValidator<Pattern, String> {
    protected java.util.regex.Pattern pattern;

    public void initialize(Pattern annotation) {
        Pattern.Flag flags[] = annotation.flags();
        int intFlag = 0;
        for (Pattern.Flag flag : flags) {
            intFlag = intFlag | flag.getValue();
        }

        try {
            pattern = java.util.regex.Pattern.compile(annotation.regexp(), intFlag);
        } catch (PatternSyntaxException e) {
            throw new IllegalArgumentException("Invalid regular expression.", e);
        }
    }


    public boolean isValid(String value, ConstraintValidatorContext context) {
        return value == null || pattern.matcher(value).matches();
    }
}
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidator.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfBoolean.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfByte.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfChar.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfDouble.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfFloat.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfInt.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfLong.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfObject.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfShort.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForCollection.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForMap.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForString.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/AgimatecFactoryContext.java
package org.apache.bval.jsr303;
import org.apache.bval.*;

import org.apache.bval.IntrospectorMetaBeanFactory;
import org.apache.bval.MetaBeanBuilder;
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.MetaBeanManager;
import org.apache.bval.xml.XMLMetaBeanFactory;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/AgimatecValidationProvider.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303;

import javax.validation.Configuration;
import javax.validation.ValidationException;
import javax.validation.spi.BootstrapState;
import javax.validation.spi.ConfigurationState;
import javax.validation.spi.ValidationProvider;

/**
 * Description: Implementation of {@link ValidationProvider} for jsr303 implementation of
 * the agimatec-validation framework.
 * <p/>
 * <br/>
 * User: roman.stumm <br/>
 * Date: 29.10.2008 <br/>
 * Time: 14:45:41 <br/>
 * Copyright: Agimatec GmbH
 */
public class AgimatecValidationProvider
      implements ValidationProvider<AgimatecValidatorConfiguration> {
    public boolean isSuitable(Class<? extends Configuration<?>> builderClass) {
        return AgimatecValidatorConfiguration.class == builderClass;
    }

    public ConfigurationImpl createSpecializedConfiguration(BootstrapState state) {
        return new ConfigurationImpl(state, this);
    }

    public Configuration<?> createGenericConfiguration(BootstrapState state) {
        return new ConfigurationImpl(state, null);
    }

    /**
     * @throws javax.validation.ValidationException
     *          if the ValidatorFactory cannot be built
     */
    public AgimatecValidatorFactory buildValidatorFactory(ConfigurationState configuration) {
        try {
            AgimatecValidatorFactory factory = new AgimatecValidatorFactory();
            factory.configure(configuration);
            return factory;
        } catch (RuntimeException ex) {
            throw new ValidationException("error building ValidatorFactory", ex);
        }
    }

}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/AgimatecValidatorConfiguration.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303;

import javax.validation.Configuration;

/**
 * Description: Uniquely identify Agimatec Validation in the Bean Validation bootstrap
 * strategy. Also contains agimatec validation specific configurations<br/>
 * User: roman.stumm <br/>
 * Date: 28.10.2008 <br/>
 * Time: 16:16:45 <br/>
 * Copyright: Agimatec GmbH
 */
public interface AgimatecValidatorConfiguration
      extends Configuration<AgimatecValidatorConfiguration> {

    /**
     * proprietary property keys for {@link ConfigurationImpl}  
     */
    public interface Properties {
        /**
         * the location where to look for the validation.xml file.
         * default: "META-INF/validation.xml"
         */
        String VALIDATION_XML_PATH = "agimatec.validation-xml-path";

        /**
         * true/false. use Introspector (java beans) metadata additionally
         * to build metadata with JSR303.<br>
         * This means that all properties exist that are java-bean properties and
         * and that some features (Hidden, Readonly) are taken from Introspector
         * to create the meta data.<br>
         * default: false
         */
        String ENABLE_INTROSPECTOR = "agimatec.enable-introspector";

        /**
         * true/false. use agimatec metaBeans xml format additionally to
         * build metadata with JSR303.
         * default: false
         */
        String ENABLE_METABEANS_XML = "agimatec.enable-metabeans-xml";

        /**
         * BeanValidator.treatMapsLikeBeans.
         * default: false 
         */
         String TREAT_MAPS_LIKE_BEANS = "agimatec.treat-maps-like-beans";
    }
}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/AgimatecValidatorFactory.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303;


import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.jsr303.xml.AnnotationIgnores;
import org.apache.bval.jsr303.xml.MetaConstraint;
import org.apache.bval.jsr303.xml.ValidationMappingParser;
import org.apache.bval.util.AccessStrategy;
import org.apache.commons.lang.ClassUtils;

import javax.validation.*;
import javax.validation.bootstrap.ProviderSpecificBootstrap;
import javax.validation.spi.ConfigurationState;
import java.lang.annotation.Annotation;
import java.util.*;

/**
 * Description: a factory is a complete configurated object that can create validators<br/>
 * this instance is not thread-safe<br/>
 * User: roman.stumm <br/>
 * Date: 29.10.2008 <br/>
 * Time: 17:06:20 <br/>
 * Copyright: Agimatec GmbH
 */
public class AgimatecValidatorFactory implements ValidatorFactory, Cloneable {
    private static AgimatecValidatorFactory DEFAULT_FACTORY;
    private static final ConstraintDefaults defaultConstraints = new ConstraintDefaults();

    private MessageInterpolator messageResolver;
    private TraversableResolver traversableResolver;
    private ConstraintValidatorFactory constraintValidatorFactory;
    private final Map<String, String> properties;

    /** information from xml parsing */
    private final AnnotationIgnores annotationIgnores = new AnnotationIgnores();
    private final ConstraintCached constraintsCache = new ConstraintCached();
    private final Map<Class<?>, Class<?>[]> defaultSequences;
    /**
     * access strategies for properties with cascade validation @Valid support
     */
    private final Map<Class<?>, List<AccessStrategy>> validAccesses;
    private final Map<Class<?>, List<MetaConstraint<?, ? extends Annotation>>> constraintMap;

    /** convenience to retrieve a default global AgimatecValidatorFactory */
    public static AgimatecValidatorFactory getDefault() {
        if (DEFAULT_FACTORY == null) {
            ProviderSpecificBootstrap<AgimatecValidatorConfiguration> provider =
                  Validation.byProvider(AgimatecValidationProvider.class);
            AgimatecValidatorConfiguration configuration = provider.configure();
            DEFAULT_FACTORY = (AgimatecValidatorFactory) configuration
                  .buildValidatorFactory();
        }
        return DEFAULT_FACTORY;
    }

    public AgimatecValidatorFactory() {
        properties = new HashMap<String, String>();
        defaultSequences = new HashMap();
        validAccesses = new HashMap();
        constraintMap = new HashMap();
    }

    public void configure(ConfigurationState configuration) {
        getProperties().putAll(configuration.getProperties());
        setMessageInterpolator(configuration.getMessageInterpolator());
        setTraversableResolver(configuration.getTraversableResolver());
        setConstraintValidatorFactory(configuration.getConstraintValidatorFactory());
        ValidationMappingParser parser = new ValidationMappingParser(this);
        parser.processMappingConfig(configuration.getMappingStreams());
    }

    public Map<String, String> getProperties() {
        return properties;
    }

    protected MessageInterpolator getDefaultMessageInterpolator() {
        return messageResolver;
    }

    /**
     * shortcut method to create a new Validator instance with factory's settings
     *
     * @return the new validator instance
     */
    public Validator getValidator() {
        return usingContext().getValidator();
    }

    /** @return the validator factory's context */
    public AgimatecFactoryContext usingContext() {
        return new AgimatecFactoryContext(this);
    }

    @SuppressWarnings({"CloneDoesntDeclareCloneNotSupportedException"})
    @Override
    public synchronized AgimatecValidatorFactory clone() {
        try {
            return (AgimatecValidatorFactory) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new InternalError(); // VM bug.
        }
    }

    public final void setMessageInterpolator(MessageInterpolator messageResolver) {
        this.messageResolver = messageResolver;
    }

    public MessageInterpolator getMessageInterpolator() {
        return ((messageResolver != null) ? messageResolver : getDefaultMessageInterpolator());
    }

    public final void setTraversableResolver(TraversableResolver traversableResolver) {
        this.traversableResolver = traversableResolver;
    }

    public TraversableResolver getTraversableResolver() {
        return traversableResolver;
    }

    public ConstraintValidatorFactory getConstraintValidatorFactory() {
        return constraintValidatorFactory;
    }

    public final void setConstraintValidatorFactory(
          ConstraintValidatorFactory constraintValidatorFactory) {
        this.constraintValidatorFactory = constraintValidatorFactory;
    }

    /**
     * Return an object of the specified type to allow access to the
     * provider-specific API.  If the Bean Validation provider
     * implementation does not support the specified class, the
     * ValidationException is thrown.
     *
     * @param type the class of the object to be returned.
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not
     *                             support the call.
     */
    public <T> T unwrap(Class<T> type) {
        if (type.isAssignableFrom(getClass())) {
            return (T) this;
        } else if (!type.isInterface()) {
            return SecureActions.newInstance(type);
        } else {
            try {
                Class<T> cls = ClassUtils.getClass(type.getName()  "Impl");
                return SecureActions.newInstance(cls);
            } catch (ClassNotFoundException e) {
                throw new ValidationException("Type "  type  " not supported");
            }
        }
    }

    public ConstraintDefaults getDefaultConstraints() {
        return defaultConstraints;
    }

    public AnnotationIgnores getAnnotationIgnores() {
        return annotationIgnores;
    }

    public ConstraintCached getConstraintsCache() {
        return constraintsCache;
    }

    public void addMetaConstraint(Class<?> beanClass, MetaConstraint<?, ?> metaConstraint) {
        List<MetaConstraint<?,? extends Annotation>> slot = constraintMap.get(beanClass);
        if (slot != null) {
            slot.add(metaConstraint);
        } else {
            List<MetaConstraint<?, ? extends Annotation>> constraintList =
                  new ArrayList<MetaConstraint<?, ? extends Annotation>>();
            constraintList.add(metaConstraint);
            constraintMap.put(beanClass, constraintList);
        }
    }

    public void addValid(Class<?> beanClass, AccessStrategy accessStategy) {
        List<AccessStrategy> slot = validAccesses.get(beanClass);
        if (slot != null) {
            slot.add(accessStategy);
        } else {
            List<AccessStrategy> tmpList = new ArrayList();
            tmpList.add(accessStategy);
            validAccesses.put(beanClass, tmpList);
        }
    }

    public void addDefaultSequence(Class<?> beanClass, Class<?>[] groupSequence) {
        defaultSequences.put(beanClass, groupSequence);
    }

    public <T> List<MetaConstraint<T, ? extends Annotation>> getMetaConstraints(
          Class<T> beanClass) {
        List<MetaConstraint<?,? extends Annotation>> slot = constraintMap.get(beanClass);
        if (slot != null) {
            //noinspection RedundantCast
            return (List)slot;
        } else {
            return Collections.EMPTY_LIST;
        }
    }

    public List<AccessStrategy> getValidAccesses(Class<?> beanClass) {
        List<AccessStrategy> slot = validAccesses.get(beanClass);
        if (slot != null) {
            return slot;
        } else {
            return Collections.EMPTY_LIST;
        }
    }

    public Class<?>[] getDefaultSequence(Class<?> beanClass) {
        return defaultSequences.get(beanClass);
    }

}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/AnnotationConstraintBuilder.java
package org.apache.bval.jsr303;

import org.apache.bval.jsr303.groups.GroupsComputer;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.AccessStrategy;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/AppendValidation.java
package org.apache.bval.jsr303;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/AppendValidationToBuilder.java
package org.apache.bval.jsr303;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/AppendValidationToMeta.java
package org.apache.bval.jsr303;
import org.apache.bval.model.FeaturesCapable;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/BeanDescriptorImpl.java
package org.apache.bval.jsr303;

import org.apache.bval.model.Features;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ClassValidator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303;


import org.apache.bval.BeanValidator;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.Groups;
import org.apache.bval.jsr303.groups.GroupsComputer;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.ValidationContext;
import org.apache.commons.lang.ClassUtils;

import javax.validation.ConstraintViolation;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.metadata.BeanDescriptor;
import java.util.List;
import java.util.Set;

/**
 * API class -
 * Description:
 * instance is able to validate bean instances (and the associated object graphs).
 * concurrent, multithreaded access implementation is safe.
 * It is recommended to cache the instance.
 * <br/>
 * User: roman.stumm <br/>
 * Date: 01.04.2008 <br/>
 * Time: 13:36:33 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class ClassValidator extends BeanValidator implements Validator {
    protected final AgimatecFactoryContext factoryContext;
    protected final GroupsComputer groupsComputer = new GroupsComputer();

    public ClassValidator(AgimatecFactoryContext factoryContext) {
        super(factoryContext.getMetaBeanFinder());
        this.factoryContext = factoryContext;
    }

    /** @deprecated provided for backward compatibility */
    public ClassValidator(AgimatecValidatorFactory factory) {
        this(factory.usingContext());
    }

    /**
     * validate all constraints on object
     *
     * @throws javax.validation.ValidationException
     *          if a non recoverable error happens during the validation process
     */
    public <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groupArray) {
        if (object == null) throw new IllegalArgumentException("cannot validate null");
        try {
            final GroupValidationContext<ConstraintValidationListener<T>> context =
                  createContext(factoryContext.getMetaBeanFinder()
                        .findForClass(object.getClass()), object, groupArray);
            final ConstraintValidationListener result = context.getListener();
            final Groups groups = context.getGroups();
            // 1. process groups
            for (Group current : groups.getGroups()) {
                context.setCurrentGroup(current);
                validateContext(context);
            }
            // 2. process sequences
            for (List<Group> eachSeq : groups.getSequences()) {
                for (Group current : eachSeq) {
                    context.setCurrentGroup(current);
                    validateContext(context);
                    /**
                     * if one of the group process in the sequence leads to one or more validation failure,
                     * the groups following in the sequence must not be processed
                     */
                    if (!result.isEmpty()) break;
                }
//                if (!result.isEmpty()) break; // ?? TODO RSt - clarify!
            }
            return result.getConstaintViolations();
        } catch (RuntimeException ex) {
            throw unrecoverableValidationError(ex, object);
        }
    }

    @Override
    public void validateBeanNet(ValidationContext vcontext) {
        GroupValidationContext context = (GroupValidationContext) vcontext;
        List<Group> defaultGroups = expandDefaultGroup(context);
        if (defaultGroups != null) {
            Group currentGroup = context.getCurrentGroup();
            for (Group each : defaultGroups) {
                context.setCurrentGroup(each);
                super.validateBeanNet(context);
                // continue validation, even if errors already found: if (!result.isEmpty())
            }
            context.setCurrentGroup(currentGroup); // restore  (finally{} not required)
        } else {
            super.validateBeanNet(context);
        }
    }

    /**
     * in case of a default group return the list of groups
     * for a redefined default GroupSequence
     *
     * @return null when no in default group or default group sequence not redefined
     */
    private List<Group> expandDefaultGroup(GroupValidationContext context) {
        if (context.getCurrentGroup().isDefault()) {
            // mention if metaBean redefines the default group
            List<Group> groupSeq =
                  context.getMetaBean().getFeature(Jsr303Features.Bean.GROUP_SEQUENCE);
            if (groupSeq != null) {
                context.getGroups().assertDefaultGroupSequenceIsExpandable(groupSeq);
            }
            return groupSeq;
        } else {
            return null;
        }
    }

    protected ValidationException unrecoverableValidationError(RuntimeException ex,
                                                               Object object) {
        if (ex instanceof ValidationException) {
            throw ex; // do not wrap specific ValidationExceptions (or instances from subclasses)
        } else {
            throw new ValidationException("error during validation of "  object, ex);
        }
    }

    /**
     * validate all constraints on <code>propertyName</code> property of object
     *
     * @param propertyName - the attribute name, or nested property name (e.g. prop[2].subpropA.subpropB)
     * @throws javax.validation.ValidationException
     *          if a non recoverable error happens
     *          during the validation process
     */
    public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName,
                                                            Class<?>... groups) {
        if (object == null) throw new IllegalArgumentException("cannot validate null");
        try {
            MetaBean metaBean =
                  factoryContext.getMetaBeanFinder().findForClass(object.getClass());
            GroupValidationContext<ConstraintValidationListener<T>> context =
                  createContext(metaBean, object, groups);
            ConstraintValidationListener result = context.getListener();
            NestedMetaProperty nestedProp = getNestedProperty(metaBean, object, propertyName);
            context.setMetaProperty(nestedProp.getMetaProperty());
            if (nestedProp.isNested()) {
                context.setFixedValue(nestedProp.getValue());
            } else {
                context.setMetaProperty(nestedProp.getMetaProperty());
            }
            if (context.getMetaProperty() == null) throw new IllegalArgumentException(
                  "Unknown property "  object.getClass().getName()  "."  propertyName);
            Groups sequence = context.getGroups();
            // 1. process groups
            for (Group current : sequence.getGroups()) {
                context.setCurrentGroup(current);
                validatePropertyInGroup(context);
            }
            // 2. process sequences
            for (List<Group> eachSeq : sequence.getSequences()) {
                for (Group current : eachSeq) {
                    context.setCurrentGroup(current);
                    validatePropertyInGroup(context);
                    /**
                     * if one of the group process in the sequence leads to one or more validation failure,
                     * the groups following in the sequence must not be processed
                     */
                    if (!result.isEmpty()) break;
                }
//                if (!result.isEmpty()) break; // ?? TODO RSt - clarify!
            }
            return result.getConstaintViolations();
        } catch (RuntimeException ex) {
            throw unrecoverableValidationError(ex, object);
        }
    }

    private void validatePropertyInGroup(GroupValidationContext context) {
        Group currentGroup = context.getCurrentGroup();
        List<Group> defaultGroups = expandDefaultGroup(context);
        if (defaultGroups != null) {
            for (Group each : defaultGroups) {
                context.setCurrentGroup(each);
                validateProperty(context);
                // continue validation, even if errors already found: if (!result.isEmpty())
            }
            context.setCurrentGroup(currentGroup); // restore
        } else {
            validateProperty(context);
        }
    }

    /**
     * find the MetaProperty for the given propertyName,
     * which could contain a path, following the path on a given object to resolve
     * types at runtime from the instance
     */
    private NestedMetaProperty getNestedProperty(MetaBean metaBean, Object t,
                                                 String propertyName) {
        NestedMetaProperty nested = new NestedMetaProperty(propertyName, t);
        nested.setMetaBean(metaBean);
        nested.parse();
        return nested;
    }

    /**
     * validate all constraints on <code>propertyName</code> property
     * if the property value is <code>value</code>
     *
     * @throws javax.validation.ValidationException
     *          if a non recoverable error happens
     *          during the validation process
     */
    public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType,
                                                         String propertyName, Object value,
                                                         Class<?>... groups) {
        try {
            MetaBean metaBean = factoryContext.getMetaBeanFinder().findForClass(beanType);
            GroupValidationContext<ConstraintValidationListener<T>> context =
                  createContext(metaBean, null, groups);
            ConstraintValidationListener result = context.getListener();
            context.setMetaProperty(
                  getNestedProperty(metaBean, null, propertyName).getMetaProperty());
            context.setFixedValue(value);
            Groups sequence = context.getGroups();
            // 1. process groups
            for (Group current : sequence.getGroups()) {
                context.setCurrentGroup(current);
                validatePropertyInGroup(context);
            }
            // 2. process sequences
            for (List<Group> eachSeq : sequence.getSequences()) {
                for (Group current : eachSeq) {
                    context.setCurrentGroup(current);
                    validatePropertyInGroup(context);
                    /**
                     * if one of the group process in the sequence leads to one or more validation failure,
                     * the groups following in the sequence must not be processed
                     */
                    if (!result.isEmpty()) break;
                }
//                if (!result.isEmpty()) break; // ?? TODO RSt - clarify!
            }
            return result.getConstaintViolations();
        } catch (RuntimeException ex) {
            throw unrecoverableValidationError(ex, value);
        }
    }

    protected <T> GroupValidationContext<ConstraintValidationListener<T>> createContext(
          MetaBean metaBean, T object, Class<?>[] groups) {
        ConstraintValidationListener<T> listener = new ConstraintValidationListener<T>(object);
        GroupValidationContextImpl<ConstraintValidationListener<T>> context =
              new GroupValidationContextImpl(listener,
                    this.factoryContext.getMessageInterpolator(),
                    this.factoryContext.getTraversableResolver(), metaBean);
        context.setBean(object, metaBean);
        context.setGroups(groupsComputer.computeGroups(groups));
        return context;
    }

    /**
     * Return the descriptor object describing bean constraints
     * The returned object (and associated objects including ConstraintDescriptors)
     * are immutable.
     *
     * @throws ValidationException if a non recoverable error happens
     *                             during the metadata discovery or if some
     *                             constraints are invalid.
     */
    public BeanDescriptor getConstraintsForClass(Class<?> clazz) {
        try {
            MetaBean metaBean = factoryContext.getMetaBeanFinder().findForClass(clazz);
            BeanDescriptorImpl edesc =
                  metaBean.getFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR);
            if (edesc == null) {
                edesc = createBeanDescriptor(metaBean);
                metaBean.putFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR, edesc);
            }
            return edesc;
        } catch (RuntimeException ex) {
            throw new ValidationException("error retrieving constraints for "  clazz, ex);
        }
    }

    protected BeanDescriptorImpl createBeanDescriptor(MetaBean metaBean) {
        return new BeanDescriptorImpl(factoryContext, metaBean, metaBean.getValidations());
    }

    /**
     * Return an object of the specified type to allow access to the
     * provider-specific API.  If the Bean Validation provider
     * implementation does not support the specified class, the
     * ValidationException is thrown.
     *
     * @param type the class of the object to be returned.
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not
     *                             support the call.
     */
    public <T> T unwrap(Class<T> type) {
        if (type.isAssignableFrom(getClass())) {
            return (T) this;
        } else if (!type.isInterface()) {
            return SecureActions.newInstance(type, new Class[]{AgimatecFactoryContext.class},
                  new Object[]{factoryContext});
        } else {
            try {
                Class<T> cls = ClassUtils.getClass(type.getName()  "Impl");
                return SecureActions.newInstance(cls,
                      new Class[]{AgimatecFactoryContext.class}, new Object[]{factoryContext});
            } catch (ClassNotFoundException e) {
                throw new ValidationException("Type "  type  " not supported");
            }
        }
    }

}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ConfigurationImpl.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303;


import org.apache.bval.jsr303.resolver.DefaultTraversableResolver;
import org.apache.bval.jsr303.xml.ValidationParser;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.validation.*;
import javax.validation.spi.BootstrapState;
import javax.validation.spi.ConfigurationState;
import javax.validation.spi.ValidationProvider;
import java.io.InputStream;
import java.util.*;

/**
 * Description: used to configure agimatec-validation for jsr303.
 * Implementation of Configuration that also implements ConfigurationState,
 * hence this can be passed to buildValidatorFactory(ConfigurationState).
 * <br/>
 * User: roman.stumm <br/>
 * Date: 29.10.2008 <br/>
 * Time: 14:47:44 <br/>
 * Copyright: Agimatec GmbH
 */
public class ConfigurationImpl implements AgimatecValidatorConfiguration, ConfigurationState {
    private static final Log log = LogFactory.getLog(ConfigurationImpl.class);
    
    protected final ValidationProvider provider;
    protected final ValidationProviderResolver providerResolver;
    protected Class<? extends ValidationProvider<?>> providerClass;
    protected MessageInterpolator messageInterpolator;
    protected ConstraintValidatorFactory constraintValidatorFactory;
    private TraversableResolver traversableResolver;

    // BEGIN DEFAULTS
    /**
     * false = dirty flag (to prevent from multiple parsing validation.xml)
     */
    private boolean prepared = false;
    private final TraversableResolver defaultTraversableResolver =
          new DefaultTraversableResolver();
    protected final MessageInterpolator defaultMessageInterpolator =
          new DefaultMessageInterpolator();
    private final ConstraintValidatorFactory defaultConstraintValidatorFactory =
          new DefaultConstraintValidatorFactory();
    // END DEFAULTS

    private Set<InputStream> mappingStreams = new HashSet<InputStream>();
    private Map<String, String> properties = new HashMap<String, String>();
    private boolean ignoreXmlConfiguration = false;

    public ConfigurationImpl(BootstrapState aState, ValidationProvider aProvider) {
        if (aProvider != null) {
            this.provider = aProvider;
            this.providerResolver = null;
        } else if (aState != null) {
            this.provider = null;
            if (aState.getValidationProviderResolver() == null) {
                providerResolver = aState.getDefaultValidationProviderResolver();
            } else {
                providerResolver = aState.getValidationProviderResolver();
            }
        } else {
            throw new ValidationException("either provider or state are required");
        }
    }

    public AgimatecValidatorConfiguration traversableResolver(TraversableResolver resolver) {
        traversableResolver = resolver;
        this.prepared = false;
        return this;
    }

    /**
     * Ignore data from the <i>META-INF/validation.xml</i> file if this
     * method is called.
     *
     * @return this
     */
    public AgimatecValidatorConfiguration ignoreXmlConfiguration() {
        ignoreXmlConfiguration = true;
//        this.prepared = false;
        return this;
    }

    public ConfigurationImpl messageInterpolator(MessageInterpolator resolver) {
        this.messageInterpolator = resolver;
        this.prepared = false;
        return this;
    }

    public ConfigurationImpl constraintValidatorFactory(
          ConstraintValidatorFactory constraintFactory) {
        this.constraintValidatorFactory = constraintFactory;
        this.prepared = false;
        return this;
    }

    /**
     * Add a stream describing constraint mapping in the Bean Validation
     * XML format.
     *
     * @return this
     */
    public AgimatecValidatorConfiguration addMapping(InputStream stream) {
        mappingStreams.add(stream);
        return this;
    }

    /**
     * Add a provider specific property. This property is equivalent to
     * XML configuration properties.
     * If we do not know how to handle the property, we silently ignore it.
     *
     * @return this
     */
    public AgimatecValidatorConfiguration addProperty(String name, String value) {
        properties.put(name, value);
        return this;
    }

    /**
     * Return a map of non type-safe custom properties.
     *
     * @return null
     */
    public Map<String, String> getProperties() {
        return properties;
    }

    /**
     * Returns true if Configuration.ignoreXMLConfiguration() has been called.
     * In this case, we ignore META-INF/validation.xml
     *
     * @return true
     */
    public boolean isIgnoreXmlConfiguration() {
        return ignoreXmlConfiguration;
    }

    public Set<InputStream> getMappingStreams() {
        return mappingStreams;
    }

    public MessageInterpolator getMessageInterpolator() {
        return messageInterpolator;
    }

    public MessageInterpolator getDefaultMessageInterpolator() {
        return defaultMessageInterpolator;
    }

    public TraversableResolver getDefaultTraversableResolver() {
        return defaultTraversableResolver;
    }

    public ConstraintValidatorFactory getDefaultConstraintValidatorFactory() {
        return defaultConstraintValidatorFactory;
    }

    /**
     * main factory method to build a ValidatorFactory
     *
     * @throw ValidationException if the ValidatorFactory cannot be built
     */
    public ValidatorFactory buildValidatorFactory() {
        prepare();
        if (provider != null) {
            return provider.buildValidatorFactory(this);
        } else {
            return findProvider().buildValidatorFactory(this);
        }
    }

    private void prepare() {
        if (prepared) return;
        parseValidationXml();
        applyDefaults();
        prepared = true;
    }

    /** Check whether a validation.xml file exists and parses it with JAXB */
    private void parseValidationXml() {
        if (isIgnoreXmlConfiguration()) {
            log.info("ignoreXmlConfiguration == true");
        } else {
            new ValidationParser(getProperties().get(Properties.VALIDATION_XML_PATH))
                  .processValidationConfig(this);
        }
    }

    private void applyDefaults() {
        // make sure we use the defaults in case they haven't been provided yet
        if (traversableResolver == null) {
            traversableResolver = getDefaultTraversableResolver();
        }
        if (messageInterpolator == null) {
            messageInterpolator = getDefaultMessageInterpolator();
        }
        if (constraintValidatorFactory == null) {
            constraintValidatorFactory = getDefaultConstraintValidatorFactory();
        }
    }

    /**
     * @return the constraint validator factory of this configuration.
     */
    public ConstraintValidatorFactory getConstraintValidatorFactory() {
        return constraintValidatorFactory;
    }

    public TraversableResolver getTraversableResolver() {
        return traversableResolver;
    }

    public ValidationProvider getProvider() {
        return provider;
    }

    private ValidationProvider findProvider() {
        if (providerClass != null) {
            for (ValidationProvider provider : providerResolver
                  .getValidationProviders()) {
                if (providerClass.isAssignableFrom(provider.getClass())) {
                    return provider;
                }
            }
            throw new ValidationException(
                  "Unable to find suitable provider: "  providerClass);
        } else {
            List<ValidationProvider<?>> providers = providerResolver.getValidationProviders();
            return providers.get(0);
        }
    }

    public void setProviderClass(Class<? extends ValidationProvider<?>> providerClass) {
        this.providerClass = providerClass;
    }

}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ConstraintCached.java
package org.apache.bval.jsr303;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ConstraintDefaults.java
package org.apache.bval.jsr303;
import org.apache.bval.jsr303.util.SecureActions;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ConstraintFinderImpl.java
package org.apache.bval.jsr303;

import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.Groups;
import org.apache.bval.jsr303.groups.GroupsComputer;
import org.apache.bval.model.MetaBean;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ConstraintValidation.java
package org.apache.bval.jsr303;

import org.apache.bval.BeanValidationContext;
import org.apache.bval.ValidationResults;
import org.apache.bval.jsr303.util.NodeImpl;
import org.apache.bval.jsr303.util.PathImpl;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.util.AccessStrategy;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ConstraintValidationListener.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package org.apache.bval.jsr303;


import javax.validation.ConstraintViolation;
import javax.validation.MessageInterpolator;
import javax.validation.Path;
import javax.validation.metadata.ConstraintDescriptor;

import org.apache.bval.jsr303.util.PathImpl;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;

import java.util.HashSet;
import java.util.Set;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 01.04.2008 <br/>
 * Time: 14:52:19 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public final class ConstraintValidationListener<T> implements ValidationListener {
    private final Set<ConstraintViolation<T>> constaintViolations = new HashSet();
    private final T rootBean;

    public ConstraintValidationListener(T aRootBean) {
        this.rootBean = aRootBean;
    }

    @SuppressWarnings({"ManualArrayToCollectionCopy"})
    public void addError(String reason, ValidationContext context) {
        addError(reason, null, context);
    }

    public void addError(Error error, ValidationContext context) {
        if (error.getOwner() instanceof Path) {
            addError(error.getReason(), (Path) error.getOwner(), context);
        } else {
            addError(error.getReason(), null, context);
        }
    }

    private void addError(String messageTemplate, Path propPath,
                          ValidationContext context) {
        final Object value;

        final ConstraintDescriptor constraint;
        final String message;
        if (context instanceof GroupValidationContext) {
            GroupValidationContext gcontext = (GroupValidationContext) context;
            value = gcontext.getValidatedValue();
            if (gcontext instanceof MessageInterpolator.Context) {
                message = gcontext.getMessageResolver()
                      .interpolate(messageTemplate,
                            (MessageInterpolator.Context) gcontext);
            } else {
                message =
                      gcontext.getMessageResolver().interpolate(messageTemplate, null);
            }
            constraint = gcontext.getConstraintDescriptor();
            if (propPath == null) propPath = gcontext.getPropertyPath();
        } else {
            if (context.getMetaProperty() == null) value = context.getBean();
            else value = context.getPropertyValue();                        
            message = messageTemplate;
            if (propPath == null)
                propPath = PathImpl.createPathFromString(context.getPropertyName());
            constraint = null;
        }
        ConstraintViolationImpl<T> ic = new ConstraintViolationImpl<T>(messageTemplate,
              message, rootBean, context.getBean(), propPath, value, constraint);
        constaintViolations.add(ic);
    }

    public Set<ConstraintViolation<T>> getConstaintViolations() {
        return constaintViolations;
    }

    public boolean isEmpty() {
        return constaintViolations.isEmpty();
    }

    public T getRootBean() {
        return rootBean;
    }
}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ConstraintValidatorContextImpl.java
package org.apache.bval.jsr303;

import org.apache.bval.jsr303.util.NodeBuilderDefinedContextImpl;
import org.apache.bval.jsr303.util.NodeImpl;
import org.apache.bval.jsr303.util.PathImpl;
import org.apache.bval.model.ValidationListener;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ConstraintViolationImpl.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package org.apache.bval.jsr303;

import javax.validation.ConstraintViolation;
import javax.validation.Path;
import javax.validation.metadata.ConstraintDescriptor;

/**
 * Description: Describe a constraint validation defect<br/>
 * From rootBean and propertyPath, it is possible to rebuild the context of the failure
 * User: roman.stumm <br/>
 * Date: 01.04.2008 <br/>
 * Time: 14:50:12 <br/>
 * Copyright: Agimatec GmbH 2008
 */
class ConstraintViolationImpl<T> implements ConstraintViolation<T> {
    private final String messageTemplate;
    private final String message;
    /** root bean validation was invoked on. */
    private final T rootBean;
    /** last bean validated. */
    private final Object leafBean;
    private final Object value;
    private final Path propertyPath;
    private final ConstraintDescriptor constraintDescriptor;

    /**
     * @param messageTemplate - message reason (raw message) 
     * @param message - interpolated message (locale specific)
     * @param rootBean
     * @param leafBean
     * @param propertyPath
     * @param value
     * @param constraintDescriptor
     */
    public ConstraintViolationImpl(String messageTemplate, String message, T rootBean, Object leafBean,
                                   Path propertyPath, Object value,
                                   ConstraintDescriptor constraintDescriptor) {
        this.messageTemplate = messageTemplate;
        this.message = message;
        this.rootBean = rootBean;
        this.propertyPath = propertyPath;
        this.leafBean = leafBean;
        this.value = value;
        this.constraintDescriptor = constraintDescriptor;
    }

    /**
     * former name getInterpolatedMessage()
     * @return The interpolated error message for this constraint violation.
     **/
    public String getMessage() {
        return message;
    }

    public String getMessageTemplate() {
        return messageTemplate;
    }

    /** Root bean being validated validated */
    public T getRootBean() {
        return rootBean;
    }

    public Class getRootBeanClass() {
        return rootBean == null ? null : rootBean.getClass();
    }

    public Object getLeafBean() {
        return leafBean;
    }

    /** The value failing to pass the constraint */
    public Object getInvalidValue() {
        return value;
    }

    /**
     * the property path to the value from <code>rootBean</code>
     * Null if the value is the rootBean itself
     */
    public Path getPropertyPath() {
        return propertyPath;
    }

    public ConstraintDescriptor getConstraintDescriptor() {
        return constraintDescriptor;
    }

    public String toString() {
        return "ConstraintViolationImpl{"  "rootBean="  rootBean  ", propertyPath='" 
              propertyPath  '\''  ", message='"  message  '\''  ", leafBean=" 
              leafBean  ", value="  value  '}';
    }
}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/DefaultConstraintValidatorFactory.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303;


import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorFactory;

import org.apache.bval.jsr303.util.SecureActions;

/**
 * Description: create constraint instances with the default / no-arg constructor <br/>
 * User: roman.stumm <br/>
 * Date: 01.04.2008 <br/>
 * Time: 13:18:36 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class DefaultConstraintValidatorFactory implements ConstraintValidatorFactory {
    /**
     * Instantiate a Constraint.
     *
     * @return Returns a new Constraint instance
     *         The ConstraintFactory is <b>not</b> responsible for calling Constraint#initialize
     */
    public <T extends ConstraintValidator<?, ?>> T getInstance(Class<T> constraintClass) {
        return SecureActions.newInstance(constraintClass);
    }
}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/DefaultMessageInterpolator.java
package org.apache.bval.jsr303;
          "org.apache.bval.jsr303.ValidationMessages";
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/DefaultValidationProviderResolver.java
package org.apache.bval.jsr303;

import org.apache.bval.jsr303.util.SecureActions;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ElementDescriptorImpl.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package org.apache.bval.jsr303;


import javax.validation.metadata.ConstraintDescriptor;
import javax.validation.metadata.ElementDescriptor;

import org.apache.bval.model.MetaBean;
import org.apache.bval.model.Validation;

import java.util.HashSet;
import java.util.Set;

/**
 * Description: MetaData class<br/>
 * User: roman.stumm <br/>
 * Date: 02.04.2008 <br/>
 * Time: 12:23:45 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public abstract class ElementDescriptorImpl implements ElementDescriptor {
    protected final MetaBean metaBean;
    protected final Class elementClass;
    private Set<ConstraintDescriptor<?>> constraintDescriptors;

    protected ElementDescriptorImpl(MetaBean metaBean,
                                 Validation[] validations) {
        this.metaBean = metaBean;
        this.elementClass = metaBean.getBeanClass();
        createConstraintDescriptors(validations);
    }

    protected ElementDescriptorImpl(Class elementClass, Validation[] validations) {
        this.metaBean = null;
        this.elementClass = elementClass;
        createConstraintDescriptors(validations);
    }

    /** @return Statically defined returned type. */
    public Class getElementClass() {
        return elementClass;
    }

    public ElementDescriptor.ConstraintFinder findConstraints() {
        return new ConstraintFinderImpl(metaBean, constraintDescriptors);
    }

    public Set<ConstraintDescriptor<?>> getConstraintDescriptors() {
        return constraintDescriptors;
    }

    /** return true if at least one constraint declaration is present on the element. */
    public boolean hasConstraints() {
        return !constraintDescriptors.isEmpty();
    }

    private void createConstraintDescriptors(Validation[] validations) {
        final Set<ConstraintDescriptor<?>> cds = new HashSet(validations.length);
        for (Validation validation : validations) {
            if (validation instanceof ConstraintValidation) {
                ConstraintValidation cval = (ConstraintValidation) validation;
                cds.add(cval);
            }
        }
        setConstraintDescriptors(cds);
    }

    public void setConstraintDescriptors(Set<ConstraintDescriptor<?>> constraintDescriptors) {
        this.constraintDescriptors = constraintDescriptors;
    }

    public MetaBean getMetaBean() {
        return metaBean;
    }
}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/GroupValidationContext.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package org.apache.bval.jsr303;


import javax.validation.ConstraintValidator;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;

import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.Groups;
import org.apache.bval.jsr303.util.PathImpl;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 28.04.2008 <br/>
 * Time: 10:15:08 <br/>
 * Copyright: Agimatec GmbH
 */
public interface GroupValidationContext<T extends ValidationListener>
      extends ValidationContext<T> {
    /** the groups in their sequence for validation */
    Groups getGroups();

    void setCurrentGroup(Group group);

    Group getCurrentGroup();

    PathImpl getPropertyPath();

    MetaBean getRootMetaBean();

    void setConstraintDescriptor(ConstraintValidation constraint);

    public ConstraintValidation getConstraintDescriptor();

    public Object getValidatedValue();

    void setFixedValue(Object value);

    MessageInterpolator getMessageResolver();

    TraversableResolver getTraversableResolver();

    boolean collectValidated(Object bean, ConstraintValidator constraint);

}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/GroupValidationContextImpl.java
package org.apache.bval.jsr303;

import org.apache.bval.BeanValidationContext;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.Groups;
import org.apache.bval.jsr303.resolver.CachingTraversableResolver;
import org.apache.bval.jsr303.util.NodeImpl;
import org.apache.bval.jsr303.util.PathImpl;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.util.AccessStrategy;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/Jsr303Features.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303;

import org.apache.bval.model.Features;

/**
 * Description: Contains MetaBean feature keys of additional features used in the implementation
 * of JSR303<br/>
 * User: roman.stumm <br/>
 * Date: 02.04.2008 <br/>
 * Time: 15:22:49 <br/>
 * Copyright: Agimatec GmbH 2008
 *
 * @see org.apache.bval.model.FeaturesCapable
 * @see org.apache.bval.model.Features
 */
public interface Jsr303Features {
    interface Property extends Features.Property {
        /** INFO: cached PropertyDescriptorImpl of the property */
        String PropertyDescriptor = "PropertyDescriptor";
    }

    interface Bean extends Features.Bean {
        /**
         * INFO: List of Group(Class) for {@link javax.validation.GroupSequence#value()}
         * (redefined default group)
         **/
        String GROUP_SEQUENCE = "GroupSequence";

        /** INFO: cached sortied Array with ValidationEntries */
        String VALIDATION_SEQUENCE = "ValidationSequence";

        /**
         * INFO: cached BeanDescriptorImpl of the bean
         */
        String BEAN_DESCRIPTOR = "BeanDescriptor";
    }
}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/Jsr303MetaBeanFactory.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303;


import org.apache.bval.MetaBeanFactory;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.jsr303.util.TypeUtils;
import org.apache.bval.jsr303.xml.MetaConstraint;
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.ClassUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.validation.*;
import javax.validation.groups.Default;
import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Description: process the class annotations for JSR303 constraint validations
 * to build the MetaBean with information from annotations and JSR303 constraint
 * mappings (defined in xml)<br/>
 * User: roman.stumm <br/>
 * Date: 01.04.2008 <br/>
 * Time: 14:12:51 <br/>
 * Copyright: Agimatec GmbH 2008
 */
public class Jsr303MetaBeanFactory implements MetaBeanFactory {
    protected static final Log log = LogFactory.getLog(Jsr303MetaBeanFactory.class);
    protected static final String ANNOTATION_VALUE = "value";
    protected final AgimatecFactoryContext factoryContext;

    public Jsr303MetaBeanFactory(AgimatecFactoryContext factoryContext) {
        this.factoryContext = factoryContext;
    }

    private ConstraintValidatorFactory getConstraintValidatorFactory() {
        return factoryContext.getConstraintValidatorFactory();
    }

    private ConstraintDefaults getDefaultConstraints() {
        return factoryContext.getFactory().getDefaultConstraints();

    }

    /**
     * add the validation features to the metabean that come from jsr303
     * annotations in the beanClass
     */
    public void buildMetaBean(MetaBean metabean) {
        try {
            final Class<?> beanClass = metabean.getBeanClass();
            processGroupSequence(beanClass, metabean);
            for (Class interfaceClass : beanClass.getInterfaces()) {
                processClass(interfaceClass, metabean);
            }

            // process class, superclasses and interfaces
            List<Class> classSequence = new ArrayList<Class>();
            Class theClass = beanClass;
            while (theClass != null && theClass != Object.class) {
                classSequence.add(theClass);
                theClass = theClass.getSuperclass();
            }
            // start with superclasses and go down the hierarchy so that
            // the child classes are processed last to have the chance to overwrite some declarations
            // of their superclasses and that they see what they inherit at the time of processing
            for (int i = classSequence.size() - 1; i >= 0; i--) {
                Class eachClass = classSequence.get(i);
                processClass(eachClass, metabean);
            }
        } catch (IllegalAccessException e) {
            throw new IllegalArgumentException(e);
        } catch (InvocationTargetException e) {
            throw new IllegalArgumentException(e.getTargetException());
        }
    }

    /**
     * process class annotations, field and method annotations
     *
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    private void processClass(Class<?> beanClass, MetaBean metabean)
          throws IllegalAccessException, InvocationTargetException {
        if (!factoryContext.getFactory().getAnnotationIgnores()
              .isIgnoreAnnotations(beanClass)) { // ignore on class level

            processAnnotations(null, beanClass, beanClass, null,
                  new AppendValidationToMeta(metabean));

            Field[] fields = beanClass.getDeclaredFields();
            for (Field field : fields) {
                MetaProperty metaProperty = metabean.getProperty(field.getName());
                // create a property for those fields for which there is not yet a MetaProperty
                if (!factoryContext.getFactory().getAnnotationIgnores()
                      .isIgnoreAnnotations(field)) {
                    if (metaProperty == null) {
                        metaProperty = createMetaProperty(field.getName(), field.getType());
                        /*if (*/
                        processAnnotations(metaProperty, beanClass, field,
                              new FieldAccess(field),
                              new AppendValidationToMeta(metaProperty));//) {
                        metabean.putProperty(metaProperty.getName(), metaProperty);
                        //}
                    } else {
                        processAnnotations(metaProperty, beanClass, field,
                              new FieldAccess(field),
                              new AppendValidationToMeta(metaProperty));
                    }
                }
            }
            Method[] methods = beanClass.getDeclaredMethods();
            for (Method method : methods) {

                String propName = null;
                if (method.getParameterTypes().length == 0) {
                    propName = MethodAccess.getPropertyName(method);
                }
                if (propName != null) {
                    if (!factoryContext.getFactory().getAnnotationIgnores()
                          .isIgnoreAnnotations(method)) {
                        MetaProperty metaProperty = metabean.getProperty(propName);
                        // create a property for those methods for which there is not yet a MetaProperty
                        if (metaProperty == null) {
                            metaProperty =
                                  createMetaProperty(propName, method.getReturnType());
                            /*if (*/
                            processAnnotations(metaProperty, beanClass, method,
                                  new MethodAccess(propName, method),
                                  new AppendValidationToMeta(metaProperty));//) {
                            metabean.putProperty(propName, metaProperty);
                            //}
                        } else {
                            processAnnotations(metaProperty, beanClass, method,
                                  new MethodAccess(propName, method),
                                  new AppendValidationToMeta(metaProperty));
                        }
                    }
                }
            }
        }
        addXmlConstraints(beanClass, metabean);
    }

    /** add cascade validation and constraints from xml mappings */
    private void addXmlConstraints(Class<?> beanClass, MetaBean metabean)
          throws IllegalAccessException, InvocationTargetException {
        for (MetaConstraint<?, ? extends Annotation> meta : factoryContext.getFactory()
              .getMetaConstraints(beanClass)) {
            MetaProperty metaProperty;
            if (meta.getAccessStrategy() == null) { // class level
                metaProperty = null;
            } else { // property level
                metaProperty =
                      metabean.getProperty(meta.getAccessStrategy().getPropertyName());
                if (metaProperty == null) {
                    metaProperty = createMetaProperty(
                          meta.getAccessStrategy().getPropertyName(),
                          meta.getAccessStrategy().getJavaType());
                    metabean.putProperty(metaProperty.getName(), metaProperty);
                }
            }
            Class<? extends ConstraintValidator<?, ?>>[] constraintClasses =
                  findConstraintValidatorClasses(meta.getAnnotation(), null);
            applyConstraint(meta.getAnnotation(), constraintClasses, metaProperty, beanClass,
                  meta.getAccessStrategy(), new AppendValidationToMeta(
                  metaProperty == null ? metabean : metaProperty));
        }
        for (AccessStrategy access : factoryContext.getFactory().getValidAccesses(beanClass)) {
            MetaProperty metaProperty = metabean.getProperty(access.getPropertyName());
            if (metaProperty == null) {
                metaProperty =
                      createMetaProperty(access.getPropertyName(), access.getJavaType());
                metabean.putProperty(metaProperty.getName(), metaProperty);
            }
            processValid(metaProperty, access);
        }
    }

    private MetaProperty createMetaProperty(String propName, Type type) {
        MetaProperty metaProperty;
        metaProperty = new MetaProperty();
        metaProperty.setName(propName);
        metaProperty.setType(type);
        return metaProperty;
    }

    private boolean processAnnotations(MetaProperty prop, Class owner,
                                       AnnotatedElement element, AccessStrategy access,
                                       AppendValidation appender)
          throws IllegalAccessException, InvocationTargetException {

        boolean changed = false;
        for (Annotation annotation : element.getDeclaredAnnotations()) {
            changed |= processAnnotation(annotation, prop, owner, access, appender);
        }
        return changed;
    }

    private boolean processAnnotation(Annotation annotation, MetaProperty prop, Class owner,
                                      AccessStrategy access, AppendValidation appender)
          throws IllegalAccessException, InvocationTargetException {
        if (annotation instanceof Valid) {
            return processValid(prop, access);
        } else {
            /**
             * An annotation is considered a constraint definition if its retention
             * policy contains RUNTIME and if the annotation itself is annotated with
             * javax.validation.Constraint.
             */
            Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
            if (vcAnno != null) {
                Class<? extends ConstraintValidator<?, ?>>[] validatorClasses;
                validatorClasses = findConstraintValidatorClasses(annotation, vcAnno);
                return applyConstraint(annotation, validatorClasses, prop, owner, access,
                      appender);
            } else {
                /**
                 * Multi-valued constraints:
                 * To support this requirement, the bean validation provider treats
                 * regular annotations (annotations not annotated by @Constraint)
                 * whose value element has a return type of an array of
                 * constraint annotations in a special way.
                 */
                Object result = SecureActions.getAnnotationValue(annotation, ANNOTATION_VALUE);
                if (result != null && result instanceof Annotation[]) {
                    boolean changed = false;
                    for (Annotation each : (Annotation[]) result) {
                        changed |= processAnnotation(each, prop, owner, access, appender);
                    }
                    return changed;
                }
            }
        }
        return false;
    }

    protected Class<? extends ConstraintValidator<?, ?>>[] findConstraintValidatorClasses(
          Annotation annotation, Constraint vcAnno) {
        if (vcAnno == null) {
            vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
        }
        Class<? extends ConstraintValidator<?, ?>>[] validatorClasses;
        validatorClasses = factoryContext.getFactory()
              .getConstraintsCache()
              .getConstraintValidators(annotation.annotationType());
        if (validatorClasses == null) {
            validatorClasses = vcAnno.validatedBy();
            if (validatorClasses.length == 0) {
                validatorClasses = getDefaultConstraints()
                      .getValidatorClasses(annotation.annotationType());
            }
        }
        return validatorClasses;
    }

    private boolean processValid(MetaProperty prop, AccessStrategy access) {
        if (prop != null/* && prop.getMetaBean() == null*/) {
            AccessStrategy[] strategies = prop.getFeature(Features.Property.REF_CASCADE);
            if (strategies == null) {
                strategies = new AccessStrategy[]{access};
                prop.putFeature(Features.Property.REF_CASCADE, strategies);
            } else {
                if (!ArrayUtils.contains(strategies, access)) {
                    AccessStrategy[] strategies_new =
                          new AccessStrategy[strategies.length  1];
                    System.arraycopy(strategies, 0, strategies_new, 0, strategies.length);
                    strategies_new[strategies.length] = access;
                    prop.putFeature(Features.Property.REF_CASCADE, strategies_new);
                }
            }
            return true;
        }
        return false;
    }

    private void processGroupSequence(Class<?> beanClass, MetaBean metabean) {
        GroupSequence annotation = beanClass.getAnnotation(GroupSequence.class);
        List<Group> groupSeq = metabean.getFeature(Jsr303Features.Bean.GROUP_SEQUENCE);
        if (groupSeq == null) {
            groupSeq = new ArrayList(annotation == null ? 1 : annotation.value().length);
            metabean.putFeature(Jsr303Features.Bean.GROUP_SEQUENCE, groupSeq);
        }
        Class<?>[] groupClasses = factoryContext.getFactory().getDefaultSequence(beanClass);
        if (groupClasses == null || groupClasses.length == 0) {
            if (annotation == null) {
                groupSeq.add(Group.DEFAULT);
                return;
            } else {
                groupClasses = annotation.value();
            }
        }
        boolean containsDefault = false;
        for (Class<?> groupClass : groupClasses) {
            if (groupClass.getName().equals(beanClass.getName())) {
                groupSeq.add(Group.DEFAULT);
                containsDefault = true;
            } else if (groupClass.getName().equals(Default.class.getName())) {
                throw new GroupDefinitionException(
                      "'Default.class' must not appear in @GroupSequence! Use '" 
                            beanClass.getSimpleName()  ".class' instead.");
            } else {
                groupSeq.add(new Group(groupClass));
            }
        }
        if (!containsDefault) {
            throw new GroupDefinitionException(
                  "Redefined default group sequence must contain "  beanClass.getName());
        }
        if (log.isDebugEnabled()) {
            log.debug("Default group sequence for bean "  beanClass.getName()  " is: " 
                  groupSeq);
        }
    }

    /**
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    protected boolean applyConstraint(Annotation annotation,
                                      Class<? extends ConstraintValidator<?, ?>>[] constraintClasses,
                                      MetaProperty prop, Class owner, AccessStrategy access,
                                      AppendValidation appender)
          throws IllegalAccessException, InvocationTargetException {

        final ConstraintValidator validator;
        if (constraintClasses != null) {
            Type type = determineTargetedType(owner, access);
            /**
             * spec says in chapter 3.5.3.:
             * The ConstraintValidator chosen to validate a
             * declared type T is the one where the type supported by the
             * ConstraintValidator is a supertype of T and where
             * there is no other ConstraintValidator whose supported type is a
             * supertype of T and not a supertype of the chosen
             * ConstraintValidator supported type.
             */
            Map<Type, Class<? extends ConstraintValidator<?, ?>>> validatorTypes =
                  TypeUtils.getValidatorsTypes(constraintClasses);
            final List<Type> assignableTypes = new ArrayList(constraintClasses.length);
            fillAssignableTypes(type, validatorTypes.keySet(), assignableTypes);
            reduceAssignableTypes(assignableTypes);
            checkOneType(assignableTypes, type, owner, annotation, access);
            validator = getConstraintValidatorFactory()
                  .getInstance(validatorTypes.get(assignableTypes.get(0)));
            validator.initialize(annotation);
        } else {
            validator = null;
        }
        final AnnotationConstraintBuilder builder = new AnnotationConstraintBuilder(
              constraintClasses, validator, annotation, owner, access);
        // process composed constraints:
        // here are not other superclasses possible, because annotations do not inherit!
        if (processAnnotations(prop, owner, annotation.annotationType(), access,
              new AppendValidationToBuilder(builder)) || validator != null) {  // recursion!
            appender.append(builder.getConstraintValidation());
            return true;
        } else {
            return false;
        }
    }

    private void checkOneType(List<Type> types, Type targetType, Class owner, Annotation anno,
                              AccessStrategy access) {

        if (types.isEmpty()) {
            StringBuilder buf = new StringBuilder()
                  .append("No validator could be found for type ")
                  .append(stringForType(targetType))
                  .append(". See: @")
                  .append(anno.annotationType().getSimpleName())
                  .append(" at ").append(stringForLocation(owner, access));
            throw new UnexpectedTypeException(buf.toString());
        } else if (types.size() > 1) {
            StringBuilder buf = new StringBuilder();
            buf.append("Ambiguous validators for type ");
            buf.append(stringForType(targetType));
            buf.append(". See: @")
                  .append(anno.annotationType().getSimpleName())
                  .append(" at ").append(stringForLocation(owner, access));
            buf.append(". Validators are: ");
            boolean comma = false;
            for (Type each : types) {
                if (comma) buf.append(", ");
                comma = true;
                buf.append(each);
            }
            throw new UnexpectedTypeException(buf.toString());
        }
    }

    /** implements spec chapter 3.5.3. ConstraintValidator resolution algorithm. */
    private Type determineTargetedType(Class owner, AccessStrategy access) {
        // if the constraint declaration is hosted on a class or an interface,
        // the targeted type is the class or the interface.
        if (access == null) return owner;
        Type type = access.getJavaType();
        if (type == null) return Object.class;
        if (type instanceof Class) type = ClassUtils.primitiveToWrapper((Class) type);
        return type;
    }

    private String stringForType(Type clazz) {
        if (clazz instanceof Class) {
            if (((Class) clazz).isArray()) {
                return ((Class) clazz).getComponentType().getName()  "[]";
            } else {
                return ((Class) clazz).getName();
            }
        } else {
            return clazz.toString();
        }
    }

    private String stringForLocation(Class owner, AccessStrategy access) {
        if (access != null) {
            return access.toString();
        } else {
            return owner.getName();
        }
    }

    private void fillAssignableTypes(Type type, Set<Type> validatorsTypes,
                                     List<Type> suitableTypes) {
        for (Type validatorType : validatorsTypes) {
            if (TypeUtils.isAssignable(validatorType, type) &&
                  !suitableTypes.contains(validatorType)) {
                suitableTypes.add(validatorType);
            }
        }
    }

    /**
     * Tries to reduce all assignable classes down to a single class.
     *
     * @param assignableTypes The set of all classes which are assignable to the class of the value to be validated and
     *                        which are handled by at least one of the validators for the specified constraint.
     */
    private void reduceAssignableTypes(List<Type> assignableTypes) {
        if (assignableTypes.size() <= 1) {
            return; // no need to reduce
        }
        boolean removed;
        do {
            removed = false;
            final Type type = assignableTypes.get(0);
            for (int i = 1; i < assignableTypes.size(); i) {
                Type nextType = assignableTypes.get(i);
                if (TypeUtils.isAssignable(type, nextType)) {
                    assignableTypes.remove(0);
                    i--;
                    removed = true;
                } else if (TypeUtils.isAssignable(nextType, type)) {
                    assignableTypes.remove(i--);
                    removed = true;
                }
            }
        } while (removed && assignableTypes.size() > 1);
    }
}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/NestedMetaProperty.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303;


import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.util.PropertyAccess;
import org.apache.commons.lang.StringUtils;

import javax.validation.ValidationException;
import java.lang.reflect.*;
import java.util.*;

/**
 * Description: handle nested property paths <br/>
 * User: roman.stumm <br/>
 * Date: 31.10.2008 <br/>
 * Time: 14:04:23 <br/>
 * Copyright: Agimatec GmbH
 */
final class NestedMetaProperty {
    private MetaBean metaBean;
    private MetaProperty metaProperty;
    private final String propertyPath;
    private boolean nested;
    private Object value;

    public NestedMetaProperty(String path, Object value) {
        this.propertyPath = path;
        this.value = value;
    }

     void parse() {
        try {
            StringTokenizer tokens = new StringTokenizer(propertyPath, ".[]", true);
            while (tokens.hasMoreTokens()) {
                String token = tokens.nextToken();
                if ("[".equals(token)) {
                    String sindex = tokens.nextToken();
                    int idx = Integer.parseInt(sindex);
                    token = tokens.nextToken();
                    if (!"]".equals(token)) {
                        throw new ValidationException(
                                "']' missing, invalid property format: "  propertyPath);
                    }
                    useIndexedValue(idx);
                    resolveMetaBean();
                } else if (!".".equals(token)) { // it is a property name
                    MetaProperty mp = getMetaBean().getProperty(token);
                    if (mp == null) {
                        throw new ValidationException(
                                "unknown property '"  token  "' in "  getMetaBean().getId());
                    }
                    if (getValue() != null) {
                        setValue(
                              PropertyAccess.getProperty(getValue(), token));
                    }
                    setMetaProperty(mp);
                    resolveMetaBean();
                }
            }
        } catch (ValidationException ex) {
            throw ex; // route exception
        } catch (Exception ex) { // wrap exception
            throw new ValidationException(
                    "invalid property format: "  propertyPath, ex);

        }
    }

    public MetaProperty getMetaProperty() {
        return metaProperty;
    }

    public String getPropertyPath() {
        return propertyPath;
    }

    public boolean isNested() {
        return nested;
    }

    public void setMetaProperty(MetaProperty aMetaProperty) {
        if (this.metaProperty != null) {
            this.nested = true;
        }
        this.metaProperty = aMetaProperty;
    }

    public MetaBean getMetaBean() {
        return metaBean;
    }

    public void setMetaBean(MetaBean metaBean) {
        this.metaBean = metaBean;
    }

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    private void useIndexedValue(int idx) {
        setValue(getAtIndex(getValue(), idx));
    }

    private Object getAtIndex(Object value, int idx) {
        if (value == null) return null;
        if (value instanceof Iterable) {
            Iterator iter = ((Iterable) value).iterator();
            for (int i = 0; i <= idx; i) {
                value = iter.next();
            }
            return value;
        } else if (value.getClass().isArray()) {
            return getAtIndex(Arrays.asList(value), idx);
        } else {
            throw new ValidationException("cannot access indexed value from "  value);
        }
    }

    static Type typeOf(Member member) {
        if (member instanceof Field) {
            return ((Field) member).getGenericType();
        }
        if (member instanceof Method) {
            return ((Method) member).getGenericReturnType();
        }
        throw new IllegalArgumentException("Member "  member  " is neither a field nor a method");
    }

    static Type getIndexedType(Type type) {
        Type indexedType = type;
        if (isCollection(type) && type instanceof ParameterizedType) {
            ParameterizedType paramType = (ParameterizedType) type;
            Class collectionClass = getCollectionClass(type);
            if (Collection.class.isAssignableFrom(collectionClass)) {
                indexedType = paramType.getActualTypeArguments()[0];
            } else if (Map.class.isAssignableFrom(collectionClass)) {
                indexedType = paramType.getActualTypeArguments()[1];
            }
        } else if (isArray(type) && type instanceof GenericArrayType) {
            GenericArrayType arrayTye = (GenericArrayType) type;
            indexedType = arrayTye.getGenericComponentType();
        }
        return indexedType;
    }

    static Class<? extends Collection> getCollectionClass(Type type) {
        if (type instanceof Class && isCollectionClass((Class) type)) {
            return (Class<? extends Collection>) type;
        }
        if (type instanceof ParameterizedType) {
            return getCollectionClass(((ParameterizedType) type).getRawType());
        }
        if (type instanceof WildcardType) {
            Type[] upperBounds = ((WildcardType) type).getUpperBounds();
            if (upperBounds.length == 0) {
                return null;
            }
            return getCollectionClass(upperBounds[0]);
        }
        return null;
    }

    static boolean isArray(Type type) {
        if (type instanceof Class) {
            return ((Class) type).isArray();
        }
        return type instanceof GenericArrayType;
    }

    /**
     * @param type the type to check.
     * @return Returns <code>true</code> if <code>type</code> is a collection type or <code>false</code> otherwise.
     */
    static boolean isCollection(Type type) {
        return getCollectionClass(type) != null;
    }

    static boolean isCollectionClass(Class<?> clazz) {
        return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);
    }

    // enhancement: HACK ALERT! improve support for nested property types, this is not correct in all cases
    private void resolveMetaBean() {
        if (metaProperty.getMetaBean() == null) {
            return;
        }

        if (getValue() != null) {
            metaBean = metaProperty.getMetaBean().resolveMetaBean(getValue());
        } else {
            Member member = null;
            try {
                member = metaBean.getBeanClass().getDeclaredField(metaProperty.getName());
            } catch (NoSuchFieldException e) {
                String getter = "get"  StringUtils.capitalize(metaProperty.getName());
                try {
                    member = metaBean.getBeanClass().getDeclaredMethod(getter);
                } catch (NoSuchMethodException e1) {
                    try {
                        member = metaBean.getBeanClass().getField(metaProperty.getName());
                    } catch (NoSuchFieldException e2) {
                        try {
                            member = metaBean.getBeanClass().getMethod(getter);
                        } catch (NoSuchMethodException e3) {                            
                        }
                    }
                }
            }
            if (member != null) {
                Type type = getIndexedType(typeOf(member));
                if (type != null) {
                    metaBean = metaProperty.getMetaBean().resolveMetaBean(type);
                }
            }
        }
    }
}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/PropertyDescriptorImpl.java
package org.apache.bval.jsr303;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.Validation;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/AppendValidationToList.java
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.AppendValidation;
import org.apache.bval.jsr303.ConstraintValidation;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/ConstructorDescriptor.java
package org.apache.bval.jsr303.extensions;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/ConstructorDescriptorImpl.java
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.ElementDescriptorImpl;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.Validation;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/MethodBeanDescriptor.java
package org.apache.bval.jsr303.extensions;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/MethodBeanDescriptorImpl.java
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.AgimatecFactoryContext;
import org.apache.bval.jsr303.BeanDescriptorImpl;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.Validation;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/MethodDescriptor.java
package org.apache.bval.jsr303.extensions;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/MethodDescriptorImpl.java
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.ElementDescriptorImpl;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.Validation;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/MethodValidator.java
package org.apache.bval.jsr303.extensions;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/MethodValidatorImpl.java
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.*;

import org.apache.bval.jsr303.AgimatecFactoryContext;
import org.apache.bval.jsr303.BeanDescriptorImpl;
import org.apache.bval.jsr303.ClassValidator;
import org.apache.bval.jsr303.ConstraintValidation;
import org.apache.bval.jsr303.ConstraintValidationListener;
import org.apache.bval.jsr303.GroupValidationContext;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.Groups;
import org.apache.bval.model.MetaBean;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/MethodValidatorMetaBeanFactory.java
package org.apache.bval.jsr303.extensions;

import org.apache.bval.jsr303.AgimatecFactoryContext;
import org.apache.bval.jsr303.AppendValidation;
import org.apache.bval.jsr303.Jsr303MetaBeanFactory;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.model.Validation;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/ParameterDescriptor.java
package org.apache.bval.jsr303.extensions;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/ParameterDescriptorImpl.java
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.ElementDescriptorImpl;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.Validation;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/extensions/ProcedureDescriptor.java
package org.apache.bval.jsr303.extensions;
import org.apache.bval.model.MetaBean;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/groups/Group.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/groups/Groups.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/groups/GroupsComputer.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/resolver/CachingRelevant.java
package org.apache.bval.jsr303.resolver;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/resolver/CachingTraversableResolver.java
package org.apache.bval.jsr303.resolver;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/resolver/DefaultTraversableResolver.java
package org.apache.bval.jsr303.resolver;
import org.apache.bval.jsr303.util.SecureActions;
          "org.apache.bval.jsr303.resolver.JPATraversableResolver";
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/resolver/JPATraversableResolver.java
package org.apache.bval.jsr303.resolver;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/resolver/SimpleTraversableResolver.java
package org.apache.bval.jsr303.resolver;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/util/ConverterUtils.java
package org.apache.bval.jsr303.util;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/util/NodeBuilderCustomizableContextImpl.java
package org.apache.bval.jsr303.util;
import org.apache.bval.jsr303.ConstraintValidatorContextImpl;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/util/NodeBuilderDefinedContextImpl.java
package org.apache.bval.jsr303.util;
import org.apache.bval.jsr303.ConstraintValidatorContextImpl;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/util/NodeContextBuilderImpl.java
package org.apache.bval.jsr303.util;
import org.apache.bval.jsr303.ConstraintValidatorContextImpl;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/util/NodeImpl.java
package org.apache.bval.jsr303.util;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/util/PathImpl.java
package org.apache.bval.jsr303.util;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/util/SecureActions.java
package org.apache.bval.jsr303.util;
import org.apache.bval.util.PrivilegedActions;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/util/TypeUtils.java
package org.apache.bval.jsr303.util;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/xml/AnnotationIgnores.java
package org.apache.bval.jsr303.xml;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/xml/AnnotationProxy.java
package org.apache.bval.jsr303.xml;
import org.apache.bval.jsr303.util.SecureActions;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/xml/AnnotationProxyBuilder.java
package org.apache.bval.jsr303.xml;

import org.apache.bval.jsr303.util.SecureActions;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/xml/MetaConstraint.java
package org.apache.bval.jsr303.xml;

import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/xml/ValidationMappingParser.java
package org.apache.bval.jsr303.xml;

import org.apache.bval.jsr303.AgimatecValidatorFactory;
import org.apache.bval.jsr303.util.ConverterUtils;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/xml/ValidationParser.java
package org.apache.bval.jsr303.xml;

import org.apache.bval.jsr303.ConfigurationImpl;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.PrivilegedActions;
 b/bval-jsr303/src/test/java/org/apache/bval/constraints/AgimatecEmail.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/test/java/org/apache/bval/constraints/FrenchZipCode.java
package org.apache.bval.constraints;

import org.apache.bval.constraints.NotEmpty;

 b/bval-jsr303/src/test/java/org/apache/bval/constraints/FrenchZipcodeValidator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.constraints;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

/**
 * Description: not implemented (test only)<br/>
 * User: roman.stumm <br/>
 * Date: 31.10.2008 <br/>
 * Time: 16:38:25 <br/>
 * Copyright: Agimatec GmbH
 */
public class FrenchZipcodeValidator implements ConstraintValidator<FrenchZipCode, Object> {
    public void initialize(FrenchZipCode constraintAnnotation) {
        // do nothing
    }

    public boolean isValid(Object object, ConstraintValidatorContext validationContext) {
        return null != object;
    }
}
 b/bval-jsr303/src/test/java/org/apache/bval/constraints/HasStringValidator.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/test/java/org/apache/bval/constraints/HasValue.java
package org.apache.bval.constraints;
 b/bval-jsr303/src/test/java/org/apache/bval/constraints/Password.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.constraints;

import javax.validation.Constraint;
import javax.validation.Payload;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import org.apache.bval.constraints.NotEmpty;

import java.lang.annotation.Retention;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 01.04.2008 <br/>
 * Time: 12:02:06 <br/>
 */
@NotEmpty
@NotNull
@Size(min = 4, max = 5)
@Retention(RUNTIME)
@Constraint(validatedBy = {})
// test that Password is validated although only combined constraints exists, no own implementation 
public @interface Password {
    String[] groups() default {};

    String message() default "Wrong password";

    int robustness() default 8;

    Class<? extends Payload>[] payload() default { };
}
 b/bval-jsr303/src/test/java/org/apache/bval/constraints/ZipCodeCityCoherence.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.constraints;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Documented;
import static java.lang.annotation.ElementType.TYPE;
import java.lang.annotation.Retention;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Target;

/**
 * not implemented! simple dummy implemenation for tests only!
 */
@Documented
@Constraint(validatedBy = ZipCodeCityCoherenceValidator.class)
@Target({TYPE})
@Retention(RUNTIME)
public @interface ZipCodeCityCoherence {
    String message() default "{validator.zipCodeCityCoherence}";    
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default { };
}
 b/bval-jsr303/src/test/java/org/apache/bval/constraints/ZipCodeCityCoherenceValidator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.constraints;


import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

import org.apache.bval.jsr303.example.ZipCodeCityCarrier;

/**
 * Description: Class not implemented! simple dummy implemenation for tests only! <br/>
 * User: roman.stumm <br/>
 * Date: 01.04.2008 <br/>
 * Time: 11:45:22 <br/>
 */
public class ZipCodeCityCoherenceValidator
      implements ConstraintValidator<ZipCodeCityCoherence, ZipCodeCityCarrier> {
    public void initialize(ZipCodeCityCoherence constraintAnnotation) {
    }

    public boolean isValid(ZipCodeCityCarrier adr, ConstraintValidatorContext context) {
        boolean r = true;
        if ("error".equals(adr.getZipCode())) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate("zipcode not OK").addConstraintViolation();
            r = false;
        }
        if ("error".equals(adr.getCity())) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate("city not OK").addNode("city").addConstraintViolation();
            r = false;
        }
        return r;
    }
}
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/Address.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;


import javax.validation.GroupSequence;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import javax.validation.groups.Default;

import org.apache.bval.constraints.ZipCodeCityCoherence;

@ZipCodeCityCoherence
public class Address implements ZipCodeCityCarrier {
    @NotNull
    @Size(max = 30)
    private String addressline1;
    @Size(max = 30)
    private String addressline2;
    @Size(max = 11)
    private String zipCode;
    @NotNull
    @Valid
    private Country country;
    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max = 30)
    @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }

    /**
     * Check conherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {
    }

    /**
     * Check both basic constraints and high level ones.
     * High level constraints are not checked if basic constraints fail.
     */
    @GroupSequence(value = {Default.class, HighLevelCoherence.class})
    public interface Complete {
    }
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/AgimatecAddress.java
package org.apache.bval.jsr303.example;
import org.apache.bval.constraints.AgimatecEmail;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/Author.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;


import javax.validation.GroupSequence;
import javax.validation.Valid;
import javax.validation.constraints.Size;

import org.apache.bval.constraints.NotEmpty;

import java.util.List;

@GroupSequence({First.class, Author.class, Last.class})
public class Author {
    @NotEmpty(groups = Last.class)
    private String firstName;
    @NotEmpty(groups = First.class)
    private String lastName;
    @Size(max = 40, groups = First.class)
    private String company;

    @Valid
    private List<Address> addresses;

    public List<Address> getAddresses() {
        return addresses;
    }

    public void setAddresses(List<Address> addresses) {
        this.addresses = addresses;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/Book.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;


import javax.validation.GroupSequence;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import org.apache.bval.constraints.NotEmpty;

@GroupSequence({First.class, Second.class, Book.class, Last.class})
public class Book {
    @NotNull(groups = First.class)
    @NotEmpty(groups = First.class)
    private String title;

    @Size(max = 30, groups = Second.class)
    private String subtitle;

    @Valid
    @NotNull(groups = First.class)
    private Author author;

    @NotNull
    private int uselessField;

    private int unconstraintField;

    public int getUnconstraintField() {
        return unconstraintField;
    }

    public void setUnconstraintField(int unconstraintField) {
        this.unconstraintField = unconstraintField;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getSubtitle() {
        return subtitle;
    }

    public void setSubtitle(String subtitle) {
        this.subtitle = subtitle;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }

    @GroupSequence(value = {First.class, Second.class, Last.class})
    public interface All {
    }
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/BusinessAddress.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;

import javax.validation.constraints.NotNull;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 28.04.2008 <br/>
 * Time: 10:47:15 <br/>
 * Copyright: Agimatec GmbH
 */
public class BusinessAddress extends Address {
    private String company;

    @NotNull
    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/Country.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;


import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class Country {
    @NotNull
    private String name;
    @Size(max = 2)
    private String ISO2Code;
    @Size(max = 3)
    private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/Customer.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;


import javax.validation.constraints.NotNull;

import org.apache.bval.constraints.Email;
import org.apache.bval.constraints.Password;

public class Customer implements Person {
    private String firstName;
    private String middleName;
    private String lastName;
    @NotNull
    private String customerId;
    @Password(robustness = 5)
    private String password;

    @Email
    private String emailAddress;

    public String getEmailAddress() {
        return emailAddress;
    }

    public void setEmailAddress(String emailAddress) {
        this.emailAddress = emailAddress;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getMiddleName() {
        return middleName;
    }

    public void setMiddleName(String middleName) {
        this.middleName = middleName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/Employee.java
package org.apache.bval.jsr303.example;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/Engine.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;

import javax.validation.constraints.Pattern;

public class Engine {
    @Pattern.List({
        @Pattern(regexp = "^[A-Z0-9-]$", flags = Pattern.Flag.CASE_INSENSITIVE,
                message = "must contain alphabetical characters only"),
        @Pattern(
                regexp = "^....-....-....$", message = "must match ....-....-....")})
    public String serialNumber;


 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/First.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 08.12.2008 <br/>
 * Time: 10:24:50 <br/>
 * Copyright: Agimatec GmbH
 */
public interface First {
}
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/FrenchAddress.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;

import org.apache.bval.constraints.FrenchZipCode;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 31.10.2008 <br/>
 * Time: 16:47:35 <br/>
 * Copyright: Agimatec GmbH
 */
public class FrenchAddress {
    @FrenchZipCode(size = 7)
    String zipCode;

    public FrenchAddress() {
    }

    public FrenchAddress(String zipCode) {
        this.zipCode = zipCode;
    }
    
    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

}
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/Last.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 08.12.2008 <br/>
 * Time: 10:24:56 <br/>
 * Copyright: Agimatec GmbH
 */
public interface Last {
}
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/Library.java
package org.apache.bval.jsr303.example;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/Person.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;

import org.apache.bval.constraints.NotEmpty;

public interface Person {
    @NotEmpty
    String getFirstName();

    String getMiddleName();

    @NotEmpty
    String getLastName();
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/PreferredGuest.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;

import javax.validation.constraints.Digits;

public class PreferredGuest extends Customer {
    @Digits(integer = 10, fraction = 0)
    private String guestCreditCardNumber;

    public String getGuestCreditCardNumber() {
        return guestCreditCardNumber;
    }

    public void setGuestCreditCardNumber(String guestCreditCardNumber) {
        this.guestCreditCardNumber = guestCreditCardNumber;
    }
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/RecursiveFoo.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;


import javax.validation.Valid;

import org.apache.bval.constraints.NotEmpty;

import java.util.ArrayList;
import java.util.Collection;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 05.09.2008 <br/>
 * Time: 11:02:24 <br/>
 * Copyright: Agimatec GmbH
 */
public class RecursiveFoo {
    @NotEmpty
    @Valid
    Collection<RecursiveFoo> foos = new ArrayList();

    public Collection<RecursiveFoo> getFoos() {
        return foos;
    }

    public void setFoos(Collection<RecursiveFoo> foos) {
        this.foos = foos;
    }
}
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/Second.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.bval.jsr303.example;

/**
 * Description: <br/>
 * User: roman.stumm <br/>
 * Date: 08.12.2008 <br/>
 * Time: 10:25:24 <br/>
 * Copyright: Agimatec GmbH
 */
public interface Second {
}
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/XmlEntitySampleBean.java
package org.apache.bval.jsr303.example;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/ZipCodeCityCarrier.java
package org.apache.bval.jsr303.example;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/extensions/ExampleMethodService.java
package org.apache.bval.jsr303.extensions;
import org.apache.bval.constraints.NotEmpty;

 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/Billable.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/BillableCreditCard.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/BillableUser.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/BuyInOneClick.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/CyclicGroupSequence.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/CyclicGroupSequence1.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/CyclicGroupSequence2.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/GClass1.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/GClass2.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/GClass3.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/GInterface1.java
package org.apache.bval.jsr303.groups;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/implicit/Auditable.java
package org.apache.bval.jsr303.groups.implicit;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/implicit/Order.java
package org.apache.bval.jsr303.groups.implicit;
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/inheritance/BillableUser.java
package org.apache.bval.jsr303.groups.inheritance;
import org.apache.bval.jsr303.groups.Billable;
import org.apache.bval.jsr303.groups.BillableCreditCard;

 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/inheritance/BuyInOneClick.java
package org.apache.bval.jsr303.groups.inheritance;
import org.apache.bval.jsr303.groups.Billable;

 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/redefining/Address.java
package org.apache.bval.jsr303.groups.redefining;
import org.apache.bval.constraints.ZipCodeCityCoherence;
import org.apache.bval.jsr303.example.ZipCodeCityCarrier;

 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/groups/redefining/InvalidRedefinedDefaultGroupAddress.java
package org.apache.bval.jsr303.groups.redefining;
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ApacheFactoryContext.java
public class ApacheFactoryContext implements ValidatorContext {
    private final ApacheValidatorFactory factory;
    public ApacheFactoryContext(ApacheValidatorFactory factory) {
    protected ApacheFactoryContext(ApacheValidatorFactory factory,
  public ApacheValidatorFactory getFactory() {
              ApacheValidatorConfiguration.Properties.TREAT_MAPS_LIKE_BEANS))) {
              ApacheValidatorConfiguration.Properties.ENABLE_INTROSPECTOR))) {
              ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML))) {
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ApacheValidationProvider.java
public class ApacheValidationProvider
      implements ValidationProvider<ApacheValidatorConfiguration> {
        return ApacheValidatorConfiguration.class == builderClass;
    public ApacheValidatorFactory buildValidatorFactory(ConfigurationState configuration) {
            ApacheValidatorFactory factory = new ApacheValidatorFactory();
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ApacheValidatorConfiguration.java
public interface ApacheValidatorConfiguration
      extends Configuration<ApacheValidatorConfiguration> {
        String VALIDATION_XML_PATH = "apache.bval.validation-xml-path";
        String ENABLE_INTROSPECTOR = "apache.bval.enable-introspector";
        String ENABLE_METABEANS_XML = "apache.bval.enable-metabeans-xml";
         String TREAT_MAPS_LIKE_BEANS = "apache.bval.treat-maps-like-beans";
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ApacheValidatorFactory.java
public class ApacheValidatorFactory implements ValidatorFactory, Cloneable {
    private static ApacheValidatorFactory DEFAULT_FACTORY;
  /** convenience to retrieve a default global ApacheValidatorFactory */
    public static ApacheValidatorFactory getDefault() {
            ProviderSpecificBootstrap<ApacheValidatorConfiguration> provider =
                  Validation.byProvider(ApacheValidationProvider.class);
            ApacheValidatorConfiguration configuration = provider.configure();
            DEFAULT_FACTORY = (ApacheValidatorFactory) configuration
    public ApacheValidatorFactory() {
    public ApacheFactoryContext usingContext() {
        return new ApacheFactoryContext(this);
    public synchronized ApacheValidatorFactory clone() {
            return (ApacheValidatorFactory) super.clone();
    protected final ApacheFactoryContext factoryContext;
    protected BeanDescriptorImpl(ApacheFactoryContext factoryContext, MetaBean metaBean,
    protected final ApacheFactoryContext factoryContext;
    public ClassValidator(ApacheFactoryContext factoryContext) {
    public ClassValidator(ApacheValidatorFactory factory) {
            return SecureActions.newInstance(type, new Class[]{ApacheFactoryContext.class},
                      new Class[]{ApacheFactoryContext.class}, new Object[]{factoryContext});
public class ConfigurationImpl implements ApacheValidatorConfiguration, ConfigurationState {
    public ApacheValidatorConfiguration traversableResolver(TraversableResolver resolver) {
    public ApacheValidatorConfiguration ignoreXmlConfiguration() {
    public ApacheValidatorConfiguration addMapping(InputStream stream) {
    public ApacheValidatorConfiguration addProperty(String name, String value) {
          "org/apache/bval/jsr303/DefaultConstraints.properties";
    protected final ApacheFactoryContext factoryContext;
    public Jsr303MetaBeanFactory(ApacheFactoryContext factoryContext) {
import org.apache.bval.jsr303.ApacheFactoryContext;
    protected MethodBeanDescriptorImpl(ApacheFactoryContext factoryContext,
import org.apache.bval.jsr303.ApacheFactoryContext;
    public MethodValidatorImpl(ApacheFactoryContext factoryContext) {
import org.apache.bval.jsr303.ApacheFactoryContext;
    public MethodValidatorMetaBeanFactory(ApacheFactoryContext factoryContext) {
import org.apache.bval.jsr303.ApacheValidatorFactory;
    private final ApacheValidatorFactory factory;
    public ValidationMappingParser(ApacheValidatorFactory factory) {
        return EMailValidation.isValid(value);
public class NotEmptyValidatorForCollection implements ConstraintValidator<NotEmpty, Collection<?>> {
    public boolean isValid(Collection<?> value, ConstraintValidatorContext context) {
public class NotEmptyValidatorForMap implements ConstraintValidator<NotEmpty, Map<?, ?>> {
    public boolean isValid(Map<?, ?> value, ConstraintValidatorContext context) {
      implements ConstraintValidator<Size, Collection<?>> {
    public boolean isValid(Collection<?> collection, ConstraintValidatorContext context) {
      implements ConstraintValidator<Size, Map<?, ?>> {
    public boolean isValid(Map<?, ?> map, ConstraintValidatorContext context) {
import java.io.InputStream;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.bval.jsr303.util.EnumerationConverter;
import org.apache.commons.beanutils.ConvertUtils;
import org.apache.commons.beanutils.Converter;

        /* Converter lookup */
        Converter converter = ConvertUtils.lookup(returnType);
        if (converter == null && returnType.isEnum()) {
            converter = EnumerationConverter.getInstance();
        }

        return ConvertUtils.convert(value, returnType);

import java.io.Closeable;
        InputStream inputStream = null;
            inputStream = getInputStream(validationXmlFile);
        } finally {
            closeQuietly(inputStream);
            InputStream in = null;
            } finally {
                closeQuietly(in);

    private static void closeQuietly(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (IOException e) {
                // do nothing
            }
        }
    }
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Enumeration;
import org.apache.bval.jsr303.ConfigurationImpl;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.PrivilegedActions;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.xml.sax.SAXException;
    protected final Class<?> elementClass;
    protected ElementDescriptorImpl(Class<?> elementClass, Validation[] validations) {
    public Class<?> getElementClass() {
        final Set<ConstraintDescriptor<?>> cds = new HashSet<ConstraintDescriptor<?>>(validations.length);
import org.apache.bval.jsr303.util.IOUtils;
        } finally {
            IOUtils.closeQuietly(in);
import org.apache.bval.jsr303.util.IOUtils;
            IOUtils.closeQuietly(inputStream);
    private static final long serialVersionUID = 1L;
    private static final long serialVersionUID = 1L;

    public static <T> T newInstance(final Class<T> cls, final Class<?>[] paramTypes,
    public static Field getDeclaredField(final Class<?> clazz, final String fieldName) {
        } else if (type instanceof Class<?>) {
            Class<?> clazz = (Class<?>) type;
            if (!(paramType.getRawType() instanceof Class<?>)) {
    private final List<ParameterDescriptor> parameterDescriptors = new ArrayList<ParameterDescriptor>();
    protected ConstructorDescriptorImpl(Class<?> elementClass, Validation[] validations) {
    ConstructorDescriptor getConstraintsForConstructor(Constructor<?> constructor);
    private Map<Constructor<?>, ConstructorDescriptor> constructorConstraints;
          Map<Constructor<?>, ConstructorDescriptor> constructorConstraints) {
    public ConstructorDescriptor getConstraintsForConstructor(Constructor<?> constructor) {
        return new HashSet<MethodDescriptor>(methodConstraints.values());
        return new HashSet<ConstructorDescriptor>(this.constructorConstraints.values());
    public void putConstructorDescriptor(Constructor<?> cons, ConstructorDescriptorImpl desc) {
    public Map<Constructor<?>, ConstructorDescriptor> getConstructorConstraints() {
    private final List<ParameterDescriptor> parameterDescriptors = new ArrayList<ParameterDescriptor>();
    protected MethodDescriptorImpl(Class<?> elementClass, Validation[] validations) {
    public ParameterDescriptorImpl(Class<?> elementClass, Validation[] validations) {
import org.apache.bval.model.MetaBean;
// TODO RSt - move. this is an optional module: move freemarker dependency and template "bean-infos-json.ftl" with it.
        @Deprecated // TODO RSt - I suggest to remove this and all related code
    @Deprecated // remove this method?
import static org.apache.bval.model.Features.Property.JAVASCRIPT_VALIDATION_FUNCTIONS;

            // obsolete code? remove from here --->
            }  // <--- to here
    public static void setDefault(ApacheValidatorFactory aDefaultFactory) {
     DEFAULT_FACTORY = aDefaultFactory;
    }

  public ApacheValidatorFactory() {
 b/bval-jsr303/src/test/java/org/apache/bval/constraints/CompanyEmail.java
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

    @Pattern(regexp = ".*?COMPANY.*?")
public @interface CompanyEmail {
    String message() default "Not an email of COMPANY";
          constraintIndex = 1) String agimatecMessage() default "Not COMPANY";
        CompanyEmail[] value();
 b/bval-jsr303/src/test/java/org/apache/bval/jsr303/example/CompanyAddress.java
import org.apache.bval.constraints.CompanyEmail;
public class CompanyAddress {
    @CompanyEmail
    public CompanyAddress() {
    public CompanyAddress(String email) {
import org.apache.bval.*;
import javax.validation.*;
      /**
       * TODO RSt - decide whether to move proprietary XMLMetaBeanFactory support (currently handled with XStream) out of the core:
       *  get rid of XStream dependency and package org.apache.bval.xml in core
       *  this would also require a split in MetaBeanManager and MetaBeanBuilder, because parts of the code deal with classes in this package  
       */
    /** Alternative method to add a fully initialized {@link ValidationListener.Error} object. */
import java.util.regex.Matcher;
import java.util.regex.Pattern;

 * TODO RSt - could become part of optional module, depends on proprietary XML support only (package org.apache.bval.xml)
 * TODO RSt - could become part of optional module, depends on proprietary XML support only (package org.apache.bval.xml)
 * TODO RSt - could become part of optional module or remove this interface. it depends indirectly on proprietary XML support only (package org.apache.bval.xml)
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.xml.XMLMetaValue;
import static org.apache.bval.routines.Reasons.*;
 * TODO RSt - could become part of optional module, depends on proprietary XML support only (package org.apache.bval.xml) 
import org.apache.bval.model.ValidationListener;
import javax.validation.ConstraintValidator;
import javax.validation.Payload;
import javax.validation.ValidationException;
import javax.validation.metadata.ConstraintDescriptor;
        for (ValidationListener.Error each : jsrContext.getErrorMessages()) {
    PropertyDescriptorImpl(Class<?> elementClass, Validation[] validations) {
    private static final long serialVersionUID = 1L;

    private Class<?> beanClass;
    public Class<?> getBeanClass() {
    public void setBeanClass(Class<?> beanClass) {
    private final Class<?> enumClass;
    public DynaTypeEnum(Class<?> enumClass) {
    public DynaTypeEnum(Class<?> enumClass, String... names) {
    public Class<?> getRawType() {
    public boolean isAssignableFrom(Class<?> cls) {
    private static final long serialVersionUID = 1L;

    private static final long serialVersionUID = 1L;

        if (rawType instanceof Class<?>) {
            return (Class<?>) rawType;
        if (value instanceof Iterable<?>) {
            Iterator<?> iter = ((Iterable<?>) value).iterator();
            Class<?> collectionClass = getCollectionClass(type);
    static Class<? extends Collection<?>> getCollectionClass(Type type) {
        if (type instanceof Class<?> && isCollectionClass((Class<?>) type)) {
            return (Class<? extends Collection<?>>) type;
        if (type instanceof Class<?>) {
            return ((Class<?>) type).isArray();
                        } catch (NoSuchMethodException e3) {
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.bval.model.MetaBean;

import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
        List<MetaBean> metaBeans = new ArrayList<MetaBean>(1);
        Map<String, Object> rootMap = new HashMap<String, Object>();
                                                                final Class<?>[] paramTypes,
        return run(new PrivilegedAction<Object>() {
    public static ClassLoader getClassLoader(final Class<?> clazz) {
    private final Class<?> beanClass;
    public PropertyAccess(Class<?> clazz, String propertyName) {
        if (bean instanceof Map<?, ?>) {
            return ((Map<?, ?>) bean).get(property);
            Class<?> theClass = beanClass;
                    Class<?> theClass = bean.getClass();
    MetaBean findForClass(Class<?> clazz);
    public MetaBean findForClass(Class<?> clazz) {
                Class<?> beanType = prop.getFeature(REF_BEAN_TYPE);
    private static final long serialVersionUID = 1L;

    public MetaBean findForClass(Class<?> clazz) {
 * Description: example validation for email addresses using a regular expression<br/>
 * 
 * TODO RSt - could become part of optional module, depends on proprietary XML
 * support only (package org.apache.bval.xml)
 * 
 * 
 * 
/**
 * Description: <br/>
 */
 * TODO - This class is NOT part of the bean_validation spec and might disappear
 * Description: <br/>
 * Description: compute group order, based on the RI behavior as to guarantee
 * compatibility with interpretations of the spec.<br/>
    protected Class<?> findLocalClass(String className) {
    public MetaBean buildForClass(Class<?> clazz) throws Exception {
    private static final long serialVersionUID = 1L;

        return bean instanceof Class<?> ?
                finder.findForClass((Class<?>) bean) : finder.findForClass(bean.getClass());
import org.apache.bval.util.AccessStrategy;
import javax.validation.Constraint;
import javax.validation.ConstraintValidator;
import javax.validation.Valid;
                	ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
                    processAnnotations(consDesc, paramAnnos, access, idx);
                ReturnAccess returnAccess = new ReturnAccess(method.getReturnType());
                    processAnnotation(anno, methodDesc, returnAccess, validations);
                	ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
                    processAnnotations(methodDesc, paramAnnos, access, idx);
                                    AccessStrategy access, int idx)
            processAnnotation(anno, methodDesc, access, validations);
                                   AccessStrategy access, AppendValidation validations)
                      desc.getMetaBean().getBeanClass(), access, validations);
                        processAnnotation(each, desc, access, validations); // recursion
    
    
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;

    
    public void save(@Pattern(regexp="[a-f0-9]{4}") String data) {
    	return;
    }
    
    @NotNull
    @Size(min=3,max=10)
    public String echo(@NotNull @Size(min=3,max=10) String str) {
    	return str;
    }
//TODO RSt - move. this is an optional module: move the whole package. core code has no dependencies on it 
    protected <VL extends ValidationListener> boolean determineMetaBean(Validate validate, Object parameter,
                                        ValidationContext<VL> context) {
            Class<?> beanClass;
            if (parameter instanceof Collection<?>) {   // do not validate empty collection
                Collection<?> coll = ((Collection<?>) parameter);
    public <VL extends ValidationListener> void validateProperty(ValidationContext<VL> context) {
    public <VL extends ValidationListener> void validateContext(ValidationContext<VL> context) {
            if (!treatMapsLikeBeans && context.getBean() instanceof Map<?, ?>) {
            } else if (context.getBean() instanceof Iterable<?>) {
    private <VL extends ValidationListener> void validateBeanInContext(ValidationContext<VL> context) {
    private <VL extends ValidationListener> void validateArrayInContext(ValidationContext<VL> context) {
    private <VL extends ValidationListener> DynamicMetaBean getDynamicMetaBean(ValidationContext<VL> context) {
    private <VL extends ValidationListener> void validateIteratableInContext(ValidationContext<VL> context) {
        Iterator<?> it = ((Iterable<?>) context.getBean()).iterator();
    private <VL extends ValidationListener> void validateMapInContext(ValidationContext<VL> context) {
        Iterator<Map.Entry<Object, Object>> it = ((Map<Object, Object>) context.getBean()).entrySet().iterator();
            Map.Entry<Object, Object> entry = it.next();
    protected <VL extends ValidationListener> void validateBeanNet(ValidationContext<VL> context) {
    private <VL extends ValidationListener> void validateRelatedBean(ValidationContext<VL> context, MetaProperty prop) {
    public <VL extends ValidationListener> void validateBean(ValidationContext<VL> context) {
    private static final long serialVersionUID = 1L;

    public <T extends ValidationListener> void addError(String reason, ValidationContext<T> context) {
    public <T extends ValidationListener> void addError(Error error, ValidationContext<T> context) {
        errorsByReason = new LinkedHashMap<String, List<Error>>();
        errorsByOwner = new LinkedHashMap<Object, Map<String, List<Error>>>();
    <T extends ValidationListener> void validate(ValidationContext<T> context);
    <T extends ValidationListener> void addError(String reason, ValidationContext<T> context);
    <T extends ValidationListener> void addError(Error error, ValidationContext<T> context);
        private static final long serialVersionUID = 1L;

import org.apache.bval.model.ValidationListener;
    public <T extends ValidationListener> void validate(ValidationContext<T> context) {
import org.apache.bval.model.ValidationListener;
    public <T extends ValidationListener> void validate(ValidationContext<T> context) {
import org.apache.bval.model.ValidationListener;
    public <T extends ValidationListener> void validate(ValidationContext<T> context) {
    protected <T extends ValidationListener> void validateTimeLag(ValidationContext<T> context) {
    protected <T extends ValidationListener> void validateRegExp(ValidationContext<T> context) {
    protected <T extends ValidationListener> void validateMinValue(ValidationContext<T> context) {
    protected <T extends ValidationListener> void validateMaxValue(ValidationContext<T> context) {
    private <T extends ValidationListener> int compare(ValidationContext<T> context, Comparable constraintValue,
    protected <T extends ValidationListener> void validateMaxLength(ValidationContext<T> context) {
    protected <T extends ValidationListener> void validateMinLength(ValidationContext<T> context) {
    protected <T extends ValidationListener> void validateMandatory(ValidationContext<T> context) {
        Comparable<Object> minValue = (Comparable<Object>) context.getMetaProperty().getFeature(MIN_VALUE);
        Comparable<Object> maxValue = (Comparable<Object>) context.getMetaProperty().getFeature(MAX_VALUE);
    private <T extends ValidationListener> int compare(ValidationContext<T> context, Comparable<Object> constraintValue,
        } else if (value instanceof Collection<?>) {
            length = ((Collection<?>) value).size();
        } else if (value instanceof Collection<?>) {
            length = ((Collection<?>) value).size();
    protected IdentityHashMap<Object, Object> validatedObjects = new IdentityHashMap<Object, Object>();
import java.lang.annotation.Annotation;

    <T extends Annotation> void append(ConstraintValidation<T> validation);
import java.lang.annotation.Annotation;

    public <T extends Annotation> void append(ConstraintValidation<T> validation) {
import java.lang.annotation.Annotation;

    public <T extends Annotation> void append(ConstraintValidation<T> validation) {
import java.lang.annotation.Annotation;
    private final List<ConstraintValidation<? extends Annotation>> validations = new ArrayList<ConstraintValidation<? extends Annotation>>();
    public <T extends Annotation> void append(ConstraintValidation<T> validation) {
    public List<ConstraintValidation<? extends Annotation>> getValidations() {
    public <A extends Annotation> AnnotationProxy(AnnotationProxyBuilder<A> descriptor) {
    private <A extends Annotation> Map<String, Object> getAnnotationValues(AnnotationProxyBuilder<A> descriptor) {
        Map<String, Object> result = new HashMap<String, Object>();
        SortedSet<String> result = new TreeSet<String>();
        Set<PropertyDescriptor> validatedProperties = new HashSet<PropertyDescriptor>();
    private Map<Method, MethodDescriptor> methodConstraints;
    public void setMethodConstraints(Map<Method, MethodDescriptor> methodConstraints) {
    public void putMethodDescriptor(Method method, MethodDescriptor desc) {
    public void putConstructorDescriptor(Constructor<?> cons, ConstructorDescriptor desc) {
    public Map<Method, MethodDescriptor> getMethodConstraints() {
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;

import javax.validation.Constraint;
import javax.validation.ConstraintValidator;
import javax.validation.Valid;

        beanDesc.setConstructorConstraints(new HashMap<Constructor<?>, ConstructorDescriptor>());
        for (Constructor<?> cons : beanDesc.getMetaBean().getBeanClass()
                    ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
        beanDesc.setMethodConstraints(new HashMap<Method, MethodDescriptor>());
                methodDesc.getConstraintDescriptors().addAll(validations.getValidations());
                    ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);

     * @param constructor     the constructor whose parameters are correctly validated
                                                    Constructor<T> constructor,
     * @param constructor    the method whose parameters are correctly validated
                                                   Constructor<T> constructor,
                                                              Constructor<T> constructor,
                                                             Constructor<T> constructor,
        List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>(3);
            for (Class<?> interfaceClass : beanClass.getInterfaces()) {
            List<Class<?>> classSequence = new ArrayList<Class<?>>();
            Class<?> theClass = beanClass;
                Class<?> eachClass = classSequence.get(i);
    private boolean processAnnotations(MetaProperty prop, Class<?> owner,
    private boolean processAnnotation(Annotation annotation, MetaProperty prop, Class<?> owner,
            groupSeq = new ArrayList<Group>(annotation == null ? 1 : annotation.value().length);
                                      MetaProperty prop, Class<?> owner, AccessStrategy access,
            final List<Type> assignableTypes = new ArrayList<Type>(constraintClasses.length);
    private void checkOneType(List<Type> types, Type targetType, Class<?> owner, Annotation anno,
    private Type determineTargetedType(Class<?> owner, AccessStrategy access) {
        if (type instanceof Class<?>) type = ClassUtils.primitiveToWrapper((Class<?>) type);
        if (clazz instanceof Class<?>) {
            if (((Class<?>) clazz).isArray()) {
                return ((Class<?>) clazz).getComponentType().getName()  "[]";
                return ((Class<?>) clazz).getName();
    private String stringForLocation(Class<?> owner, AccessStrategy access) {
        defaultSequences = new HashMap<Class<?>, Class<?>[]>();
        validAccesses = new HashMap<Class<?>, List<AccessStrategy>>();
        constraintMap = new HashMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>>();
            List<AccessStrategy> tmpList = new ArrayList<AccessStrategy>();
            return (List) slot;
    private Type paramType;
    private int paramIdx;
    public ParameterAccess(Type paramType, int paramIdx ) {
        this.paramType = paramType;
        this.paramIdx = paramIdx;
    }
    @Override
    public Object get(Object instance) {
        throw new NotImplementedException("Obtaining a parameter value not yet implemented");
    }
    @Override
    public ElementType getElementType() {
        return ElementType.PARAMETER;
    }
    @Override
    public Type getJavaType() {
        return this.paramType;
    }
    @Override
    public String getPropertyName() {
        return ""  paramIdx;
    }
    private Type returnType;
    public ReturnAccess(Type returnType) {
        this.returnType = returnType;
    }
    @Override
    public Object get(Object instance) {
        throw new NotImplementedException("Obtaining a method return value not yet implemented");
    }
    @Override
    public ElementType getElementType() {
        return ElementType.METHOD;
    }
    @Override
    public Type getJavaType() {
        return this.returnType;
    }
    @Override
    public String getPropertyName() {
        return "Return value";
    }
    	if ( isRootPath() && nodeList.get(0).getIndex() == null ) {
    		nodeList.set(0, node);
    	}
    	else {
    		nodeList.add(node);
    	}
    }           
            return value.longValue() <= max;
            return value.longValue() >= minValue;
                resolvedParameterValue = parameter;
        checkGroups(groupArray);
        
                        .findForClass(object.getClass()), object, (Class<T>)object.getClass(), groupArray);
        if (ex instanceof ValidationException || ex instanceof IllegalArgumentException) {
        
        checkPropertyName(propertyName);
        checkGroups(groups);
        
                  createContext(metaBean, object, (Class<T>)object.getClass(), groups);
        
        checkBeanType(beanType);
        checkPropertyName(propertyName);
        checkGroups(groups);
        
                  createContext(metaBean, null, beanType, groups);
          MetaBean metaBean, T object, Class<T> objectClass, Class<?>[] groups) {
        ConstraintValidationListener<T> listener = new ConstraintValidationListener<T>(object, objectClass);
    /**
     * Checks that beanType is valid according to spec Section 4.1.1 i. Throws
     * an {@link IllegalArgumentException} if it is not.
     * 
     * @param beanType
     *            Bean type to check.
     */
    private void checkBeanType(Class<?> beanType) {
        if (beanType == null) {
            throw new IllegalArgumentException("Bean type cannot be null.");
        }
    }

    /**
     * Checks that the property name is valid according to spec Section 4.1.1 i.
     * Throws an {@link IllegalArgumentException} if it is not.
     * 
     * @param propertyName
     *            Property name to check.
     */
    private void checkPropertyName(String propertyName) {
        if (propertyName == null || propertyName.isEmpty() ) {
            throw new IllegalArgumentException("Property path cannot be null or empty.");
        }
    }

    /**
     * Checks that the groups array is valid according to spec Section 4.1.1 i.
     * Throws an {@link IllegalArgumentException} if it is not.
     * 
     * @param groups
     *            The groups to check.
     */
    private void checkGroups(Class<?>[] groups) {
        if ( groups == null ) {
            throw new IllegalArgumentException("Groups cannot be null.");
        }
    }
                  new ConstraintValidationListener(oldListener.getRootBean(), oldListener.getRootBeanType());
    private final Class<T> rootBeanType;
    public ConstraintValidationListener(T aRootBean, Class<T> rootBeanType) {
        this.rootBeanType = rootBeanType;
              message, rootBean, context.getBean(), propPath, value, constraint, rootBeanType);
    
    public Class<T> getRootBeanType() {
        return rootBeanType;
    }
    private final Class<T> rootBeanClass;
    
                                   ConstraintDescriptor constraintDescriptor, Class<T> rootBeanClass) {
        this.rootBeanClass = rootBeanClass;
    public Class<T> getRootBeanClass() {
        return rootBeanClass;
                        throw new IllegalArgumentException(
        } catch (IllegalArgumentException ex) {
            throw ex; // route exception
              createContext(methodDescriptor.getMetaBean(), returnedValue, null, groupArray);
                      createContext(metaBean, null, null, groupArray);
                  createContext(paramDesc.getMetaBean(), parameter, null, groupArray);
import java.util.*;
            fillFullClassHierarchyAsList(classSequence, beanClass);

    
    /**
     * Fill the list with the full class/interface hierarchy of the given class.
     * List is ordered from the most to less specific.
     * 
     * @param allClasses
     *            The current list of classes in the hierarchy.
     * @param clazz
     *            The current class, root of the hierarchy to traverse.
     */
    private void fillFullClassHierarchyAsList(List<Class<?>> allClasses, Class<?> clazz) {
        
        if ( clazz == null || clazz == Object.class ) {
            return;
        }
        
        if ( allClasses.contains(clazz) ) {
            // No duplicates wanted, and if it is already in the list, then
            // its superclasses/interfaces will also be
            return;
        }
        
        allClasses.add(clazz);

        // Obtain the list of interfaces and superclass
        List<Class<?>> subClasses = new ArrayList<Class<?>>(Arrays.asList(clazz.getInterfaces()));
        subClasses.add(0, clazz.getSuperclass());
        
        for ( Class<?> subClass : subClasses ) {
            fillFullClassHierarchyAsList(allClasses, subClass);
        }
        
    }
  private final Class<?> beanClass;
  private final String propertyName;
  private Field rememberField;
  public PropertyAccess(Class<?> clazz, String propertyName) {
    this.beanClass = clazz;
    this.propertyName = propertyName;
  }

  public ElementType getElementType() {
    return ElementType.METHOD;
  }

  private static Object getPublicProperty(Object bean, String property) throws
      InvocationTargetException, NoSuchMethodException, IllegalAccessException {
    if (bean instanceof Map<?, ?>) {
      return ((Map<?, ?>) bean).get(property);
    } else { // supports DynaBean and standard Objects
      return PropertyUtils.getSimpleProperty(bean, property);
  }
  public static Object getProperty(Object bean, String propertyName) throws
      InvocationTargetException, NoSuchMethodException, IllegalAccessException {
    return new PropertyAccess(bean.getClass(), propertyName).get(bean);
  }

  public String toString() {
    return "Property{"  beanClass.getName()  '.'  propertyName  '}';
  }

  public Type getJavaType() {
    /*if(Map.class.isAssignableFrom(beanClass)) {
        return beanClass.
    }*/
    if (rememberField != null) {  // use cached field of previous access
      return rememberField.getGenericType();
    for (PropertyDescriptor each : PropertyUtils.getPropertyDescriptors(beanClass)) {
      if (each.getName().equals(propertyName) && each.getReadMethod() != null) {
        return each.getReadMethod().getGenericReturnType();
      }
    try { // try public field
      return beanClass.getField(propertyName).getGenericType();
    } catch (NoSuchFieldException ex2) {
      // search for private/protected field up the hierarchy
      Class<?> theClass = beanClass;
      while (theClass != null) {
          return theClass.getDeclaredField(propertyName).getGenericType();
        } catch (NoSuchFieldException ex3) {
          // do nothing
        theClass = theClass.getSuperclass();
      }
    return Object.class; // unknown type: allow any type??
  }
  public String getPropertyName() {
    return propertyName;
  }
  public Object get(Object bean) {
    try {
      if (rememberField != null) {  // cache field of previous access
        return rememberField.get(bean);
      }
      try {   // try public method
        return getPublicProperty(bean, propertyName);
      } catch (NoSuchMethodException ex) {
        return getFieldValue(bean);
      }
    } catch (IllegalArgumentException e) {
      throw e;
    } catch (Exception e) {
      throw new IllegalArgumentException("cannot access "  propertyName, e);
  }
  private Object getFieldValue(Object bean) throws IllegalAccessException {
    Object value;
    try { // try public field
      Field aField = bean.getClass().getField(propertyName);
      value = aField.get(bean);
      rememberField = aField;
      return value;
    } catch (NoSuchFieldException ex2) {
      // search for private/protected field up the hierarchy
      Class<?> theClass = bean.getClass();
      while (theClass != null) {
        try {
          Field aField = theClass
              .getDeclaredField(propertyName);
          if (!aField.isAccessible()) {
            aField.setAccessible(true);
          }
          value = aField.get(bean);
          rememberField = aField;
          return value;
        } catch (NoSuchFieldException ex3) {
          // do nothing
        }
        theClass = theClass.getSuperclass();
      }
      throw new IllegalArgumentException(
          "cannot access field "  propertyName);
  }

  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    PropertyAccess that = (PropertyAccess) o;

    return beanClass.equals(that.beanClass) && propertyName.equals(that.propertyName);
  }

  public int hashCode() {
    int result;
    result = beanClass.hashCode();
    result = 31 * result  propertyName.hashCode();
    return result;
  }
                if (!result.isEmpty()) break; 
                if (!result.isEmpty()) break;
                if (!result.isEmpty()) break;
                        setValue(PropertyAccess.getProperty(getValue(), token));
import org.apache.bval.model.*;
import java.util.IdentityHashMap;

    
    public AccessStrategy getAccess() {
        return this.access;
    }
    
    AccessStrategy getAccess();
 * Description: Undefined dynamic strategy (FIELD or METHOD access) 
 * Uses PropertyUtils or tries to determine
    return (rememberField != null) ? ElementType.FIELD : ElementType.METHOD;
    }            

    public ConstraintDescriptor<T> asSerializableDescriptor() {
      return new ConstraintDescriptorImpl(this);
        context.setConstraintValidation(this);
import javax.validation.ConstraintViolation;
import javax.validation.MessageInterpolator;
import javax.validation.Path;
import javax.validation.metadata.ConstraintDescriptor;
import java.lang.annotation.ElementType;
        final ConstraintDescriptor descriptor;
            descriptor = gcontext.getConstraintValidation().asSerializableDescriptor();
            else value = context.getPropertyValue();
            descriptor = null;
        ElementType elementType = (context.getAccess() != null) ? context.getAccess().getElementType() : null;
              message, rootBean, context.getBean(), propPath, value, descriptor, rootBeanType, elementType);

import javax.validation.ConstraintValidatorContext;
import javax.validation.Path;
import javax.validation.ValidationException;
import java.io.Serializable;
import java.lang.annotation.ElementType;
 * TODO RSt - must be serializable (BVAL-13)
class ConstraintViolationImpl<T> implements ConstraintViolation<T>, Serializable {
    private final ElementType elementType;
                                   ConstraintDescriptor constraintDescriptor, Class<T> rootBeanClass, ElementType elementType) {
        this.elementType = elementType;

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result
                 ((this.leafBean == null) ? 0 : this.leafBean.hashCode());
        result = prime * result
                 ((this.message == null) ? 0 : this.message.hashCode());
        result = prime
                * result
                 ((this.propertyPath == null) ? 0 : this.propertyPath
                        .hashCode());
        result = prime * result
                 ((this.rootBean == null) ? 0 : this.rootBean.hashCode());
        result = prime * result
                 ((this.value == null) ? 0 : this.value.hashCode());
        result = prime * result
                 ((this.elementType == null) ? 0 : this.elementType.hashCode());
        return result;
    }

    /**
     * NOTE: Needed to avoid duplication in the reported violations.
     * 
     * @param   obj   the reference object with which to compare.
     * @return  <code>true</code> if this object is the same as the obj
     *          argument; <code>false</code> otherwise.
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof ConstraintViolationImpl<?>)) {
            return false;
        }

        ConstraintViolationImpl<?> other = (ConstraintViolationImpl<?>) obj;

        if (this.leafBean == null) {
            if (other.leafBean != null) {
                return false;
            }
        } else if (!this.leafBean.equals(other.leafBean)) {
            return false;
        }
        
        if (this.message == null) {
            if (other.message != null) {
                return false;
            }
        } else if (!this.message.equals(other.message)) {
            return false;
        }
        
        if (this.propertyPath == null) {
            if (other.propertyPath != null) {
                return false;
            }
        } else if (!this.propertyPath.equals(other.propertyPath)) {
            return false;
        }
        
        if (this.rootBean == null) {
            if (other.rootBean != null) {
                return false;
            }
        } else if (!this.rootBean.equals(other.rootBean)) {
            return false;
        }
        
        if (this.rootBeanClass != other.rootBeanClass) {
            return false;
        }
        
        if (this.value == null) {
            if (other.value != null) {
                return false;
            }
        } else if (!this.value.equals(other.value)) {
            return false;
        }
        
        if (this.elementType != other.elementType) {
            return false;
        }
        
        return true;
    }
    
    
import javax.validation.ConstraintValidator;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;

    void setConstraintValidation(ConstraintValidation constraint);
    public ConstraintValidation getConstraintValidation();
import javax.validation.ConstraintValidator;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;
import javax.validation.metadata.ConstraintDescriptor;
    extends BeanValidationContext<T>
    implements GroupValidationContext<T>, MessageInterpolator.Context {
  private final MessageInterpolator messageResolver;
  private final PathImpl path;
  private final MetaBean rootMetaBean;
  /**
   * the groups in the sequence of validation to take place
   */
  private Groups groups;
  /**
   * the current group during the validation process
   */
  private Group currentGroup;
  /**
   * contains the validation constraints that have already been processed during
   * this validation routine (as part of a previous group match)
   */
  private IdentityHashMap<Object, IdentityHashMap<ConstraintValidator, Object>> validatedConstraints =
      new IdentityHashMap();
  private ConstraintValidation constraintValidation;
  private final TraversableResolver traversableResolver;
  public GroupValidationContextImpl(T listener, MessageInterpolator aMessageResolver,
                                    TraversableResolver traversableResolver,
                                    MetaBean rootMetaBean) {
    super(listener);
    this.messageResolver = aMessageResolver;
    this.traversableResolver = CachingTraversableResolver.cacheFor(traversableResolver);
    this.rootMetaBean = rootMetaBean;
    this.path = PathImpl.create(null);
  }

  @Override
  public void setCurrentIndex(int index) {
    path.getLeafNode().setIndex(index);
  }

  @Override
  public void setCurrentKey(Object key) {
    path.getLeafNode().setKey(key);
  }

  @Override
  public void moveDown(MetaProperty prop, AccessStrategy access) {
    path.addNode(new NodeImpl(prop.getName()));
    super.moveDown(prop, access);
  }

  @Override
  public void moveUp(Object bean, MetaBean metaBean) {
    path.removeLeafNode();
    super.moveUp(bean, metaBean); // call super!
  }

  /**
   * add the object in the current group
   * to the collection of validated objects to keep
   * track of them to avoid endless loops during validation.
   *
   * @return true when the object was not already validated in this context
   */
  @Override
  public boolean collectValidated() {
    Set<Group> groupSet = (Set<Group>) validatedObjects.get(getBean());
    if (groupSet == null) {
      groupSet = new HashSet(10);
      validatedObjects.put(getBean(), groupSet);
    return groupSet.add(getCurrentGroup());
  }
  /**
   * @return true when the constraint for this object was not already validated in this context
   */
  public boolean collectValidated(Object bean, ConstraintValidator constraint) {
    IdentityHashMap<ConstraintValidator, Object> beanConstraints =
        validatedConstraints.get(bean);
    if (beanConstraints == null) {
      beanConstraints = new IdentityHashMap();
      validatedConstraints.put(bean, beanConstraints);
    return beanConstraints.put(constraint, Boolean.TRUE) == null;
  }
  public boolean isValidated(Object bean, ConstraintValidator constraint) {
    IdentityHashMap<ConstraintValidator, Object> beanConstraints =
        validatedConstraints.get(bean);
    return beanConstraints != null && beanConstraints.containsKey(constraint);
  }
  public void resetValidatedConstraints() {
    validatedConstraints.clear();
  }
  /**
   * if an associated object is validated,
   * add the association field or JavaBeans property name and a dot ('.') as a prefix
   * to the previous rules.
   * uses prop[index] in property path for elements in to-many-relationships.
   *
   * @return the path in dot notation
   */
  public PathImpl getPropertyPath() {
    PathImpl currentPath = PathImpl.copy(path);
    if (getMetaProperty() != null) {
      currentPath.addNode(new NodeImpl(getMetaProperty().getName()));
    return currentPath;
  }
  public MetaBean getRootMetaBean() {
    return rootMetaBean;
  }
  public void setGroups(Groups groups) {
    this.groups = groups;
  }
  public Groups getGroups() {
    return groups;
  }
  public Group getCurrentGroup() {
    return currentGroup;
  }
  public void setCurrentGroup(Group currentGroup) {
    this.currentGroup = currentGroup;
  }
  public void setConstraintValidation(ConstraintValidation constraint) {
    constraintValidation = constraint;
  }
  public ConstraintValidation getConstraintValidation() {
    return constraintValidation;
  }
  public ConstraintDescriptor getConstraintDescriptor() {
    return constraintValidation;
  }
  /**
   * @return value being validated
   */
  public Object getValidatedValue() {
    if (getMetaProperty() != null) {
      return getPropertyValue(constraintValidation.getAccess());
    } else {
      return getBean();
  }
  public MessageInterpolator getMessageResolver() {
    return messageResolver;
  }
  public TraversableResolver getTraversableResolver() {
    return traversableResolver;
  }
import javax.validation.Constraint;
import javax.validation.ConstraintValidator;
import javax.validation.Valid;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;

 * Description: Describe a constraint validation defect.<br/>
        if (clazz == null) {
            throw new IllegalArgumentException("Class cannot be null");
        }
        if (validator != null && !context.collectValidated(context.getPropertyPath(), validator))
            matcher.appendReplacement(sb, sanitizeForAppendReplacement(resolvedParameterValue));
            matcher.appendReplacement(sb, sanitizeForAppendReplacement(resolvedParameterValue));
    
    /**
     * Escapes the string to comply with
     * {@link Matcher#appendReplacement(StringBuffer, String)} requirements.
     * 
     * @param src
     *            The original string.
     * @return The sanitized string.
     */
    private String sanitizeForAppendReplacement(String src) {
        return src.replace("\\", "\\\\").replace("$", "\\$");
    }
import java.util.*;
  private HashMap<PathImpl, IdentityHashMap<ConstraintValidator, Object>> validatedConstraints =
      new HashMap<PathImpl, IdentityHashMap<ConstraintValidator, Object>>();
    /**
     * add the object in the current group to the collection of validated
     * objects to keep track of them to avoid endless loops during validation.
     * 
     * @return true when the object was not already validated in this context
     */
    @Override
    public boolean collectValidated() {
        Map<Group, Set<PathImpl>> groupMap = (Map<Group, Set<PathImpl>>) validatedObjects
                .get(getBean());
        if (groupMap == null) {
            groupMap = new HashMap<Group, Set<PathImpl>>();
            validatedObjects.put(getBean(), groupMap);
        }
        Set<PathImpl> validatedPathsForGroup = groupMap.get(getCurrentGroup());
        if (validatedPathsForGroup == null) {
            validatedPathsForGroup = new HashSet<PathImpl>();
            groupMap.put(getCurrentGroup(), validatedPathsForGroup);
        }
        // If any of the paths is a subpath of the current path, there is a
        // circular dependency, so return false
        for (PathImpl validatedPath : validatedPathsForGroup) {
            if (path.isSubPathOf(validatedPath)) {
                return false;
            }
        }

        // Else, add the currentPath to the set of validatedPaths
        validatedPathsForGroup.add(PathImpl.copy(path));
        return true;
    }
  
    /**
     * @return true when the constraint for the object in this path was not
     *         already validated in this context
     */
    public boolean collectValidated(Object path, ConstraintValidator constraint) {
        IdentityHashMap<ConstraintValidator, Object> constraints = this.validatedConstraints
                .get(path);
        if (constraints == null) {
            constraints = new IdentityHashMap<ConstraintValidator, Object>();
            this.validatedConstraints.put((PathImpl) path, constraints);
        }

        return (constraints.put(constraint, Boolean.TRUE) == null);
    }
        if ( ((PathImpl)path).isRootPath() ) {
            return true;
        }
    protected RuntimeException unrecoverableValidationError(RuntimeException ex,
        if (ex instanceof UnknownPropertyException) {
            // Convert to IllegalArgumentException
            return new IllegalArgumentException(ex.getMessage(), ex);
        }
        else if (ex instanceof ValidationException) {
            return ex; // do not wrap specific ValidationExceptions (or instances from subclasses)
            return new ValidationException("error during validation of "  object, ex);
                        throw new UnknownPropertyException(
                        valueMethod.setAccessible(true);
import javax.validation.metadata.BeanDescriptor;
import javax.validation.metadata.PropertyDescriptor;
        if (propertyName == null || propertyName.isEmpty()) {
            throw new IllegalArgumentException("propertyName cannot be null or empty");
        }
    public void setCurrentIndex(Integer index) {
import org.apache.bval.model.*;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.PropertyAccess;

import java.util.List;
            } else if (context.getBean() instanceof List<?>) {
            	validateIteratableInContext(context);
                validateNonPositionalIteratableInContext(context);
    
    private <VL extends ValidationListener> void validateNonPositionalIteratableInContext(ValidationContext<VL> context) {
        Iterator<?> it = ((Iterable<?>) context.getBean()).iterator();
        // jsr303 spec: Each object provided by the iterator is validated.
        context.setCurrentIndex(null);
        final DynamicMetaBean dyn = getDynamicMetaBean(context);
        while (it.hasNext()) { // to Many
            Object each = it.next();
            if (each == null)
                continue; // enhancement: throw IllegalArgumentException? (=> spec)
            if (dyn != null) {
                context.setBean(each, dyn.resolveMetaBean(each));
            } else {
                context.setBean(each);
            }
            validateBeanNet(context);
        }
    }
    void setCurrentIndex(Integer index);
        if (validator != null && !context.collectValidated(validator))
    boolean collectValidated(ConstraintValidator constraint);
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
  private HashSet<ConstraintValidatorIdentity> validatedConstraints =
      new HashSet<ConstraintValidatorIdentity>();
  public void setCurrentIndex(Integer index) {
  /**
   * add the object in the current group to the collection of validated
   * objects to keep track of them to avoid endless loops during validation.
   *
   * @return true when the object was not already validated in this context
   */
  @Override
  public boolean collectValidated() {
    Map<Group, Set<PathImpl>> groupMap = (Map<Group, Set<PathImpl>>) validatedObjects
        .get(getBean());
    if (groupMap == null) {
      groupMap = new HashMap<Group, Set<PathImpl>>();
      validatedObjects.put(getBean(), groupMap);
    Set<PathImpl> validatedPathsForGroup = groupMap.get(getCurrentGroup());
    if (validatedPathsForGroup == null) {
      validatedPathsForGroup = new HashSet<PathImpl>();
      groupMap.put(getCurrentGroup(), validatedPathsForGroup);
    // If any of the paths is a subpath of the current path, there is a
    // circular dependency, so return false
    for (PathImpl validatedPath : validatedPathsForGroup) {
      if (path.isSubPathOf(validatedPath)) {
        return false;
      }
    }

    // Else, add the currentPath to the set of validatedPaths
    validatedPathsForGroup.add(PathImpl.copy(path));
    return true;
  }

  /**
   * @return true when the constraint for the object in this path was not
   *         already validated in this context
   */
  public boolean collectValidated(ConstraintValidator constraint) {
    ConstraintValidatorIdentity cvi = new ConstraintValidatorIdentity(getBean(), getPropertyPath(), constraint);
    return this.validatedConstraints.add(cvi);
  }

    // The name of the last "added" node, it will only be added if it has a non-null name
    // The actual incorporation in the path will take place when the definition of the current leaf node is complete
    private String lastNodeName; // Not final as it can be re-used
                              PathImpl path, String name) {
        lastNodeName = name;
        // Modifies the "previous" node in the path
        this.propertyPath.getLeafNode().setInIterable( true );
        return new NodeContextBuilderImpl(parent, messageTemplate, propertyPath, lastNodeName);
        addLastNodeIfNeeded();
        lastNodeName = name;
        return this; // Re-use this instance
        addLastNodeIfNeeded();
    
    private void addLastNodeIfNeeded() {
        if (lastNodeName != null) {
            NodeImpl node = new NodeImpl(lastNodeName);
            propertyPath.addNode(node);
        }
    }
        // Node not yet added, wait until more information is provided
        return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, name);
    // The name of the last "added" node, it will only be added if it has a non-null name
    // The actual incorporation in the path will take place when the definition of the current leaf node is complete
    private final String lastNodeName;
                                    String template, PathImpl path, String name) {
        lastNodeName = name;
        // Modifies the "previous" node in the path
        addLastNodeIfNeeded();
        // Modifies the "previous" node in the path
        addLastNodeIfNeeded();
        addLastNodeIfNeeded();
        return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, lastNodeName);
        addLastNodeIfNeeded();
    
    private void addLastNodeIfNeeded() {
        if (lastNodeName != null) {
            NodeImpl node = new NodeImpl(lastNodeName);
            propertyPath.addNode(node);
        }
    }
/**
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

/**
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

/**
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

/**
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

import java.util.Set;
        // JSR-303 2.3:
        // Groups from the main constraint annotation are inherited by the composing annotations.
        // Any groups definition on a composing annotation is ignored.
        validation.setGroups(builder.getConstraintValidation().getGroups());
    
    /**
     * @return The set of groups from the parent constraint.
     */
    public Set<?> getInheritedGroups() {
        return builder.getConstraintValidation().getGroups();
    }
    
            
            // JSR-303 2.3:
            // Groups from the main constraint annotation are inherited by the composing annotations.
            // Any groups definition on a composing annotation is ignored.
//            applyGroupInheritance(metabean);
            

//    /**
//     * Traverses the metabean to set the groups of the composed constraints the
//     * same as the groups from its root constraint.
//     * 
//     * @param metabean
//     *            The metabean to which group inheritance will be applied.
//     */
//    private void applyGroupInheritance(MetaBean metabean) {
//        for ( MetaProperty prop : metabean.getProperties() ) {
//            for ( Validation val : prop.getValidations() ) {
//                if ( val instanceof ConstraintValidation<?> ) { // Should always be true?
//                    ConstraintValidation<?> cv = (ConstraintValidation<?>) val;
//                    Set<Class<?>> baseGroups = cv.getGroups();
//                    for ( ConstraintValidation<?> composedVal : cv.getComposingValidations() ) {
//                        overrideGroupsAndContinueRecursion(baseGroups, composedVal);
//                    }
//                }
//            }
//        }        
//    }
//
//    /**
//     * Recursive method that sets the current {@link ConstraintValidation}
//     * groups as baseGroups, and continues the recursion with its composing
//     * validations (if any).
//     * 
//     * @param baseGroups
//     *            The groups to set in the current validation node.
//     * @param val
//     *            The current validation node.
//     */
//    private void overrideGroupsAndContinueRecursion(Set<Class<?>> baseGroups, ConstraintValidation<?> val) {
//        val.setGroups(baseGroups);
//        for ( ConstraintValidation<?> composedVal : val.getComposingValidations() ) {
//            overrideGroupsAndContinueRecursion(baseGroups, composedVal);
//        }
//    }

                } // TODO: If propName == null AND it's annotated, throw Ex
        // If already building a constraint composition tree, ensure that the parent groups are inherited
        if ( appender instanceof AppendValidationToBuilder ) {
            builder.getConstraintValidation().setGroups(((AppendValidationToBuilder) appender).getInheritedGroups());
        }
            try {
                validator.initialize(annotation);
            } catch (RuntimeException e) {
                // Either a "legit" problem initializing the validator or a ClassCastException if
                // the validator associated annotation is not a supertype of the validated annotation.
                throw new ConstraintDefinitionException("Incorrect validator ["validator.getClass().getCanonicalName()"] for annotation "  annotation.annotationType().getCanonicalName(), e);
            }
import org.apache.bval.jsr303.xml.AnnotationProxyBuilder;

        Set<Class<?>> inheritedGroups = builder.getConstraintValidation().getGroups();
        validation.setGroups(inheritedGroups);

        // Inherited groups value must also be replicated in the annotation, so
        // it has to be substituted with a new proxy.
        T originalAnnot = validation.getAnnotation();
        AnnotationProxyBuilder<T> apb = new AnnotationProxyBuilder<T>(originalAnnot);
        apb.putValue("groups", inheritedGroups.toArray(new Class[inheritedGroups.size()]));
        T newAnnot = apb.createAnnotation();
        validation.setAnnotation(newAnnot);
        
        // And finally, add the composed validation
    private T annotation; // for metadata request API
    
    public void setAnnotation(T annotation) {
        this.annotation = annotation;
    }
import org.apache.bval.jsr303.util.SecureActions;

import java.io.Serializable;
public class AnnotationProxy implements Annotation, InvocationHandler, Serializable {
import javax.validation.Payload;
import javax.validation.ValidationException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
final public class AnnotationProxyBuilder<A extends Annotation> {
    /**
     * Replicates an existing {@link Annotation} instance.
     * 
     * @param annot
     *            Annotation to be replicated.
     */
    public AnnotationProxyBuilder(A annot) {
        this.type = (Class<A>) annot.annotationType();
        // Obtain the "elements" of the annotation
        Method[] methods = SecureActions.getDeclaredMethods(annot.annotationType());
        for ( Method m : methods ) {
            if ( !m.isAccessible() ) {
                m.setAccessible(true);
            }
            try {
                Object value = m.invoke(annot);
                this.elements.put(m.getName(), value);
            } catch (IllegalArgumentException e) {
                // No args, so should not happen
                throw new ValidationException("Cannot access annotation "  annot  " element: "  m.getName());
            } catch (IllegalAccessException e) {
                throw new ValidationException("Cannot access annotation "  annot  " element: "  m.getName());
            } catch (InvocationTargetException e) {
                throw new ValidationException("Cannot access annotation "  annot  " element: "  m.getName());
            }
        }
    }

import javax.validation.Payload;
        
        // JSR-303 2.3 p:
        // Payloads are also inherited
        Set<Class<? extends Payload>> inheritedPayload = builder.getConstraintValidation().getPayload();
        validation.setPayload(inheritedPayload);
        // Inherited groups and payload values must also be replicated in the 
        // annotation, so it has to be substituted with a new proxy.
        apb.putValue("payload", inheritedPayload.toArray(new Class[inheritedPayload.size()]));
    /**
     * @return The set of payloads from the parent constraint.
     */
    public Set<?> getInheritedPayload() {
        return builder.getConstraintValidation().getPayload();
    }
    
        // If already building a constraint composition tree, ensure that:
        //  - the parent groups are inherited
        //  - the parent payload is inherited
            AppendValidationToBuilder avb = (AppendValidationToBuilder) appender;
            builder.getConstraintValidation().setGroups(avb.getInheritedGroups());
            builder.getConstraintValidation().setPayload(avb.getInheritedPayload());
import org.apache.bval.jsr303.xml.AnnotationProxyBuilder;
    private void applyOverridesAttributes(ConstraintValidation<?> composite) {
        if (null == overrides) {
            buildOverridesAttributes();
        }
            int index = computeIndex(composite);

            // Search for the overrides to apply
            ConstraintOverrides generalOverride = findOverride(composite.getAnnotation().annotationType(), -1);
            if ( generalOverride != null ) {
                if ( index > 0 ) {
                    throw new ConstraintDeclarationException("Wrong OverridesAttribute declaration for "  generalOverride.constraintType  ", it needs a defined index when there is a list of constraints");
                }
                generalOverride.applyOn(composite);

            ConstraintOverrides override = findOverride(composite.getAnnotation().annotationType(), index);
            if ( override != null ) {
                override.applyOn(composite);
            }
            
    
    /**
     * Calculates the index of the composite constraint. The index represents
     * the order in which it is added in reference to other constraints of the
     * same type.
     * 
     * @param composite
     *            The composite constraint (not yet added).
     * @return An integer index always >= 0
     */
    private int computeIndex(ConstraintValidation<?> composite) {
        int idx = 0;
            if (each.getAnnotation().annotationType() == composite.getAnnotation().annotationType()) {
        overrides = new LinkedList<ConstraintOverrides>();
            // Update the attributes
            
            // And the annotation
            Annotation originalAnnot = composite.getAnnotation();
            AnnotationProxyBuilder<Annotation> apb = new AnnotationProxyBuilder<Annotation>(originalAnnot);
            for ( String key : values.keySet() ) {
                apb.putValue(key, values.get(key));
            }
            Annotation newAnnot = apb.createAnnotation();
            composite.setAnnotation(newAnnot);
public class AppendValidationToBuilder extends BaseAppendValidation {
    public <T extends Annotation> void preProcessValidation(ConstraintValidation<T> validation) {
    }
    
    public <T extends Annotation> void performAppend(ConstraintValidation<T> validation) {
import java.lang.annotation.Annotation;

public class AppendValidationToMeta extends BaseAppendValidation {
    public <T extends Annotation> void performAppend(ConstraintValidation<T> validation) {
import javax.validation.ConstraintDefinitionException;
        // Restore current constraint validation
        context.setConstraintValidation(this);
        
    /**
     * Initialize the validator (if not <code>null</code>) with the stored
     * annotation.
     */
    public void initialize() {
        if (null != validator) {
            try {
                validator.initialize(annotation);
            } catch (RuntimeException e) {
                // Either a "legit" problem initializing the validator or a
                // ClassCastException if the validator associated annotation is 
                // not a supertype of the validated annotation.
                throw new ConstraintDefinitionException("Incorrect validator ["  validator.getClass().getCanonicalName()  "] for annotation "  annotation.annotationType().getCanonicalName(), e);
            }
        }
    }

            // NOTE: validator initialization deferred until append phase
import org.apache.bval.jsr303.BaseAppendValidation;
import org.apache.bval.jsr303.ConstraintValidation;

public class AppendValidationToList extends BaseAppendValidation {
    public <T extends Annotation> void performAppend(ConstraintValidation<T> validation) {
            
            // Restore current constraint validation
            context.setConstraintValidation(this);
            
            
            // Restore current constraint validation
            context.setConstraintValidation(this);
        if ( validatorClasses == null ) {
            return Collections.emptyList();
        }
    public Set<Class<?>> getInheritedGroups() {
    public Set<Class<? extends Payload>> getInheritedPayload() {
import org.apache.bval.jsr303.util.ConstraintDefinitionValidator;
                ConstraintDefinitionValidator.validateConstraintDefinition(annotation);

    Class<?>[] groups() default {};
                        // groups  payload must also appear in attributes (also checked by TCK-Tests)
                                constraintValidation.getAttributes()
                                      .put(method.getName(), method.invoke(
                                            constraintValidation.getAnnotation()));


     *

        this.attributes.put("groups", groups.toArray(new Class[groups.size()]));
        this.attributes.put("payload", groups.toArray(new Class[groups.size()]));
                                } else {
                                    constraintValidation.getAttributes()
                                          .put(method.getName(), method.invoke(
                                                constraintValidation.getAnnotation()));
    private MetaBean parentMetaBean;
    
    public MetaBean getParentMetaBean() {
        return parentMetaBean;
    }

    public void setParentMetaBean(MetaBean parentMetaBean) {
        this.parentMetaBean = parentMetaBean;
    }    
        return groups.contains(reqGroup);
                        metaProperty = createMetaProperty(metabean, field.getName(), field.getType());
                                  createMetaProperty(metabean, propName, method.getReturnType());
                    metaProperty = createMetaProperty(metabean,
                      createMetaProperty(metabean, access.getPropertyName(), access.getJavaType());
    private MetaProperty createMetaProperty(MetaBean parentMetaBean, String propName, Type type) {
        metaProperty.setParentMetaBean(parentMetaBean);

        // JSR-303 3.4.4: Add implicit groups
        if ( prop != null && prop.getParentMetaBean() != null ) {
            MetaBean parentMetaBean = prop.getParentMetaBean();
            // If:
            //  - the owner is an interface
            //  - the class of the metabean being build is different than the owner
            //  - and only the Default group is defined
            // Then: add the owner interface as implicit groups
            if ( builder.getConstraintValidation().getOwner().isInterface() &&
                    parentMetaBean.getBeanClass() != builder.getConstraintValidation().getOwner() &&
                    builder.getConstraintValidation().getGroups().size() == 1 &&
                    builder.getConstraintValidation().getGroups().contains(Default.class) ) {
                Set<Class<?>> groups = builder.getConstraintValidation().getGroups();
                groups.add(builder.getConstraintValidation().getOwner());
                builder.getConstraintValidation().setGroups(groups);
            }
        }

        
    private static String lineSeparator = null;
    private static String pathSeparator = null;

    /**
     * Return the value of the "line.separator" system property.
     * 
     * Requires security policy: 
     *   'permission java.util.PropertyPermission "read";'
     */
    public static final String getLineSeparator() {
        if (lineSeparator == null) {
            lineSeparator =
                AccessController.doPrivileged(new PrivilegedAction<String>() {
                    public String run() {
                        return System.getProperty("line.separator");
                    }
                });
        }
        return lineSeparator;
    }

    /**
     * Return the value of the "path.separator" system property.
     * 
     * Requires security policy:
     *   'permission java.util.PropertyPermission "read";'
     */
    public static final String getPathSeparator() {
        if (pathSeparator == null) {
            pathSeparator =
                AccessController.doPrivileged(new PrivilegedAction<String>() {
                    public String run() {
                        return System.getProperty("path.separator");
                    }
                });
        }
        return pathSeparator;
    }

    /**
     * Return a PrivilegedAction object for clazz.getDeclaredMethod().invoke().
     * 
     * Requires security policy
     *  'permission java.lang.RuntimePermission "accessDeclaredMembers";'
     *  'permission java.lang.reflect.ReflectPermission "suppressAccessChecks";'
     *   
     * @return Object
     * @exception IllegalAccessException, InvocationTargetException
     */
    /**
     * Return a PrivilegeAction object for clazz.getClassloader().
     * 
     * Requires security policy:
     *   'permission java.lang.RuntimePermission "getClassLoader";'
     *   
     * @return Classloader
     */

    /**
     * Return a PrivilegeAction object for System.getProperty().
     * 
     * Requires security policy:
     *   'permission java.util.PropertyPermission "read";'
     *   
     * @return String
     */
    public static final String getProperty(final String name) {
        return AccessController.doPrivileged(new PrivilegedAction<String>() {
            public String run() {
                return System.getProperty(name);
            }
        });
    }


  /**
   * bidirectional - set the relationship between a MetaProperty and its parentMetaBean
   * @param name
   * @param property
   */
        if(property != null) property.setParentMetaBean(this);
    /** the metabean of the target bean (mainly for relationships) */

  /**
   * the metabean that owns this property (set by MetaBean.putProperty())
   */
                        metaProperty = createMetaProperty(field.getName(), field.getType());
                        metabean.putProperty(metaProperty.getName(), metaProperty);
                                  createMetaProperty(propName, method.getReturnType());
                            metabean.putProperty(propName, metaProperty);
                    metaProperty = createMetaProperty(
                      createMetaProperty(access.getPropertyName(), access.getJavaType());
    private MetaProperty createMetaProperty(String propName, Type type) {
        final ConstraintValidationListener result = (ConstraintValidationListener) vcontext.getListener();
                // Spec 3.4.3 - Stop validation if errors already found
                if ( !result.isEmpty() ) {
                    break;
                }
                        metaProperty = addMetaProperty(metabean, field.getName(), field.getType());
                                  addMetaProperty(metabean, propName, method.getReturnType());
                    metaProperty = addMetaProperty(metabean,
                      addMetaProperty(metabean, access.getPropertyName(), access.getJavaType());
    private MetaProperty addMetaProperty(MetaBean parentMetaBean, String propName, Type type) {
        parentMetaBean.putProperty(propName, metaProperty);
//import com.thoughtworks.xstream.converters.ConversionException;
            throw new RuntimeException("Only enum types supported in this version!");
            throw new RuntimeException("Null values not supported in this version!");
            throw new RuntimeException("Only java.lang.String values supported in this version!");
import javax.validation.GroupDefinitionException;
            throw new GroupDefinitionException("Cyclic dependency in groups definition");
 b/bval-optional/src/main/java/org/apache/bval/optional/json/JSONGenerator.java
package org.apache.bval.optional.json;
 *
 * This is an optional module which requires the freemarker dependency
 * and template resourece file "bean-infos-json.ftl" with it.
 b/bval-json/src/main/java/org/apache/bval/json/JSONGenerator.java
package org.apache.bval.json;
                }
                else if ( hasValidationConstraintsDefined(method) ) {
                    throw new ValidationException("Property "  method.getName()  " does not follow javabean conventions.");
                }
    
    private boolean hasValidationConstraintsDefined(Method method) {
        boolean ret = false;
        for ( Annotation annot : method.getDeclaredAnnotations() ) {
            if ( true == (ret = hasValidationConstraintsDefined(annot)) ) {
                break;
            }
        }
        
        return ret;
    }
    
    private boolean hasValidationConstraintsDefined(Annotation annot) {
        // If it is annotated with @Constraint
        if ( annot.annotationType().getAnnotation(Constraint.class) != null ) {
            return true;
        }
        boolean ret = false;
        
        // Check in case it is a multivalued constraint
        Object value = null;
        try {
            value = SecureActions.getAnnotationValue(annot, ANNOTATION_VALUE);
        } catch (IllegalAccessException e) {
            // Swallow it
        } catch (InvocationTargetException e) {
            // Swallow it
        }
        
        if ( value instanceof Annotation[] ) {
            for (Annotation annot2 : (Annotation[])value ) {
                if ( true == (ret = hasValidationConstraintsDefined(annot2)) ) {
                    break;
                }
            }
        }
        
        return ret;
    }
import javax.validation.ValidationException;
import javax.validation.metadata.BeanDescriptor;
import org.apache.bval.jsr303.Jsr303Features;
    
    @Override
    public BeanDescriptor getConstraintsForClass(Class<?> clazz) {
        // TODO: Cache this MetaBean
        MetaBean uncachedStubmetaBean = new MetaBean();
        uncachedStubmetaBean.setBeanClass(clazz);
        BeanDescriptorImpl edesc = createBeanDescriptor(uncachedStubmetaBean);
        return edesc;
    }


  private static final Log log = LogFactory.getLog(MetaBeanBuilder.class);
  /**
   * here you can install different kinds of factories to create MetaBeans from
   */
  private MetaBeanFactory[] factories;
  private XMLMetaBeanFactory xmlFactory;
  public MetaBeanBuilder() {
    this(new MetaBeanFactory[]{new IntrospectorMetaBeanFactory(),
        new XMLMetaBeanFactory()});
  }

  public MetaBeanBuilder(MetaBeanFactory[] factories) {
    setFactories(factories);
  }

  public MetaBeanFactory[] getFactories() {
    return factories;
  }

  public void setFactories(MetaBeanFactory[] factories) {
    this.factories = factories;
    updateXmlFactory();
  }

  private void updateXmlFactory() {
    for (MetaBeanFactory each : factories) {
      if (each instanceof XMLMetaBeanFactory) { // use the first one!
        xmlFactory = (XMLMetaBeanFactory) each;
        return;
      }
    xmlFactory = null; // none
  }
  public XMLMetaBeanFactory getXmlFactory() {
    return xmlFactory;
  }
    */

  /**
   * convenience method
   *//*
  public void addLoader(XMLMetaBeanLoader loader) {
    assertXmlFactory();
    xmlFactory.addLoader(loader);
  }
  public Map<String, MetaBean> buildAll() throws Exception {
    final Map<String, MetaBean> all = new HashMap<String, MetaBean>();
    if (xmlFactory != null) {
      xmlFactory.visitXMLBeanMeta(null, new XMLMetaBeanFactory.Visitor() {
        public void visit(XMLMetaBean empty, XMLMetaBeanInfos xmlInfos)
            throws Exception {
          if (xmlInfos.getBeans() == null) return; // empty file, ignore
          XMLMetaBeanFactory.XMLResult carrier =
              new XMLMetaBeanFactory.XMLResult(null, xmlInfos);
          for (XMLMetaBean xmlMeta : xmlInfos.getBeans()) {
            MetaBean meta = all.get(xmlMeta.getId());
            if (meta == null) {
              meta = createMetaBean(xmlMeta);
              all.put(xmlMeta.getId(), meta);
            carrier.xmlMeta = xmlMeta;
            xmlFactory.enrichMetaBean(meta, carrier);
          }

        public MetaBean getMetaBean() {
          return null;  // do nothing
        }
      });
    }
    return all;
  }

  public Map<String, MetaBean> enrichCopies(Map<String, MetaBean> all,
                                            XMLMetaBeanInfos... infosArray)
      throws Exception {
    assertXmlFactory();
    final Map<String, MetaBean> copies = new HashMap<String, MetaBean>(all.size());
    boolean nothing = true;
    XMLMetaBeanFactory.XMLResult carrier = new XMLMetaBeanFactory.XMLResult();
    for (XMLMetaBeanInfos xmlMetaBeanInfos : infosArray) {
      carrier.xmlInfos = xmlMetaBeanInfos;
      if (xmlMetaBeanInfos == null) continue;
      try {
        for (XMLMetaBean xmlMeta : xmlMetaBeanInfos.getBeans()) {
          nothing = false;
          MetaBean copy = copies.get(xmlMeta.getId());
          if (copy == null) { // ist noch nicht kopiert
            MetaBean meta = all.get(xmlMeta.getId());
            if (meta == null) { // gibt es nicht
              copy = createMetaBean(xmlMeta);
            } else { // gibt es, jetzt kopieren
              copy = meta.copy();
            copies.put(xmlMeta.getId(), copy);
          }
          carrier.xmlMeta = xmlMeta;
          xmlFactory.enrichMetaBean(copy, carrier);
      } catch (IOException e) {
        xmlFactory.handleLoadException(xmlMetaBeanInfos, e);
      }
    if (nothing) return all;
    for (Map.Entry<String, MetaBean> entry : all.entrySet()) {
      /*
      * alle unveraenderten werden AUCH KOPIERT (nur zwar nur, wegen
      * potentieller CrossReferenzen durch Relationships)
      */
      if (!copies.containsKey(entry.getKey())) {
        if (entry.getValue().hasRelationships()) {
          copies.put(entry.getKey(), (MetaBean) entry.getValue().copy());
        } else { // no relationship: do not clone()
          copies.put(entry.getKey(), entry.getValue());
      }
    return copies;
  }
  private void assertXmlFactory() {
    if (xmlFactory == null) {
      throw new IllegalStateException("no xmlFactory available");
  }
  public MetaBean buildForId(String beanInfoId) throws Exception {
    final XMLMetaBeanFactory.Visitor v;
    assertXmlFactory();
    xmlFactory.visitXMLBeanMeta(beanInfoId, v = new XMLMetaBeanFactory.Visitor() {
      private MetaBean meta;
      public MetaBean getMetaBean() {
      }

      public void visit(XMLMetaBean xmlMeta, XMLMetaBeanInfos xmlInfos)
          throws Exception {
        if (meta == null) {
          meta = createMetaBean(xmlMeta);
        }
        xmlFactory.enrichMetaBean(meta,
            new XMLMetaBeanFactory.XMLResult(xmlMeta, xmlInfos));
      }


    });
    if (v.getMetaBean() == null) {
      throw new IllegalArgumentException("MetaBean "  beanInfoId  " not found");
    return v.getMetaBean();
  }

  private MetaBean createMetaBean(XMLMetaBean xmlMeta) throws Exception {
    return buildForClass(findLocalClass(xmlMeta.getImpl()));
  }

  protected Class<?> findLocalClass(String className) {
    if (className != null) {
      try {
        return ClassUtils.getClass(className);
      } catch (ClassNotFoundException e) {
        log.warn("class not found: "  className, e);
      }
    }
    return null;
  }

  public MetaBean buildForClass(Class<?> clazz) throws Exception {
    MetaBean meta = new MetaBean();
    if (clazz != null) { // local class here?
      meta.setBeanClass(clazz);
      meta.setId(clazz.getName()); // default id = full class name!
    }
    for (MetaBeanFactory factory : factories) {
      factory.buildMetaBean(meta);
    }
    return meta;
  }
    public ApacheValidatorFactory getFactory() {
    protected boolean hasValidationConstraintsDefined(Method method) {
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.MetaBeanManager;
import org.apache.bval.jsr303.*;
import javax.validation.ConstraintViolation;
import javax.validation.metadata.ConstraintDescriptor;
  public MethodValidatorImpl(ApacheFactoryContext factoryContext) {
    super(factoryContext);
    patchFactoryContextForMethodValidation(factoryContext);
  }
  /**
   * experimental: replace the Jsr303MetaBeanFactory with a MethodValidatorMetaBeanFactory in the factoryContext.
   */
  private void patchFactoryContextForMethodValidation(ApacheFactoryContext factoryContext) {
    MetaBeanFactory[] factories = ((MetaBeanManager) getMetaBeanFinder()).getBuilder().getFactories();
    for(int i=0;i<factories.length;i) {
      if(factories[i] instanceof Jsr303MetaBeanFactory && !(factories[i] instanceof MethodValidatorMetaBeanFactory)) {
        factories[i] = new MethodValidatorMetaBeanFactory(factoryContext);
      }
  }
  @Override
  protected BeanDescriptorImpl createBeanDescriptor(MetaBean metaBean) {
    MethodBeanDescriptorImpl descriptor = new MethodBeanDescriptorImpl(factoryContext,
        metaBean, metaBean.getValidations());
    MethodValidatorMetaBeanFactory factory =
        new MethodValidatorMetaBeanFactory(factoryContext);
    factory.buildMethodDescriptor(descriptor);
    return descriptor;
  }
  /**
   * enhancement: method-level-validation not yet completly implemented
   * <pre>example:
   * <code>
   * public @NotNull String saveItem(@Valid @NotNull Item item, @Max(23) BigDecimal
   * </code></pre>
   * spec:
   * The constraints declarations evaluated are the constraints hosted on the
   * parameters of the method or constructor. If @Valid is placed on a parameter,
   * constraints declared on the object itself are considered.
   *
   * @throws IllegalArgumentException enhancement: if the method does not belong to <code>T</code>
   *                                  or if the Object[] does not match the method signature
   */
  public <T> Set<ConstraintViolation<T>> validateParameters(Class<T> clazz, Method method,
                                                            Object[] parameters,
                                                            Class<?>... groupArray) {
    MethodBeanDescriptorImpl beanDesc =
        (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
    MethodDescriptorImpl methodDescriptor =
        (MethodDescriptorImpl) beanDesc.getConstraintsForMethod(method);
    return validateParameters(methodDescriptor.getMetaBean(),
        methodDescriptor.getParameterDescriptors(), parameters, groupArray);
  }
  public <T> Set<ConstraintViolation<T>> validateParameter(Class<T> clazz, Method method,
                                                           Object parameter,
                                                           int parameterIndex,
                                                           Class<?>... groupArray) {
    MethodBeanDescriptorImpl beanDesc =
        (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
    MethodDescriptorImpl methodDescriptor =
        (MethodDescriptorImpl) beanDesc.getConstraintsForMethod(method);
    ParameterDescriptorImpl paramDesc = (ParameterDescriptorImpl) methodDescriptor
        .getParameterDescriptors().get(parameterIndex);
    return validateParameter(paramDesc, parameter, groupArray);
  }
  public <T> Set<ConstraintViolation<T>> validateParameters(Class<T> clazz,
                                                            Constructor<T> constructor,
                                                            Object[] parameters,
                                                            Class<?>... groupArray) {
    MethodBeanDescriptorImpl beanDesc =
        (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
    ConstructorDescriptorImpl constructorDescriptor =
        (ConstructorDescriptorImpl) beanDesc.getConstraintsForConstructor(constructor);
    return validateParameters(constructorDescriptor.getMetaBean(),
        constructorDescriptor.getParameterDescriptors(), parameters, groupArray);
  }
  public <T> Set<ConstraintViolation<T>> validateParameter(Class<T> clazz,
                                                           Constructor<T> constructor,
                                                           Object parameter,
                                                           int parameterIndex,
                                                           Class<?>... groupArray) {
    MethodBeanDescriptorImpl beanDesc =
        (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
    ConstructorDescriptorImpl methodDescriptor =
        (ConstructorDescriptorImpl) beanDesc.getConstraintsForConstructor(constructor);
    ParameterDescriptorImpl paramDesc = (ParameterDescriptorImpl) methodDescriptor
        .getParameterDescriptors().get(parameterIndex);
    return validateParameter(paramDesc, parameter, groupArray);
  }

  /**
   * If @Valid  is placed on the method, the constraints declared on the object
   * itself are considered.
   */
  public <T> Set<ConstraintViolation<T>> validateReturnedValue(Class<T> clazz, Method method,
                                                               Object returnedValue,
                                                               Class<?>... groupArray) {
    MethodBeanDescriptorImpl beanDesc =
        (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
    MethodDescriptorImpl methodDescriptor =
        (MethodDescriptorImpl) beanDesc.getConstraintsForMethod(method);
    final GroupValidationContext<ConstraintValidationListener<Object>> context =
        createContext(methodDescriptor.getMetaBean(), returnedValue, null, groupArray);
    validateReturnedValueInContext(context, methodDescriptor);
    ConstraintValidationListener result = context.getListener();
    return result.getConstaintViolations();
  }

  private <T> Set<ConstraintViolation<T>> validateParameters(MetaBean metaBean,
                                                             List<ParameterDescriptor> paramDescriptors,
                                                             Object[] parameters,
    if (parameters == null) throw new IllegalArgumentException("cannot validate null");
    if (parameters.length > 0) {
      try {
        GroupValidationContext<ConstraintValidationListener<Object[]>> context =
            createContext(metaBean, null, null, groupArray);
        for (int i = 0; i < parameters.length; i) {
          ParameterDescriptorImpl paramDesc =
              (ParameterDescriptorImpl) paramDescriptors.get(i);
          context.setBean(parameters[i]);
          validateParameterInContext(context, paramDesc);
        }
      } catch (RuntimeException ex) {
        throw unrecoverableValidationError(ex, parameters);
      }
    } else {
      return Collections.EMPTY_SET;
  }
  private <T> Set<ConstraintViolation<T>> validateParameter(
      ParameterDescriptorImpl paramDesc, Object parameter, Class<?>... groupArray) {
    try {
      final GroupValidationContext<ConstraintValidationListener<Object>> context =
          createContext(paramDesc.getMetaBean(), parameter, null, groupArray);
      final ConstraintValidationListener result = context.getListener();
      validateParameterInContext(context, paramDesc);
      return result.getConstaintViolations();
    } catch (RuntimeException ex) {
      throw unrecoverableValidationError(ex, parameter);
  }
  /**
   * validate constraints hosted on parameters of a method
   */
  private <T> void validateParameterInContext(
      GroupValidationContext<ConstraintValidationListener<T>> context,
      ParameterDescriptorImpl paramDesc) {

    final Groups groups = context.getGroups();

    for (ConstraintDescriptor consDesc : paramDesc.getConstraintDescriptors()) {
      ConstraintValidation validation = (ConstraintValidation) consDesc;
      // 1. process groups
      for (Group current : groups.getGroups()) {
        context.setCurrentGroup(current);
        validation.validate(context);
      }
      // 2. process sequences
      for (List<Group> eachSeq : groups.getSequences()) {
        for (Group current : eachSeq) {
          context.setCurrentGroup(current);
          validation.validate(context);
          /**
           * if one of the group process in the sequence leads to one or more validation failure,
           * the groups following in the sequence must not be processed
           */
          if (!context.getListener().isEmpty()) break;
      }
    if (paramDesc.isCascaded() && context.getValidatedValue() != null) {
      context.setMetaBean(factoryContext.getMetaBeanFinder().
          findForClass(context.getValidatedValue().getClass()));
      // 1. process groups
      for (Group current : groups.getGroups()) {
        context.setCurrentGroup(current);
        validateContext(context);
      }
      // 2. process sequences
      for (List<Group> eachSeq : groups.getSequences()) {
        for (Group current : eachSeq) {
          context.setCurrentGroup(current);
          validateContext(context);
          /**
           * if one of the group process in the sequence leads to one or more validation failure,
           * the groups following in the sequence must not be processed
           */
          if (!context.getListener().isEmpty()) break;
      }
  }
  /**
   * validate constraints hosted on parameters of a method
   */
  private <T> void validateReturnedValueInContext(
      GroupValidationContext<ConstraintValidationListener<T>> context,
      MethodDescriptorImpl methodDescriptor) {
    final Groups groups = context.getGroups();
    for (ConstraintDescriptor consDesc : methodDescriptor.getConstraintDescriptors()) {
      ConstraintValidation validation = (ConstraintValidation) consDesc;
      // 1. process groups
      for (Group current : groups.getGroups()) {
        context.setCurrentGroup(current);
        validation.validate(context);
      }
      // 2. process sequences
      for (List<Group> eachSeq : groups.getSequences()) {
        for (Group current : eachSeq) {
          context.setCurrentGroup(current);
          validation.validate(context);
          /**
           * if one of the group process in the sequence leads to one or more validation failure,
           * the groups following in the sequence must not be processed
           */
          if (!context.getListener().isEmpty()) break;
      }
    if (methodDescriptor.isCascaded() && context.getValidatedValue() != null) {
      context.setMetaBean(factoryContext.getMetaBeanFinder().
          findForClass(context.getValidatedValue().getClass()));
      // 1. process groups
      for (Group current : groups.getGroups()) {
        context.setCurrentGroup(current);
        validateContext(context);
      }
      // 2. process sequences
      for (List<Group> eachSeq : groups.getSequences()) {
        for (Group current : eachSeq) {
          context.setCurrentGroup(current);
          validateContext(context);
          /**
           * if one of the group process in the sequence leads to one or more validation failure,
           * the groups following in the sequence must not be processed
           */
          if (!context.getListener().isEmpty()) break;
        }
      }
    }
  }
  public MethodValidatorMetaBeanFactory(ApacheFactoryContext factoryContext) {
    super(factoryContext);
  }
  @Override
  protected boolean hasValidationConstraintsDefined(Method method) {
    return false;
  }

  public void buildMethodDescriptor(MethodBeanDescriptorImpl descriptor) {
    try {
      buildMethodConstraints(descriptor);
      buildConstructorConstraints(descriptor);
    } catch (Exception e) {
      throw new IllegalArgumentException(e.getMessage(), e);
    }
  }

  private void buildConstructorConstraints(MethodBeanDescriptorImpl beanDesc)
      throws InvocationTargetException, IllegalAccessException {
    beanDesc.setConstructorConstraints(new HashMap<Constructor<?>, ConstructorDescriptor>());

    for (Constructor<?> cons : beanDesc.getMetaBean().getBeanClass()
        .getDeclaredConstructors()) {
      if (!factoryContext.getFactory().getAnnotationIgnores()
          .isIgnoreAnnotations(cons)) {

        ConstructorDescriptorImpl consDesc =
            new ConstructorDescriptorImpl(beanDesc.getMetaBean(), new Validation[0]);
        beanDesc.putConstructorDescriptor(cons, consDesc);

        Annotation[][] paramsAnnos = cons.getParameterAnnotations();
        int idx = 0;
        for (Annotation[] paramAnnos : paramsAnnos) {
          ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
          processAnnotations(consDesc, paramAnnos, access, idx);
          idx;
      }
  }
  private void buildMethodConstraints(MethodBeanDescriptorImpl beanDesc)
      throws InvocationTargetException, IllegalAccessException {
    beanDesc.setMethodConstraints(new HashMap<Method, MethodDescriptor>());
    for (Method method : beanDesc.getMetaBean().getBeanClass().getDeclaredMethods()) {
      if (!factoryContext.getFactory().getAnnotationIgnores()
          .isIgnoreAnnotations(method)) {
        MethodDescriptorImpl methodDesc = new MethodDescriptorImpl(
            beanDesc.getMetaBean(), new Validation[0]);
        beanDesc.putMethodDescriptor(method, methodDesc);
        // return value validations
        ReturnAccess returnAccess = new ReturnAccess(method.getReturnType());
        for (Annotation anno : method.getAnnotations()) {
          processAnnotation(anno, methodDesc, returnAccess, validations);
        methodDesc.getConstraintDescriptors().addAll(validations.getValidations());
        // parameter validations
        Annotation[][] paramsAnnos = method.getParameterAnnotations();
        int idx = 0;
        for (Annotation[] paramAnnos : paramsAnnos) {
          ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
          processAnnotations(methodDesc, paramAnnos, access, idx);
          idx;
      }
  }

  private void processAnnotations(ProcedureDescriptor methodDesc, Annotation[] paramAnnos,
                                  AccessStrategy access, int idx)
      throws InvocationTargetException, IllegalAccessException {
    AppendValidationToList validations = new AppendValidationToList();
    for (Annotation anno : paramAnnos) {
      processAnnotation(anno, methodDesc, access, validations);
    }
    ParameterDescriptorImpl paramDesc = new ParameterDescriptorImpl(
        methodDesc.getMetaBean(), validations.getValidations().toArray(
            new Validation[validations.getValidations().size()]));
    paramDesc.setIndex(idx);
    methodDesc.getParameterDescriptors().add(paramDesc);
  }

  private void processAnnotation(Annotation annotation, ProcedureDescriptor desc,
                                 AccessStrategy access, AppendValidation validations)
      throws InvocationTargetException, IllegalAccessException {

    if (annotation instanceof Valid) {
      desc.setCascaded(true);
    } else {
      Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
      if (vcAnno != null) {
        Class<? extends ConstraintValidator<?, ?>>[] validatorClasses;
        validatorClasses = findConstraintValidatorClasses(annotation, vcAnno);
        applyConstraint(annotation, validatorClasses, null,
            desc.getMetaBean().getBeanClass(), access, validations);
      } else {
        /**
         * Multi-valued constraints
         */
        Object result = SecureActions.getAnnotationValue(annotation, ANNOTATION_VALUE);
        if (result != null && result instanceof Annotation[]) {
          for (Annotation each : (Annotation[]) result) {
            processAnnotation(each, desc, access, validations); // recursion
          }
        }
      }
    }
  }
        this.attributes.put("payload", payload.toArray(new Class[payload.size()]));
import java.util.Map;
    protected Map validatedObjects;
        this(listener, new IdentityHashMap());
    }

    protected BeanValidationContext(T listener, Map validatedMap) {
        this.validatedObjects = validatedMap;
    protected <VL extends ValidationListener> void validateBeanInContext(ValidationContext<VL> context) {
    protected <VL extends ValidationListener> void validateArrayInContext(ValidationContext<VL> context) {
    protected <VL extends ValidationListener> void validateIteratableInContext(ValidationContext<VL> context) {
    protected <VL extends ValidationListener> void validateNonPositionalIteratableInContext(ValidationContext<VL> context) {
    protected <VL extends ValidationListener> void validateMapInContext(ValidationContext<VL> context) {
    protected <VL extends ValidationListener> void validateRelatedBean(ValidationContext<VL> context, MetaProperty prop) {
import org.apache.bval.jsr303.util.ClassHelper;
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.PropertyAccess;
import javax.validation.groups.Default;
import java.util.ArrayList;
import java.util.Map;
                validateBeanNet(context);
                    validateBeanNet(context);
    /**
     * Validates a bean and all its cascaded related beans for the currently
     * defined group.
     * 
     * Special code is present to manage the {@link Default} group.
     * 
     * TODO: More descriptive name and don't override method from BeanValidator.
     * 
     * @param ValidationContext
     *            The current context of this validation call.
     */
    protected void validateBeanNet(ValidationContext vcontext) {
        
        GroupValidationContext<?> context = (GroupValidationContext<?>)vcontext;
        
        // If reached a cascaded bean which is null
        if ( context.getBean() == null ) {
            return;
        }
        
        // If reached a cascaded bean which has already been validated for the current group
        if ( !context.collectValidated() ) {
            return;
        }
        
        
        // ### First, validate the bean
        
        // Default is a special case
        if ( context.getCurrentGroup().isDefault() ) {
            
            List<Group> defaultGroups = expandDefaultGroup(context);
            final ConstraintValidationListener result = (ConstraintValidationListener) context.getListener();
            
            // If the rootBean defines a GroupSequence
            if ( defaultGroups.size() > 1 ) {
                
                int numViolations = result.violationsSize();
                
                // Validate the bean for each group in the sequence
                Group currentGroup = context.getCurrentGroup();
                for (Group each : defaultGroups) {
                    context.setCurrentGroup(each);
                    super.validateBean(context);
                    // Spec 3.4.3 - Stop validation if errors already found
                    if ( result.violationsSize() > numViolations ) {
                        break;
                    }
                context.setCurrentGroup(currentGroup);
            else {
                
                // For each class in the hierarchy of classes of rootBean,
                // validate the constraints defined in that class according
                // to the GroupSequence defined in the same class
                
                // Obtain the full class hierarchy
                List<Class<?>> classHierarchy = new ArrayList<Class<?>>();
                ClassHelper.fillFullClassHierarchyAsList(classHierarchy, context.getMetaBean().getBeanClass());
                Class<?> initialOwner = context.getCurrentOwner();
                
                // For each owner in the hierarchy
                for ( Class<?> owner : classHierarchy ) {
                    context.setCurrentOwner(owner);
                    
                    int numViolations = result.violationsSize();
                    
                    // Obtain the group sequence of the owner, and use it for the constraints that belong to it
                    List<Group> ownerDefaultGroups = context.getMetaBean().getFeature("{GroupSequence:"owner.getCanonicalName()"}");
                    for (Group each : ownerDefaultGroups) {
                        context.setCurrentGroup(each);
                        super.validateBean(context);
                        // Spec 3.4.3 - Stop validation if errors already found
                        if ( result.violationsSize() > numViolations ) {
                            break;
                        }
                    }
                    
                }
                context.setCurrentOwner(initialOwner);
                context.setCurrentGroup(Group.DEFAULT);
                
            }
            
        }
        // if not the default group, proceed as normal
        else {
            super.validateBean(context);
        }
        
        
        // ### Then, the cascaded beans (@Valid)
        for (MetaProperty prop : context.getMetaBean().getProperties()) {
            validateCascadedBean(context, prop);
        }
         
    }

    /**
     * TODO: Currently, almost the same code as super.validateRelatedBean, but
     * as it is being called at a different time, I have explicitly added the
     * code here with a different method name.
     * 
     * @param context
     *            The current context
     * @param prop
     *            The property to cascade from (in case it is possible).
     */
    private void validateCascadedBean(GroupValidationContext<?> context, MetaProperty prop) {
        AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
        if (access == null && prop.getMetaBean() != null) { // single property access strategy
            // save old values from context
            final Object bean = context.getBean();
            final MetaBean mbean = context.getMetaBean();
            // modify context state for relationship-target bean
            context.moveDown(prop, new PropertyAccess(bean.getClass(), prop.getName()));
            followCascadedConstraint(context);
            // restore old values in context
            context.moveUp(bean, mbean);
        } else if (access != null) { // different accesses to relation
            // save old values from context
            final Object bean = context.getBean();
            final MetaBean mbean = context.getMetaBean();
            for (AccessStrategy each : access) {
                // modify context state for relationship-target bean
                context.moveDown(prop, each);
                // Now, if the related bean is an instance of Map/Array/etc, 
                followCascadedConstraint(context);
                // restore old values in context
                context.moveUp(bean, mbean);
            }
    
    
    /**
     * TODO: Currently almost the same code as super.validateContext, but as it
     * is being called at a different time, I have explicitly added the code
     * here with a different method name.
     * 
     * Methods defined in {@link BeanValidator} take care of setting the path
     * and current bean correctly and call
     * {@link #validateBeanNet(ValidationContext)} for each individual bean.
     * 
     * @param context
     *            The current validation context.
     */
    private void followCascadedConstraint(GroupValidationContext<?> context) {
        if ( context.getBean() != null ) {
            if (context.getBean() instanceof Map<?, ?>) {
                validateMapInContext(context);
            } else if (context.getBean() instanceof List<?>) {
                validateIteratableInContext(context);
            } else if (context.getBean() instanceof Iterable<?>) {
                validateNonPositionalIteratableInContext(context);
            } else if (context.getBean() instanceof Object[]) {
                validateArrayInContext(context);
            } else { // to One Bean (or Map like Bean) 
                validateBeanInContext(context);
            }
        }
    }
    
    implements Validation, ConstraintDescriptor<T> {
  private static final String ANNOTATION_MESSAGE = "message";
  private final ConstraintValidator validator;
  private T annotation; // for metadata request API
  private final AccessStrategy access;
  private final boolean reportFromComposite;
  private final Map<String, Object> attributes;
  private Set<ConstraintValidation<?>> composedConstraints;
  /**
   * the owner is the type where the validation comes from.
   * it is used to support implicit grouping.
   */
  private final Class owner;
  private Set<Class<?>> groups;
  private Set<Class<? extends Payload>> payload;
  private Class<? extends ConstraintValidator<T, ?>>[] validatorClasses;

  /**
   * @param validator  - the constraint validator
   * @param annotation - the annotation of the constraint
   * @param owner      - the type where the annotated element is placed
   *                   (class, interface, annotation type)
   * @param access     - how to access the value
   */
  public ConstraintValidation(
      Class<? extends ConstraintValidator<T, ?>>[] validatorClasses,
      ConstraintValidator validator, T annotation, Class owner,
      AccessStrategy access, boolean reportFromComposite) {
    this.attributes = new HashMap();
    this.validatorClasses = validatorClasses;
    this.validator = validator;
    this.annotation = annotation;
    this.owner = owner;
    this.access = access;
    this.reportFromComposite = reportFromComposite;
  }

  public ConstraintDescriptor<T> asSerializableDescriptor() {
    return new ConstraintDescriptorImpl(this);
  }

  void setGroups(Set<Class<?>> groups) {
    this.groups = groups;
    this.attributes.put("groups", groups.toArray(new Class[groups.size()]));
  }

  void setPayload(Set<Class<? extends Payload>> payload) {
    this.payload = payload;
    this.attributes.put("payload", payload.toArray(new Class[payload.size()]));
  }

  public boolean isReportAsSingleViolation() {
    return reportFromComposite;
  }

  public void addComposed(ConstraintValidation aConstraintValidation) {
    if (composedConstraints == null) {
      composedConstraints = new HashSet();
    }
    composedConstraints.add(aConstraintValidation);
  }

  public void validate(ValidationContext context) {
    validate((GroupValidationContext) context);
  }

  public void validate(GroupValidationContext context) {
    context.setConstraintValidation(this);
     * execute unless the given validation constraint has already been processed
     * during this validation routine (as part of a previous group match)
    if (!isMemberOf(context.getCurrentGroup().getGroup())) {
      return; // do not validate in the current group
    }
    if (context.getCurrentOwner() != null && this.owner != context.getCurrentOwner()) {
      return;
    }
    if (validator != null && !context.collectValidated(validator))
      return; // already done
    if (context.getMetaProperty() != null && !isCascadeEnabled(context)) {
      return;
    // process composed constraints
    if (isReportAsSingleViolation()) {
      BeanValidationContext gctx = (BeanValidationContext) context;
      ConstraintValidationListener oldListener =
          ((ConstraintValidationListener) gctx.getListener());
      ConstraintValidationListener listener =
          new ConstraintValidationListener(oldListener.getRootBean(), oldListener.getRootBeanType());
      gctx.setListener(listener);
      try {
        for (ConstraintValidation composed : getComposingValidations()) {
          composed.validate(context);
      } finally {
        gctx.setListener(oldListener);
      }

      // Restore current constraint validation
      context.setConstraintValidation(this);

      // stop validating when already failed and ReportAsSingleInvalidConstraint = true ?
      if (!listener.getConstaintViolations().isEmpty()) {
        // TODO RSt - how should the composed constraint error report look like?
        ConstraintValidatorContextImpl jsrContext =
            new ConstraintValidatorContextImpl(context, this);
        addErrors(context, jsrContext); // add defaultErrorMessage only*/
        return;
      }
    } else {
      for (ConstraintValidation composed : getComposingValidations()) {
        composed.validate(context);
      }

      // Restore current constraint validation
      context.setConstraintValidation(this);
    if (validator != null) {
      ConstraintValidatorContextImpl jsrContext =
          new ConstraintValidatorContextImpl(context, this);
      if (!validator.isValid(context.getValidatedValue(), jsrContext)) {
        addErrors(context, jsrContext);
      }
    }
  }

  /**
   * Initialize the validator (if not <code>null</code>) with the stored
   * annotation.
   */
  public void initialize() {
    if (null != validator) {
      try {
        validator.initialize(annotation);
      } catch (RuntimeException e) {
        // Either a "legit" problem initializing the validator or a
        // ClassCastException if the validator associated annotation is
        // not a supertype of the validated annotation.
        throw new ConstraintDefinitionException(
            "Incorrect validator ["  validator.getClass().getCanonicalName()  "] for annotation " 
                annotation.annotationType().getCanonicalName(), e);
      }
    }
  }

  private boolean isCascadeEnabled(GroupValidationContext context) {
    PathImpl path = context.getPropertyPath();
    NodeImpl node = path.getLeafNode();
    PathImpl beanPath = path.getPathWithoutLeafNode();
    if (beanPath == null) {
      beanPath = PathImpl.create(null);
    }
    try {
      if (!context.getTraversableResolver()
          .isReachable(context.getBean(), node,
              context.getRootMetaBean().getBeanClass(), beanPath,
              access.getElementType())) return false;
    } catch (RuntimeException e) {
      throw new ValidationException(
          "Error in TraversableResolver.isReachable() for "  context.getBean(), e);
    try {
      if (!context.getTraversableResolver()
          .isCascadable(context.getBean(), node,
              context.getRootMetaBean().getBeanClass(), beanPath,
              access.getElementType())) return false;
    } catch (RuntimeException e) {
      throw new ValidationException(
          "Error TraversableResolver.isCascadable() for "  context.getBean(), e);
    return true;
  }

  private void addErrors(GroupValidationContext context,
                         ConstraintValidatorContextImpl jsrContext) {
    for (ValidationListener.Error each : jsrContext.getErrorMessages()) {
      context.getListener().addError(each, context);
  }
  public String toString() {
    return "ConstraintValidation{"  validator  '}';
  }
  public String getMessageTemplate() {
    return (String) attributes.get(ANNOTATION_MESSAGE);
  }
  public ConstraintValidator getValidator() {
    return validator;
  }

  protected boolean isMemberOf(Class<?> reqGroup) {
    return groups.contains(reqGroup);
  }

  public Class getOwner() {
    return owner;
  }

  public T getAnnotation() {
    return annotation;
  }

  public AccessStrategy getAccess() {
    return access;
  }

  public void setAnnotation(T annotation) {
    this.annotation = annotation;
  }

  /////////////////////////// ConstraintDescriptor implementation


  public Map<String, Object> getAttributes() {
    return attributes;
  }

  public Set<ConstraintDescriptor<?>> getComposingConstraints() {
    return composedConstraints == null ? Collections.EMPTY_SET : composedConstraints;
  }

  Set<ConstraintValidation<?>> getComposingValidations() {
    return composedConstraints == null ? Collections.EMPTY_SET : composedConstraints;
  }

  public Set<Class<?>> getGroups() {
    return groups;
  }

  public Set<Class<? extends Payload>> getPayload() {
    return payload;
  }

  public List<Class<? extends ConstraintValidator<T, ?>>> getConstraintValidatorClasses() {
    if (validatorClasses == null) {
      return Collections.emptyList();
    return Arrays.asList(validatorClasses);
  }
    
    public int violationsSize() {
        return constaintViolations.size();
    }
    
    Class<?> getCurrentOwner();
    
    void setCurrentOwner(Class<?> currentOwner);
  private Class<?> currentOwner;


    // inherited variable 'validatedObjects' is of type: HashMap<GraphBeanIdentity, Set<PathImpl>> in this class 
    super(listener, new HashMap<GraphBeanIdentity, Set<PathImpl>>());
   * <p/>
   * NOTE: No longer uses the inherited validatedObjects hashmap
    // Combination of beangroupowner (owner is currently ignored)
    GraphBeanIdentity gbi = new GraphBeanIdentity(getBean(), getCurrentGroup().getGroup(), getCurrentOwner());

    Set<PathImpl> validatedPathsForGBI = (Set<PathImpl>) validatedObjects.get(gbi);
    if (validatedPathsForGBI == null) {
      validatedPathsForGBI = new HashSet<PathImpl>();
      validatedObjects.put(gbi, validatedPathsForGBI);
    for (PathImpl validatedPath : validatedPathsForGBI) {
    validatedPathsForGBI.add(PathImpl.copy(path));


  public Class<?> getCurrentOwner() {
    return this.currentOwner;
  }

  public void setCurrentOwner(Class<?> currentOwner) {
    this.currentOwner = currentOwner;
  }
import org.apache.bval.jsr303.util.ClassHelper;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
            ClassHelper.fillFullClassHierarchyAsList(classSequence, beanClass);
                processGroupSequence(eachClass, metabean, "{GroupSequence:"eachClass.getCanonicalName()"}");
        processGroupSequence(beanClass, metabean, Jsr303Features.Bean.GROUP_SEQUENCE);
    }
    
    private void processGroupSequence(Class<?> beanClass, MetaBean metabean, String key) {
        List<Group> groupSeq = metabean.getFeature(key);
            metabean.putFeature(key, groupSeq);
            if ( validator == null ) {
                throw new ValidationException("Factory returned null validator for: "  validatorTypes.get(assignableTypes.get(0)));
            }
import org.apache.bval.jsr303.util.NodeImpl;
import org.apache.bval.jsr303.util.PathImpl;
//      TODO: Delete, never reached in JSR-303 validations
//        if (access == null && prop.getMetaBean() != null) { // single property access strategy
//            System.out.println("\n\n ### UNEXPECTED REACH ### \n\n");
//            // save old values from context
//            final Object bean = context.getBean();
//            final MetaBean mbean = context.getMetaBean();
//            // modify context state for relationship-target bean
//            context.moveDown(prop, new PropertyAccess(bean.getClass(), prop.getName()));
//            followCascadedConstraint(context);
//            // restore old values in context
//            context.moveUp(bean, mbean);
//        } else
        if (access != null) { // different accesses to relation
                if (isCascadable(context, prop, each)) {
                    // modify context state for relationship-target bean
                    context.moveDown(prop, each);
                    // Now, if the related bean is an instance of Map/Array/etc,
                    followCascadedConstraint(context);
                    // restore old values in context
                    context.moveUp(bean, mbean);
                }

    /**
     * Before accessing a related bean (marked with {@link Valid}), the
     * validator has to check if it is reachable and cascadable.
     * 
     * @param context
     *            The current validation context.
     * @param prop
     *            The property of the related bean.
     * @param access
     *            The access strategy used to get the related bean value.
     * @return <code>true</code> if the validator can access the related bean,
     *         <code>false</code> otherwise.
     */
    private boolean isCascadable(GroupValidationContext<?> context, MetaProperty prop, AccessStrategy access) {
        
        PathImpl beanPath = context.getPropertyPath();
        NodeImpl node = new NodeImpl(prop.getName());
        if (beanPath == null) {
            beanPath = PathImpl.create(null);
        }
        try {
            if (!context.getTraversableResolver().isReachable(
                    context.getBean(), node,
                    context.getRootMetaBean().getBeanClass(), beanPath,
                    access.getElementType()))
                return false;
        } catch (RuntimeException e) {
            throw new ValidationException("Error in TraversableResolver.isReachable() for "  context.getBean(), e);
        }

        try {
            if (!context.getTraversableResolver().isCascadable(
                    context.getBean(), node,
                    context.getRootMetaBean().getBeanClass(), beanPath,
                    access.getElementType()))
                return false;
        } catch (RuntimeException e) {
            throw new ValidationException("Error TraversableResolver.isCascadable() for "  context.getBean(), e);
        }

        return true;
    }
    if (context.getMetaProperty() != null && !isReachable(context)) {
  private boolean isReachable(GroupValidationContext context) {
        super(metaBean, metaBean.getBeanClass(), validations);
            edesc = new PropertyDescriptorImpl(
                      metaBean,
                      prop.getName(),
import java.util.Iterator;
import java.util.List;
            if ( group.isDefault() ) {
                // If group is default, check if it gets redefined
                List<Group> expandedDefaultGroup = metaBean.getFeature(Jsr303Features.Bean.GROUP_SEQUENCE);
                for ( Group defaultGroupMember : expandedDefaultGroup ) {
                    for (ConstraintValidation descriptor : constraintDescriptors) {
                        if (isInScope(descriptor) && isInGroup(descriptor, defaultGroupMember)) {
                            matchingDescriptors.add(descriptor);
                        }
                    }
                }
            }
            else {
                for (ConstraintValidation descriptor : constraintDescriptors) {
                    if (isInScope(descriptor) && isInGroup(descriptor, group)) {
                        matchingDescriptors.add(descriptor);
                    }
            for (Iterator<ConstraintValidation> it = constraintDescriptors.iterator(); it.hasNext(); ) {
                ConstraintValidation cv = it.next();
                if ( cv.getOwner() != metaBean.getBeanClass() ) {
                    it.remove();
                }
            }
    protected ElementDescriptorImpl(MetaBean metaBean, Class<?> elementClass, 
        this.elementClass = elementClass;
    PropertyDescriptorImpl(MetaBean metaBean, String propertyPath, Validation[] validations) {
        super(metaBean, metaBean.getProperty(propertyPath).getTypeClass(), validations);
        super(metaBean, metaBean.getBeanClass(), validations);
        super(metaBean, metaBean.getClass(), validations);
        super(metaBean, metaBean.getClass(), validations);
        InputStream inputStream = loader.getResourceAsStream( path );
        
        if ( inputStream != null ) {
            // spec says: If more than one META-INF/validation.xml file
            // is found in the classpath, a ValidationException is raised.
            if ( path.equals("META-INF/validation.xml") ) {
                Enumeration<URL> urls = loader.getResources(path);
                if ( urls.hasMoreElements() && (urls.nextElement() != null) && urls.hasMoreElements() ) {
                    throw new ValidationException("More than one "  path  " is found in the classpath");
                }
        
        return inputStream;
        for (JAXBElement<String> mappingFileNameElement : xmlConfig.getConstraintMapping()) {
            String mappingFileName = mappingFileNameElement.getValue();
            if ( mappingFileName.startsWith("/") ) {
                // Classloader needs a path without a starting /
                mappingFileName = mappingFileName.substring(1);
            }
                      "Trying to open input stream for "  mappingFileName);
                in = getInputStream(mappingFileName);
                                mappingFileName);
                      mappingFileName, e);
        
        // if NOT ignore class level annotations
              .isIgnoreAnnotations(beanClass)) { 
        }
        Field[] fields = beanClass.getDeclaredFields();
        for (Field field : fields) {
            MetaProperty metaProperty = metabean.getProperty(field.getName());
            // create a property for those fields for which there is not yet a MetaProperty
            if (!factoryContext.getFactory().getAnnotationIgnores()
                  .isIgnoreAnnotations(field)) {
                if (metaProperty == null) {
                    metaProperty = addMetaProperty(metabean, field.getName(), field.getType());
                    processAnnotations(metaProperty, beanClass, field,
                          new FieldAccess(field),
                          new AppendValidationToMeta(metaProperty));//) {
                } else {
                    processAnnotations(metaProperty, beanClass, field,
                          new FieldAccess(field),
                          new AppendValidationToMeta(metaProperty));
                }
            }
        }
        Method[] methods = beanClass.getDeclaredMethods();
        for (Method method : methods) {

            String propName = null;
            if (method.getParameterTypes().length == 0) {
                propName = MethodAccess.getPropertyName(method);
            }
            if (propName != null) {
                      .isIgnoreAnnotations(method)) {
                    MetaProperty metaProperty = metabean.getProperty(propName);
                    // create a property for those methods for which there is not yet a MetaProperty
                        metaProperty =
                              addMetaProperty(metabean, propName, method.getReturnType());
                        processAnnotations(metaProperty, beanClass, method,
                              new MethodAccess(propName, method),
                        processAnnotations(metaProperty, beanClass, method,
                              new MethodAccess(propName, method),
            else if ( hasValidationConstraintsDefined(method) ) {
                throw new ValidationException("Property "  method.getName()  " does not follow javabean conventions.");

        
        return converter.convert(returnType, value);
        if ( target.getMessageInterpolator() == null ) {
            if (messageInterpolatorClass != null) {
                Class<MessageInterpolator> clazz = (Class<MessageInterpolator>) SecureActions
                      .loadClass(messageInterpolatorClass, this.getClass());
                target.messageInterpolator(SecureActions.newInstance(clazz));
                if (log.isInfoEnabled())
                    log.info("Using "  messageInterpolatorClass  " as message interpolator.");
    
            }
        if ( target.getTraversableResolver() == null ) {
            if (traversableResolverClass != null) {
                Class<TraversableResolver> clazz = (Class<TraversableResolver>) SecureActions
                      .loadClass(traversableResolverClass, this.getClass());
                target.traversableResolver(SecureActions.newInstance(clazz));
                if (log.isInfoEnabled())
                    log.info("Using "  traversableResolverClass  " as traversable resolver.");
            }
        if ( target.getConstraintValidatorFactory() == null ) {
            if (constraintFactoryClass != null) {
                Class<ConstraintValidatorFactory> clazz =
                      (Class<ConstraintValidatorFactory>) SecureActions
                            .loadClass(constraintFactoryClass, this.getClass());
                target.constraintValidatorFactory(SecureActions.newInstance(clazz));
                if (log.isInfoEnabled())
                    log.info("Using "  constraintFactoryClass  " as constraint factory.");
            }
        // If no constraints and not cascaded, return null
        if ( prop.getValidations().length == 0 && prop.getFeature(Features.Property.REF_CASCADE) == null ) {
            return null;
        }
        
        // curly braces need to be scaped in the original msg, so unescape them now
        resolvedMessage = resolvedMessage.replace( "\\{", "{" ).replace( "\\}", "}" ).replace( "\\\\", "\\" );
        
        if (constraintClasses != null && constraintClasses.length > 0) {
        processAnnotations(prop, owner, annotation.annotationType(), access, new AppendValidationToBuilder(builder));
        
        // Even if the validator is null, it must be added to mimic the RI impl
        appender.append(builder.getConstraintValidation());
        return true;
 * Description: Create or enrich MetaBeans from apache beanInfos xml<br/>
 * the apache-validation framework.
 * Description: Uniquely identify apache Validation in the Bean Validation bootstrap
 * strategy. Also contains apache validation specific configurations<br/>
         * true/false. use apache metaBeans xml format additionally to
 * Description: used to configure apache-validation for jsr303.
 * Description: Adapter between Constraint (JSR303) and Validation (Core)<br/>
        log.trace("class not found: "  className, e);
}
import org.apache.commons.lang.ClassUtils;
          if (anno instanceof Valid) {
            methodDesc.setCascaded(true);
          } else {
            processAnnotation(anno, methodDesc, returnAccess, validations);
          }
    boolean cascaded = false;
      if (anno instanceof Valid) {
        cascaded = true;
      } else {
        processAnnotation(anno, methodDesc, access, validations);
      }
    paramDesc.setCascaded( cascaded );
            ClassUtils.primitiveToWrapper((Class)access.getJavaType()), access, validations);
import javax.validation.Valid;
    
    public void personOp1(@Valid Person p) {
        return;
    }
    
    public void personOp2(@NotNull @Valid Person p) {
        return;
    }
    
    public static class Person {
        @NotNull
        String name;
    }
    
    public MetaProperty clone() throws CloneNotSupportedException {
        return (MetaProperty) super.clone();
    }

import java.io.IOException;
        } catch (IOException ioe) {
                Method valueMethod;
                } catch (NoSuchMethodException ex) {
                    // do nothing
                    valueMethod = null;
                }

    @XStreamOmitField
    private static final long serialVersionUID = 1L;

    private transient Validation validation;
import java.lang.reflect.InvocationTargetException;
            } catch (IllegalAccessException iae) {
                // do nothing
            } catch (NoSuchMethodException nsme) {
                // do nothing
            } catch (InvocationTargetException ite) {

        if (garr == null || garr.length == 0) {
            garr = GroupsComputer.getDefaultGroupArray();
        }
    private static volatile ApacheValidatorFactory DEFAULT_FACTORY;
                prop.getFeature(Jsr303Features.Property.PropertyDescriptor);
            prop.getFeature(Features.Property.REF_BEAN_TYPE, prop.getTypeClass());
        DEFAULT_GROUPS = new GroupsComputer().computeGroups(
            Arrays.asList(getDefaultGroupArray()));
    }

    public static Class<?>[] getDefaultGroupArray() {
        return new Class<?>[]{Default.class};

        if (converter != null) {
            return converter.convert(returnType, value);
        } else {
            return converter;
        }
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import static org.apache.bval.model.Features.Property.*;
 * NOTE: THIS IS AN OPTIONAL CLASS, TO ENABLE IT, SET Factory Property apache.bval.enable-introspector="true"
 * Description: internal implementation class to construct 
 * metabeans with factories<br/>

    this(new MetaBeanFactory[]{new IntrospectorMetaBeanFactory()});
  public MetaBean buildForId(String beanInfoId) throws Exception {
    throw new IllegalArgumentException("MetaBean "  beanInfoId  " not found");

    return new HashMap<String, MetaBean>();
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import static org.apache.bval.model.Features.Property.*;
public class MetaBeanManager implements MetaBeanFinder {
    protected boolean complete = false;
    protected void computeRelationships(MetaBean beanInfo, Map<String, MetaBean> cached) {
import java.io.Serializable;
import java.util.*;

     * @param reason       - Features from {@link org.apache.bval.model.Features.Property}
     * @param reason       - Features from {@link org.apache.bval.model.Features.Property} or custom validation reason
import org.apache.bval.routines.EMailValidationUtils;

        return EMailValidationUtils.isValid(value);
import org.apache.bval.xml.XMLMetaBeanBuilder;
import org.apache.bval.xml.XMLMetaBeanManager;
     * @return a new instance of MetaBeanManager with adequate MetaBeanFactories
    protected MetaBeanManager buildMetaBeanManager() {
        // as long as we support both: jsr303 and xstream-xml metabeans:
          return createXMLMetaBeanManager(builders);
        } else {
          return createMetaBeanManager(builders);

  protected MetaBeanManager createMetaBeanManager(List<MetaBeanFactory> builders) {
    return new MetaBeanManager(
      new MetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
  }

  protected MetaBeanManager createXMLMetaBeanManager(List<MetaBeanFactory> builders) {
    builders.add(new XMLMetaBeanFactory());
    return new XMLMetaBeanManager(
        new XMLMetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
  }
         *
         * @deprecated we could decide to drop this feature in the future.
         * we keep it as long as we support both: jsr303 and xstream-xml meta data at
         * the same time (and potentially for the same domain classes)
 b/bval-xstream/src/main/java/org/apache/bval/routines/StandardValidation.java
import org.apache.bval.model.*;

 b/bval-xstream/src/main/java/org/apache/bval/xml/MetaBeanEnricher.java
package org.apache.bval.xml;

import java.util.Map;
 b/bval-xstream/src/main/java/org/apache/bval/xml/XMLFeaturesCapable.java
import org.apache.bval.model.FeaturesCapable;
 b/bval-xstream/src/main/java/org/apache/bval/xml/XMLMetaBeanInfos.java
 b/bval-xstream/src/main/java/org/apache/bval/xml/XMLMetaBeanReference.java
import org.apache.bval.model.MetaProperty;

import static org.apache.bval.model.Features.Property.REF_BEAN_ID;
 b/bval-xstream/src/main/java/org/apache/bval/xml/XMLMetaElement.java
import static org.apache.bval.model.Features.Property.*;

 b/bval-xstream/src/main/java/org/apache/bval/xml/XMLMetaProperty.java
import org.apache.bval.model.MetaProperty;

import static org.apache.bval.model.Features.Property.*;
 b/bval-xstream/src/main/java/org/apache/bval/xml/XMLMetaValidator.java
import org.apache.bval.model.Validation;
 b/bval-xstream/src/test/java/org/apache/bval/example/BusinessObjectBeanInfo.java
import org.apache.bval.model.Features;
     * @see org.apache.bval.MetaBeanManagerFactory#getFinder()
  protected final MetaBeanCache cache = new MetaBeanCache();
  protected final MetaBeanBuilder builder;
  protected boolean complete = false;
  public MetaBeanManager() {
    builder = new MetaBeanBuilder();
  }
  public MetaBeanManager(MetaBeanBuilder builder) {
    this.builder = builder;
  }
  public MetaBeanBuilder getBuilder() {
    return builder;
  }
  public MetaBeanCache getCache() {
    return cache;
  }
  public MetaBean findForId(String beanInfoId) {
    MetaBean beanInfo = cache.findForId(beanInfoId);
    if (beanInfo != null) return beanInfo;
    try {
      beanInfo = builder.buildForId(beanInfoId);
      cache.cache(beanInfo);
      computeRelationships(beanInfo);
      return beanInfo;
    } catch (RuntimeException e) {
      throw e; // do not wrap runtime exceptions
    } catch (Exception e) {
      throw new IllegalArgumentException(
          "error creating beanInfo with id: "  beanInfoId, e);
  }
  public MetaBean findForClass(Class<?> clazz) {
    if (clazz == null) return null;
    MetaBean beanInfo = cache.findForClass(clazz);
    if (beanInfo != null) return beanInfo;
    try {
      beanInfo = builder.buildForClass(clazz);
      cache.cache(beanInfo);
      computeRelationships(beanInfo);
      return beanInfo;
    } catch (RuntimeException e) {
      throw e; // do not wrap runtime exceptions
    } catch (Exception e) {
      throw new IllegalArgumentException("error creating beanInfo for "  clazz, e);
  }
  /**
   * must be called AFTER cache.cache()
   * to avoid endless loop
   *
   * @param beanInfo - the bean for which to compute relationships
   */
  protected void computeRelationships(MetaBean beanInfo) {
    for (MetaProperty prop : beanInfo.getProperties()) {
      String beanRef = (String) prop.getFeature(REF_BEAN_ID);
      computeRelatedMetaBean(prop, beanRef);
  }
  protected void computeRelatedMetaBean(MetaProperty prop, String beanRef) {
    Class<?> beanType = prop.getFeature(REF_BEAN_TYPE);
    if (beanType != null) {
      prop.setMetaBean(findForClass(beanType));
    } else if (prop.getFeature(REF_CASCADE) != null) { // dynamic type resolution:
      prop.setMetaBean(new DynamicMetaBean(this));
  }
     * @return the singleton
  private final ApacheValidatorFactory factory;
  private final MetaBeanFinder metaBeanFinder;
  private MessageInterpolator messageInterpolator;
  private TraversableResolver traversableResolver;
  private ConstraintValidatorFactory constraintValidatorFactory;
  public ApacheFactoryContext(ApacheValidatorFactory factory) {
    this.factory = factory;
    this.metaBeanFinder = buildMetaBeanManager();
  }

  protected ApacheFactoryContext(ApacheValidatorFactory factory,
                                 MetaBeanFinder metaBeanFinder) {
    this.factory = factory;
    this.metaBeanFinder = metaBeanFinder;
  }

  public ApacheValidatorFactory getFactory() {
    return factory;
  }

  public final MetaBeanFinder getMetaBeanFinder() {
    return metaBeanFinder;
  }

  public ValidatorContext messageInterpolator(MessageInterpolator messageInterpolator) {
    this.messageInterpolator = messageInterpolator;
    return this;
  }

  public ValidatorContext traversableResolver(TraversableResolver traversableResolver) {
    this.traversableResolver = traversableResolver;
    return this;
  }

  public ValidatorContext constraintValidatorFactory(
      ConstraintValidatorFactory constraintValidatorFactory) {
    this.constraintValidatorFactory = constraintValidatorFactory;
    return this;
  }

  public ConstraintValidatorFactory getConstraintValidatorFactory() {
    return constraintValidatorFactory == null ? factory.getConstraintValidatorFactory() :
        constraintValidatorFactory;
  }

  public Validator getValidator() {
    ClassValidator validator = new ClassValidator(this);
    if (Boolean.getBoolean(factory.getProperties().get(
        ApacheValidatorConfiguration.Properties.TREAT_MAPS_LIKE_BEANS))) {
      validator.setTreatMapsLikeBeans(true);
    return validator;
  }
  public MessageInterpolator getMessageInterpolator() {
    return messageInterpolator == null ? factory.getMessageInterpolator() :
        messageInterpolator;
  }
  public TraversableResolver getTraversableResolver() {
    return traversableResolver == null ? factory.getTraversableResolver() :
        traversableResolver;
  }
  /**
   * Create MetaBeanManager that
   * uses JSR303-XML  JSR303-Annotations
   * to build meta-data from.
   *
   * @return a new instance of MetaBeanManager with adequate MetaBeanFactories
   */
  protected MetaBeanManager buildMetaBeanManager() {
    // this is relevant: xml before annotations
    // (because ignore-annotations settings in xml)
    List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>(3);
    if (Boolean.parseBoolean(factory.getProperties().get(
        ApacheValidatorConfiguration.Properties.ENABLE_INTROSPECTOR))) {
      builders.add(new IntrospectorMetaBeanFactory());
    builders.add(new Jsr303MetaBeanFactory(this));
    // as long as we support both: jsr303 and xstream-xml metabeans:
    if (Boolean.parseBoolean(factory.getProperties().get(
        ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML))) {
      return XMLMetaBeanManagerCreator.createXMLMetaBeanManager(builders);
    } else {
      return createMetaBeanManager(builders);
  }
        new MetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
  /**
   * separate class to prevent the classloader to immediately load
   * optional classes: XMLMetaBeanManager, XMLMetaBeanFactory, XMLMetaBeanBuilder
   * that might not be available in the classpath
   */
  private static class XMLMetaBeanManagerCreator {

    protected static MetaBeanManager createXMLMetaBeanManager(List<MetaBeanFactory> builders) {
      builders.add(new XMLMetaBeanFactory());
      return new XMLMetaBeanManager(
          new XMLMetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
    }
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.model.MetaProperty;
import static org.apache.bval.model.Features.Property.REF_BEAN_ID;

public class XMLMetaBeanManager extends MetaBeanManager
    implements MetaBeanFinder, XMLMetaBeanRegistry, MetaBeanEnricher {
    ((XMLMetaBeanBuilder) builder).addLoader(loader);
      Map<String, MetaBean> patched = ((XMLMetaBeanBuilder) builder).enrichCopies(cached, infos);

  /**
   * 
   * @return all MetaBeans for classes that have a xml descriptor:
   *         key = bean.id, value = MetaBean
   */
  public Map<String, MetaBean> findAll() {
    if (!complete) {
      try {
        Map<String, MetaBean> allBuilt = builder.buildAll();
        for (MetaBean meta : allBuilt.values()) {
          MetaBean cached = cache.findForId(meta.getId());
          if (cached == null) {
            cache.cache(meta);
          }
        }
        Map<String, MetaBean> map = cache.findAll();
        for (Object oentry : map.values()) {
          MetaBean meta = (MetaBean) oentry;
          computeRelationships(meta, map);
        }
        complete = true;
        return map;
      } catch (RuntimeException e) {
        throw e; // do not wrap runtime exceptions
      } catch (Exception e) {
        throw new IllegalArgumentException("error creating beanInfos", e);
      }
    } else {
      return cache.findAll();
    }
  }

  protected void computeRelationships(MetaBean beanInfo, Map<String, MetaBean> cached) {
    for (MetaProperty prop : beanInfo.getProperties()) {
      String beanRef = (String) prop.getFeature(REF_BEAN_ID);
      if (beanRef != null) {
        prop.setMetaBean(cached.get(beanRef));
      }
    }
  }

  protected void computeRelatedMetaBean(MetaProperty prop, String beanRef) {
    if (beanRef != null) {
        prop.setMetaBean(findForId(beanRef));
    } else {
      super.computeRelatedMetaBean(prop, beanRef);
    }
  }
import org.apache.bval.model.Features;
            prop.putFeature(Features.Property.REF_BEAN_ID, getBeanId());
public class BeanValidator<T extends ValidationListener> extends AbstractBeanValidator {
  private final MetaBeanFinder metaBeanFinder;
  /**
   * convenience method. Use the global instance of MetaBeanManagerFactory.getFinder().
   */
  public BeanValidator() {
    this(MetaBeanManagerFactory.getFinder());
  }

  public BeanValidator(MetaBeanFinder metaBeanFinder) {
    this.metaBeanFinder = metaBeanFinder;
  }


  /**
   * convenience API. validate a root object with all related objects
   * with its default metaBean definition.
   *
   * @return results - validation results found
   */
  public T validate(Object bean) {
    MetaBean metaBean =
        getMetaBeanFinder().findForClass(bean.getClass());
    return validate(bean, metaBean);
  }

  /**
   * convenience API. validate a root object with all related objects
   * according to the metaBean.
   *
   * @param bean - a single bean or a collection of beans (that share the same metaBean!)
   * @return results - validation results found
   */
  public T validate(Object bean, MetaBean metaBean) {
    ValidationContext<T> context = createContext();
    context.setBean(bean, metaBean);
    validateContext(context);
    return context.getListener();
  }

  /**
   * validate the method parameters based on @Validate annotations.
   * Requirements:
   * Parameter, that are to be validated must be annotated with @Validate
   *
   * @param method     -  a method
   * @param parameters - the parameters suitable to the method
   * @return a validation result or null when there was nothing to validate
   * @see Validate
   */
  public T validateCall(Method method, Object[] parameters) {
    if (parameters.length > 0) {
      // shortcut (for performance!)
      Annotation[][] annotations = method.getParameterAnnotations();
      ValidationContext<T> context = null;
      for (int i = 0; i < parameters.length; i) {
        for (Annotation anno : annotations[i]) {
          if (anno instanceof Validate) {
            if (context == null) context = createContext();
            if (determineMetaBean((Validate) anno, parameters[i], context)) {
              validateContext(context);
              break; // next parameter
            }
          }
        }
      }
      return context != null ? context.getListener() : null;
    return null;
  }
  /**
   * @return true when validation should happen, false to skip it
   */
  protected <VL extends ValidationListener> boolean determineMetaBean(Validate validate, Object parameter,
                                                                      ValidationContext<VL> context) {
    if (validate.value().length() == 0) {
      if (parameter == null) return false;
      Class<?> beanClass;
      if (parameter instanceof Collection<?>) {   // do not validate empty collection
        Collection<?> coll = ((Collection<?>) parameter);
        if (coll.isEmpty()) return false;
        beanClass = coll.iterator().next().getClass(); // get first object
      } else if (parameter.getClass().isArray()) {
        beanClass = parameter.getClass().getComponentType();
      } else {
        beanClass = parameter.getClass();
      }
      context.setBean(parameter, getMetaBeanFinder().findForClass(beanClass));
    } else {
      context.setBean(parameter, getMetaBeanFinder().findForId(validate.value()));
    return true;
  }
  /**
   * factory method -
   * overwrite in subclasses
   */
  protected T createResults() {
    return (T) new ValidationResults();
  }

  /**
   * factory method -
   * overwrite in subclasses
   */
  protected ValidationContext<T> createContext() {
    return new BeanValidationContext<T>(createResults());
  }

  /**
   * convenience API. validate a single property.
   *
   * @param bean         - the root object
   * @param metaProperty - metadata for the property
   * @return validation results
   */
  public T validateProperty(Object bean, MetaProperty metaProperty) {
    ValidationContext<T> context = createContext();
    context.setBean(bean);
    context.setMetaProperty(metaProperty);
    validateProperty(context);
    return context.getListener();
  }

  /**
   * internal validate a bean (=not a collection of beans) and its related beans
   */
  protected <VL extends ValidationListener> void validateBeanNet(ValidationContext<VL> context) {
    if (context.collectValidated()) {
      validateBean(context);
      for (MetaProperty prop : context.getMetaBean().getProperties()) {
        validateRelatedBean(context, prop);
      }
  }
  protected <VL extends ValidationListener> void validateRelatedBean(ValidationContext<VL> context, MetaProperty prop) {
    AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
    if (access == null && prop.getMetaBean() != null) { // single property access strategy
      // save old values from context
      final Object bean = context.getBean();
      final MetaBean mbean = context.getMetaBean();
      // modify context state for relationship-target bean
      context.moveDown(prop, new PropertyAccess(bean.getClass(), prop.getName()));
      validateContext(context);
      // restore old values in context
      context.moveUp(bean, mbean);
    } else if (access != null) { // different accesses to relation
      // save old values from context
      final Object bean = context.getBean();
      final MetaBean mbean = context.getMetaBean();
      for (AccessStrategy each : access) {
        // modify context state for relationship-target bean
        context.moveDown(prop, each);
        // restore old values in context
        context.moveUp(bean, mbean);
      }
  }
  /**
   * the metabean finder associated with this validator.
   *
   * @return a MetaBeanFinder
   * @see org.apache.bval.MetaBeanManagerFactory#getFinder()
   */
  public MetaBeanFinder getMetaBeanFinder() {
    return metaBeanFinder;
  }
         * default: false
import org.apache.bval.AbstractBeanValidator;
import org.apache.bval.MetaBeanFinder;
public class ClassValidator extends AbstractBeanValidator implements Validator {
  protected final ApacheFactoryContext factoryContext;
  protected final GroupsComputer groupsComputer = new GroupsComputer();
  public ClassValidator(ApacheFactoryContext factoryContext) {
//        super(factoryContext.getMetaBeanFinder());
    this.factoryContext = factoryContext;
  }

  /**
   * @deprecated provided for backward compatibility
   */
  public ClassValidator(ApacheValidatorFactory factory) {
    this(factory.usingContext());
  }

  /**
   * the metabean finder associated with this validator.
   *
   * @return a MetaBeanFinder
   * @see org.apache.bval.MetaBeanManagerFactory#getFinder()
   */
  public MetaBeanFinder getMetaBeanFinder() {
    return factoryContext.getMetaBeanFinder();
  }

  /**
   * validate all constraints on object
   *
   * @throws javax.validation.ValidationException
   *          if a non recoverable error happens during the validation process
   */
  public <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groupArray) {
    if (object == null) throw new IllegalArgumentException("cannot validate null");
    checkGroups(groupArray);

    try {
      final GroupValidationContext<ConstraintValidationListener<T>> context =
          createContext(factoryContext.getMetaBeanFinder()
              .findForClass(object.getClass()), object, (Class<T>) object.getClass(), groupArray);
      final ConstraintValidationListener result = context.getListener();
      final Groups groups = context.getGroups();
      // 1. process groups
      for (Group current : groups.getGroups()) {
        context.setCurrentGroup(current);
        validateBeanNet(context);
      }
      // 2. process sequences
      for (List<Group> eachSeq : groups.getSequences()) {
        for (Group current : eachSeq) {
          context.setCurrentGroup(current);
          validateBeanNet(context);
          /**
           * if one of the group process in the sequence leads to one or more validation failure,
           * the groups following in the sequence must not be processed
           */
          if (!result.isEmpty()) break;
        }
        if (!result.isEmpty()) break;
      }
      return result.getConstaintViolations();
    } catch (RuntimeException ex) {
      throw unrecoverableValidationError(ex, object);
    }
  }

  /**
   * Validates a bean and all its cascaded related beans for the currently
   * defined group.
   * <p/>
   * Special code is present to manage the {@link Default} group.
   * <p/>
   * TODO: More descriptive name and don't override method from BeanValidator.
   *
   * @param vcontext The current context of this validation call.
   */
  @Override
  protected void validateBeanNet(ValidationContext vcontext) {

    GroupValidationContext<?> context = (GroupValidationContext<?>) vcontext;

    // If reached a cascaded bean which is null
    if (context.getBean() == null) {
      return;
    // If reached a cascaded bean which has already been validated for the current group
    if (!context.collectValidated()) {
      return;
    // ### First, validate the bean

    // Default is a special case
    if (context.getCurrentGroup().isDefault()) {

      List<Group> defaultGroups = expandDefaultGroup(context);
      final ConstraintValidationListener result = (ConstraintValidationListener) context.getListener();

      // If the rootBean defines a GroupSequence
      if (defaultGroups.size() > 1) {

        int numViolations = result.violationsSize();

        // Validate the bean for each group in the sequence
        Group currentGroup = context.getCurrentGroup();
        for (Group each : defaultGroups) {
          context.setCurrentGroup(each);
          super.validateBean(context);
          // Spec 3.4.3 - Stop validation if errors already found
          if (result.violationsSize() > numViolations) {
            break;
          }
        context.setCurrentGroup(currentGroup);
      } else {

        // For each class in the hierarchy of classes of rootBean,
        // validate the constraints defined in that class according
        // to the GroupSequence defined in the same class

        // Obtain the full class hierarchy
        List<Class<?>> classHierarchy = new ArrayList<Class<?>>();
        ClassHelper.fillFullClassHierarchyAsList(classHierarchy, context.getMetaBean().getBeanClass());
        Class<?> initialOwner = context.getCurrentOwner();

        // For each owner in the hierarchy
        for (Class<?> owner : classHierarchy) {
          context.setCurrentOwner(owner);

          int numViolations = result.violationsSize();

          // Obtain the group sequence of the owner, and use it for the constraints that belong to it
          List<Group> ownerDefaultGroups =
              context.getMetaBean().getFeature("{GroupSequence:"  owner.getCanonicalName()  "}");
          for (Group each : ownerDefaultGroups) {
            context.setCurrentGroup(each);
            // Spec 3.4.3 - Stop validation if errors already found
            if (result.violationsSize() > numViolations) {
              break;
            }
          }

        context.setCurrentOwner(initialOwner);
        context.setCurrentGroup(Group.DEFAULT);

      }

    }
    // if not the default group, proceed as normal
    else {
      super.validateBean(context);

    // ### Then, the cascaded beans (@Valid)
    for (MetaProperty prop : context.getMetaBean().getProperties()) {
      validateCascadedBean(context, prop);
    }

  }

  /**
   * TODO: Currently, almost the same code as super.validateRelatedBean, but
   * as it is being called at a different time, I have explicitly added the
   * code here with a different method name.
   *
   * @param context The current context
   * @param prop    The property to cascade from (in case it is possible).
   */
  private void validateCascadedBean(GroupValidationContext<?> context, MetaProperty prop) {
    AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
    if (access != null) { // different accesses to relation
      // save old values from context
      final Object bean = context.getBean();
      final MetaBean mbean = context.getMetaBean();
      for (AccessStrategy each : access) {
        if (isCascadable(context, prop, each)) {
          // modify context state for relationship-target bean
          context.moveDown(prop, each);
          // Now, if the related bean is an instance of Map/Array/etc,
          validateContext(context);
          // restore old values in context
          context.moveUp(bean, mbean);
      }
    }
  }

  /**
   * Before accessing a related bean (marked with {@link javax.validation.Valid}), the
   * validator has to check if it is reachable and cascadable.
   *
   * @param context The current validation context.
   * @param prop    The property of the related bean.
   * @param access  The access strategy used to get the related bean value.
   * @return <code>true</code> if the validator can access the related bean,
   *         <code>false</code> otherwise.
   */
  private boolean isCascadable(GroupValidationContext<?> context, MetaProperty prop, AccessStrategy access) {

    PathImpl beanPath = context.getPropertyPath();
    NodeImpl node = new NodeImpl(prop.getName());
    if (beanPath == null) {
      beanPath = PathImpl.create(null);
    }
    try {
      if (!context.getTraversableResolver().isReachable(
          context.getBean(), node,
          context.getRootMetaBean().getBeanClass(), beanPath,
          access.getElementType()))
        return false;
    } catch (RuntimeException e) {
      throw new ValidationException("Error in TraversableResolver.isReachable() for "  context.getBean(), e);
    try {
      if (!context.getTraversableResolver().isCascadable(
          context.getBean(), node,
          context.getRootMetaBean().getBeanClass(), beanPath,
          access.getElementType()))
        return false;
    } catch (RuntimeException e) {
      throw new ValidationException("Error TraversableResolver.isCascadable() for "  context.getBean(), e);
    return true;
  }
  /**
   * in case of a default group return the list of groups
   * for a redefined default GroupSequence
   *
   * @return null when no in default group or default group sequence not redefined
   */
  private List<Group> expandDefaultGroup(GroupValidationContext context) {
    if (context.getCurrentGroup().isDefault()) {
      // mention if metaBean redefines the default group
      List<Group> groupSeq =
          context.getMetaBean().getFeature(Jsr303Features.Bean.GROUP_SEQUENCE);
      if (groupSeq != null) {
        context.getGroups().assertDefaultGroupSequenceIsExpandable(groupSeq);
      }
      return groupSeq;
    } else {
      return null;
    }
  }

  protected RuntimeException unrecoverableValidationError(RuntimeException ex,
                                                          Object object) {
    if (ex instanceof UnknownPropertyException) {
      // Convert to IllegalArgumentException
      return new IllegalArgumentException(ex.getMessage(), ex);
    } else if (ex instanceof ValidationException) {
      return ex; // do not wrap specific ValidationExceptions (or instances from subclasses)
    } else {
      return new ValidationException("error during validation of "  object, ex);
    }
  }

  /**
   * validate all constraints on <code>propertyName</code> property of object
   *
   * @param propertyName - the attribute name, or nested property name (e.g. prop[2].subpropA.subpropB)
   * @throws javax.validation.ValidationException
   *          if a non recoverable error happens
   *          during the validation process
   */
  public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName,
                                                          Class<?>... groups) {
    if (object == null) throw new IllegalArgumentException("cannot validate null");

    checkPropertyName(propertyName);
    checkGroups(groups);

    try {
      MetaBean metaBean =
          factoryContext.getMetaBeanFinder().findForClass(object.getClass());
      GroupValidationContext<ConstraintValidationListener<T>> context =
          createContext(metaBean, object, (Class<T>) object.getClass(), groups);
      ConstraintValidationListener result = context.getListener();
      NestedMetaProperty nestedProp = getNestedProperty(metaBean, object, propertyName);
      context.setMetaProperty(nestedProp.getMetaProperty());
      if (nestedProp.isNested()) {
        context.setFixedValue(nestedProp.getValue());
      } else {
        context.setMetaProperty(nestedProp.getMetaProperty());
      }
      if (context.getMetaProperty() == null) throw new IllegalArgumentException(
          "Unknown property "  object.getClass().getName()  "."  propertyName);
      Groups sequence = context.getGroups();
      // 1. process groups
      for (Group current : sequence.getGroups()) {
        context.setCurrentGroup(current);
        validatePropertyInGroup(context);
      }
      // 2. process sequences
      for (List<Group> eachSeq : sequence.getSequences()) {
        for (Group current : eachSeq) {
          context.setCurrentGroup(current);
          validatePropertyInGroup(context);
          /**
           * if one of the group process in the sequence leads to one or more validation failure,
           * the groups following in the sequence must not be processed
           */
          if (!result.isEmpty()) break;
        if (!result.isEmpty()) break;
      }
      return result.getConstaintViolations();
    } catch (RuntimeException ex) {
      throw unrecoverableValidationError(ex, object);
  }
  private void validatePropertyInGroup(GroupValidationContext context) {
    Group currentGroup = context.getCurrentGroup();
    List<Group> defaultGroups = expandDefaultGroup(context);
    if (defaultGroups != null) {
      for (Group each : defaultGroups) {
        context.setCurrentGroup(each);
        validateProperty(context);
        // continue validation, even if errors already found: if (!result.isEmpty())
      }
      context.setCurrentGroup(currentGroup); // restore
    } else {
      validateProperty(context);
    }
  }

  /**
   * find the MetaProperty for the given propertyName,
   * which could contain a path, following the path on a given object to resolve
   * types at runtime from the instance
   */
  private NestedMetaProperty getNestedProperty(MetaBean metaBean, Object t,
                                               String propertyName) {
    NestedMetaProperty nested = new NestedMetaProperty(propertyName, t);
    nested.setMetaBean(metaBean);
    nested.parse();
    return nested;
  }

  /**
   * validate all constraints on <code>propertyName</code> property
   * if the property value is <code>value</code>
   *
   * @throws javax.validation.ValidationException
   *          if a non recoverable error happens
   *          during the validation process
   */
  public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType,
                                                       String propertyName, Object value,
                                                       Class<?>... groups) {

    checkBeanType(beanType);
    checkPropertyName(propertyName);
    checkGroups(groups);

    try {
      MetaBean metaBean = factoryContext.getMetaBeanFinder().findForClass(beanType);
      GroupValidationContext<ConstraintValidationListener<T>> context =
          createContext(metaBean, null, beanType, groups);
      ConstraintValidationListener result = context.getListener();
      context.setMetaProperty(
          getNestedProperty(metaBean, null, propertyName).getMetaProperty());
      context.setFixedValue(value);
      Groups sequence = context.getGroups();
      // 1. process groups
      for (Group current : sequence.getGroups()) {
        context.setCurrentGroup(current);
        validatePropertyInGroup(context);
      }
      // 2. process sequences
      for (List<Group> eachSeq : sequence.getSequences()) {
        for (Group current : eachSeq) {
          context.setCurrentGroup(current);
          validatePropertyInGroup(context);
          /**
           * if one of the group process in the sequence leads to one or more validation failure,
           * the groups following in the sequence must not be processed
           */
          if (!result.isEmpty()) break;
        if (!result.isEmpty()) break;
      }
      return result.getConstaintViolations();
    } catch (RuntimeException ex) {
      throw unrecoverableValidationError(ex, value);
  }
  protected <T> GroupValidationContext<ConstraintValidationListener<T>> createContext(
      MetaBean metaBean, T object, Class<T> objectClass, Class<?>[] groups) {
    ConstraintValidationListener<T> listener = new ConstraintValidationListener<T>(object, objectClass);
    GroupValidationContextImpl<ConstraintValidationListener<T>> context =
        new GroupValidationContextImpl(listener,
            this.factoryContext.getMessageInterpolator(),
            this.factoryContext.getTraversableResolver(), metaBean);
    context.setBean(object, metaBean);
    context.setGroups(groupsComputer.computeGroups(groups));
    return context;
  }
  /**
   * Return the descriptor object describing bean constraints
   * The returned object (and associated objects including ConstraintDescriptors)
   * are immutable.
   *
   * @throws ValidationException if a non recoverable error happens
   *                             during the metadata discovery or if some
   *                             constraints are invalid.
   */
  public BeanDescriptor getConstraintsForClass(Class<?> clazz) {
    if (clazz == null) {
      throw new IllegalArgumentException("Class cannot be null");
    try {
      MetaBean metaBean = factoryContext.getMetaBeanFinder().findForClass(clazz);
      BeanDescriptorImpl edesc =
          metaBean.getFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR);
      if (edesc == null) {
        edesc = createBeanDescriptor(metaBean);
        metaBean.putFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR, edesc);
      }
      return edesc;
    } catch (RuntimeException ex) {
      throw new ValidationException("error retrieving constraints for "  clazz, ex);
    }
  }
  protected BeanDescriptorImpl createBeanDescriptor(MetaBean metaBean) {
    return new BeanDescriptorImpl(factoryContext, metaBean, metaBean.getValidations());
  }
  /**
   * Return an object of the specified type to allow access to the
   * provider-specific API.  If the Bean Validation provider
   * implementation does not support the specified class, the
   * ValidationException is thrown.
   *
   * @param type the class of the object to be returned.
   * @return an instance of the specified class
   * @throws ValidationException if the provider does not
   *                             support the call.
   */
  public <T> T unwrap(Class<T> type) {
    if (type.isAssignableFrom(getClass())) {
      return (T) this;
    } else if (!type.isInterface()) {
      return SecureActions.newInstance(type, new Class[]{ApacheFactoryContext.class},
          new Object[]{factoryContext});
    } else {
      try {
        Class<T> cls = ClassUtils.getClass(type.getName()  "Impl");
        return SecureActions.newInstance(cls,
            new Class[]{ApacheFactoryContext.class}, new Object[]{factoryContext});
      } catch (ClassNotFoundException e) {
        throw new ValidationException("Type "  type  " not supported");
      }
  }
  /**
   * Checks that beanType is valid according to spec Section 4.1.1 i. Throws
   * an {@link IllegalArgumentException} if it is not.
   *
   * @param beanType Bean type to check.
   */
  private void checkBeanType(Class<?> beanType) {
    if (beanType == null) {
      throw new IllegalArgumentException("Bean type cannot be null.");
  }
  /**
   * Checks that the property name is valid according to spec Section 4.1.1 i.
   * Throws an {@link IllegalArgumentException} if it is not.
   *
   * @param propertyName Property name to check.
   */
  private void checkPropertyName(String propertyName) {
    if (propertyName == null || propertyName.isEmpty()) {
      throw new IllegalArgumentException("Property path cannot be null or empty.");
  }
  /**
   * Checks that the groups array is valid according to spec Section 4.1.1 i.
   * Throws an {@link IllegalArgumentException} if it is not.
   *
   * @param groups The groups to check.
   */
  private void checkGroups(Class<?>[] groups) {
    if (groups == null) {
      throw new IllegalArgumentException("Groups cannot be null.");
  }
    for (int i = 0; i < factories.length; i) {
      if (factories[i] instanceof Jsr303MetaBeanFactory && !(factories[i] instanceof MethodValidatorMetaBeanFactory)) {
  }  
          validateBean(context);
            validateBean(context);
      validateBean(context);
   * validate the related beans that are cascadable.
    // execute all property level validations
    
    // execute all bean level validations
  /**
   * Iterates the values of an array, setting the current context
   * appropriately and validating each value.
   * 
   * @param <VL>
   * @param context
   *            The validation context, its current bean must be an array.
   */
   * Iterates the values of an {@link Iterable} object, setting the current
   * context appropriately and validating each value.
   * 
   * @param <VL>
   * @param context The validation context, its current bean must implement
   *            {@link Iterable}.
  protected <VL extends ValidationListener> void validateIterableInContext(ValidationContext<VL> context) {
      
    final boolean positional = context.getBean() instanceof List<?>;
    
    // jsr303 spec: Each object provided by the iterator is validated.
    for ( Object each : (Iterable<?>) context.getBean() ) {
      if ( positional ) {
          context.setCurrentIndex(index);
      }
      if (each == null) {
          continue; // Null values are not validated
      }
          context.setBean(each, dyn.resolveMetaBean(each));
          context.setBean(each);
  /**
   * Iterates the values of a {@link Map}, setting the current context
   * appropriately and validating each value.
   * 
   * @param <VL>
   * @param context
   *            The validation context, its current bean must implement
   *            {@link Map}.
   */
      if (entry.getValue() == null) {
        continue; // Null values are not validated
      }
        validateIterableInContext(context);
 * Objects of this class are able to validate bean instances (and the associated
 * object graphs).
 * <p>
 * Implementation is thread-safe.
 * <p>
 * API class
 * 
 * @author Roman Stumm
 * @author Carlos Vara
  // Validator implementation --------------------------------------------------
  
   * Validates all constraints on <code>object</code>.
   * 
   * @param object
   *            object to validate
   * @param groups
   *            group or list of groups targeted for validation
   *            (default to {@link javax.validation.groups.Default})
   * 
   * @return constraint violations or an empty Set if none
   * 
   * @throws IllegalArgumentException
   *             if object is null
   *             or if null is passed to the varargs groups
   * @throws ValidationException
   *             if a non recoverable error happens
   *             during the validation process
  @Override
      
      Class<T> objectClass = (Class<T>) object.getClass();
      MetaBean objectMetaBean = factoryContext.getMetaBeanFinder().findForClass(objectClass);
      
          createContext(objectMetaBean, object, objectClass, groupArray);
      final ConstraintValidationListener<T> result = context.getListener();
      final Groups sequence = context.getGroups();
      
      for (Group current : sequence.getGroups()) {
      
      for (List<Group> eachSeq : sequence.getSequences()) {
          // if one of the group process in the sequence leads to one or more validation failure,
          // the groups following in the sequence must not be processed
          if (!result.isEmpty()) break;
        }
        if (!result.isEmpty()) break;
      }
      return result.getConstaintViolations();
    } catch (RuntimeException ex) {
      throw unrecoverableValidationError(ex, object);
    }
  }
  
  /**
   * Validates all constraints placed on the property of <code>object</code>
   * named <code>propertyName</code>.
   * 
   * @param object
   *            object to validate
   * @param propertyName
   *            property to validate (ie field and getter constraints). Nested
   *            properties may be referenced (e.g. prop[2].subpropA.subpropB)
   * @param groups
   *            group or list of groups targeted for validation
   *            (default to {@link javax.validation.groups.Default})
   * 
   * @return constraint violations or an empty Set if none
   * 
   * @throws IllegalArgumentException
   *             if <code>object</code> is null,
   *             if <code>propertyName</code> null, empty or not a valid
   *             object property
   *             or if null is passed to the varargs groups
   * @throws ValidationException
   *             if a non recoverable error happens
   *             during the validation process
   */
  @Override
  public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName,
                                                          Class<?>... groups) {
    if (object == null) throw new IllegalArgumentException("cannot validate null");

    checkPropertyName(propertyName);
    checkGroups(groups);

    try {
      
      Class<T> objectClass = (Class<T>) object.getClass();
      MetaBean objectMetaBean = factoryContext.getMetaBeanFinder().findForClass(objectClass);

      GroupValidationContext<ConstraintValidationListener<T>> context =
          createContext(objectMetaBean, object, objectClass, groups);
      ConstraintValidationListener<T> result = context.getListener();
      NestedMetaProperty nestedProp = getNestedProperty(objectMetaBean, object, propertyName);
      context.setMetaProperty(nestedProp.getMetaProperty());
      if (nestedProp.isNested()) {
        context.setFixedValue(nestedProp.getValue());
      } else {
        context.setMetaProperty(nestedProp.getMetaProperty());
      }
      if (context.getMetaProperty() == null) throw new IllegalArgumentException(
          "Unknown property "  object.getClass().getName()  "."  propertyName);
      Groups sequence = context.getGroups();
      
      // 1. process groups
      for (Group current : sequence.getGroups()) {
        context.setCurrentGroup(current);
        validatePropertyInGroup(context);
      }
      
      // 2. process sequences
      for (List<Group> eachSeq : sequence.getSequences()) {
        for (Group current : eachSeq) {
          context.setCurrentGroup(current);
          validatePropertyInGroup(context);
   * Validates all constraints placed on the property named
   * <code>propertyName</code> of the class <code>beanType</code> would the
   * property value be <code>value</code>
   * <p/>
   * <code>ConstraintViolation</code> objects return null for
   * {@link ConstraintViolation#getRootBean()} and
   * {@link ConstraintViolation#getLeafBean()}
   * 
   * @param beanType
   *            the bean type
   * @param propertyName
   *            property to validate
   * @param value
   *            property value to validate
   * @param groups
   *            group or list of groups targeted for validation
   *            (default to {@link javax.validation.groups.Default})
   * 
   * @return constraint violations or an empty Set if none
   * 
   * @throws IllegalArgumentException
   *             if <code>beanType</code> is null,
   *             if <code>propertyName</code> null, empty or not a valid
   *             object property
   *             or if null is passed to the varargs groups
   * @throws ValidationException
   *             if a non recoverable error happens
   *             during the validation process
   */
  @Override
  public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType,
                                                       String propertyName, Object value,
                                                       Class<?>... groups) {

    checkBeanType(beanType);
    checkPropertyName(propertyName);
    checkGroups(groups);

    try {
      MetaBean metaBean = factoryContext.getMetaBeanFinder().findForClass(beanType);
      GroupValidationContext<ConstraintValidationListener<T>> context =
          createContext(metaBean, null, beanType, groups);
      ConstraintValidationListener<T> result = context.getListener();
      context.setMetaProperty(
          getNestedProperty(metaBean, null, propertyName).getMetaProperty());
      context.setFixedValue(value);
      Groups sequence = context.getGroups();
      
      // 1. process groups
      for (Group current : sequence.getGroups()) {
        context.setCurrentGroup(current);
        validatePropertyInGroup(context);
      }
      // 2. process sequences
      for (List<Group> eachSeq : sequence.getSequences()) {
        for (Group current : eachSeq) {
          context.setCurrentGroup(current);
          validatePropertyInGroup(context);
          // if one of the group process in the sequence leads to one or more validation failure,
          // the groups following in the sequence must not be processed
          if (!result.isEmpty()) break;
        }
        if (!result.isEmpty()) break;
      }
      return result.getConstaintViolations();
    } catch (RuntimeException ex) {
      throw unrecoverableValidationError(ex, value);
    }
  }
  
  /**
   * Return the descriptor object describing bean constraints.
   * The returned object (and associated objects including
   * <code>ConstraintDescriptor<code>s) are immutable.
   * 
   * @param clazz
   *            class or interface type evaluated
   * 
   * @return the bean descriptor for the specified class.
   * 
   * @throws IllegalArgumentException
   *             if clazz is null
   * @throws ValidationException
   *             if a non recoverable error happens
   *             during the metadata discovery or if some
   *             constraints are invalid.
   */
  @Override
  public BeanDescriptor getConstraintsForClass(Class<?> clazz) {
    if (clazz == null) {
      throw new IllegalArgumentException("Class cannot be null");
    }
    try {
      MetaBean metaBean = factoryContext.getMetaBeanFinder().findForClass(clazz);
      BeanDescriptorImpl edesc =
          metaBean.getFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR);
      if (edesc == null) {
        edesc = createBeanDescriptor(metaBean);
        metaBean.putFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR, edesc);
      }
      return edesc;
    } catch (RuntimeException ex) {
      throw new ValidationException("error retrieving constraints for "  clazz, ex);
    }
  }
  
  /**
   * Return an instance of the specified type allowing access to
   * provider-specific APIs. If the Bean Validation provider
   * implementation does not support the specified class,
   * <code>ValidationException</code> is thrown.
   * 
   * @param type
   *            the class of the object to be returned.
   * 
   * @return an instance of the specified class
   * 
   * @throws ValidationException
   *             if the provider does not support the call.
   */
  @SuppressWarnings("unchecked")
  @Override
  public <T> T unwrap(Class<T> type) {
    if (type.isAssignableFrom(getClass())) {
      return (T) this;
    } else if (!type.isInterface()) {
      return SecureActions.newInstance(type, new Class[]{ApacheFactoryContext.class},
          new Object[]{factoryContext});
    } else {
      try {
        Class<T> cls = ClassUtils.getClass(type.getName()  "Impl");
        return SecureActions.newInstance(cls,
            new Class[]{ApacheFactoryContext.class}, new Object[]{factoryContext});
      } catch (ClassNotFoundException e) {
        throw new ValidationException("Type "  type  " not supported");
      }
    }
  }
  
  
  // Helpers -------------------------------------------------------------------
  
  /**
   * <p>
   * 
   * @param ValidationContext
   *            The current context of this validation call. Must have its
   *            {@link GroupValidationContext#getCurrentGroup()} field set.
   * Checks if the the meta property <code>prop</code> defines a cascaded
   * bean, and in case it does, validates it.
   * 
   * @param context
   *            The current validation context.
   * @param prop
   *            The property to cascade from (in case it is possible).
        new GroupValidationContextImpl<ConstraintValidationListener<T>>(listener,

        if (propertyName == null || propertyName.trim().length() == 0) {
    if (propertyName == null || propertyName.trim().length() == 0) {
        // List<Class<?>> subClasses = new ArrayList<Class<?>>(Arrays.asList(clazz.getInterfaces()));
        // List<Class<?>> subClasses = new List<Class<?>>(Arrays.asList(clazz.getInterfaces()));
        List<Class<?>> subClasses = new ArrayList(Arrays.asList(clazz.getInterfaces()));
  // @Override - not allowed in 1.5 for Interface methods
  // @Override - not allowed in 1.5 for Interface methods
  // @Override - not allowed in 1.5 for Interface methods
  // @Override - not allowed in 1.5 for Interface methods
  // @Override - not allowed in 1.5 for Interface methods
     * The groups have to be validated, empty by default.
     * @return the groups have to be validated, empty by default.
     * Marks if the returned object by the intercepted method execution has to
     * be validated, false by default.
     * @return false by default.
    /**
     * The exception re-thrown when an error occurs during the validation.
     *
     * @return the exception re-thrown when an error occurs during the
     *         validation.
     */
    Class<? extends Throwable> rethrowExceptionsAs() default Exception.class;

import javax.validation.ConstraintViolationException;

    Class<? extends Throwable> rethrowExceptionsAs() default ConstraintViolationException.class;
import java.lang.reflect.Constructor;
            throw getException(new ConstraintViolationException("Validation error when calling method '"
                     Arrays.deepToString(arguments), constraintViolations), validate.rethrowExceptionsAs());
                throw getException(new ConstraintViolationException("Method '"
                         returnedValue, constraintViolations), validate.rethrowExceptionsAs());
    private static Throwable getException(ConstraintViolationException exception,
            Class<? extends Throwable> exceptionWrapperClass) {
        // check the thrown exception is of same re-throw type
        if (exceptionWrapperClass == ConstraintViolationException.class) {
            return exception;
        }

        // re-throw the exception as new exception
        Throwable rethrowEx = null;

        try {
            Constructor<? extends Throwable> constructor = exceptionWrapperClass.getConstructor(Throwable.class);
            rethrowEx = constructor.newInstance(exception);
        } catch (Exception e) {
            rethrowEx = new RuntimeException("Impossible to re-throw '"
                     exceptionWrapperClass
                     "', it needs the constructor with <Throwable> argument.", e);
        }

        return rethrowEx;
    }

import javax.validation.Valid;
    @Validate(
            groups = { Update.class },
            rethrowExceptionsAs = DummyException.class
    )
    public int updateCountry(@Valid Country country) {
        return 0;
    }

import javax.validation.ValidationException;
    if ( methodDescriptor == null ) {
        throw new ValidationException("Method "  method  " doesn't belong to class "  clazz);
    }
    if ( methodDescriptor == null ) {
        throw new ValidationException("Method "  method  " doesn't belong to class "  clazz);
    }
    if ( constructorDescriptor == null ) {
        throw new ValidationException("Constructor "  constructor  " doesn't belong to class "  clazz);
    }
    ConstructorDescriptorImpl constructorDescriptor =
    if ( constructorDescriptor == null ) {
        throw new ValidationException("Constructor "  constructor  " doesn't belong to class "  clazz);
    }
    ParameterDescriptorImpl paramDesc = (ParameterDescriptorImpl) constructorDescriptor
    if ( methodDescriptor == null ) {
        throw new ValidationException("Method "  method  " doesn't belong to class "  clazz);
    }
  @SuppressWarnings("unchecked")
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
    /**
     * Create a new BeanValidationContext instance.
     * @param listener
     */
    /**
     * Create a new BeanValidationContext instance.
     * @param listener
     * @param validatedMap
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Set the listener.
     * @param listener T
     */
     * {@inheritDoc}
     * Here, state equates to a given bean reference.
    /**
     * Learn whether a particular object has been validated.
     * @param object
     * @return true when the object has already been validated in this context
     */
    /**
     * {@inheritDoc}
     */
     * Get the cached value or access it somehow (via field or method)<br>
    /**
     * {@inheritDoc}
     * Caches retrieved value.
     */
     * Convenience method to access metaProperty.name
    /**
     * Set the current property value.
     * @param propertyValue
     */
    /**
     * Set the property value, fixed.
     * @param value
     */
        setFixed(true);
    /**
     * Learn whether the current property value is "fixed."
     * @return boolean
     */
    /**
     * Potentially declare the current property value as being "fixed."
     * If <code>true</code>, the context will reuse any not-<code>UNKNOWN</code>
     * propertyValue regardless of the {@link AccessStrategy} by which it is requested.
     * @param fixed
     */
     * Depending on whether we have a metaProperty or not,
     * Drop cached value, marking the internal cachedValue as <code>UNKNOWN</code>.
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */

    /**
     * {@inheritDoc}
     */
   * Create a new BeanValidator instance.
   * Convenience constructor. Use the global instance of MetaBeanManagerFactory.getFinder().
  /**
   * Create a new BeanValidator instance.
   * @param metaBeanFinder
   */
   * Convenience API. validate a root object with all related objects
   * @param bean
   * Convenience API. validate a root object with all related objects
   * @param metaBean
   * Validate the method parameters based on @Validate annotations.
   * Determine the metabean for the given object.
   * @param <VL>
   * @param validate
   * @param parameter
   * @param context
   * 
   * @return ValidationListener of the proper type
  @SuppressWarnings("unchecked")
   * 
   * @return ValidationContext parameterized with our listener type
   * Convenience API. validate a single property.
   * {@inheritDoc}
  /**
   * Validate a property of a graph.
   * @param <VL>
   * @param context
   * @param prop
   */
   * Get the metabean finder associated with this validator.
 * Description: Dynamic {@link MetaBean} subclass.<br/>
    /**
     * Create a new DynamicMetaBean instance.
     * @param finder
     */
     * {@inheritDoc}
    /**
     * {@inheritDoc}
     */
    /**
     * Create a {@link MetaProperty} from the specified {@link PropertyDescriptor}.
     * @param pd
     * @return MetaProperty
     */
  /**
   * Create a new MetaBeanBuilder instance.
   */
  /**
   * Create a new MetaBeanBuilder instance.
   * @param factories
   */
  /**
   * Get the configured set of {@link MetaBeanFactory} objects.
   * @return {@link MetaBeanFactory} array
   */
  /**
   * Set the array of {@link MetaBeanFactory} instances with which to enrich {@link MetaBean}s.
   * @param factories
   */
  /**
   * Build a {@link MetaBean} for a given id.
   * @param beanInfoId
   * @return MetaBean
   * @throws Exception if unable to build
   */
    *//* convenience method *//*
  /*
  /**
   * Build beans for all known ids.  Default implementation returns an empty map.
   * @return Map of String : MetaBean
   */
  /**
   * Find the named class.
   * @param className
   * @return Class found or null
   */
  /**
   * Build a MetaBean for the specified class.
   * @param clazz
   * @return MetaBean
   * @throws Exception
   */
    /**
     * Cache keyed by id.
     */
    /**
     * Cache keyed by class.
     */
    /**
     * Create a new MetaBeanCache instance.
     */
    /**
     * Create a new MetaBeanCache instance.
     * @param beans
     */
    /**
     * Clear the cache.
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Return all cached MetaBeans by id.
     * @return live map
     */
    @SuppressWarnings("unchecked")
    /**
     * Cache the specified MetaBean.
     * @param beanInfo
     */
    /**
     * Remove a single MetaBean from the cache.
     * @param beanInfo
     */
    /**
     * Initialize the specified {@link MetaBean}.
     * @param metaBean
     * @throws Exception
     */
    void buildMetaBean(MetaBean metaBean) throws Exception;
     * Find a MetaBean with a certain id.
     * Find the MetaBean for the specified class.
  /** MetaBean cache */
  /** MetaBean builder */
  /** Complete flag */
  /**
   * Create a new MetaBeanManager instance.
   */
  /**
   * Create a new MetaBeanManager instance.
   * @param builder
   */
  /**
   * Get the builder used.
   * @return {@link MetaBeanBuilder}
   */
  /**
   * Get the cache used.
   * @return {@link MetaBeanCache}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
   * Compute all known relationships for <code>beanInfo</code>.
  /**
   * Compute a single related {@link MetaBean}.
   * @param prop
   * @param beanRef
   */
    /**
     * Create an Error object.
     * @param reason
     * @param owner
     * @param propertyName
     * @return new {@link Error}
     */
    /**
     * Add an Error to the set of Errors shared by a particular "reason."
     * @param error
     * @see {@link Error#getReason()}
     */
    /**
     * Add an Error to the property-keyed map of Errors maintained for this Error's owner.
     * @param error
     * @see {@link Error#getOwner()}
     */
    /**
     * Get the map of Errors by reason; 
     * key = reason, value = list of errors for this reason
     * @return map
     */
     * Get the map of Errors by owner;
     * @return map
    /**
     * Learn whether these results are empty/error-free.
     * @return true when there are NO errors in this validation result
     */
    /**
     * Learn whether there is an Error keyed to a specified reason description.
     * @param reason
     * @return boolean
     * @see {@link Error#getReason()}
     */
     * Learn whether <code>bean</code> has any errors keyed to property <code>propertyName</code>.
     * @param bean
     * @return boolean
    /**
     * {@inheritDoc}
     */
    /**
     * Resolve the type indirection.
     * @return Type
     */
 * Description: ("artificial" enum with custom values).<br/>
    /**
     * Create a new DynaTypeEnum instance.
     * @param enumClass
     */
    /**
     * Create a new DynaTypeEnum instance.
     * @param enumClass
     * @param names
     */
        this(enumClass);
    /**
     * Set the enumeration value names.
     * @param names
     */
    /**
     * Get the name of the enum class.
     * @return String
     */
    /**
     * {@inheritDoc}
     */
     * Learn whether the referred class is, in fact, an enum class.
     * Get the emulated constants.
     * @return Value[]
    /**
     * Learn whether the wrapped class is assignable from <code>cls</code>.
     * @param cls
     * @return boolean
     */
     * Represents a single "enum" instance (= the value).
        /**
         * Create a new Value instance.
         * @param name
         */
         * @return the name of this constant
         * INFO: Boolean, Field visible?
import org.apache.commons.lang.ArrayUtils;
    /**
     * Create a new FeaturesCapable instance.
     */
    /**
     * Get the (live) map of features.
     * @return Map<String, Object>
     */
    @SuppressWarnings("unchecked")
    /**
     * Set whether to optimize read operations by accessing the
     * features map in an unsynchronized manner.
     * @param fast
     */
    /**
     * Get the specified feature.
     * @param <T>
     * @param key
     * @return T
     */
    @SuppressWarnings("unchecked")
    /**
     * Get the specified feature, returning <code>defaultValue</code> if undeclared.
     * @param <T>
     * @param key
     * @param defaultValue
     * @return T
     */
    @SuppressWarnings("unchecked")
    /**
     * Convenience method to set a particular feature value.
     * @param <T>
     * @param key
     * @param value
     */
    /**
     * Create a deep copy (copy receiver and copy properties).
     * @param <T>
     * @return new T instance
     */
    @SuppressWarnings("unchecked")
    /**
     * Copy this {@link FeaturesCapable} into another {@link FeaturesCapable} instance.
     * @param <T>
     * @param target
     */
    /**
     * Get any validations set for this {@link FeaturesCapable}.
     * @return Validation array
     */
    /**
     * Add a validation to this {@link FeaturesCapable}.
     * @param validation to add
     */
        validations = (Validation[]) ArrayUtils.add(validations, validation);
    /**
     * Search for an equivalent validation among those configured.
     * @param aValidation
     * @return true if found
     */
    /**
     * Get the id.
     * @return String
     */
    /**
     * Set the id.
     * @param id the String to set
     */
    /**
     * Get the name.
     * @return String
     */
    /**
     * Set the name.
     * @param name the String to set
     */
    /**
     * Get the beanClass.
     * @return Class<?>
     */
    public Class<?> getBeanClass() {
        return beanClass;
    }

    /**
     * Set the beanClass.
     * @param beanClass the Class<?> to set
     */
    /**
     * Get the properties.
     * @return MetaProperty[]
     */
    /**
     * Set the properties.
     * @param properties the MetaProperty[] to set
     */
    /**
     * Get the specified {@link MetaProperty}.
     * @param name
     * @return MetaProperty found or <code>null</code>
     */
    /**
     * Learn whether any known property is a relationship.
     * @see MetaProperty#isRelationship()
     * @return true when at least one of the properties is a relationship
     */
    /**
     * Learn whether there are any known properties.
     * @return boolean
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * <p>If this {@link MetaBean} is compatible with <code>bean</code>, return <code>this</code>, else <code>null</code>.</p><p>
     * Compatibility is satisfied in one of the following ways:<ul>
     * <li><code>bean</code> is null</li>
     * <li><code>bean</code> is an instance of our <code>beanClass</code></li>
     * <li><code>bean</code> <em>is</em> our <code>beanClass</code> itself</li>
     * </ul></p>
     * @param bean
     * @return <code>this</code> or <code>null</code>
     */
 * Description: the meta description of a property of a bean. It supports a map
 * of features and multiple validations.<br/>
    /**
     * Create a new MetaProperty instance.
     */
    /**
     * Get the metabean of the target bean (mainly for relationships).
     * @return MetaBean (may be null).
     */
    /**
     * Set the MetaBean of this {@link MetaProperty}.
     * @param metaBean to set
     */
    /**
     * Get the metabean that owns this property (set by MetaBean.putProperty())
     * @return
     */
    /**
     * Set the metabean that owns this property (usually called by MetaBean.putProperty())
     * @param parentMetaBean
     */
    //TODO could this be made package-private?
    }
    /**
     * Learn whether this property is considered a relationship.
     * @return <code>true</code> if it has a MetaBean of its own
     */
    /**
     * Set the type of this property.
     * @param type to set
     */
    /**
     * Get the type of this property.
     * @return
     */
    /**
     * Resolve the type of this property to a class.
     * @return Class, <code>null</code> if cannot be determined
     */
    //TODO can this handle variables?  Perhaps move TypeUtils up from bval-jsr303
    private static Class<?> getTypeClass(Type rawType) {
    /**
     * Get the name of this property.
     * @return String
     */
    /**
     * Learn whether this property is considered mandatory.
     * @return <code>true</code> if the <code>MANDATORY</code> feature is set to <code>true</code>.
     * @see {@link Features.Property#MANDATORY}
     */
    /**
     * Set this property as being mandatory (or not).
     * @param mandatory
     * @see {@link Features.Property#MANDATORY}
     */
    /**
     * Get javascript validations of this property.
     * @return String[]
     * @deprecated
     */
    /**
     * Set the name of this property.
     * @param name to set
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Get the property value.
     * @return {@link Object}
     */
    /**
     * Get the value by using the given access strategy.
     * @param access
     * @return {@link Object}
     */
    /**
     * Get the property name.
     * @return {@link String}
     */
    /**
     * Get the {@link ValidationListener}.
     * @return T
     */
    /**
     * Get the bean.
     * @return {@link Object}
     */
    /**
     * Get the model meta-bean.
     * @return {@link MetaBean}
     */
    /**
     * Set the model meta-bean.
     * @param metaBean
     */
    /**
     * Get the model meta-property.
     * @return {@link MetaProperty}
     */
    /**
     * Set the bean.
     * @param bean
     */
    /**
     * Avoid recursion by recording the current state of this context as having been validated.
     * <p/>
     *
     * @return true when this state had not already been recorded
     */
    /**
     * Set the current bean/metabean.
     * @param aBean
     * @param aMetaBean
     */
    /**
     * Set the current meta-property.
     * @param metaProperty
     */
    /**
     * Step deeper into association at 'prop' 
     * @param prop
     * @param access
     */
    /**
     * Step out from a validation of associated objects.
     * @param bean
     * @param metaBean
     */
     * Set the index of the object currently validated into the context.
     * @param index
     * @param key

    /**
     * Get the current access strategy.
     * @return {@link AccessStrategy}
     */
     * An object holding a single validation constraint violation
        /** Reason */
        /** Owner */
        /** Property name*/
        /**
         * Create a new Error instance.
         * @param aReason
         * @param aOwner
         * @param aPropertyName
         */
        /**
         * Get the reason.
         * @return String
         */
        /**
         * Get the owner.
         * @return Object
         */
        /**
         * Get the propertyName.
         * @return String
         */
        /**
         * {@inheritDoc}
         */
  /**
   * Learn whether a given object is a valid email address.
   * @param value to check
   * @return <code>true</code> if the validation passes
   */
  /**
   * Learn whether a particular value matches a given pattern per {@link Matcher#matches()}.
   * @param value
   * @param aPattern
   * @return <code>true</code> if <code>value</code> was a <code>String</code> matching <code>aPattern</code>
   */
  //TODO it would seem to make sense to move or reduce the visibility of this method as it is more general than email.
    //TODO could effortlessly validate any CharSequence
 * to get the value of a Property.  This class is designed such that
 * subclasses are intended to know internally to which property they refer,
 * with only the particular target instance being externally required
 * to calculate the property's value.  One intent of this design is
 * that the notion of the very definition of a property is abstracted
 * along with the mechanism for accessing that property.<br/>
     * Get the value from the given instance.
    /**
     * Get the Java program {@link ElementType} used by this {@link AccessStrategy}
     * to determine property values.
     * @return ElementType
     */
    /**
     * Get the type of the property
     * @return Type
     */
    /**
     * Get a name representative of this property.
     * @return String
     */
    /** Project name */
    /** Unique id of the current project/version/revision */
    /** Version number */
    /** Major release number */
    /** Minor release number */
    /** Patch/point release number */
    /** Release status */
    /** Version control revision number */
    /**
     * Get the project version number.
     * @return String
     */
    /**
     * Get the version control revision number.
     * @return String
     */
    /**
     * Get the project name.
     * @return String
     */
    /**
     * Get the fully-qualified project id.
     * @return String
     */
    /**
     * Main method of this class that prints the {@link #toString()} to <code>System.out</code>.
     * @param args ignored
     */
    /**
     * {@inheritDoc}
     */
 * Description: direct field access strategy.<br/>
    /**
     * Create a new FieldAccess instance.
     * @param field
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    public Type getJavaType() {
        return field.getGenericType();
    }

    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Create a new MethodAccess instance.
     * @param method
     */
    /**
     * Create a new MethodAccess instance.
     * @param propertyName
     * @param method
     */
     * {@inheritDoc}
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    public Type getJavaType() {
        return method.getGenericReturnType();
    }

    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
     * Create a new instance of a specified class.
    /**
     * Create a new instance of a specified class.
     *
     * @param <T>
     * @param <E>
     * @param cls - the class (no interface, non-abstract, has accessible matching constructor)
     * @param exception type to rethrow
     * @param paramTypes
     * @param values
     * @return a new instance
     * @throws E
     */
     * Create a new instance of the class using the default no-arg constructor.
     * Perform action with AccessController.doPrivileged() if possible.
  /**
   * Create a new PropertyAccess instance.
   * @param clazz
   * @param propertyName
   */
  /**
   * {@inheritDoc}
   */
  /**
   * Get a named property from <code>bean</code>.
   * @param bean
   * @param propertyName
   * @return Object found
   * @throws InvocationTargetException
   * @throws NoSuchMethodException
   * @throws IllegalAccessException
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
final class AnnotationConstraintBuilder<A extends Annotation> {

    //TODO extract these to some neutral location; see AnnotationProxyBuilder
    /**
     * Create a new AnnotationConstraintBuilder instance.
     * @param validatorClasses
     * @param constraintValidator
     * @param annotation
     * @param owner
     * @param access
     */
          Class<? extends ConstraintValidator<A, ?>>[] validatorClasses,
          ConstraintValidator<A, ?> constraintValidator, A annotation, Class<?> owner,
        constraintValidation = new ConstraintValidation<A>(validatorClasses,
        if (raw instanceof Class<?>) {
            garr = new Class[]{(Class<?>) raw};
        constraintValidation.setGroups(new HashSet<Class<?>>(Arrays.asList(garr)));
    @SuppressWarnings("unchecked")
        Class<? extends Payload>[] payload_raw =
              (Class<? extends Payload>[]) method.invoke(constraintValidation.getAnnotation());
        Set<Class<? extends Payload>> payloadSet;
            payloadSet = Collections.<Class<? extends Payload>>emptySet();
            payloadSet = new HashSet<Class<? extends Payload>>(payload_raw.length);
            payloadSet.addAll(Arrays.asList(payload_raw));
        constraintValidation.setPayload(payloadSet);
    /**
     * Get the configured {@link ConstraintValidation}.
     * @return {@link ConstraintValidation}
     */
    public ConstraintValidation<?> getConstraintValidation() {
    public void addComposed(ConstraintValidation<?> composite) {
            values = new HashMap<String, Object>();
        @SuppressWarnings("unchecked")
        private void applyOn(ConstraintValidation<?> composite) {
            ((ConstraintValidation<Annotation>) composite).setAnnotation(newAnnot);
  /**
   * Create a new ApacheFactoryContext instance.
   * @param factory
   */
  /**
   * Create a new ApacheFactoryContext instance.
   * @param factory
   * @param metaBeanFinder
   */
  /**
   * Get the {@link ApacheValidatorFactory} used by this {@link ApacheFactoryContext}.
   * @return {@link ApacheValidatorFactory}
   */
  /**
   * Get the metaBeanFinder.
   * @return {@link MetaBeanFinder}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * Get the {@link ConstraintValidatorFactory}.
   * @return {@link ConstraintValidatorFactory}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * Get the {@link MessageInterpolator}.
   * @return {@link MessageInterpolator}
   */
  /**
   * Get the {@link TraversableResolver}.
   * @return {@link TraversableResolver}
   */
  @SuppressWarnings("deprecation")
protected MetaBeanManager buildMetaBeanManager() {
  /**
   * Create a {@link MetaBeanManager} using the specified builders.
   * @param builders {@link MetaBeanFactory} {@link List}
   * @return {@link MetaBeanManager}
   */
    /**
     * Create the {@link XMLMetaBeanManager}.
     * @param builders
     * @return {@link XMLMetaBeanManager}
     */
    protected static XMLMetaBeanManager createXMLMetaBeanManager(List<MetaBeanFactory> builders) {
    /**
     * Learn whether a particular builder class is suitable for this {@link ValidationProvider}.
     * @param builderClass
     * @return boolean suitability
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
     * {@inheritDoc}
 * Description: a factory is a complete configurated object that can create validators.<br/>
 * This instance is not thread-safe.<br/>
    /**
     * Convenience method to retrieve a default global ApacheValidatorFactory
     * @return {@link ApacheValidatorFactory}
     */
    public static synchronized ApacheValidatorFactory getDefault() {
    /**
     * Set a particular {@link ApacheValidatorFactory} instance as the default.
     * @param aDefaultFactory
     */
    /**
     * Create a new ApacheValidatorFactory instance.
     */

  /**
   * Configure this {@link ApacheValidatorFactory} from a {@link ConfigurationState}.
   * @param configuration
   */
    /**
     * Get the property map of this {@link ApacheValidatorFactory}.
     * @return Map<String, String>
     */
    /**
     * Get the default {@link MessageInterpolator} used by this {@link ApacheValidatorFactory}.
     * @return {@link MessageInterpolator}
     */
     * Shortcut method to create a new Validator instance with factory's settings
    /**
     * {@inheritDoc}
     * @return the validator factory's context
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Set the {@link MessageInterpolator} used.
     * @param messageResolver
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Set the {@link TraversableResolver} used.
     * @param traversableResolver
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Set the {@link ConstraintValidatorFactory} used.
     * @param constraintValidatorFactory
     */
     * {@inheritDoc}
     */
    public ConstraintValidatorFactory getConstraintValidatorFactory() {
        return constraintValidatorFactory;
    }
    
    /**
    @SuppressWarnings("unchecked")
        if (type.isInstance(this)) {
    /**
     * Get the detected {@link ConstraintDefaults}.
     * @return ConstraintDefaults
     */
    /**
     * Get the detected {@link AnnotationIgnores}. 
     * @return AnnotationIgnores
     */
    /**
     * Get the constraint cache used.
     * @return {@link ConstraintCached}
     */
    /**
     * Add a meta-constraint to this {@link ApacheValidatorFactory}'s runtime customizations.
     * @param beanClass
     * @param metaConstraint
     */
    /**
     * Mark a property of <code>beanClass</code> for nested validation.
     * @param beanClass
     * @param accessStrategy defining the property to validate
     */
    public void addValid(Class<?> beanClass, AccessStrategy accessStrategy) {
            slot.add(accessStrategy);
            tmpList.add(accessStrategy);
    /**
     * Set the default group sequence for a particular bean class.
     * @param beanClass
     * @param groupSequence
     */
    /**
     * Retrieve the runtime constraint configuration for a given class.
     * @param <T>
     * @param beanClass
     * @return List of {@link MetaConstraint}s applicable to <code>beanClass</code>
     */
    @SuppressWarnings("unchecked")
    /**
     * Get the {@link AccessStrategy} {@link List} indicating nested bean
     * validations that must be triggered in the course of validating a
     * <code>beanClass</code> graph.
     * @param beanClass
     * @return {@link List} of {@link AccessStrategy}
     */
            return Collections.<AccessStrategy> emptyList();
    /**
     * Get the default group sequence configured for <code>beanClass</code>.
     * @param beanClass
     * @return group Class array
     */
 * Description: unified interface to accumulate {@link ConstraintValidation}s
 * to varied targets.<br/>
    /**
     * Append a {@link ConstraintValidation}.
     * @param <T>
     * @param validation
     */
 * Description: Adapt {@link AnnotationConstraintBuilder} to the {@link AppendValidation} interface.<br/>
    private final AnnotationConstraintBuilder<?> builder;
    /**
     * Create a new AppendValidationToBuilder instance.
     * @param builder
     */
    public AppendValidationToBuilder(AnnotationConstraintBuilder<?> builder) {
    /**
     * {@inheritDoc}
     */

    /**
     * {@inheritDoc}
     */

     * Get inherited groups.

     * Get inherited payload.

 * Description: adapt any {@link FeaturesCapable} from the core meta-model to the {@link AppendValidation} interface.<br/>
    /**
     * Create a new AppendValidationToMeta instance.
     * @param meta
     */
    /**
     * {@inheritDoc}
     */
     * {@inheritDoc}
     *
 * Description: Implements {@link BeanDescriptor}.<br/>
    /**
     * The {@link ApacheFactoryContext} (not) used by this {@link BeanDescriptorImpl} 
     */
    /**
     * Create a new BeanDescriptorImpl instance.
     * @param factoryContext
     * @param metaBean
     * @param validations
     */
    /**
     * {@inheritDoc}
     * @return the property descriptors having at least a constraint defined
     */
    /**
     * {@inheritDoc}
     */
import org.apache.bval.model.ValidationListener;
  /**
   * {@link ApacheFactoryContext} used
   */
  /**
   * {@link GroupsComputer} used
   */
  /**
   * Create a new ClassValidator instance.
   * @param factoryContext
   */
   * Create a new ClassValidator instance.
   * @param factory
   * Get the metabean finder associated with this validator.
   * {@inheritDoc}
  @SuppressWarnings("unchecked")
  public <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {
    checkGroups(groups);
          createContext(objectMetaBean, object, objectClass, groups);

   * {@inheritDoc}
  @SuppressWarnings("unchecked")
   * {@inheritDoc}
   * {@inheritDoc}
   * {@inheritDoc}
   * @param validationContext
  @SuppressWarnings("unchecked")
  protected <VL extends ValidationListener> void validateBeanNet(ValidationContext<VL> validationContext) {
    GroupValidationContext<VL> context = (GroupValidationContext<VL>) validationContext;
      final ConstraintValidationListener<VL> result = (ConstraintValidationListener<VL>) context.getListener();
  private List<Group> expandDefaultGroup(GroupValidationContext<?> context) {
  /**
   * Generate an unrecoverable validation error
   * @param ex
   * @param object
   * @return a {@link RuntimeException} of the appropriate type
   */
  protected static RuntimeException unrecoverableValidationError(RuntimeException ex,
  private void validatePropertyInGroup(GroupValidationContext<?> context) {
  /**
   * Create a {@link GroupValidationContext}.
   * @param <T>
   * @param metaBean
   * @param object
   * @param objectClass
   * @param groups
   * @return {@link GroupValidationContext} instance
   */
  /**
   * Create a {@link BeanDescriptorImpl}
   * @param metaBean
   * @return {@link BeanDescriptorImpl} instance
   */
import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;
import javax.validation.ValidationException;
import javax.validation.ValidationProviderResolver;
import javax.validation.ValidatorFactory;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

    /**
     * Configured {@link ValidationProvider}
     */
    //couldn't this be parameterized <ApacheValidatorConfiguration> or <? super ApacheValidatorConfiguration>?
    protected final ValidationProvider<?> provider;

    /**
     * Configured {@link ValidationProviderResolver}
     */

    /**
     * Configured {@link ValidationProvider} class
     */

    /**
     * Configured {@link MessageInterpolator}
     */

    /**
     * Configured {@link ConstraintValidatorFactory}
     */


    /**
     * Default {@link MessageInterpolator}
     */

    /**
     * Create a new ConfigurationImpl instance.
     * @param aState
     * @param aProvider
     */
    public ConfigurationImpl(BootstrapState aState, ValidationProvider<?> aProvider) {
    /**
     * {@inheritDoc}
     */
     * {@inheritDoc}
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
     * {@inheritDoc}
     * {@inheritDoc}
     * {@inheritDoc}
     * {@inheritDoc}
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
     * {@inheritDoc}
     * @throws ValidationException if the ValidatorFactory cannot be built
     * {@inheritDoc}
    /**
     * {@inheritDoc}
     */
    /**
     * Get the configured {@link ValidationProvider}.
     * @return {@link ValidationProvider}
     */
    public ValidationProvider<?> getProvider() {
    private ValidationProvider<?> findProvider() {
            for (ValidationProvider<?> provider : providerResolver
    /**
     * Set {@link ValidationProvider} class.
     * @param providerClass
     */
          new HashMap<Class<? extends Annotation>, Class<? extends ConstraintValidator<?,?>>[]>();
    /**
     * Record the set of validator classes for a given constraint annotation.
     * @param annotationClass
     * @param definitionClasses
     */
                                                              Class<? extends ConstraintValidator<A, ?>>[] definitionClasses) {
    /**
     * Learn whether we have cached the validator classes for the requested constraint annotation.
     * @param annotationClass to look up
     * @return boolean
     */
    /**
     * Get the cached validator classes for the requested constraint annotation.
     * @param annotationClass to look up
     * @return array of {@link ConstraintValidator} implementation types
     */
    @SuppressWarnings("unchecked")
    public <A extends Annotation> Class<? extends ConstraintValidator<A, ?>>[] getConstraintValidators(
        return (Class<? extends ConstraintValidator<A, ?>>[]) classes.get(annotationClass);
import java.lang.annotation.Annotation;
 * Description: Provides access to the default constraints/validator implementation classes built into the framework.
 * These are configured in DefaultConstraints.properties.<br/>
    private static final String DEFAULT_CONSTRAINTS =
    
    /**
     * The default constraint data stored herein.
     */
    protected Map<String, Class<? extends ConstraintValidator<?, ?>>[]> defaultConstraints;
    /**
     * Create a new ConstraintDefaults instance.
     */
        defaultConstraints = loadDefaultConstraints(DEFAULT_CONSTRAINTS);
    /**
     * Get the default constraint data.
     * @return String-keyed map
     */
    public Map<String, Class<? extends ConstraintValidator<?, ?>>[]> getDefaultConstraints() {
    /**
     * Get the default validator implementation types for the specified constraint annotation type. 
     * @param annotationType
     * @return array of {@link ConstraintValidator} implementation classes
     */
    @SuppressWarnings("unchecked")
    public <A extends Annotation> Class<? extends ConstraintValidator<A, ?>>[] getValidatorClasses(
          Class<A> annotationType) {
        return (Class<? extends ConstraintValidator<A, ?>>[]) getDefaultConstraints().get(annotationType.getName());

    @SuppressWarnings("unchecked")
    private Map<String, Class<? extends ConstraintValidator<?, ?>>[]> loadDefaultConstraints(String resource) {
        Map<String, Class<? extends ConstraintValidator<?, ?>>[]> loadedConstraints
                = new HashMap<String, Class<? extends ConstraintValidator<?,?>>[]>();
  /** Serialization version */
  private static final long serialVersionUID = 1L;

  /**
   * Create a new ConstraintDescriptorImpl instance.
   * @param descriptor
   */
  /**
   * Create a new ConstraintDescriptorImpl instance.
   * @param annotation
   * @param groups
   * @param payload
   * @param constraintValidatorClasses
   * @param attributes
   * @param composingConstraints
   * @param reportAsSingleViolation
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
import javax.validation.metadata.ElementDescriptor.ConstraintFinder;
 * Description: Implementation of the fluent {@link ConstraintFinder} interface.<br/>
    private Set<ConstraintValidation<?>> constraintDescriptors;
    /**
     * Create a new ConstraintFinderImpl instance.
     * @param metaBean
     * @param constraintDescriptors
     */
    ConstraintFinderImpl(MetaBean metaBean, Set<ConstraintValidation<?>> constraintDescriptors) {
    /**
     * {@inheritDoc}
     */
        Set<ConstraintValidation<?>> matchingDescriptors =
              new HashSet<ConstraintValidation<?>>(constraintDescriptors.size());
                    for (ConstraintValidation<?> descriptor : constraintDescriptors) {
                for (ConstraintValidation<?> descriptor : constraintDescriptors) {
    /**
     * {@inheritDoc}
     */
            for (Iterator<ConstraintValidation<?>> it = constraintDescriptors.iterator(); it.hasNext(); ) {
                ConstraintValidation<?> cv = it.next();
    /**
     * {@inheritDoc}
     */
        Set<ConstraintValidation<?>> matchingDescriptors =
              new HashSet<ConstraintValidation<?>>(constraintDescriptors.size());
            for (ConstraintValidation<?> descriptor : constraintDescriptors) {
    private boolean isAtElement(ConstraintValidation<?> descriptor, ElementType each) {
    private boolean isInScope(ConstraintValidation<?> descriptor) {
            Class<?> owner = descriptor.getOwner();
    private boolean isInGroup(ConstraintValidation<?> descriptor, Group group) {
          Set<ConstraintValidation<?>> matchingDescriptors) {
    /**
     * {@inheritDoc}
     */
    @SuppressWarnings("unchecked")
    /**
     * {@inheritDoc}
     */

import java.io.Serializable;

  private final ConstraintValidator<T, ?> validator;
  private final Class<?> owner;
   * Create a new ConstraintValidation instance.
   * @param validatorClasses
   * @param reportFromComposite
      ConstraintValidator<T, ?> validator, T annotation, Class<?> owner,
    this.attributes = new HashMap<String, Object>();
  /**
   * Return a {@link Serializable} {@link ConstraintDescriptor} capturing a snapshot of current state.
   * @return {@link ConstraintDescriptor}
   */
    return new ConstraintDescriptorImpl<T>(this);
  /**
   * Set the applicable validation groups.
   * @param groups
   */
  /**
   * Set the payload.
   * @param payload
   */
  /**
   * {@inheritDoc}
   */
  /**
   * Add a composing constraint.
   * @param aConstraintValidation to add
   */
  public void addComposed(ConstraintValidation<?> aConstraintValidation) {
      composedConstraints = new HashSet<ConstraintValidation<?>>();
  /**
   * {@inheritDoc}
   */
  public <L extends ValidationListener> void validate(ValidationContext<L> context) {
    validate((GroupValidationContext<L>) context);
  /**
   * Validate a {@link GroupValidationContext}.
   * @param context root
   */
  public <L extends ValidationListener> void validate(GroupValidationContext<L> context) {
      for (ConstraintValidation<?> composed : getComposingValidations()) {
      if (!((ConstraintValidator<T, Object>) validator).isValid(context.getValidatedValue(), jsrContext)) {
  private boolean isReachable(GroupValidationContext<?> context) {
  private void addErrors(GroupValidationContext<?> context,
  /**
   * {@inheritDoc}
   */
  /**
   * Get the message template used by this constraint.
   * @return String
   */
  /**
   * Get the {@link ConstraintValidator} invoked by this {@link ConstraintValidation}.
   * @return
   */
  public ConstraintValidator<T, ?> getValidator() {
  /**
   * Learn whether this {@link ConstraintValidation} belongs to the specified group.
   * @param reqGroup
   * @return boolean
   */
  /**
   * Get the owning class of this {@link ConstraintValidation}.
   * @return Class
   */
  public Class<?> getOwner() {
  /**
   * {@inheritDoc}
   */
  /**
   * Get the {@link AccessStrategy} used by this {@link ConstraintValidation}.
   * @return {@link AccessStrategy}
   */
  /**
   * Override the Annotation set at construction.
   * @param annotation
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  @SuppressWarnings("unchecked")
  /**
   * Get the composing {@link ConstraintValidation} objects.  This is effectively
   * an implementation-specific analogue to {@link #getComposingConstraints()}.
   * @return {@link Set} of {@link ConstraintValidation}
   */
  @SuppressWarnings("unchecked")
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
 * Description: JSR-303 {@link ValidationListener} implementation; provides {@link ConstraintViolation}s.<br/>
    private final Set<ConstraintViolation<T>> constraintViolations = new HashSet<ConstraintViolation<T>>();
    /**
     * Create a new ConstraintValidationListener instance.
     * @param aRootBean
     * @param rootBeanType
     */
    /**
     * {@inheritDoc}
     */
    public <VL extends ValidationListener> void addError(String reason, ValidationContext<VL> context) {
    /**
     * {@inheritDoc}
     */
    public <VL extends ValidationListener> void addError(Error error, ValidationContext<VL> context) {
                          ValidationContext<?> context) {
        final ConstraintDescriptor<?> descriptor;
        if (context instanceof GroupValidationContext<?>) {
            GroupValidationContext<?> gcontext = (GroupValidationContext<?>) context;
        constraintViolations.add(ic);
    /**
     * Get the {@link ConstraintViolation}s accumulated by this {@link ConstraintValidationListener}.
     * @return {@link Set} of {@link ConstraintViolation}
     */
    //TODO rename method for correct spelling
        return constraintViolations;
    /**
     * Learn whether no violations were found. 
     * @return boolean
     */
        return constraintViolations.isEmpty();
    /**
     * Get the root bean.
     * @return T
     */
    /**
     * Get the root bean type of this {@link ConstraintValidationListener}.
     * @return Class<T>
     */
    /**
     * Get the count of encountered violations.
     * @return int
     */
        return constraintViolations.size();

import javax.validation.ConstraintValidator;
 * Description: Short-lived {@link ConstraintValidatorContext} implementation passed by
 * a {@link ConstraintValidation} to its adapted {@link ConstraintValidator}. <br/>
    private final ConstraintValidation<?> constraintDescriptor;
    private final GroupValidationContext<?> validationContext;
    /**
     * Create a new ConstraintValidatorContextImpl instance.
     * @param validationContext
     * @param aConstraintValidation
     */
    public ConstraintValidatorContextImpl(GroupValidationContext<?> validationContext,
                                          ConstraintValidation<?> aConstraintValidation) {
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
        /**
         * Create a new ConstraintViolationBuilderImpl instance.
         * @param contextImpl
         * @param template
         * @param path
         */
        /**
         * {@inheritDoc}
         */
        /**
         * {@inheritDoc}
         */
    /**
     * Get the queued error messages.
     * @return List
     */
    /**
     * Get this {@link ConstraintValidatorContext}'s {@link GroupValidationContext}.
     * @return {@link GroupValidationContext}
     */
    public GroupValidationContext<?> getValidationContext() {
    /**
     * Add an error message to this {@link ConstraintValidatorContext}.
     * @param messageTemplate
     * @param propertyPath
     */
    /**
     * Create a new ConstraintValidatorIdentity instance.
     * @param bean
     * @param path
     * @param constraintValidator
     */
    /**
     * Get the referenced bean.
     * @return Object
     */
    /**
     * Get the referenced property {@link Path}.
     * @return Path
     */
    /**
     * Get the associated {@link ConstraintValidator}.
     * @return {@link ConstraintValidator}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /** Serialization version */
    private static final long serialVersionUID = 1L;

    private final ConstraintDescriptor<?> constraintDescriptor;
     * Create a new ConstraintViolationImpl instance.
     * @param rootBeanClass
     * @param elementType
                                   ConstraintDescriptor<?> constraintDescriptor, Class<T> rootBeanClass, ElementType elementType) {
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     * @return Root bean being validated
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     * @return The value failing to pass the constraint
     */
     * {@inheritDoc}
     * @return the property path to the value from <code>rootBean</code>
     *         Null if the value is the rootBean itself
    /**
     * {@inheritDoc}
     */
    public ConstraintDescriptor<?> getConstraintDescriptor() {
    /**
     * {@inheritDoc}
     */
    @Override
    /**
     * {@inheritDoc}
     */
     * {@inheritDoc}
    /** Builtin resource bundles hashed against their locale. */
    /**
     * Create a new DefaultMessageInterpolator instance.
     */
    /**
     * Create a new DefaultMessageInterpolator instance.
     * @param resourceBundle
     */
        return interpolate(message, context, defaultLocale);
    /**
     * Set the default locale used by this {@link DefaultMessageInterpolator}.
     * @param locale
     */
    /**
     * {@inheritDoc}
        List<ValidationProvider<?>> providers = new ArrayList<ValidationProvider<?>>();
                                providers.add((ValidationProvider<?>) SecureActions.newInstance(provider));
    /**
     * {@inheritDoc}
     *  @return Statically defined returned type.
     */
    /**
     * {@inheritDoc}
     */
    @SuppressWarnings("unchecked")
        return new ConstraintFinderImpl(metaBean, (Set) constraintDescriptors);
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     * return true if at least one constraint declaration is present on the element.
     */
            if (validation instanceof ConstraintValidation<?>) {
                ConstraintValidation<?> cval = (ConstraintValidation<?>) validation;
    /**
     * Set the constraintDescriptors for this element.
     * @param constraintDescriptors to set
     */
    /**
     * Get the model {@link MetaBean} used.
     * @return MetaBean
     */
 * FIXME: Owner is currently not used in identity checking, and probably
 * never will be.  So it is likely to be deleted.
    /**
     * Create a new GraphBeanIdentity instance.
     * @param bean
     * @param group
     * @param owner
     */
    /**
     * Get the bean.
     * @return Object
     */
    /**
     * Get the group being validated.
     * @return Class
     */
    /**
     * Get the owning class
     * @return
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
 * Description: JSR-303 {@link ValidationContext} extension. <br/>
    
    /**
     * Get the groups of this {@link GroupValidationContext}.
     * @return the groups in their sequence for validation
     */
    /**
     * Set the current {@link Group}.
     * @param group to set
     */
    /**
     * Get the current {@link Group}.
     * @return Group
     */
    /**
     * Get the property path.
     * @return {@link PathImpl}
     */
    /**
     * Get the root {@link MetaBean}.
     * @return {@link MetaBean}
     */
    /**
     * Set the {@link ConstraintValidation}.
     * @param constraint to set
     */
    void setConstraintValidation(ConstraintValidation<?> constraint);
    /**
     * Get the {@link ConstraintValidation}.
     * @return {@link ConstraintValidation}
     */
    ConstraintValidation<?> getConstraintValidation();
    /**
     * Get the value being validated.
     * @return Object
     */
    Object getValidatedValue();
    /**
     * Set a fixed value for the context.
     * @param value to set
     */
    /**
     * Get the message resolver.
     * @return {@link MessageInterpolator}
     */
    /**
     * Get the {@link TraversableResolver}.
     * @return {@link TraversableResolver}
     */
    /**
     * Accumulate a validated constraint.
     * @param constraint
     * @return true when the constraint for the object in this path was not
     *         already validated in this context
     */
    boolean collectValidated(ConstraintValidator<?, ?> constraint);

    /**
     * Get the current owning class.
     * @return Class
     */

    /**
     * Set the current owning class.
     * @param currentOwner to set
     */

  private ConstraintValidation<?> constraintValidation;
  /**
   * Create a new GroupValidationContextImpl instance.
   * @param listener
   * @param aMessageResolver
   * @param traversableResolver
   * @param rootMetaBean
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
   * {@inheritDoc}
   * Here, state equates to bean identity  group.
  @SuppressWarnings("unchecked")
   * {@inheritDoc}
  public boolean collectValidated(ConstraintValidator<?, ?> constraint) {
  /**
   * Reset the validated constraints.
   */
   * {@inheritDoc}
   * If an associated object is validated,
  /**
   * {@inheritDoc}
   */
  /**
   * Set the Groups.
   * @param groups
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  public void setConstraintValidation(ConstraintValidation<?> constraint) {
  /**
   * {@inheritDoc}
   */
  public ConstraintValidation<?> getConstraintValidation() {
   * {@inheritDoc}
   */
  public ConstraintDescriptor<?> getConstraintDescriptor() {
    return constraintValidation;
  }

  /**
   * {@inheritDoc}
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
    /**
     * JSR303 Property features
     */
    /**
     * JSR303 bean features
     */
    /** Shared log instance */ //of dubious utility as it's static :/
    /** Constant for the "value" annotation attribute specified in JSR303*/
    /** {@link ApacheFactoryContext} used */
    /**
     * Create a new Jsr303MetaBeanFactory instance.
     * @param factoryContext
     */
     * {@inheritDoc}
     * Add the validation features to the metabean that come from JSR303
     * annotations in the beanClass.
     * Process class annotations, field and method annotations.
     * @param beanClass
     * @param metabean

    /**
     * Learn whether a given Method has validation constraints defined via JSR303 annotations.
     * @param method
     * @return <code>true</code> if constraints detected
     */

    /**
     * Add cascade validation and constraints from xml mappings
     * @param beanClass
     * @param metabean
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    @SuppressWarnings("unchecked")
            Class<? extends ConstraintValidator<? extends Annotation, ?>>[] constraintClasses =
            applyConstraint(
                    (Annotation) meta.getAnnotation(),
                    (Class<? extends ConstraintValidator<Annotation, ?>>[]) constraintClasses,
                    metaProperty, beanClass, meta.getAccessStrategy(),
                    new AppendValidationToMeta(metaProperty == null ? metabean
                            : metaProperty));
    private <A extends Annotation> boolean processAnnotation(A annotation, MetaProperty prop, Class<?> owner,
                Class<? extends ConstraintValidator<A, ?>>[] validatorClasses;
    /**
     * Find available {@link ConstraintValidation} classes for a given constraint annotation.
     * @param annotation
     * @param vcAnno
     * @return {@link ConstraintValidation} implementation class array
     */
    @SuppressWarnings("unchecked")
    protected <A extends Annotation> Class<? extends ConstraintValidator<A, ?>>[] findConstraintValidatorClasses(
          A annotation, Constraint vcAnno) {
        Class<? extends ConstraintValidator<A, ?>>[] validatorClasses;
        Class<A> annotationType = (Class<A>) annotation.annotationType();
              .getConstraintValidators(annotationType);
            validatorClasses = (Class<? extends ConstraintValidator<A, ?>>[]) vcAnno.validatedBy();
                      .getValidatorClasses(annotationType);
     * Apply a constraint to the specified <code>appender</code>.
     * @param annotation constraint annotation
     * @param constraintClasses known {@link ConstraintValidator} implementation classes for <code>annotation</code>
     * @param prop meta-property
     * @param owner type
     * @param access strategy
     * @param appender
     * @return success flag
    /*
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    protected <A extends Annotation> boolean applyConstraint(A annotation,
                                      Class<? extends ConstraintValidator<A, ?>>[] constraintClasses,
        final ConstraintValidator<A, ?> validator;
            Map<Type, Class<? extends ConstraintValidator<A, ?>>> validatorTypes =
                  (Map<Type, Class<? extends ConstraintValidator<A, ?>>>) TypeUtils.getValidatorsTypes(constraintClasses);
        final AnnotationConstraintBuilder<A> builder = new AnnotationConstraintBuilder<A>(
    /**
     * Create a new NestedMetaProperty instance.
     * @param path
     * @param value
     */
    /**
     * Parse this {@link NestedMetaProperty}.
     */
    void parse() {
    /**
     * Get the resolved MetaProperty.
     * @return MetaProperty
     */
    /**
     * Get the property path.
     * @return String path
     */
    /**
     * Learn whether the {@link MetaProperty} represented is indeed nested.
     * @return boolean
     */
    /**
     * Set the MetaProperty directly
     * @param aMetaProperty to set
     */
    /**
     * Get the resolved MetaBean.
     * @return MetaBean
     */
    /**
     * Set the MetaBean directly
     * @param metaBean to set
     */
    /**
     * Get the property value referenced.
     * @return Object
     */
    /**
     * Set the property value directly.
     * @param value to set
     */
    /**
     * Get the declared type of a Member.
     * @param member
     * @return generic type
     */
    /**
     * Get the component type of an indexed type.
     * @param type
     * @return Type
     */
    /**
     * Resolve the raw type of a Collection.
     * @param type
     * @return Class if found
     */
    @SuppressWarnings("unchecked")
    /**
     * Learn whether a particular type represents an array.
     * @param type
     * @return boolean
     */
     * Learn whether <code>type</code> is a {@link Collection} type.
    /**
     * Learn whether <code>clazz</code> implements either {@link Collection} or {@link Map}.
     * @param clazz
     * @return boolean
     */
    //TODO should all these Collection references be Iterable?
 * Description: {@link PropertyDescriptor} implementation.<br/>
    /**
     * Create a new PropertyDescriptorImpl instance.
     * @param metaBean
     * @param propertyPath
     * @param validations
     */
    /**
     * Create a new PropertyDescriptorImpl instance.
     * @param elementClass
     * @param validations
     */
    /**
     * Set whether the referenced property is cascaded.
     * @param cascaded
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Set the referenced property path.
     * @param propertyPath
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Create a new UnknownPropertyException instance.
     * @param message
     */
    /**
     * Create a new UnknownPropertyException instance.
     */
    /**
     * Create a new UnknownPropertyException instance.
     * @param message
     * @param cause
     */
    /**
     * Create a new UnknownPropertyException instance.
     * @param cause
     */
import org.apache.bval.jsr303.AppendValidation;
 * Description: {@link AppendValidation} implementation that acts as an intermediate
 * cache of validations for further processing.<br/>
    /**
     * Create a new AppendValidationToList instance.
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Get the list of cached validations.
     * @return {@link List} of {@link ConstraintValidation}
     */
    /**
     * Get the list of {@link ParameterDescriptor}s.
     * @return {@link List} of {@link ParameterDescriptor}
     */
    /**
     * Learn whether the referenced constructor should be validated.
     * @return
     */
 * Description: {@link ConstructorDescriptor} implementation.<br/>
    /**
     * Create a new ConstructorDescriptorImpl instance.
     * @param metaBean
     * @param validations
     */
    /**
     * Create a new ConstructorDescriptorImpl instance.
     * @param elementClass
     * @param validations
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
 * Description: Provides method/constructor-related constraint information
 * for a type.  This class will disappear when such
    /**
     * Get the constraints that apply to a particular method.
     * @param method
     * @return {@link MethodDescriptor}
     */
    /**
     * Get the constraints that apply to a particular constructor.
     * @param constructor
     * @return {@link ConstructorDescriptor}
     */
    /**
     * Get the set of constrained methods.
     * @return {@link Set} of {@link MethodDescriptor}
     */
    /**
     * Get the set of constrained constructors.
     * @return {@link Set} of {@link ConstructorDescriptor}
     */
 * Description: {@link MethodBeanDescriptor} implementation.<br/>
    /**
     * Create a new MethodBeanDescriptorImpl instance.
     * @param factoryContext
     * @param metaBean
     * @param validations
     */
    /**
     * Set the map of method constraints for this bean.
     * @param methodConstraints
     */
    /**
     * Set the map of constructor constraints for this bean.
     * @param constructorConstraints
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Add a {@link MethodDescriptor} to this {@link MethodBeanDescriptorImpl}.
     * @param method
     * @param desc
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Add a {@link ConstructorDescriptor} to this {@link MethodBeanDescriptorImpl}.
     * @param cons
     * @param desc
     */
    /**
     * Get the configured method constraints.
     * @return {@link Map} of {@link Method} : {@link MethodDescriptor}
     */
    /**
     * Get the configured constructor constraints.
     * @return {@link Map} of {@link Constructor} : {@link ConstructorDescriptor}
     */
    /**
     * Get the {@link ParameterDescriptor}s for this {@link MethodDescriptor}.
     * @return {@link List} of {@link ParameterDescriptor}
     */
    /**
     * Learn whether the referenced method should be validated.
     * @return boolean
     */
 * Description: {@link MethodDescriptor} implementation.<br/>
    /**
     * Create a new MethodDescriptorImpl instance.
     * @param metaBean
     * @param validations
     */
    /**
     * Create a new MethodDescriptorImpl instance.
     * @param elementClass
     * @param validations
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
  /**
   * Create a new MethodValidatorImpl instance.
   * @param factoryContext
   */
   * @param factoryContext
  /**
   * {@inheritDoc}
   */
   * {@inheritDoc}
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
  /**
   * {@inheritDoc}
   */
   * {@inheritDoc}
  @SuppressWarnings("unchecked")
    ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
  @SuppressWarnings("unchecked")
        ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
      return Collections.<ConstraintViolation<T>> emptySet();
  @SuppressWarnings("unchecked")
      final ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
    for (ConstraintDescriptor<?> consDesc : paramDesc.getConstraintDescriptors()) {
      ConstraintValidation<?> validation = (ConstraintValidation<?>) consDesc;
    for (ConstraintDescriptor<?> consDesc : methodDescriptor.getConstraintDescriptors()) {
      ConstraintValidation<?> validation = (ConstraintValidation<?>) consDesc;
 * Description: extension to validate parameters/return values of methods/constructors.<br/>
  /**
   * Create a new MethodValidatorMetaBeanFactory instance.
   * @param factoryContext
   */
  /**
   * {@inheritDoc}
   */
  /**
   * Finish building the specified {@link MethodBeanDescriptorImpl}.
   * @param descriptor
   */
  private <A extends Annotation> void processAnnotation(A annotation, ProcedureDescriptor desc,
        Class<? extends ConstraintValidator<A, ?>>[] validatorClasses;
            ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations);
    /**
     * Create a new ParameterAccess instance.
     * @param paramType
     * @param paramIdx
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Get the index of the referenced parameter.
     * @return int
     */
 * Description: {@link ParameterDescriptor} implementation.<br/>
    /**
     * Create a new ParameterDescriptorImpl instance.
     * @param metaBean
     * @param validations
     */
    /**
     * Create a new ParameterDescriptorImpl instance.
     * @param elementClass
     * @param validations
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Set whether the referenced parameter descriptor should be validated.
     * @param cascaded
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Set the index of the referenced parameter.
     * @param index
     */
 * Description: superinterface of {@link ConstructorDescriptor} and {@link MethodDescriptor}.<br/>
    /**
     * Get the owning metabean.
     * @return MetaBean
     */
    /**
     * Set whether this procedure should be validated.
     * @param b
     */
    /**
     * Get the parameter descriptors of this procedure.
     * @return {@link List} of {@link ParameterDescriptor}
     */
    /**
     * Create a new ReturnAccess instance.
     * @param returnType
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
 * Immutable object that wraps an interface representing a single group.

    /**
     * Create a new Group instance.
     * @param group
     */
    /**
     * Get the actual group class.
     * @return
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Learn whether the group represented is the default group.
     * @return boolean
     */
	/**
	 * {@inheritDoc}
	 */
    /**
     * {@inheritDoc}
     */
 * Defines the order to validate groups during validation.
    /**
     * Get the Groups.
     * @return {@link List} of {@link Group}.
     */
    /**
     * Get the Group sequences.
     * @return {@link List} of {@link List} of {@link Group}
     */
    /**
     * Insert a {@link Group}.
     * @param group to insert
     */
    /**
     * Insert a sequence.
     * @param groups {@link List} of {@link Group} to insert
     */
    /**
     * Assert that the default group can be expanded to <code>defaultGroups</code>.
     * @param defaultGroups
     */
    /**
     * Get the default group array.
     * @return <code>{@link Default}.class</code> only
     */
    /**
     * Compute groups from an array of group classes.
     * @param groups
     * @return {@link Groups}
     */
    /**
     * Main compute implementation.
     * @param groups
     * @return {@link Groups}
     */
import javax.validation.TraversableResolver;

 * whether results of traversable resolver should be cached.<br/>
    /**
     * Learn whether the results of the {@link TraversableResolver} should be cached.
     * @return boolean
     */
    /**
     * Convenience method to check whether caching is necessary on a given {@link TraversableResolver}.
     * @param resolver to check
     * @return true when a CachingTraversableResolver is to be used during validation
     */
    /**
     * Create a new CachingTraversableResolver instance.
     * @param delegate
     */
    /**
     * If necessary, return a caching wrapper for the specified {@link TraversableResolver}.
     * @param traversableResolver
     * @return {@link TraversableResolver}
     * @see #needsCaching(TraversableResolver)
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Entry in the cache.
     */
        /**
         * Create a new CacheEntry instance.
         * @param traversableObject
         * @param traversableProperty
         * @param rootBeanType
         * @param pathToTraversableObject
         * @param elementType
         */
        /**
         * {@inheritDoc}
         */
        /**
         * {@inheritDoc}
         */
    /**
     * Create a new DefaultTraversableResolver instance.
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    @SuppressWarnings("unchecked")
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
 * Description: traversable resolver that does always resolve.<br/>
    /**
     * {@inheritDoc}
     *  @return <code>true</code>
     */
    /**
     * {@inheritDoc}
     * @return <code>true</code>
     */
    /**
     * {@inheritDoc}
     * @return <code>false</code>
     */
 * Common operations on classes that do not require an {@link AccessController}.
 * Description: implementation of {@link NodeBuilderCustomizableContext}.<br/>
    /**
     * Create a new NodeBuilderCustomizableContextImpl instance.
     * @param contextImpl
     * @param template
     * @param path
     * @param name
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
 * Description: Implementation of {@link NodeBuilderDefinedContext}.<br/>
    /**
     * Create a new NodeBuilderDefinedContextImpl instance.
     * @param contextImpl
     * @param template
     * @param path
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
import javax.validation.ConstraintValidatorContext.ConstraintViolationBuilder.NodeContextBuilder;
 * Description: Implementation of {@link NodeContextBuilder}.<br/>
    /**
     * Create a new NodeContextBuilderImpl instance.
     * @param contextImpl
     * @param template
     * @param path
     * @param name
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
import java.util.Map;
    /**
     * Create a new NodeImpl instance.
     * @param name
     */
    /**
     * Create a new NodeImpl instance.
     * @param node
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Set whether this node represents a contained value of an {@link Iterable} or {@link Map}.
     * @param inIterable
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Set the index of this node, implying <code>inIterable</code>.
     * @param index
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Set the map key of this node, implying <code>inIterable</code>.
     * @param key
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    private static final String PROPERTY_PATH_SEPARATOR = ".";
    /**
     * Create a {@link PathImpl} instance representing the specified path.
     * @param name
     * @return PathImpl
     */
    /**
     * Copy another Path.
     * @param path
     * @return new {@link PathImpl}
     */
    /**
     * Learn whether this {@link PathImpl} points to the root of its graph.
     * @return true if no child nodes
     */
    //our implementation stores a nameless root node.
    /**
     * Return a new {@link PathImpl} that represents <code>this</code> minus its leaf node (if present). 
     * @return PathImpl
     */
    /**
     * Add a node to this {@link PathImpl}.
     * @param node to add
     */
    /**
     * Trim the leaf node from this {@link PathImpl}.
     * @return the node removed
     * @throws IllegalStateException if no nodes are found
     */
        //TODO what if isRootNode()?
    /**
     * Get the leaf node (if any) from this {@link PathImpl}
     * @return {@link NodeImpl}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * Learn whether <code>path</code> is a parent to <code>this</code>.
     * @param path
     * @return <code>true</code> if our nodes begin with nodes equal to those found in <code>path</code>
     */
        if (path instanceof PathImpl && ((PathImpl) path).isRootPath()) {
    /**
     * {@inheritDoc}
     */
                builder.append(PROPERTY_PATH_SEPARATOR);
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
     * Create a new instance of the class using the default no-arg constructor.
    /**
     * Create a new instance of a specified class, rethrowing {@link ValidationException}.
     *
     * @param <T>
     * @param cls - the class (no interface, non-abstract, has accessible matching constructor)
     * @param paramTypes
     * @param values
     * @return a new instance
     */
    /**
     * Load a class.
     * @param className
     * @param caller
     * @return loaded Class instance
     */
    /**
     * Get a field declared on a given class.
     * @param clazz
     * @param fieldName
     * @return Field found
     */
     * @param clazz
     * @param methodName
    /**
     * Get the method of <code>methodName</code> available on <code>clazz</code>.
     * @param clazz
     * @param methodName
     * @return {@link Method} found
     */
    /**
     * Get methods declared on <code>clazz</code>.
     * @param clazz
     * @return {@link Method} array
     */
    /**
     * Get the constructor of <code>clazz</code> matching <code>params</code>.
     * @param <T>
     * @param clazz
     * @param params
     * @return {@link Constructor} found
     */
import java.lang.annotation.Annotation;
    /**
     * Given a set of {@link ConstraintValidator} implementation classes, map those
     * to their target types.
     * @param validators
     * @return {@link Map} of {@link Type} : {@link ConstraintValidator} subtype
     */
    public static <A extends Annotation> Map<Type, Class<? extends ConstraintValidator<A, ?>>> getValidatorsTypes(
          Class<? extends ConstraintValidator<A, ?>>[] validators) {
        Map<Type, Class<? extends ConstraintValidator<A, ?>>> validatorsTypes =
              new HashMap<Type, Class<? extends ConstraintValidator<A, ?>>>();
        for (Class<? extends ConstraintValidator<A, ?>> validator : validators) {
    /**
     * Learn whether <code>type</code> is assignable to <code>supertype</code>.
     * @param supertype
     * @param type
     * @return boolean
     */
    /**
     * Record the ignore state for a particular annotation type.
     * @param clazz
     * @param b, default true if null
     */
        ignoreAnnotationDefaults.put(clazz, b == null || b.booleanValue());
    /**
     * Learn whether the specified annotation type should be ignored.
     * @param clazz
     * @return boolean
     */
        return ignoreAnnotationDefaults.containsKey(clazz)
                && ignoreAnnotationDefaults.get(clazz);
    /**
     * Ignore annotations on a particular {@link Member} of a class.
     * @param member
     */
        List<Member> memberList = ignoreAnnotationOnMember.get(beanClass);
        if (memberList == null) {
            memberList = new ArrayList<Member>();
            ignoreAnnotationOnMember.put(beanClass, memberList);
        memberList.add(member);
    /**
     * Learn whether annotations should be ignored on a particular {@link Member} of a class.
     * @param member
     * @return boolean
     */
    /**
     * Record the ignore state of a particular class. 
     * @param clazz
     * @param b
     */
    /**
     * Learn whether annotations should be ignored for a given class.
     * @param clazz to check
     * @return boolean
     */
//TODO confirm that this class must be public for RT invocation purposes, then document this fact
//TODO move this guy up to org.apache.bval.jsr303 or org.apache.bval.jsr303.model
    /** Serialization version */
    private static final long serialVersionUID = 1L;

    /**
     * Create a new AnnotationProxy instance.
     * @param <A>
     * @param descriptor
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
    /**
     * {@inheritDoc}
     */
//TODO move this guy up to org.apache.bval.jsr303 or org.apache.bval.jsr303.model
    //TODO extract these to some neutral location; see AnnotationConstraintBuilder
    /**
     * Create a new AnnotationProxyBuilder instance.
     * @param annotationType
     */
    /**
     * Create a new AnnotationProxyBuilder instance.
     * @param annotationType
     * @param elements
     */
        this(annotationType);
     * Create a builder initially configured to create an annotation equivalent to <code>annot</code>.
     *
    @SuppressWarnings("unchecked")
        this((Class<A>) annot.annotationType());
    /**
     * Add an element to the configuration.
     * @param elementName
     * @param value
     */
    /**
     * Get the specified element value from the current configuration.
     * @param elementName
     * @return Object value
     */
    /**
     * Learn whether a given element has been configured.
     * @param elementName
     * @return <code>true</code> if an <code>elementName</code> element is found on this annotation
     */
    /**
     * Get the number of configured elements.
     * @return int
     */
    /**
     * Get the configured Annotation type.
     * @return Class<A>
     */
    /**
     * Configure the well-known JSR303 "message" element.
     * @param message
     */
    /**
     * Configure the well-known JSR303 "groups" element.
     * @param groups
     */
    /**
     * Configure the well-known JSR303 "payload" element.
     * @param payload
     */
    /**
     * Create the annotation represented by this builder.
     * @return {@link Annotation}
     */
    @SuppressWarnings("unchecked")
//TODO move this guy up to org.apache.bval.jsr303 or org.apache.bval.jsr303.model
//to decouple ApacheValidatorFactory from xml package and allow others to consume MetaConstraint
     * Create a new MetaConstraint instance.
     * @param annotation
    /**
     * Get the bean class of this constraint.
     * @return Class
     */
    /**
     * Get the member to which this constraint applies.
     * @return Member
     */
    /**
     * Get the annotation that defines this constraint.
     * @return Annotation
     */
    /**
     * Get the access strategy used for the associated property.
     * @return {@link AccessStrategy}
     */
@SuppressWarnings("restriction")
    private final Set<Class<?>> processedClasses;
    /**
     * Create a new ValidationMappingParser instance.
     * @param factory
     */
        this.processedClasses = new HashSet<Class<?>>();
     * Parse files with constraint mappings and collect information in the factory.
    @SuppressWarnings("unchecked")
    @SuppressWarnings("unchecked")
        } else if (serializable instanceof JAXBElement<?> &&
              ((JAXBElement<?>) serializable).getDeclaredType()
        } else if (serializable instanceof JAXBElement<?> &&
              ((JAXBElement<?>) serializable).getDeclaredType()
                Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) returnType;
    @SuppressWarnings("unchecked")
    @SuppressWarnings("unchecked")
@SuppressWarnings("restriction")
    /**
     * Create a new ValidationParser instance.
     * @param file
     */
    /**
     * Process the validation configuration into <code>targetConfig</code>.
     * @param targetConfig
     */
    /**
     * Get a Schema object from the specified resource name.
     * @param xsd
     * @return {@link Schema}
     */
    @SuppressWarnings("unchecked")
    @SuppressWarnings("unchecked")
    @SuppressWarnings("unchecked")
    @SuppressWarnings("unchecked")
  protected MetaBeanManager buildMetaBeanManager() {
    // NOTE - We return MetaBeanManager instead of XMLMetaBeanManager to keep
    //        bval-xstream an optional module.
    protected static MetaBeanManager createXMLMetaBeanManager(List<MetaBeanFactory> builders) {
}
      return result.getConstraintViolations();
      return result.getConstraintViolations();
      return result.getConstraintViolations();
      if (!listener.getConstraintViolations().isEmpty()) {
    public Set<ConstraintViolation<T>> getConstraintViolations() {
    return result.getConstraintViolations();
        return result.getConstraintViolations();
      return result.getConstraintViolations();
     * Create the {@link MetaBeanManager} to process JSR303 XML.  Requires bval-xstream at RT.
     * @return {@link MetaBeanManager}
      final GroupValidationContext<T> context =
      GroupValidationContext<T> context =
      GroupValidationContext<T> context =
  protected <T> GroupValidationContext<T> createContext(
    GroupValidationContextImpl<T> context =
        new GroupValidationContextImpl<T>(listener,
    validate((GroupValidationContext<?>) context);
  public void validate(GroupValidationContext<?> context) {
      ConstraintValidationListener<?> listener = context.getListener();
      listener.beginReportAsSingle();

      boolean failed = false;
          // stop validating when already failed and ReportAsSingleInvalidConstraint = true ?
          for (Iterator<ConstraintValidation<?>> composed = getComposingValidations().iterator(); !failed && composed.hasNext();) {
              composed.next().validate(context);
              failed = listener.hasViolations();
          }
          listener.endReportAsSingle();
          // Restore current constraint validation
          context.setConstraintValidation(this);
      if (failed) {
import java.util.concurrent.atomic.AtomicInteger;
    // TODO: Currently there is no need for atomicity here as all the validation process
    //       is single-threaded and it's unlikely to change in the near future.
    private final AtomicInteger compositeDepth = new AtomicInteger(0);
    private boolean hasCompositeError;
        if (compositeDepth.get() > 0) {
            hasCompositeError |= true;
            return;
        }
    /**
     * Learn whether there are violations available.
     * If in report-as-single-violation mode, the result is scoped accordingly.
     * Note that this means you must check before exiting report-as-single-violation mode
     * @return boolean
     */
    public boolean hasViolations() {
        return compositeDepth.get() == 0 ? !constraintViolations.isEmpty() : hasCompositeError; 
    }

    /**
     * Signify the beginning of a report-as-single-violation composite validation.
     * @return <code>true</code> as this call caused the listener to enter report-as-single-violation mode
     */
    public boolean beginReportAsSingle() {
        return compositeDepth.incrementAndGet() == 1;
    }

    /**
     * Signify the end of a report-as-single-violation composite validation.
     * @return <code>true</code> as this call caused the listener to exit report-as-single-violation mode
     */
    public boolean endReportAsSingle() {
        return compositeDepth.decrementAndGet() == 0;
    }
public interface GroupValidationContext<T>
      extends ValidationContext<ConstraintValidationListener<T>> {
final class GroupValidationContextImpl<T>
    extends BeanValidationContext<ConstraintValidationListener<T>>
  public GroupValidationContextImpl(ConstraintValidationListener<T> listener, MessageInterpolator aMessageResolver,
    final GroupValidationContext<Object> context =
      final GroupValidationContext<Object> context =
      GroupValidationContext<T> context,
      GroupValidationContext<T> context,
    if (!(value instanceof CharSequence)) return false;
    CharSequence seq = (CharSequence) value;
    if (seq.length() == 0) return true;
    Matcher m = aPattern.matcher(seq);
public class EmailValidator implements ConstraintValidator<Email, CharSequence> {
    public boolean isValid(CharSequence value, ConstraintValidatorContext context) {
// TODO: Remove
///**
// *  Licensed to the Apache Software Foundation (ASF) under one or more
// *  contributor license agreements.  See the NOTICE file distributed with
// *  this work for additional information regarding copyright ownership.
// *  The ASF licenses this file to You under the Apache License, Version 2.0
// *  (the "License"); you may not use this file except in compliance with
// *  the License.  You may obtain a copy of the License at
// *
// *     http://www.apache.org/licenses/LICENSE-2.0
// *
// *  Unless required by applicable law or agreed to in writing, software
// *  distributed under the License is distributed on an "AS IS" BASIS,
// *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// *  See the License for the specific language governing permissions and
// *  limitations under the License.
// */
//package org.apache.bval;
//
//import org.apache.bval.model.MetaProperty;
//import org.apache.bval.model.Validation;
//import org.apache.bval.model.ValidationContext;
//import org.apache.bval.model.ValidationListener;
//
//import java.util.Iterator;
//import java.util.List;
//import java.util.Map;
//
///**
// * Description: <br>
// * User: roman.stumm<br>
// * Date: 18.06.2010<br>
// * Time: 11:25:26<br>
// * viaboxx GmbH, 2010
// */
//public abstract class AbstractBeanValidator {
//  private boolean treatMapsLikeBeans = false;
//
//  /**
//   * Behavior configuration -
//   * <pre>
//   * parameter: treatMapsLikeBeans - true (validate maps like beans, so that
//   *                             you can use Maps to validate dynamic classes or
//   *                             beans for which you have the MetaBean but no instances)
//   *                           - false (default), validate maps like collections
//   *                             (validating the values only)
//   * </pre>
//   * (is still configuration to better in BeanValidationContext?)
//   */
//  public boolean isTreatMapsLikeBeans() {
//    return treatMapsLikeBeans;
//  }
//
//  public void setTreatMapsLikeBeans(boolean treatMapsLikeBeans) {
//    this.treatMapsLikeBeans = treatMapsLikeBeans;
//  }
//
//  /**
//   * validate a single bean only. no related beans will be validated
//   */
//  public <VL extends ValidationListener> void validateBean(ValidationContext<VL> context) {
//    // execute all property level validations
//    for (MetaProperty prop : context.getMetaBean().getProperties()) {
//      context.setMetaProperty(prop);
//      validateProperty(context);
//    }
//    
//    // execute all bean level validations
//    context.setMetaProperty(null);
//    for (Validation validation : context.getMetaBean().getValidations()) {
//      validation.validate(context);
//    }
//  }
//
//
//  /**
//   * validate a single property only. performs all validations
//   * for this property.
//   */
//  public <VL extends ValidationListener> void validateProperty(ValidationContext<VL> context) {
//    for (Validation validation : context.getMetaProperty().getValidations()) {
//      validation.validate(context);
//    }
//  }
//
//  protected <VL extends ValidationListener> void validateBeanInContext(ValidationContext<VL> context) {
//    if (getDynamicMetaBean(context) != null) {
//      context.setMetaBean(
//          getDynamicMetaBean(context).resolveMetaBean(context.getBean()));
//    }
//    validateBeanNet(context);
//  }
//
//  /**
//   * Iterates the values of an array, setting the current context
//   * appropriately and validating each value.
//   * 
//   * @param <VL>
//   * @param context
//   *            The validation context, its current bean must be an array.
//   */
//  protected <VL extends ValidationListener> void validateArrayInContext(ValidationContext<VL> context) {
//    int index = 0;
//    DynamicMetaBean dyn = getDynamicMetaBean(context);
//    for (Object each : ((Object[]) context.getBean())) {
//      context.setCurrentIndex(index);
//      if (each == null) continue; // or throw IllegalArgumentException? (=> spec)
//      if (dyn != null) {
//        context.setBean(each, dyn.resolveMetaBean(each));
//      } else {
//        context.setBean(each);
//      }
//      validateBeanNet(context);
//    }
//  }
//
//  /**
//   * Iterates the values of an {@link Iterable} object, setting the current
//   * context appropriately and validating each value.
//   * 
//   * @param <VL>
//   * @param context The validation context, its current bean must implement
//   *            {@link Iterable}.
//   */
//  protected <VL extends ValidationListener> void validateIterableInContext(ValidationContext<VL> context) {
//      
//    final boolean positional = context.getBean() instanceof List<?>;
//    int index = 0;
//    context.setCurrentIndex(null);
//    
//    // jsr303 spec: Each object provided by the iterator is validated.
//    final DynamicMetaBean dyn = getDynamicMetaBean(context);
//    for ( Object each : (Iterable<?>) context.getBean() ) {
//      if ( positional ) {
//          context.setCurrentIndex(index);
//      }
//      if (each == null) {
//          continue; // Null values are not validated
//      }
//      if (dyn != null) {
//          context.setBean(each, dyn.resolveMetaBean(each));
//      } else {
//          context.setBean(each);
//      }
//      validateBeanNet(context);
//    }
//  }
//
//  /**
//   * Iterates the values of a {@link Map}, setting the current context
//   * appropriately and validating each value.
//   * 
//   * @param <VL>
//   * @param context
//   *            The validation context, its current bean must implement
//   *            {@link Map}.
//   */
//  @SuppressWarnings("unchecked")
//  protected <VL extends ValidationListener> void validateMapInContext(ValidationContext<VL> context) {
//    // jsr303 spec: For Map, the value of each Map.Entry is validated (key is not validated).
//    Iterator<Map.Entry<Object, Object>> it = ((Map<Object, Object>) context.getBean()).entrySet().iterator();
//    final DynamicMetaBean dyn = getDynamicMetaBean(context);
//    while (it.hasNext()) { // to Many
//      Map.Entry<Object, Object> entry = it.next();
//      context.setCurrentKey(entry.getKey());
//      if (entry.getValue() == null) {
//        continue; // Null values are not validated
//      }
//      if (dyn != null) {
//        context.setBean(entry.getValue(), dyn.resolveMetaBean(entry.getValue()));
//      } else {
//        context.setBean(entry.getValue());
//      }
//      validateBeanNet(context);
//    }
//  }
//
//  private <VL extends ValidationListener> DynamicMetaBean getDynamicMetaBean(ValidationContext<VL> context) {
//    return context.getMetaBean() instanceof DynamicMetaBean ?
//        (DynamicMetaBean) context.getMetaBean() : null;
//  }
//
//  /**
//   * internal validate a bean (=not a collection of beans) and its related beans
//   */
//  protected abstract <VL extends ValidationListener> void validateBeanNet(ValidationContext<VL> context);
//
//
//  /**
//   * validate a complex 'bean' with related beans according to
//   * validation rules in 'metaBean'
//   *
//   * @param context - the context is initialized with:
//   *                <br>&nbsp;&nbsp;bean - the root object start validation at
//   *                or a collection of root objects
//   *                <br>&nbsp;&nbsp;metaBean - the meta information for the root object(s)
//   * @param context The current validation context.
//   * @return a new instance of validation results
//   *         <p/>
//   *         Methods defined in {@link BeanValidator} take care of setting the path
//   *         and current bean correctly and call
//   *         {@link #validateBeanNet(ValidationContext)} for each individual bean.
//   */
//  protected void validateContext(ValidationContext<?> context) {
//    if (context.getBean() != null) {
//      if (!treatMapsLikeBeans && context.getBean() instanceof Map<?, ?>) {
//        validateMapInContext(context);
//      } else if (context.getBean() instanceof Iterable<?>) {
//        validateIterableInContext(context);
//      } else if (context.getBean() instanceof Object[]) {
//        validateArrayInContext(context);
//      } else { // to One Bean (or Map like Bean)
//        validateBeanInContext(context);
//      }
//    }
//  }  
//}
import org.apache.bval.util.ValidationHelper;
// TODO: centralize treatMapsLikeBeans

public class BeanValidator<T extends ValidationListener> {
    ValidationHelper.validateContext(context, new BeanValidatorCallback(context), treatMapsLikeBeans);
              ValidationHelper.validateContext(context, new BeanValidatorCallback(context), treatMapsLikeBeans);
    ValidationHelper.validateProperty(context);
      ValidationHelper.validateBean(context);
      ValidationHelper.validateContext(context, new BeanValidatorCallback(context), treatMapsLikeBeans);
        ValidationHelper.validateContext(context, new BeanValidatorCallback(context), treatMapsLikeBeans);
  private boolean treatMapsLikeBeans = false;
  
  public boolean isTreatMapsLikeBeans() {
    return treatMapsLikeBeans;
  }
    
  public void setTreatMapsLikeBeans(boolean treatMapsLikeBeans) {
    this.treatMapsLikeBeans = treatMapsLikeBeans;
  }
  

  /**
   * Dispatches a call from {@link #validate()} to
   * {@link BeanValidator#validateBeanNet(ValidationContext)} with the current
   * context set.
   */
  private class BeanValidatorCallback implements ValidationHelper.ValidateCallback {

    private final ValidationContext<?> context;
    
    public BeanValidatorCallback(ValidationContext<?> context) {
        this.context = context;
    }

    public void validate() {
        validateBeanNet(context);
    }

  }
  
// TODO: Reduce visibility

public final class DynamicMetaBean extends MetaBean {
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import javax.validation.ConstraintViolation;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.groups.Default;
import javax.validation.metadata.BeanDescriptor;
import org.apache.bval.util.ValidationHelper;

// TODO: centralize treatMapsLikeBeans
public class ClassValidator implements Validator {
  protected void validateBeanNet(GroupValidationContext<?> context) {
      final ConstraintValidationListener<?> result = (ConstraintValidationListener<?>) context.getListener();
          ValidationHelper.validateBean(context);
            ValidationHelper.validateBean(context);
        ValidationHelper.validateBean(context);
          ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), treatMapsLikeBeans);
        ValidationHelper.validateProperty(context);
        ValidationHelper.validateProperty(context);
  
  private boolean treatMapsLikeBeans = false;
  
  /**
   * Behavior configuration -
   * <pre>
   * parameter: treatMapsLikeBeans - true (validate maps like beans, so that
   *                             you can use Maps to validate dynamic classes or
   *                             beans for which you have the MetaBean but no instances)
   *                           - false (default), validate maps like collections
   *                             (validating the values only)
   * </pre>
   * (is still configuration to better in BeanValidationContext?)
   */
  public boolean isTreatMapsLikeBeans() {
    return treatMapsLikeBeans;
  }


  public void setTreatMapsLikeBeans(boolean treatMapsLikeBeans) {
    this.treatMapsLikeBeans = treatMapsLikeBeans;
  }
  
  /**
   * Dispatches a call from {@link #validate()} to
   * {@link ClassValidator#validateBeanNet(GroupValidationContext)} with the
   * current context set.
   */
  protected class Jsr303ValidationCallback implements ValidationHelper.ValidateCallback {

    private final GroupValidationContext<?> context;

    public Jsr303ValidationCallback(GroupValidationContext<?> context) {
        this.context = context;
    }

    public void validate() {
        validateBeanNet(context);
    }

  }
  
import org.apache.bval.util.ValidationHelper;
        ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
          ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
        ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
          ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
      @SuppressWarnings("unchecked")
      final ConstraintValidator<T, Object> objectValidator = (ConstraintValidator<T, Object>) validator;
      if (!objectValidator.isValid(context.getValidatedValue(), jsrContext)) {
    @SuppressWarnings("unchecked")
    @SuppressWarnings("unchecked")
    @SuppressWarnings("unchecked")
    @SuppressWarnings("unchecked")
        //TODO following call seems to do nothing:
     * The {@link ValidatorProvider} reference.
    private ValidatorProvider validatorProvider;
     * Sets the {@link ValidatorProvider} reference.
     * @param validatorProvider the {@link ValidatorProvider} reference.
    public void setValidatorProvider(ValidatorProvider validatorProvider) {
        this.validatorProvider = validatorProvider;

        Validator validator = this.validatorProvider.get();
        MethodValidator methodValidator = validator.unwrap(MethodValidator.class);
final class ValidatorProvider implements Provider<Validator> {
    private final ValidatorFactory validatorFactory;
        this.validatorFactory = validatorFactory;
        return this.validatorFactory.getValidator();
final class ValidatorFactoryProvider implements Provider<ValidatorFactory> {
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
                         method
                         "' with arguments "
                         Arrays.deepToString(arguments), constraintViolations),
                    validate.rethrowExceptionsAs());
    /**
     * Define the {@link Throwable} has to be thrown when a validation error
     * occurs and the user defined the custom error wrapper.
     *
     * @param exception the occurred validation error.
     * @param exceptionWrapperClass the user defined custom error wrapper.
     * @return the {@link Throwable} has o be thrown.
     */
    private boolean inIterable;
        this.inIterable = node.isInIterable();
        return inIterable;
        this.inIterable = inIterable;
        inIterable = true;
        inIterable = true;
        if (inIterable) {
        if (inIterable != node.inIterable) {
        result = 31 * result  (inIterable ? 1 : 0);
    private static final Object UNKNOWN = new Object() {
        public String toString() {
            return "unknown property value";
        };
    };
            @SuppressWarnings("unchecked")
            final T result = (T) this;
            return result;
                Class<?> cls = ClassUtils.getClass(type.getName()  "Impl");
                if (type.isAssignableFrom(cls)) {
                    @SuppressWarnings("unchecked")
                    final Class<? extends T> implClass = (Class<? extends T>) cls;
                    return SecureActions.newInstance(implClass);
                }
            throw new ValidationException("Type "  type  " not supported");
      @SuppressWarnings("unchecked")
      final T result = (T) this;
      return result;
        Class<?> cls = ClassUtils.getClass(type.getName()  "Impl");
        if (type.isAssignableFrom(cls)) {
          @SuppressWarnings("unchecked")
          final Class<? extends T> implClass = (Class<? extends T>) cls;
          return SecureActions.newInstance(implClass,
              new Class[]{ApacheFactoryContext.class}, new Object[]{factoryContext});
        }
      throw new ValidationException("Type "  type  " not supported");
import java.lang.reflect.Modifier;
        } else if (!(type.isInterface() || Modifier.isAbstract(type.getModifiers()))) {
import java.lang.reflect.Modifier;
    } else if (!(type.isInterface() || Modifier.isAbstract(type.getModifiers()))) {
 * @author Carlos Vara <br/>
    /**
     * {@link ApacheFactoryContext} used
     */
    protected final ApacheFactoryContext factoryContext;
    /**
     * {@link GroupsComputer} used
     */
    protected final GroupsComputer groupsComputer = new GroupsComputer();
    /**
     * Create a new ClassValidator instance.
     * 
     * @param factoryContext
     */
    public ClassValidator(ApacheFactoryContext factoryContext) {
        this.factoryContext = factoryContext;
    /**
     * Create a new ClassValidator instance.
     * 
     * @param factory
     * @deprecated provided for backward compatibility
     */
    public ClassValidator(ApacheValidatorFactory factory) {
        this(factory.usingContext());
    /**
     * Get the metabean finder associated with this validator.
     * 
     * @return a MetaBeanFinder
     * @see org.apache.bval.MetaBeanManagerFactory#getFinder()
     */
    public MetaBeanFinder getMetaBeanFinder() {
        return factoryContext.getMetaBeanFinder();
    }
    // Validator implementation
    // --------------------------------------------------
    /**
     * {@inheritDoc} Validates all constraints on <code>object</code>.
     * 
     * @param object
     *            object to validate
     * @param groups
     *            group or list of groups targeted for validation (default to
     *            {@link javax.validation.groups.Default})
     * 
     * @return constraint violations or an empty Set if none
     * 
     * @throws IllegalArgumentException
     *             if object is null or if null is passed to the varargs groups
     * @throws ValidationException
     *             if a non recoverable error happens during the validation
     *             process
     */
    // @Override - not allowed in 1.5 for Interface methods
    @SuppressWarnings("unchecked")
    public <T> Set<ConstraintViolation<T>> validate(T object,
        Class<?>... groups) {
        if (object == null)
            throw new IllegalArgumentException("cannot validate null");
        checkGroups(groups);
        try {
            Class<T> objectClass = (Class<T>) object.getClass();
            MetaBean objectMetaBean =
                factoryContext.getMetaBeanFinder().findForClass(objectClass);
            final GroupValidationContext<T> context =
                createContext(objectMetaBean, object, objectClass, groups);
            final ConstraintValidationListener<T> result =
                context.getListener();
            final Groups sequence = context.getGroups();
            // 1. process groups
            for (Group current : sequence.getGroups()) {
                context.setCurrentGroup(current);
                validateBeanNet(context);

            // 2. process sequences
            for (List<Group> eachSeq : sequence.getSequences()) {
                for (Group current : eachSeq) {
                    context.setCurrentGroup(current);
                    validateBeanNet(context);
                    // if one of the group process in the sequence leads to one
                    // or more validation failure,
                    // the groups following in the sequence must not be
                    // processed
                    if (!result.isEmpty())
                        break;
                }
                if (!result.isEmpty())
                    break;
            }
            return result.getConstraintViolations();
        } catch (RuntimeException ex) {
            throw unrecoverableValidationError(ex, object);
        }
    }

    /**
     * {@inheritDoc} Validates all constraints placed on the property of
     * <code>object</code> named <code>propertyName</code>.
     * 
     * @param object
     *            object to validate
     * @param propertyName
     *            property to validate (ie field and getter constraints). Nested
     *            properties may be referenced (e.g. prop[2].subpropA.subpropB)
     * @param groups
     *            group or list of groups targeted for validation (default to
     *            {@link javax.validation.groups.Default})
     * 
     * @return constraint violations or an empty Set if none
     * 
     * @throws IllegalArgumentException
     *             if <code>object</code> is null, if <code>propertyName</code>
     *             null, empty or not a valid object property or if null is
     *             passed to the varargs groups
     * @throws ValidationException
     *             if a non recoverable error happens during the validation
     *             process
     */
    // @Override - not allowed in 1.5 for Interface methods
    @SuppressWarnings("unchecked")
    public <T> Set<ConstraintViolation<T>> validateProperty(T object,
        String propertyName, Class<?>... groups) {
        if (object == null)
            throw new IllegalArgumentException("cannot validate null");

        checkPropertyName(propertyName);
        checkGroups(groups);

        try {

            Class<T> objectClass = (Class<T>) object.getClass();
            MetaBean objectMetaBean =
                factoryContext.getMetaBeanFinder().findForClass(objectClass);

            GroupValidationContext<T> context =
                createContext(objectMetaBean, object, objectClass, groups);
            ConstraintValidationListener<T> result = context.getListener();
            NestedMetaProperty nestedProp =
                getNestedProperty(objectMetaBean, object, propertyName);
            context.setMetaProperty(nestedProp.getMetaProperty());
            if (nestedProp.isNested()) {
                context.setFixedValue(nestedProp.getValue());
            }
            if (context.getMetaProperty() == null)
                throw new IllegalArgumentException("Unknown property "
                     object.getClass().getName()  "."  propertyName);
            Groups sequence = context.getGroups();

            // 1. process groups
            for (Group current : sequence.getGroups()) {
                context.setCurrentGroup(current);
                validatePropertyInGroup(context);
            }

            // 2. process sequences
            for (List<Group> eachSeq : sequence.getSequences()) {
                for (Group current : eachSeq) {
                    context.setCurrentGroup(current);
                    validatePropertyInGroup(context);
                    /**
                     * if one of the group process in the sequence leads to one
                     * or more validation failure, the groups following in the
                     * sequence must not be processed
                     */
                    if (!result.isEmpty())
                        break;
                }
                if (!result.isEmpty())
                    break;
            }
            return result.getConstraintViolations();
        } catch (RuntimeException ex) {
            throw unrecoverableValidationError(ex, object);
        }
    }

    /**
     * {@inheritDoc} Validates all constraints placed on the property named
     * <code>propertyName</code> of the class <code>beanType</code> would the
     * property value be <code>value</code>
     * <p/>
     * <code>ConstraintViolation</code> objects return null for
     * {@link ConstraintViolation#getRootBean()} and
     * {@link ConstraintViolation#getLeafBean()}
     * 
     * @param beanType
     *            the bean type
     * @param propertyName
     *            property to validate
     * @param value
     *            property value to validate
     * @param groups
     *            group or list of groups targeted for validation (default to
     *            {@link javax.validation.groups.Default})
     * 
     * @return constraint violations or an empty Set if none
     * 
     * @throws IllegalArgumentException
     *             if <code>beanType</code> is null, if
     *             <code>propertyName</code> null, empty or not a valid object
     *             property or if null is passed to the varargs groups
     * @throws ValidationException
     *             if a non recoverable error happens during the validation
     *             process
     */
    // @Override - not allowed in 1.5 for Interface methods
    public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType,
        String propertyName, Object value, Class<?>... groups) {

        checkBeanType(beanType);
        checkPropertyName(propertyName);
        checkGroups(groups);

        try {
            MetaBean metaBean =
                factoryContext.getMetaBeanFinder().findForClass(beanType);
            GroupValidationContext<T> context =
                createContext(metaBean, null, beanType, groups);
            ConstraintValidationListener<T> result = context.getListener();
            context.setMetaProperty(getNestedProperty(metaBean, null,
                propertyName).getMetaProperty());
            context.setFixedValue(value);
            Groups sequence = context.getGroups();

            // 1. process groups
            for (Group current : sequence.getGroups()) {
                context.setCurrentGroup(current);
                validatePropertyInGroup(context);
            }
            // 2. process sequences
            for (List<Group> eachSeq : sequence.getSequences()) {
                for (Group current : eachSeq) {
                    context.setCurrentGroup(current);
                    validatePropertyInGroup(context);
                    // if one of the group process in the sequence leads to one
                    // or more validation failure,
                    // the groups following in the sequence must not be
                    // processed
                    if (!result.isEmpty())
                        break;
                }
                if (!result.isEmpty())
                    break;
            }
            return result.getConstraintViolations();
        } catch (RuntimeException ex) {
            throw unrecoverableValidationError(ex, value);
        }
    }

    /**
     * {@inheritDoc} Return the descriptor object describing bean constraints.
     * The returned object (and associated objects including
     * <code>ConstraintDescriptor<code>s) are immutable.
     * 
     * @param clazz
     *            class or interface type evaluated
     * 
     * @return the bean descriptor for the specified class.
     * 
     * @throws IllegalArgumentException
     *             if clazz is null
     * @throws ValidationException
     *             if a non recoverable error happens during the metadata
     *             discovery or if some constraints are invalid.
     */
    // @Override - not allowed in 1.5 for Interface methods
    public BeanDescriptor getConstraintsForClass(Class<?> clazz) {
        if (clazz == null) {
            throw new IllegalArgumentException("Class cannot be null");
        }
        try {
            MetaBean metaBean =
                factoryContext.getMetaBeanFinder().findForClass(clazz);
            BeanDescriptorImpl edesc =
                metaBean.getFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR);
            if (edesc == null) {
                edesc = createBeanDescriptor(metaBean);
                metaBean.putFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR, edesc);
            }
            return edesc;
        } catch (RuntimeException ex) {
            throw new ValidationException("error retrieving constraints for "
                 clazz, ex);
        }
    }

    /**
     * {@inheritDoc} Return an instance of the specified type allowing access to
     * provider-specific APIs. If the Bean Validation provider implementation
     * does not support the specified class, <code>ValidationException</code> is
     * thrown.
     * 
     * @param type
     *            the class of the object to be returned.
     * 
     * @return an instance of the specified class
     * 
     * @throws ValidationException
     *             if the provider does not support the call.
     */
    // @Override - not allowed in 1.5 for Interface methods
    public <T> T unwrap(Class<T> type) {
        if (type.isAssignableFrom(getClass())) {
            @SuppressWarnings("unchecked")
            final T result = (T) this;
            return result;
        } else if (!(type.isInterface() || Modifier.isAbstract(type
            .getModifiers()))) {
            return SecureActions.newInstance(type,
                new Class[] { ApacheFactoryContext.class },
                new Object[] { factoryContext });
        } else {
            try {
                Class<?> cls = ClassUtils.getClass(type.getName()  "Impl");
                if (type.isAssignableFrom(cls)) {
                    @SuppressWarnings("unchecked")
                    final Class<? extends T> implClass =
                        (Class<? extends T>) cls;
                    return SecureActions.newInstance(implClass,
                        new Class[] { ApacheFactoryContext.class },
                        new Object[] { factoryContext });
                }
            } catch (ClassNotFoundException e) {
            }
            throw new ValidationException("Type "  type  " not supported");
        }
    }

    // Helpers
    // -------------------------------------------------------------------

    /**
     * Validates a bean and all its cascaded related beans for the currently
     * defined group.
     * <p>
     * Special code is present to manage the {@link Default} group.
     * 
     * @param validationContext
     *            The current context of this validation call. Must have its
     *            {@link GroupValidationContext#getCurrentGroup()} field set.
     */
    protected void validateBeanNet(GroupValidationContext<?> context) {

        // If reached a cascaded bean which is null
        if (context.getBean() == null) {
            return;
        }

        // If reached a cascaded bean which has already been validated for the
        // current group
        if (!context.collectValidated()) {
            return;
        }

        // ### First, validate the bean

        // Default is a special case
        if (context.getCurrentGroup().isDefault()) {

            List<Group> defaultGroups = expandDefaultGroup(context);
            final ConstraintValidationListener<?> result =
                (ConstraintValidationListener<?>) context.getListener();

            // If the rootBean defines a GroupSequence
            if (defaultGroups.size() > 1) {

                int numViolations = result.violationsSize();

                // Validate the bean for each group in the sequence
                Group currentGroup = context.getCurrentGroup();
                for (Group each : defaultGroups) {
                    context.setCurrentGroup(each);
                    ValidationHelper.validateBean(context);
                    // Spec 3.4.3 - Stop validation if errors already found
                    if (result.violationsSize() > numViolations) {
                        break;
                    }
                }
                context.setCurrentGroup(currentGroup);
            } else {

                // For each class in the hierarchy of classes of rootBean,
                // validate the constraints defined in that class according
                // to the GroupSequence defined in the same class

                // Obtain the full class hierarchy
                List<Class<?>> classHierarchy = new ArrayList<Class<?>>();
                ClassHelper.fillFullClassHierarchyAsList(classHierarchy,
                    context.getMetaBean().getBeanClass());
                Class<?> initialOwner = context.getCurrentOwner();

                // For each owner in the hierarchy
                for (Class<?> owner : classHierarchy) {
                    context.setCurrentOwner(owner);

                    int numViolations = result.violationsSize();

                    // Obtain the group sequence of the owner, and use it for
                    // the constraints that belong to it
                    List<Group> ownerDefaultGroups =
                        context.getMetaBean().getFeature(
                            "{GroupSequence:"  owner.getCanonicalName()  "}");
                    for (Group each : ownerDefaultGroups) {
                        context.setCurrentGroup(each);
                        ValidationHelper.validateBean(context);
                        // Spec 3.4.3 - Stop validation if errors already found
                        if (result.violationsSize() > numViolations) {
                            break;
                        }
                    }

                }
                context.setCurrentOwner(initialOwner);
                context.setCurrentGroup(Group.DEFAULT);

            }
        // if not the default group, proceed as normal
        else {
            ValidationHelper.validateBean(context);
        // ### Then, the cascaded beans (@Valid)
        for (MetaProperty prop : context.getMetaBean().getProperties()) {
            validateCascadedBean(context, prop);
        }
    /**
     * Checks if the the meta property <code>prop</code> defines a cascaded
     * bean, and in case it does, validates it.
     * 
     * @param context
     *            The current validation context.
     * @param prop
     *            The property to cascade from (in case it is possible).
     */
    private void validateCascadedBean(GroupValidationContext<?> context,
        MetaProperty prop) {
        AccessStrategy[] access =
            prop.getFeature(Features.Property.REF_CASCADE);
        if (access != null) { // different accesses to relation
            // save old values from context
            final Object bean = context.getBean();
            final MetaBean mbean = context.getMetaBean();
            for (AccessStrategy each : access) {
                if (isCascadable(context, prop, each)) {
                    // modify context state for relationship-target bean
                    context.moveDown(prop, each);
                    // Now, if the related bean is an instance of Map/Array/etc,
                    ValidationHelper.validateContext(context,
                        new Jsr303ValidationCallback(context),
                        treatMapsLikeBeans);
                    // restore old values in context
                    context.moveUp(bean, mbean);
                }
            }
        }
    /**
     * Before accessing a related bean (marked with
     * {@link javax.validation.Valid}), the validator has to check if it is
     * reachable and cascadable.
     * 
     * @param context
     *            The current validation context.
     * @param prop
     *            The property of the related bean.
     * @param access
     *            The access strategy used to get the related bean value.
     * @return <code>true</code> if the validator can access the related bean,
     *         <code>false</code> otherwise.
     */
    private boolean isCascadable(GroupValidationContext<?> context,
        MetaProperty prop, AccessStrategy access) {
        PathImpl beanPath = context.getPropertyPath();
        NodeImpl node = new NodeImpl(prop.getName());
        if (beanPath == null) {
            beanPath = PathImpl.create(null);
        }
        try {
            if (!context.getTraversableResolver().isReachable(
                context.getBean(), node,
                context.getRootMetaBean().getBeanClass(), beanPath,
                access.getElementType()))
                return false;
        } catch (RuntimeException e) {
            throw new ValidationException(
                "Error in TraversableResolver.isReachable() for "
                     context.getBean(), e);
        }
        try {
            if (!context.getTraversableResolver().isCascadable(
                context.getBean(), node,
                context.getRootMetaBean().getBeanClass(), beanPath,
                access.getElementType()))
                return false;
        } catch (RuntimeException e) {
            throw new ValidationException(
                "Error TraversableResolver.isCascadable() for "
                     context.getBean(), e);
        }
        return true;
    /**
     * in case of a default group return the list of groups for a redefined
     * default GroupSequence
     * 
     * @return null when no in default group or default group sequence not
     *         redefined
     */
    private List<Group> expandDefaultGroup(GroupValidationContext<?> context) {
        if (context.getCurrentGroup().isDefault()) {
            // mention if metaBean redefines the default group
            List<Group> groupSeq =
                context.getMetaBean().getFeature(
                    Jsr303Features.Bean.GROUP_SEQUENCE);
            if (groupSeq != null) {
                context.getGroups().assertDefaultGroupSequenceIsExpandable(
                    groupSeq);
            }
            return groupSeq;
        } else {
            return null;
        }
    /**
     * Generate an unrecoverable validation error
     * 
     * @param ex
     * @param object
     * @return a {@link RuntimeException} of the appropriate type
     */
    protected static RuntimeException unrecoverableValidationError(
        RuntimeException ex, Object object) {
        if (ex instanceof UnknownPropertyException) {
            // Convert to IllegalArgumentException
            return new IllegalArgumentException(ex.getMessage(), ex);
        } else if (ex instanceof ValidationException) {
            return ex; // do not wrap specific ValidationExceptions (or
                       // instances from subclasses)
        } else {
            return new ValidationException("error during validation of "
                 object, ex);
        }
    }

    private void validatePropertyInGroup(GroupValidationContext<?> context) {
        Group currentGroup = context.getCurrentGroup();
        List<Group> defaultGroups = expandDefaultGroup(context);
        if (defaultGroups != null) {
            for (Group each : defaultGroups) {
                context.setCurrentGroup(each);
                ValidationHelper.validateProperty(context);
                // continue validation, even if errors already found: if
                // (!result.isEmpty())
            }
            context.setCurrentGroup(currentGroup); // restore
        } else {
            ValidationHelper.validateProperty(context);
        }
    }

    /**
     * find the MetaProperty for the given propertyName, which could contain a
     * path, following the path on a given object to resolve types at runtime
     * from the instance
     */
    private NestedMetaProperty getNestedProperty(MetaBean metaBean, Object t,
        String propertyName) {
        NestedMetaProperty nested = new NestedMetaProperty(propertyName, t);
        nested.setMetaBean(metaBean);
        nested.parse();
        return nested;
    }

    /**
     * Create a {@link GroupValidationContext}.
     * 
     * @param <T>
     * @param metaBean
     * @param object
     * @param objectClass
     * @param groups
     * @return {@link GroupValidationContext} instance
     */
    protected <T> GroupValidationContext<T> createContext(MetaBean metaBean,
        T object, Class<T> objectClass, Class<?>[] groups) {
        ConstraintValidationListener<T> listener =
            new ConstraintValidationListener<T>(object, objectClass);
        GroupValidationContextImpl<T> context =
            new GroupValidationContextImpl<T>(listener, this.factoryContext
                .getMessageInterpolator(), this.factoryContext
                .getTraversableResolver(), metaBean);
        context.setBean(object, metaBean);
        context.setGroups(groupsComputer.computeGroups(groups));
        return context;
    }

    /**
     * Create a {@link BeanDescriptorImpl}
     * 
     * @param metaBean
     * @return {@link BeanDescriptorImpl} instance
     */
    protected BeanDescriptorImpl createBeanDescriptor(MetaBean metaBean) {
        return new BeanDescriptorImpl(factoryContext, metaBean, metaBean
            .getValidations());
    }

    private boolean treatMapsLikeBeans = false;

    /**
     * Behavior configuration -
     * 
     * <pre>
     * parameter: treatMapsLikeBeans - true (validate maps like beans, so that
     *                             you can use Maps to validate dynamic classes or
     *                             beans for which you have the MetaBean but no instances)
     *                           - false (default), validate maps like collections
     *                             (validating the values only)
     * </pre>
     * 
     * (is still configuration to better in BeanValidationContext?)
     */
    public boolean isTreatMapsLikeBeans() {
        return treatMapsLikeBeans;
    }

    public void setTreatMapsLikeBeans(boolean treatMapsLikeBeans) {
        this.treatMapsLikeBeans = treatMapsLikeBeans;
    }

    /**
     * Checks that beanType is valid according to spec Section 4.1.1 i. Throws
     * an {@link IllegalArgumentException} if it is not.
     * 
     * @param beanType
     *            Bean type to check.
     */
    private void checkBeanType(Class<?> beanType) {
        if (beanType == null) {
            throw new IllegalArgumentException("Bean type cannot be null.");
        }
    }

    /**
     * Checks that the property name is valid according to spec Section 4.1.1 i.
     * Throws an {@link IllegalArgumentException} if it is not.
     * 
     * @param propertyName
     *            Property name to check.
     */
    private void checkPropertyName(String propertyName) {
        if (propertyName == null || propertyName.trim().length() == 0) {
            throw new IllegalArgumentException(
                "Property path cannot be null or empty.");
        }
    }

    /**
     * Checks that the groups array is valid according to spec Section 4.1.1 i.
     * Throws an {@link IllegalArgumentException} if it is not.
     * 
     * @param groups
     *            The groups to check.
     */
    private void checkGroups(Class<?>[] groups) {
        if (groups == null) {
            throw new IllegalArgumentException("Groups cannot be null.");
        }
    }

    /**
     * Dispatches a call from {@link #validate()} to
     * {@link ClassValidator#validateBeanNet(GroupValidationContext)} with the
     * current context set.
     */
    protected class Jsr303ValidationCallback implements
        ValidationHelper.ValidateCallback {

        private final GroupValidationContext<?> context;

        public Jsr303ValidationCallback(GroupValidationContext<?> context) {
            this.context = context;
        }

        public void validate() {
            validateBeanNet(context);
        }

    }

import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;
import javax.validation.Validation;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import javax.validation.bootstrap.ProviderSpecificBootstrap;
import javax.validation.spi.ConfigurationState;
 * Description: a factory is a complete configurated object that can create
 * validators.<br/>
    private static final ConstraintDefaults defaultConstraints =
        new ConstraintDefaults();
     * 
                Validation.byProvider(ApacheValidationProvider.class);
            DEFAULT_FACTORY =
                (ApacheValidatorFactory) configuration.buildValidatorFactory();
     * 
        DEFAULT_FACTORY = aDefaultFactory;
    public ApacheValidatorFactory() {
        constraintMap =
            new HashMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>>();
    /**
     * Configure this {@link ApacheValidatorFactory} from a
     * {@link ConfigurationState}.
     * 
     * @param configuration
     */
        setConstraintValidatorFactory(configuration
            .getConstraintValidatorFactory());
     * 
     * Get the default {@link MessageInterpolator} used by this
     * {@link ApacheValidatorFactory}.
     * 
     * Shortcut method to create a new Validator instance with factory's
     * settings
     * 
     * 
     * 
        return ((messageResolver != null) ? messageResolver
            : getDefaultMessageInterpolator());
     * 
    public final void setTraversableResolver(
        TraversableResolver traversableResolver) {
     * 
        ConstraintValidatorFactory constraintValidatorFactory) {

     * provider-specific API. If the Bean Validation provider implementation
     * does not support the specified class, the ValidationException is thrown.
     * 
     * @param type
     *            the class of the object to be returned.
     * @throws ValidationException
     *             if the provider does not support the call.
        } else if (!(type.isInterface() || Modifier.isAbstract(type
            .getModifiers()))) {
                    final Class<? extends T> implClass =
                        (Class<? extends T>) cls;
     * 
     * Get the detected {@link AnnotationIgnores}.
     * 
     * 
     * Add a meta-constraint to this {@link ApacheValidatorFactory}'s runtime
     * customizations.
     * 
    public void addMetaConstraint(Class<?> beanClass,
        MetaConstraint<?, ?> metaConstraint) {
        List<MetaConstraint<?, ? extends Annotation>> slot =
            constraintMap.get(beanClass);
                new ArrayList<MetaConstraint<?, ? extends Annotation>>();
     * 
     * @param accessStrategy
     *            defining the property to validate
     * 
     * 
     * @return List of {@link MetaConstraint}s applicable to
     *         <code>beanClass</code>
        Class<T> beanClass) {
        List<MetaConstraint<?, ? extends Annotation>> slot =
            constraintMap.get(beanClass);
            // noinspection RedundantCast
     * 
     * 
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.PropertyAccess;
import org.apache.bval.util.ValidationHelper;


        if (clazz == null || clazz == Object.class) {
        if (allClasses.contains(clazz)) {
        List<Class<?>> subClasses = new ArrayList<Class<?>>(Arrays.asList(clazz.getInterfaces()));
        for (Class<?> subClass : subClasses) {
        }

 * Description: Top-Level API-class to validate objects or object-trees. You can
 * invoke, extend or utilize this class if you need other ways to integrate
 * This class supports cyclic object graphs by keeping track of validated
 * instances in the validation context.<br/>
    private final MetaBeanFinder metaBeanFinder;
    /**
     * Create a new BeanValidator instance. Convenience constructor. Use the
     * global instance of MetaBeanManagerFactory.getFinder().
     */
    public BeanValidator() {
        this(MetaBeanManagerFactory.getFinder());
    /**
     * Create a new BeanValidator instance.
     * 
     * @param metaBeanFinder
     */
    public BeanValidator(MetaBeanFinder metaBeanFinder) {
        this.metaBeanFinder = metaBeanFinder;
    /**
     * Convenience API. validate a root object with all related objects with its
     * default metaBean definition.
     * 
     * @param bean
     * @return results - validation results found
     */
    public T validate(Object bean) {
        MetaBean metaBean = getMetaBeanFinder().findForClass(bean.getClass());
        return validate(bean, metaBean);
    /**
     * Convenience API. validate a root object with all related objects
     * according to the metaBean.
     * 
     * @param bean
     *            - a single bean or a collection of beans (that share the same
     *            metaBean!)
     * @param metaBean
     * @return results - validation results found
     */
    public T validate(Object bean, MetaBean metaBean) {
        ValidationContext<T> context = createContext();
        context.setBean(bean, metaBean);
        return context.getListener();
    /**
     * Validate the method parameters based on @Validate annotations.
     * Requirements: Parameter, that are to be validated must be annotated with @Validate
     * 
     * @param method
     *            - a method
     * @param parameters
     *            - the parameters suitable to the method
     * @return a validation result or null when there was nothing to validate
     * @see Validate
     */
    public T validateCall(Method method, Object[] parameters) {
        if (parameters.length > 0) {
            // shortcut (for performance!)
            Annotation[][] annotations = method.getParameterAnnotations();
            ValidationContext<T> context = null;
            for (int i = 0; i < parameters.length; i) {
                for (Annotation anno : annotations[i]) {
                    if (anno instanceof Validate) {
                        if (context == null)
                            context = createContext();
                        if (determineMetaBean((Validate) anno, parameters[i], context)) {
                            ValidationHelper.validateContext(context, new BeanValidatorCallback(context),
                                treatMapsLikeBeans);
                            break; // next parameter
                        }
                    }
                }
            }
            return context != null ? context.getListener() : null;
        }
        return null;
    /**
     * Determine the metabean for the given object.
     * 
     * @param <VL>
     * @param validate
     * @param parameter
     * @param context
     * @return true when validation should happen, false to skip it
     */
    protected <VL extends ValidationListener> boolean determineMetaBean(Validate validate, Object parameter,
        ValidationContext<VL> context) {
        if (validate.value().length() == 0) {
            if (parameter == null)
                return false;
            Class<?> beanClass;
            if (parameter instanceof Collection<?>) { // do not validate empty
                                                      // collection
                Collection<?> coll = ((Collection<?>) parameter);
                if (coll.isEmpty())
                    return false;
                beanClass = coll.iterator().next().getClass(); // get first
                                                               // object
            } else if (parameter.getClass().isArray()) {
                beanClass = parameter.getClass().getComponentType();
            } else {
                beanClass = parameter.getClass();
            }
            context.setBean(parameter, getMetaBeanFinder().findForClass(beanClass));
        } else {
            context.setBean(parameter, getMetaBeanFinder().findForId(validate.value()));
        }
        return true;
    }

    /**
     * factory method - overwrite in subclasses
     * 
     * @return ValidationListener of the proper type
     */
    @SuppressWarnings("unchecked")
    protected T createResults() {
        return (T) new ValidationResults();
    }

    /**
     * factory method - overwrite in subclasses
     * 
     * @return ValidationContext parameterized with our listener type
     */
    protected ValidationContext<T> createContext() {
        return new BeanValidationContext<T>(createResults());
    }

    /**
     * Convenience API. validate a single property.
     * 
     * @param bean
     *            - the root object
     * @param metaProperty
     *            - metadata for the property
     * @return validation results
     */
    public T validateProperty(Object bean, MetaProperty metaProperty) {
        ValidationContext<T> context = createContext();
        context.setBean(bean);
        context.setMetaProperty(metaProperty);
        ValidationHelper.validateProperty(context);
        return context.getListener();
    }

    /**
     * {@inheritDoc} internal validate a bean (=not a collection of beans) and
     * its related beans
     */
    protected <VL extends ValidationListener> void validateBeanNet(ValidationContext<VL> context) {
        if (context.collectValidated()) {
            ValidationHelper.validateBean(context);
            for (MetaProperty prop : context.getMetaBean().getProperties()) {
                validateRelatedBean(context, prop);
            }
        }
    }

    /**
     * Validate a property of a graph.
     * 
     * @param <VL>
     * @param context
     * @param prop
     */
    protected <VL extends ValidationListener> void validateRelatedBean(ValidationContext<VL> context, MetaProperty prop) {
        AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
        if (access == null && prop.getMetaBean() != null) { // single property
                                                            // access strategy
            // save old values from context
            final Object bean = context.getBean();
            final MetaBean mbean = context.getMetaBean();
            // modify context state for relationship-target bean
            context.moveDown(prop, new PropertyAccess(bean.getClass(), prop.getName()));
            ValidationHelper.validateContext(context, new BeanValidatorCallback(context), treatMapsLikeBeans);
            // restore old values in context
            context.moveUp(bean, mbean);
        } else if (access != null) { // different accesses to relation
            // save old values from context
            final Object bean = context.getBean();
            final MetaBean mbean = context.getMetaBean();
            for (AccessStrategy each : access) {
                // modify context state for relationship-target bean
                context.moveDown(prop, each);
                ValidationHelper.validateContext(context, new BeanValidatorCallback(context), treatMapsLikeBeans);
                // restore old values in context
                context.moveUp(bean, mbean);
            }
        }
    }

    private boolean treatMapsLikeBeans = false;

    public boolean isTreatMapsLikeBeans() {
        return treatMapsLikeBeans;
    }

    public void setTreatMapsLikeBeans(boolean treatMapsLikeBeans) {
        this.treatMapsLikeBeans = treatMapsLikeBeans;
    }

    /**
     * Get the metabean finder associated with this validator.
     * 
     * @return a MetaBeanFinder
     * @see org.apache.bval.MetaBeanManagerFactory#getFinder()
     */
    public MetaBeanFinder getMetaBeanFinder() {
        return metaBeanFinder;
    }

    /**
     * Dispatches a call from {@link #validate()} to
     * {@link BeanValidator#validateBeanNet(ValidationContext)} with the current
     * context set.
     */
    private class BeanValidatorCallback implements ValidationHelper.ValidateCallback {

        private final ValidationContext<?> context;

        public BeanValidatorCallback(ValidationContext<?> context) {
            this.context = context;
        }

        public void validate() {
            validateBeanNet(context);
        }

    }

 * Description: internal implementation class to construct metabeans with
 * factories<br/>
    private static final Log log = LogFactory.getLog(MetaBeanBuilder.class);
    /**
     * here you can install different kinds of factories to create MetaBeans
     * from
     */
    private MetaBeanFactory[] factories;
    /**
     * Create a new MetaBeanBuilder instance.
     */
    public MetaBeanBuilder() {
        this(new MetaBeanFactory[] { new IntrospectorMetaBeanFactory() });
    /**
     * Create a new MetaBeanBuilder instance.
     * 
     * @param factories
     */
    public MetaBeanBuilder(MetaBeanFactory[] factories) {
        setFactories(factories);

    /**
     * Get the configured set of {@link MetaBeanFactory} objects.
     * 
     * @return {@link MetaBeanFactory} array
     */
    public MetaBeanFactory[] getFactories() {
        return factories;

    /**
     * Set the array of {@link MetaBeanFactory} instances with which to enrich
     * {@link MetaBean}s.
     * 
     * @param factories
     */
    public void setFactories(MetaBeanFactory[] factories) {
        this.factories = factories;
    }

    /**
     * Build a {@link MetaBean} for a given id.
     * 
     * @param beanInfoId
     * @return MetaBean
     * @throws Exception
     *             if unable to build
     */
    public MetaBean buildForId(String beanInfoId) throws Exception {
        throw new IllegalArgumentException("MetaBean "  beanInfoId  " not found");
    }

    /**
     * Build beans for all known ids. Default implementation returns an empty
     * map.
     * 
     * @return Map of String : MetaBean
     */
    public Map<String, MetaBean> buildAll() throws Exception {
        return new HashMap<String, MetaBean>();
    }

    /**
     * Find the named class.
     * 
     * @param className
     * @return Class found or null
     */
    protected Class<?> findLocalClass(String className) {
        if (className != null) {
            try {
                return ClassUtils.getClass(className);
            } catch (ClassNotFoundException e) {
                log.trace("class not found: "  className, e);
            }
        }
        return null;
    }

    /**
     * Build a MetaBean for the specified class.
     * 
     * @param clazz
     * @return MetaBean
     * @throws Exception
     */
    public MetaBean buildForClass(Class<?> clazz) throws Exception {
        MetaBean meta = new MetaBean();
        if (clazz != null) { // local class here?
            meta.setBeanClass(clazz);
            meta.setId(clazz.getName()); // default id = full class name!
        }
        for (MetaBeanFactory factory : factories) {
            factory.buildMetaBean(meta);
        }
        return meta;
    }
 * sufficient and you can get this instance from the
 * {@link MetaBeanManagerFactory}. <br/>
    /** MetaBean cache */
    protected final MetaBeanCache cache = new MetaBeanCache();
    /** MetaBean builder */
    protected final MetaBeanBuilder builder;
    /** Complete flag */
    protected boolean complete = false;
    /**
     * Create a new MetaBeanManager instance.
     */
    public MetaBeanManager() {
        builder = new MetaBeanBuilder();
    /**
     * Create a new MetaBeanManager instance.
     * 
     * @param builder
     */
    public MetaBeanManager(MetaBeanBuilder builder) {
        this.builder = builder;
    /**
     * Get the builder used.
     * 
     * @return {@link MetaBeanBuilder}
     */
    public MetaBeanBuilder getBuilder() {
        return builder;
    /**
     * Get the cache used.
     * 
     * @return {@link MetaBeanCache}
     */
    public MetaBeanCache getCache() {
        return cache;

    /**
     * {@inheritDoc}
     */
    public MetaBean findForId(String beanInfoId) {
        MetaBean beanInfo = cache.findForId(beanInfoId);
        if (beanInfo != null)
            return beanInfo;
        try {
            beanInfo = builder.buildForId(beanInfoId);
            cache.cache(beanInfo);
            computeRelationships(beanInfo);
            return beanInfo;
        } catch (RuntimeException e) {
            throw e; // do not wrap runtime exceptions
        } catch (Exception e) {
            throw new IllegalArgumentException("error creating beanInfo with id: "  beanInfoId, e);
        }
    }

    /**
     * {@inheritDoc}
     */
    public MetaBean findForClass(Class<?> clazz) {
        if (clazz == null)
            return null;
        MetaBean beanInfo = cache.findForClass(clazz);
        if (beanInfo != null)
            return beanInfo;
        try {
            beanInfo = builder.buildForClass(clazz);
            cache.cache(beanInfo);
            computeRelationships(beanInfo);
            return beanInfo;
        } catch (RuntimeException e) {
            throw e; // do not wrap runtime exceptions
        } catch (Exception e) {
            throw new IllegalArgumentException("error creating beanInfo for "  clazz, e);
        }
    }

    /**
     * Compute all known relationships for <code>beanInfo</code>. must be called
     * AFTER cache.cache() to avoid endless loop
     * 
     * @param beanInfo
     *            - the bean for which to compute relationships
     */
    protected void computeRelationships(MetaBean beanInfo) {
        for (MetaProperty prop : beanInfo.getProperties()) {
            String beanRef = (String) prop.getFeature(REF_BEAN_ID);
            computeRelatedMetaBean(prop, beanRef);
        }
    }

    /**
     * Compute a single related {@link MetaBean}.
     * 
     * @param prop
     * @param beanRef
     */
    protected void computeRelatedMetaBean(MetaProperty prop, String beanRef) {
        Class<?> beanType = prop.getFeature(REF_BEAN_TYPE);
        if (beanType != null) {
            prop.setMetaBean(findForClass(beanType));
        } else if (prop.getFeature(REF_CASCADE) != null) { // dynamic type
                                                           // resolution:
            prop.setMetaBean(new DynamicMetaBean(this));
        }
    }
    private static String ATOM = "[^\\x00-\\x1F^\\(^\\)^\\<^\\>^\\@^\\,^\\;^\\:^\\\\^\\\"^\\.^\\[^\\]^\\s]";
    private static String DOMAIN = "("  ATOM  "(\\."  ATOM  ")*";
    private static String IP_DOMAIN = "\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\]";
    public static final java.util.regex.Pattern DEFAULT_EMAIL_PATTERN;
    static {
        DEFAULT_EMAIL_PATTERN =
            java.util.regex.Pattern.compile("^"  ATOM  "(\\."  ATOM  ")*@"  DOMAIN  "|"  IP_DOMAIN  ")$",
                java.util.regex.Pattern.CASE_INSENSITIVE);
    }
    /**
     * Learn whether a given object is a valid email address.
     * 
     * @param value
     *            to check
     * @return <code>true</code> if the validation passes
     */
    public static boolean isValid(Object value) {
        return isValid(value, DEFAULT_EMAIL_PATTERN);
    }
    /**
     * Learn whether a particular value matches a given pattern per
     * {@link Matcher#matches()}.
     * 
     * @param value
     * @param aPattern
     * @return <code>true</code> if <code>value</code> was a <code>String</code>
     *         matching <code>aPattern</code>
     */
    // TODO it would seem to make sense to move or reduce the visibility of this
    // method as it is more general than email.
    public static boolean isValid(Object value, Pattern aPattern) {
        if (value == null)
            return true;
        if (!(value instanceof CharSequence))
            return false;
        CharSequence seq = (CharSequence) value;
        if (seq.length() == 0)
            return true;
        Matcher m = aPattern.matcher(seq);
        return m.matches();
    }
 * Description: Undefined dynamic strategy (FIELD or METHOD access) Uses
 * PropertyUtils or tries to determine field to access the value<br/>
    private final Class<?> beanClass;
    private final String propertyName;
    private Field rememberField;
    /**
     * Create a new PropertyAccess instance.
     * 
     * @param clazz
     * @param propertyName
     */
    public PropertyAccess(Class<?> clazz, String propertyName) {
        this.beanClass = clazz;
        this.propertyName = propertyName;
    /**
     * {@inheritDoc}
     */
    public ElementType getElementType() {
        return (rememberField != null) ? ElementType.FIELD : ElementType.METHOD;

    private static Object getPublicProperty(Object bean, String property) throws InvocationTargetException,
        NoSuchMethodException, IllegalAccessException {
        if (bean instanceof Map<?, ?>) {
            return ((Map<?, ?>) bean).get(property);
        } else { // supports DynaBean and standard Objects
            return PropertyUtils.getSimpleProperty(bean, property);
    /**
     * Get a named property from <code>bean</code>.
     * 
     * @param bean
     * @param propertyName
     * @return Object found
     * @throws InvocationTargetException
     * @throws NoSuchMethodException
     * @throws IllegalAccessException
     */
    public static Object getProperty(Object bean, String propertyName) throws InvocationTargetException,
        NoSuchMethodException, IllegalAccessException {
        return new PropertyAccess(bean.getClass(), propertyName).get(bean);
    /**
     * {@inheritDoc}
     */
    public String toString() {
        return "Property{"  beanClass.getName()  '.'  propertyName  '}';
    }

    /**
     * {@inheritDoc}
     */
    public Type getJavaType() {
        /*
         * if(Map.class.isAssignableFrom(beanClass)) { return beanClass. }
         */
        if (rememberField != null) { // use cached field of previous access
            return rememberField.getGenericType();
        for (PropertyDescriptor each : PropertyUtils.getPropertyDescriptors(beanClass)) {
            if (each.getName().equals(propertyName) && each.getReadMethod() != null) {
                return each.getReadMethod().getGenericReturnType();
            }
        }
        try { // try public field
            return beanClass.getField(propertyName).getGenericType();
        } catch (NoSuchFieldException ex2) {
            // search for private/protected field up the hierarchy
            Class<?> theClass = beanClass;
            while (theClass != null) {
                try {
                    return theClass.getDeclaredField(propertyName).getGenericType();
                } catch (NoSuchFieldException ex3) {
                    // do nothing
                }
                theClass = theClass.getSuperclass();
            }
        }
        return Object.class; // unknown type: allow any type??
    /**
     * {@inheritDoc}
     */
    public String getPropertyName() {
        return propertyName;
    }
    /**
     * {@inheritDoc}
     */
    public Object get(Object bean) {
        try {
            if (rememberField != null) { // cache field of previous access
                return rememberField.get(bean);
            }
            try { // try public method
                return getPublicProperty(bean, propertyName);
            } catch (NoSuchMethodException ex) {
                return getFieldValue(bean);
            }
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (Exception e) {
            throw new IllegalArgumentException("cannot access "  propertyName, e);
        }
    }
    private Object getFieldValue(Object bean) throws IllegalAccessException {
        Object value;
        try { // try public field
            Field aField = bean.getClass().getField(propertyName);
            value = aField.get(bean);
            rememberField = aField;
            return value;
        } catch (NoSuchFieldException ex2) {
            // search for private/protected field up the hierarchy
            Class<?> theClass = bean.getClass();
            while (theClass != null) {
                try {
                    Field aField = theClass.getDeclaredField(propertyName);
                    if (!aField.isAccessible()) {
                        aField.setAccessible(true);
                    }
                    value = aField.get(bean);
                    rememberField = aField;
                    return value;
                } catch (NoSuchFieldException ex3) {
                    // do nothing
                }
                theClass = theClass.getSuperclass();
            }
            throw new IllegalArgumentException("cannot access field "  propertyName);
        }
    }

    /**
     * {@inheritDoc}
     */
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;

        PropertyAccess that = (PropertyAccess) o;

        return beanClass.equals(that.beanClass) && propertyName.equals(that.propertyName);
    }

    /**
     * {@inheritDoc}
     */
    public int hashCode() {
        int result;
        result = beanClass.hashCode();
        result = 31 * result  propertyName.hashCode();
        return result;
    }
    VALUE1, VALUE2, VALUE3
 * Description: Represents the context that is used to create
 * <code>ClassValidator</code> instances.<br/>
    private final ApacheValidatorFactory factory;
    private final MetaBeanFinder metaBeanFinder;
    private MessageInterpolator messageInterpolator;
    private TraversableResolver traversableResolver;
    private ConstraintValidatorFactory constraintValidatorFactory;
     * Create a new ApacheFactoryContext instance.
     * 
     * @param factory
     */
    public ApacheFactoryContext(ApacheValidatorFactory factory) {
        this.factory = factory;
        this.metaBeanFinder = buildMetaBeanManager();
    }

    /**
     * Create a new ApacheFactoryContext instance.
     * 
     * @param factory
     * @param metaBeanFinder
     */
    protected ApacheFactoryContext(ApacheValidatorFactory factory, MetaBeanFinder metaBeanFinder) {
        this.factory = factory;
        this.metaBeanFinder = metaBeanFinder;
    }

    /**
     * Get the {@link ApacheValidatorFactory} used by this
     * {@link ApacheFactoryContext}.
     * 
     * @return {@link ApacheValidatorFactory}
     */
    public ApacheValidatorFactory getFactory() {
        return factory;
    }

    /**
     * Get the metaBeanFinder.
     * 
     * @return {@link MetaBeanFinder}
     */
    public final MetaBeanFinder getMetaBeanFinder() {
        return metaBeanFinder;
    }

    /**
     * {@inheritDoc}
     */
    public ValidatorContext messageInterpolator(MessageInterpolator messageInterpolator) {
        this.messageInterpolator = messageInterpolator;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    public ValidatorContext traversableResolver(TraversableResolver traversableResolver) {
        this.traversableResolver = traversableResolver;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    public ValidatorContext constraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory) {
        this.constraintValidatorFactory = constraintValidatorFactory;
        return this;
    }

    /**
     * Get the {@link ConstraintValidatorFactory}.
     * 
     * @return {@link ConstraintValidatorFactory}
     */
    public ConstraintValidatorFactory getConstraintValidatorFactory() {
        return constraintValidatorFactory == null ? factory.getConstraintValidatorFactory()
            : constraintValidatorFactory;
    }

    /**
     * {@inheritDoc}
     */
    public Validator getValidator() {
        ClassValidator validator = new ClassValidator(this);
        if (Boolean.getBoolean(factory.getProperties().get(
            ApacheValidatorConfiguration.Properties.TREAT_MAPS_LIKE_BEANS))) {
            validator.setTreatMapsLikeBeans(true);
        }
        return validator;
    }

    /**
     * Get the {@link MessageInterpolator}.
     * 
     * @return {@link MessageInterpolator}
     */
    public MessageInterpolator getMessageInterpolator() {
        return messageInterpolator == null ? factory.getMessageInterpolator() : messageInterpolator;
    }

    /**
     * Get the {@link TraversableResolver}.
     * 
     * @return {@link TraversableResolver}
     */
    public TraversableResolver getTraversableResolver() {
        return traversableResolver == null ? factory.getTraversableResolver() : traversableResolver;
    }

    /**
     * Create MetaBeanManager that uses JSR303-XML  JSR303-Annotations to build
     * meta-data from.
     * 
     * @return a new instance of MetaBeanManager with adequate MetaBeanFactories
     */
    @SuppressWarnings("deprecation")
    protected MetaBeanManager buildMetaBeanManager() {
        // this is relevant: xml before annotations
        // (because ignore-annotations settings in xml)
        List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>(3);
        if (Boolean.parseBoolean(factory.getProperties().get(
            ApacheValidatorConfiguration.Properties.ENABLE_INTROSPECTOR))) {
            builders.add(new IntrospectorMetaBeanFactory());
        }
        builders.add(new Jsr303MetaBeanFactory(this));
        // as long as we support both: jsr303 and xstream-xml metabeans:
        if (Boolean.parseBoolean(factory.getProperties().get(
            ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML))) {
            return XMLMetaBeanManagerCreator.createXMLMetaBeanManager(builders);
        } else {
            return createMetaBeanManager(builders);
        }
    }

    /**
     * Create a {@link MetaBeanManager} using the specified builders.
     * 
     *            {@link MetaBeanFactory} {@link List}
    protected MetaBeanManager createMetaBeanManager(List<MetaBeanFactory> builders) {
        return new MetaBeanManager(new MetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));

    /**
     * separate class to prevent the classloader to immediately load optional
     * classes: XMLMetaBeanManager, XMLMetaBeanFactory, XMLMetaBeanBuilder that
     * might not be available in the classpath
     */
    private static class XMLMetaBeanManagerCreator {

        /**
         * Create the {@link MetaBeanManager} to process JSR303 XML. Requires
         * bval-xstream at RT.
         * 
         * @param builders
         * @return {@link MetaBeanManager}
         */
        // NOTE - We return MetaBeanManager instead of XMLMetaBeanManager to
        // keep
        // bval-xstream an optional module.
        protected static MetaBeanManager createXMLMetaBeanManager(List<MetaBeanFactory> builders) {
            builders.add(new XMLMetaBeanFactory());
            return new XMLMetaBeanManager(
                new XMLMetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
        }
    }
 * Description: immutable, serializable implementation of ConstraintDescriptor
 * interface of JSR303<br>
    /** Serialization version */
    private static final long serialVersionUID = 1L;
    private final T annotation;
    private final Set<Class<?>> groups;
    private final Set<Class<? extends javax.validation.Payload>> payload;
    private final List<java.lang.Class<? extends javax.validation.ConstraintValidator<T, ?>>> constraintValidatorClasses;
    private final Map<String, Object> attributes;
    private final Set<ConstraintDescriptor<?>> composingConstraints;
    private final boolean reportAsSingleViolation;
    /**
     * Create a new ConstraintDescriptorImpl instance.
     * 
     * @param descriptor
     */
    public ConstraintDescriptorImpl(ConstraintDescriptor<T> descriptor) {
        this(descriptor.getAnnotation(), descriptor.getGroups(), descriptor.getPayload(), descriptor
            .getConstraintValidatorClasses(), descriptor.getAttributes(), descriptor.getComposingConstraints(),
            descriptor.isReportAsSingleViolation());
    }
    /**
     * Create a new ConstraintDescriptorImpl instance.
     * 
     * @param annotation
     * @param groups
     * @param payload
     * @param constraintValidatorClasses
     * @param attributes
     * @param composingConstraints
     * @param reportAsSingleViolation
     */
    public ConstraintDescriptorImpl(T annotation, Set<Class<?>> groups,
        Set<Class<? extends javax.validation.Payload>> payload,
        List<java.lang.Class<? extends javax.validation.ConstraintValidator<T, ?>>> constraintValidatorClasses,
        Map<String, Object> attributes, Set<ConstraintDescriptor<?>> composingConstraints,
        boolean reportAsSingleViolation) {
        this.annotation = annotation;
        this.groups = groups;
        this.payload = payload;
        this.constraintValidatorClasses = constraintValidatorClasses;
        this.attributes = attributes;
        this.composingConstraints = composingConstraints;
        this.reportAsSingleViolation = reportAsSingleViolation;
    }
    /**
     * {@inheritDoc}
     */
    public T getAnnotation() {
        return annotation;
    }
    /**
     * {@inheritDoc}
     */
    public Set<Class<?>> getGroups() {
        return groups;
    }
    /**
     * {@inheritDoc}
     */
    public Set<Class<? extends Payload>> getPayload() {
        return payload;
    }
    /**
     * {@inheritDoc}
     */
    public List<java.lang.Class<? extends javax.validation.ConstraintValidator<T, ?>>> getConstraintValidatorClasses() {
        return constraintValidatorClasses;
    }
    /**
     * {@inheritDoc}
     */
    public Map<String, Object> getAttributes() {
        return attributes;
    }
    /**
     * {@inheritDoc}
     */
    public Set<ConstraintDescriptor<?>> getComposingConstraints() {
        return composingConstraints;
    }
    /**
     * {@inheritDoc}
     */
    public boolean isReportAsSingleViolation() {
        return reportAsSingleViolation;
    }
public class ConstraintValidation<T extends Annotation> implements Validation, ConstraintDescriptor<T> {
    private static final String ANNOTATION_MESSAGE = "message";
    private final ConstraintValidator<T, ?> validator;
    private T annotation; // for metadata request API
    private final AccessStrategy access;
    private final boolean reportFromComposite;
    private final Map<String, Object> attributes;
    private Set<ConstraintValidation<?>> composedConstraints;
     * the owner is the type where the validation comes from. it is used to
     * support implicit grouping.
    private final Class<?> owner;
    private Set<Class<?>> groups;
    private Set<Class<? extends Payload>> payload;
    private Class<? extends ConstraintValidator<T, ?>>[] validatorClasses;
    /**
     * Create a new ConstraintValidation instance.
     * 
     * @param validatorClasses
     * @param validator
     *            - the constraint validator
     * @param annotation
     *            - the annotation of the constraint
     * @param owner
     *            - the type where the annotated element is placed (class,
     *            interface, annotation type)
     * @param access
     *            - how to access the value
     * @param reportFromComposite
     */
    public ConstraintValidation(Class<? extends ConstraintValidator<T, ?>>[] validatorClasses,
        ConstraintValidator<T, ?> validator, T annotation, Class<?> owner, AccessStrategy access,
        boolean reportFromComposite) {
        this.attributes = new HashMap<String, Object>();
        this.validatorClasses = validatorClasses;
        this.validator = validator;
        this.annotation = annotation;
        this.owner = owner;
        this.access = access;
        this.reportFromComposite = reportFromComposite;
    /**
     * Return a {@link Serializable} {@link ConstraintDescriptor} capturing a
     * snapshot of current state.
     * 
     * @return {@link ConstraintDescriptor}
     */
    public ConstraintDescriptor<T> asSerializableDescriptor() {
        return new ConstraintDescriptorImpl<T>(this);
    /**
     * Set the applicable validation groups.
     * 
     * @param groups
     */
    void setGroups(Set<Class<?>> groups) {
        this.groups = groups;
        this.attributes.put("groups", groups.toArray(new Class[groups.size()]));
    /**
     * Set the payload.
     * 
     * @param payload
     */
    void setPayload(Set<Class<? extends Payload>> payload) {
        this.payload = payload;
        this.attributes.put("payload", payload.toArray(new Class[payload.size()]));
    /**
     * {@inheritDoc}
     */
    public boolean isReportAsSingleViolation() {
        return reportFromComposite;

    /**
     * Add a composing constraint.
     * 
     * @param aConstraintValidation
     *            to add
     */
    public void addComposed(ConstraintValidation<?> aConstraintValidation) {
        if (composedConstraints == null) {
            composedConstraints = new HashSet<ConstraintValidation<?>>();
        }
        composedConstraints.add(aConstraintValidation);
    }

    /**
     * {@inheritDoc}
     */
    public <L extends ValidationListener> void validate(ValidationContext<L> context) {
        validate((GroupValidationContext<?>) context);
    }

    /**
     * Validate a {@link GroupValidationContext}.
     * 
     * @param context
     *            root
     */
    public void validate(GroupValidationContext<?> context) {
        context.setConstraintValidation(this);
        /**
         * execute unless the given validation constraint has already been
         * processed during this validation routine (as part of a previous group
         * match)
         */
        if (!isMemberOf(context.getCurrentGroup().getGroup())) {
            return; // do not validate in the current group
        }
        if (context.getCurrentOwner() != null && this.owner != context.getCurrentOwner()) {
            return;
        }
        if (validator != null && !context.collectValidated(validator))
            return; // already done

        if (context.getMetaProperty() != null && !isReachable(context)) {
            return;
        }

        // process composed constraints
        if (isReportAsSingleViolation()) {
            ConstraintValidationListener<?> listener = context.getListener();
            listener.beginReportAsSingle();

            boolean failed = false;
            try {
                // stop validating when already failed and
                // ReportAsSingleInvalidConstraint = true ?
                for (Iterator<ConstraintValidation<?>> composed = getComposingValidations().iterator(); !failed
                    && composed.hasNext();) {
                    composed.next().validate(context);
                    failed = listener.hasViolations();
                }
            } finally {
                listener.endReportAsSingle();
                // Restore current constraint validation
                context.setConstraintValidation(this);
            }

            if (failed) {
                // TODO RSt - how should the composed constraint error report
                // look like?
                ConstraintValidatorContextImpl jsrContext = new ConstraintValidatorContextImpl(context, this);
                addErrors(context, jsrContext); // add defaultErrorMessage
                                                // only*/
                return;
            }
        } else {
            for (ConstraintValidation<?> composed : getComposingValidations()) {
                composed.validate(context);
            }

            // Restore current constraint validation
            context.setConstraintValidation(this);
        }

        if (validator != null) {
            ConstraintValidatorContextImpl jsrContext = new ConstraintValidatorContextImpl(context, this);
            @SuppressWarnings("unchecked")
            final ConstraintValidator<T, Object> objectValidator = (ConstraintValidator<T, Object>) validator;
            if (!objectValidator.isValid(context.getValidatedValue(), jsrContext)) {
                addErrors(context, jsrContext);
            }
        }
    }

    /**
     * Initialize the validator (if not <code>null</code>) with the stored
     * annotation.
     */
    public void initialize() {
        if (null != validator) {
            try {
                validator.initialize(annotation);
            } catch (RuntimeException e) {
                // Either a "legit" problem initializing the validator or a
                // ClassCastException if the validator associated annotation is
                // not a supertype of the validated annotation.
                throw new ConstraintDefinitionException("Incorrect validator ["
                     validator.getClass().getCanonicalName()  "] for annotation "
                     annotation.annotationType().getCanonicalName(), e);
            }
        }
    }

    private boolean isReachable(GroupValidationContext<?> context) {
        PathImpl path = context.getPropertyPath();
        NodeImpl node = path.getLeafNode();
        PathImpl beanPath = path.getPathWithoutLeafNode();
        if (beanPath == null) {
            beanPath = PathImpl.create(null);
        }
        try {
            if (!context.getTraversableResolver().isReachable(context.getBean(), node,
                context.getRootMetaBean().getBeanClass(), beanPath, access.getElementType()))
                return false;
        } catch (RuntimeException e) {
            throw new ValidationException("Error in TraversableResolver.isReachable() for "  context.getBean(), e);
        }

        return true;
    }

    private void addErrors(GroupValidationContext<?> context, ConstraintValidatorContextImpl jsrContext) {
        for (ValidationListener.Error each : jsrContext.getErrorMessages()) {
            context.getListener().addError(each, context);
        }
    }

    /**
     * {@inheritDoc}
     */
    public String toString() {
        return "ConstraintValidation{"  validator  '}';
    }

    /**
     * Get the message template used by this constraint.
     * 
     * @return String
     */
    public String getMessageTemplate() {
        return (String) attributes.get(ANNOTATION_MESSAGE);
    }

    /**
     * Get the {@link ConstraintValidator} invoked by this
     * {@link ConstraintValidation}.
     * 
     * @return
     */
    public ConstraintValidator<T, ?> getValidator() {
        return validator;
    }

    /**
     * Learn whether this {@link ConstraintValidation} belongs to the specified
     * group.
     * 
     * @param reqGroup
     * @return boolean
     */
    protected boolean isMemberOf(Class<?> reqGroup) {
        return groups.contains(reqGroup);
    }

    /**
     * Get the owning class of this {@link ConstraintValidation}.
     * 
     * @return Class
     */
    public Class<?> getOwner() {
        return owner;
    }

    /**
     * {@inheritDoc}
     */
    public T getAnnotation() {
        return annotation;
    }

    /**
     * Get the {@link AccessStrategy} used by this {@link ConstraintValidation}.
     * 
     * @return {@link AccessStrategy}
     */
    public AccessStrategy getAccess() {
        return access;
    }

    /**
     * Override the Annotation set at construction.
     * 
     * @param annotation
     */
    public void setAnnotation(T annotation) {
        this.annotation = annotation;
    }

    // ///////////////////////// ConstraintDescriptor implementation

    /**
     * {@inheritDoc}
     */
    public Map<String, Object> getAttributes() {
        return attributes;
    }

    /**
     * {@inheritDoc}
     */
    @SuppressWarnings("unchecked")
    public Set<ConstraintDescriptor<?>> getComposingConstraints() {
        return composedConstraints == null ? Collections.EMPTY_SET : composedConstraints;
    }

    /**
     * Get the composing {@link ConstraintValidation} objects. This is
     * effectively an implementation-specific analogue to
     * {@link #getComposingConstraints()}.
     * 
     * @return {@link Set} of {@link ConstraintValidation}
     */
    @SuppressWarnings("unchecked")
    Set<ConstraintValidation<?>> getComposingValidations() {
        return composedConstraints == null ? Collections.EMPTY_SET : composedConstraints;
    }

    /**
     * {@inheritDoc}
     */
    public Set<Class<?>> getGroups() {
        return groups;
    }

    /**
     * {@inheritDoc}
     */
    public Set<Class<? extends Payload>> getPayload() {
        return payload;
    }

    /**
     * {@inheritDoc}
     */
    public List<Class<? extends ConstraintValidator<T, ?>>> getConstraintValidatorClasses() {
        if (validatorClasses == null) {
            return Collections.emptyList();
        }
        return Arrays.asList(validatorClasses);
    }
    /**
     * Create a new MethodValidatorImpl instance.
     * 
     * @param factoryContext
     */
    public MethodValidatorImpl(ApacheFactoryContext factoryContext) {
        super(factoryContext);
        patchFactoryContextForMethodValidation(factoryContext);
    /**
     * experimental: replace the Jsr303MetaBeanFactory with a
     * MethodValidatorMetaBeanFactory in the factoryContext.
     * 
     * @param factoryContext
     */
    private void patchFactoryContextForMethodValidation(ApacheFactoryContext factoryContext) {
        MetaBeanFactory[] factories = ((MetaBeanManager) getMetaBeanFinder()).getBuilder().getFactories();
        for (int i = 0; i < factories.length; i) {
            if (factories[i] instanceof Jsr303MetaBeanFactory
                && !(factories[i] instanceof MethodValidatorMetaBeanFactory)) {
                factories[i] = new MethodValidatorMetaBeanFactory(factoryContext);
            }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected BeanDescriptorImpl createBeanDescriptor(MetaBean metaBean) {
        MethodBeanDescriptorImpl descriptor =
            new MethodBeanDescriptorImpl(factoryContext, metaBean, metaBean.getValidations());
        MethodValidatorMetaBeanFactory factory = new MethodValidatorMetaBeanFactory(factoryContext);
        factory.buildMethodDescriptor(descriptor);
        return descriptor;
    }

    /**
     * {@inheritDoc} enhancement: method-level-validation not yet completly
     * implemented
     * 
     * <pre>
     * example:
     * <code>
     * public @NotNull String saveItem(@Valid @NotNull Item item, @Max(23) BigDecimal
     * </code>
     * </pre>
     * 
     * spec: The constraints declarations evaluated are the constraints hosted
     * on the parameters of the method or constructor. If @Valid is placed on a
     * parameter, constraints declared on the object itself are considered.
     * 
     * @throws IllegalArgumentException
     *             enhancement: if the method does not belong to <code>T</code>
     *             or if the Object[] does not match the method signature
     */
    public <T> Set<ConstraintViolation<T>> validateParameters(Class<T> clazz, Method method, Object[] parameters,
        Class<?>... groupArray) {
        MethodBeanDescriptorImpl beanDesc = (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
        MethodDescriptorImpl methodDescriptor = (MethodDescriptorImpl) beanDesc.getConstraintsForMethod(method);
        if (methodDescriptor == null) {
            throw new ValidationException("Method "  method  " doesn't belong to class "  clazz);
        }
        return validateParameters(methodDescriptor.getMetaBean(), methodDescriptor.getParameterDescriptors(),
            parameters, groupArray);
    }

    /**
     * {@inheritDoc}
     */
    public <T> Set<ConstraintViolation<T>> validateParameter(Class<T> clazz, Method method, Object parameter,
        int parameterIndex, Class<?>... groupArray) {
        MethodBeanDescriptorImpl beanDesc = (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
        MethodDescriptorImpl methodDescriptor = (MethodDescriptorImpl) beanDesc.getConstraintsForMethod(method);
        if (methodDescriptor == null) {
            throw new ValidationException("Method "  method  " doesn't belong to class "  clazz);
        }
        ParameterDescriptorImpl paramDesc =
            (ParameterDescriptorImpl) methodDescriptor.getParameterDescriptors().get(parameterIndex);
        return validateParameter(paramDesc, parameter, groupArray);
    }

    /**
     * {@inheritDoc}
     */
    public <T> Set<ConstraintViolation<T>> validateParameters(Class<T> clazz, Constructor<T> constructor,
        Object[] parameters, Class<?>... groupArray) {
        MethodBeanDescriptorImpl beanDesc = (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
        ConstructorDescriptorImpl constructorDescriptor =
            (ConstructorDescriptorImpl) beanDesc.getConstraintsForConstructor(constructor);
        if (constructorDescriptor == null) {
            throw new ValidationException("Constructor "  constructor  " doesn't belong to class "  clazz);
        }
        return validateParameters(constructorDescriptor.getMetaBean(), constructorDescriptor.getParameterDescriptors(),
            parameters, groupArray);
    }

    /**
     * {@inheritDoc}
     */
    public <T> Set<ConstraintViolation<T>> validateParameter(Class<T> clazz, Constructor<T> constructor,
        Object parameter, int parameterIndex, Class<?>... groupArray) {
        MethodBeanDescriptorImpl beanDesc = (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
        ConstructorDescriptorImpl constructorDescriptor =
            (ConstructorDescriptorImpl) beanDesc.getConstraintsForConstructor(constructor);
        if (constructorDescriptor == null) {
            throw new ValidationException("Constructor "  constructor  " doesn't belong to class "  clazz);
        }
        ParameterDescriptorImpl paramDesc =
            (ParameterDescriptorImpl) constructorDescriptor.getParameterDescriptors().get(parameterIndex);
        return validateParameter(paramDesc, parameter, groupArray);
    }

    /**
     * {@inheritDoc} If @Valid is placed on the method, the constraints declared
     * on the object itself are considered.
     */
    @SuppressWarnings("unchecked")
    public <T> Set<ConstraintViolation<T>> validateReturnedValue(Class<T> clazz, Method method, Object returnedValue,
        Class<?>... groupArray) {
        MethodBeanDescriptorImpl beanDesc = (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
        MethodDescriptorImpl methodDescriptor = (MethodDescriptorImpl) beanDesc.getConstraintsForMethod(method);
        if (methodDescriptor == null) {
            throw new ValidationException("Method "  method  " doesn't belong to class "  clazz);
        }
        final GroupValidationContext<Object> context =
            createContext(methodDescriptor.getMetaBean(), returnedValue, null, groupArray);
        validateReturnedValueInContext(context, methodDescriptor);
    @SuppressWarnings("unchecked")
    private <T> Set<ConstraintViolation<T>> validateParameters(MetaBean metaBean,
        List<ParameterDescriptor> paramDescriptors, Object[] parameters, Class<?>... groupArray) {
        if (parameters == null)
            throw new IllegalArgumentException("cannot validate null");
        if (parameters.length > 0) {
            try {
                GroupValidationContext<ConstraintValidationListener<Object[]>> context =
                    createContext(metaBean, null, null, groupArray);
                for (int i = 0; i < parameters.length; i) {
                    ParameterDescriptorImpl paramDesc = (ParameterDescriptorImpl) paramDescriptors.get(i);
                    context.setBean(parameters[i]);
                    validateParameterInContext(context, paramDesc);
                }
                ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
                return result.getConstraintViolations();
            } catch (RuntimeException ex) {
                throw unrecoverableValidationError(ex, parameters);
            }
        } else {
            return Collections.<ConstraintViolation<T>> emptySet();
    @SuppressWarnings("unchecked")
    private <T> Set<ConstraintViolation<T>> validateParameter(ParameterDescriptorImpl paramDesc, Object parameter,
        Class<?>... groupArray) {
        try {
            final GroupValidationContext<Object> context =
                createContext(paramDesc.getMetaBean(), parameter, null, groupArray);
            final ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
            validateParameterInContext(context, paramDesc);
            return result.getConstraintViolations();
        } catch (RuntimeException ex) {
            throw unrecoverableValidationError(ex, parameter);

    /**
     * validate constraints hosted on parameters of a method
     */
    private <T> void validateParameterInContext(GroupValidationContext<T> context, ParameterDescriptorImpl paramDesc) {

        final Groups groups = context.getGroups();

        for (ConstraintDescriptor<?> consDesc : paramDesc.getConstraintDescriptors()) {
            ConstraintValidation<?> validation = (ConstraintValidation<?>) consDesc;
            // 1. process groups
            for (Group current : groups.getGroups()) {
                context.setCurrentGroup(current);
                validation.validate(context);
            }
            // 2. process sequences
            for (List<Group> eachSeq : groups.getSequences()) {
                for (Group current : eachSeq) {
                    context.setCurrentGroup(current);
                    validation.validate(context);
                    /**
                     * if one of the group process in the sequence leads to one
                     * or more validation failure, the groups following in the
                     * sequence must not be processed
                     */
                    if (!context.getListener().isEmpty())
                        break;
                }
            }
        if (paramDesc.isCascaded() && context.getValidatedValue() != null) {
            context
                .setMetaBean(factoryContext.getMetaBeanFinder().findForClass(context.getValidatedValue().getClass()));
            // 1. process groups
            for (Group current : groups.getGroups()) {
                context.setCurrentGroup(current);
                ValidationHelper
                    .validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
            }
            // 2. process sequences
            for (List<Group> eachSeq : groups.getSequences()) {
                for (Group current : eachSeq) {
                    context.setCurrentGroup(current);
                    ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context),
                        isTreatMapsLikeBeans());
                    /**
                     * if one of the group process in the sequence leads to one
                     * or more validation failure, the groups following in the
                     * sequence must not be processed
                     */
                    if (!context.getListener().isEmpty())
                        break;
                }
            }
        }

    /**
     * validate constraints hosted on parameters of a method
     */
    private <T> void validateReturnedValueInContext(GroupValidationContext<T> context,
        MethodDescriptorImpl methodDescriptor) {

        final Groups groups = context.getGroups();

        for (ConstraintDescriptor<?> consDesc : methodDescriptor.getConstraintDescriptors()) {
            ConstraintValidation<?> validation = (ConstraintValidation<?>) consDesc;
            // 1. process groups
            for (Group current : groups.getGroups()) {
                context.setCurrentGroup(current);
                validation.validate(context);
            }
            // 2. process sequences
            for (List<Group> eachSeq : groups.getSequences()) {
                for (Group current : eachSeq) {
                    context.setCurrentGroup(current);
                    validation.validate(context);
                    /**
                     * if one of the group process in the sequence leads to one
                     * or more validation failure, the groups following in the
                     * sequence must not be processed
                     */
                    if (!context.getListener().isEmpty())
                        break;
                }
            }
        }
        if (methodDescriptor.isCascaded() && context.getValidatedValue() != null) {
            context
                .setMetaBean(factoryContext.getMetaBeanFinder().findForClass(context.getValidatedValue().getClass()));
            // 1. process groups
            for (Group current : groups.getGroups()) {
                context.setCurrentGroup(current);
                ValidationHelper
                    .validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
            }
            // 2. process sequences
            for (List<Group> eachSeq : groups.getSequences()) {
                for (Group current : eachSeq) {
                    context.setCurrentGroup(current);
                    ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context),
                        isTreatMapsLikeBeans());
                    /**
                     * if one of the group process in the sequence leads to one
                     * or more validation failure, the groups following in the
                     * sequence must not be processed
                     */
                    if (!context.getListener().isEmpty())
                        break;
                }
            }
        }
    }
 * Description: extension to validate parameters/return values of
 * methods/constructors.<br/>
// TODO RSt - move. this is an optional module: move the whole package. core
// code has no dependencies on it
    /**
     * Create a new MethodValidatorMetaBeanFactory instance.
     * 
     * @param factoryContext
     */
    public MethodValidatorMetaBeanFactory(ApacheFactoryContext factoryContext) {
        super(factoryContext);
    /**
     * {@inheritDoc}
     */
    @Override
    protected boolean hasValidationConstraintsDefined(Method method) {
        return false;
    }
    /**
     * Finish building the specified {@link MethodBeanDescriptorImpl}.
     * 
     * @param descriptor
     */
    public void buildMethodDescriptor(MethodBeanDescriptorImpl descriptor) {
        try {
            buildMethodConstraints(descriptor);
            buildConstructorConstraints(descriptor);
        } catch (Exception e) {
            throw new IllegalArgumentException(e.getMessage(), e);
    private void buildConstructorConstraints(MethodBeanDescriptorImpl beanDesc) throws InvocationTargetException,
        IllegalAccessException {
        beanDesc.setConstructorConstraints(new HashMap<Constructor<?>, ConstructorDescriptor>());
        for (Constructor<?> cons : beanDesc.getMetaBean().getBeanClass().getDeclaredConstructors()) {
            if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(cons)) {
                ConstructorDescriptorImpl consDesc =
                    new ConstructorDescriptorImpl(beanDesc.getMetaBean(), new Validation[0]);
                beanDesc.putConstructorDescriptor(cons, consDesc);
                Annotation[][] paramsAnnos = cons.getParameterAnnotations();
                int idx = 0;
                for (Annotation[] paramAnnos : paramsAnnos) {
                    ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
                    processAnnotations(consDesc, paramAnnos, access, idx);
                    idx;
                }
            }
        }
    }
    private void buildMethodConstraints(MethodBeanDescriptorImpl beanDesc) throws InvocationTargetException,
        IllegalAccessException {
        beanDesc.setMethodConstraints(new HashMap<Method, MethodDescriptor>());

        for (Method method : beanDesc.getMetaBean().getBeanClass().getDeclaredMethods()) {
            if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(method)) {

                MethodDescriptorImpl methodDesc = new MethodDescriptorImpl(beanDesc.getMetaBean(), new Validation[0]);
                beanDesc.putMethodDescriptor(method, methodDesc);

                // return value validations
                AppendValidationToList validations = new AppendValidationToList();
                ReturnAccess returnAccess = new ReturnAccess(method.getReturnType());
                for (Annotation anno : method.getAnnotations()) {
                    if (anno instanceof Valid) {
                        methodDesc.setCascaded(true);
                    } else {
                        processAnnotation(anno, methodDesc, returnAccess, validations);
                    }
                }
                methodDesc.getConstraintDescriptors().addAll(validations.getValidations());

                // parameter validations
                Annotation[][] paramsAnnos = method.getParameterAnnotations();
                int idx = 0;
                for (Annotation[] paramAnnos : paramsAnnos) {
                    ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
                    processAnnotations(methodDesc, paramAnnos, access, idx);
                    idx;
                }
            }
        }
    }

    private void processAnnotations(ProcedureDescriptor methodDesc, Annotation[] paramAnnos, AccessStrategy access,
        int idx) throws InvocationTargetException, IllegalAccessException {
        boolean cascaded = false;
        for (Annotation anno : paramAnnos) {
            if (anno instanceof Valid) {
                cascaded = true;
            } else {
                processAnnotation(anno, methodDesc, access, validations);
            }
        ParameterDescriptorImpl paramDesc =
            new ParameterDescriptorImpl(methodDesc.getMetaBean(), validations.getValidations().toArray(
                new Validation[validations.getValidations().size()]));
        paramDesc.setIndex(idx);
        paramDesc.setCascaded(cascaded);
        methodDesc.getParameterDescriptors().add(paramDesc);
    }
    private <A extends Annotation> void processAnnotation(A annotation, ProcedureDescriptor desc,
        AccessStrategy access, AppendValidation validations) throws InvocationTargetException, IllegalAccessException {

        if (annotation instanceof Valid) {
            desc.setCascaded(true);
        } else {
            Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
            if (vcAnno != null) {
                Class<? extends ConstraintValidator<A, ?>>[] validatorClasses;
                validatorClasses = findConstraintValidatorClasses(annotation, vcAnno);
                applyConstraint(annotation, validatorClasses, null, ClassUtils.primitiveToWrapper((Class<?>) access
                    .getJavaType()), access, validations);
            } else {
                /**
                 * Multi-valued constraints
                 */
                Object result = SecureActions.getAnnotationValue(annotation, ANNOTATION_VALUE);
                if (result != null && result instanceof Annotation[]) {
                    for (Annotation each : (Annotation[]) result) {
                        processAnnotation(each, desc, access, validations); // recursion
                    }
                }
            }
    private XMLMetaBeanFactory xmlFactory;
    public XMLMetaBeanBuilder(MetaBeanFactory[] factories) {
        setFactories(factories);
    public XMLMetaBeanBuilder() {
        setFactories(new MetaBeanFactory[] { new IntrospectorMetaBeanFactory(), new XMLMetaBeanFactory() });
    }
    public void setFactories(MetaBeanFactory[] factories) {
        super.setFactories(factories);
        updateXmlFactory();
    }

    public void addLoader(XMLMetaBeanLoader loader) {
        assertXmlFactory();
        xmlFactory.addLoader(loader);
    }

    public MetaBean buildForId(String beanInfoId) throws Exception {
        final XMLMetaBeanFactory.Visitor v;
        assertXmlFactory();
        xmlFactory.visitXMLBeanMeta(beanInfoId, v = new XMLMetaBeanFactory.Visitor() {
            private MetaBean meta;

            public MetaBean getMetaBean() {
                return meta;
            public void visit(XMLMetaBean xmlMeta, XMLMetaBeanInfos xmlInfos) throws Exception {
                if (meta == null) {
                    meta = createMetaBean(xmlMeta);
                }
                xmlFactory.enrichMetaBean(meta, new XMLMetaBeanFactory.XMLResult(xmlMeta, xmlInfos));

        });
        if (v.getMetaBean() == null) {
            throw new IllegalArgumentException("MetaBean "  beanInfoId  " not found");
        return v.getMetaBean();

    public Map<String, MetaBean> buildAll() throws Exception {
        final Map<String, MetaBean> all = super.buildAll();
        if (xmlFactory != null) {
            xmlFactory.visitXMLBeanMeta(null, new XMLMetaBeanFactory.Visitor() {
                public void visit(XMLMetaBean empty, XMLMetaBeanInfos xmlInfos) throws Exception {
                    if (xmlInfos.getBeans() == null)
                        return; // empty file, ignore
                    XMLMetaBeanFactory.XMLResult carrier = new XMLMetaBeanFactory.XMLResult(null, xmlInfos);

                    for (XMLMetaBean xmlMeta : xmlInfos.getBeans()) {
                        MetaBean meta = all.get(xmlMeta.getId());
                        if (meta == null) {
                            meta = createMetaBean(xmlMeta);
                            all.put(xmlMeta.getId(), meta);
                        }
                        carrier.xmlMeta = xmlMeta;
                        xmlFactory.enrichMetaBean(meta, carrier);
                    }
                }

                public MetaBean getMetaBean() {
                    return null; // do nothing
                }
            });
        return all;
    public Map<String, MetaBean> enrichCopies(Map<String, MetaBean> all, XMLMetaBeanInfos... infosArray)
        throws Exception {
        assertXmlFactory();
        final Map<String, MetaBean> copies = new HashMap<String, MetaBean>(all.size());
        boolean nothing = true;
        XMLMetaBeanFactory.XMLResult carrier = new XMLMetaBeanFactory.XMLResult();
        for (XMLMetaBeanInfos xmlMetaBeanInfos : infosArray) {
            carrier.xmlInfos = xmlMetaBeanInfos;
            if (xmlMetaBeanInfos == null)
                continue;
            try {
                for (XMLMetaBean xmlMeta : xmlMetaBeanInfos.getBeans()) {
                    nothing = false;
                    MetaBean copy = copies.get(xmlMeta.getId());
                    if (copy == null) { // ist noch nicht kopiert
                        MetaBean meta = all.get(xmlMeta.getId());
                        if (meta == null) { // gibt es nicht
                            copy = createMetaBean(xmlMeta);
                        } else { // gibt es, jetzt kopieren
                            copy = meta.copy();
                        }
                        copies.put(xmlMeta.getId(), copy);
                    }
                    carrier.xmlMeta = xmlMeta;
                    xmlFactory.enrichMetaBean(copy, carrier);
                }
            } catch (IOException e) {
                xmlFactory.handleLoadException(xmlMetaBeanInfos, e);
            }
        }
        if (nothing)
            return all;
        for (Map.Entry<String, MetaBean> entry : all.entrySet()) {
            /*
             * alle unveraenderten werden AUCH KOPIERT (nur zwar nur, wegen
             * potentieller CrossReferenzen durch Relationships)
             */
            if (!copies.containsKey(entry.getKey())) {
                if (entry.getValue().hasRelationships()) {
                    copies.put(entry.getKey(), (MetaBean) entry.getValue().copy());
                } else { // no relationship: do not clone()
                    copies.put(entry.getKey(), entry.getValue());
                }
            }
        }
        return copies;
    private MetaBean createMetaBean(XMLMetaBean xmlMeta) throws Exception {
        return buildForClass(findLocalClass(xmlMeta.getImpl()));

    private void updateXmlFactory() {
        for (MetaBeanFactory each : getFactories()) {
            if (each instanceof XMLMetaBeanFactory) { // use the first one!
                xmlFactory = (XMLMetaBeanFactory) each;
                return;
            }
        }
        xmlFactory = null; // none
    }

    public XMLMetaBeanFactory getXmlFactory() {
        return xmlFactory;
    }

    private void assertXmlFactory() {
        if (xmlFactory == null) {
            throw new IllegalStateException("no xmlFactory available");
        }
    }
 * Description: internal implementation class to construct metabeans with
 * factories and from xstream xml files. You can register different
 * XMLMetaBeanLoaders (see addLoader()) to register xstream-xml-files that
 * contain meta-data. You can merge  unify meta data with method
 * enrichCopies(). <br/>
public class XMLMetaBeanManager extends MetaBeanManager implements MetaBeanFinder, XMLMetaBeanRegistry,
    MetaBeanEnricher {
    public XMLMetaBeanManager() {
        this(new XMLMetaBeanBuilder());
    public XMLMetaBeanManager(XMLMetaBeanBuilder builder) {
        super(builder);
    }

    public void addResourceLoader(String resource) {
        addLoader(new XMLMetaBeanURLLoader(PrivilegedActions.getClassLoader(getClass()).getResource(resource)));
    }

    public synchronized void addLoader(XMLMetaBeanLoader loader) {
        ((XMLMetaBeanBuilder) builder).addLoader(loader);
        cache.clear(); // clear because new loaders can affect ALL MetaBeans
                       // already created!
        complete = false;
    }

    /**
     * @param infos
     *            - the patches to apply
     * @return all MetaBeans for classes that have a xml descriptor and
     *         additional the MetaBeans loaded by the given loaders. The given
     *         loaders may also return patches for MetaBeans that have also been
     *         returned by other loaders. The beans with patches for references
     *         to patched beans will be copied.
     */
    public Map<String, MetaBean> enrichCopies(XMLMetaBeanInfos... infos) {
        Map<String, MetaBean> cached = findAll();
        try {
            Map<String, MetaBean> patched = ((XMLMetaBeanBuilder) builder).enrichCopies(cached, infos);
            for (Object entry : patched.values()) {
                MetaBean meta = (MetaBean) entry;
                computeRelationships(meta, patched);
            }
            return patched;
        } catch (RuntimeException e) {
            throw e; // do not wrap runtime exceptions
        } catch (Exception e) {
            throw new IllegalArgumentException("error enriching beanInfos", e);
    }

    /**
     * 
     * @return all MetaBeans for classes that have a xml descriptor: key =
     *         bean.id, value = MetaBean
     */
    public Map<String, MetaBean> findAll() {
        if (!complete) {
            try {
                Map<String, MetaBean> allBuilt = builder.buildAll();
                for (MetaBean meta : allBuilt.values()) {
                    MetaBean cached = cache.findForId(meta.getId());
                    if (cached == null) {
                        cache.cache(meta);
                    }
                }
                Map<String, MetaBean> map = cache.findAll();
                for (Object oentry : map.values()) {
                    MetaBean meta = (MetaBean) oentry;
                    computeRelationships(meta, map);
                }
                complete = true;
                return map;
            } catch (RuntimeException e) {
                throw e; // do not wrap runtime exceptions
            } catch (Exception e) {
                throw new IllegalArgumentException("error creating beanInfos", e);
            }
        } else {
            return cache.findAll();
    protected void computeRelationships(MetaBean beanInfo, Map<String, MetaBean> cached) {
        for (MetaProperty prop : beanInfo.getProperties()) {
            String beanRef = (String) prop.getFeature(REF_BEAN_ID);
            if (beanRef != null) {
                prop.setMetaBean(cached.get(beanRef));
            }
        }
    protected void computeRelatedMetaBean(MetaProperty prop, String beanRef) {
        if (beanRef != null) {
            prop.setMetaBean(findForId(beanRef));
        } else {
            super.computeRelatedMetaBean(prop, beanRef);
        }
        if (Boolean.parseBoolean(factory.getProperties().get(
        List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>(2);
import org.apache.bval.jsr303.ApacheValidationProvider;
    private final ValidatorFactory validatorFactory;
        this.validatorFactory = new ApacheValidationProvider().buildValidatorFactory(configurationState);
import javax.validation.ValidatorFactory;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.commons.lang.ClassUtils;

 * Description: Implementation of {@link ValidationProvider} for jsr303
 * implementation of the apache-validation framework.
public class ApacheValidationProvider implements ValidationProvider<ApacheValidatorConfiguration> {

    private static final Class<?>[] VALIDATOR_FACTORY_CONSTRUCTOR_ARGS = new Class[] { ConfigurationState.class };

     * Learn whether a particular builder class is suitable for this
     * {@link ValidationProvider}.
     * 
     * 
     *             if the ValidatorFactory cannot be built
    public ValidatorFactory buildValidatorFactory(ConfigurationState configuration) {
            String validatorFactoryClassname =
                configuration.getProperties().get(ApacheValidatorConfiguration.Properties.VALIDATOR_FACTORY_CLASSNAME);
            @SuppressWarnings("unchecked")
            final Class<? extends ValidatorFactory> validatorFactoryClass =
                validatorFactoryClassname == null ? ApacheValidatorFactory.class
                    : (Class<? extends ValidatorFactory>) ClassUtils.getClass(validatorFactoryClassname);
            return SecureActions.newInstance(validatorFactoryClass, VALIDATOR_FACTORY_CONSTRUCTOR_ARGS,
                new Object[] { configuration });
        } catch (ValidationException ex) {
            throw ex;
        } catch (Exception ex) {
import javax.validation.ValidatorFactory;
import javax.validation.spi.ConfigurationState;
 * Description: Uniquely identify Apache Bean Validation in the Bean Validation bootstrap
 * strategy. Also contains Apache Bean Validation specific configurations<br/>
     * Proprietary property keys for {@link ConfigurationImpl}  

        /**
         * Specifies the classname of the {@link ValidatorFactory} to use: this
         * class is presumed have a constructor that accepts a single
         * {@link ConfigurationState} argument.
         */
         String VALIDATOR_FACTORY_CLASSNAME = "apache.bval.validator-factory-classname";
    public ApacheValidatorFactory(ConfigurationState configurationState) {
        configure(configurationState);
    protected void configure(ConfigurationState configuration) {
        this.metaBeanFinder = buildMetaBeanFinder();
     * @deprecated does anyone need this?  If the default {@link ApacheFactoryContext}
     * uses a {@link Jsr303MetaBeanFactory}, which circularly refers to its owning {@link ApacheFactoryContext},
     * it follows that this constructor can't be conveniently used with a {@link Jsr303MetaBeanFactory}.
    protected MetaBeanFinder buildMetaBeanFinder() {
            Class<? extends ConstraintValidator<? extends Annotation, ?>>[] validatorClasses =
                    (Class<? extends ConstraintValidator<Annotation, ?>>[]) validatorClasses,
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*

import java.util.Collections;
     * The {@link ApacheFactoryContext} (not) used by this
     * {@link BeanDescriptorImpl}
     * 
    protected BeanDescriptorImpl(ApacheFactoryContext factoryContext, MetaBean metaBean) {
        super(metaBean, metaBean.getBeanClass(), metaBean.getValidations());
     * <ul>
     * <li>a constraint is hosted on the bean itself</li>
     * <li>a constraint is hosted on one of the bean properties, OR</li>
     * <li>a bean property is marked for cascade (<code>@Valid</code>)</li>
     * </ul>
     * 
     * @return true if the bean involves validation
        if (hasAnyConstraints())
            return true;
            if (mprop.getMetaBean() != null || mprop.getFeature(Features.Property.REF_CASCADE) != null)
                return true;
        if (hasConstraints())
            return true;
            if (getConstraintDescriptors(mprop.getValidations()).size() > 0)
                return true;
<<<<<<< .working
=======
     * Return the property level constraints for a given propertyName or null if
     * either the property does not exist or has no constraint The returned
     * object (and associated objects including ConstraintDescriptors) are
     * immutable.
     * 
     * @param propertyName
     *            property evaluated
>>>>>>> .merge-right.r997084
        if (prop == null)
            return null;
        if (prop.getValidations().length == 0 && prop.getFeature(Features.Property.REF_CASCADE) == null) {
        PropertyDescriptorImpl edesc = prop.getFeature(Jsr303Features.Property.PropertyDescriptor);
            edesc = new PropertyDescriptorImpl(prop);
     * 
            if (prop.getValidations().length > 0
                || (prop.getMetaBean() != null || prop.getFeature(Features.Property.REF_CASCADE) != null)) {
        return Collections.unmodifiableSet(validatedProperties);
        return new BeanDescriptorImpl(factoryContext, metaBean);
import java.util.Collections;
     * 
            new HashSet<ConstraintValidation<?>>(constraintDescriptors.size());
            if (group.isDefault()) {
                for (Group defaultGroupMember : expandedDefaultGroup) {
            } else {
            for (Iterator<ConstraintValidation<?>> it = constraintDescriptors.iterator(); it.hasNext();) {
                if (cv.getOwner() != metaBean.getBeanClass()) {
            new HashSet<ConstraintValidation<?>>(constraintDescriptors.size());
        if (findInScopes.size() == Scope.values().length)
            return true; // all scopes
                case LOCAL_ELEMENT:
                    if (owner.equals(metaBean.getBeanClass()))
                        return true;
                    break;
                case HIERARCHY:
                    if (!owner.equals(metaBean.getBeanClass()))
                        return true;
                    break;
    private ElementDescriptor.ConstraintFinder thisWith(Set<ConstraintValidation<?>> matchingDescriptors) {
        return constraintDescriptors.isEmpty() ? Collections.<ConstraintDescriptor<?>> emptySet() : Collections
            .<ConstraintDescriptor<?>> unmodifiableSet(constraintDescriptors);
import java.util.Collections;
    /**
     * Get a set of {@link ConstraintDescriptor}s from the specified array of
     * {@link Validation}s.
     * 
     * @param validations
     * @return {@link ConstraintDescriptor} set
     */
    protected static Set<ConstraintDescriptor<?>> getConstraintDescriptors(Validation[] validations) {
        final Set<ConstraintDescriptor<?>> result = new HashSet<ConstraintDescriptor<?>>(validations.length);
        for (Validation validation : validations) {
            if (validation instanceof ConstraintValidation<?>) {
                result.add((ConstraintValidation<?>) validation);
            }
        }
        return result;
    /** the MetaBean of this element */
    protected final MetaBean metaBean;

    /** the raw type of this element */
    protected final Class<?> elementClass;

    private Set<ConstraintDescriptor<?>> constraintDescriptors;

    /**
     * Create a new ElementDescriptorImpl instance.
     * 
     * @param metaBean
     * @param elementClass
     * @param validations
     */
    protected ElementDescriptorImpl(MetaBean metaBean, Class<?> elementClass, Validation[] validations) {
        this.metaBean = metaBean;
        setConstraintDescriptors(getConstraintDescriptors(validations));
    }

    /**
     * Create a new ElementDescriptorImpl instance.
     * 
     * @param elementClass
     * @param validations
     */
    protected ElementDescriptorImpl(Class<?> elementClass, Validation[] validations) {
        this(null, elementClass, validations);
     * 
     * @return Statically defined returned type.
        return new ConstraintFinderImpl(metaBean, new HashSet((Set) constraintDescriptors));
        return constraintDescriptors.isEmpty() ? Collections.<ConstraintDescriptor<?>> emptySet() : Collections
            .unmodifiableSet(constraintDescriptors);
    }

    /**
     * Get the mutable {@link ConstraintDescriptor} {@link Set}.
     * 
     * @return Set of {@link ConstraintDescriptor}
     */
    protected Set<ConstraintDescriptor<?>> getMutableConstraintDescriptors() {
     * {@inheritDoc} return true if at least one constraint declaration is
     * present on the element.
        return !getConstraintDescriptors().isEmpty();
     * 
     * @param constraintDescriptors
     *            to set
     * 
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
     * 
     * @param property
    PropertyDescriptorImpl(MetaProperty property) {
        super(property.getParentMetaBean(), property.getTypeClass(), property.getValidations());
        setCascaded(property.getMetaBean() != null || property.getFeature(Features.Property.REF_CASCADE) != null);
        setPropertyPath(property.getName());
     * 
     * 
        return "PropertyDescriptorImpl{"  "returnType="  elementClass  ", propertyPath='"  propertyPath  '\''
             '}';
class MethodBeanDescriptorImpl extends BeanDescriptorImpl implements MethodBeanDescriptor {
     * 
    protected MethodBeanDescriptorImpl(ApacheFactoryContext factoryContext, MetaBean metaBean) {
        super(factoryContext, metaBean);
     * 
     * 
    public void setConstructorConstraints(Map<Constructor<?>, ConstructorDescriptor> constructorConstraints) {
     * 
     * Add a {@link ConstructorDescriptor} to this
     * {@link MethodBeanDescriptorImpl}.
     * 
     * 
     * 
     * @return {@link Map} of {@link Constructor} :
     *         {@link ConstructorDescriptor}
import java.util.Collection;
import org.apache.bval.jsr303.ConstraintValidation;
public class MethodDescriptorImpl extends ElementDescriptorImpl implements MethodDescriptor, ProcedureDescriptor {
     * 
     * 
    public List<ParameterDescriptor> getParameterDescriptors() {
        // index aligned
    /**
     * Add the specified validations to this {@link MethodDescriptorImpl}.
     * @param validations
     */
    void addValidations(Collection<ConstraintValidation<?>> validations) {
        getMutableConstraintDescriptors().addAll(validations);
    }
        MethodBeanDescriptorImpl descriptor = new MethodBeanDescriptorImpl(factoryContext, metaBean);
                methodDesc.addValidations(validations.getValidations());
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private static final Logger log = LoggerFactory.getLogger(MetaBeanBuilder.class);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private static final Logger log = LoggerFactory.getLogger(AnnotationConstraintBuilder.class);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private static final Logger log = LoggerFactory.getLogger(ConfigurationImpl.class);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private static final Logger log = LoggerFactory.getLogger(ConstraintDefaults.class);
            log.warn("cannot find {}", resource);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private static final Logger log = LoggerFactory.getLogger(DefaultMessageInterpolator.class);
        if (rb != null) {
            log.debug("{} found", USER_VALIDATION_MESSAGES);
        } else {
            log.debug("{} not found. Delegating to {}", USER_VALIDATION_MESSAGES, DEFAULT_VALIDATION_MESSAGES);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    protected static final Logger log = LoggerFactory.getLogger(Jsr303MetaBeanFactory.class);
        log.debug("Default group sequence for bean {} is: {}", beanClass.getName(), groupSeq);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private static final Logger log = LoggerFactory.getLogger(DefaultTraversableResolver.class);
            log.debug("Found {} on classpath.", PERSISTENCE_UTIL_CLASSNAME);
            log.debug("Cannot find {} on classpath. All properties will per default be traversable.", PERSISTENCE_UTIL_CLASSNAME);
            log.debug("Instantiated an instance of {}.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private static final Logger log = LoggerFactory.getLogger(AnnotationIgnores.class);
        log.debug("{} level annotations are getting ignored for {}.{}", new Object[]{type, clazz.getName(), member.getName()});
        if (ignoreAnnotation) {
            log.debug("Class level annotation are getting ignored for {}", clazz.getName());
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private static final Logger log = LoggerFactory.getLogger(ValidationParser.class);
                log.debug("No {} found. Using annotation based configuration only.", validationXmlFile);
            log.debug("{} found.", validationXmlFile);
            log.info("Using {} as validation provider.", providerClassName);
                log.info("Using {} as message interpolator.", messageInterpolatorClass);
                log.info("Using {} as traversable resolver.", traversableResolverClass);
                log.info("Using {} as constraint factory.", constraintFactoryClass);
            log.debug("Trying to open input stream for {}", mappingFileName);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private static final Logger log = LoggerFactory.getLogger(XMLMetaBeanFactory.class);
     * Set the validations for this {@link FeaturesCapable}.
     * 
     * @param validations
     */
    public void setValidations(Validation[] validations) {
        this.validations = validations;
    }

    /**
import org.apache.commons.lang.ObjectUtils;

public final class Group {
        if (o instanceof Group == false) return false;
        return ObjectUtils.equals(group, ((Group) o).group);
         * SECURITY, INFO: Boolean, Field accessible?
        return createMetaBeanManager(builders);
    @SuppressWarnings("deprecation")
        // as long as we support both: jsr303 (in the builders list) and xstream-xml metabeans:
        if (Boolean.parseBoolean(factory.getProperties().get(
            ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML))) {
            return XMLMetaBeanManagerCreator.createXMLMetaBeanManager(builders);
        }
         * true/false. use Apache metaBeans xml format additionally to
        String TREAT_MAPS_LIKE_BEANS = "apache.bval.treat-maps-like-beans";
import org.apache.bval.model.*;
    void setParentMetaBean(MetaBean parentMetaBean) {
                                if (Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD.equals(method.getName())) {
                                } else if (Jsr303MetaBeanFactory.ANNOTATION_GROUPS.equals(method.getName())) {
        apb.putValue(Jsr303MetaBeanFactory.ANNOTATION_GROUPS, inheritedGroups.toArray(new Class[inheritedGroups.size()]));
        apb.putValue(Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD, inheritedPayload.toArray(new Class[inheritedPayload.size()]));
        this.attributes.put(Jsr303MetaBeanFactory.ANNOTATION_GROUPS, groups.toArray(new Class[groups.size()]));
        this.attributes.put(Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD, payload.toArray(new Class[payload.size()]));
        return (String) attributes.get(Jsr303MetaBeanFactory.ANNOTATION_MESSAGE);
    // the validation process is single-threaded and it's unlikely to change in the near future (otherwise use AtomicInteger).
    private int compositeDepth = 0;
        if (compositeDepth > 0) {
        return compositeDepth == 0 ? !constraintViolations.isEmpty() : hasCompositeError;
        return compositeDepth == 1;
        return --compositeDepth == 0;
    public static final String ANNOTATION_PAYLOAD = "payload";
    public static final String ANNOTATION_GROUPS = "groups";
    public static final String ANNOTATION_MESSAGE = "message";

import org.apache.bval.jsr303.Jsr303MetaBeanFactory;

        Method groupsMethod = SecureActions.getMethod(annotation.annotationType(), Jsr303MetaBeanFactory.ANNOTATION_GROUPS);
        Method payloadMethod = SecureActions.getMethod(annotation.annotationType(), Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD);
        Method messageMethod = SecureActions.getMethod(annotation.annotationType(), Jsr303MetaBeanFactory.ANNOTATION_MESSAGE);
import org.apache.bval.jsr303.Jsr303MetaBeanFactory;
        putValue(Jsr303MetaBeanFactory.ANNOTATION_MESSAGE, message);
        putValue(Jsr303MetaBeanFactory.ANNOTATION_GROUPS, groups);
        putValue(Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD, payload);
import org.apache.bval.jsr303.ApacheValidatorFactory;
import org.apache.bval.jsr303.Jsr303MetaBeanFactory;
import org.apache.bval.jsr303.util.EnumerationConverter;
import org.apache.bval.jsr303.util.IOUtils;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;
import org.apache.commons.beanutils.ConvertUtils;
import org.apache.commons.beanutils.Converter;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.util.*;
    private static final String[] RESERVED_PARAMS = {
            Jsr303MetaBeanFactory.ANNOTATION_MESSAGE,
            Jsr303MetaBeanFactory.ANNOTATION_GROUPS,
            Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD };
import java.beans.IndexedPropertyDescriptor;
            if (!(pd instanceof IndexedPropertyDescriptor || pd.getName().equals("class"))) {
            String objectId = "";
            try {
                if (object != null) {
                    objectId = object.toString();
                } else {
                    objectId = "<null>";
                }
            } catch (Exception e) {
                objectId = "<unknown>";
            } finally {
                return new ValidationException("error during validation of "
                     objectId, ex);
            }
        // is immutable and uniquely built per Validation definition, the comparison has to be based on == and not equals though
     * Runs the message interpolation according to algorithm specified in JSR 303.
     * Lookups in user bundles are recursive whereas lookups in default bundle are not!
        fixed = false;
import org.apache.bval.jsr303.util.SecureActions;
        final ClassLoader classLoader = SecureActions.getContextClassLoader(Thread.currentThread());
            rb = loadBundle(SecureActions.getClassLoader(this.getClass()), locale,
        final Field[] fields = SecureActions.getDeclaredFields(beanClass);
        final Method[] methods = SecureActions.getDeclaredMethods(beanClass);
    /**
     * Get all fields declared on a given class.
     * @param clazz
     * @return Field found
     */
    public static Field[] getDeclaredFields(final Class<?> clazz) {
        return run(new PrivilegedAction<Field[]>() {
            public Field[] run() {
                Field[] fs = clazz.getDeclaredFields();
                for( Field f : fs ) {
                    setAccessibility(f);
                }
                return fs;
            }
        });
    }

     * Get class loader of <code>clazz</code>.
     * @param clazz
     * @return {@link ClassLoader}
     */
    public static ClassLoader getClassLoader(final Class<?> clazz) {
        return run(new PrivilegedAction<ClassLoader>() {
            public ClassLoader run() {
                return clazz.getClassLoader();
            }
        });
    }

    /**
     * Get context class loader of <code>thread</code>.
     * @param thread
     * @return {@link ClassLoader}
     */
    public static ClassLoader getContextClassLoader(final Thread thread) {
        return run(new PrivilegedAction<ClassLoader>() {
            public ClassLoader run() {
                return thread.getContextClassLoader();
            }
        });
    }

    /**
    public FieldAccess(final Field field) {
            PrivilegedActions.run( new PrivilegedAction<Object>() {
                public Object run() {
                    field.setAccessible(true);
                    return (Object) null;
                }
            });
    public MethodAccess(String propertyName, final Method method) {
            PrivilegedActions.run( new PrivilegedAction<Object>() {
                public Object run() {
                    method.setAccessible(true);
                    return (Object) null;
                }
            });
import java.lang.annotation.ElementType;

import org.apache.bval.jsr303.util.ClassHelper;
import org.apache.bval.jsr303.util.SecureActions;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
            ClassHelper.getClass(PERSISTENCE_UTIL_CLASSNAME);
                  (Class<? extends TraversableResolver>) ClassHelper
import org.apache.commons.lang.ClassUtils;

    /**
     * Perform ClassUtils.getClass functions with Java 2 Security enabled.
     */
    public static Class<?> getClass(String className) throws ClassNotFoundException {
        return getClass(className, true);
    }

    public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {
        ClassLoader ctxtCldr = SecureActions.getContextClassLoader(Thread.currentThread());
        ClassLoader loader = (ctxtCldr != null) ? ctxtCldr : SecureActions.getClassLoader(ClassHelper.class);
        return ClassUtils.getClass(loader, className, initialize);
    }
     * Get class loader of <code>class</code>.
     * @param clazz
     * @return {@link ClassLoader}
     */
    public static ClassLoader getContextClassLoader(final Class<?> clazz) {
        return run(new PrivilegedAction<ClassLoader>() {
            public ClassLoader run() {
                return clazz.getClassLoader();
            }
        });
    }

    /**
        ClassLoader classLoader = SecureActions.getClassLoader(getType());
            boolean failed = listener.hasViolations();
                for (Iterator<ConstraintValidation<?>> composed = getComposingValidations().iterator(); !failed && composed.hasNext();) {
                addErrors(context, jsrContext); // add defaultErrorMessage only
//        INFO: cached sorted Array with ValidationEntries 
//        String VALIDATION_SEQUENCE = "ValidationSequence";
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Target({METHOD, FIELD, CONSTRUCTOR, PARAMETER})
@Retention(RUNTIME)
    /**
     * (optional) the MetaBean.id to use
     */

    /**
     * to Support groups on @Valid(ate) in method/return validation
     */
    Class<?>[] groups() default {};
import javax.validation.ConstraintViolation;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.groups.Default;
import javax.validation.metadata.BeanDescriptor;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

            // TODO implement Validation.groups support on related bean
//            Class[] groups = prop.getFeature(Jsr303Features.Property.REF_GROUPS);
        /**
         * INFO: Class[] with the groups to validate a REF_CASCADE
         */
        String REF_GROUPS = "refGroups";
import org.apache.bval.Validate;
        } else if (annotation instanceof Validate) {
            return processValid(prop, access, ((Validate)annotation).groups());
    private boolean processValid(MetaProperty prop, AccessStrategy access, Class<?>... groups) {
            prop.putFeature(Jsr303Features.Property.REF_GROUPS, groups);
import org.apache.bval.Validate;
                    if (anno instanceof Valid || anno instanceof Validate) {
            if (anno instanceof Valid || anno instanceof Validate) {
        if (annotation instanceof Valid || annotation instanceof Validate) {
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import org.apache.bval.model.MetaBean;
    protected final ConcurrentMap<String, MetaBean> cacheById = new ConcurrentHashMap<String, MetaBean>();
    protected final ConcurrentMap<Class<?>, MetaBean> cacheByClass = new ConcurrentHashMap<Class<?>, MetaBean>();
        super();
        return cacheById.get(beanInfoId);
        return cacheByClass.get(clazz);
            cacheByClass.putIfAbsent(beanInfo.getBeanClass(), beanInfo);
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.commons.lang.ArrayUtils;
 * Description: abstract superclass of meta objects that support a map of
 * features.<br/>
    private static final long serialVersionUID = -4045110242904814218L;
    private ConcurrentMap<String, Object> features = createFeaturesMap();

    private volatile boolean locking;
    private ReentrantLock lock = new ReentrantLock(true);

        super();
     * 
     * Set whether to optimize read operations by accessing the features map in
     * an unsynchronized manner.
     * 
        lock.lock();
        try {
            this.locking = !fast;
        } finally {
            lock.unlock();
        }
     * 
        return getFeature(key, (T) null);
     * Get the specified feature, returning <code>defaultValue</code> if
     * undeclared.
     * 
        boolean release = acquireLockIfNeeded();
        try {
            return features.containsKey(key) ? (T) features.get(key) : defaultValue;
        } finally {
            if (release) {
                lock.unlock();
            }
     * 
        boolean release = acquireLockIfNeeded();
        try {
            features.put(key, value);
        } finally {
            if (release) {
                lock.unlock();
            }
        }
     * 
            @SuppressWarnings("unchecked")
            final T self = (T) clone();
     * Copy this {@link FeaturesCapable} into another {@link FeaturesCapable}
     * instance.
     * 
        target.features = target.createFeaturesMap();
        target.features.putAll(features);
     * 
     * 
     * @param validation
     *            to add
     * 
        if (validations == null)
            return false;
            if (validation.equals(aValidation))
                return true;

    /**
     * Create a features map for this {@link FeaturesCapable} object.
     * @return ConcurrentMap
     */
    protected ConcurrentMap<String, Object> createFeaturesMap() {
        return new ConcurrentHashMap<String, Object>();
    }

    private boolean acquireLockIfNeeded() {
        if (locking) {
            lock.lock();
            // double read
            if (locking) {
                return true;
            }
            lock.unlock();
        }
        return false;
    }

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.apache.bval.model.Validation;
import org.apache.commons.lang.ClassUtils;

        final HashMap<String, XMLMetaBean> map = new HashMap<String, XMLMetaBean>(beans.size());
            map.put(bean.getId(), bean);
        beanLookup = new ConcurrentHashMap<String, XMLMetaBean>(map);
        final HashMap<String, XMLMetaValidator> map = new HashMap<String, XMLMetaValidator>(validators.size());
                map.put(xv.getId(), xv);
        validationLookup = new ConcurrentHashMap<String, XMLMetaValidator>(map);
        if (beans == null) beans = new ArrayList<XMLMetaBean>();
        if (validators == null) validators = new ArrayList<XMLMetaValidator>();
 * This class is not synchronized.
        if (isRootPath() || nodeList.size() == 0) {
        try {
            return nodeList.remove(nodeList.size() - 1);
        } finally {
            if (nodeList.isEmpty()) {
                nodeList.add(new NodeImpl((String) null));
            }
        }
import javax.inject.Inject;
import javax.inject.Provider;
import javax.validation.spi.BootstrapState;
    @com.google.inject.Inject(optional = true)
    private BootstrapState bootstrapState;
    private ValidationProvider<?> validationProvider;

    @Inject
    private TraversableResolver traversableResolver;

    @Inject
    private MessageInterpolator messageInterpolator;

    @Inject
    private ConstraintValidatorFactory constraintValidatorFactory;

    public void setBootstrapState(BootstrapState bootstrapState) {
        this.bootstrapState = bootstrapState;
    public void setValidationProvider(ValidationProvider<?> validationProvider) {
        this.validationProvider = validationProvider;
    public void setTraversableResolver(TraversableResolver traversableResolver) {
        this.traversableResolver = traversableResolver;
    public void setMessageInterpolator(MessageInterpolator messageInterpolator) {
        this.messageInterpolator = messageInterpolator;
    }

    public void setConstraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory) {
        this.constraintValidatorFactory = constraintValidatorFactory;
        ConfigurationImpl configuration = new ConfigurationImpl(this.bootstrapState, this.validationProvider);
        configuration.traversableResolver(this.traversableResolver);
        configuration.messageInterpolator(this.messageInterpolator);
        configuration.constraintValidatorFactory(this.constraintValidatorFactory);
        return configuration;
import javax.inject.Inject;
import javax.inject.Singleton;
    private Injector injector;

    public void setInjector(Injector injector) {
import javax.inject.Inject;
        this.bind(ConfigurationState.class).toProvider(ConfigurationStateProvider.class).in(Scopes.SINGLETON);
        this.bind(ValidatorFactory.class).toProvider(ValidatorFactoryProvider.class).in(Scopes.SINGLETON);
import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
    private ConfigurationState configurationState;

    public void setConfigurationState(ConfigurationState configurationState) {
        this.configurationState = configurationState;
        return new ApacheValidationProvider().buildValidatorFactory(this.configurationState);
import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
    private ValidatorFactory validatorFactory;

    public void setValidatorFactory(ValidatorFactory validatorFactory) {
import javax.inject.Singleton;
    /**
     * A custom error message when throwing the custom exception.
     *
     * It supports java.util.Formatter place holders, intercepted method
     * arguments will be used as message format arguments.
     *
     * @return a custom error message when throwing the custom exception.
     * @see java.util.Formatter#format(String, Object...)
     */
    String exceptionMessage() default "";

    private static final Class<?>[] CAUSE_TYPES = new Class[]{ Throwable.class };

    private static final Class<?>[] MESSAGE_CAUSE_TYPES = new Class[]{ String.class, Throwable.class };

            throw getException(new ConstraintViolationException(
                    String.format("Validation error when calling method '%s' with arguments ",
                            method,
                            Arrays.deepToString(arguments)),
                    constraintViolations),
                    validate.rethrowExceptionsAs(),
                    validate.exceptionMessage(),
                    arguments);

                throw getException(new ConstraintViolationException(
                        String.format("Method '%s' returned a not valid value ",
                                method,
                                returnedValue),
                        constraintViolations),
                        validate.rethrowExceptionsAs(),
                        validate.exceptionMessage(),
                        arguments);
            Class<? extends Throwable> exceptionWrapperClass,
            String exceptionMessage,
            Object[] arguments) {
        String errorMessage;
        Object[] initargs;
        Class<?>[] initargsType;

        if (exceptionMessage.length() != 0) {
            errorMessage = String.format(exceptionMessage, arguments);
            initargs = new Object[]{ errorMessage, exception };
            initargsType = MESSAGE_CAUSE_TYPES;
        } else {
            initargs = new Object[]{ exception };
            initargsType = CAUSE_TYPES;
        }

        Constructor<? extends Throwable> exceptionConstructor = getMatchingConstructor(exceptionWrapperClass, initargsType);
        if (exceptionConstructor != null) {
            try {
                rethrowEx = exceptionConstructor.newInstance(initargs);
            } catch (Exception e) {
                errorMessage = String.format("Impossible to re-throw '%s', it needs the constructor with %s argument(s).",
                        exceptionWrapperClass.getName(),
                        Arrays.toString(initargsType));
                rethrowEx = new RuntimeException(errorMessage, e);
            }
        } else {
            errorMessage = String.format("Impossible to re-throw '%s', it needs the constructor with %s or %s argument(s).",
                    exceptionWrapperClass.getName(),
                    Arrays.toString(CAUSE_TYPES),
                    Arrays.toString(MESSAGE_CAUSE_TYPES));
            rethrowEx = new RuntimeException(errorMessage);
    @SuppressWarnings("unchecked")
    private static <E extends Throwable> Constructor<E> getMatchingConstructor(Class<E> type,
            Class<?>[] argumentsType) {
        Class<? super E> currentType = type;
        while (Object.class != currentType) {
            for (Constructor<?> constructor : currentType.getConstructors()) {
                if (Arrays.equals(argumentsType, constructor.getParameterTypes())) {
                    return (Constructor<E>) constructor;
                }
            }
            currentType = currentType.getSuperclass();
        }
        return null;
    }

        groups = { Insert.class },
        validateReturnedValue = true
        groups = { Update.class },
        rethrowExceptionsAs = DummyException.class,
        exceptionMessage = "This is just a dummy message %s"
    public DummyException(String message, Throwable cause) {
        super(message, cause);
    }

import javax.validation.ValidatorFactory;
     * The {@link ValidatorFactory} reference.
    private ValidatorFactory validatorFactory;
     * Sets the {@link ValidatorFactory} reference.
     * @param validatorFactory the {@link ValidatorFactory} reference
    public void setValidatorFactory(ValidatorFactory validatorFactory) {
        this.validatorFactory = validatorFactory;
        Validator validator = this.validatorFactory.getValidator();
import org.apache.bval.jsr303.ConfigurationImpl;
import org.apache.bval.jsr303.util.IOUtils;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.PrivilegedActions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
            "META-INF/validation-configuration-1.0.xsd";
    protected final String validationXmlFile;
     *
        if (file == null) {
     *
                    unmarshaller.unmarshal(stream, ValidationConfigType.class);
    protected InputStream getInputStream(String path) throws IOException {
        InputStream inputStream = loader.getResourceAsStream(path);

        if (inputStream != null) {
            Enumeration<URL> urls = loader.getResources(path);
            Set<String> uniqueUrls = new HashSet<String>(2);
            while (urls.hasMoreElements()) {
                uniqueUrls.add(urls.nextElement().toString());
                if (uniqueUrls.size() > 1){ // complain when first duplicate found
                    throw new ValidationException("More than one "  path  " is found in the classpath"
                             uniqueUrls);

     *
                        property.getValue()  "' in "  validationXmlFile);
                    (Class<? extends ValidationProvider<?>>) SecureActions
                            .loadClass(providerClassName, this.getClass());
        if (target.getMessageInterpolator() == null) {
                        .loadClass(messageInterpolatorClass, this.getClass());
        if (target.getTraversableResolver() == null) {
                        .loadClass(traversableResolverClass, this.getClass());
        if (target.getConstraintValidatorFactory() == null) {
                        (Class<ConstraintValidatorFactory>) SecureActions
                                .loadClass(constraintFactoryClass, this.getClass());
            if (mappingFileName.startsWith("/")) {
                            "Unable to open input stream for mapping file " 
                                    mappingFileName);
                        mappingFileName, e);
            if (urls.hasMoreElements()) {
                String url = urls.nextElement().toString();
                while (urls.hasMoreElements()) {
                    if (!url.equals(urls.nextElement().toString())) { // complain when first duplicate found
                        throw new ValidationException("More than one "  path  " is found in the classpath");
                    }
    @Deprecated // unused method - will remove in future release
    @Deprecated // unused method - will remove in future release
        return doPrivileged(new PrivilegedAction<Object>() {
        return doPrivileged(new PrivilegedAction<ClassLoader>() {


    /**
     * Perform action with AccessController.doPrivileged() if possible.
     *
     * @param action - the action to run
     * @return result of running the action
     */
    private static <T> T doPrivileged(final PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.reflect.Method;
import org.apache.commons.lang.ClassUtils;

import java.security.AccessController;
import java.security.PrivilegedAction;
    @SuppressWarnings("unchecked")
    public ValidatorFactory buildValidatorFactory(final ConfigurationState configuration) {
        final Class<? extends ValidatorFactory> validatorFactoryClass;

            if (validatorFactoryClassname == null)
                validatorFactoryClass = ApacheValidatorFactory.class;
            else
            {
                validatorFactoryClass
                  = (Class<? extends ValidatorFactory>) ClassUtils.getClass(validatorFactoryClassname);
                validatorFactoryClass.asSubclass(ValidatorFactory.class);
            }

        // FIXME 2011-03-27 jw:
        // Should not use privileged action, but to avoid breaking things
        // doing it here like the former version of this class did.
        //
        // The privileged action should be applied by the ValidatorFactory
        // itself, if required.
        // No privileges should be required to access the constructor,
        // because the classloader of ApacheValidationProvider will always
        // be an ancestor of the loader of validatorFactoryClass.
        return (System.getSecurityManager() == null)
            ? instantiateValidatorFactory(validatorFactoryClass, configuration)
            : AccessController.doPrivileged(new PrivilegedAction<ValidatorFactory>() {
                  public ValidatorFactory run() {
                      return instantiateValidatorFactory(validatorFactoryClass, configuration);
                  }
              });



    private static ValidatorFactory instantiateValidatorFactory(
        final Class<? extends ValidatorFactory> validatorFactoryClass,
        final ConfigurationState                configuration
    ) {
      try
      {
          return validatorFactoryClass.getConstructor(ConfigurationState.class).newInstance(configuration);
      }
      catch (final Exception ex)
      {
          throw new ValidationException("Cannot instantiate : "  validatorFactoryClass, ex);
      }
    }

import javax.validation.*;
import javax.validation.bootstrap.ProviderSpecificBootstrap;
import javax.validation.spi.ConfigurationState;
import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.*;

            new ConstraintDefaults();
    /**
     * information from xml parsing
     */
     *
                    Validation.byProvider(ApacheValidationProvider.class);
                    (ApacheValidatorFactory) configuration.buildValidatorFactory();
     *
                new HashMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>>();
     *
                .getConstraintValidatorFactory());
     *
     *
     *
     *
     *
                : getDefaultMessageInterpolator());
     *
            TraversableResolver traversableResolver) {
     *
            ConstraintValidatorFactory constraintValidatorFactory) {
     *
     * @param type the class of the object to be returned.
     * @throws ValidationException if the provider does not support the call.
    public <T> T unwrap(final Class<T> type) {
        // FIXME 2011-03-27 jw:
        // This code is unsecure.
        // It should allow only a fixed set of classes.
        // Can't fix this because don't know which classes this method should support.

            //noinspection unchecked
            return (T) this;
                .getModifiers()))) {
            return newInstance(type);
                    //noinspection unchecked
                    return (T) newInstance(cls);
                // do nothing
    private <T> T newInstance(final Class<T> cls) {
        return AccessController.doPrivileged(new PrivilegedAction<T>() {
            public T run() {
                try {
                    return cls.newInstance();
                } catch (final Exception ex) {
                    throw new ValidationException("Cannot instantiate : "  cls, ex);
                }
            }
        });
    }

     *
     *
     *
     *
                                  MetaConstraint<?, ?> metaConstraint) {
                constraintMap.get(beanClass);
                    new ArrayList<MetaConstraint<?, ? extends Annotation>>();
     *
     * @param accessStrategy defining the property to validate
     *
     *
            Class<T> beanClass) {
                constraintMap.get(beanClass);
     *
            return Collections.<AccessStrategy>emptyList();
     *
import java.lang.reflect.Constructor;
import java.security.AccessController;
import java.security.PrivilegedAction;
 * <p/>
 * <p/>
 *
     *
     *
     *
     *
     * @param object object to validate
     * @param groups group or list of groups targeted for validation (default to
     *               {@link javax.validation.groups.Default})
     * @throws IllegalArgumentException if object is null or if null is passed to the varargs groups
     * @throws ValidationException      if a non recoverable error happens during the validation
     *                                  process
                                                    Class<?>... groups) {
                    factoryContext.getMetaBeanFinder().findForClass(objectClass);
                    createContext(objectMetaBean, object, objectClass, groups);
                    context.getListener();
     *
     * @param object       object to validate
     * @param propertyName property to validate (ie field and getter constraints). Nested
     *                     properties may be referenced (e.g. prop[2].subpropA.subpropB)
     * @param groups       group or list of groups targeted for validation (default to
     *                     {@link javax.validation.groups.Default})
     * @throws IllegalArgumentException if <code>object</code> is null, if <code>propertyName</code>
     *                                  null, empty or not a valid object property or if null is
     *                                  passed to the varargs groups
     * @throws ValidationException      if a non recoverable error happens during the validation
     *                                  process
                                                            String propertyName, Class<?>... groups) {
                    factoryContext.getMetaBeanFinder().findForClass(objectClass);
                    createContext(objectMetaBean, object, objectClass, groups);
                    getNestedProperty(objectMetaBean, object, propertyName);
                         object.getClass().getName()  "."  propertyName);
     *
     * @param beanType     the bean type
     * @param propertyName property to validate
     * @param value        property value to validate
     * @param groups       group or list of groups targeted for validation (default to
     *                     {@link javax.validation.groups.Default})
     * @throws IllegalArgumentException if <code>beanType</code> is null, if
     *                                  <code>propertyName</code> null, empty or not a valid object
     *                                  property or if null is passed to the varargs groups
     * @throws ValidationException      if a non recoverable error happens during the validation
     *                                  process
                                                         String propertyName, Object value, Class<?>... groups) {
                    factoryContext.getMetaBeanFinder().findForClass(beanType);
                    createContext(metaBean, null, beanType, groups);
                    propertyName).getMetaProperty());
     *
     * @param clazz class or interface type evaluated
     * @throws IllegalArgumentException if clazz is null
     * @throws ValidationException      if a non recoverable error happens during the metadata
     *                                  discovery or if some constraints are invalid.
                    factoryContext.getMetaBeanFinder().findForClass(clazz);
                    metaBean.getFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR);
                     clazz, ex);
     *
     * @param type the class of the object to be returned.
     * @throws ValidationException if the provider does not support the call.
        // FIXME 2011-03-27 jw:
        // This code is unsecure.
        // It should allow only a fixed set of classes.
        // Can't fix this because don't know which classes this method should support.

                .getModifiers()))) {
            return newInstance(type);
                            (Class<? extends T>) cls;
                    return newInstance(implClass);
    private <T> T newInstance(final Class<T> cls) {
        return AccessController.doPrivileged(new PrivilegedAction<T>() {
            public T run() {
                try {
                    Constructor<T> cons = cls.getConstructor(ApacheFactoryContext.class);
                    if (!cons.isAccessible()) {
                        cons.setAccessible(true);
                    }
                    return cons.newInstance(factoryContext);
                } catch (final Exception ex) {
                    throw new ValidationException("Cannot instantiate : "  cls, ex);
                }
            }
        });
    }

     * <p/>
     *
     * @param validationContext The current context of this validation call. Must have its
     *                          {@link GroupValidationContext#getCurrentGroup()} field set.
                    (ConstraintValidationListener<?>) context.getListener();
                        context.getMetaBean().getBeanClass());
                            context.getMetaBean().getFeature(
                                    "{GroupSequence:"  owner.getCanonicalName()  "}");
     *
     * @param context The current validation context.
     * @param prop    The property to cascade from (in case it is possible).
                                      MetaProperty prop) {
                prop.getFeature(Features.Property.REF_CASCADE);
                            new Jsr303ValidationCallback(context),
                            treatMapsLikeBeans);
     *
     * @param context The current validation context.
     * @param prop    The property of the related bean.
     * @param access  The access strategy used to get the related bean value.
                                 MetaProperty prop, AccessStrategy access) {
                    context.getBean(), node,
                    context.getRootMetaBean().getBeanClass(), beanPath,
                    access.getElementType()))
                    "Error in TraversableResolver.isReachable() for "
                             context.getBean(), e);
                    context.getBean(), node,
                    context.getRootMetaBean().getBeanClass(), beanPath,
                    access.getElementType()))
                    "Error TraversableResolver.isCascadable() for "
                             context.getBean(), e);
     *
                    context.getMetaBean().getFeature(
                            Jsr303Features.Bean.GROUP_SEQUENCE);
                        groupSeq);
     *
            RuntimeException ex, Object object) {
            // instances from subclasses)
                         objectId, ex);
                                                 String propertyName) {
     *
                                                          T object, Class<T> objectClass, Class<?>[] groups) {
                new ConstraintValidationListener<T>(object, objectClass);
                new GroupValidationContextImpl<T>(listener, this.factoryContext
                        .getMessageInterpolator(), this.factoryContext
                        .getTraversableResolver(), metaBean);
     *
     * <p/>
     * <p/>
     *
     * @param beanType Bean type to check.
     *
     * @param propertyName Property name to check.
                    "Property path cannot be null or empty.");
     *
     * @param groups The groups to check.
            ValidationHelper.ValidateCallback {
import javax.validation.*;
import java.util.*;
import javax.validation.metadata.ConstraintDescriptor;
import javax.validation.metadata.ElementDescriptor;
import javax.validation.metadata.ElementDescriptor.ConstraintFinder;
import javax.validation.metadata.Scope;
import java.util.*;
import javax.validation.ValidationException;

    public <T extends ConstraintValidator<?, ?>> T getInstance(final Class<T> constraintClass)
    {
      // 2011-03-27 jw: Do not use PrivilegedAction.
      // Otherwise any user code would be executed with the privileges of this class.
      try
      {
        return constraintClass.newInstance();
      }
      catch (final Exception ex)
      {
        throw new ValidationException("Cannot instantiate : "  constraintClass, ex);
      }
import java.security.AccessController;
import java.security.PrivilegedAction;
        final ClassLoader classLoader = doPrivileged(SecureActions.getContextClassLoader());

        // 2011-03-27 jw: No privileged action required.
        // A class can always access the classloader of itself and of subclasses.
            rb = loadBundle(
              getClass().getClassLoader(),
              locale,
              USER_VALIDATION_MESSAGES  " not found by validator classloader"
            );
        StringBuffer sb = new StringBuffer(64);
        StringBuffer sb = new StringBuffer(64);
        ResourceBundle bundle = defaultBundlesMap.get(locale);
        if (bundle == null)
        {
            bundle = ResourceBundle.getBundle(DEFAULT_VALIDATION_MESSAGES, locale);
            defaultBundlesMap.put(locale, bundle);
        ResourceBundle bundle = userBundlesMap.get(locale);
        if (bundle == null)
        {
            bundle = getFileBasedResourceBundle(locale);
            if (bundle != null) {
                userBundlesMap.put(locale, bundle);
            }


    /**
     * Perform action with AccessController.doPrivileged() if a security manager is installed.
     *
     * @param action
     *  the action to run
     * @return
     *  result of the action
     */
    private static <T> T doPrivileged(final PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }

import java.security.AccessController;
import java.security.PrivilegedAction;
            "META-INF/services/javax.validation.spi.ValidationProvider";
                                ValidationProvider<?> vp =
                                        AccessController.doPrivileged(new PrivilegedAction<ValidationProvider<?>>() {
                                            public ValidationProvider<?> run() {
                                                try {
                                                    return (ValidationProvider<?>) provider.newInstance();
                                                } catch (final Exception ex) {
                                                    throw new ValidationException("Cannot instantiate : "  provider, ex);
                                                }
                                            }
                                        });
                                 providers.add(vp);

                                        line  " configured in file "  url, e);
import javax.validation.metadata.ConstraintDescriptor;
import javax.validation.metadata.ElementDescriptor;
import java.security.AccessController;
import java.security.PrivilegedAction;
        final Field[] fields = doPrivileged(SecureActions.getDeclaredFields(beanClass));
        final Method[] methods = doPrivileged(SecureActions.getDeclaredMethods(beanClass));



    /**
     * Perform action with AccessController.doPrivileged() if a security manager is installed.
     *
     * @param action
     *  the action to run
     * @return
     *  result of the action
     */
    private static <T> T doPrivileged(final PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }
import javax.validation.metadata.PropertyDescriptor;

import java.util.ArrayList;
import java.util.List;

import org.apache.bval.jsr303.ApacheFactoryContext;
import org.apache.bval.jsr303.BeanDescriptorImpl;
import org.apache.bval.model.MetaBean;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import java.util.List;

import javax.validation.groups.Default;

import org.apache.bval.jsr303.util.ClassHelper;
import org.apache.commons.lang.ClassUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.lang.annotation.ElementType;
import java.security.AccessController;
import java.security.PrivilegedAction;
        final ClassLoader classLoader = getClassLoader();
            ClassUtils.getClass(classLoader, PERSISTENCE_UTIL_CLASSNAME, true);
              (Class<? extends TraversableResolver>)
                ClassUtils.getClass(classLoader, JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME, true);
            jpaTR = jpaAwareResolverClass.newInstance();


    
    private static ClassLoader getClassLoader()
    {
      return (System.getSecurityManager() == null)
        ? getClassLoader0()
        : AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
              public ClassLoader run() {
                return getClassLoader0();
              }
          });
    }

    private static ClassLoader getClassLoader0()
    {
      final ClassLoader loader = Thread.currentThread().getContextClassLoader();
      return (loader != null) ? loader : ClassHelper.class.getClassLoader();
    }


import java.security.AccessController;
import java.util.List;

        fillFullClassHierarchyAsList(allClasses, clazz.getSuperclass());
        for (Class<?> subClass : clazz.getInterfaces()) {
     * @deprecated Will be removed for security reasons.
     *
    @Deprecated
    /**
     * @deprecated Will be removed for security reasons.
     *
     * Perform ClassUtils.getClass functions with Java 2 Security enabled.
     */
    @Deprecated
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        if (loader == null)
          loader = ClassHelper.class.getClassLoader();
    private static void validGroups(final Annotation annotation) {
        final Method groupsMethod = SecureActions.doPrivileged(
            SecureActions.getPublicMethod(annotation.annotationType(), Jsr303MetaBeanFactory.ANNOTATION_GROUPS)
        );
        if (groupsMethod == null) {
        final Object defaultGroupsValue = groupsMethod.getDefaultValue();
        if (defaultGroupsValue instanceof Class<?>[]) {
            if (((Class[]) defaultGroupsValue).length != 0) {
    private static void validPayload(final Annotation annotation) {
        final Method payloadMethod = SecureActions.doPrivileged(
            SecureActions.getPublicMethod(annotation.annotationType(), Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD)
        );
        if (payloadMethod == null) {
        final Object defaultPayloadValue = payloadMethod.getDefaultValue();
        if (defaultPayloadValue instanceof Class<?>[]) {
            if (((Class[]) defaultPayloadValue).length != 0) {
    private static void validMessage(final Annotation annotation) {
        final Method messageMethod = SecureActions.doPrivileged(
            SecureActions.getPublicMethod(annotation.annotationType(), Jsr303MetaBeanFactory.ANNOTATION_MESSAGE)
        );
        if (messageMethod == null) {
        final Object defaultMessageValue = messageMethod.getDefaultValue();
        if (!(defaultMessageValue instanceof String)) {
    private static void validAttributes(final Annotation annotation) {
        final Method[] methods = SecureActions.doPrivileged(
            SecureActions.getDeclaredMethods(annotation.annotationType())
        );
        for (Method method : methods ){
import javax.validation.ConstraintValidatorContext;

import javax.validation.ConstraintValidatorContext;

import org.apache.bval.jsr303.ConstraintValidatorContextImpl;

import java.lang.reflect.AccessibleObject;
import java.security.AccessController;
     * Create a privileged action to get the context classloader of the current thread.
     * @see Thread#getContextClassLoader()
    public static PrivilegedAction<ClassLoader> getContextClassLoader()
    {
        return SecureActions.GetContextClassLoader.instance;
     * Create a privileged action to get the named field declared by the specified class.
     * The result of the action will be {@code null} if there is no such field.
    public static PrivilegedAction<Field> getDeclaredField(final Class<?> clazz, final String fieldName) {
        return new PrivilegedAction<Field>() {
                    final Field f = clazz.getDeclaredField(fieldName);
                } catch (final NoSuchFieldException ex) {
        };
    }



    /**
     * Create a privileged action to get all fields declared by the specified class.
     */
    public static PrivilegedAction<Field[]> getDeclaredFields(final Class<?> clazz) {
        return new PrivilegedAction<Field[]>() {
            public Field[] run() {
                final Field[] fields = clazz.getDeclaredFields();
                if (fields.length > 0)
                    AccessibleObject.setAccessible(fields, true);
                return fields;
            }
        };
    }



    /**
     * Create a privileged action to get all methods declared by the specified class.
     */
    public static PrivilegedAction<Method[]> getDeclaredMethods(final Class<?> clazz) {
      // XXX 2011-03-27 jw: Inconsistent behaviour.
      // doGetDeclaredFields() is setting fields accessible, but here we don't.
      return new PrivilegedAction<Method[]>() {
          public Method[] run() {
            return clazz.getDeclaredMethods();
        }
      };
     * Create a privileged action to get the named method declared by the specified class
     * or by one of its ancestors.
     * The result of the action will be {@code null} if there is no such method.
    public static PrivilegedAction<Method> getPublicMethod(final Class<?> clazz, final String methodName) {
      return new PrivilegedAction<Method>() {
          public Method run() {
              try {
                  return clazz.getMethod(methodName, (Class[]) null);
              } catch (final NoSuchMethodException ex) {
                  return null;
              }
          }
      };
      // FIXME 2011-03-27 jw:
      // - Why not simply call field.setAccessible(true)?
      // - Fields can not be abstract.
    static <T> T doPrivileged(final PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    private static final class GetContextClassLoader extends Object implements PrivilegedAction<ClassLoader> {
      static final GetContextClassLoader instance = new GetContextClassLoader();
      private GetContextClassLoader()
      {
        super();
      }
      public final ClassLoader run() {
          return Thread.currentThread().getContextClassLoader();
      }
import java.security.AccessController;
import java.security.PrivilegedAction;
        final Method[] declaredMethods = doPrivileged(
          SecureActions.getDeclaredMethods(annotationType)
        );



    private static <T> T doPrivileged(final PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }
import org.apache.bval.util.PrivilegedActions;
import java.lang.reflect.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
     *
     *
     * @param annot Annotation to be replicated.
        final Method[] methods = doPrivileged(SecureActions.getDeclaredMethods(annot.annotationType()));
        for (Method m : methods) {
            if (!m.isAccessible()) {
     *
     *
     *
     *
     *
     *
     *
     *
     *
        final Class<A> proxyClass = (Class<A>) Proxy.getProxyClass(classLoader, getType());
        final InvocationHandler handler = new AnnotationProxy(this);
        return PrivilegedActions.run(new PrivilegedAction<A>() {
            public A run() {
                try {
                    Constructor<A> constructor = proxyClass.getConstructor(InvocationHandler.class);
                    return constructor.newInstance(handler);
                } catch (Exception e) {
                    throw new ValidationException("Unable to create annotation for configured constraint", e);
                }
            }
        });
    }

    private static <T> T doPrivileged(final PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
import javax.validation.ValidationException;
import org.apache.commons.lang.StringUtils;
import java.security.AccessController;
import java.security.PrivilegedAction;
          final Class<A> annotationClass, final String name) {
        final Method m = doPrivileged(SecureActions.getPublicMethod(annotationClass, name));
            final Field field = doPrivileged(SecureActions.getDeclaredField(beanClass, fieldName));
            final Method method = getGetter(beanClass, getterName);
                validatorClass = (Class<? extends ConstraintValidator<?, ?>>)
                      loadClass(validatorClassName.getValue());
        return loadClass(toQualifiedClassName(className, defaultPackage));


    private static <T> T doPrivileged(final PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }



    private static Method getGetter(final Class<?> clazz, final String propertyName) {
        return doPrivileged(new PrivilegedAction<Method>() {
            public Method run() {
                try {
                    final String p = StringUtils.capitalize(propertyName);
                    try {
                        return clazz.getMethod("get"  p);
                    } catch (NoSuchMethodException e) {
                        return clazz.getMethod("is"  p);
                    }
                } catch (NoSuchMethodException e) {
                    return null;
                }
            }
        });

    }



    private Class<?> loadClass(final String className) {
        ClassLoader loader = doPrivileged(SecureActions.getContextClassLoader());
        if (loader == null)
            loader = getClass().getClassLoader();

        try {
            return Class.forName(className, true, loader);
        } catch (ClassNotFoundException ex) {
            throw new ValidationException("Unable to load class: "  className, ex);
        }
    }

import java.security.AccessController;
import java.security.PrivilegedAction;
                    (Class<? extends ValidationProvider<?>>) loadClass(providerClassName);
                Class<MessageInterpolator> clazz = (Class<MessageInterpolator>)
                        loadClass(messageInterpolatorClass);
                target.messageInterpolator(newInstance(clazz));
                Class<TraversableResolver> clazz = (Class<TraversableResolver>)
                        loadClass(traversableResolverClass);
                target.traversableResolver(newInstance(clazz));
    private <T> T newInstance(final Class<T> cls) {
        return AccessController.doPrivileged(new PrivilegedAction<T>() {
            public T run() {
                try {
                    return cls.newInstance();
                } catch (final Exception ex) {
                    throw new ValidationException("Cannot instantiate : "  cls, ex);
                }
            }
        });
    }

                Class<ConstraintValidatorFactory> clazz = (Class<ConstraintValidatorFactory>)
                        loadClass(constraintFactoryClass);
                target.constraintValidatorFactory(newInstance(clazz));


    private static <T> T doPrivileged(final PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }

    private Class<?> loadClass(final String className) {
        ClassLoader loader = doPrivileged(SecureActions.getContextClassLoader());
        if (loader == null)
            loader = getClass().getClassLoader();

        try {
            return Class.forName(className, true, loader);
        } catch (ClassNotFoundException ex) {
            throw new ValidationException("Unable to load class: "  className, ex);
        }
    }

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import org.apache.bval.jsr303.example.ZipCodeCityCarrier;

import org.apache.bval.constraints.ZipCodeCityCoherence;

import org.apache.bval.constraints.NotEmpty;

import org.apache.bval.constraints.NotEmpty;

import javax.validation.constraints.NotNull;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.groups.Default;

import javax.validation.groups.Default;

import org.apache.bval.constraints.ZipCodeCityCoherence;
import org.apache.bval.jsr303.example.ZipCodeCityCarrier;

        try {
            return field.get(instance);
        } catch (IllegalAccessException e) {
            throw new IllegalArgumentException(e);
        }
        try {
            return method.invoke(instance);
        } catch (IllegalAccessException e) {
            throw new IllegalArgumentException(e);
        } catch (InvocationTargetException e) {
            throw new IllegalArgumentException(e);
        }
        @SuppressWarnings("unchecked")
        return doPrivileged(new PrivilegedAction<A>() {
    @SuppressWarnings({ "rawtypes" })
    @SuppressWarnings({ "rawtypes" })
    @SuppressWarnings({ "rawtypes" })
import java.lang.reflect.Method;
import java.lang.reflect.Type;
 * Description: use information from java.beans.Introspector in MetaBeans. The PropertyDescriptor can contain info about
 * HIDDEN, PREFERRED, READONLY and other features<br/>
public class IntrospectorMetaBeanFactory implements MetaBeanFactory {
        if (meta.getBeanClass() == null) {
            return; // handle only, when local class exists
        }
        if (meta.getName() == null && info.getBeanDescriptor() != null) {
            meta.setName(info.getBeanDescriptor().getName()); // (display?)name = simple class name!
                MetaProperty metaProp = buildMetaProperty(pd, meta.getProperty(pd.getName()));
     * 
    @Deprecated
        return buildMetaProperty(pd, null);
    }

    /**
     * Create a {@link MetaProperty} from the specified {@link PropertyDescriptor}.
     * 
     * @param pd
     * @param existing
     * @return MetaProperty
     */
    protected MetaProperty buildMetaProperty(PropertyDescriptor pd, MetaProperty existing) {
        meta.setType(determineGenericPropertyType(pd));
        if (pd.isHidden()) {
            meta.putFeature(HIDDEN, Boolean.TRUE);
        }
        if (pd.isPreferred()) {
            meta.putFeature(PREFERRED, Boolean.TRUE);
        }
        if (pd.isConstrained()) {
            meta.putFeature(READONLY, Boolean.TRUE);
        }

    private Type determineGenericPropertyType(PropertyDescriptor pd) {
        Method m = pd.getReadMethod();
        if (m != null) {
            return m.getGenericReturnType();
        }
        m = pd.getWriteMethod();
        if (m != null && m.getParameterTypes().length == 1) {
            return m.getGenericParameterTypes()[0];
        }
        return pd.getPropertyType();
    }
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.ArrayUtils;
        validations = ArrayUtils.add(validations, validation);
import java.util.Arrays;
import java.util.Comparator;

import org.apache.commons.lang3.ArrayUtils;
 * Description: the meta description of a bean or class. the class/bean itself can have a map of features and an array
 * of metaproperties.<br/>
 * 
    /**
     * Comparator for managing the sorted properties array.
     */
    private static class PropertyNameComparator implements Comparator<Object> {
        /** Static instance */
        static final PropertyNameComparator INSTANCE = new PropertyNameComparator();

        /**
         * {@inheritDoc}
         */
        public int compare(Object o1, Object o2) {
            return getName(o1).compareTo(getName(o2));
        }

        private String getName(Object o) {
            if (o == null) {
                throw new NullPointerException();
            }
            return o instanceof MetaProperty ? ((MetaProperty) o).getName() : String.valueOf(o);
        }
    }

     * 
     * 
     * @param id
     *            the String to set
     * 
     * 
     * @param name
     *            the String to set
     * 
     * 
     * @param beanClass
     *            the Class<?> to set
     * 
     * 
     * @param properties
     *            the MetaProperty[] to set
        Arrays.sort(properties, PropertyNameComparator.INSTANCE);
     * 
        final MetaProperty[] props = properties;
        int pos = Arrays.binarySearch(props, name, PropertyNameComparator.INSTANCE);
        return pos < 0 ? null : props[pos];
     * 
            if (p.isRelationship()) {
                return true;
            }
     * 
    /**
     * bidirectional - set the relationship between a MetaProperty and its parentMetaBean
     * 
     * @param name
     * @param property
     *            if <code>null</code>, remove
     */
        if (property != null) {
            property.setParentMetaBean(this);
        Object key = property == null ? name : property;
        // make a local copy for consistency
        MetaProperty[] props = properties;
        int pos = Arrays.binarySearch(props, key, PropertyNameComparator.INSTANCE);
        if (pos < 0) {
            if (property == null) {
                // store null property for unknown name == NOOP
                return;
            }
            props = ArrayUtils.add(props, 0 - pos - 1, property);
        } else {
            if (property == null) {
                props = ArrayUtils.remove(props, pos);
            } else {
                props[pos] = property;
            }
        }
        this.properties = props;
        return "MetaBean{"  "id='"  id  '\''  ", name='"  name  '\''  ", beanClass="  beanClass  '}';
     * <p>
     * If this {@link MetaBean} is compatible with <code>bean</code>, return <code>this</code>, else <code>null</code>.
     * </p>
     * <p>
     * Compatibility is satisfied in one of the following ways:
     * <ul>
     * </ul>
     * </p>
     * 
import org.apache.commons.lang3.reflect.TypeUtils;

        Type targetType = type instanceof DynaType ? ((DynaType) type)
                .getRawType() : type;
        if (targetType == null) {
            return null;
        Type assigningType = getParentMetaBean() == null ? null
                : getParentMetaBean().getBeanClass();
        return TypeUtils.getRawType(targetType, assigningType);

import java.lang.reflect.Method;
 * Description: Undefined dynamic strategy (FIELD or METHOD access) Uses PropertyUtils or tries to determine field to
 * access the value<br/>
        return rememberField != null ? ElementType.FIELD : ElementType.METHOD;
        Type result = getTypeInner();
        return result == null ? Object.class : result;
    }

    /**
     * Learn whether this {@link PropertyAccess} references a known property.
     * 
     * @return boolean
     */
    public boolean isKnown() {
        return getTypeInner() != null;
    }

    /**
     * Find out what, if any, type can be calculated.
     * 
     * @return type found or <code>null</code>
     */
    private Type getTypeInner() {
        if (rememberField != null) {
        Method readMethod = getPropertyReadMethod(propertyName, beanClass);
        if (readMethod != null) {
            return readMethod.getGenericReturnType();
        }
        Field fld = getField(propertyName, beanClass);
        if (fld != null) {
            cacheField(fld);
            return rememberField.getGenericType();
        }
        return null;
    }

    private static Method getPropertyReadMethod(String propertyName, Class<?> beanClass) {
            if (each.getName().equals(propertyName)) {
                return each.getReadMethod();
        return null;
    }

    private static Field getField(String propertyName, Class<?> beanClass) {
            return beanClass.getField(propertyName);
                    return theClass.getDeclaredField(propertyName);
        return null;
        Field field = getField(propertyName, beanClass);
        if (field != null) {
            cacheField(field);
            return rememberField.get(bean);
        throw new IllegalArgumentException("cannot access field "  propertyName);
    }

    private void cacheField(Field field) {
        if (!field.isAccessible()) {
            field.setAccessible(true);
        }
        this.rememberField = field;
import org.apache.bval.model.MetaBean;
        Object[] array = (Object[]) context.getBean();
        MetaBean metaBean = context.getMetaBean();
        context.setCurrentIndex(null);
        try {
            for (Object each : array) {
                context.setCurrentIndex(index);
                if (each == null) {
                    continue; // Null values are not validated
                }
                if (dyn != null) {
                    context.setBean(each, dyn.resolveMetaBean(each));
                } else {
                    context.setBean(each);
                }
                s.validate();
        } finally {
            context.moveUp(array, metaBean);
        Iterable<?> iterable = (Iterable<?>) context.getBean();
        MetaBean metaBean = context.getMetaBean();
        try {
            // jsr303 spec: Each object provided by the iterator is validated.
            final DynamicMetaBean dyn = getDynamicMetaBean(context);
            for (Object each : iterable) {
                if (positional) {
                    context.setCurrentIndex(index);
                }
                if (each == null) {
                    continue; // Null values are not validated
                }
                if (dyn != null) {
                    context.setBean(each, dyn.resolveMetaBean(each));
                } else {
                    context.setBean(each);
                }
                s.validate();
        } finally {
            context.moveUp(iterable, metaBean);
        // jsr303 spec: For Map, the value of each Map.Entry is validated (key
        // is not validated).
        MetaBean metaBean = context.getMetaBean();
        context.setCurrentKey(null);
        try {
            for (Object key : currentBean.keySet()) {
                context.setCurrentKey(key);
                Object value = currentBean.get(key);
                if (value == null) {
                    continue; // Null values are not validated
                }
                if (dyn != null) {
                    context.setBean(value, dyn.resolveMetaBean(value));
                } else {
                    context.setBean(value);
                }
                s.validate();
        } finally {
            context.moveUp(currentBean, metaBean);
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.PrivilegedAction;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintValidator;
import javax.validation.OverridesAttribute;
import javax.validation.Payload;
import javax.validation.ReportAsSingleViolation;
 * composite constraint validations by parsing the jsr303-annotations and
 * providing information (e.g. for @OverridesAttributes) <br/>
     * 
    public AnnotationConstraintBuilder(Class<? extends ConstraintValidator<A, ?>>[] validatorClasses,
        ConstraintValidator<A, ?> constraintValidator, A annotation, Class<?> owner, AccessStrategy access) {
        boolean reportFromComposite =
            annotation != null && annotation.annotationType().isAnnotationPresent(ReportAsSingleViolation.class);
        constraintValidation =
            new ConstraintValidation<A>(validatorClasses, constraintValidator, annotation, owner, access,
                reportFromComposite);
                    for (Method method : constraintValidation.getAnnotation().annotationType().getDeclaredMethods()) {
                        // groups  payload must also appear in attributes (also
                        // checked by TCK-Tests)
                                if (ConstraintAnnotationAttributes.PAYLOAD.getAttributeName().equals(method.getName())) {
                                } else if (ConstraintAnnotationAttributes.GROUPS.getAttributeName().equals(
                                    method.getName())) {
                                    constraintValidation.getAttributes().put(method.getName(),
                                        method.invoke(constraintValidation.getAnnotation()));
                                log.warn("error processing annotation: "  constraintValidation.getAnnotation(), e);
    private void buildGroups(Method method) throws IllegalAccessException, InvocationTargetException {
            garr = new Class[] { (Class<?>) raw };
    private void buildPayload(Method method) throws IllegalAccessException, InvocationTargetException {
            (Class<? extends Payload>[]) method.invoke(constraintValidation.getAnnotation());
            payloadSet = Collections.<Class<? extends Payload>> emptySet();
     * 
     * initialize a child composite 'validation' with @OverridesAttribute from
     * 'constraintValidation' and add to composites.
            if (generalOverride != null) {
                if (index > 0) {
                    throw new ConstraintDeclarationException("Wrong OverridesAttribute declaration for "
                         generalOverride.constraintType
                         ", it needs a defined index when there is a list of constraints");
            if (override != null) {
     * 
        for (Method method : constraintValidation.getAnnotation().annotationType().getDeclaredMethods()) {
            OverridesAttribute.List annoOAL = method.getAnnotation(OverridesAttribute.List.class);
        target.values.put(oa.name(), constraintValidation.getAttributes().get(methodName));
    private ConstraintOverrides findOverride(Class<? extends Annotation> constraint, int constraintIndex) {
            if (each.constraintType == constraint && each.constraintIndex == constraintIndex) {
     * Holds the values to override in a composed constraint during creation of
     * a composed ConstraintValidation
        private ConstraintOverrides(Class<? extends Annotation> constraintType, int constraintIndex) {
            for (String key : values.keySet()) {
import java.lang.reflect.Constructor;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;

import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.ValidatorContext;

import org.apache.bval.IntrospectorMetaBeanFactory;
import org.apache.bval.MetaBeanBuilder;
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.MetaBeanManager;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.PrivilegedActions;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.reflect.ConstructorUtils;
     * Create MetaBeanManager that uses factories:
     * <ol>
     * <li>if enabled by
     * {@link ApacheValidatorConfiguration.Properties#ENABLE_INTROSPECTOR}, an
     * {@link IntrospectorMetaBeanFactory}</li>
     * <li>{@link MetaBeanFactory} types (if any) specified by
     * {@link ApacheValidatorConfiguration.Properties#METABEAN_FACTORY_CLASSNAMES}
     * </li>
     * <li>if no {@link Jsr303MetaBeanFactory} has yet been specified (this
     * allows factory order customization), a {@link Jsr303MetaBeanFactory}
     * which handles both JSR303-XML and JSR303-Annotations</li>
     * <li>if enabled by
     * {@link ApacheValidatorConfiguration.Properties#ENABLE_METABEANS_XML}, an
     * {@link XMLMetaBeanFactory}</li>
     * </ol>
        List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>();
        String[] factoryClassNames =
            StringUtils.split(
                factory.getProperties().get(ApacheValidatorConfiguration.Properties.METABEAN_FACTORY_CLASSNAMES));
        if (factoryClassNames != null) {
            for (String clsName : factoryClassNames) {
                // cast, relying on #createMetaBeanFactory to throw the exception if incompatible:
                @SuppressWarnings("unchecked")
                Class<? extends MetaBeanFactory> factoryClass = (Class<? extends MetaBeanFactory>) loadClass(clsName);
                builders.add(createMetaBeanFactory(factoryClass));
            }
        }
        boolean jsr303Found = false;
        for (MetaBeanFactory builder : builders) {
            jsr303Found |= builder instanceof Jsr303MetaBeanFactory;
        }
        if (!jsr303Found) {
            builders.add(new Jsr303MetaBeanFactory(this));
        }
        @SuppressWarnings("deprecation")
        boolean enableMetaBeansXml = Boolean.parseBoolean(factory.getProperties().get(
            ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML));
        if (enableMetaBeansXml) {
            XMLMetaBeanManagerCreator.addFactory(builders);
        }
    protected MetaBeanFinder createMetaBeanManager(List<MetaBeanFactory> builders) {
    private <F extends MetaBeanFactory> F createMetaBeanFactory(final Class<F> cls) {
        return PrivilegedActions.run(new PrivilegedAction<F>() {

            public F run() {
                try {
                    Constructor<F> c = ConstructorUtils.getMatchingAccessibleConstructor(cls, ApacheFactoryContext.this.getClass());
                    if (c != null) {
                        return c.newInstance(ApacheFactoryContext.this);
                    }
                    c = ConstructorUtils.getMatchingAccessibleConstructor(cls, getFactory().getClass());
                    if (c != null) {
                        return c.newInstance(getFactory());
                    }
                    return cls.newInstance();
                } catch (Exception e) {
                    throw new ValidationException(e);
                }
            }
        });
    }

        static void addFactory(List<MetaBeanFactory> builders) {
            builders.add(new XMLMetaBeanFactory());
        }


    private static <T> T doPrivileged(final PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }

    private Class<?> loadClass(final String className) {
        ClassLoader loader = doPrivileged(SecureActions.getContextClassLoader());
        if (loader == null)
            loader = getClass().getClassLoader();

        try {
            return Class.forName(className, true, loader);
        } catch (ClassNotFoundException ex) {
            throw new ValidationException("Unable to load class: "  className, ex);
        }
    }
import java.security.AccessController;
import java.security.PrivilegedAction;

import org.apache.commons.lang3.ClassUtils;
    public ApacheValidatorConfiguration createSpecializedConfiguration(BootstrapState state) {
import javax.validation.ValidatorContext;

        /**
         * Specifies the names, delimited by whitespace, of
         * {@link MetaBeanFactory} classes that should be added to collaborate
         * with an {@link ApacheFactoryContext}'s {@link MetaBeanFinder}. These
         * are instantiated per {@link ValidatorContext}, attempting to use
         * constructor arguments of decreasing specificity:
         * <ol>
         * <li>assignable from the creating {@link ApacheFactoryContext}</li>
         * <li>assignable from the associated {@link ApacheValidatorFactory}</li>
         * <li>default (no-args) constructor</li>
         * </ol>
         */
         String METABEAN_FACTORY_CLASSNAMES = "apache.bval.metabean-factory-classnames";
import org.apache.commons.lang3.ClassUtils;
     * @param accessStrategy
     *            defining the property to validate
    @SuppressWarnings({ "unchecked", "rawtypes" })
        apb.putValue(ConstraintAnnotationAttributes.GROUPS.getAttributeName(),
            inheritedGroups.toArray(new Class[inheritedGroups.size()]));
        apb.putValue(ConstraintAnnotationAttributes.PAYLOAD.getAttributeName(),
            inheritedPayload.toArray(new Class[inheritedPayload.size()]));
     * Return the property level constraints for a given propertyName or {@code null} if
     * either the property does not exist or has no constraint. The returned
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import javax.validation.ConstraintViolation;
import javax.validation.ValidationException;
import javax.validation.groups.Default;
import javax.validation.metadata.BeanDescriptor;

import org.apache.bval.DynamicMetaBean;
import org.apache.bval.jsr303.util.PathNavigation;
import org.apache.bval.jsr303.util.ValidationContextTraversal;
import org.apache.bval.model.FeaturesCapable;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.reflect.TypeUtils;
 * Objects of this class are able to validate bean instances (and the associated object graphs).
 * @version $Rev$ $Date$
 * 
 * @author Carlos Vara
public class ClassValidator implements CascadingPropertyValidator {
    private static final Object VALIDATE_PROPERTY = new Object() {
        public String toString() {
            return "VALIDATE_PROPERTY";
        }
    };


    protected MetaBeanFinder getMetaBeanFinder() {
    public <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {
            MetaBean objectMetaBean = getMetaBeanFinder().findForClass(objectClass);
            final GroupValidationContext<T> context = createContext(objectMetaBean, object, objectClass, groups);
            final ConstraintValidationListener<T> result = context.getListener();
     * {@inheritDoc} Validates all constraints placed on the property of <code>object</code> named
     * <code>propertyName</code>.
    public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, Class<?>... groups) {
        return validateProperty(object, propertyName, false, groups);
     * {@inheritDoc}
     */
    public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, boolean cascade,
        Class<?>... groups) {

        if (object == null)
            throw new IllegalArgumentException("cannot validate null");

        @SuppressWarnings("unchecked")
        Set<ConstraintViolation<T>> result =
            validateValueImpl((Class<T>) object.getClass(), object, propertyName, VALIDATE_PROPERTY, cascade, groups);
        return result;
    }

    /**
     * {@inheritDoc} Validates all constraints placed on the property named <code>propertyName</code> of the class
     * <code>beanType</code> would the property value be <code>value</code>
     * <code>ConstraintViolation</code> objects return null for {@link ConstraintViolation#getRootBean()} and
    public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value,
        Class<?>... groups) {
        return validateValue(beanType, propertyName, value, false, groups);
     * {@inheritDoc}
     */
    public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value,
        boolean cascade, Class<?>... groups) {
        return validateValueImpl(checkBeanType(beanType), null, propertyName, value, cascade, groups);
    }

    /**
     * {@inheritDoc} Return the descriptor object describing bean constraints. The returned object (and associated
     * objects including <code>ConstraintDescriptor<code>s) are immutable.
            MetaBean metaBean = getMetaBeanFinder().findForClass(clazz);
            BeanDescriptorImpl edesc = metaBean.getFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR);
            throw new ValidationException("error retrieving constraints for "  clazz, ex);
     * {@inheritDoc} Return an instance of the specified type allowing access to provider-specific APIs. If the Bean
     * Validation provider implementation does not support the specified class, <code>ValidationException</code> is
        } else if (!(type.isInterface() || Modifier.isAbstract(type.getModifiers()))) {
                    final Class<? extends T> implClass = (Class<? extends T>) cls;
     * Validates a bean and all its cascaded related beans for the currently defined group.
            final ConstraintValidationListener<?> result = (ConstraintValidationListener<?>) context.getListener();
            if (defaultGroups != null && defaultGroups.size() > 1) {
                ClassHelper.fillFullClassHierarchyAsList(classHierarchy, context.getMetaBean().getBeanClass());
                        context.getMetaBean().getFeature("{GroupSequence:"  owner.getCanonicalName()  "}");
     * Checks if the the meta property <code>prop</code> defines a cascaded bean, and in case it does, validates it.
    private void validateCascadedBean(GroupValidationContext<?> context, MetaProperty prop) {
        AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
                    ValidationHelper
                        .validateContext(context, new Jsr303ValidationCallback(context), treatMapsLikeBeans);
     * Before accessing a related bean (marked with {@link javax.validation.Valid}), the validator has to check if it is
     * @return <code>true</code> if the validator can access the related bean, <code>false</code> otherwise.
    private boolean isCascadable(GroupValidationContext<?> context, MetaProperty prop, AccessStrategy access) {
            if (!context.getTraversableResolver().isReachable(context.getBean(), node,
                context.getRootMetaBean().getBeanClass(), beanPath, access.getElementType()))
            throw new ValidationException("Error in TraversableResolver.isReachable() for "  context.getBean(), e);
            if (!context.getTraversableResolver().isCascadable(context.getBean(), node,
                context.getRootMetaBean().getBeanClass(), beanPath, access.getElementType()))
            throw new ValidationException("Error TraversableResolver.isCascadable() for "  context.getBean(), e);
     * in case of a default group return the list of groups for a redefined default GroupSequence
     * @return null when no in default group or default group sequence not redefined
            List<Group> groupSeq = context.getMetaBean().getFeature(Jsr303Features.Bean.GROUP_SEQUENCE);
                context.getGroups().assertDefaultGroupSequenceIsExpandable(groupSeq);
    @SuppressWarnings("finally")
    protected static RuntimeException unrecoverableValidationError(RuntimeException ex, Object object) {
        if (ex instanceof UnknownPropertyException || ex instanceof IncompatiblePropertyValueException) {
    private void validatePropertyInGroup(final GroupValidationContext<?> context) {
        final Runnable helper;
        if (context.getMetaProperty() == null) {
            helper = new Runnable() {

                public void run() {
                    ValidationHelper.validateBean(context);
                }
            };
        } else {
            helper = new Runnable() {

                public void run() {
                    ValidationHelper.validateProperty(context);
                }
            };
        }
                helper.run();
                // continue validation, even if errors already found
            helper.run();
    protected <T> GroupValidationContext<T> createContext(MetaBean metaBean, T object, Class<T> objectClass,
        Class<?>... groups) {
        ConstraintValidationListener<T> listener = new ConstraintValidationListener<T>(object, objectClass);
            new GroupValidationContextImpl<T>(listener, this.factoryContext.getMessageInterpolator(),
                this.factoryContext.getTraversableResolver(), metaBean);
     * @return treatMapsLikeBeans - true (validate maps like beans, so that
     *                              you can use Maps to validate dynamic classes or
     *                              beans for which you have the MetaBean but no instances)
     *                            - false (default), validate maps like collections
     *                              (validating the values only)
    /**
     * Set whether maps are to be treated like beans.
     * 
     * <pre>
     * @param treatMapsLikeBeans - true (validate maps like beans, so that
     *                             you can use Maps to validate dynamic classes or
     *                             beans for which you have the MetaBean but no instances)
     *                           - false (default), validate maps like collections
     *                             (validating the values only)
     * </pre>
     */
     * Checks that beanType is valid according to spec Section 4.1.1 i. Throws an {@link IllegalArgumentException} if it
     * is not.
    private <T> Class<T> checkBeanType(Class<T> beanType) {
        return beanType;
     * Checks that the property name is valid according to spec Section 4.1.1 i. Throws an
     * {@link IllegalArgumentException} if it is not.
            throw new IllegalArgumentException("Property path cannot be null or empty.");
     * Checks that the groups array is valid according to spec Section 4.1.1 i. Throws an
     * {@link IllegalArgumentException} if it is not.
     * Dispatches a call from {@link #validate()} to {@link ClassValidator#validateBeanNet(GroupValidationContext)} with
     * the current context set.
    protected class Jsr303ValidationCallback implements ValidationHelper.ValidateCallback {
    /**
     * Create a {@link ValidationContextTraversal} instance for this {@link ClassValidator}.
     * 
     * @param validationContext
     * @return {@link ValidationContextTraversal}
     */
    protected ValidationContextTraversal createValidationContextTraversal(GroupValidationContext<?> validationContext) {
        return new ValidationContextTraversal(validationContext);
    }

    /**
     * Implement {@link #validateProperty(Object, String, boolean, Class...)} and
     * {@link #validateValue(Class, String, Object, boolean, Class...)}.
     * 
     * @param <T>
     * @param beanType
     * @param object
     * @param propertyName
     * @param value
     * @param cascade
     * @param groups
     * @return {@link ConstraintViolation} {@link Set}
     */
    private <T> Set<ConstraintViolation<T>> validateValueImpl(Class<T> beanType, T object, String propertyName,
        Object value, final boolean cascade, Class<?>... groups) {

        assert (object == null) ^ (value == VALIDATE_PROPERTY);
        checkPropertyName(propertyName);
        checkGroups(groups);

        try {
            final MetaBean initialMetaBean = new DynamicMetaBean(getMetaBeanFinder());
            initialMetaBean.setBeanClass(beanType);
            GroupValidationContext<T> context = createContext(initialMetaBean, object, beanType, groups);
            ValidationContextTraversal contextTraversal = createValidationContextTraversal(context);
            PathNavigation.navigate(propertyName, contextTraversal);

            MetaProperty prop = context.getMetaProperty();
            boolean fixed = false;
            if (value != VALIDATE_PROPERTY) {
                assert !context.getPropertyPath().isRootPath();
                if (prop == null && value != null) {
                    context.setMetaBean(getMetaBeanFinder().findForClass(value.getClass()));
                }
                if (!cascade) {
                    //TCK doesn't care what type a property is if there are no constraints to validate:
                    FeaturesCapable meta = prop == null ? context.getMetaBean() : prop;
                    if (ArrayUtils.isEmpty(meta.getValidations())) {
                        return Collections.<ConstraintViolation<T>> emptySet();
                    }
                }
                if (!TypeUtils.isAssignable(value == null ? null : value.getClass(), contextTraversal.getType())) {
                    throw new IncompatiblePropertyValueException(String.format(
                        "%3$s is not a valid value for property %2$s of type %1$s", beanType, propertyName, value));
                }
                if (prop == null) {
                    context.setBean(value);
                } else {
                    context.setFixedValue(value);
                    fixed = true;
                }
            }
            boolean doCascade = cascade && (prop == null || prop.getMetaBean() != null);

            Object bean = context.getBean();

            ConstraintValidationListener<T> result = context.getListener();
            Groups sequence = context.getGroups();

            // 1. process groups

            for (Group current : sequence.getGroups()) {
                context.setCurrentGroup(current);

                if (!doCascade || prop != null) {
                    validatePropertyInGroup(context);
                }
                if (doCascade) {
                    contextTraversal.moveDownIfNecessary();
                    if (context.getMetaBean() instanceof DynamicMetaBean) {
                        context.setMetaBean(context.getMetaBean().resolveMetaBean(
                            ObjectUtils.defaultIfNull(context.getBean(), contextTraversal.getRawType())));
                    }
                    validateBeanNet(context);
                    if (prop != null) {
                        context.moveUp(bean, prop.getParentMetaBean());
                        context.setMetaProperty(prop);
                        if (fixed) {
                            context.setFixedValue(value);
                        }
                    }
                }
            }

            // 2. process sequences

            int groupViolations = result.getConstraintViolations().size();

            outer: for (List<Group> eachSeq : sequence.getSequences()) {
                for (Group current : eachSeq) {
                    context.setCurrentGroup(current);

                    if (!doCascade || prop != null) {
                        validatePropertyInGroup(context);
                    }
                    if (doCascade) {
                        contextTraversal.moveDownIfNecessary();
                        if (context.getMetaBean() instanceof DynamicMetaBean) {
                            context.setMetaBean(context.getMetaBean().resolveMetaBean(
                                ObjectUtils.defaultIfNull(context.getBean(), contextTraversal.getRawType())));
                        }
                        validateBeanNet(context);
                        if (prop != null) {
                            context.moveUp(bean, prop.getParentMetaBean());
                            context.setMetaProperty(prop);
                            if (fixed) {
                                context.setFixedValue(value);
                            }
                        }
                    }
                    /**
                     * if one of the group process in the sequence leads to one or more validation failure, the groups
                     * following in the sequence must not be processed
                     */
                    if (result.getConstraintViolations().size() > groupViolations)
                        break outer;
                }
            }
            return result.getConstraintViolations();
        } catch (RuntimeException ex) {
            throw unrecoverableValidationError(ex, ObjectUtils.defaultIfNull(object, value));
        }
    }

        for (Map.Entry<Object, Object> entry : constraintProperties.entrySet()) {
            LinkedList<Class<?>> classes = new LinkedList<Class<?>>();
                Class<?> constraintValidatorClass =
                      SecureActions.run(new PrivilegedAction<Class<?>>() {
                          public Class<?> run() {
                        (Class<? extends ConstraintValidator<?, ?>>[]) classes.toArray(new Class[classes.size()]));
        ConstraintAnnotationAttributes.GROUPS.put(attributes, groups.toArray(new Class[groups.size()]));
        ConstraintAnnotationAttributes.PAYLOAD.put(attributes, payload.toArray(new Class[payload.size()]));
                // TODO RSt - how should the composed constraint error report look like?
        return ConstraintAnnotationAttributes.MESSAGE.get(attributes);
 * 
 * @version $Rev$ $Date$
import javax.validation.MessageInterpolator;

import org.apache.bval.jsr303.util.SecureActions;
import org.apache.commons.lang3.ArrayUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;




     *
import java.util.Collections;
    @SuppressWarnings({"unchecked", "rawtypes"})
final class GroupValidationContextImpl<T> extends BeanValidationContext<ConstraintValidationListener<T>> implements
    GroupValidationContext<T>, MessageInterpolator.Context {
    private final MessageInterpolator messageResolver;
    private final PathImpl path;
    private final MetaBean rootMetaBean;
    /**
     * the groups in the sequence of validation to take place
     */
    private Groups groups;
    /**
     * the current group during the validation process
     */
    private Group currentGroup;
    private Class<?> currentOwner;
    /**
     * contains the validation constraints that have already been processed
     * during this validation routine (as part of a previous group match)
     */
    private HashSet<ConstraintValidatorIdentity> validatedConstraints = new HashSet<ConstraintValidatorIdentity>();
    private ConstraintValidation<?> constraintValidation;
    private final TraversableResolver traversableResolver;
    /**
     * Create a new GroupValidationContextImpl instance.
     * 
     * @param listener
     * @param aMessageResolver
     * @param traversableResolver
     * @param rootMetaBean
     */
    public GroupValidationContextImpl(ConstraintValidationListener<T> listener, MessageInterpolator aMessageResolver,
        TraversableResolver traversableResolver, MetaBean rootMetaBean) {
        // inherited variable 'validatedObjects' is of type:
        // HashMap<GraphBeanIdentity, Set<PathImpl>> in this class
        super(listener, new HashMap<GraphBeanIdentity, Set<PathImpl>>());
        this.messageResolver = aMessageResolver;
        this.traversableResolver = CachingTraversableResolver.cacheFor(traversableResolver);
        this.rootMetaBean = rootMetaBean;
        this.path = PathImpl.create(null);
    /**
     * {@inheritDoc}
     */
    @Override
    public void setCurrentIndex(Integer index) {
        NodeImpl leaf = path.getLeafNode();
        if (leaf.getName() == null) {
            leaf.setIndex(index);
        } else {
            path.addNode(NodeImpl.atIndex(index));
        }
    /**
     * {@inheritDoc}
     */
    @Override
    public void setCurrentKey(Object key) {
        NodeImpl leaf = path.getLeafNode();
        if (leaf.getName() == null) {
            leaf.setKey(key);
        } else {
            path.addNode(NodeImpl.atKey(key));
        }
    /**
     * {@inheritDoc}
     */
    @Override
    public void moveDown(MetaProperty prop, AccessStrategy access) {
        path.addProperty(prop.getName());
        super.moveDown(prop, access);
    /**
     * {@inheritDoc}
     */
    @Override
    public void moveUp(Object bean, MetaBean metaBean) {
        NodeImpl leaf = path.getLeafNode();
        if (leaf.isInIterable() && leaf.getName() != null) {
            leaf.setName(null);
        } else {
            path.removeLeafNode();
        }
        super.moveUp(bean, metaBean); // call super!
    }
    /**
     * {@inheritDoc} Here, state equates to bean identity  group.
     */
    @SuppressWarnings("unchecked")
    @Override
    public boolean collectValidated() {
        // Combination of beangroupowner (owner is currently ignored)
        GraphBeanIdentity gbi = new GraphBeanIdentity(getBean(), getCurrentGroup().getGroup(), getCurrentOwner());
        Set<PathImpl> validatedPathsForGBI = (Set<PathImpl>) validatedObjects.get(gbi);
        if (validatedPathsForGBI == null) {
            validatedPathsForGBI = new HashSet<PathImpl>();
            validatedObjects.put(gbi, validatedPathsForGBI);
        }

        // If any of the paths is a subpath of the current path, there is a
        // circular dependency, so return false
        for (PathImpl validatedPath : validatedPathsForGBI) {
            if (path.isSubPathOf(validatedPath)) {
                return false;
            }
        }

        // Else, add the currentPath to the set of validatedPaths
        validatedPathsForGBI.add(PathImpl.copy(path));
        return true;
    }

    /**
     * {@inheritDoc}
     */
    public boolean collectValidated(ConstraintValidator<?, ?> constraint) {
        ConstraintValidatorIdentity cvi = new ConstraintValidatorIdentity(getBean(), getPropertyPath(), constraint);
        return this.validatedConstraints.add(cvi);
    }

    /**
     * Reset the validated constraints.
     */
    public void resetValidatedConstraints() {
        validatedConstraints.clear();
    }

    /**
     * {@inheritDoc} If an associated object is validated, add the association
     * field or JavaBeans property name and a dot ('.') as a prefix to the
     * previous rules. uses prop[index] in property path for elements in
     * to-many-relationships.
     * 
     * @return the path in dot notation
     */
    public PathImpl getPropertyPath() {
        PathImpl currentPath = PathImpl.copy(path);
        if (getMetaProperty() != null) {
            currentPath.addProperty(getMetaProperty().getName());
        }
        return currentPath;
    }

    /**
     * {@inheritDoc}
     */
    public MetaBean getRootMetaBean() {
        return rootMetaBean;
    }

    /**
     * Set the Groups.
     * 
     * @param groups
     */
    public void setGroups(Groups groups) {
        this.groups = groups;
    }

    /**
     * {@inheritDoc}
     */
    public Groups getGroups() {
        return groups;
    }

    /**
     * {@inheritDoc}
     */
    public Group getCurrentGroup() {
        return currentGroup;
    }

    /**
     * {@inheritDoc}
     */
    public void setCurrentGroup(Group currentGroup) {
        this.currentGroup = currentGroup;
    }

    /**
     * {@inheritDoc}
     */
    public void setConstraintValidation(ConstraintValidation<?> constraint) {
        constraintValidation = constraint;
    }

    /**
     * {@inheritDoc}
     */
    public ConstraintValidation<?> getConstraintValidation() {
        return constraintValidation;
    }

    /**
     * {@inheritDoc}
     */
    public ConstraintDescriptor<?> getConstraintDescriptor() {
        return constraintValidation;
    }

    /**
     * {@inheritDoc}
     */
    public Object getValidatedValue() {
        if (getMetaProperty() != null) {
            return getPropertyValue(constraintValidation.getAccess());
        } else {
            return getBean();
        }
    }

    /**
     * {@inheritDoc}
     */
    public MessageInterpolator getMessageResolver() {
        return messageResolver;
    }

    /**
     * {@inheritDoc}
     */
    public TraversableResolver getTraversableResolver() {
        return traversableResolver;
    }

    /**
     * {@inheritDoc}
     */
    public Class<?> getCurrentOwner() {
        return this.currentOwner;
    }

    /**
     * {@inheritDoc}
     */
    public void setCurrentOwner(Class<?> currentOwner) {
        this.currentOwner = currentOwner;
    }
 * under the License.
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;

import javax.validation.Constraint;
import javax.validation.GroupDefinitionException;
import javax.validation.GroupSequence;
import javax.validation.ValidationException;
import javax.validation.groups.Default;
 * Description: process the class annotations for JSR303 constraint validations to build the MetaBean with information
 * from annotations and JSR303 constraint mappings (defined in xml)<br/>
    /** Shared log instance */
    // of dubious utility as it's static :/
     * {@link AnnotationProcessor} used.
     */
    protected AnnotationProcessor annotationProcessor;

    /**
     * 
        this.annotationProcessor = new AnnotationProcessor(factoryContext);
     * {@inheritDoc} Add the validation features to the metabean that come from JSR303 annotations in the beanClass.
            // the child classes are processed last to have the chance to
            // overwrite some declarations
            // of their superclasses and that they see what they inherit at the
            // time of processing
                processGroupSequence(eachClass, metabean, "{GroupSequence:"  eachClass.getCanonicalName()  "}");

     * 
    private void processClass(Class<?> beanClass, MetaBean metabean) throws IllegalAccessException,
        InvocationTargetException {

        if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(beanClass)) {
            annotationProcessor.processAnnotations(null, beanClass, beanClass, null, new AppendValidationToMeta(
                metabean));
            // create a property for those fields for which there is not yet a
            // MetaProperty
            if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(field)) {
                AccessStrategy access = new FieldAccess(field);
                boolean create = metaProperty == null;
                if (create) {
                    metaProperty = addMetaProperty(metabean, access);
                }
                if (!annotationProcessor.processAnnotations(metaProperty, beanClass, field, access,
                    new AppendValidationToMeta(metaProperty)) && create) {
                    metabean.putProperty(metaProperty.getName(), null);
                if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(method)) {
                    AccessStrategy access = new MethodAccess(propName, method);
                    boolean create = metaProperty == null;
                    // create a property for those methods for which there is
                    // not yet a MetaProperty
                    if (create) {
                        metaProperty = addMetaProperty(metabean, access);
                    }
                    if (!annotationProcessor.processAnnotations(metaProperty, beanClass, method, access,
                        new AppendValidationToMeta(metaProperty)) && create) {
                        metabean.putProperty(propName, null);
            } else if (hasValidationConstraintsDefined(method)) {
     * 
        for (Annotation annot : method.getDeclaredAnnotations()) {
            if (hasValidationConstraintsDefined(annot)) {
                return true;
        return false;
        if (annot.annotationType().getAnnotation(Constraint.class) != null) {

        // Check whether it is a multivalued constraint:
        if (ConstraintAnnotationAttributes.VALUE.isDeclaredOn(annot.annotationType())) {
            Annotation[] children = ConstraintAnnotationAttributes.VALUE.getValue(annot);
            if (children != null) {
                for (Annotation child : children) {
                    if (hasValidationConstraintsDefined(child)) {
                        return true;
                    }

        return false;
     * 
    private void addXmlConstraints(Class<?> beanClass, MetaBean metabean) throws IllegalAccessException,
        InvocationTargetException {
        for (MetaConstraint<?, ? extends Annotation> meta : factoryContext.getFactory().getMetaConstraints(beanClass)) {
            AccessStrategy access = meta.getAccessStrategy();
            boolean create = false;
            if (access == null) { // class level
                metaProperty = metabean.getProperty(access.getPropertyName());
                create = metaProperty == null;
                if (create) {
                    metaProperty = addMetaProperty(metabean, access);
            if (!annotationProcessor.processAnnotation(meta.getAnnotation(), metaProperty, beanClass,
                meta.getAccessStrategy(), new AppendValidationToMeta(metaProperty == null ? metabean : metaProperty))
                && create) {
                metabean.putProperty(access.getPropertyName(), null);
            }
            boolean create = metaProperty == null;
            if (create) {
                metaProperty = addMetaProperty(metabean, access);
            if (!annotationProcessor.addAccessStrategy(metaProperty, access) && create) {
                metabean.putProperty(access.getPropertyName(), null);

                throw new GroupDefinitionException("'Default.class' must not appear in @GroupSequence! Use '"
                     beanClass.getSimpleName()  ".class' instead.");
            throw new GroupDefinitionException("Redefined default group sequence must contain "  beanClass.getName());
     * Add a {@link MetaProperty} to a {@link MetaBean}.
     * @param parentMetaBean
     * @param access
     * @return the created {@link MetaProperty}
    public static MetaProperty addMetaProperty(MetaBean parentMetaBean, AccessStrategy access) {
        final MetaProperty result = new MetaProperty();
        final String name = access.getPropertyName();
        result.setName(name);
        result.setType(access.getJavaType());
        parentMetaBean.putProperty(name, result);
        return result;
 * @version $Rev$ $Date$
 * 
import javax.validation.ConstraintViolation;
import javax.validation.ValidationException;
import javax.validation.metadata.ConstraintDescriptor;

import org.apache.bval.jsr303.ApacheFactoryContext;
import org.apache.bval.jsr303.BeanDescriptorImpl;
import org.apache.bval.jsr303.ClassValidator;
import org.apache.bval.jsr303.ConstraintValidation;
import org.apache.bval.jsr303.ConstraintValidationListener;
import org.apache.bval.jsr303.GroupValidationContext;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.Groups;
import org.apache.bval.model.MetaBean;
import org.apache.bval.util.ValidationHelper;

import org.apache.bval.jsr303.ConstraintAnnotationAttributes;
import org.apache.commons.lang3.ClassUtils;
                annotationProcessor.processAnnotation(annotation, null,
                    ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations);
                if (ConstraintAnnotationAttributes.VALUE.isDeclaredOn(annotation.annotationType())) {
                    Annotation[] children = ConstraintAnnotationAttributes.VALUE.getValue(annotation);
                    if (children != null) {
                        for (Annotation child : children) {
                            processAnnotation(child, desc, access, validations); // recursion
                        }
        throw new UnsupportedOperationException("Obtaining a parameter value not yet implemented");
        throw new UnsupportedOperationException("Obtaining a method return value not yet implemented");
import org.apache.commons.lang3.ObjectUtils;

        DEFAULT_GROUPS = new GroupsComputer().computeGroups(Arrays.asList(getDefaultGroupArray()));
        return new Class<?>[] { Default.class };
    private final Map<Class<?>, List<Group>> resolvedSequences = Collections
        .synchronizedMap(new HashMap<Class<?>, List<Group>>());
import javax.validation.Path;
import javax.validation.TraversableResolver;

import org.apache.bval.jsr303.util.ClassHelper;
import org.apache.commons.lang3.ClassUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.commons.lang3.ClassUtils;

import org.apache.bval.jsr303.ConstraintAnnotationAttributes;

        ConstraintAnnotationAttributes.GROUPS.validateOn(annotation.annotationType());
        ConstraintAnnotationAttributes.PAYLOAD.validateOn(annotation.annotationType());
        ConstraintAnnotationAttributes.MESSAGE.validateOn(annotation.annotationType());

            if (method.getName().toLowerCase(Locale.ENGLISH).startsWith("valid")) {
                throw new ConstraintDefinitionException(
                    "A constraint annotation cannot have methods which start with 'valid'");
    private NodeImpl node;
        node = new NodeImpl(name);
        node.setInIterable(true);
        return new NodeContextBuilderImpl(parent, messageTemplate, propertyPath, node);
        propertyPath.addNode(node);
        node = new NodeImpl(name);
        propertyPath.addNode(node);
        node = null;
    private final NodeImpl node;
                                    String template, PathImpl path, NodeImpl node) {
        this.node = node;
        node.setKey(key);
        propertyPath.addNode(node);
        node.setIndex(index);
        propertyPath.addNode(node);
        propertyPath.addNode(node);
        return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, name);
        propertyPath.addNode(node);
import javax.validation.Path.Node;

    /**
     * Append a Node to the specified StringBuilder.
     * @param node
     * @param to
     * @return to
     */
    public static StringBuilder appendNode(Node node, StringBuilder to) {
        if (node.isInIterable()) {
            to.append(INDEX_OPEN);
            if (node.getIndex() != null) {
                to.append(node.getIndex());
            } else if (node.getKey() != null) {
                to.append(node.getKey());
            }
            to.append(INDEX_CLOSE);
        }
        if (node.getName() != null) {
            if (to.length() > 0) {
                to.append(PathImpl.PROPERTY_PATH_SEPARATOR);
            }
            to.append(node.getName());
        }
        return to;
    }

    /**
     * Get a NodeImpl indexed from the preceding node (or root).
     * @param index
     * @return NodeImpl
     */
    public static NodeImpl atIndex(Integer index) {
        NodeImpl result = new NodeImpl();
        result.setIndex(index);
        return result;
    }

    /**
     * Get a NodeImpl keyed from the preceding node (or root).
     * @param key
     * @return NodeImpl
     */
    public static NodeImpl atKey(Object key) {
        NodeImpl result = new NodeImpl();
        result.setKey(key);
        return result;
    }

    private String name;
    private NodeImpl() {
    }

     * @param name the name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
        this.key = null;
        this.index = null;
        return appendNode(this, new StringBuilder()).toString();

 * (Implementation partially based on reference implementation)
 * 
 * @version $Rev$ $Date$
    static final String PROPERTY_PATH_SEPARATOR = ".";
    /**
     * Builds non-root paths from expressions.
     */
    private static class PathImplBuilder implements PathNavigation.Callback<PathImpl> {
        PathImpl result = new PathImpl();

        /**
         * {@inheritDoc}
         */
        public void handleProperty(String name) {
            result.addProperty(name);
        }

        /**
         * {@inheritDoc}
         */
        public void handleIndexOrKey(String value) {
            // with no context to guide us, we can only parse ints and fall back to String keys:
            NodeImpl node;
            try {
                node = NodeImpl.atIndex(Integer.parseInt(value));
            } catch (NumberFormatException e) {
                node = NodeImpl.atKey(value);
            }
            result.addNode(node);
        }

        /**
         * {@inheritDoc}
         */
        public PathImpl result() {
            if (result.nodeList.isEmpty()) {
                throw new IllegalStateException();
            }
            return result;
        }

        /**
         * {@inheritDoc}
         */
        public void handleGenericInIterable() {
            result.addNode(NodeImpl.atIndex(null));
        }

    }
     * Returns a {@code Path} instance representing the path described by the given string. To create a root node the
     * empty string should be passed. Note: This signature is to maintain pluggability with the RI impl.
     * 
     * @param propertyPath
     *            the path as string representation.
        return PathNavigation.navigateAndReturn(propertyPath, new PathImplBuilder());
     * 
     * 
     * 
    // our implementation stores a nameless root node.
        if (nodeList.size() != 1) {
            return false;
        }
        Path.Node first = nodeList.get(0);
        return !first.isInIterable() && first.getName() == null;
     * Return a new {@link PathImpl} that represents <code>this</code> minus its leaf node (if present).
     * 
     * 
     * @param node
     *            to add
        if (isRootPath()) {
            nodeList.set(0, node);
        } else {
            nodeList.add(node);
        }
    }

    /**
     * Encapsulate the node manipulations needed to add a named property to this path.
     * 
     * @param name
     */
    public void addProperty(String name) {
        if (!nodeList.isEmpty()) {
            NodeImpl leaf = getLeafNode();
            if (leaf != null && leaf.isInIterable() && leaf.getName() == null) {
                leaf.setName(name);
                return;
            }
        }
        addNode(new NodeImpl(name));
     * 
     * @throws IllegalStateException
     *             if no nodes are found
     * 
     * 
            if (pathNode.isInIterable()) {
                if (!thisNode.isInIterable()) {
                    return false;
                }
                if (pathNode.getIndex() != null && !pathNode.getIndex().equals(thisNode.getIndex())) {
                    return false;
                }
                if (pathNode.getKey() != null && !pathNode.getKey().equals(thisNode.getKey())) {
                    return false;
                }
            } else if (thisNode.isInIterable()) {
                // in this case we have shown that the proposed parent is not
                // indexed, and we are, thus the paths cannot match
            if (pathNode.getName() == null || pathNode.getName().equals(thisNode.getName())) {
                continue;
            }
            return false;
        for (Path.Node node : this) {
            NodeImpl.appendNode(node, builder);
        return !(nodeList != null && !nodeList.equals(path.nodeList)) && !(nodeList == null && path.nodeList != null);
import org.apache.bval.util.PrivilegedActions;

import org.apache.bval.jsr303.util.SecureActions;
 * InvocationHandler implementation of <code>Annotation</code> that pretends it
 * is a "real" source code annotation.
// TODO move this guy up to org.apache.bval.jsr303 or
// org.apache.bval.jsr303.model
class AnnotationProxy implements Annotation, InvocationHandler, Serializable {
     * 
            throw new RuntimeException("Trying to instanciate "  annotationType  " with unknown paramters.");
            if (comma)
                result.append(", ");
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import javax.validation.Payload;
import javax.validation.ValidationException;

import org.apache.bval.jsr303.ConstraintAnnotationAttributes;
import org.apache.bval.jsr303.util.SecureActions;

 * Description: Holds the information and creates an annotation proxy during xml
 * parsing of validation mapping constraints. <br/>
// TODO move this guy up to org.apache.bval.jsr303 or
// org.apache.bval.jsr303.model
     * Create a builder initially configured to create an annotation equivalent
     * to <code>annot</code>.
     * 
     * @return <code>true</code> if an <code>elementName</code> element is found
     *         on this annotation
        ConstraintAnnotationAttributes.MESSAGE.put(elements, message);
        ConstraintAnnotationAttributes.GROUPS.put(elements, groups);
     * 
        ConstraintAnnotationAttributes.PAYLOAD.put(elements, payload);
import java.io.InputStream;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.bval.jsr303.ApacheValidatorFactory;
import org.apache.bval.jsr303.ConstraintAnnotationAttributes;
import org.apache.bval.jsr303.util.EnumerationConverter;
import org.apache.bval.jsr303.util.IOUtils;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;
import org.apache.commons.beanutils.ConvertUtils;
import org.apache.commons.beanutils.Converter;
import org.apache.commons.lang3.StringUtils;

    private static final Set<ConstraintAnnotationAttributes> RESERVED_PARAMS = Collections.unmodifiableSet(EnumSet.of(
        ConstraintAnnotationAttributes.GROUPS, ConstraintAnnotationAttributes.MESSAGE,
        ConstraintAnnotationAttributes.PAYLOAD));
        for (ConstraintAnnotationAttributes attr : RESERVED_PARAMS) {
            if (attr.getAttributeName().equals(name)) {
                throw new ValidationException(name  " is a reserved parameter name.");
            List<Class<? extends ConstraintValidator<?, ?>>> classes =
                new ArrayList<Class<? extends ConstraintValidator<?, ?>>>();
import org.apache.commons.lang3.ArrayUtils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

    private final Map<String, Book> taggedBooks = new HashMap<String, Book>();

        if (persons == null)
            return Collections.emptyList();
        ArrayList<Employee> emps = new ArrayList<Employee>(persons.length);
        for (Person each : persons) {
            if (each instanceof Employee)
                emps.add((Employee) each);
    Collection<RecursiveFoo> foos = new ArrayList<RecursiveFoo>();
import org.apache.commons.lang3.ClassUtils;
public class XMLMetaBeanManager extends MetaBeanManager implements XMLMetaBeanRegistry, MetaBeanEnricher {
import org.apache.commons.lang3.ClassUtils;
@GroupSequence({Address.class, Address.HighLevelCoherence.class, Address.ExtraCareful.class })
    
    
    /**
     * Extra-careful validation group.
     */
    public interface ExtraCareful {}

    @NotNull
    @Size(max = 50, min = 1, groups = ExtraCareful.class)
    private String street1;

    @NotNull 
    private String zipCode;
    
    @NotNull
    @Size(max = 30)
    private String city;
            validationContext.setMetaBean(metaBean);
            bigDecimal = new BigDecimal(num.toString());
        bigDecimal = bigDecimal.stripTrailingZeros();
        int i = 0;
        for (String each : names) {
import org.apache.commons.lang3.ArrayUtils;
        return ArrayUtils.clone(factories);
        this.factories = ArrayUtils.clone(factories);
import org.apache.commons.lang3.ArrayUtils;

        return ArrayUtils.clone(enumConstants);
        return ArrayUtils.clone(validations);
        this.validations = ArrayUtils.clone(validations);
        return ArrayUtils.clone(properties);
        this.properties = ArrayUtils.clone(properties);
        Arrays.sort(this.properties, PropertyNameComparator.INSTANCE);
            for (Map.Entry<?, ?> entry : currentBean.entrySet()) {
                Object value = entry.getValue();
                    continue;
                context.setCurrentKey(entry.getKey());
                if (dyn == null) {
                } else {
                    context.setBean(value, dyn.resolveMetaBean(value));
                    String.format("Validation error when calling method '%s' with arguments %s",
                        String.format("Method '%s' returned a not valid value %s",
import org.apache.commons.lang3.ArrayUtils;
        this.validatorClasses = ArrayUtils.clone(validatorClasses);
        /**
         * {@inheritDoc}
         */
        /*
         * Override equals to make findbugs happy;
         * would simply ignore but doesn't seem to be possible at the inner class level
         * without attaching the filter to the containing class.
         */
        @Override
        public boolean equals(Object obj) {
            return super.equals(obj);
        }
        
        /**
         * {@inheritDoc}
         */
        /*
         * Override hashCode to make findbugs happy in the presence of overridden #equals :P
         */
        @Override
        public int hashCode() {
            return super.hashCode();
        }
import static org.apache.bval.model.Features.Property.MANDATORY;
import static org.apache.bval.model.Features.Property.MAX_LENGTH;
import static org.apache.bval.model.Features.Property.MAX_VALUE;
import static org.apache.bval.model.Features.Property.MIN_LENGTH;
import static org.apache.bval.model.Features.Property.MIN_VALUE;
import static org.apache.bval.model.Features.Property.REG_EXP;
import static org.apache.bval.model.Features.Property.TIME_LAG;
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.xml.XMLMetaValue;
            @SuppressWarnings("unchecked")
            T result = (T) this;
            return result;
                    @SuppressWarnings("unchecked")
                    T result = (T) newInstance(cls);
                    return result;
    @SuppressWarnings({ "unchecked", "rawtypes" })
    @SuppressWarnings("unused")
    @SuppressWarnings("unused")
    @SuppressWarnings("unused")
    @SuppressWarnings("unused")
        @SuppressWarnings("unchecked")
        @SuppressWarnings("unchecked")
    /** Serialization version */
    private static final long serialVersionUID = 1L;

    /** Serialization version */
    private static final long serialVersionUID = 1L;

        if (properties == null) properties = new ArrayList<XMLMetaProperty>();
        if (beanRelations == null) beanRelations = new ArrayList<XMLMetaBeanReference>();
          new LinkedHashMap<XMLMetaBeanLoader, XMLMetaBeanInfos>();
    @SuppressWarnings("deprecation")
    /** Serialization version */
    private static final long serialVersionUID = 1L;

    /** Serialization version */
    private static final long serialVersionUID = 1L;
    /** Serialization version */
    private static final long serialVersionUID = 1L;

    /** Serialization version */
    private static final long serialVersionUID = 1L;
    /** Serialization version */
    private static final long serialVersionUID = 1L;

    Class<?> targetClass = BusinessObject.class;
 * <p><b>InetAddress</b> validation and conversion routines (<code>java.net.InetAddress</code>).</p>
 *
 * <p>This class provides methods to validate a candidate IP address.
    String message() default "{org.apache.bval.extras.constraints.InetAddress.message}";
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * Modulus 10 <b>ABA Number</b> (or <b>Routing Transit Number</b> (RTN)) Check Digit
 * calculation/validation.
 * <p>
 * ABA Numbers (or Routing Transit Numbers) are a nine digit numeric code used
 * to identify American financial institutions for things such as checks or deposits
 * (ABA stands for the American Bankers Association).
 * <p>
 * Check digit calculation is based on <i>modulus 10</i> with digits being weighted
 * based on their position (from right to left) as follows:
 * <ul>
 *     <li>Digits 1, 4 and & 7 are weighted 1
 *     <li>Digits 2, 5 and & 8 are weighted 7
 *     <li>Digits 3, 6 and & 9 are weighted 3
 * </ul>
 * <p>
 * For further information see
 *  <a href="http://en.wikipedia.org/wiki/Routing_transit_number">Wikipedia -
 *  Routing transit number</a>.
 */
 b/bval-extras/src/main/java/org/apache/bval/extras/constraints/file/Directory.java
package org.apache.bval.extras.constraints.file;
 b/bval-extras/src/main/java/org/apache/bval/extras/constraints/file/DirectoryValidator.java
package org.apache.bval.extras.constraints.file;
 b/bval-extras/src/main/java/org/apache/bval/extras/constraints/file/NotDirectory.java
package org.apache.bval.extras.constraints.file;
 b/bval-extras/src/main/java/org/apache/bval/extras/constraints/file/NotDirectoryValidator.java
package org.apache.bval.extras.constraints.file;
 b/bval-extras/src/main/java/org/apache/bval/extras/constraints/file/Symlink.java
package org.apache.bval.extras.constraints.file;
 b/bval-extras/src/main/java/org/apache/bval/extras/constraints/file/SymlinkValidator.java
package org.apache.bval.extras.constraints.file;
 b/bval-extras/src/main/java/org/apache/bval/extras/constraints/net/Domain.java
package org.apache.bval.extras.constraints.net;
 b/bval-extras/src/main/java/org/apache/bval/extras/constraints/net/DomainValidator.java
package org.apache.bval.extras.constraints.net;
 b/bval-extras/src/main/java/org/apache/bval/extras/constraints/net/InetAddress.java
package org.apache.bval.extras.constraints.net;
 b/bval-extras/src/main/java/org/apache/bval/extras/constraints/net/InetAddressValidator.java
package org.apache.bval.extras.constraints.net;
    protected int toInt(char character, int leftPos, int rightPos) {
    /**
     * Add together the individual digits in a number.
     *
     * @param number The number whose digits are to be added
     * @return The sum of the digits
     */
    protected static int sumDigits(int number) {
        int total = 0;
        int todo = number;
        while (todo > 0) {
            total = todo % 10;
            todo  = todo / 10;
        }
        return total;
    }

    String message() default "{org.apache.bval.extras.constraints.checkdigit.ABANumber.message}";
    String message() default "{org.apache.bval.extras.constraints.checkdigit.CUSIP.message}";
 * under the License.
    String message() default "{org.apache.bval.extras.constraints.file.Directory.message}";
 * under the License.
    String message() default "{org.apache.bval.extras.constraints.file.NotDirectory.message}";
 * under the License.
    String message() default "{org.apache.bval.extras.constraints.file.Symlink.message}";
    String message() default "{org.apache.bval.extras.constraints.net.Domain.message}";
    String message() default "{org.apache.bval.extras.constraints.net.InetAddress.message}";
    extends ModulusValidator<ISBN10> {
import static java.lang.Character.getNumericValue;

            int num = getNumericValue(code.charAt(idx));
 b/bval-core/src/main/java/org/apache/bval/util/BValVersion.java
 * This class contains version information for BVal.
public class BValVersion {
    public static final String PROJECT_NAME = "Apache BVal";
            InputStream in = BValVersion.class.getResourceAsStream
        System.out.println(new BValVersion().toString());
 * The Google-Guice module for Apache BVal.
 * Contains Apache BVal support for Google-Guice.
 * Description: Uniquely identify Apache BVal in the Bean Validation bootstrap
 * strategy. Also contains Apache BVal specific configurations<br/>
import java.security.PrivilegedExceptionAction;
            getUtilClass(classLoader);
    private static Class<?> getUtilClass(final ClassLoader classLoader) throws Exception {
        return (System.getSecurityManager() == null) 
            ? getUtilClass0(classLoader)
            : AccessController.doPrivileged(new PrivilegedExceptionAction<Class<?>>() {
                    public Class<?> run() throws Exception {
                        return getUtilClass0(classLoader);
                    }
                });
    }
    private static Class<?> getUtilClass0(ClassLoader classLoader) throws Exception {
        return ClassUtils.getClass(classLoader, PERSISTENCE_UTIL_CLASSNAME, true);
    }
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;

import org.apache.commons.lang3.ClassUtils;
     * Perform action with AccessController.doPrivileged() if security if enabled.
     * Perform action with AccessController.doPrivileged() if security if enabled.
     *
     * @param action - the action to run
     * @return result of running the action
     */
    public static <T> T run(final PrivilegedExceptionAction<T> action) throws PrivilegedActionException, Exception {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }

    /**
     * Perform AccessController.doPrivileged() action for ClassUtil.getClass()
     * 
     * @return Class
     * @exception Exception
     */
    public static Class<?> getUtilClass(final ClassLoader classLoader, final String className) throws Exception {
        return PrivilegedActions.run(new PrivilegedExceptionAction<Class<?>>() {
            public Class<?> run() throws Exception {
                return ClassUtils.getClass(classLoader, className, true);
            }
        });
    }

    /**
        return run(new PrivilegedAction<Object>() {
        return run(new PrivilegedAction<ClassLoader>() {
import org.apache.bval.jsr303.util.SecureActions;
        return SecureActions.run(SecureActions.doPrivBuildValidatorFactory(this));
    }

    public ValidatorFactory doPrivBuildValidatorFactory() {
import org.apache.bval.util.PrivilegedActions;
            PrivilegedActions.getUtilClass(classLoader, PERSISTENCE_UTIL_CLASSNAME);
        final Method[] methods = SecureActions.run(
import javax.validation.ValidatorFactory;

import org.apache.bval.jsr303.ConfigurationImpl;
    /**
     * Create a privileged action for ConfigurationImpl.buildValidatorFactory.
     */
    public static PrivilegedAction<ValidatorFactory> doPrivBuildValidatorFactory(final ConfigurationImpl config) {
        return new PrivilegedAction<ValidatorFactory>() {
            public ValidatorFactory run() {
                return config.doPrivBuildValidatorFactory();
            }
        };
    private final List<ConstraintValidation<?>> validations = new ArrayList<ConstraintValidation<?>>();
    public List<ConstraintValidation<?>> getValidations() {

import java.util.logging.Level;
import java.util.logging.Logger;

    private static final Logger log =  Logger.getLogger(MetaBeanBuilder.class.getName());
            	log.log(Level.FINE, String.format("Class not found: %s", className), e);
import java.util.logging.Level;
import java.util.logging.Logger;
    private static final Logger log = Logger.getLogger(AnnotationConstraintBuilder.class.getName());
                                log.log(Level.WARNING, String.format("Error processing annotation: %s ", constraintValidation.getAnnotation()), e);
import java.util.logging.Logger;
    private static final Logger log = Logger.getLogger(ConfigurationImpl.class.getName());
import java.util.logging.Level;
import java.util.logging.Logger;
    private static final Logger log = Logger.getLogger(ConstraintDefaults.class.getName());
                log.log(Level.SEVERE, String.format("Cannot load %s", resource), e);
            log.log(Level.WARNING, String.format("Cannot find %s", resource));

                                  log.log(Level.SEVERE, String.format("Cannot find class %s", eachClassName), e);
import java.util.logging.Level;
import java.util.logging.Logger;
    private static final Logger log = Logger.getLogger(DefaultMessageInterpolator.class.getName());
            log.log(Level.FINEST, String.format("%s found", USER_VALIDATION_MESSAGES));
        	log.log(Level.FINEST, String.format("%s not found. Delegating to %s", USER_VALIDATION_MESSAGES, DEFAULT_VALIDATION_MESSAGES));
            log.fine(message);
import java.util.logging.Level;
import java.util.logging.Logger;
    protected static final Logger log = Logger.getLogger(Jsr303MetaBeanFactory.class.getName());
        log.log(Level.FINEST, String.format("Default group sequence for bean %s is: %s", beanClass.getName(), groupSeq));
import java.util.logging.Level;
import java.util.logging.Logger;
    private static final Logger log = Logger.getLogger(DefaultTraversableResolver.class.getName());
            log.log(Level.FINEST, String.format("Found %s on classpath.", PERSISTENCE_UTIL_CLASSNAME));
            log.log(Level.FINEST, String.format("Cannot find %s on classpath. All properties will per default be traversable.", PERSISTENCE_UTIL_CLASSNAME));
            log.log(Level.FINEST, String.format("Instantiated an instance of %s.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME));
			log.log(Level.WARNING,
					String.format(
							"Unable to load or instanciate JPA aware resolver %s. All properties will per default be traversable.",
							JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME, e));
import java.util.logging.Level;
import java.util.logging.Logger;
    private static final Logger log = Logger.getLogger(AnnotationIgnores.class.getName());
        log.log(Level.FINEST, String.format("%s level annotations are getting ignored for %s.%s", type, clazz.getName(), member.getName()));
        	log.log(Level.FINEST, String.format("Class level annotation are getting ignored for %s", clazz.getName()));
import java.util.logging.Level;
import java.util.logging.Logger;
    private static final Logger log = Logger.getLogger(ValidationParser.class.getName());
            	log.log(Level.FINEST, String.format("No %s found. Using annotation based configuration only.", validationXmlFile));
            log.log(Level.FINEST, String.format("%s found.", validationXmlFile));
            log.log(Level.WARNING, String.format("Unable to parse schema: %s", xsd), e);
            if (log.isLoggable(Level.FINEST)) {
                log.log(Level.FINEST, String.format("Found property '%s' with value '%s' in %s", property.getName(), property.getValue(), validationXmlFile));
            log.log(Level.INFO, String.format("Using %s as validation provider.", providerClassName));
                log.log(Level.INFO, String.format("Using %s as message interpolator.", messageInterpolatorClass));
                log.log(Level.INFO, String.format("Using %s as traversable resolver.", traversableResolverClass));
                log.log(Level.INFO, String.format("Using %s as constraint factory.", constraintFactoryClass));
            log.log(Level.FINEST, String.format("Trying to open input stream for %s", mappingFileName));
import java.util.logging.Level;
import java.util.logging.Logger;
    private static final Logger loggger = Logger.getLogger(XMLMetaBeanFactory.class.getName());
        loggger.log(Level.SEVERE, String.format("Error loading %s", loader), e);
							"Unable to load or instantiate JPA aware resolver %s. All properties will per default be traversable.",
import static org.apache.bval.model.Features.Property.JAVASCRIPT_VALIDATION_FUNCTIONS;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

    private static final Logger logger = Logger.getLogger(XMLMetaBeanFactory.class.getName());
        logger.log(Level.SEVERE, String.format("Error loading %s", loader), e);
    public static Class<?> getClass(final ClassLoader classLoader, final String className) throws Exception {
        return run(new PrivilegedExceptionAction<Class<?>>() {
        //TODO #run
            PrivilegedActions.getClass(classLoader, PERSISTENCE_UTIL_CLASSNAME);
        return run(new PrivilegedAction<String>() {
import java.security.AccessController;
        if (!field.isAccessible()) {
            run(new PrivilegedAction<Void>() {
                public Void run() {
                    return null;

    private static <T> T run(PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }
import java.security.AccessController;
            run( new PrivilegedAction<Void>() {
                public Void run() {
                    return null;

    private static <T> T run(PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }
    // should not be called by just anyone; do not increase access
    private static <T> T run(PrivilegedAction<T> action) {
    // should not be called by just anyone; do not increase access
    private static <T> T run(final PrivilegedExceptionAction<T> action) throws PrivilegedActionException, Exception {
import java.security.AccessController;
            run(new PrivilegedAction<Object>() {

    private static <T> T run(PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }
        return run(new PrivilegedAction<F>() {

    private static <T> T run(PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }
import java.security.AccessController;
import java.security.PrivilegedAction;
        return run(SecureActions.doPrivBuildValidatorFactory(this));
    private static <T> T run(PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }
import java.security.AccessController;
                      run(new PrivilegedAction<Class<?>>() {

    private static <T> T run(PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }
import java.security.AccessController;
import java.security.PrivilegedAction;
        final Method[] methods = run(SecureActions.getDeclaredMethods(annotation.annotationType()));
    private static <T> T run(PrivilegedAction<T> action) {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged(action);
        } else {
            return action.run();
        }
    }
    protected void copyInto(FeaturesCapable target) {
    protected void copyInto(FeaturesCapable target) {
     * Check coherence on the overall object
}
                (ConstraintValidator<A, ? super T>) factoryContext.getConstraintValidatorFactory()
import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;
import javax.validation.Validation;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import javax.validation.bootstrap.ProviderSpecificBootstrap;
import javax.validation.spi.ConfigurationState;


                Validation.byProvider(ApacheValidationProvider.class).configure().buildValidatorFactory()
                    .unwrap(ApacheValidatorFactory.class);
        return ApacheValidatorConfiguration.class.equals(builderClass);
            if (validatorFactoryClassname == null) {
            } else {
                validatorFactoryClass =
                    ClassUtils.getClass(validatorFactoryClassname).asSubclass(ValidatorFactory.class);
            ? instantiateValidatorFactory(validatorFactoryClass, configuration) : AccessController
                .doPrivileged(new PrivilegedAction<ValidatorFactory>() {
                    public ValidatorFactory run() {
                        return instantiateValidatorFactory(validatorFactoryClass, configuration);
                    }
                });
        final Class<? extends ValidatorFactory> validatorFactoryClass, final ConfigurationState configuration) {
        try {
            return validatorFactoryClass.getConstructor(ConfigurationState.class).newInstance(configuration);
        } catch (final Exception ex) {
            throw new ValidationException("Cannot instantiate : "  validatorFactoryClass, ex);
        }
import org.apache.commons.lang3.ArrayUtils;
        return messageResolver;
        }

        // FIXME 2011-03-27 jw:
        // This code is unsecure.
        // It should allow only a fixed set of classes.
        // Can't fix this because don't know which classes this method should support.
        
        if (!(type.isInterface() || Modifier.isAbstract(type
        try {
            Class<?> cls = ClassUtils.getClass(type.getName()  "Impl");
            if (type.isAssignableFrom(cls)) {
                @SuppressWarnings("unchecked")
                T result = (T) newInstance(cls);
                return result;
            }
        } catch (ClassNotFoundException e) {
            // do nothing
        }
        throw new ValidationException("Type "  type  " not supported");
        List<MetaConstraint<?, ? extends Annotation>> slot;
        synchronized (constraintMap) {
            slot = constraintMap.get(beanClass);
            if (slot == null) {
                slot = new ArrayList<MetaConstraint<?, ? extends Annotation>>();
                constraintMap.put(beanClass, slot);
            }
        slot.add(metaConstraint);
        List<AccessStrategy> slot;
        synchronized (validAccesses) {
            slot = validAccesses.get(beanClass);
            if (slot == null) {
                slot = new ArrayList<AccessStrategy>();
                validAccesses.put(beanClass, slot);
            }
        slot.add(accessStrategy);
    public void addDefaultSequence(Class<?> beanClass, Class<?>... groupSequence) {
        defaultSequences.put(beanClass, safeArray(groupSequence));
        final List<MetaConstraint<?, ? extends Annotation>> slot = constraintMap.get(beanClass);
        if (slot == null) {
            return Collections.emptyList();
        // noinspection RedundantCast
        @SuppressWarnings({ "unchecked", "rawtypes" })
        final List<MetaConstraint<T, ? extends Annotation>> result = (List) slot;
        return Collections.unmodifiableList(result);
        final List<AccessStrategy> slot = validAccesses.get(beanClass);
        return slot == null ? Collections.<AccessStrategy> emptyList() : Collections.unmodifiableList(slot);
        return safeArray(defaultSequences.get(beanClass));
    private static Class<?>[] safeArray(Class<?>... array) {
        return ArrayUtils.isEmpty(array) ? ArrayUtils.EMPTY_CLASS_ARRAY : ArrayUtils.clone(array);
    }
            log.config("ignoreXmlConfiguration == true");
 * Description: annotation to validate as ABANumber<br/>
 * Description: annotation to validate as CUSIP<br/>
 * Description: annotation to validate as EAN13<br/>
 * Description: annotation to validate as IBAN<br/>
 * Description: annotation to validate as ISBN10<br/>
 * Description: annotation to validate as Luhn<br/>
 * Description: annotation to validate as Sedol<br/>
 * Description: annotation to validate as Verhoeff<br/>
        return getFeature(key, null);
        target.validations = ArrayUtils.clone(validations);
        if (this.validations == null) {
            this.validations = new Validation[] { validation };
        } else {
            Validation[] newValidations = new Validation[this.validations.length  1];
            System.arraycopy(this.validations, 0, newValidations, 0, this.validations.length);
            newValidations[validations.length] = validation;
            this.validations = newValidations;
        }
import java.util.Map;
import java.util.TreeMap;
    private static final long serialVersionUID = 2L;
    private Map<String, MetaProperty> properties = new TreeMap<String, MetaProperty>();
        return properties.values().toArray(new MetaProperty[this.properties.size()]);
        this.properties.clear();
        for (MetaProperty property : properties) {
            this.properties.put(property.getName(), property);
        }
        return this.properties.get(name);
        for (MetaProperty property : this.properties.values()) {
            if (property.isRelationship()) {
        return this.properties.size() > 0;
        if (property == null) {
            this.properties.remove(name);
        } else {        
            this.properties.put(name, property);
            copy.properties = new TreeMap<String, MetaProperty>();        
            for (Map.Entry<String, MetaProperty> entry : properties.entrySet()) {
                copy.properties.put(entry.getKey(), (MetaProperty) entry.getValue().copy());
            AccessStrategy[] newStrategies = new AccessStrategy[strategies.length  1];
            System.arraycopy(strategies, 0, newStrategies, 0, strategies.length);
            newStrategies[strategies.length] = access;
            prop.putFeature(Features.Property.REF_CASCADE, newStrategies);
        return getFeature(key, (T) null);
        boolean endOutMostReportAsSingle = (--compositeDepth == 0);
        if( endOutMostReportAsSingle ) {
            hasCompositeError = false;
        }
        return endOutMostReportAsSingle;
    @FrenchZipCode
    String zipCode2 = "123456";

    public void moveDown(String prop) {
        // no-op: not supported
    }

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Comparator;

    // TODO: optimize sortings

    private Map<String, MetaProperty> properties = new TreeMap<String, MetaProperty>(new Comparator<String>() { // order of fields to ensure correct failling order
        public int compare(final String o1, final String o2) {
            return fieldIndex(o1) - fieldIndex(o2);
        }

        private int fieldIndex(final String o2) {
            final Class<?> clazz = getBeanClass();

            int i = 0;
            Class<?> beanClass1 = clazz;
            while (beanClass1 != null && beanClass1 != Object.class) {
                for (final Field f : beanClass1.getDeclaredFields()) {
                    i;
                    if (f.getName().equals(o2)) {
                        return i;
                    }
                }
                beanClass1 = beanClass1.getSuperclass();
            }

            if (clazz != null) {
                final String getter = "get"  Character.toUpperCase(o2.charAt(0))  o2.substring(1);
                for (final Method m : clazz.getMethods()) {
                    i;
                    if (m.getName().equals(getter) && m.getParameterTypes().length == 0) {
                        return i;
                    }
                }
            }

            return Integer.MIN_VALUE; // to avoid collision and false positive in get() due to equals
        }
    });
    private Map<Method, MetaMethod> methods = new TreeMap<Method, MetaMethod>(new Comparator<Method>() {
        public int compare(final Method o1, final Method o2) {
            final int i = o1.getName().compareTo(o2.getName());
            if (i != 0) {
                return i;
            }
            return Arrays.hashCode(o1.getParameterTypes()) - Arrays.hashCode(o2.getParameterTypes());
        }
    });
    private Map<Constructor<?>, MetaConstructor> constructors = new TreeMap<Constructor<?>, MetaConstructor>(new Comparator<Constructor<?>>() {
        public int compare(final Constructor<?> o1, final Constructor<?> o2) {
            return Arrays.hashCode(o1.getParameterTypes()) - Arrays.hashCode(o2.getParameterTypes());
        }
    });
    public MetaMethod[] getMethods() {
        return methods.values().toArray(new MetaMethod[this.methods.size()]);
    }

    public void addMethod(final Method method, final MetaMethod meta) {
        methods.put(method, meta);
    }

    public MetaConstructor[] getConstructors() {
        return constructors.values().toArray(new MetaConstructor[this.constructors.size()]);
    }

    public void addConstructor(final Constructor<?> constructor, final MetaConstructor meta) {
        constructors.put(constructor, meta);
    }

    public MetaMethod getMethod(final Method method) {
        return methods.get(method);
    }

    public MetaConstructor getConstructor(final Constructor<?> constructor) {
        return constructors.get(constructor);
    }
import java.lang.reflect.Type;

public class MetaProperty extends Meta
    void moveDown(String prop);

import org.apache.bval.model.ValidationContext;

     * Error notification added from a {@link org.apache.bval.model.Validation} with context information
     * taken from the given {@link org.apache.bval.model.ValidationContext}.

import javax.validation.executable.ExecutableType;
import java.util.Collections;

        configuration.setExecutableValidation(Collections.<ExecutableType>singleton(ExecutableType.ALL));
    public void releaseInstance(ConstraintValidator<?, ?> instance) {
        // no-op
    }

import javax.validation.executable.ExecutableValidator;
        ExecutableValidator methodValidator = validator.forExecutables();
        constraintViolations.addAll(methodValidator.validateParameters(invocation.getThis(),
            constraintViolations.addAll(methodValidator.validateReturnValue(invocation.getThis(), method, returnedValue, groups));
 b/bval-jsr303/src/main/java/org/apache/bval/constraints/SizeValidatorForCharSequence.java
public class SizeValidatorForCharSequence extends SizeValidator
      implements ConstraintValidator<Size, CharSequence> {
    public boolean isValid(CharSequence s, ConstraintValidatorContext context) {
import org.apache.bval.jsr303.groups.GroupsComputer;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.jsr303.xml.AnnotationProxyBuilder;
import org.apache.bval.util.AccessStrategy;

import javax.annotation.processing.SupportedAnnotationTypes;
import javax.validation.Constraint;
import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintDefinitionException;
import javax.validation.ConstraintTarget;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import javax.validation.OverridesAttribute;
import javax.validation.Payload;
import javax.validation.ReportAsSingleViolation;
import javax.validation.constraintvalidation.SupportedValidationTarget;
import javax.validation.constraintvalidation.ValidationTarget;
        ConstraintValidator<A, ?> constraintValidator, A annotation, Class<?> owner, AccessStrategy access,
        ConstraintTarget target, RuntimeException missingValidatorException) {
                reportFromComposite, target, missingValidatorException);
                                final String name = method.getName();
                                if (ConstraintAnnotationAttributes.PAYLOAD.getAttributeName().equals(name)) {
                                } else if (ConstraintAnnotationAttributes.GROUPS.getAttributeName().equals(name)) {
                                } else if (ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getAttributeName().equals(name)) {
                                    buildValidationAppliesTo(method);
                                } else if (name.startsWith("valid")) {
                                    throw new ConstraintDefinitionException("constraints parameters can't start with valid: "  name);
                                    constraintValidation.getAttributes().put(name, method.invoke(constraintValidation.getAnnotation()));
                            } catch (final ConstraintDefinitionException cde) {
                                throw cde;
                            } catch (final Exception e) { // do nothing

                    // valid validationAppliesTo
                    final Constraint annotation = constraintValidation.getAnnotation().annotationType().getAnnotation(Constraint.class);
                    if (annotation == null) {
                        return null;
                    }

                    final Pair validationTarget = computeValidationTarget(annotation.validatedBy());
                    for (final Annotation a : constraintValidation.getAnnotation().annotationType().getAnnotations()) {
                        final Constraint inheritedConstraint = a.annotationType().getAnnotation(Constraint.class);
                        if (inheritedConstraint != null && !a.annotationType().getName().startsWith("javax.validation.constraints.")) {
                            final Pair validationTargetInherited = computeValidationTarget(inheritedConstraint.validatedBy());
                            if ((validationTarget.a > 0 && validationTargetInherited.b > 0 && validationTarget.b == 0)
                                    || (validationTarget.b > 0 && validationTargetInherited.a > 0 && validationTarget.a == 0)) {
                                throw new ConstraintDefinitionException("Parent and child constraint have different targets");
                            }
                        }
                    }

    private Pair computeValidationTarget(final Class<?>[] validators) {
        int param = 0;
        int annotatedElt = 0;

        for (final Class<?> validator : validators) {
            final SupportedValidationTarget supportedAnnotationTypes = validator.getAnnotation(SupportedValidationTarget.class);
            if (supportedAnnotationTypes != null) {
                final List<ValidationTarget> values = Arrays.asList(supportedAnnotationTypes.value());
                if (values.contains(ValidationTarget.PARAMETERS)) {
                    param;
                }
                if (values.contains(ValidationTarget.ANNOTATED_ELEMENT)) {
                    annotatedElt;
                }
            } else {
                annotatedElt;
            }
        }

        if (annotatedElt == 0 && param >= 1 && constraintValidation.getValidationAppliesTo() != null) { // pure cross param
            throw new ConstraintDefinitionException("pure cross parameter constraints shouldn't get validationAppliesTo attribute");
        } else {
            if (param >= 1 && annotatedElt >= 1 && constraintValidation.getValidationAppliesTo() == null) { // generic and cross param
                throw new ConstraintDefinitionException("cross parameter AND generic constraints should get validationAppliesTo attribute");
            } else if (param == 0 && constraintValidation.getValidationAppliesTo() != null) { // pure generic
                throw new ConstraintDefinitionException("pure generic constraints shouldn't get validationAppliesTo attribute");
            }
        }

        return new Pair(annotatedElt, param);
    }

    private void buildValidationAppliesTo(final Method method) throws InvocationTargetException, IllegalAccessException {
        final Object validationAppliesTo = method.invoke(constraintValidation.getAnnotation());
        if (ConstraintTarget.class.isInstance(validationAppliesTo)) {
            constraintValidation.setValidationAppliesTo(ConstraintTarget.class.cast(validationAppliesTo));
        } else {
            throw new ConstraintDefinitionException("validationAppliesTo type is "  ConstraintTarget.class.getName());
        }
    }


        if (constraintValidation.getValidationAppliesTo() != null) {
            composite.setValidationAppliesTo(constraintValidation.getValidationAppliesTo());
        }


    private static class Pair {
        private int a;
        private int b;

        private Pair(int a, int b) {
            this.a = a;
            this.b = b;
        }
    }
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.GroupConversionDescriptorImpl;
import org.apache.bval.jsr303.util.ConstraintDefinitionValidator;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.model.Features;
import org.apache.bval.model.Meta;
import org.apache.bval.model.MetaBean;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.PropertyAccess;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.reflect.TypeUtils;

import javax.validation.Constraint;
import javax.validation.ConstraintDefinitionException;
import javax.validation.ConstraintValidator;
import javax.validation.UnexpectedTypeException;
import javax.validation.Valid;
import javax.validation.ValidationException;
import javax.validation.constraintvalidation.SupportedValidationTarget;
import javax.validation.constraintvalidation.ValidationTarget;
import javax.validation.groups.ConvertGroup;
import javax.validation.groups.Default;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
    public boolean processAnnotations(Meta prop, Class<?> owner, AnnotatedElement element,
            changed |= processAnnotation(annotation, prop, owner, access, appender, true);
        return processAnnotation(annotation, null, owner, null, appender, true);
    public <A extends Annotation> boolean processAnnotation(A annotation, Meta prop, Class<?> owner,
        AccessStrategy access, AppendValidation appender, boolean reflection) throws IllegalAccessException, InvocationTargetException {

        if (ConvertGroup.class.isInstance(annotation) || ConvertGroup.List.class.isInstance(annotation)) {
            if (!reflection) {
                Collection<Annotation> annotations = prop.getFeature(Jsr303Features.Property.ANNOTATIONS_TO_PROCESS);
                if (annotations == null) {
                    annotations = new ArrayList<Annotation>();
                    prop.putFeature(Jsr303Features.Property.ANNOTATIONS_TO_PROCESS, annotations);
                }
                annotations.add(annotation);
            }
            return true;
        }

        final Object result = SecureActions.getAnnotationValue(annotation, ConstraintAnnotationAttributes.VALUE.getAttributeName());
            for (final Annotation each : (Annotation[]) result) {
                changed |= processAnnotation(each, prop, owner, access, appender, reflection);
    public boolean addAccessStrategy(Meta prop, AccessStrategy access) {
     * @param rawConstraintClasses
        Class<? extends ConstraintValidator<A, ?>>[] rawConstraintClasses, Meta prop, Class<?> owner,
        final Class<? extends ConstraintValidator<A, ?>>[] constraintClasses = select(rawConstraintClasses, access);
        if (constraintClasses != null && constraintClasses.length == 0 && rawConstraintClasses.length > 0) {
            return false;
        }

        RuntimeException missingValidatorException = null;
        ConstraintValidator<A, ?> validator = null;
        try {
            validator = getConstraintValidator(annotation, constraintClasses, owner, access);
        } catch (final RuntimeException e) {
            missingValidatorException = e;
        }
            new AnnotationConstraintBuilder<A>(constraintClasses, validator, annotation, owner, access, null, missingValidatorException);
    private static <A extends Annotation> Class<? extends ConstraintValidator<A, ?>>[] select(
            final Class<? extends ConstraintValidator<A, ?>>[] rawConstraintClasses, final AccessStrategy access) {
        final boolean isReturn = ReturnAccess.class.isInstance(access);
        final boolean isParam = ParametersAccess.class.isInstance(access);
        if (rawConstraintClasses != null && (isReturn || isParam)) {
            final Collection<Class<? extends ConstraintValidator<A, ?>>> selected = new ArrayList<Class<? extends ConstraintValidator<A, ?>>>();
            for (final Class<? extends ConstraintValidator<A, ?>> constraint : rawConstraintClasses) {
                final SupportedValidationTarget target = constraint.getAnnotation(SupportedValidationTarget.class);
                if (target == null && isReturn) {
                    selected.add(constraint);
                } else if (target != null) {
                    for (final ValidationTarget validationTarget : target.value()) {
                        if (isReturn && ValidationTarget.ANNOTATED_ELEMENT.equals(validationTarget)) {
                            selected.add(constraint);
                        } else if (isParam && ValidationTarget.PARAMETERS.equals(validationTarget)) {
                            selected.add(constraint);
                        }
                    }
            }
            }
            return selected.toArray(new Class[selected.size()]);
        }
        return rawConstraintClasses;
    }


            final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validatorTypes = getValidatorsTypes(constraintClasses);
            reduceTarget(validatorTypes, access);

            if ((type == Object.class || type == Object[].class) && validatorTypes.containsKey(Object.class) && validatorTypes.containsKey(Object[].class)) {
                throw new ConstraintDefinitionException("Only a validator for Object or Object[] should be provided for cross parameter validators");
            }

            final Collection<Class<? extends ConstraintValidator<A, ?>>> key = validatorTypes.get(assignableTypes.get(0));
            if (key.size() > 1) {
                final String message = "Factory returned "  key.size()  " validators";
                if (ParametersAccess.class.isInstance(access)) { // cross parameter
                    throw new ConstraintDefinitionException(message);
                }
                throw new UnexpectedTypeException(message);
            }

            final ConstraintValidator<A, ? super T> validator = (ConstraintValidator<A, ? super T>) factoryContext.getConstraintValidatorFactory().getInstance(key.iterator().next());
                throw new ValidationException("Factory returned null validator for: "  key);
    private <A extends Annotation> void reduceTarget(final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validator, final AccessStrategy access) {
        for (final Map.Entry<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> entry : validator.entrySet()) {
            final Collection<Class<? extends ConstraintValidator<A, ?>>> validators = entry.getValue();
            final Iterator<Class<? extends ConstraintValidator<A, ?>>> it = validators.iterator();
            while (it.hasNext()) {
                final Type v = it.next();
                if (!Class.class.isInstance(v)) {
                    continue; // TODO: handle this case
                }

                final Class<?> clazz = Class.class.cast(v);
                final SupportedValidationTarget target = clazz.getAnnotation(SupportedValidationTarget.class);
                if (target != null) {
                    final Collection<ValidationTarget> targets = Arrays.asList(target.value());
                    final boolean isParameter = ParameterAccess.class.isInstance(access) || ParametersAccess.class.isInstance(access);
                    if ((isParameter && !targets.contains(ValidationTarget.PARAMETERS))
                            || (!isParameter && !targets.contains(ValidationTarget.ANNOTATED_ELEMENT))) {
                        it.remove();
                    }
                }
            }
            if (validators.isEmpty()) {
                validator.remove(entry.getKey());
            }
        }
    }

            final String message = "No validator could be found for type "  stringForType(targetType)
                     ". See: @"  anno.annotationType().getSimpleName()  " at "  stringForLocation(owner, access);
            if (Object[].class.equals(targetType)) { // cross parameter
                throw new ConstraintDefinitionException(message);
            }
            throw new UnexpectedTypeException(message);
        for (final Type validatorType : validatorsTypes) {
    private static <A extends Annotation> Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> getValidatorsTypes(
        final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validatorsTypes = new HashMap<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>>();
            Type validatedType = TypeUtils.getTypeArguments(validatorType, ConstraintValidator.class).get(ConstraintValidator.class.getTypeParameters()[1]);
            if (!validatorsTypes.containsKey(validatedType)) {
                validatorsTypes.put(validatedType, new ArrayList<Class<? extends ConstraintValidator<A, ?>>>());
            }
            validatorsTypes.get(validatedType).add(validatorType);
import javax.validation.ParameterNameProvider;
    private ParameterNameProvider parameterNameProvider;
    public ValidatorContext parameterNameProvider(ParameterNameProvider parameterNameProvider) {
        this.parameterNameProvider = parameterNameProvider;
        return this;
    }

    public ParameterNameProvider getParameterNameProvider() {
        return parameterNameProvider == null ? factory.getParameterNameProvider() : parameterNameProvider;
    }


        String EXECUTABLE_VALIDATION_TYPES = "apache.bval.executable-validation.types";
import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.ParameterNameProvider;
import javax.validation.TraversableResolver;
import javax.validation.Validation;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import javax.validation.executable.ExecutableType;
import javax.validation.spi.ConfigurationState;
import java.io.Closeable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;

    private static final ConstraintDefaults defaultConstraints = new ConstraintDefaults();
    private ParameterNameProvider parameterNameProvider;
    private final Collection<ExecutableType> executableTypes = new CopyOnWriteArrayList<ExecutableType>();
    private final Collection<Closeable> toClose = new ArrayList<Closeable>();

            DEFAULT_FACTORY = Validation.byProvider(ApacheValidationProvider.class).configure()
                    .buildValidatorFactory().unwrap(ApacheValidatorFactory.class);
        constraintMap = new HashMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>>();
        setParameterNameProvider(configuration.getParameterNameProvider());
        setConstraintValidatorFactory(configuration.getConstraintValidatorFactory());

        if (ConfigurationImpl.class.isInstance(configuration)) {
            final ConfigurationImpl impl = ConfigurationImpl.class.cast(configuration);
            executableTypes.addAll(impl.getExecutableValidation());
            toClose.add(impl.getClosable());
        } else {
            final String executableTypesStr = getProperties().get(ApacheValidatorConfiguration.Properties.EXECUTABLE_VALIDATION_TYPES);
            if (executableTypesStr != null && !executableTypesStr.isEmpty()) {
                for (final String s : executableTypesStr.split(",")) {
                    executableTypes.add(ExecutableType.valueOf(s.trim()));
                }
            }
        }

        new ValidationMappingParser(this).processMappingConfig(configuration.getMappingStreams());
        if (messageResolver != null) {
            this.messageResolver = messageResolver;
        }
        if (traversableResolver != null) {
            this.traversableResolver = traversableResolver;
        }
    }

    public void setParameterNameProvider(final ParameterNameProvider parameterNameProvider) {
        if (parameterNameProvider != null) {
            this.parameterNameProvider = parameterNameProvider;
        }
        if (constraintValidatorFactory != null) {
            this.constraintValidatorFactory = constraintValidatorFactory;
            if (DefaultConstraintValidatorFactory.class.isInstance(constraintValidatorFactory)) {
                toClose.add(Closeable.class.cast(constraintValidatorFactory));
            }
        }
    public ParameterNameProvider getParameterNameProvider() {
        return parameterNameProvider;
    }

    public void close() {
        try {
            for (final Closeable c : toClose) {
                c.close();
            }
            toClose.clear();
        } catch (final Exception e) {
            // no-op
        }
    }

            return (T) this;
    public void addMetaConstraint(final Class<?> beanClass,
                                  final MetaConstraint<?, ?> metaConstraint) {
    public Collection<ExecutableType> getExecutableTypes() {
        return executableTypes;
    }

 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/AppendValidationToList.java
package org.apache.bval.jsr303;
 * Description: {@link org.apache.bval.jsr303.AppendValidation} implementation that acts as an intermediate
     * @return {@link java.util.List} of {@link org.apache.bval.jsr303.ConstraintValidation}
import org.apache.bval.Validate;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.GroupConversionDescriptorImpl;
import org.apache.bval.jsr303.util.ClassHelper;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.model.MetaConstructor;
import org.apache.bval.model.MetaMethod;
import org.apache.bval.model.MetaParameter;
import org.apache.bval.model.Validation;
import org.apache.bval.util.AccessStrategy;
import org.apache.commons.lang3.ClassUtils;
import javax.validation.Constraint;
import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintTarget;
import javax.validation.Valid;
import javax.validation.groups.ConvertGroup;
import javax.validation.metadata.ConstructorDescriptor;
import javax.validation.metadata.ExecutableDescriptor;
import javax.validation.metadata.GroupConversionDescriptor;
import javax.validation.metadata.MethodDescriptor;
import javax.validation.metadata.MethodType;
import javax.validation.metadata.ParameterDescriptor;
import javax.validation.metadata.ReturnValueDescriptor;
import java.beans.Introspector;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArraySet;
    private static final CopyOnWriteArraySet<ConstraintValidation<?>> NO_CONSTRAINTS = new CopyOnWriteArraySet<ConstraintValidation<?>>();
    private final AnnotationProcessor annotationProcessor;
    private Set<ConstructorDescriptor> constrainedConstructors = new CopyOnWriteArraySet<ConstructorDescriptor>();
    private Map<Method, MethodDescriptor> methodConstraints = new HashMap<Method, MethodDescriptor>();
    private Set<MethodDescriptor> containedMethods = new CopyOnWriteArraySet<MethodDescriptor>();
    private Map<Constructor<?>, ConstructorDescriptor> contructorConstraints = new HashMap<Constructor<?>, ConstructorDescriptor>();
        this.annotationProcessor = new AnnotationProcessor(factoryContext);

        buildExecutableDescriptors();
    }

    private static void addGroupConvertion(final MetaProperty prop, final PropertyDescriptorImpl edesc) {
        boolean fieldFound = false;
        boolean methodFound = false;
        Class<?> current = prop.getParentMetaBean().getBeanClass();
        while (current != null && current != Object.class && (!methodFound || !fieldFound)) {
            if (!fieldFound) {
                final Field field = SecureActions.getDeclaredField(current, prop.getName()).run();
                if (field != null) {
                    final ConvertGroup.List convertGroupList = field.getAnnotation(ConvertGroup.List.class);
                    if (convertGroupList != null) {
                        for (final ConvertGroup convertGroup : convertGroupList.value()) {
                            edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
                        }
                    }

                    final ConvertGroup convertGroup = field.getAnnotation(ConvertGroup.class);
                    if (convertGroup != null) {
                        edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
                    }
                    fieldFound = true;
                }
            }

            if (!methodFound) {
                final String name = Character.toUpperCase(prop.getName().charAt(0))  prop.getName().substring(1);
                for (final Method method : Arrays.asList(
                        SecureActions.getDeclaredMethod(current, "is"  name).run(),
                        SecureActions.getDeclaredMethod(current, "get"  name).run())) {

                    if (method != null) {
                        final ConvertGroup.List convertGroupList = method.getAnnotation(ConvertGroup.List.class);
                        if (convertGroupList != null) {
                            for (final ConvertGroup convertGroup : convertGroupList.value()) {
                                edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
                            }
                        }

                        final ConvertGroup convertGroup = method.getAnnotation(ConvertGroup.class);
                        if (convertGroup != null) {
                            edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
                        }

                        methodFound = true;
                        break;
                    }
                }
            }

            current = current.getSuperclass();
        }

        final Collection<Annotation> annotations = prop.getFeature(Jsr303Features.Property.ANNOTATIONS_TO_PROCESS);
        if (annotations != null) {
            for (final Annotation a : annotations) {
                if (ConvertGroup.List.class.isInstance(a)) {
                    for (final ConvertGroup convertGroup : ConvertGroup.List.class.cast(a).value()) {
                        edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
                    }
                }

                if (ConvertGroup.class.isInstance(a)) {
                    final ConvertGroup convertGroup = ConvertGroup.class.cast(a);
                    edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
                }
            }
            annotations.clear();
        }

        if (!edesc.getGroupConversions().isEmpty() && !edesc.isCascaded()) {
            throw new ConstraintDeclarationException("@Valid is needed for group conversion");
        }
     *
     *
     * @param propertyName property evaluated
            addGroupConvertion(prop, edesc);
     *
                    || (prop.getMetaBean() != null || prop.getFeature(Features.Property.REF_CASCADE) != null)) {
    public MethodDescriptor getConstraintsForMethod(String methodName, Class<?>... parameterTypes) {
        if (methodName == null) {
            throw new IllegalArgumentException("Method name can't be null");
        }

        Class<?> beanClass = metaBean.getBeanClass();
        Method method = null;
        do {
            try {
                method = beanClass.getDeclaredMethod(methodName, parameterTypes);
                break;
            } catch (final NoSuchMethodException e) {
                // no-op
            }
            beanClass = beanClass.getSuperclass();
        } while (beanClass != Object.class && beanClass != null);
        if (method == null) {
            return null;
        }

        final MethodDescriptor descriptor = methodConstraints.get(method);
        if (descriptor != null) {
            final boolean hasConstraint = descriptor.hasConstrainedParameters() || descriptor.hasConstrainedReturnValue();
            if (!hasConstraint) {
                return null;
            }
            return descriptor;
        }

        // TODO: surely remove it
        for (final MetaMethod metaMethod : metaBean.getMethods()) {
            if (metaMethod.getMethod().equals(method)) {
                final MethodDescriptorImpl methodDescriptor = createMethodDescriptor(metaMethod);
                ensureNotNullDescriptors(metaMethod.getMethod().getReturnType(), methodDescriptor);
                methodConstraints.put(method, methodDescriptor);
                containedMethods.add(methodDescriptor);
                return methodDescriptor;
            }
        }

        return null;
    }

    private MethodDescriptorImpl createMethodDescriptor(final MetaMethod metaMethod) {
        MethodDescriptorImpl edesc = metaMethod.getFeature(Jsr303Features.Method.MethodDescriptor);
        if (edesc == null) {
            edesc = new MethodDescriptorImpl(metaBean, metaMethod);
            metaMethod.putFeature(Jsr303Features.Method.MethodDescriptor, edesc);
        }
        return edesc;
    }

    public Set<MethodDescriptor> getConstrainedMethods(MethodType methodType, MethodType... methodTypes) {
        final Set<MethodDescriptor> desc = new HashSet<MethodDescriptor>();
        desc.addAll(filter(containedMethods, methodType));
        if (methodTypes != null) {
            for (final MethodType type : methodTypes) {
                desc.addAll(filter(containedMethods, type));
            }
        }
        return desc;
    }

    private static Collection<MethodDescriptor> filter(final Set<MethodDescriptor> containedMethods, final MethodType type) {
        final Collection<MethodDescriptor> list = new ArrayList<MethodDescriptor>();
        for (final MethodDescriptor d : containedMethods) {
            final boolean getter = d.getName().startsWith("get") && d.getParameterDescriptors().isEmpty();

            switch (type) {
                case GETTER:
                    if (getter) {
                        list.add(d);
                    }
                break;

                case NON_GETTER:
                    if (!getter) {
                        list.add(d);
                    }
            }
        }
        return list;
    }

    public ConstructorDescriptor getConstraintsForConstructor(Class<?>... parameterTypes) {
        final Constructor<?> declaredConstructor;
        try {
            declaredConstructor = metaBean.getBeanClass().getDeclaredConstructor(parameterTypes);
        } catch (final NoSuchMethodException e) {
            return null;
        }

        final ConstructorDescriptor descriptor = contructorConstraints.get(declaredConstructor);
        if (descriptor != null && (descriptor.hasConstrainedParameters() || descriptor.hasConstrainedReturnValue())) {
            return descriptor;
        }

        return null;
    }

    public Set<ConstructorDescriptor> getConstrainedConstructors() {
        return constrainedConstructors;
    }


    public void buildExecutableDescriptors() {
        try {
            buildMethodConstraints();
            setConstrained(containedMethods, methodConstraints.values());

            buildConstructorConstraints();
            setConstrained(constrainedConstructors, contructorConstraints.values());
        } catch (final Exception ex) {
            if (RuntimeException.class.isInstance(ex)) {
                throw RuntimeException.class.cast(ex);
            }

            throw new IllegalArgumentException(ex.getMessage(), ex);
        }
    }

    private <A extends ExecutableDescriptor> void setConstrained(final Set<A> dest, final Collection<A> src) {
        for (final A d : src) {
            if (d.hasConstrainedParameters() || d.hasConstrainedReturnValue()) {
                dest.add(d);
            }
        }
    }

    private void buildConstructorConstraints() throws InvocationTargetException, IllegalAccessException {
        for (final Constructor<?> cons : SecureActions.getDeclaredConstructors(getMetaBean().getBeanClass()).run()) {
            final ConstructorDescriptorImpl consDesc = new ConstructorDescriptorImpl(getMetaBean(), new Validation[0]);
            contructorConstraints.put(cons, consDesc);

            final List<String> names = factoryContext.getParameterNameProvider().getParameterNames(cons);
            final boolean isInnerClass = cons.getDeclaringClass().getEnclosingClass() != null && !Modifier.isStatic(cons.getDeclaringClass().getModifiers());

            {
                final Annotation[][] paramsAnnos = cons.getParameterAnnotations();

                int idx = 0;
                if (isInnerClass) { // paramsAnnos.length = parameterTypes.length - 1 in this case
                    final ParameterDescriptorImpl paramDesc = new ParameterDescriptorImpl(getMetaBean(), new Validation[0], names.get(idx));
                    consDesc.getParameterDescriptors().add(paramDesc);
                    idx;
                }

                for (final Annotation[] paramAnnos : paramsAnnos) {
                    if (factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnParameter(cons, idx)) {
                        consDesc.getParameterDescriptors().add(new ParameterDescriptorImpl(metaBean, new Validation[0], names.get(idx)));
                    } else if (cons.getParameterTypes().length > idx) {
                        ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
                        consDesc.addValidations(processAnnotations(consDesc, paramAnnos, access, idx, names.get(idx)).getValidations());
                    } // else anonymous class so that's fine
                    idx;
                }

                if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(cons)) {
                    for (final Annotation anno : cons.getAnnotations()) {
                        if (!Valid.class.isInstance(anno)) {
                            processAnnotations(null, consDesc, cons.getDeclaringClass(), anno);
                        } else {
                            consDesc.setCascaded(true);
                        }
                    }
                }
            }

            if (factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnCrossParameter(cons) && consDesc.getCrossParameterDescriptor() != null) {
                consDesc.setCrossParameterDescriptor(null);
            }
            if (factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnReturn(cons) && consDesc.getReturnValueDescriptor() != null) {
                consDesc.setReturnValueDescriptor(null);
            }

            final MetaConstructor metaConstructor = metaBean.getConstructor(cons);
            if (metaConstructor != null) {
                for (final Annotation anno : metaConstructor.getAnnotations()) {
                    if (!Valid.class.isInstance(anno)) {
                        processAnnotations(null, consDesc, cons.getDeclaringClass(), anno);
                    } else {
                        consDesc.setCascaded(true);
                    }
                }

                // parameter validations
                final Collection<MetaParameter> paramsAnnos = metaConstructor.getParameters();
                for (final MetaParameter paramAnnos : paramsAnnos) {
                    final int idx = paramAnnos.getIndex();
                    final ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
                    processAnnotations(consDesc, paramAnnos.getAnnotations(), access, idx, names.get(idx));
                }
            }

            if (!consDesc.getGroupConversions().isEmpty() && !consDesc.isCascaded()) {
                throw new ConstraintDeclarationException("@Valid is needed to define a group conversion");
            }

            ensureNotNullDescriptors(cons.getDeclaringClass(), consDesc);
        }
    }

    private void ensureNotNullDescriptors(final Class<?> returnType, final InvocableElementDescriptor consDesc) {
        // can't be null
        if (consDesc.getCrossParameterDescriptor() == null) {
            consDesc.setCrossParameterDescriptor(new CrossParameterDescriptorImpl(getMetaBean(), NO_CONSTRAINTS));
        }
        if (consDesc.getReturnValueDescriptor() == null) {
            consDesc.setReturnValueDescriptor(new ReturnValueDescriptorImpl(getMetaBean(), returnType, NO_CONSTRAINTS, consDesc.isCascaded()));
        }
        // enforce it since ReturnValueDescriptor can be created before cascaded is set to true
        final ReturnValueDescriptorImpl returnValueDescriptor = ReturnValueDescriptorImpl.class.cast(consDesc.getReturnValueDescriptor());
        returnValueDescriptor.setCascaded(consDesc.isCascaded());
        if (returnValueDescriptor.getGroupConversions().isEmpty()) {
            // loop to not forget to map calling addGroupConversion()
            for (final GroupConversionDescriptor c : consDesc.getGroupConversions()) {
                returnValueDescriptor.addGroupConversion(c);
            }
        }

    }

    private void processAnnotations(final Method mtd, final InvocableElementDescriptor consDesc, final Class<?> clazz, final Annotation anno) throws InvocationTargetException, IllegalAccessException {
        if (mtd == null || !factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnReturn(mtd)) {
            final ReturnAccess returnAccess = new ReturnAccess(clazz);
            final AppendValidationToList validations = new AppendValidationToList();
            processAnnotation(anno, consDesc, returnAccess, validations);
            final List<ConstraintValidation<?>> list = removeFromListValidationAppliesTo(validations.getValidations(), ConstraintTarget.PARAMETERS);
            consDesc.addValidations(list);

            ReturnValueDescriptorImpl returnValueDescriptor = ReturnValueDescriptorImpl.class.cast(consDesc.getReturnValueDescriptor());
            if (consDesc.getReturnValueDescriptor() != null) {
                returnValueDescriptor.getMutableConstraintDescriptors().addAll(list);
            } else {
                returnValueDescriptor = new ReturnValueDescriptorImpl(getMetaBean(), clazz, list, consDesc.isCascaded());
                consDesc.setReturnValueDescriptor(returnValueDescriptor);
            }
        }

        if (mtd == null || !factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnCrossParameter(mtd)) {
            final ParametersAccess parametersAccess = new ParametersAccess();
            final AppendValidationToList validations = new AppendValidationToList();
            processAnnotation(anno, consDesc, parametersAccess, validations);
            final List<ConstraintValidation<?>> list = removeFromListValidationAppliesTo(validations.getValidations(), ConstraintTarget.RETURN_VALUE);
            consDesc.addValidations(list);
            if (consDesc.getCrossParameterDescriptor() != null) {
                CrossParameterDescriptorImpl.class.cast(consDesc.getCrossParameterDescriptor()).getMutableConstraintDescriptors().addAll(list);
            } else {
                consDesc.setCrossParameterDescriptor(new CrossParameterDescriptorImpl(getMetaBean(), list));
            }
        }
    }

    private static List<ConstraintValidation<?>> removeFromListValidationAppliesTo(final List<ConstraintValidation<?>> validations, final ConstraintTarget constraint) {
        final Iterator<ConstraintValidation<?>> i = validations.iterator();
        while (i.hasNext()) {
            if (constraint.equals(i.next().getValidationAppliesTo())) {
                i.remove();
            }
        }
        return validations;
    }

    private void buildMethodConstraints() throws InvocationTargetException, IllegalAccessException {

        Class<?> current = getMetaBean().getBeanClass();
        do {
            for (final Method method : current.getDeclaredMethods()) {
                final boolean getter = method.getName().startsWith("get") && method.getParameterTypes().length == 0;

                final MethodDescriptorImpl methodDesc = new MethodDescriptorImpl(getMetaBean(), new Validation[0], method);
                methodConstraints.put(method, methodDesc);

                final List<Class<?>> classHierarchy = new ArrayList<Class<?>>();
                ClassHelper.fillFullClassHierarchyAsList(classHierarchy, current);
                classHierarchy.remove(current);

                final Collection<Method> parents = new ArrayList<Method>();
                for (final Class<?> clazz : classHierarchy) {
                    final Method overriden = SecureActions.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes()).run();
                    if (overriden != null) {
                        processMethod(overriden, methodDesc);
                        parents.add(overriden);
                    }
                }

                processMethod(method, methodDesc);

                ensureNotNullDescriptors(method.getReturnType(), methodDesc);

                // validations, TODO: if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(method)) {
                if (parents != null) {
                    if (parents.size() > 1) {
                        for (final Method parent : parents) {
                            final InvocableElementDescriptor elementDescriptor = InvocableElementDescriptor.class.cast(factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes()));
                            if (elementDescriptor != null) {
                                ensureNoParameterConstraint(elementDescriptor, "Parameter constraints can't be defined for parallel interfaces/parents");
                            } else {
                                ensureMethodDoesntDefineParameterConstraint(methodDesc);
                            }
                            ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parent, "Return value constraints should be the same for parent and children");
                        }
                    } else if (!parents.isEmpty()) {
                        final Method parent = parents.iterator().next();
                        ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parent, "Return value constraints should be at least the same for parent and children");

                        final MethodDescriptor parentDesc = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
                        if (parentDesc != null) {
                            final Iterator<ParameterDescriptor> parentPd = parentDesc.getParameterDescriptors().iterator();
                            for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
                                final ParameterDescriptor next = parentPd.next();
                                if (pd.getConstraintDescriptors().size() != next.getConstraintDescriptors().size()) {
                                    throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
                                }
                                if (pd.isCascaded() != next.isCascaded()) { // @Valid
                                    throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
                                }
                            }
                        } else {
                            ensureMethodDoesntDefineParameterConstraint(methodDesc);
                        }
                    }

                    final Class<?>[] interfaces = method.getDeclaringClass().getInterfaces();
                    final Collection<Method> itfWithThisMethod = new ArrayList<Method>();
                    for (final Class<?> i : interfaces) {
                        final Method m = SecureActions.getDeclaredMethod(i, method.getName(), method.getParameterTypes()).run();
                        if (m != null) {
                            itfWithThisMethod.add(m);
                        }
                    }
                    if (itfWithThisMethod.size() > 1) {
                        for (final Method m : itfWithThisMethod) {
                            ensureNoConvertGroup(m, "ConvertGroup can't be used in parallel interfaces");
                        }
                    } else if (itfWithThisMethod.size() == 1) {
                        ensureNoConvertGroup(itfWithThisMethod.iterator().next(), "ConvertGroup can't be used in interface AND parent class");
                    }

                    int returnValid = 0;
                    if (method.getAnnotation(Valid.class) != null) {
                        returnValid;
                    }
                    for (final Class<?> clazz : classHierarchy) {
                        final Method overriden = SecureActions.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes()).run();
                        if (overriden != null) {
                            if (overriden.getAnnotation(Valid.class) != null) {
                                returnValid;
                            }
                        }
                    }
                    if (returnValid > 1 && !(interfaces.length == returnValid && method.getAnnotation(Valid.class) == null)) {
                        throw new ConstraintDeclarationException("@Valid on returned value can't be set more than once");
                    }
                }

                if (getter) {
                    final MetaProperty prop = metaBean.getProperty(Introspector.decapitalize(method.getName().substring(3)));
                    if (prop != null && prop.getFeature(Features.Property.REF_CASCADE) != null) {
                        methodDesc.setCascaded(true);
                    }
                }

                if (!methodDesc.getGroupConversions().isEmpty() && !methodDesc.isCascaded()) {
                    throw new ConstraintDeclarationException("@Valid is needed to define a group conversion");
                }
            }
            current = current.getSuperclass();
        } while (current != null && current != Object.class);
    }

    private void ensureMethodDoesntDefineParameterConstraint(MethodDescriptorImpl methodDesc) {
        for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
            if (!pd.getConstraintDescriptors().isEmpty()) {
                throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
            }
            if (pd.isCascaded()) { // @Valid
                throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
            }
        }
    }

    private void ensureNoReturnValueAddedInChild(final ReturnValueDescriptor returnValueDescriptor, final Method parent, final String msg) {
        final MethodDescriptor parentDesc = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
        if (parentDesc == null) {
            return;
        }

        final ReturnValueDescriptor parentReturnDesc = parentDesc.getReturnValueDescriptor();
        if (parentReturnDesc.isCascaded() && !returnValueDescriptor.isCascaded() || parentReturnDesc.getConstraintDescriptors().size() > returnValueDescriptor.getConstraintDescriptors().size()) {
            throw new ConstraintDeclarationException(msg);
        }
    }

    private static void ensureNoParameterConstraint(final InvocableElementDescriptor constraintsForMethod, final String msg) {
        for (final ParameterDescriptor parameterDescriptor : constraintsForMethod.getParameterDescriptors()) {
            if (!parameterDescriptor.getConstraintDescriptors().isEmpty() || parameterDescriptor.isCascaded()) {
                throw new ConstraintDeclarationException(msg);
            }
        }
    }

    private static void ensureNoConvertGroup(final Method method, final String msg) {
        for (final Annotation[] annotations : method.getParameterAnnotations()) {
            for (final Annotation a : annotations) {
                if (ConvertGroup.class.isInstance(a)) {
                    throw new ConstraintDeclarationException(msg);
                }
            }
        }
        if (method.getAnnotation(ConvertGroup.class) != null) {
            throw new ConstraintDeclarationException(msg);
        }
    }

    private void processMethod(Method method, MethodDescriptorImpl methodDesc) throws InvocationTargetException, IllegalAccessException {
        { // reflection
            if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(method)) {
                // return value validations and/or cross-parameter validation
                for (Annotation anno : method.getAnnotations()) {
                    if (anno instanceof Valid || anno instanceof Validate) {
                        methodDesc.setCascaded(true);
                    } else {
                        processAnnotations(method, methodDesc, method.getReturnType(), anno);
                    }
                }
            }

            // parameter validations
            final Annotation[][] paramsAnnos = method.getParameterAnnotations();
            int idx = 0;
            final List<String> names = factoryContext.getParameterNameProvider().getParameterNames(method);
            for (final Annotation[] paramAnnos : paramsAnnos) {
                if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnParameter(method, idx)) {
                    final ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
                    processAnnotations(methodDesc, paramAnnos, access, idx, names.get(idx));
                } else {
                    final ParameterDescriptorImpl parameterDescriptor = new ParameterDescriptorImpl(metaBean, new Validation[0], names.get(idx));
                    parameterDescriptor.setIndex(idx);
                    methodDesc.getParameterDescriptors().add(parameterDescriptor);
                }
                idx;
            }
        }

        if (factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnCrossParameter(method) && methodDesc.getCrossParameterDescriptor() != null) {
            methodDesc.setCrossParameterDescriptor(null);
        }
        if (factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnReturn(method) && methodDesc.getReturnValueDescriptor() != null) {
            methodDesc.setReturnValueDescriptor(null);
        }

        final MetaMethod metaMethod = metaBean.getMethod(method);
        if (metaMethod != null) {
            for (final Annotation anno : metaMethod.getAnnotations()) {
                if (anno instanceof Valid) {
                    methodDesc.setCascaded(true);
                } else {
                    // set first param as null to force it to be read
                    processAnnotations(null, methodDesc, method.getReturnType(), anno);
                }
            }

            // parameter validations
            final Collection<MetaParameter> paramsAnnos = metaMethod.getParameters();
            final List<String> names = factoryContext.getParameterNameProvider().getParameterNames(method);
            for (final MetaParameter paramAnnos : paramsAnnos) {
                final int idx = paramAnnos.getIndex();
                final ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
                processAnnotations(methodDesc, paramAnnos.getAnnotations(), access, idx, names.get(idx));
            }

        }

    }

    private AppendValidationToList processAnnotations(InvocableElementDescriptor methodDesc, Annotation[] paramAnnos, AccessStrategy access, int idx, String name)
            throws InvocationTargetException, IllegalAccessException {
        final AppendValidationToList validations = new AppendValidationToList();
        boolean cascaded = false;

        Group[] from = null;
        Group[] to = null;

        for (final Annotation anno : paramAnnos) {
            if (anno instanceof Valid || anno instanceof Validate) {
                cascaded = true;
            } else if (ConvertGroup.class.isInstance(anno)) {
                final ConvertGroup cg = ConvertGroup.class.cast(anno);
                from = new Group[]{new Group(cg.from())};
                to = new Group[]{new Group(cg.to())};
            } else if (ConvertGroup.List.class.isInstance(anno)) {
                final ConvertGroup.List cgl = ConvertGroup.List.class.cast(anno);
                final ConvertGroup[] groups = cgl.value();
                from = new Group[groups.length];
                to = new Group[groups.length];
                for (int i = 0; i < to.length; i) {
                    from[i] = new Group(groups[i].from());
                    to[i] = new Group(groups[i].to());
                }
            } else {
                processAnnotation(anno, methodDesc, access, validations);
            }
        }

        ParameterDescriptorImpl paramDesc = null;
        for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
            if (pd.getIndex() == idx) {
                paramDesc = ParameterDescriptorImpl.class.cast(pd);
            }
        }

        if (paramDesc == null) {
            paramDesc = new ParameterDescriptorImpl(Class.class.cast(access.getJavaType()), // set from getParameterTypes() so that's a Class<?>
                    validations.getValidations().toArray(new Validation[validations.getValidations().size()]), name);
            paramDesc.setIndex(idx);
            methodDesc.getParameterDescriptors().add(paramDesc);
            paramDesc.setCascaded(cascaded);
        } else {
            paramDesc.getMutableConstraintDescriptors().addAll(validations.getValidations());
            if (cascaded) {
                paramDesc.setCascaded(true);
            } // else keep previous config
        }
        if (paramDesc.isCascaded() && from != null) {
            for (int i = 0; i < from.length; i) {
                paramDesc.addGroupConversion(new GroupConversionDescriptorImpl(from[i], to[i]));
            }
        } else if (from != null) {
            throw new ConstraintDeclarationException("Group conversion is only relevant for @Valid cases");
        }

        return validations;
    }

    private <A extends Annotation> void processAnnotation(A annotation, InvocableElementDescriptor desc,
                                                          AccessStrategy access, AppendValidation validations) throws InvocationTargetException, IllegalAccessException {

        if (annotation instanceof Valid || annotation instanceof Validate) {
            desc.setCascaded(true);
        } else if (ConvertGroup.class.isInstance(annotation) && ReturnAccess.class.isInstance(access)) { // access is just tested to ensure to not read it twice with cross parameter
            final ConvertGroup cg = ConvertGroup.class.cast(annotation);
            desc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(cg.from()), new Group(cg.to())));
        } else if (ConvertGroup.List.class.isInstance(annotation) && ReturnAccess.class.isInstance(access)) {
            final ConvertGroup.List cgl = ConvertGroup.List.class.cast(annotation);
            for (final ConvertGroup cg : cgl.value()) {
                desc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(cg.from()), new Group(cg.to())));
            }
        } else {
            Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
            if (vcAnno != null) {
                annotationProcessor.processAnnotation(annotation, null, ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations, true);
            } else {
                /**
                 * Multi-valued constraints
                 */
                if (ConstraintAnnotationAttributes.VALUE.isDeclaredOn(annotation.annotationType())) {
                    Annotation[] children = ConstraintAnnotationAttributes.VALUE.getValue(annotation);
                    if (children != null) {
                        for (Annotation child : children) {
                            processAnnotation(child, desc, access, validations); // recursion
                        }
                    }
                }
            }
        }
    }
import org.apache.bval.jsr303.util.Proxies;
import org.apache.bval.model.Validation;
import org.apache.commons.lang3.tuple.ImmutablePair;

import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintDefinitionException;
import javax.validation.ConstraintTarget;
import javax.validation.ConstraintViolation;
import javax.validation.ElementKind;
import javax.validation.ValidationException;
import javax.validation.executable.ExecutableValidator;
import javax.validation.groups.Default;
import javax.validation.metadata.BeanDescriptor;
import javax.validation.metadata.ConstraintDescriptor;
import javax.validation.metadata.ElementDescriptor;
import javax.validation.metadata.ParameterDescriptor;
import javax.validation.metadata.PropertyDescriptor;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
public class ClassValidator implements CascadingPropertyValidator, ExecutableValidator {
        if (object == null) {
        }
            final Class<T> objectClass = (Class<T>) object.getClass();
            final MetaBean objectMetaBean = getMetaBeanFinder().findForClass(objectClass);
            return validateBeanWithGroups(context, context.getGroups());
        } catch (final RuntimeException ex) {
    private <T> Set<ConstraintViolation<T>> validateBeanWithGroups(final GroupValidationContext<T> context, final Groups sequence) {
        final ConstraintValidationListener<T> result = context.getListener();

        // 1. process groups
        for (final Group current : sequence.getGroups()) {
            context.setCurrentGroup(current);
            validateBeanNet(context);
        }

        // 2. process sequences
        for (final List<Group> eachSeq : sequence.getSequences()) {
            for (final Group current : eachSeq) {
                context.setCurrentGroup(current);
                validateBeanNet(context);
                // if one of the group process in the sequence leads to one
                // or more validation failure,
                // the groups following in the sequence must not be
                // processed
                if (!result.isEmpty()) {
                    break;
                }
            }
            if (!result.isEmpty()) {
                break;
            }
        }
        return result.getConstraintViolations();
    }

            MetaBean metaBean = getMetaBeanFinder().findForClass(clazz); // don't throw an exception because of a missing validator here
        } catch (final ConstraintDefinitionException definitionEx) {
            throw definitionEx;
        } catch (final ConstraintDeclarationException declarationEx) {
            throw declarationEx;
        } catch (final RuntimeException ex) {
    public ExecutableValidator forExecutables() {
        return this;
    }

     * @param context The current context of this validation call. Must have its
            final ConstraintValidationListener<?> result = context.getListener();
                final Group currentGroup = context.getCurrentGroup();
                for (final Group each : defaultGroups) {

                    // ValidationHelper.validateBean(context);, doesn't match anymore because of @ConvertGroup
                    validateBean(context);

                final List<Class<?>> classHierarchy = new ArrayList<Class<?>>();
                final Class<?> initialOwner = context.getCurrentOwner();
                for (final Class<?> owner : classHierarchy) {
                    final List<Group> ownerDefaultGroups = context.getMetaBean().getFeature("{GroupSequence:"  owner.getCanonicalName()  "}");
                        validateBean(context);
            validateBean(context);
        for (final MetaProperty prop : context.getMetaBean().getProperties()) {
            final Group group = context.getCurrentGroup();
            final Group mappedGroup;

            final Object feature = prop.getFeature(Jsr303Features.Property.PropertyDescriptor);
            if (feature != null) {
                mappedGroup = PropertyDescriptorImpl.class.cast(feature).mapGroup(group);
            } else {
                mappedGroup = group;
            }


            if (group != mappedGroup) {
                final Groups propertyGroup = groupsComputer.computeGroups(new Class<?>[]{ mappedGroup.getGroup() });
                validateCascadedBean(context, prop, propertyGroup);
            } else {
                validateCascadedBean(context, prop, null);
            }

            context.setCurrentGroup(group);
    // TODO: maybe add a GroupMapper to bval-core to ease this kind of thing and void to fork this method from ValidationHelper
    private void validateBean(final GroupValidationContext<?> context) {
        // execute all property level validations
        for (final PropertyDescriptor prop : getConstraintsForClass(context.getMetaBean().getBeanClass()).getConstrainedProperties()) {
            final PropertyDescriptorImpl impl = PropertyDescriptorImpl.class.cast(prop);
            checkValidationAppliesTo(impl.getConstraintDescriptors(), ConstraintTarget.PARAMETERS);
            checkValidationAppliesTo(impl.getConstraintDescriptors(), ConstraintTarget.RETURN_VALUE);

            final MetaProperty metaProperty = context.getMetaBean().getProperty(prop.getPropertyName());
            context.setMetaProperty(metaProperty);
            final Group current = context.getCurrentGroup();
            context.setCurrentGroup(impl.mapGroup(current));
            ValidationHelper.validateProperty(context);
            context.setCurrentGroup(current);
        }

        // execute all bean level validations
        context.setMetaProperty(null);
        for (final Validation validation : context.getMetaBean().getValidations()) {
            if (ConstraintValidation.class.isInstance(validation)) {
                checkValidationAppliesTo(ConstraintValidation.class.cast(validation).getValidationAppliesTo(), ConstraintTarget.PARAMETERS);
                checkValidationAppliesTo(ConstraintValidation.class.cast(validation).getValidationAppliesTo(), ConstraintTarget.RETURN_VALUE);
            }
            validation.validate(context);
        }
    }

    private void validateCascadedBean(final GroupValidationContext<?> context, final MetaProperty prop, final Groups groups) {
            for (final AccessStrategy each : access) {
                    // validate
                    if (groups == null) {
                        ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), treatMapsLikeBeans);
                    } else {
                        ValidationHelper.validateContext(context, new ValidationHelper.ValidateCallback() {
                            public void validate() {
                                validateBeanWithGroups(context, groups);
                            }
                        }, treatMapsLikeBeans);
                    }
        final NodeImpl node = new NodeImpl.PropertyNodeImpl(prop.getName());
            beanPath = PathImpl.create();
                context.getRootMetaBean().getBeanClass(), beanPath, access.getElementType())) {
            }
    protected <T> GroupValidationContext<T> createContext(MetaBean metaBean, T object, Class<T> objectClass, Class<?>... groups) {
        final ConstraintValidationListener<T> listener = new ConstraintValidationListener<T>(object, objectClass);
        final GroupValidationContextImpl<T> context =
                this.factoryContext.getTraversableResolver(), factoryContext.getParameterNameProvider(), metaBean);
    /*
    protected BeanDescriptorImpl createBeanDescriptor(MetaBean metaBean) {
        return new BeanDescriptorImpl(factoryContext, metaBean);
    }
    */
        for (final Class<?> c : groups) {
            if (c == null) {
                throw new IllegalArgumentException("Group cannot be null.");
            }
        }
    }

    public <T> Set<ConstraintViolation<T>> validateConstructorParameters(Constructor<? extends T> constructor, Object[] parameterValues, Class<?>... gps) {
        notNull("Constructor", constructor);
        notNull("Groups", gps);
        notNull("Parameters", parameterValues);

        final Class<?> declaringClass = constructor.getDeclaringClass();
        final ConstructorDescriptorImpl constructorDescriptor = ConstructorDescriptorImpl.class.cast(getConstraintsForClass(declaringClass).getConstraintsForConstructor(constructor.getParameterTypes()));
        if (constructorDescriptor == null) { // no constraint
            return Collections.emptySet();
        }

        // validations
        if (parameterValues.length > 0) {
            checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()), ConstraintTarget.IMPLICIT);
            checkValidationAppliesTo(constructorDescriptor.getParameterDescriptors(), ConstraintTarget.IMPLICIT);
        } else {
            checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()), ConstraintTarget.PARAMETERS);
            checkValidationAppliesTo(constructorDescriptor.getParameterDescriptors(), ConstraintTarget.PARAMETERS);
        }

        final Set<ConstraintViolation<T>> violations = new HashSet<ConstraintViolation<T>>();
        final ImmutablePair<Set<ConstraintViolation<Object>>, Group> result;
        {
            final GroupValidationContext<ConstraintValidationListener<?>> context = createContext(constructorDescriptor.getMetaBean(), null, Class.class.cast(constructor.getDeclaringClass()), gps);
            context.moveDown(new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(), Arrays.asList(constructor.getParameterTypes())));
            result = validateParameters(context, constructorDescriptor.getParameterDescriptors(), parameterValues);
            violations.addAll(Set.class.cast(result.getLeft()));
            context.moveUp(null, null);
        }
        {
            final GroupValidationContext<Object> crossParameterContext;
            if (result.getRight() == null) {
                crossParameterContext = createContext(constructorDescriptor.getMetaBean(), parameterValues, Class.class.cast(constructor.getDeclaringClass()), gps);
            } else {
                crossParameterContext = createContext(constructorDescriptor.getMetaBean(), parameterValues, Class.class.cast(constructor.getDeclaringClass()), result.getRight().getGroup());
            }

            crossParameterContext.setBean(parameterValues);
            crossParameterContext.moveDown(new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(), Arrays.asList(constructor.getParameterTypes())));
            crossParameterContext.moveDown("<cross-parameter>");
            crossParameterContext.setKind(ElementKind.CROSS_PARAMETER);
            validateElementInContext(crossParameterContext, constructorDescriptor.getCrossParameterDescriptor());
            crossParameterContext.moveUp(null, null);
            crossParameterContext.moveUp(null, null);

            violations.addAll(Set.class.cast(crossParameterContext.getListener().getConstraintViolations()));
        }

        return violations;
    }

    private static void checkValidationAppliesTo(final Collection<? extends ElementDescriptor> descriptors, final ConstraintTarget forbidden) {
        for (final ElementDescriptor descriptor : descriptors) {
            for (final ConstraintDescriptor<?> consDesc : descriptor.getConstraintDescriptors()) {
                checkValidationAppliesTo(consDesc.getValidationAppliesTo(), forbidden);
            }
        }
    }

    private static void checkValidationAppliesTo(final Set<ConstraintDescriptor<?>> constraintDescriptors, final ConstraintTarget forbidden) {
        for (final ConstraintDescriptor<?> descriptor : constraintDescriptors) {
            checkValidationAppliesTo(descriptor.getValidationAppliesTo(), forbidden);
        }
    }

    private static void checkValidationAppliesTo(final ConstraintTarget configured, final ConstraintTarget forbidden) {
        if (forbidden.equals(configured)) {
            throw new ConstraintDeclarationException(forbidden.name()  " forbidden here");
        }
    }

    public <T> Set<ConstraintViolation<T>> validateConstructorReturnValue(final Constructor<? extends T> constructor, final T createdObject, final Class<?>... groups) {
        if (constructor == null) {
            throw new IllegalArgumentException("constructor shouldn't be null");
        }
        if (createdObject == null) {
            throw new IllegalArgumentException("returned value shouldn't be null");
        }

        final ConstructorDescriptorImpl methodDescriptor = ConstructorDescriptorImpl.class.cast(getConstraintsForClass(constructor.getDeclaringClass()).getConstraintsForConstructor(constructor.getParameterTypes()));
        if (methodDescriptor == null) {
            throw new ValidationException("Constructor "  constructor  " doesn't belong to class "  constructor.getDeclaringClass());
        }

        final GroupValidationContext<T> context = createContext(methodDescriptor.getMetaBean(), createdObject, (Class<T>) Proxies.classFor(createdObject.getClass()), groups);
        context.moveDown(new NodeImpl.ConstructorNodeImpl(constructor.getDeclaringClass().getSimpleName(), Arrays.asList(constructor.getParameterTypes())));
        context.moveDown(new NodeImpl.ReturnValueNodeImpl());
        context.setReturnValue(createdObject);
        validateElementInContext(context, methodDescriptor.getReturnValueDescriptor());
        final Set<ConstraintViolation<T>> constraintViolations = context.getListener().getConstraintViolations();
        context.moveUp(null, null);
        context.moveUp(null, null);

        if (methodDescriptor.isCascaded()) {
            context.moveDown(new NodeImpl.ConstructorNodeImpl(constructor.getDeclaringClass().getSimpleName(), Arrays.asList(constructor.getParameterTypes())));
            context.moveDown(new NodeImpl.ReturnValueNodeImpl());
            context.setReturnValue(createdObject);
            context.setBean(createdObject);
            for (final Group group : context.getGroups().getGroups()) {
                context.setCurrentGroup(methodDescriptor.mapGroup(group));
                validateBeanNet(context);
            }
            for (final List<Group> sequence : context.getGroups().getSequences()) {
                for (final Group group : sequence) {
                    context.setCurrentGroup(methodDescriptor.mapGroup(group));
                    validateBeanNet(context);
                }
            }
            constraintViolations.addAll(Set.class.cast(context.getListener().getConstraintViolations()));
            context.moveUp(null, null);
            context.moveUp(null, null);
        }

        return constraintViolations;
    }

    public <T> Set<ConstraintViolation<T>> validateParameters(T object, Method method, Object[] parameterValues, Class<?>... groups) {
        {
            notNull("Object", object);
            notNull("Parameters", parameterValues);
            notNull("Method", method);
            notNull("Groups", groups);
            for (final Class<?> g : groups) {
                notNull("Each group", g);
            }
        }

        final MethodDescriptorImpl methodDescriptor = findMethodDescriptor(object, method);
        if (methodDescriptor == null) { // no constraint
            return Collections.emptySet();
        }

        if (method.getParameterTypes().length > 0 && method.getReturnType() != Void.TYPE) {
            checkValidationAppliesTo(Collections.singleton(methodDescriptor.getCrossParameterDescriptor()), ConstraintTarget.IMPLICIT);
            checkValidationAppliesTo(methodDescriptor.getParameterDescriptors(), ConstraintTarget.IMPLICIT);
        } else if (method.getParameterTypes().length == 0) {
            checkValidationAppliesTo(Collections.singleton(methodDescriptor.getCrossParameterDescriptor()), ConstraintTarget.PARAMETERS);
            checkValidationAppliesTo(methodDescriptor.getParameterDescriptors(), ConstraintTarget.PARAMETERS);
        }

        final Set<ConstraintViolation<T>> violations = new HashSet<ConstraintViolation<T>>();

        final ImmutablePair<Set<ConstraintViolation<Object>>, Group> result;
        { // parameter validations
            final GroupValidationContext<ConstraintValidationListener<?>> context = createContext(methodDescriptor.getMetaBean(), object, Class.class.cast(object.getClass()), groups);
            context.setMethod(method);
            context.moveDown(new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())));
            result = validateParameters(context, methodDescriptor.getParameterDescriptors(), parameterValues);
            violations.addAll(Set.class.cast(result.getLeft()));
            context.moveUp(null, null);
        }

        { // cross parameters validation
            final GroupValidationContext<Object[]> context;
            if (result.getRight() == null) {
                context = createContext(methodDescriptor.getMetaBean(), object, Class.class.cast(Object[].class), groups);
            } else {
                context = createContext(methodDescriptor.getMetaBean(), object, Class.class.cast(Object[].class), result.getRight().getGroup());
            }
            context.setMethod(method);
            context.setBean(parameterValues);
            context.moveDown(new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())));
            context.moveDown(new NodeImpl.CrossParameterNodeImpl());
            validateElementInContext(context, methodDescriptor.getCrossParameterDescriptor());
            violations.addAll(Set.class.cast(context.getListener().getConstraintViolations()));
            context.moveUp(null, null);
            context.moveUp(null, null);
        }

        return violations;
    }

    private static void notNull(final String entity, final Object shouldntBeNull) {
        if (shouldntBeNull == null) {
            throw new IllegalArgumentException(entity  " shouldn't be null");
        }
    }

    /**
     * {@inheritDoc}
     */
    public <T> Set<ConstraintViolation<T>> validateReturnValue(T object, Method method, Object returnValue, Class<?>... groups) {
        notNull("object", object);
        notNull("method", method);
        notNull("groups", groups);

        MethodDescriptorImpl methodDescriptor = findMethodDescriptor(object, method);
        if (methodDescriptor == null) {
            throw new ValidationException("Method "  method  " doesn't belong to class "  object.getClass());
        }

        if (method.getReturnType() == Void.TYPE) {
            checkValidationAppliesTo(methodDescriptor.getReturnValueDescriptor().getConstraintDescriptors(), ConstraintTarget.RETURN_VALUE);
        }

        final GroupValidationContext<?> context = createContext(methodDescriptor.getMetaBean(), returnValue, Class.class.cast(Proxies.classFor(object.getClass())), groups);
        context.moveDown(new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())));
        context.moveDown(new NodeImpl.ReturnValueNodeImpl());
        context.setReturnValue(object); // switched with returnValue when creating violation, avoid to modify the validation logic
        initMetaBean(context, factoryContext.getMetaBeanFinder(), method.getReturnType());
        validateElementInContext(context, methodDescriptor.getReturnValueDescriptor());
        final ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
        context.moveUp(null, null);
        context.moveUp(null, null);

        return result.getConstraintViolations();
    }

    private <T> MethodDescriptorImpl findMethodDescriptor(final T object, final Method method) {
        return MethodDescriptorImpl.class.cast(getConstraintsForClass(Proxies.classFor(object.getClass())).getConstraintsForMethod(method.getName(), method.getParameterTypes()));
    }

    private <T> ImmutablePair<Set<ConstraintViolation<T>>, Group> validateParameters(GroupValidationContext<ConstraintValidationListener<?>> context,
                                                                                         List<ParameterDescriptor> paramDescriptors, Object[] parameters) {
        if (parameters == null) {
            throw new IllegalArgumentException("cannot validate null");
        }
        if (parameters.length > 0) {
            try {
                Group gp = null;
                for (int i = 0; i < parameters.length; i) {
                    final ParameterDescriptorImpl paramDesc = (ParameterDescriptorImpl) paramDescriptors.get(i);
                    context.setBean(parameters[i]);
                    context.setParameters(parameters);
                    context.moveDown(new NodeImpl.ParameterNodeImpl(paramDesc.getName(), i));
                    final Group current = validateElementInContext(context, paramDesc);
                    if (current != null) {
                        gp = current;
                    }
                    context.moveUp(null, null);
                }

                final ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
                return new ImmutablePair<Set<ConstraintViolation<T>>, Group>(result.getConstraintViolations(), gp);
            } catch (final RuntimeException ex) {
                throw unrecoverableValidationError(ex, parameters);
            }
        } else {
            return new ImmutablePair<Set<ConstraintViolation<T>>, Group>(Collections.<ConstraintViolation<T>> emptySet(), null);
        }
    }

    private <T> void initMetaBean(final GroupValidationContext<T> context, final MetaBeanFinder metaBeanFinder, final Class<?> directValueClass) {
        final boolean collection = Collection.class.isAssignableFrom(directValueClass);
        final boolean map = Map.class.isAssignableFrom(directValueClass);
        if (!directValueClass.isArray()
                && (!collection || Collection.class.cast(context.getValidatedValue()).isEmpty())
                && (!map || Map.class.cast(context.getValidatedValue()).isEmpty())) {
            context.setMetaBean(metaBeanFinder.findForClass(directValueClass));
        } else if (collection) {
            context.setMetaBean(metaBeanFinder.findForClass(Collection.class.cast(context.getValidatedValue()).iterator().next().getClass()));
        } else if (map) {
            context.setMetaBean(metaBeanFinder.findForClass(Map.class.cast(context.getValidatedValue()).values().iterator().next().getClass()));
        } else {
            context.setMetaBean(metaBeanFinder.findForClass(directValueClass.getComponentType()));
        }
    }

    private <T> Group validateElementInContext(final GroupValidationContext<T> context,
                                              final ElementDescriptor eltDescriptor) {

        final ElementDescriptorImpl impl = ElementDescriptorImpl.class.cast(eltDescriptor);

        final Groups groups = context.getGroups();

        Group breakOnGroup = null;

        for (final ConstraintDescriptor<?> consDesc : eltDescriptor.getConstraintDescriptors()) {
            final ConstraintValidation<?> validation = (ConstraintValidation<?>) consDesc;

            // 1. process groups
            for (final Group current : groups.getGroups()) {
                context.setCurrentGroup(current);
                validation.validate(context);
            }
            // 2. process sequences
            for (final List<Group> eachSeq : groups.getSequences()) {
                for (final Group current : eachSeq) {
                    context.setCurrentGroup(current);
                    validation.validate(context);
                    /**
                     * if one of the group process in the sequence leads to one
                     * or more validation failure, the groups following in the
                     * sequence must not be processed
                     */
                    if (!context.getListener().isEmpty()) {
                        breakOnGroup = current;
                        break;
                    }
                }
            }
        }
        if (impl.isCascaded() && context.getValidatedValue() != null) {
            initMetaBean(context, factoryContext.getMetaBeanFinder(), context.getValidatedValue().getClass());

            // 1. process groups
            for (final Group current : groups.getGroups()) {
                context.setCurrentGroup(impl.mapGroup(current));
                ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
            }
            // 2. process sequences
            for (final List<Group> eachSeq : groups.getSequences()) {
                for (final Group current : eachSeq) {
                    context.setCurrentGroup(impl.mapGroup(current));
                    ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
                    /**
                     * if one of the group process in the sequence leads to one
                     * or more validation failure, the groups following in the
                     * sequence must not be processed
                     */
                    if (!context.getListener().isEmpty()) {
                        breakOnGroup = current;
                        break;
                    }
                }
            }
        }
        return breakOnGroup;
import org.apache.bval.jsr303.parameter.DefaultParameterNameProvider;
import org.apache.bval.jsr303.util.IOs;
import javax.validation.BootstrapConfiguration;
import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.ParameterNameProvider;
import javax.validation.TraversableResolver;
import javax.validation.ValidationException;
import javax.validation.ValidationProviderResolver;
import javax.validation.ValidatorFactory;
import javax.validation.executable.ExecutableType;
import java.io.Closeable;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
    protected MessageInterpolator defaultMessageInterpolator = new DefaultMessageInterpolator();
    protected MessageInterpolator messageInterpolator = defaultMessageInterpolator;
    protected ConstraintValidatorFactory defaultConstraintValidatorFactory = new DefaultConstraintValidatorFactory();
    protected ConstraintValidatorFactory constraintValidatorFactory = defaultConstraintValidatorFactory;
    private TraversableResolver defaultTraversableResolver = new DefaultTraversableResolver();
    private TraversableResolver traversableResolver = defaultTraversableResolver;

    protected ParameterNameProvider defaultParameterNameProvider = new DefaultParameterNameProvider();
    protected ParameterNameProvider parameterNameProvider = defaultParameterNameProvider;

    protected BootstrapConfiguration  bootstrapConfiguration;

    protected Collection<ExecutableType> executableValidation;
    private ValidationParser parser;

    public ApacheValidatorConfiguration parameterNameProvider(ParameterNameProvider parameterNameProvider) {
        this.parameterNameProvider = parameterNameProvider;
        return this;
    }

        mappingStreams.add(IOs.convertToMarkableInputStream(stream));
    public MessageInterpolator getDefaultMessageInterpolator() {
        return defaultMessageInterpolator;
    }

    public TraversableResolver getDefaultTraversableResolver() {
        return defaultTraversableResolver;
    }

    public ConstraintValidatorFactory getDefaultConstraintValidatorFactory() {
        return defaultConstraintValidatorFactory;
    }

    public ParameterNameProvider getDefaultParameterNameProvider() {
        return defaultParameterNameProvider;
    }

    public BootstrapConfiguration getBootstrapConfiguration() {
        if (bootstrapConfiguration == null) {
            synchronized (this) {
                if (bootstrapConfiguration == null) {
                    parser = parseValidationXml();
                    bootstrapConfiguration = parser.getBootstrap();
                }
            }
        }
        return bootstrapConfiguration;
        parser.ensureValidatorFactoryCanBeBuilt();
    public ConfigurationImpl prepare() {
        if (prepared) {
            return this;
        }

        if (parser == null) {
            parser = parseValidationXml(); // already done if BootstrapConfiguration already looked up
            synchronized (this) { // this synchro should be done in a better way
                if (bootstrapConfiguration == null) {
                    bootstrapConfiguration = parser.getBootstrap();
                }
            }
        }
        parser.applyConfigWithInstantiation(this); // instantiate the config if needed

        // TODO: maybe find a better way to communicate between validator factory and config
        if (getBootstrapConfiguration().isExecutableValidationEnabled()) {
            getProperties().put(Properties.EXECUTABLE_VALIDATION_TYPES, executableValidationTypesAsString());
        }

        return this;
    private ValidationParser parseValidationXml() {
        return ValidationParser.processValidationConfig(getProperties().get(Properties.VALIDATION_XML_PATH), this, ignoreXmlConfiguration);
    public ParameterNameProvider getParameterNameProvider() {
        return parameterNameProvider;
    }


    public void setExecutableValidation(final Collection<ExecutableType> executableValidation) {
        this.executableValidation = executableValidation;
    }

    public Collection<ExecutableType> getExecutableValidation() {
        return executableValidation;
    }

    private String executableValidationTypesAsString() {
        if (executableValidation == null || executableValidation.isEmpty()) {
            return "";
        }

        final StringBuilder builder = new StringBuilder();
        for (final ExecutableType type : executableValidation) {
            builder.append(type.name()).append(",");
        }
        final String s = builder.toString();
        return s.substring(0, s.length() - 1);
    }

    public Closeable getClosable() {
        return parser;
    }

    public ValidationParser getParser() {
        return parser;
    }

    public void setParser(ValidationParser parser) {
        this.parser = parser;
    }
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.commons.lang3.reflect.TypeUtils;

import javax.validation.Constraint;
import javax.validation.ConstraintDefinitionException;
import javax.validation.ConstraintTarget;
import javax.validation.Payload;
import javax.validation.ValidationException;
    MESSAGE(false, false, "message"),
    GROUPS(false, false, "groups"),
    PAYLOAD(false, false, "payload"),

    /**
     * "validationAppliesTo"
     */
    VALIDATION_APPLIES_TO(true, true, "validationAppliesTo"),
    VALUE(false, true, "value");
        ConstraintTarget validationAppliesTo;
    private final Type type;
    private final boolean permitNullDefaultValue;
    private final String attributeName;
    private final boolean quiet;
    private ConstraintAnnotationAttributes(final boolean quiet, final boolean permitNullDefaultValue, final String name) {
        this.quiet = quiet;
        this.attributeName = name;
        return attributeName;
        new Worker<A>(type, quiet);
        return  (T) new Worker<A>(type, quiet).defaultValue;
import javax.validation.ConstraintTarget;
    private final ConstraintTarget validationAppliesTo;
    private final String template;
    public ConstraintDescriptorImpl(final ConstraintDescriptor<T> descriptor) {
            descriptor.isReportAsSingleViolation(), descriptor.getValidationAppliesTo(), descriptor.getMessageTemplate());
        boolean reportAsSingleViolation, ConstraintTarget validationAppliesTo, String messageTemplate) {
        this.validationAppliesTo = validationAppliesTo;
        this.template = messageTemplate;
    public String getMessageTemplate() {
        return template;
    }

    public ConstraintTarget getValidationAppliesTo() {
        return validationAppliesTo;
    }


    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        ConstraintDescriptorImpl that = (ConstraintDescriptorImpl) o;

        if (reportAsSingleViolation != that.reportAsSingleViolation) return false;
        if (!annotation.annotationType().equals(that.annotation.annotationType())) return false;
        if (composingConstraints != null ? !composingConstraints.equals(that.composingConstraints) : that.composingConstraints != null)
            return false;
        if (constraintValidatorClasses != null ? !constraintValidatorClasses.equals(that.constraintValidatorClasses) : that.constraintValidatorClasses != null)
            return false;
        if (payload != null ? !payload.equals(that.payload) : that.payload != null) return false;
        if (template != null ? !template.equals(that.template) : that.template != null) return false;
        if (validationAppliesTo != that.validationAppliesTo) return false;

        return true;
    }

    @Override
    public int hashCode() {
        int result = annotation != null ? annotation.annotationType().hashCode() : 0;
        result = 31 * result  (payload != null ? payload.hashCode() : 0);
        result = 31 * result  (constraintValidatorClasses != null ? constraintValidatorClasses.hashCode() : 0);
        result = 31 * result  (composingConstraints != null ? composingConstraints.hashCode() : 0);
        result = 31 * result  (reportAsSingleViolation ? 1 : 0);
        result = 31 * result  (validationAppliesTo != null ? validationAppliesTo.hashCode() : 0);
        result = 31 * result  (template != null ? template.hashCode() : 0);
        return result;
    }
        if (constraintDescriptors.isEmpty()) {
            return Collections.emptySet();
        }
        return Collections.<ConstraintDescriptor<?>>unmodifiableSet(constraintDescriptors);
import javax.validation.ConstraintTarget;
    private final RuntimeException missingValidatorException;
    private ConstraintTarget validationAppliesTo = null;
     *
 *            - the annotation of the constraint
*            - the type where the annotated element is placed (class,
*            interface, annotation type)
*            - how to access the value
     * @param missingValidatorException
                                ConstraintValidator<T, ?> validator, T annotation, Class<?> owner, AccessStrategy access,
                                boolean reportFromComposite, ConstraintTarget target, RuntimeException missingValidatorException) {
        this.validationAppliesTo = target;
        this.missingValidatorException = missingValidatorException;
        if (missingValidatorException != null) {
            throw missingValidatorException;
        }

        final PathImpl path = context.getPropertyPath();
        final NodeImpl node = path.getLeafNode();
            beanPath = PathImpl.create();
    public ConstraintTarget getValidationAppliesTo() {
        return validationAppliesTo;
    }

    public void setValidationAppliesTo(final ConstraintTarget validationAppliesTo) {
        this.validationAppliesTo = validationAppliesTo;
    }
import javax.validation.ElementKind;
import java.util.Iterator;

        final Object[] parameters;
        Object leaf;
        Object returnValue;
        T rootBean;
        if (GroupValidationContext.class.isInstance(context)) { // TODO: clean up it but it would need to rework completely our context - get rid of it would be the best
            final GroupValidationContext<T> ctx = GroupValidationContext.class.cast(context);
            final ElementKind elementKind = ctx.getElementKind();
            final Iterator<Path.Node> it = propPath.iterator();
            final ElementKind kind = propPath.iterator().next().getKind();

            returnValue = ctx.getReturnValue();

            if (ElementKind.CONSTRUCTOR.equals(kind)) {
                rootBean = null;
                leaf = context.getBean();
            } else if (ElementKind.METHOD.equals(kind)) {
                if (ElementKind.RETURN_VALUE.equals(elementKind)) { // switch back return value and rootBean
                    rootBean = (T) returnValue;
                    if (kindOf(propPath, ElementKind.RETURN_VALUE)) {
                        leaf = returnValue;
                        returnValue = this.rootBean;
                    } else {
                        leaf = this.rootBean;
                        returnValue = this.rootBean;
                    }
                } else {
                    rootBean = this.rootBean;
                    if (kindOf(propPath, ElementKind.PARAMETER, ElementKind.CROSS_PARAMETER)) {
                        leaf = rootBean;
                    } else {
                        leaf = context.getBean();
                    }
                }
            } else {
                rootBean = this.rootBean;
                leaf = context.getBean();
            }

            if (ElementKind.CONSTRUCTOR.equals(kind)
                    && (ElementKind.CROSS_PARAMETER.equals(elementKind)
                        || ElementKind.PARAMETER.equals(elementKind))
                    && (it.hasNext() && it.next() != null && it.hasNext() && it.next() != null && !it.hasNext())) { // means inherited validation use real value
                leaf = null;
            }

            parameters = ctx.getParameters();
        } else {
            leaf = context.getBean();
            returnValue = null;
            parameters = null;
            rootBean = this.rootBean;
        }

        constraintViolations.add(new ConstraintViolationImpl<T>(
                messageTemplate, message,
                rootBean, leaf,
                propPath, value, descriptor,
                rootBeanType,
                elementType, returnValue, parameters));
    }

    private static boolean kindOf(final Path propPath, final ElementKind... kinds) {
        final Iterator<Path.Node> node = propPath.iterator();
        boolean isParam = false;
        while (node.hasNext()) {
            final ElementKind current = node.next().getKind();
            isParam = false;
            for (final ElementKind k : kinds) {
                if (k.equals(current)) {
                    isParam = true;
                    break;
                }
            }
        }
        return isParam;
import org.apache.bval.jsr303.util.LeafNodeBuilderCustomizableContextImpl;
import javax.validation.ElementKind;
import javax.validation.ParameterNameProvider;
import java.lang.reflect.Method;
        return new ConstraintViolationBuilderImpl(this, messageTemplate, validationContext.getPropertyPath());
    }

    public <T> T unwrap(Class<T> type) {
        if (type.isInstance(this)) {
            return type.cast(this);
        }
        throw new ValidationException("Type "  type  " not supported");
                path = PathImpl.create();
                path.getLeafNode().setName(name);
        public NodeBuilderCustomizableContext addPropertyNode(String name) {
            final NodeImpl node;
            if (!propertyPath.isRootPath()) {
                if (propertyPath.getLeafNode().getKind() != null) {
                    node = new NodeImpl.PropertyNodeImpl(name);
                    propertyPath.addNode(node);
                } else {
                    node = propertyPath.getLeafNode();
                }
            } else {
                node = new NodeImpl.PropertyNodeImpl(name);
                propertyPath.addNode(node);
            }
            node.setName(name);
            node.setKind(ElementKind.PROPERTY); // enforce it
            return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
        }

        public LeafNodeBuilderCustomizableContext addBeanNode() {
            final NodeImpl node = new NodeImpl.BeanNodeImpl();
            node.setKind(ElementKind.BEAN);
            propertyPath.addNode(node);
            return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
        }

        public NodeBuilderDefinedContext addParameterNode(int index) {
            final Method method = parent.validationContext.getMethod();
            final List<String> parameters = parent.validationContext.getParameterNameProvider().getParameterNames(method);
            final NodeImpl node = new NodeImpl.ParameterNodeImpl(parameters.get(index), index);
            node.setParameterIndex(index);
            node.setKind(ElementKind.PARAMETER);
            if (!propertyPath.isRootPath()) {
                propertyPath.removeLeafNode();
            }
            propertyPath.addNode(node);
            return new NodeBuilderDefinedContextImpl(parent, messageTemplate, propertyPath);
        }

import javax.validation.ValidationException;
import java.util.Arrays;
    private final Object returnValue;
    private final Object[] parameters;

     * @param messageTemplate - message reason (raw message)
     * @param returnValue
     * @param parameters
                                   ConstraintDescriptor<?> constraintDescriptor, Class<T> rootBeanClass,
                                   ElementType elementType, Object returnValue, Object[] parameters) {
        this.returnValue = returnValue;
        this.parameters = parameters;
    public Object[] getExecutableParameters() {
        return parameters;
    }

    public Object getExecutableReturnValue() {
        return returnValue;
    }

    public <U> U unwrap(Class<U> type) {
        if (type.isInstance(this)) {
            return type.cast(this);
        }
        throw new ValidationException("Type "  type  " is not supported");
    }

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ConstraintViolationImpl that = (ConstraintViolationImpl) o;
        if (constraintDescriptor != null ? !constraintDescriptor.equals(that.constraintDescriptor) : that.constraintDescriptor != null)
            return false;
        if (elementType != that.elementType) return false;
        if (leafBean != null ? !leafBean.equals(that.leafBean) : that.leafBean != null) return false;
        if (message != null ? !message.equals(that.message) : that.message != null) return false;
        if (messageTemplate != null ? !messageTemplate.equals(that.messageTemplate) : that.messageTemplate != null)
            return false;
        // Probably incorrect - comparing Object[] arrays with Arrays.equals
        if (!Arrays.equals(parameters, that.parameters)) return false;
        if (propertyPath != null ? !propertyPath.equals(that.propertyPath) : that.propertyPath != null) return false;
        if (returnValue != null ? !returnValue.equals(that.returnValue) : that.returnValue != null) return false;
        if (rootBean != null ? !rootBean.equals(that.rootBean) : that.rootBean != null) return false;
        if (rootBeanClass != null ? !rootBeanClass.equals(that.rootBeanClass) : that.rootBeanClass != null)
            return false;
        if (value != null ? !value.equals(that.value) : that.value != null) return false;

    @Override
    public int hashCode() {
        int result = messageTemplate != null ? messageTemplate.hashCode() : 0;
        result = 31 * result  (message != null ? message.hashCode() : 0);
        result = 31 * result  (rootBean != null ? rootBean.hashCode() : 0);
        result = 31 * result  (rootBeanClass != null ? rootBeanClass.hashCode() : 0);
        result = 31 * result  (leafBean != null ? leafBean.hashCode() : 0);
        result = 31 * result  (value != null ? value.hashCode() : 0);
        result = 31 * result  (propertyPath != null ? propertyPath.hashCode() : 0);
        result = 31 * result  (elementType != null ? elementType.hashCode() : 0);
        result = 31 * result  (constraintDescriptor != null ? constraintDescriptor.hashCode() : 0);
        result = 31 * result  (returnValue != null ? returnValue.hashCode() : 0);
        result = 31 * result  (parameters != null ? Arrays.hashCode(parameters) : 0);
        return result;
    }
import org.apache.bval.cdi.BValExtension;

import java.io.Closeable;
import java.io.IOException;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;
public class DefaultConstraintValidatorFactory implements ConstraintValidatorFactory, Closeable {
    private final Collection< BValExtension.Releasable<?>> releasables = new CopyOnWriteArrayList<BValExtension.Releasable<?>>();
    public <T extends ConstraintValidator<?, ?>> T getInstance(final Class<T> constraintClass) {
        // 2011-03-27 jw: Do not use PrivilegedAction.
        // Otherwise any user code would be executed with the privileges of this class.
        try {
            try {
                return BValExtension.inject(constraintClass).getInstance();
            } catch (final Exception e) {
                return constraintClass.newInstance();
            } catch (final NoClassDefFoundError error) {
                return constraintClass.newInstance();
            }
        } catch (final Exception ex) {
            throw new ValidationException("Cannot instantiate : "  constraintClass, ex);
        }
    }

    public void releaseInstance(final ConstraintValidator<?, ?> instance) {
        // no-op
    }

    public void close() throws IOException {
        for (final BValExtension.Releasable<?> releasable : releasables) {
            // ensure to call this callback
            releaseInstance(ConstraintValidator.class.cast(releasable.getInstance()));
            releasable.release();
        }
        releasables.clear();
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.commons.lang3.ArrayUtils;

import javax.el.ArrayELResolver;
import javax.el.BeanELResolver;
import javax.el.CompositeELResolver;
import javax.el.ELContext;
import javax.el.ELException;
import javax.el.ELResolver;
import javax.el.ExpressionFactory;
import javax.el.FunctionMapper;
import javax.el.ListELResolver;
import javax.el.MapELResolver;
import javax.el.MethodNotFoundException;
import javax.el.PropertyNotWritableException;
import javax.el.ResourceBundleELResolver;
import javax.el.ValueExpression;
import javax.el.VariableMapper;
import javax.validation.MessageInterpolator;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Formatter;
import java.util.HashMap;
    private static final ExpressionFactory EXPRESSION_FACTORY;
    static {
        ExpressionFactory ef;
        try {
            ef = ExpressionFactory.newInstance();
        } catch (final Exception e) {
            ef = null;
        }
        EXPRESSION_FACTORY = ef;
    }

    private static final String DEFAULT_VALIDATION_MESSAGES = "org.apache.bval.jsr303.ValidationMessages";
    private static final Pattern messageParameterPattern = Pattern.compile("(\\{[\\w\\.]\\})");
    private final Map<Locale, ResourceBundle> defaultBundlesMap = new ConcurrentHashMap<Locale, ResourceBundle>();
    private static ELResolver initResolver() {
        final CompositeELResolver resolver = new CompositeELResolver();
        resolver.add(new MapELResolver());
        resolver.add(new ListELResolver());
        resolver.add(new ArrayELResolver());
        resolver.add(new ResourceBundleELResolver());
        resolver.add(new BeanELResolver() {
            @Override // patched because G l API contains a bug with array used by formatter usage, when fixed just update the API and remove this method
            public Object invoke(ELContext context, Object base, Object method, Class<?>[] paramTypes, Object[] params) {
                if (context == null) {
                    throw new NullPointerException("ELContext could not be nulll");
                }
                // Why static invocation is not supported
                if(base == null || method == null) {
                    return null;
                }
                if (params == null) {
                    params = new Object[0];
                }
                String methodName = (String) EXPRESSION_FACTORY.coerceToType(method, String.class);
                if (methodName.length() == 0) {
                    throw new MethodNotFoundException("The parameter method could not be zero-length");
                }
                Class<?> targetClass = base.getClass();
                if (methodName.equals("<init>") || methodName.equals("<cinit>")) {
                    throw new MethodNotFoundException(method  " is not found in target class "  targetClass.getName());
                }
                Method targetMethod = null;
                if (paramTypes == null) {
                    int paramsNumber = params.length;
                    for (final Method m : targetClass.getMethods()) {
                        if (m.getName().equals(methodName) && m.getParameterTypes().length == paramsNumber) {
                            targetMethod = m;
                            break;
                        }
                    }
                    if (targetMethod == null) {
                        for (final Method m : targetClass.getMethods()) {
                            if (m.getName().equals(methodName) && m.isVarArgs() && paramsNumber >= (m.getParameterTypes().length - 1)) {
                                targetMethod = m;
                                break;
                            }
                        }
                    }
                } else {
                    try {
                        targetMethod = targetClass.getMethod(methodName, paramTypes);
                    } catch (SecurityException e) {
                        throw new ELException(e);
                    } catch (NoSuchMethodException e) {
                        throw new MethodNotFoundException(e);
                    }
                }
                if (targetMethod == null) {
                    throw new MethodNotFoundException(method  " is not found in target class "  targetClass.getName());
                }
                if (paramTypes == null) {
                    paramTypes = targetMethod.getParameterTypes();
                }
                //Initial check whether the types and parameter values length
                if (targetMethod.isVarArgs()) {
                    if (paramTypes.length - 1 > params.length) {
                        throw new IllegalArgumentException("Inconsistent number between argument types and values");
                    }
                } else if (paramTypes.length != params.length) {
                    throw new IllegalArgumentException("Inconsistent number between argument types and values");
                }
                try {
                    Object[] finalParamValues = new Object[paramTypes.length];
                    //Only do the parameter conversion while the method is not a non-parameter one
                    if (paramTypes.length > 0) {
                        int iCurrentIndex = 0;
                        for (int iLoopSize = paramTypes.length - 1; iCurrentIndex < iLoopSize; iCurrentIndex) {
                            finalParamValues[iCurrentIndex] = EXPRESSION_FACTORY.coerceToType(params[iCurrentIndex], paramTypes[iCurrentIndex]);
                        }
                        /**
                         * Not sure it is over-designed. Do not find detailed description about how the parameter values are passed if the method is of variable arguments.
                         * It might be an array directly passed or each parameter value passed one by one.
                         */
                        if (targetMethod.isVarArgs()) {
                            // varArgsClassType should be an array type
                            Class<?> varArgsClassType = paramTypes[iCurrentIndex];
                            // 1. If there is no parameter value left for the variable argument, create a zero-length array
                            // 2. If there is only one parameter value left for the variable argument, and it has the same array type with the varArgsClass, pass in directly
                            // 3. Else, create an array of varArgsClass type, and add all the left coerced parameter values
                            if (iCurrentIndex == params.length) {
                                finalParamValues[iCurrentIndex] = Array.newInstance(varArgsClassType.getComponentType(), 0);
                            } else if (iCurrentIndex == params.length - 1 && varArgsClassType == params[iCurrentIndex].getClass()
                                    && varArgsClassType.getClassLoader() == params[iCurrentIndex].getClass().getClassLoader()) {
                                finalParamValues[iCurrentIndex] = params[iCurrentIndex];
                            } else {
                                Object targetArray = Array.newInstance(varArgsClassType.getComponentType(), params.length - iCurrentIndex);
                                Class<?> componentClassType = varArgsClassType.getComponentType();
                                for (int i = 0, iLoopSize = params.length - iCurrentIndex; i < iLoopSize; i) {
                                    Array.set(targetArray, i, EXPRESSION_FACTORY.coerceToType(params[iCurrentIndex  i], componentClassType));
                                }
                                finalParamValues[iCurrentIndex] = targetArray;
                            }
                        } else {
                            finalParamValues[iCurrentIndex] = EXPRESSION_FACTORY.coerceToType(params[iCurrentIndex], paramTypes[iCurrentIndex]);
                        }
                    }
                    Object retValue = targetMethod.invoke(base, finalParamValues);
                    context.setPropertyResolved(true);
                    return retValue;
                }  catch (IllegalAccessException e) {
                    throw new ELException(e);
                } catch (InvocationTargetException e) {
                    throw new ELException(e.getCause());
                }
            }
        });
        return resolver;
    }

              context.getConstraintDescriptor().getAttributes(), locale, context.getValidatedValue());
                                      Locale locale, Object validatedValue) {
        resolvedMessage = replaceAnnotationAttributes(resolvedMessage, annotationParameters);

        final ELResolver resolver = initResolver();
        final BValELContext context = new BValELContext(resolver);
        final VariableMapper variables = context.getVariableMapper();
        for (final Map.Entry<String, Object> var : annotationParameters.entrySet()) {
            variables.setVariable(var.getKey(), new ValueExpressionLiteral(var.getValue()));
        }
        variables.setVariable("validatedValue", new ValueExpressionLiteral(validatedValue));

        try {
            if (EXPRESSION_FACTORY != null) {
                final String tmp = resolvedMessage.replace("#{", "\\#{"); // shouldn't be evaluated
                resolvedMessage = EXPRESSION_FACTORY.createValueExpression(context, tmp, String.class).getValue(context).toString();
            }
        } catch (final Exception e) {
            // no-op
        }
        resolvedMessage = resolvedMessage.replace( "\\{", "{" ).replace( "\\}", "}" ).replace( "\\\\", "\\" ).replace( "\\$", "$" );
        final Matcher matcher = messageParameterPattern.matcher(message);
        final StringBuffer sb = new StringBuffer(64);
            final String parameter = matcher.group(1);
    private String replaceAnnotationAttributes(final String message,
                                               final Map<String, Object> annotationParameters) {
                    parameterValue = replaceVariables(parameterValue, bundle, locale, recurse);
        } catch (final MissingResourceException e) {

    private static class BValELContext extends ELContext {
        private final ELResolver resolver;
        private final FunctionMapper functions;
        private final VariableMapper variables;

        public BValELContext(final ELResolver resolver) {
            this.resolver = resolver;
            this.variables = new BValVariableMapper();
            this.functions = new BValFunctionMapper();
        }

        @Override
        public ELResolver getELResolver() {
            return resolver;
        }

        @Override
        public FunctionMapper getFunctionMapper() {
            return functions;
        }

        @Override
        public VariableMapper getVariableMapper() {
            return variables;
        }
    }

    private static class BValFunctionMapper extends FunctionMapper {
        @Override
        public Method resolveFunction(final String prefix, final String localName) {
            return null;
        }
    }

    private static class BValVariableMapper extends VariableMapper {
        private final Map<String, ValueExpression> variables = new HashMap<String, ValueExpression>();

        @Override
        public ValueExpression resolveVariable(final String variable) {
            if ("formatter".equals(variable)) {
                return new ValueExpressionLiteral(new BValFormatter());
            }
            return variables.get(variable);
        }

        @Override
        public ValueExpression setVariable(final String variable, final ValueExpression expression) {
            variables.put(variable, expression);
            return expression;
        }
    }

    // used to not expose all method and avoid ambiguity with format(Local, String, Object...) in EL
    public static class BValFormatter {
        private final Formatter formatter = new Formatter();

        public Formatter format(final String format, final Object ... args) {
            return formatter.format(format, args);
        }
    }

    private static final class ValueExpressionLiteral extends ValueExpression {
        private final Object value;

        public ValueExpressionLiteral(final Object value) {
            this.value = value;
        }

        @Override
        public Object getValue(final ELContext context) {
            return value;
        }

        @Override
        public void setValue(final ELContext context, final Object value) {
            throw new PropertyNotWritableException(value.toString());
        }

        @Override
        public boolean isReadOnly(final ELContext context) {
            return true;
        }

        @Override
        public Class<?> getType(final ELContext context) {
            return (this.value != null) ? this.value.getClass() : null;
        }

        @Override
        public Class<?> getExpectedType() {
            return String.class;
        }

        @Override
        public String getExpressionString() {
            return (this.value != null) ? this.value.toString() : null;
        }

        @Override
        public boolean equals(Object obj) {
            return (obj instanceof ValueExpressionLiteral && this
                    .equals((ValueExpressionLiteral) obj));
        }

        public boolean equals(final ValueExpressionLiteral ve) {
            return (ve != null && (this.value != null && ve.value != null && (this.value == ve.value || this.value
                    .equals(ve.value))));
        }

        @Override
        public int hashCode() {
            return (this.value != null) ? this.value.hashCode() : 0;
        }

        @Override
        public boolean isLiteralText() {
            return true;
        }
    }
import org.apache.bval.jsr303.groups.Group;
import javax.validation.ConstraintDeclarationException;
import javax.validation.metadata.GroupConversionDescriptor;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArraySet;
    private final Set<GroupConversionDescriptor> groupConversions = new CopyOnWriteArraySet<GroupConversionDescriptor>();
    private boolean cascaded;
    private final Map<Group, Group> groupMapping = new HashMap<Group, Group>();

     *
    public Set<ConstraintDescriptor<?>> getMutableConstraintDescriptors() {

    public void addGroupMapping(final Group from, final Group to) {
        groupMapping.put(from, to);
    }

    public Group mapGroup(final Group current) {
        final Group mapping = groupMapping.get(current);
        if (mapping != null) {
            return mapping;
        }
        return current;
    }

    public Set<GroupConversionDescriptor> getGroupConversions() {
        return groupConversions;
    }

    public void addGroupConversion(final GroupConversionDescriptor descriptor) {
        groupConversions.add(descriptor);
        final Group from = new Group(descriptor.getFrom());
        if (mapGroup(from) != from) { // ref == is fine
            throw new ConstraintDeclarationException("You can't map twice from the same group");
        }
        addGroupMapping(from, new Group(descriptor.getTo()));
    }

    public boolean isCascaded() {
        return cascaded;
    }

    public void setCascaded(final boolean cascaded) {
        this.cascaded = cascaded;
    }
import javax.validation.ElementKind;
import javax.validation.ParameterNameProvider;
import javax.validation.Path;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
    void setCurrentGroups(Groups groups);

    void setKind(ElementKind type);

    ElementKind getElementKind();

    Object getReturnValue();

    Object[] getParameters();

    void setParameters(Object[] parameters);

    void setReturnValue(Object returnValue);

    ParameterNameProvider getParameterNameProvider();

    void setMethod(Method method);

    Method getMethod();

    void setConstructor(Constructor<?> method);

    Constructor<?> getConstructor();

    void moveDown(Path.Node node);
import javax.validation.ElementKind;
import javax.validation.ParameterNameProvider;
import javax.validation.Path;
import javax.validation.ValidationException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
    private final ParameterNameProvider parameterNameProvider;
    private Object[] parameters;
    private Object returnValue;
    private Method method;
    private Constructor<?> constructor;

     *
     * @param parameterNameProvider
                                      TraversableResolver traversableResolver, ParameterNameProvider parameterNameProvider, MetaBean rootMetaBean) {
        this.parameterNameProvider = parameterNameProvider;
        this.path = PathImpl.create();
    public void setKind(final ElementKind type) {
        path.getLeafNode().setKind(type);
    }

        moveDown(prop.getName());
    @Override
    public void moveDown(final String prop) {
        path.addProperty(prop);
    }

    public void moveDown(final Path.Node node) {
        path.addNode(node);
    }

    public void setCurrentGroups(final Groups g) {
        groups = g;
    }

    public <T> T unwrap(Class<T> type) {
        if (type.isInstance(this)) {
            return type.cast(this);
        }
        throw new ValidationException("Type "  type  " not supported");
    }


    public ElementKind getElementKind() {
        return path.getLeafNode().getKind();
    }

    public Object getReturnValue() {
        return returnValue;
    }

    public Object[] getParameters() {
        return parameters;
    }

    public void setParameters(final Object[] parameters) {
        this.parameters = parameters;
    }

    public void setReturnValue(final Object returnValue) {
        this.returnValue = returnValue;
    }

    public ParameterNameProvider getParameterNameProvider() {
        return parameterNameProvider;
    }

    public void setMethod(final Method method) {
        this.method = method;
    }

    public Method getMethod() {
        return method;
    }

    public Constructor<?> getConstructor() {
        return constructor;
    }

    public void setConstructor(final Constructor<?> constructor) {
        this.constructor = constructor;
    }
    interface Method extends Features.Property {
        String MethodDescriptor = "MethodDescriptor";
    }

    interface Constructor extends Features.Property {
        String ConstructorDescriptor = "ConstructorDescriptor";
    }


        // Collection<Annotation>
        String ANNOTATIONS_TO_PROCESS = "annotationToProcess";
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.util.ClassHelper;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.jsr303.xml.MetaConstraint;
import org.apache.bval.model.Meta;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaConstructor;
import org.apache.bval.model.MetaMethod;
import org.apache.bval.model.MetaParameter;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;

import javax.validation.Constraint;
import javax.validation.ConstraintDeclarationException;
import javax.validation.GroupDefinitionException;
import javax.validation.GroupSequence;
import javax.validation.groups.ConvertGroup;
import javax.validation.groups.Default;
import javax.validation.metadata.PropertyDescriptor;
import java.io.Serializable;
import java.lang.annotation.ElementType;
import java.lang.reflect.Constructor;
import java.util.Collection;
                if (eachClass == Serializable.class || eachClass == Cloneable.class) {
                    continue;
                }

            annotationProcessor.processAnnotations(null, beanClass, beanClass, null, new AppendValidationToMeta(metabean));
        final Collection<String> missingValid = new ArrayList<String>();

        for (final Field field : fields) {

                if (field.getAnnotation(ConvertGroup.class) != null) {
                    missingValid.add(field.getName());
                }
        for (final Method method : methods) {

        for (final String name : missingValid) {
            final MetaProperty metaProperty = metabean.getProperty(name);
            if (metaProperty != null && metaProperty.getFeature(Jsr303Features.Property.REF_CASCADE) == null) {
                throw new ConstraintDeclarationException("@ConvertGroup needs @Valid");
            }
        }
        missingValid.clear();
        for (final MetaConstraint<?, ? extends Annotation> metaConstraint : factoryContext.getFactory().getMetaConstraints(beanClass)) {
            Meta meta;
            AccessStrategy access = metaConstraint.getAccessStrategy();
                meta = null;
            } else if (access.getElementType() == ElementType.METHOD && !metaConstraint.getMember().getName().startsWith("get")) { // TODO: better getter test
                final Method method = Method.class.cast(metaConstraint.getMember());
                meta = metabean.getMethod(method);
                final MetaMethod metaMethod;
                if (meta == null) {
                    meta = new MetaMethod(metabean, method);
                    metaMethod = MetaMethod.class.cast(meta);
                    metabean.addMethod(method, metaMethod);
                } else {
                    metaMethod = MetaMethod.class.cast(meta);
                }
                final Integer index = metaConstraint.getIndex();
                if (index != null && index >= 0) {
                    MetaParameter param = metaMethod.getParameter(index);
                    if (param == null) {
                        param = new MetaParameter(metaMethod, index);
                        metaMethod.addParameter(index, param);
                    }
                    param.addAnnotation(metaConstraint.getAnnotation());
                } else {
                    metaMethod.addAnnotation(metaConstraint.getAnnotation());
                }
                continue;
            } else if (access.getElementType() == ElementType.CONSTRUCTOR){
                final Constructor<?> constructor = Constructor.class.cast(metaConstraint.getMember());
                meta = metabean.getConstructor(constructor);
                final MetaConstructor metaConstructor;
                if (meta == null) {
                    meta = new MetaConstructor(metabean, constructor);
                    metaConstructor = MetaConstructor.class.cast(meta);
                    metabean.addConstructor(constructor, metaConstructor);
                } else {
                    metaConstructor = MetaConstructor.class.cast(meta);
                }
                final Integer index = metaConstraint.getIndex();
                if (index != null && index >= 0) {
                    MetaParameter param = metaConstructor.getParameter(index);
                    if (param == null) {
                        param = new MetaParameter(metaConstructor, index);
                        metaConstructor.addParameter(index, param);
                    }
                    param.addAnnotation(metaConstraint.getAnnotation());
                } else {
                    metaConstructor.addAnnotation(metaConstraint.getAnnotation());
                }
                continue;
                meta = metabean.getProperty(access.getPropertyName());
                create = meta == null;
                    meta = addMetaProperty(metabean, access);
            if (!annotationProcessor.processAnnotation(metaConstraint.getAnnotation(), meta, beanClass,
                metaConstraint.getAccessStrategy(), new AppendValidationToMeta(meta == null ? metabean : meta), false)
        for (final AccessStrategy access : factoryContext.getFactory().getValidAccesses(beanClass)) {
            if (access.getElementType() == ElementType.PARAMETER) {
                continue;
            }

        for (final Class<?> groupClass : groupClasses) {
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/MethodDescriptor.java
package org.apache.bval.jsr303;
import javax.validation.metadata.ParameterDescriptor;
     * Get the {@link javax.validation.metadata.ParameterDescriptor}s for this {@link org.apache.bval.jsr303.MethodDescriptor}.
     * @return {@link java.util.List} of {@link javax.validation.metadata.ParameterDescriptor}
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ParameterAccess.java
package org.apache.bval.jsr303;
 * Implementation of {@link org.apache.bval.util.AccessStrategy} for method parameters.
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ProcedureDescriptor.java
package org.apache.bval.jsr303;
import org.apache.bval.jsr303.groups.Group;
import javax.validation.metadata.ParameterDescriptor;
 * Description: superinterface of {@link javax.validation.metadata.ConstructorDescriptor} and {@link org.apache.bval.jsr303.MethodDescriptor}.<br/>
     * @return {@link java.util.List} of {@link javax.validation.metadata.ParameterDescriptor}

    void addGroupMapping(Group from, Group to);

    Group mapGroup(Group current);
import javax.validation.metadata.GroupConversionDescriptor;
import java.util.Set;
 *
 * TODO: use it instead of MetaProperty!
 b/bval-jsr303/src/main/java/org/apache/bval/jsr303/ReturnAccess.java
package org.apache.bval.jsr303;
 * Implementation of {@link org.apache.bval.util.AccessStrategy} for method return values.
    public boolean equals(final Object o) {
        return this == o || o instanceof Group && ObjectUtils.equals(group, ((Group) o).group);
        for (final Class<?> clazz : groups) {
            if (clazz == null) {
                throw new IllegalArgumentException("At least one group has to be specified.");
            }

                throw new ValidationException("A group has to be an interface. "  clazz.getName()  " is not.");
import java.io.Serializable;
        if (clazz == null || clazz == Object.class || clazz == Serializable.class) {
import javax.validation.ConstraintTarget;
    public static void validateConstraintDefinition(final Annotation annotation) {
        final Class<? extends Annotation> type = annotation.annotationType();

        ConstraintAnnotationAttributes.GROUPS.validateOn(type);
        ConstraintAnnotationAttributes.PAYLOAD.validateOn(type);
        ConstraintAnnotationAttributes.MESSAGE.validateOn(type);
        ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.validateOn(type);

        final Object defaultValidationApplies = ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getDefaultValue(type);
        if (ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.isDeclaredOn(type) && !ConstraintTarget.IMPLICIT.equals(defaultValidationApplies)) {
            throw new ConstraintDefinitionException("validationAppliesTo default value should be IMPLICIT");
        }

        /*
        */
import javax.validation.ElementKind;
 * Description: implementation of {@link javax.validation.ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext}.<br/>
        node.setKind(ElementKind.PROPERTY);
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addNode(String name) {
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(String name) {
        propertyPath.addNode(node);
        node = new NodeImpl.PropertyNodeImpl(name);
        node.setKind(ElementKind.PROPERTY);
        return null;
    }

    public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext addBeanNode() {
        propertyPath.addNode(node);
        node = new NodeImpl((String) null);
        node.setKind(ElementKind.BEAN);
        return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
    }

import javax.validation.ElementKind;
import javax.validation.Path;
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addNode(String name) {
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(String name) {
        return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, name);
    }

    public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext addBeanNode() {
        final NodeImpl node = new NodeImpl((String) null);
        node.setKind(ElementKind.BEAN);
        propertyPath.addNode(node);
        return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
    }

import javax.validation.ElementKind;
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(String name) {
        propertyPath.addProperty(name);
        return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, node.getName());
    }

    public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext addBeanNode() {
        return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
    }

import javax.validation.ElementKind;
import java.util.List;
 *
 * TODO: split it in several impl
public class NodeImpl implements Path.Node, Serializable {
    private List<Class<?>> parameterTypes;
    private int parameterIndex;
    private ElementKind kind;
    public  NodeImpl(String name) {
        this.kind = node.getKind();
    public void setParameterIndex(final Integer parameterIndex) {
        this.parameterIndex = parameterIndex;
    }

    public ElementKind getKind() {
        return kind;
    }

    public void setKind(ElementKind kind) {
        this.kind = kind;
    }

    public <T extends Node> T as(final Class<T> nodeType) {
        if (nodeType.isInstance(this)) {
            return nodeType.cast(this);
        }
        throw new ClassCastException("Type "  nodeType  " not supported");
    }

        if (kind != null ? !kind.equals(node.kind) : node.kind != null) {
            return false;
        }
        result = 31 * result  (kind != null ? kind.hashCode() : 0);

    public int getParameterIndex() {
        return parameterIndex;
    }

    public List<Class<?>> getParameterTypes() {
        return parameterTypes;
    }

    public void setParameterTypes(final List<Class<?>> parameterTypes) {
        this.parameterTypes = parameterTypes;
    }

    public static class ParameterNodeImpl extends NodeImpl implements Path.ParameterNode {
        public ParameterNodeImpl(final Node cast) {
            super(cast);
            if (ParameterNodeImpl.class.isInstance(cast)) {
                setParameterIndex(ParameterNodeImpl.class.cast(cast).getParameterIndex());
            }
        }

        public ParameterNodeImpl(final String name, final int idx) {
            super(name);
            setParameterIndex(idx);
        }

        public ElementKind getKind() {
            return ElementKind.PARAMETER;
        }
    }

    public static class ConstructorNodeImpl extends NodeImpl implements Path.ConstructorNode {
        public ConstructorNodeImpl(final Node cast) {
            super(cast);
            if (NodeImpl.class.isInstance(cast)) {
                setParameterTypes(NodeImpl.class.cast(cast).parameterTypes);
            }
        }

        public ConstructorNodeImpl(final String simpleName, List<Class<?>> paramTypes) {
            super(simpleName);
            setParameterTypes(paramTypes);
        }

        public ElementKind getKind() {
            return ElementKind.CONSTRUCTOR;
        }
    }

    public static class CrossParameterNodeImpl extends NodeImpl implements Path.CrossParameterNode {
        public CrossParameterNodeImpl() {
            super("<cross-parameter>");
        }

        public CrossParameterNodeImpl(final Node cast) {
            super(cast);
        }

        public ElementKind getKind() {
            return ElementKind.CROSS_PARAMETER;
        }
    }

    public static class MethodNodeImpl extends NodeImpl implements Path.MethodNode {
        public MethodNodeImpl(final Node cast) {
            super(cast);
            if (MethodNodeImpl.class.isInstance(cast)) {
                setParameterTypes(MethodNodeImpl.class.cast(cast).getParameterTypes());
            }
        }

        public MethodNodeImpl(final String name, final List<Class<?>> classes) {
            super(name);
            setParameterTypes(classes);
        }

        public ElementKind getKind() {
            return ElementKind.METHOD;
        }
    }

    public static class ReturnValueNodeImpl extends NodeImpl implements Path.ReturnValueNode {
        public ReturnValueNodeImpl(final Node cast) {
            super(cast);
        }

        public ReturnValueNodeImpl() {
            super("<return value>");
        }

        public ElementKind getKind() {
            return ElementKind.RETURN_VALUE;
        }
    }

    public static class PropertyNodeImpl extends NodeImpl implements Path.PropertyNode {
        public PropertyNodeImpl(final String name) {
            super(name);
        }

        public PropertyNodeImpl(final Node cast) {
            super(cast);
        }

        public ElementKind getKind() {
            return ElementKind.PROPERTY;
        }
    }

    public static class BeanNodeImpl extends NodeImpl implements Path.BeanNode {
        public BeanNodeImpl() {
            // no-op
        }

        public BeanNodeImpl(final Node cast) {
            super(cast);
        }

        public ElementKind getKind() {
            return ElementKind.BEAN;
        }
    }
            return create();
     *
    public static PathImpl create() {
        final PathImpl path = new PathImpl();
        final NodeImpl node = new NodeImpl.BeanNodeImpl();
        for (final Object aPath : path) {
            nodeList.add(newNode(Node.class.cast(aPath)));
    private static Node newNode(final Node cast) {
        if (PropertyNode.class.isInstance(cast)) {
            return new NodeImpl.PropertyNodeImpl(cast);
        }
        if (BeanNode.class.isInstance(cast)) {
            return new NodeImpl.BeanNodeImpl(cast);
        }
        if (MethodNode.class.isInstance(cast)) {
            return new NodeImpl.MethodNodeImpl(cast);
        }
        if (ConstructorNode.class.isInstance(cast)) {
            return new NodeImpl.ConstructorNodeImpl(cast);
        }
        if (ConstructorNode.class.isInstance(cast)) {
            return new NodeImpl.ConstructorNodeImpl(cast);
        }
        if (ReturnValueNode.class.isInstance(cast)) {
            return new NodeImpl.ReturnValueNodeImpl(cast);
        }
        if (ParameterNode.class.isInstance(cast)) {
            return new NodeImpl.ParameterNodeImpl(cast);
        }
        if (CrossParameterNode.class.isInstance(cast)) {
            return new NodeImpl.CrossParameterNodeImpl(cast);
        }
        return new NodeImpl(cast);
    }

            if (leaf != null && leaf.isInIterable() && leaf.getName() == null) { // TODO: avoid to be here
                if (!PropertyNode.class.isInstance(leaf)) {
                    final NodeImpl tmp = new NodeImpl.PropertyNodeImpl(leaf);
                    removeLeafNode();
                    addNode(tmp);
                    leaf = tmp;
                }

        final NodeImpl node;
        if ("<cross-parameter>".equals(name)) {
            node = new NodeImpl.CrossParameterNodeImpl();
        } else {
            node = new NodeImpl.PropertyNodeImpl(name);
        }
        addNode(node);

import org.apache.bval.jsr303.ConfigurationImpl;
import org.apache.bval.util.PrivilegedActions;

import javax.validation.ValidatorFactory;
import java.lang.reflect.Constructor;
    public static PrivilegedAction<Constructor<?>> getDeclaredConstructor(final Class<?> clazz, final Class<?>... parameters) {
      return new PrivilegedAction<Constructor<?>>() {
          public Constructor<?> run() {
              try {
                  return clazz.getDeclaredConstructor(parameters);
              } catch (final NoSuchMethodException e) {
                  return null;
              }
          }
    public static PrivilegedAction<Method> getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>... parameters) {
        return new PrivilegedAction<Method>() {
            public Method run() {
                try {
                    return clazz.getDeclaredMethod(name, parameters);
                } catch (final NoSuchMethodException e) {
                    return null;
                }
            }
        };
    }

    public static PrivilegedAction<Method[]> getDeclaredMethods(final Class<?> clazz) {
        // XXX 2011-03-27 jw: Inconsistent behaviour.
        // doGetDeclaredFields() is setting fields accessible, but here we don't.
        return new PrivilegedAction<Method[]>() {
            public Method[] run() {
                return clazz.getDeclaredMethods();
            }
        };
    }

    public static PrivilegedAction<Constructor<?>[]> getDeclaredConstructors(final Class<?> clazz) {
        return new PrivilegedAction<Constructor<?>[]>() {
            public Constructor<?>[] run() {
                return clazz.getDeclaredConstructors();
            }
        };
    }

    private final Map<Class<?>, Map<Member, Boolean>> ignoreAnnotationOnMember = new HashMap<Class<?>, Map<Member, Boolean>>();
    private final Map<Class<?>, Boolean> ignoreAnnotationOnClass = new HashMap<Class<?>, Boolean>();

    private final Map<Class<?>, Map<Member, Map<Integer, Boolean>>> ignoreAnnotationOnParameter = new HashMap<Class<?>, Map<Member, Map<Integer, Boolean>>>();
    private final Map<Member, Boolean> ignoreAnnotationOnReturn = new HashMap<Member, Boolean>();
    private final Map<Member, Boolean> ignoreAnnotationOnCrossParameter = new HashMap<Member, Boolean>();
    public void setIgnoreAnnotationsOnMember(Member member, boolean value) {
        Map<Member, Boolean> memberList = ignoreAnnotationOnMember.get(beanClass);
            memberList = new HashMap<Member, Boolean>();
        memberList.put(member, value);
    public boolean isIgnoreAnnotations(final Member member) {
        final Class<?> clazz = member.getDeclaringClass();
        final Map<Member, Boolean> ignoreAnnotationForMembers = ignoreAnnotationOnMember.get(clazz);
        if (ignoreAnnotationForMembers != null && ignoreAnnotationForMembers.containsKey(member)) {
            final boolean value = ignoreAnnotationForMembers.get(member);
            if (value) {
                logMessage(member, clazz);
            }
            return value;

        final boolean ignoreAnnotation = getDefaultIgnoreAnnotation(clazz);
    public void setIgnoreAnnotationsOnParameter(final Member method, final int i, final boolean value) {
        final Class<?> beanClass = method.getDeclaringClass();
        Map<Member, Map<Integer, Boolean>> memberList = ignoreAnnotationOnParameter.get(beanClass);
        if (memberList == null) {
            memberList = new HashMap<Member, Map<Integer, Boolean>>();
            ignoreAnnotationOnParameter.put(beanClass, memberList);
        }
        Map<Integer, Boolean> indexes = memberList.get(method);
        if (indexes == null) {
            indexes = new HashMap<Integer, Boolean>();
            memberList.put(method, indexes);
        }
        indexes.put(i, value);
    }

    public boolean isIgnoreAnnotationOnParameter(final Member m, final int i) {
        final Map<Member, Map<Integer, Boolean>> members = ignoreAnnotationOnParameter.get(m.getDeclaringClass());
        if (members != null) {
            final Map<Integer, Boolean> indexes = members.get(m);
            if (indexes != null && indexes.containsKey(i)) {
                return indexes.get(i);
            }
        }
        return false;
    }


    public void setIgnoreAnnotationOnReturn(final Member method, final boolean value) {
        ignoreAnnotationOnReturn.put(method, value);
    }

    public boolean isIgnoreAnnotationOnReturn(final Member m) {
        final Boolean value = ignoreAnnotationOnReturn.get(m);
        if (value != null) {
            return value;
        }
        return false;
    }

    public void setIgnoreAnnotationOnCrossParameter(final Member method, final boolean value) {
        ignoreAnnotationOnCrossParameter.put(method, value);
    }

    public boolean isIgnoreAnnotationOnCrossParameter(final Member m) {
        final Boolean value = ignoreAnnotationOnCrossParameter.get(m);
        if (value != null) {
            return value;
        }
        return false;
    }
import javax.validation.Valid;

        if (processedValuesFromDescriptor != descriptor.size()
                && !Valid.class.equals(annotationType)) {
import org.apache.bval.jsr303.ConstraintAnnotationAttributes;
import org.apache.bval.jsr303.util.SecureActions;

import javax.validation.Payload;
import javax.validation.Valid;
import javax.validation.ValidationException;
import javax.validation.groups.ConvertGroup;


    public static final class ValidAnnotation implements Valid {
        public static final ValidAnnotation INSTANCE = new ValidAnnotation();

        public Class<? extends Annotation> annotationType() {
            return Valid.class;
        }
    }

    public static final class ConverGroupAnnotation implements ConvertGroup {
        private final Class<?> from;
        private final Class<?> to;

        public ConverGroupAnnotation(final Class<?> from, final Class<?> to) {
            this.from = from;
            this.to = to;
        }

        public Class<? extends Annotation> annotationType() {
            return ConvertGroup.class;
        }

        public Class<?> from() {
            return from;
        }

        public Class<?> to() {
            return to;
        }
    }
import org.apache.bval.ConstructorAccess;
import java.lang.reflect.Constructor;
    private Integer index; // for parameters

            /*TODO: see if can really be removed
            if (accessStrategy == null || accessStrategy.getPropertyName() == null) { // can happen if method does not follow the bean convention
                throw new ValidationException("Annotated method does not follow the JavaBeans naming convention: "  member);
            */
        } else if (member instanceof Constructor<?>) {
            return new ConstructorAccess((Constructor<?>) member);

    public Integer getIndex() {
        return index;
    }

    public void setIndex(final int index) {
        this.index = index;
    }
import javax.validation.Constraint;
import javax.validation.ConstraintValidator;
import javax.validation.Payload;
import javax.validation.ValidationException;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
    private static final String VALIDATION_MAPPING_XSD = "META-INF/validation-mapping-1.1.xsd";
        ConstraintAnnotationAttributes.PAYLOAD, ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO));
        for (final InputStream xmlStream : xmlStreams) {
            final String defaultPackage = mapping.getDefaultPackage();
            for (final BeanType bean : mapping.getBean()) {

                boolean ignoreAnnotations = bean.getIgnoreAnnotations() == null ? true : bean.getIgnoreAnnotations();
                factory.getAnnotationIgnores().setDefaultIgnoreAnnotation(beanClass, ignoreAnnotations);
                processConstructorLevel(bean.getConstructor(), beanClass, defaultPackage, ignoreAnnotations);
                processFieldLevel(bean.getField(), beanClass, defaultPackage, ignoreAnnotations);
                final Collection<String> potentialMethodName = processPropertyLevel(bean.getGetter(), beanClass, defaultPackage, ignoreAnnotations);
                processMethodLevel(bean.getMethod(), beanClass, defaultPackage, ignoreAnnotations, potentialMethodName);
            throw new ValidationException("Failed to parse XML deployment descriptor file.", e);
            try {
                in.reset(); // can be read several times  we ensured it was re-readable in addMapping()
            } catch (final IOException e) {
                // no-op
            }
        if (classType.getIgnoreAnnotations() != null) {
            factory.getAnnotationIgnores().setIgnoreAnnotationsOnClass(beanClass, classType.getIgnoreAnnotations());
            final ConstraintType constraint, final Class<T> beanClass,
            final Member member, final String defaultPackage) {

        final Class<A> annotationClass = (Class<A>) loadClass(constraint.getAnnotation(), defaultPackage);
        final AnnotationProxyBuilder<A> annoBuilder = new AnnotationProxyBuilder<A>(annotationClass);
        for (final ElementType elementType : constraint.getElement()) {
            final String name = elementType.getName();

            final Class<?> returnType = getAnnotationParameterType(annotationClass, name);
            final Object elementValue = getElementValue(elementType, returnType, defaultPackage);
        } else if (Byte.class.equals(returnType) || byte.class.equals(returnType)) { // spec mandates it
            return Byte.parseByte(value);
        } else if (Short.class.equals(returnType) || short.class.equals(returnType)) {
            return Short.parseShort(value);
        } else if (Integer.class.equals(returnType) || int.class.equals(returnType)) {
            return Integer.parseInt(value);
        } else if (Long.class.equals(returnType) || long.class.equals(returnType)) {
            return Long.parseLong(value);
        } else if (Float.class.equals(returnType) || float.class.equals(returnType)) {
            return Float.parseFloat(value);
        } else if (Double.class.equals(returnType) || double.class.equals(returnType)) {
            return Double.parseDouble(value);
        } else if (Boolean.class.equals(returnType) || boolean.class.equals(returnType)) {
            return Boolean.parseBoolean(value);
        } else if (Character.class.equals(returnType) || char.class.equals(returnType)) {
            if (value.length() > 1) {
                throw new IllegalArgumentException("a char has a length of 1");
            }
            return value.charAt(0);
        for (String groupClass : groupsType.getValue()) {
            groupList.add(loadClass(groupClass, defaultPackage));
        for (String groupClass : payloadType.getValue()) {
            Class<?> payload = loadClass(groupClass, defaultPackage);
            for (String groupName : groupSequenceType.getValue()) {
                Class<?> group = loadClass(groupName, defaultPackage);
    private <A> void processMethodLevel(final List<MethodType> methods, final Class<A> beanClass, final String defaultPackage, final boolean parentIgnoreAnn, final Collection<String> getters) {
        final List<String> methodNames = new ArrayList<String>();
        for (final MethodType methodType : methods) {
            final String methodName = methodType.getName();
            if (methodNames.contains(methodName) || getters.contains(methodName)) {
                throw new ValidationException(methodName  " is defined more than once in mapping xml for bean "  beanClass.getName());
            } else {
                methodNames.add(methodName);
            }
            final Method method = doPrivileged(SecureActions.getDeclaredMethod(beanClass, methodName, toTypes(methodType.getParameter(), defaultPackage)));
            if (method == null) {
                throw new ValidationException(beanClass.getName()  " does not contain the method  "  methodName);
            }

            // ignore annotations
            final boolean ignoreMethodAnnotation = methodType.getIgnoreAnnotations() == null ? parentIgnoreAnn : methodType.getIgnoreAnnotations();
            factory.getAnnotationIgnores().setIgnoreAnnotationsOnMember(method, ignoreMethodAnnotation);

            final boolean ignoreAnn;
            if (methodType.getIgnoreAnnotations() != null) {
                ignoreAnn = methodType.getIgnoreAnnotations();
            } else {
                ignoreAnn = parentIgnoreAnn;
            }

            // constraints
            int i = 0;
            for (final ParameterType p : methodType.getParameter()) {
                for (final ConstraintType constraintType : p.getConstraint()) {
                    final MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, method, defaultPackage);
                    constraint.setIndex(i);
                    factory.addMetaConstraint(beanClass, constraint);
                }
                if (p.getValid() != null) {
                    final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                    constraint.setIndex(i);
                    factory.addMetaConstraint(beanClass, constraint);
                }

                if (p.getConvertGroup() != null) {
                    for (final GroupConversionType groupConversion : p.getConvertGroup()) {
                        final Class<?> from = loadClass(groupConversion.getFrom(), defaultPackage);
                        final Class<?> to = loadClass(groupConversion.getTo(), defaultPackage);
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConverGroupAnnotation(from, to));
                        constraint.setIndex(i);
                        factory.addMetaConstraint(beanClass, constraint);
                    }
                }

                boolean ignoreParametersAnnotation = p.getIgnoreAnnotations() == null ? ignoreMethodAnnotation : p.getIgnoreAnnotations();
                factory.getAnnotationIgnores().setIgnoreAnnotationsOnParameter(method, i, ignoreParametersAnnotation);

                i;
            }

            final ReturnValueType returnValue = methodType.getReturnValue();
            if (returnValue != null) {
                for (final ConstraintType constraintType : returnValue.getConstraint()) {
                    final MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, method, defaultPackage);
                    factory.addMetaConstraint(beanClass, constraint);
                }
                if (returnValue.getValid() != null) {
                    final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                    factory.addMetaConstraint(beanClass, constraint);
                }

                if (returnValue.getConvertGroup() != null) {
                    for (final GroupConversionType groupConversion : returnValue.getConvertGroup()) {
                        final Class<?> from = loadClass(groupConversion.getFrom(), defaultPackage);
                        final Class<?> to = loadClass(groupConversion.getTo(), defaultPackage);
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConverGroupAnnotation(from, to));
                        factory.addMetaConstraint(beanClass, constraint);
                    }
                }
                factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(method, returnValue.getIgnoreAnnotations() == null ? ignoreAnn : returnValue.getIgnoreAnnotations());
            }

            final CrossParameterType crossParameter = methodType.getCrossParameter();
            if (crossParameter != null) {
                for (final ConstraintType constraintType : crossParameter.getConstraint()) {
                    final MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, method, defaultPackage);
                    factory.addMetaConstraint(beanClass, constraint);
                }
                factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(method, crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
            }
        }
    }

    private <A> void processConstructorLevel(final List<ConstructorType> constructors, final Class<A> beanClass, final String defaultPackage, final boolean parentIgnore) {
        for (final ConstructorType constructorType : constructors) {
            final Constructor<?> constructor = doPrivileged(SecureActions.getDeclaredConstructor(beanClass, toTypes(constructorType.getParameter(), defaultPackage)));
            if (constructor == null) {
                throw new ValidationException(beanClass.getName()  " does not contain the constructor  "  constructorType);
            }

            // ignore annotations
            final boolean ignoreMethodAnnotation = constructorType.getIgnoreAnnotations() == null ? parentIgnore : constructorType.getIgnoreAnnotations();
            factory.getAnnotationIgnores().setIgnoreAnnotationsOnMember(constructor, ignoreMethodAnnotation);

            final boolean ignoreAnn;
            if (constructorType.getIgnoreAnnotations() != null) {
                ignoreAnn = constructorType.getIgnoreAnnotations();
            } else {
                ignoreAnn = parentIgnore;
            }

            // constraints
            int i = 0;
            for (final ParameterType p : constructorType.getParameter()) {
                for (final ConstraintType constraintType : p.getConstraint()) {
                    final MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, constructor, defaultPackage);
                    constraint.setIndex(i);
                    factory.addMetaConstraint(beanClass, constraint);
                }
                if (p.getValid() != null) {
                    final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                    constraint.setIndex(i);
                    factory.addMetaConstraint(beanClass, constraint);
                }

                if (p.getConvertGroup() != null) {
                    for (final GroupConversionType groupConversion : p.getConvertGroup()) {
                        final Class<?> from = loadClass(groupConversion.getFrom(), defaultPackage);
                        final Class<?> to = loadClass(groupConversion.getTo(), defaultPackage);
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, new AnnotationProxyBuilder.ConverGroupAnnotation(from, to));
                        constraint.setIndex(i);
                        factory.addMetaConstraint(beanClass, constraint);
                    }
                }

                boolean ignoreParametersAnnotation = p.getIgnoreAnnotations() == null ? ignoreMethodAnnotation : p.getIgnoreAnnotations();
                if (ignoreParametersAnnotation || (ignoreMethodAnnotation && p.getIgnoreAnnotations() == null)) {

                }
                factory.getAnnotationIgnores().setIgnoreAnnotationsOnParameter(constructor, i, p.getIgnoreAnnotations() != null ? p.getIgnoreAnnotations() : ignoreAnn);

                i;
            }

            final ReturnValueType returnValue = constructorType.getReturnValue();
            if (returnValue != null) {
                for (final ConstraintType constraintType : returnValue.getConstraint()) {
                    final MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, constructor, defaultPackage);
                    constraint.setIndex(-1);
                    factory.addMetaConstraint(beanClass, constraint);
                }
                if (returnValue.getValid() != null) {
                    final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                    constraint.setIndex(-1);
                    factory.addMetaConstraint(beanClass, constraint);
                }

                if (returnValue.getConvertGroup() != null) {
                    for (final GroupConversionType groupConversion : returnValue.getConvertGroup()) {
                        final Class<?> from = loadClass(groupConversion.getFrom(), defaultPackage);
                        final Class<?> to = loadClass(groupConversion.getTo(), defaultPackage);
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, new AnnotationProxyBuilder.ConverGroupAnnotation(from, to));
                        constraint.setIndex(-1);
                        factory.addMetaConstraint(beanClass, constraint);
                    }
                }
                factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(constructor, returnValue.getIgnoreAnnotations() != null ? returnValue.getIgnoreAnnotations() : ignoreAnn);
            }

            final CrossParameterType crossParameter = constructorType.getCrossParameter();
            if (crossParameter != null) {
                for (final ConstraintType constraintType : crossParameter.getConstraint()) {
                    final MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, constructor, defaultPackage);
                    factory.addMetaConstraint(beanClass, constraint);
                }
                factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(constructor, crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
            }
        }
    }

    private Class<?>[] toTypes(final List<ParameterType> parameter, final String defaultPck) {
        if (parameter == null) {
            return null;
        }
        final Class<?>[] types = new Class<?>[parameter.size()];
        int i = 0;
        for (final ParameterType type : parameter) {
            types[i] = loadClass(type.getType(), defaultPck);
        }
        return types;
    }

    private <A> void processFieldLevel(List<FieldType> fields, Class<A> beanClass,
                                       String defaultPackage, boolean ignoreAnnotations) {
        final List<String> fieldNames = new ArrayList<String>();
            final boolean ignoreFieldAnnotation = fieldType.getIgnoreAnnotations() == null ? ignoreAnnotations : fieldType.getIgnoreAnnotations();
            factory.getAnnotationIgnores().setIgnoreAnnotationsOnMember(field, ignoreFieldAnnotation);
            for (final GroupConversionType conversion : fieldType.getConvertGroup()) {
                final Class<?> from = loadClass(conversion.getFrom(), defaultPackage);
                final Class<?> to = loadClass(conversion.getTo(), defaultPackage);
                final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, field, new AnnotationProxyBuilder.ConverGroupAnnotation(from, to));
                factory.addMetaConstraint(beanClass, constraint);
            }

    private <A> Collection<String> processPropertyLevel(List<GetterType> getters, Class<A> beanClass,
                                      String defaultPackage, boolean ignoreAnnotatino) {
            final String getterName = getterType.getName();
            final String methodName = "get"  StringUtils.capitalize(getterType.getName());
            if (getterNames.contains(methodName)) {
                getterNames.add(methodName);
            final boolean ignoreGetterAnnotation = getterType.getIgnoreAnnotations() == null ? ignoreAnnotatino : getterType.getIgnoreAnnotations();
            factory.getAnnotationIgnores().setIgnoreAnnotationsOnMember(method, ignoreGetterAnnotation);
            // ConvertGroup
            for (final GroupConversionType conversion : getterType.getConvertGroup()) {
                final Class<?> from = loadClass(conversion.getFrom(), defaultPackage);
                final Class<?> to = loadClass(conversion.getTo(), defaultPackage);
                final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConverGroupAnnotation(from, to));
                factory.addMetaConstraint(beanClass, constraint);
            }


        return getterNames;
            if (validatedByType.getIncludeExistingValidators() != null &&
                  validatedByType.getIncludeExistingValidators()) {
            for (String validatorClassName : validatedByType.getValue()) {
                      loadClass(validatorClassName);
            if (className.startsWith("[L") && className.endsWith(";")) {
                className = "[L"  defaultPackage  "."  className.substring(2);
            } else {
                className = defaultPackage  "."  className;
            }
import org.apache.bval.cdi.BValExtension;
import org.apache.bval.jsr303.BootstrapConfigurationImpl;
import org.apache.bval.jsr303.util.IOs;
import javax.validation.ParameterNameProvider;
import javax.validation.executable.ExecutableType;
import java.io.Closeable;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CopyOnWriteArraySet;
public class ValidationParser implements Closeable {
            "META-INF/validation-configuration-1.1.xsd";
    private ValidationConfigType xmlConfig;
    private BootstrapConfigurationImpl bootstrap;
    private Collection<ValidationException> exceptions = new CopyOnWriteArrayList<ValidationException>();
    private Collection<BValExtension.Releasable> releasables = new CopyOnWriteArrayList<BValExtension.Releasable>();

    private ValidationParser() {
        // no-op
    }

    public void applyConfigWithInstantiation(ConfigurationImpl targetConfig) {
        if (xmlConfig == null) {
            return;

        applyProviderClass(xmlConfig, targetConfig);
        applyMessageInterpolator(xmlConfig, targetConfig);
        applyTraversableResolver(xmlConfig, targetConfig);
        applyConstraintFactory(xmlConfig, targetConfig);
        applyParameterNameProvider(xmlConfig, targetConfig);
        applyMappingStreams(xmlConfig, targetConfig);
        applyProperties(xmlConfig, targetConfig);
    }

    public BootstrapConfigurationImpl getBootstrap() {
        return bootstrap;
    }

    public static String getValidationXmlFile(String file) {
        if (file == null) {
            return DEFAULT_VALIDATION_XML_FILE;
        }
        return file;
    public static ValidationParser processValidationConfig(final String file, final ConfigurationImpl targetConfig, final boolean ignoreXml) {
        final ValidationParser parser = new ValidationParser();

        if (!ignoreXml) {
            parser.xmlConfig = parseXmlConfig(file);

        if (parser.xmlConfig != null) {
            if (parser.xmlConfig.getExecutableValidation() == null) {
                final ExecutableValidationType value = new ExecutableValidationType();
                value.setEnabled(true);

                final DefaultValidatedExecutableTypesType defaultValidatedExecutableTypes = new DefaultValidatedExecutableTypesType();
                value.setDefaultValidatedExecutableTypes(defaultValidatedExecutableTypes);
                defaultValidatedExecutableTypes.getExecutableType().add(ExecutableType.CONSTRUCTORS);
                defaultValidatedExecutableTypes.getExecutableType().add(ExecutableType.NON_GETTER_METHODS);

                parser.xmlConfig.setExecutableValidation(value);
            }

            applySimpleConfig(parser.xmlConfig, targetConfig);

            parser.bootstrap = new BootstrapConfigurationImpl(
                    parser.xmlConfig.getDefaultProvider(),
                    parser.xmlConfig.getConstraintValidatorFactory(),
                    parser.xmlConfig.getMessageInterpolator(),
                    parser.xmlConfig.getTraversableResolver(),
                    parser.xmlConfig.getParameterNameProvider(),
                    new CopyOnWriteArraySet<String>(parser.xmlConfig.getConstraintMapping()),
                    parser.xmlConfig.getExecutableValidation().getEnabled(),
                    new CopyOnWriteArraySet<ExecutableType>(targetConfig.getExecutableValidation()),
                    toMap(parser.xmlConfig.getProperty()));
            return parser;
        } else { // default config
            final CopyOnWriteArraySet<ExecutableType> executableTypes = new CopyOnWriteArraySet<ExecutableType>();
            executableTypes.add(ExecutableType.CONSTRUCTORS);
            executableTypes.add(ExecutableType.NON_GETTER_METHODS);

            parser.bootstrap = new BootstrapConfigurationImpl(
                    null, null, null, null, null,
                    new CopyOnWriteArraySet<String>(),
                    true,
                    executableTypes,
                    new HashMap<String, String>());

            targetConfig.setExecutableValidation(executableTypes);
        }

        return parser;
    private static Map<String, String> toMap(final List<PropertyType> property) {
        final Map<String, String> map = new HashMap<String, String>();
        if (property != null) {
            for (final PropertyType p : property) {
                map.put(p.getName(), p.getValue());
            }
        }
        return map;
    }

    private static ValidationConfigType parseXmlConfig(final String validationXmlFile) {
            inputStream = getInputStream(getValidationXmlFile(validationXmlFile));
    protected static InputStream getInputStream(String path) throws IOException {
        ClassLoader loader = PrivilegedActions.getClassLoader(ValidationParser.class);
        return IOs.convertToMarkableInputStream(inputStream);
    private static Schema getSchema() {
    public static void applySimpleConfig(ValidationConfigType xmlConfig, ConfigurationImpl targetConfig) {
        applyExecutableValidation(xmlConfig, targetConfig);
    private static void applyProperties(ValidationConfigType xmlConfig, ConfigurationImpl target) {
        for (final PropertyType property : xmlConfig.getProperty()) {
    private static void applyExecutableValidation(final ValidationConfigType xmlConfig, final ConfigurationImpl targetConfig) {
        final CopyOnWriteArrayList<ExecutableType> executableTypes = new CopyOnWriteArrayList<ExecutableType>();
        if (xmlConfig.getExecutableValidation() != null && xmlConfig.getExecutableValidation().getEnabled()
                && xmlConfig.getExecutableValidation().getDefaultValidatedExecutableTypes() != null) {
            executableTypes.addAll(xmlConfig.getExecutableValidation().getDefaultValidatedExecutableTypes().getExecutableType());
        }

        if (executableTypes.contains(ExecutableType.ALL)) {
            executableTypes.clear();
            executableTypes.add(ExecutableType.CONSTRUCTORS);
            executableTypes.add(ExecutableType.NON_GETTER_METHODS);
            executableTypes.add(ExecutableType.GETTER_METHODS);
        } else if (executableTypes.contains(ExecutableType.NONE)) { // if both are present ALL gains
            executableTypes.clear();
        }

        targetConfig.setExecutableValidation(executableTypes);
    }

    private void applyParameterNameProvider(final ValidationConfigType xmlConfig, final ConfigurationImpl targetConfig) {
        final String parameterNameProvider = xmlConfig.getParameterNameProvider();
        if (targetConfig.getParameterNameProvider() == targetConfig.getDefaultParameterNameProvider()) { // ref ==
            if (parameterNameProvider != null) {
                final Class<? extends ParameterNameProvider> clazz = Class.class.cast(loadClass(parameterNameProvider));
                targetConfig.parameterNameProvider(newInstance(clazz));
                log.log(Level.INFO, String.format("Using %s as validation provider.", parameterNameProvider));
            }
        }
    }

                (Class<? extends ValidationProvider<?>>) loadClass(providerClassName);
        if (target.getMessageInterpolator() == target.getDefaultMessageInterpolator()) { // ref ==
        if (target.getTraversableResolver() == target.getDefaultTraversableResolver()) { // ref ==
                    try {
                        final BValExtension.Releasable<T> releasable = BValExtension.inject(cls);
                        releasables.add(releasable);
                        return releasable.getInstance();
                    } catch (final Exception e) {
                        return cls.newInstance();
                    } catch (final NoClassDefFoundError error) {
                        return cls.newInstance();
                    }
                    exceptions.add(new ValidationException("Cannot instantiate : "  cls, ex));
                    return null; // ensure BootstrapConfiguration can be read even if class can't be instantiated
        if (target.getConstraintValidatorFactory() == target.getDefaultConstraintValidatorFactory()) { // ref ==
    private static void applyMappingStreams(ValidationConfigType xmlConfig,
        for (String rawMappingFileName : xmlConfig.getConstraintMapping()) {
            String mappingFileName = rawMappingFileName;
            InputStream in;
            loader = ValidationParser.class.getClassLoader();
            // TCK check BootstrapConfig is present in all cases
            // so throw next exception later
            exceptions.add(new ValidationException("Unable to load class: "  className, ex));
            return null;
    public void ensureValidatorFactoryCanBeBuilt() {
        if (!exceptions.isEmpty()) {
            throw  exceptions.iterator().next();
        }
    }

    public void close() throws IOException {
        for (final BValExtension.Releasable<?> releasable : releasables) {
            releasable.release();
        }
        releasables.clear();
    }
                ResourceBundle.getBundle(DEFAULT_VALIDATION_MESSAGES, defaultLocale));
        resolver.add(new BeanELResolver());
                context.getConstraintDescriptor().getAttributes(), locale, context.getValidatedValue());
import org.apache.bval.el.MessageEvaluator;
    private final MessageEvaluator evaluator;

        MessageEvaluator ev = null;
        try {
            ev = MessageEvaluator.class.cast(getClass().getClassLoader().loadClass("org.apache.bval.el.ELFacade").newInstance());
        } catch (final Throwable e) { // can be exception or error
            // no-op
        }
        evaluator = ev;
        // EL handling
        if (evaluator != null) {
            resolvedMessage = evaluator.interpolate(resolvedMessage, annotationParameters, validatedValue);
    protected void configure(final ConfigurationState configuration) {
            if (!impl.isValidated(impl)) {
                checkValidationAppliesTo(impl.getConstraintDescriptors(), ConstraintTarget.PARAMETERS);
                checkValidationAppliesTo(impl.getConstraintDescriptors(), ConstraintTarget.RETURN_VALUE);
                impl.setValidated(impl); // we don't really care about concurrency here
            }
                final ConstraintValidation constraintValidation = ConstraintValidation.class.cast(validation);
                if (!constraintValidation.isValidated()) {
                    checkValidationAppliesTo(constraintValidation.getValidationAppliesTo(), ConstraintTarget.PARAMETERS);
                    checkValidationAppliesTo(constraintValidation.getValidationAppliesTo(), ConstraintTarget.RETURN_VALUE);
                    constraintValidation.setValidated(true);
                }
        if (!constructorDescriptor.isValidated(constructor)) {
            if (parameterValues.length > 0) {
                checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()), ConstraintTarget.IMPLICIT);
                checkValidationAppliesTo(constructorDescriptor.getParameterDescriptors(), ConstraintTarget.IMPLICIT);
            } else {
                checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()), ConstraintTarget.PARAMETERS);
                checkValidationAppliesTo(constructorDescriptor.getParameterDescriptors(), ConstraintTarget.PARAMETERS);
            }
            constructorDescriptor.setValidated(constructor);
        if (!methodDescriptor.isValidated(method)) {
            if (method.getParameterTypes().length > 0 && method.getReturnType() != Void.TYPE) {
                checkValidationAppliesTo(Collections.singleton(methodDescriptor.getCrossParameterDescriptor()), ConstraintTarget.IMPLICIT);
                checkValidationAppliesTo(methodDescriptor.getParameterDescriptors(), ConstraintTarget.IMPLICIT);
            } else if (method.getParameterTypes().length == 0) {
                checkValidationAppliesTo(Collections.singleton(methodDescriptor.getCrossParameterDescriptor()), ConstraintTarget.PARAMETERS);
                checkValidationAppliesTo(methodDescriptor.getParameterDescriptors(), ConstraintTarget.PARAMETERS);
            }
            methodDescriptor.setValidated(method);
    private boolean validated = false;


    public boolean isValidated() {
        return validated;
    }

    public void setValidated(final boolean validated) {
        this.validated = validated;
    }
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;
    private final Collection<Object> validated = new CopyOnWriteArraySet<Object>();

    public boolean isValidated(final Object object) {
        return validated.contains(object);
    }

    public void setValidated(final Object object) {
        this.validated.add(object);
    }
            final String executableTypesStr = getProperties().remove(ApacheValidatorConfiguration.Properties.EXECUTABLE_VALIDATION_TYPES);
        final ConstraintDescriptorImpl that = (ConstraintDescriptorImpl) o;
        if (attributes != null ? !attributes.equals(that.attributes) : that.attributes != null) return false;
        if (groups != null ? !groups.equals(that.groups) : that.groups != null) return false;
        int result = annotation.annotationType().hashCode();
        result = 31 * result  (groups != null ? groups.hashCode() : 0);
        result = 31 * result  (attributes != null ? attributes.hashCode() : 0);
import java.lang.reflect.Member;
            return (T) this;
    protected <T> GroupValidationContext<T> createInvocableContext(MetaBean metaBean, T object, Class<T> objectClass, Class<?>... groups) {
        final ConstraintValidationListener<T> listener = new ConstraintValidationListener<T>(object, objectClass);
        final GroupValidationContextImpl<T> context =
                new GroupValidationContextImpl<T>(listener, this.factoryContext.getMessageInterpolator(),
                        this.factoryContext.getTraversableResolver(), factoryContext.getParameterNameProvider(), metaBean);
        context.setBean(object, metaBean);
        final Groups computedGroup = groupsComputer.computeGroups(groups);
        if (computedGroup.getGroups().size() == 1 && Group.DEFAULT.equals(computedGroup.getGroups().iterator().next()) && metaBean.getFeature(Jsr303Features.Bean.GROUP_SEQUENCE) != null) {
            final Groups sequence = new Groups();
            sequence.getGroups().addAll(List.class.cast(metaBean.getFeature(Jsr303Features.Bean.GROUP_SEQUENCE)));
            context.setGroups(sequence);
        } else {
            context.setGroups(computedGroup);
        }
        return context;
    }

        // sanity checks
        // validations
        return validateInvocationParameters(constructor, parameterValues, constructorDescriptor, gps, new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(), Arrays.asList(constructor.getParameterTypes())), null);
    }

    private <T> Set<ConstraintViolation<T>> validateInvocationParameters(final Member invocable, final Object[] parameterValues, final InvocableElementDescriptor constructorDescriptor,
                                                                         final Class<?>[] gps, final NodeImpl rootNode, final Object rootBean) {


        final GroupValidationContext<ConstraintValidationListener<?>> parametersContext = createInvocableContext(constructorDescriptor.getMetaBean(), rootBean, Class.class.cast(invocable.getDeclaringClass()), gps);
        final GroupValidationContext<Object> crossParameterContext = createContext(constructorDescriptor.getMetaBean(), rootBean, Class.class.cast(invocable.getDeclaringClass()), gps);
        if (rootBean != null) { // could be more sexy but that's ok for now
            final Method m = Method.class.cast(invocable);
            parametersContext.setMethod(m);
            crossParameterContext.setMethod(m);
        } else {
            final Constructor<?> m = Constructor.class.cast(invocable);
            parametersContext.setConstructor(m);
            crossParameterContext.setConstructor(m);

        final Groups groups = parametersContext.getGroups();

        final List<ParameterDescriptor> parameterDescriptors = constructorDescriptor.getParameterDescriptors();
        final ElementDescriptorImpl crossParamDescriptor = ElementDescriptorImpl.class.cast(constructorDescriptor.getCrossParameterDescriptor());
        final Set<ConstraintDescriptor<?>> crossParamConstraints = crossParamDescriptor.getConstraintDescriptors();

        crossParameterContext.setBean(parameterValues);
        crossParameterContext.moveDown(rootNode);
        crossParameterContext.moveDown("<cross-parameter>");
        crossParameterContext.setKind(ElementKind.CROSS_PARAMETER);

        parametersContext.moveDown(rootNode);
        parametersContext.setParameters(parameterValues);

        for (final Group current : groups.getGroups()) {
            for (int i = 0; i < parameterValues.length; i) {
                final ParameterDescriptorImpl paramDesc = ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
                parametersContext.setBean(parameterValues[i]);
                parametersContext.moveDown(new NodeImpl.ParameterNodeImpl(paramDesc.getName(), i));
                for (final ConstraintDescriptor<?> constraintDescriptor : paramDesc.getConstraintDescriptors()) {
                    final ConstraintValidation<?> validation = ConstraintValidation.class.cast(constraintDescriptor);
                    parametersContext.setCurrentGroup(paramDesc.mapGroup(current));
                    validation.validate(parametersContext);
                }
                parametersContext.moveUp(null, null);
            for (final ConstraintDescriptor<?> d : crossParamConstraints) {
                final ConstraintValidation<?> validation = ConstraintValidation.class.cast(d);
                crossParameterContext.setCurrentGroup(crossParamDescriptor.mapGroup(current));
                validation.validate(crossParameterContext);
            }
            if (gps.length == 0 && parametersContext.getListener().getConstraintViolations().size()  crossParameterContext.getListener().getConstraintViolations().size() > 0) {
                break;
            }
        for (final Group current : groups.getGroups()) {
            for (int i = 0; i < parameterValues.length; i) {
                final ParameterDescriptorImpl paramDesc = ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
                if (paramDesc.isCascaded() && parameterValues[i] != null) {
                    parametersContext.setBean(parameterValues[i]);
                    parametersContext.moveDown(new NodeImpl.ParameterNodeImpl(paramDesc.getName(), i));
                    initMetaBean(parametersContext, factoryContext.getMetaBeanFinder(), parameterValues[i].getClass());
                    parametersContext.setCurrentGroup(paramDesc.mapGroup(current));
                    ValidationHelper.validateContext(parametersContext, new Jsr303ValidationCallback(parametersContext), isTreatMapsLikeBeans());
                    parametersContext.moveUp(null, null);
                }
            }
        }

        for (final List<Group> eachSeq : groups.getSequences()) {
            for (final Group current : eachSeq) {
                for (int i = 0; i < parameterValues.length; i) {
                    final ParameterDescriptorImpl paramDesc = ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
                    parametersContext.setBean(parameterValues[i]);
                    parametersContext.moveDown(new NodeImpl.ParameterNodeImpl(paramDesc.getName(), i));
                    for (final ConstraintDescriptor<?> constraintDescriptor : paramDesc.getConstraintDescriptors()) {
                        final ConstraintValidation<?> validation = ConstraintValidation.class.cast(constraintDescriptor);
                        parametersContext.setCurrentGroup(paramDesc.mapGroup(current));
                        validation.validate(parametersContext);
                    }
                    parametersContext.moveUp(null, null);
                }

                for (final ConstraintDescriptor<?> d : crossParamConstraints) {
                    final ConstraintValidation<?> validation = ConstraintValidation.class.cast(d);
                    crossParameterContext.setCurrentGroup(crossParamDescriptor.mapGroup(current));
                    validation.validate(crossParameterContext);
                }

                if (parametersContext.getListener().getConstraintViolations().size()  crossParameterContext.getListener().getConstraintViolations().size() > 0) {
                    break;
                }
            }

            for (final Group current : eachSeq) {
                for (int i = 0; i < parameterValues.length; i) {
                    final ParameterDescriptorImpl paramDesc = ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
                    if (paramDesc.isCascaded() && parameterValues[i] != null) {
                        parametersContext.setBean(parameterValues[i]);
                        parametersContext.moveDown(new NodeImpl.ParameterNodeImpl(paramDesc.getName(), i));
                        initMetaBean(parametersContext, factoryContext.getMetaBeanFinder(), parameterValues[i].getClass());
                        parametersContext.setCurrentGroup(paramDesc.mapGroup(current));
                        ValidationHelper.validateContext(parametersContext, new Jsr303ValidationCallback(parametersContext), isTreatMapsLikeBeans());
                        parametersContext.moveUp(null, null);
                    }
                }
            }
        }
        if (constructorDescriptor.isCascaded()) {
            if (parametersContext.getValidatedValue() != null) {
                initMetaBean(parametersContext, factoryContext.getMetaBeanFinder(), parametersContext.getValidatedValue().getClass());

                for (final Group current : groups.getGroups()) {
                    parametersContext.setCurrentGroup(constructorDescriptor.mapGroup(current));
                    ValidationHelper.validateContext(parametersContext, new Jsr303ValidationCallback(parametersContext), isTreatMapsLikeBeans());
                }
                for (final List<Group> eachSeq : groups.getSequences()) {
                    for (final Group current : eachSeq) {
                        parametersContext.setCurrentGroup(constructorDescriptor.mapGroup(current));
                        ValidationHelper.validateContext(parametersContext, new Jsr303ValidationCallback(parametersContext), isTreatMapsLikeBeans());
                        if (!parametersContext.getListener().isEmpty()) {
                            break;
                        }
                    }
                }
            }
            if (crossParameterContext.getValidatedValue() != null) {
                initMetaBean(crossParameterContext, factoryContext.getMetaBeanFinder(), crossParameterContext.getValidatedValue().getClass());

                for (final Group current : groups.getGroups()) {
                    crossParameterContext.setCurrentGroup(constructorDescriptor.mapGroup(current));
                    ValidationHelper.validateContext(crossParameterContext, new Jsr303ValidationCallback(crossParameterContext), isTreatMapsLikeBeans());
                }
                for (final List<Group> eachSeq : groups.getSequences()) {
                    for (final Group current : eachSeq) {
                        crossParameterContext.setCurrentGroup(constructorDescriptor.mapGroup(current));
                        ValidationHelper.validateContext(crossParameterContext, new Jsr303ValidationCallback(crossParameterContext), isTreatMapsLikeBeans());
                        if (!crossParameterContext.getListener().isEmpty()) {
                            break;
                        }
                    }
                }
            }
        }

        violations.addAll(Set.class.cast(parametersContext.getListener().getConstraintViolations()));
        violations.addAll(Set.class.cast(crossParameterContext.getListener().getConstraintViolations()));

    public <T> Set<ConstraintViolation<T>> validateConstructorReturnValue(final Constructor<? extends T> constructor, final T createdObject, final Class<?>... gps) {
        {
            notNull("Constructor", constructor);
            notNull("Returned value", createdObject);
        final Class<? extends T> declaringClass = constructor.getDeclaringClass();
        final ConstructorDescriptorImpl methodDescriptor = ConstructorDescriptorImpl.class.cast(getConstraintsForClass(declaringClass).getConstraintsForConstructor(constructor.getParameterTypes()));
            throw new ValidationException("Constructor "  constructor  " doesn't belong to class "  declaringClass);
        return validaReturnedValue(new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(), Arrays.asList(constructor.getParameterTypes())), createdObject, declaringClass, methodDescriptor, gps, null);
    }
    private <T> Set<ConstraintViolation<T>> validaReturnedValue(final NodeImpl rootNode, final T createdObject, final Class<?> clazz,
                                                                final InvocableElementDescriptor methodDescriptor, final Class<?>[] gps,
                                                                final Object rootBean) {
        final ElementDescriptorImpl returnedValueDescriptor = ElementDescriptorImpl.class.cast(methodDescriptor.getReturnValueDescriptor());
        final Set<ConstraintDescriptor<?>> returnedValueConstraints = returnedValueDescriptor.getConstraintDescriptors();

        final GroupValidationContext<T> context = createInvocableContext(methodDescriptor.getMetaBean(), createdObject, Class.class.cast(Proxies.classFor(clazz)), gps);
        context.moveDown(rootNode);
        context.moveDown(new NodeImpl.ReturnValueNodeImpl());
        context.setReturnValue(rootBean);

        final Groups groups = context.getGroups();

        for (final Group current : groups.getGroups()) {
            for (final ConstraintDescriptor<?> d : returnedValueConstraints) {
                final ConstraintValidation<?> validation = ConstraintValidation.class.cast(d);
                context.setCurrentGroup(returnedValueDescriptor.mapGroup(current));
                validation.validate(context);

            if (gps.length == 0 && !context.getListener().getConstraintViolations().isEmpty()) {
                break;
            }
        }

        int currentViolationNumber = context.getListener().getConstraintViolations().size();
        for (final Group current : groups.getGroups()) {
            if (returnedValueDescriptor.isCascaded() && context.getValidatedValue() != null) {
                context.setBean(createdObject);
                initMetaBean(context, factoryContext.getMetaBeanFinder(), context.getValidatedValue().getClass());

                context.setCurrentGroup(methodDescriptor.mapGroup(current));
                ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());

                if (currentViolationNumber < context.getListener().getConstraintViolations().size()) {
                    break;
        for (final List<Group> eachSeq : groups.getSequences()) {
            for (final Group current : eachSeq) {
                for (final ConstraintDescriptor<?> d : returnedValueConstraints) {
                    final ConstraintValidation<?> validation = ConstraintValidation.class.cast(d);
                    // context.setCurrentGroup(returnedValueDescriptor.mapGroup(current)); // mapping is only relevant for cascaded validations
                    context.setCurrentGroup(current);
                    validation.validate(context);
                }

                if (!context.getListener().getConstraintViolations().isEmpty()) {
                    break;
                }
            }

            currentViolationNumber = context.getListener().getConstraintViolations().size();
            for (final Group current : eachSeq) {
                if (returnedValueDescriptor.isCascaded() && context.getValidatedValue() != null) {
                    context.setBean(createdObject);
                    initMetaBean(context, factoryContext.getMetaBeanFinder(), context.getValidatedValue().getClass());

                    context.setCurrentGroup(methodDescriptor.mapGroup(current));
                    ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());

                    if (currentViolationNumber < context.getListener().getConstraintViolations().size()) {
                        break;
                    }
                }
            }
        }

        return context.getListener().getConstraintViolations();
        return validateInvocationParameters(method, parameterValues, methodDescriptor, groups, new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())), object);
        return Set.class.cast(validaReturnedValue(new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())), returnValue, object.getClass(), methodDescriptor, groups, object));
     * Implement {@link #validateProperty(Object, String, boolean, Class[])} } and
                returnValue = this.rootBean; // switch back return value and rootBean
// which would be a pain in app servers
        beforeBeanDiscovery.addAnnotatedType(beanManager.createAnnotatedType(BValInterceptor.class));
import org.jboss.arquillian.container.test.spi.client.deployment.ApplicationArchiveProcessor;
        builder.service(TestEnricher.class, EJBEnricher.class)
            .service(ApplicationArchiveProcessor.class, CdiMethodValidationProcessor.class);
import java.util.HashSet;
import java.util.concurrent.CopyOnWriteArraySet;
            globalExecutableTypes = convertToRuntimeTypes(bootstrap.getDefaultValidatedExecutableTypes());
    private static Set<ExecutableType> convertToRuntimeTypes(final Set<ExecutableType> defaultValidatedExecutableTypes) {
        final Set<ExecutableType> types = new CopyOnWriteArraySet<ExecutableType>();
        for (final ExecutableType type : defaultValidatedExecutableTypes) {
            if (ExecutableType.IMPLICIT.equals(type)) {
                types.add(ExecutableType.CONSTRUCTORS);
                types.add(ExecutableType.NON_GETTER_METHODS);
            } else if (ExecutableType.ALL.equals(type)) {
                types.add(ExecutableType.CONSTRUCTORS);
                types.add(ExecutableType.NON_GETTER_METHODS);
                types.add(ExecutableType.GETTER_METHODS);
                break;
            } else if (!ExecutableType.NONE.equals(type)) {
                types.add(type);
            }
        }
        return types;
    }

    public Set<ExecutableType> getGlobalExecutableTypes() {
        return globalExecutableTypes;
    }

        if (!isExecutableValidationEnabled) {
            return;
        }

        if (!isExecutableValidationEnabled) {
            return;
        }

import javax.validation.executable.ExecutableType;
import javax.validation.executable.ValidateOnExecution;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;
    private Collection<ExecutableType> classConfiguration = null;
    private final Map<Method, Boolean> methodConfiguration = new ConcurrentHashMap<Method, Boolean>();

    @Inject
    private BValExtension globalConfiguration;

        final Method method = context.getMethod();
        if (!isMethodValidated(Proxies.classFor(context.getTarget().getClass()), method)) {
            return context.proceed();
        }


    private boolean isMethodValidated(final Class<?> targetClass, final Method method) throws NoSuchMethodException {
        Boolean methodConfig;// config
        if (classConfiguration == null) {
            synchronized (this) {
                if (classConfiguration == null) {
                    classConfiguration = new CopyOnWriteArraySet<ExecutableType>();

                    final ValidateOnExecution annotation = targetClass.getAnnotation(ValidateOnExecution.class);
                    if (annotation == null) {
                        classConfiguration.addAll(globalConfiguration.getGlobalExecutableTypes());
                    } else {
                        for (final ExecutableType type : annotation.type()) {
                            if (ExecutableType.IMPLICIT.equals(type)) {
                                classConfiguration.add(ExecutableType.CONSTRUCTORS);
                                classConfiguration.add(ExecutableType.NON_GETTER_METHODS);
                            } else if (ExecutableType.ALL.equals(type)) {
                                classConfiguration.add(ExecutableType.CONSTRUCTORS);
                                classConfiguration.add(ExecutableType.NON_GETTER_METHODS);
                                classConfiguration.add(ExecutableType.GETTER_METHODS);
                                break;
                            } else if (!ExecutableType.NONE.equals(type)) {
                                classConfiguration.add(type);
                            }
                        }
                    }
                }
            }
        }

        methodConfig = methodConfiguration.get(method);
        if (methodConfig == null) {
            synchronized (this) {
                methodConfig = methodConfiguration.get(method);
                if (methodConfig == null) {
                    // reuse Proxies to avoid issue with some subclassing libs removing annotations
                    final ValidateOnExecution annotation = targetClass.getMethod(method.getName(), method.getParameterTypes()).getAnnotation(ValidateOnExecution.class);
                    if (annotation == null) {
                        methodConfig = doValidMethod(method, classConfiguration);
                    } else {
                        final Collection<ExecutableType> config = new HashSet<ExecutableType>();
                        for (final ExecutableType type : annotation.type()) {
                            if (ExecutableType.IMPLICIT.equals(type)) { // on method it just means validate, even on getters
                                config.add(ExecutableType.CONSTRUCTORS);
                                config.add(ExecutableType.NON_GETTER_METHODS);
                                config.add(ExecutableType.GETTER_METHODS);
                            } else if (ExecutableType.ALL.equals(type)) {
                                config.add(ExecutableType.CONSTRUCTORS);
                                config.add(ExecutableType.NON_GETTER_METHODS);
                                config.add(ExecutableType.GETTER_METHODS);
                                break;
                            } else if (!ExecutableType.NONE.equals(type)) {
                                config.add(type);
                            }
                        }
                        methodConfig = doValidMethod(method, config);
                    }
                }
                methodConfiguration.put(method, methodConfig);
            }
        }

        return methodConfig;
    }

    private boolean doValidMethod(final Method method, final Collection<ExecutableType> config) {
        final boolean getter = isGetter(method);
        return (!getter && config.contains(ExecutableType.NON_GETTER_METHODS)) || (getter && config.contains(ExecutableType.GETTER_METHODS));
    }

    private static boolean isGetter(final Method method) {
        final String name = method.getName();
        return (name.startsWith("get") || name.startsWith("is")) && method.getReturnType() != Void.TYPE && method.getParameterTypes().length == 0;
    }
import org.apache.bval.jsr303.util.ClassHelper;
import javax.interceptor.AroundConstruct;
import javax.validation.metadata.ConstructorDescriptor;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
    private Boolean constructorValidated = null;
    private ExecutableValidator executableValidator;

    @AroundConstruct // TODO: maybe add it through ASM to be compliant with CDI 1.0 containers using simply this class as a template for the one created with ASM
    public Object construct(final InvocationContext context) throws Exception {
        final Constructor constructor = context.getConstructor();
        final Class<?> targetClass = Proxies.classFor(context.getTarget().getClass());
        if (!isConstructorValidated(targetClass, constructor)) {
        final ConstructorDescriptor constraints = validator.getConstraintsForClass(targetClass).getConstraintsForConstructor(constructor.getParameterTypes());
        if (constraints == null) {
        initExecutableValidator();

            final Set<ConstraintViolation<?>> violations = executableValidator.validateConstructorParameters(constructor, context.getParameters());
            final Set<ConstraintViolation<?>> violations = executableValidator.validateConstructorReturnValue(constructor, result);
    @AroundInvoke
    public Object invoke(final InvocationContext context) throws Throwable {
        final Method method = context.getMethod();
        final Class<?> targetClass = Proxies.classFor(context.getTarget().getClass());
        if (!isMethodValidated(targetClass, method)) {
            return context.proceed();
        }

        final MethodDescriptor constraintsForMethod = validator.getConstraintsForClass(targetClass).getConstraintsForMethod(method.getName(), method.getParameterTypes());
        if (constraintsForMethod == null) {
            return context.proceed();
        }

        initExecutableValidator();

        {
            final Set<ConstraintViolation<Object>> violations = executableValidator.validateParameters(context.getTarget(), method, context.getParameters());
            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        }

        final Object result = context.proceed();

        {
            final Set<ConstraintViolation<Object>> violations = executableValidator.validateReturnValue(context.getTarget(), method, result);
            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        }

        return result;
    }

    private boolean isConstructorValidated(final Class<?> targetClass, final Constructor<?> constructor) throws NoSuchMethodException {
        initClassConfig(targetClass);

        if (constructorValidated == null) {
            synchronized (this) {
                if (constructorValidated == null) {
                    final ValidateOnExecution annotation = targetClass.getConstructor(constructor.getParameterTypes()).getAnnotation(ValidateOnExecution.class);
                    if (annotation == null) {
                        constructorValidated = classConfiguration.contains(ExecutableType.CONSTRUCTORS);
                    } else {
                        final Collection<ExecutableType> types = Arrays.asList(annotation.type());
                        constructorValidated = types.contains(ExecutableType.CONSTRUCTORS) || types.contains(ExecutableType.IMPLICIT) || types.contains(ExecutableType.ALL);
                    }
                }
            }
        }

        return constructorValidated;
    }

        initClassConfig(targetClass);

        Boolean methodConfig = methodConfiguration.get(method);
        if (methodConfig == null) {
            synchronized (this) {
                methodConfig = methodConfiguration.get(method);
                if (methodConfig == null) {
                    final List<Class<?>> classHierarchy = ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), targetClass);

                    Class<?> lastClassWithTheMethod = null;

                    // search on method @ValidateOnExecution
                    Collections.reverse(classHierarchy);
                    ValidateOnExecution validateOnExecution = null;
                    for (final Class<?> c : classHierarchy) {
                        try {
                            validateOnExecution = c.getDeclaredMethod(method.getName(), method.getParameterTypes()).getAnnotation(ValidateOnExecution.class);
                            if (lastClassWithTheMethod == null) {
                                lastClassWithTheMethod = c;
                            }
                            if (validateOnExecution != null) {
                                lastClassWithTheMethod = null;
                                break;
                            }
                        } catch (final Throwable h) {
                            // no-op
                        }
                    }

                    // if not found look in the class declaring the method
                    if (validateOnExecution == null && lastClassWithTheMethod != null) {
                        validateOnExecution = lastClassWithTheMethod.getAnnotation(ValidateOnExecution.class);
                    }

                    if (validateOnExecution == null) {
                        methodConfig = doValidMethod(method, classConfiguration);
                    } else {
                        final Collection<ExecutableType> config = new HashSet<ExecutableType>();
                        for (final ExecutableType type : validateOnExecution.type()) {
                            if (ExecutableType.IMPLICIT.equals(type)) { // on method it just means validate, even on getters
                                config.add(ExecutableType.NON_GETTER_METHODS);
                                if (lastClassWithTheMethod == null) {
                                    config.add(ExecutableType.GETTER_METHODS);
                                } // else the annotation was not on the method so implicit doesn't mean getters
                            } else if (ExecutableType.ALL.equals(type)) {
                                config.add(ExecutableType.NON_GETTER_METHODS);
                                config.add(ExecutableType.GETTER_METHODS);
                                break;
                            } else if (!ExecutableType.NONE.equals(type)) {
                                config.add(type);
                            }
                        }
                        methodConfig = doValidMethod(method, config);
                    }
                }
                methodConfiguration.put(method, methodConfig);
            }
        }

        return methodConfig;
    }

    private void initClassConfig(Class<?> targetClass) {
    private void initExecutableValidator() {
        if (executableValidator == null) {
            synchronized (this) {
                if (executableValidator == null) {
                    executableValidator = validator.forExecutables();
                }
            }
        }
    }

    private static boolean doValidMethod(final Method method, final Collection<ExecutableType> config) {
import javax.validation.metadata.ConstraintDescriptor;
                final boolean getter = (method.getName().startsWith("get") || method.getName().startsWith("is")) && method.getParameterTypes().length == 0 && method.getReturnType() != Void.TYPE;
            final List<ParameterDescriptor> parameterDescriptors = methodDesc.getParameterDescriptors();
            if (!parameterDescriptors.contains(paramDesc)) {
                parameterDescriptors.add(paramDesc);
            }
            final List<ConstraintValidation<?>> newValidations = validations.getValidations();
            for (final ConstraintValidation<?> validation : newValidations) { // don't add it if exactly the same is already here
                boolean alreadyHere = false;
                for (final ConstraintDescriptor<?> existing : paramDesc.getMutableConstraintDescriptors()) {
                    if (existing.getAnnotation().annotationType().equals(validation.getAnnotation().annotationType())) { // TODO: make it a bit finer
                        alreadyHere = true;
                        break;
                    }
                }
                if (!alreadyHere) {
                    paramDesc.getMutableConstraintDescriptors().add(validation);
                }
            }

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        final ParameterAccess that = (ParameterAccess) o;
        return paramIdx == that.paramIdx && paramType.equals(that.paramType);
    }

    @Override
    public int hashCode() {
        int result = paramType.hashCode();
        result = 31 * result  paramIdx;
        return result;
    }
     *
    static public List<Class<?>> fillFullClassHierarchyAsList(List<Class<?>> allClasses, Class<?> clazz) {
            return allClasses;
            return allClasses;
        return allClasses;
import javax.annotation.Priority;
@Priority(4800) // TODO: maybe add it through ASM to be compliant with CDI 1.0 containers using simply this class as a template to generate another one for CDI 1.1 impl
    private ExecutableValidator executableValidator = null;
    @AroundConstruct // TODO: see previous one
        final Class<?> targetClass = constructor.getDeclaringClass();
        if (constraints == null) { // surely implicit constructor
// hack while OWB doesn't have interceptor discovery
    private static final String ValidationInterceptorPriorityTest_BEANS_XML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" 
        "<beans xmlns=\"http://java.sun.com/xml/ns/javaee\"\n" 
        "       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n" 
        "       xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee\n" 
        "      http://java.sun.com/xml/ns/javaee/beans_1_0.xsd\">\n" 
        "  <interceptors>\n" 
        "    <class>org.hibernate.beanvalidation.tck.tests.integration.cdi.executable.priority.LaterInterceptor</class>\n" 
        "    <class>org.hibernate.beanvalidation.tck.tests.integration.cdi.executable.priority.EarlierInterceptor</class>\n" 
        "    <class>org.apache.bval.cdi.BValInterceptor</class>\n" 
        "  </interceptors>\n" 
        "</beans>";

            final String beansXmlStr;
            if (testClass.getJavaClass().getSimpleName().equals("ValidationInterceptorPriorityTest")) {
                beansXmlStr = ValidationInterceptorPriorityTest_BEANS_XML;
            } else {
                beansXmlStr = BEANS_XML;
            }

                ManifestContainer.class.cast(applicationArchive).addAsManifestResource(new StringAsset(beansXmlStr), "beans.xml");
                WebContainer.class.cast(applicationArchive).addAsWebInfResource(new StringAsset(beansXmlStr), "beans.xml");
            if (System.getSecurityManager() == null) {
                constructor.setAccessible(true);
            } else {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        constructor.setAccessible(true);
                        return null;
                    }
                });
            }
import org.apache.bval.util.reflection.Reflection;

import java.beans.Introspector;
import java.util.HashMap;
    private Map<String, MetaProperty> properties = null;
    private Map<Method, MetaMethod> methods = null;
    private Map<Constructor<?>, MetaConstructor> constructors = null;
     * @return Class
        if (beanClass != null) {
            // order of fields to ensure correct failling order
            final Map<String, MetaProperty> oldProperties = properties;
            final Map<Method, MetaMethod> oldMethods = methods;
            final Map<Constructor<?>, MetaConstructor> oldConstructors = constructors;

            properties = new TreeMap<String, MetaProperty>(new FieldComparator(beanClass));
            if (oldProperties != null) {
                properties.putAll(oldProperties);
            }
            methods = new TreeMap<Method, MetaMethod>(new MethodComparator(beanClass));
            if (oldMethods != null) {
                methods.putAll(oldMethods);
            }
            constructors = new TreeMap<Constructor<?>, MetaConstructor>(new ConstructorComparator(beanClass));
            if (oldConstructors != null) {
                constructors.putAll(oldConstructors);
            }
        }
        if (properties == null) {
            return new MetaProperty[0];
        }
        if (methods == null) {
            return new MetaMethod[0];
        }
        if (methods == null) {
            methods = new HashMap<Method, MetaMethod>();
        }
        if (constructors == null) {
            constructors = new HashMap<Constructor<?>, MetaConstructor>();
        }
        this.properties = new HashMap<String, MetaProperty>();
        for (final MetaProperty property : properties) {
     * @param name property name
        if (properties == null) {
            return null;
        }
        if (properties == null) {
            return false;
        }
     * @param name property name
        if (properties == null) {
            properties = new HashMap<String, MetaProperty>();
        }
     * @param bean instance
        if (methods == null) {
            return null;
        }
        if (constructors == null) {
            return null;
        }

    protected static class FieldComparator implements Comparator<String> {
        private final Map<String, Integer> fields = new HashMap<String, Integer>();

        protected FieldComparator(final Class<?> beanClass) {
            int i = 0;
            Class<?> clazz = beanClass;
            while (clazz != null && clazz != Object.class) {
                for (final Field f : Reflection.INSTANCE.getDeclaredFields(clazz)) {
                    i;
                    final String name = f.getName();
                    if (!fields.containsKey(name)) {
                        fields.put(name, i);
                    }
                }
                for (final Method m : clazz.getDeclaredMethods()) {
                    if (m.getName().startsWith("get") && Void.TYPE != m.getReturnType() && m.getParameterTypes().length == 0) {
                        final String name = Introspector.decapitalize(m.getName().substring("get".length()));
                        if (!name.isEmpty()) {
                            i;
                            if (!fields.containsKey(name)) {
                                fields.put(name, i);
                            }
                        }
                    }
                }
                clazz = clazz.getSuperclass();
            }
        }

        public int compare(final String o1, final String o2) {
            return fieldIndex(o1) - fieldIndex(o2);
        }

        private int fieldIndex(final String o2) {
            final Integer idx = fields.get(o2);
            if (idx != null) {
                return idx;
            }
            return Integer.MIN_VALUE; // to avoid collision and false positive in get() due to equals
        }
    }

    protected static class MethodComparator implements Comparator<Method> {
        private final Map<Method, Integer> methods = new HashMap<Method, Integer>();

        protected MethodComparator(final Class<?> beanClass) {
            Class<?> clazz = beanClass;
            while (clazz != null && clazz != Object.class) {
                for (final Method m : Reflection.INSTANCE.getDeclaredMethods(clazz)) {
                    methods.put(m, Arrays.hashCode(m.getParameterTypes()));
                }
                clazz = clazz.getSuperclass();
            }
        }

        public int compare(final Method o1, final Method o2) {
            if (o1 == o2) {
                return 0;
            }

            final int i = o1.getName().compareTo(o2.getName());
            if (i != 0) {
                return i;
            }
            return methods.get(o1) - methods.get(o2);
        }
    }

    protected static class ConstructorComparator implements Comparator<Constructor<?>> {
        private final Map<Constructor<?>, Integer> constructors = new HashMap<Constructor<?>, Integer>();

        protected ConstructorComparator(final Class<?> beanClass) {
            for (final Constructor<?> c : Reflection.INSTANCE.getDeclaredConstructors(beanClass)) {
                constructors.put(c, Arrays.hashCode(c.getParameterTypes()));
            }
        }

        public int compare(final Constructor<?> o1, final Constructor<?> o2) {
            if (o1 == o2) {
                return 0;
            }

            final int i = o1.getName().compareTo(o2.getName());
            if (i != 0) {
                return i;
            }
            return constructors.get(o1) - constructors.get(o2);
        }
    }
import org.apache.bval.util.reflection.Reflection;

import java.io.InputStream;
            Reflection.INSTANCE.getProperty("java.class.path"));
            Reflection.INSTANCE.getProperty(prop));
            if (System.getSecurityManager() == null) {
                field.setAccessible(true);
            } else {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        field.setAccessible(true);
                        return null;
                    }
                });
            }
            if (System.getSecurityManager() == null) {
                method.setAccessible(true);
            } else {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        method.setAccessible(true);
                        return null;
                    }
                });
            }
import org.apache.bval.util.reflection.Reflection;
            if (System.getSecurityManager() == null) {
                doBuildFromAnnotations();
            } else {
                AccessController.doPrivileged(new PrivilegedAction<Object>() {
                    public Object run() {
                        doBuildFromAnnotations();
                });
            }
        }
    }
    private void doBuildFromAnnotations() {
        final Class<? extends Annotation> annotationType = constraintValidation.getAnnotation().annotationType();

        for (final Method method : Reflection.INSTANCE.getDeclaredMethods(annotationType)) {
            // groups  payload must also appear in attributes (also
            // checked by TCK-Tests)
            if (method.getParameterTypes().length == 0) {
                try {
                    final String name = method.getName();
                    if (ConstraintAnnotationAttributes.PAYLOAD.getAttributeName().equals(name)) {
                        buildPayload(method);
                    } else if (ConstraintAnnotationAttributes.GROUPS.getAttributeName().equals(name)) {
                        buildGroups(method);
                    } else if (ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getAttributeName().equals(name)) {
                        buildValidationAppliesTo(method);
                    } else if (name.startsWith("valid")) {
                        throw new ConstraintDefinitionException("constraints parameters can't start with valid: "  name);
                    } else {
                        constraintValidation.getAttributes().put(name, method.invoke(constraintValidation.getAnnotation()));
                } catch (final ConstraintDefinitionException cde) {
                    throw cde;
                } catch (final Exception e) { // do nothing
                    log.log(Level.WARNING, String.format("Error processing annotation: %s ", constraintValidation.getAnnotation()), e);
            }
        }

        // valid validationAppliesTo
        final Constraint annotation = annotationType.getAnnotation(Constraint.class);
        if (annotation == null) {
            return;
        }

        final Pair validationTarget = computeValidationTarget(annotation.validatedBy());
        for (final Annotation a : annotationType.getAnnotations()) {
            final Constraint inheritedConstraint = a.annotationType().getAnnotation(Constraint.class);
            if (inheritedConstraint != null && !a.annotationType().getName().startsWith("javax.validation.constraints.")) {
                final Pair validationTargetInherited = computeValidationTarget(inheritedConstraint.validatedBy());
                if ((validationTarget.a > 0 && validationTargetInherited.b > 0 && validationTarget.b == 0)
                        || (validationTarget.b > 0 && validationTargetInherited.a > 0 && validationTarget.a == 0)) {
                    throw new ConstraintDefinitionException("Parent and child constraint have different targets");
                }
            }
    private void buildGroups(final Method method) throws IllegalAccessException, InvocationTargetException {
        final Object raw = method.invoke(constraintValidation.getAnnotation());
            garr = GroupsComputer.DEFAULT_GROUP;
        constraintValidation.setGroups(garr);
            Collections.addAll(payloadSet, payload_raw);
import org.apache.bval.util.reflection.Reflection;
        for (final Annotation annotation : element.getDeclaredAnnotations()) {
            final Class<?> type = annotation.annotationType();
            if (type.getName().startsWith("java.lang.annotation")) {
                continue;
            }
        final Object result = Reflection.INSTANCE.getAnnotationValue(annotation, ConstraintAnnotationAttributes.VALUE.getAttributeName());
import org.apache.bval.IntrospectorMetaBeanFactory;
import org.apache.bval.MetaBeanBuilder;
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.MetaBeanManager;
import org.apache.bval.util.reflection.Reflection;
import org.apache.bval.xml.XMLMetaBeanBuilder;
import org.apache.bval.xml.XMLMetaBeanFactory;
import org.apache.bval.xml.XMLMetaBeanManager;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.reflect.ConstructorUtils;
import java.lang.reflect.Constructor;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;
     * @param factory validator factory
     * @param factory validator factory
     * @param metaBeanFinder meta finder
        if (System.getSecurityManager() == null) {
            return doCreateMetaBeanFactory(cls);
        }
        return AccessController.doPrivileged(new PrivilegedAction<F>() {
                return doCreateMetaBeanFactory(cls);
    private <F extends MetaBeanFactory> F doCreateMetaBeanFactory(final Class<F> cls) {
        try {
            Constructor<F> c = ConstructorUtils.getMatchingAccessibleConstructor(cls, ApacheFactoryContext.this.getClass());
            if (c != null) {
                return c.newInstance(ApacheFactoryContext.this);
            }
            c = ConstructorUtils.getMatchingAccessibleConstructor(cls, getFactory().getClass());
            if (c != null) {
                return c.newInstance(getFactory());
            }
            return cls.newInstance();
        } catch (Exception e) {
            throw new ValidationException(e);
        }
    }

         * @param builders meta bean builders
            return Class.forName(className, true, Reflection.INSTANCE.getClassLoader(ApacheFactoryContext.class));
import org.apache.bval.util.reflection.Reflection;
        try {
            return Reflection.INSTANCE.newInstance(cls);
        } catch (final RuntimeException e) {
            throw new ValidationException(e.getCause());
        }
import org.apache.bval.jsr303.xml.AnnotationIgnores;
import org.apache.bval.util.reflection.Reflection;
    private static final Validation[] EMPTY_VALIDATION = new Validation[0];

                final Field field = Reflection.INSTANCE.getDeclaredField(current, prop.getName());
                                    Reflection.INSTANCE.getDeclaredMethod(current, "is"  name),
                                    Reflection.INSTANCE.getDeclaredMethod(current, "get"  name))) {
        for (final Constructor<?> cons : Reflection.INSTANCE.getDeclaredConstructors(getMetaBean().getBeanClass())) {
            final AnnotationIgnores annotationIgnores = factoryContext.getFactory().getAnnotationIgnores();

                    final ParameterDescriptorImpl paramDesc = new ParameterDescriptorImpl(getMetaBean(), EMPTY_VALIDATION, names.get(idx));
                    if (annotationIgnores.isIgnoreAnnotationOnParameter(cons, idx)) {
                        consDesc.getParameterDescriptors().add(new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx)));
                if (!annotationIgnores.isIgnoreAnnotations(cons)) {
            if (annotationIgnores.isIgnoreAnnotationOnCrossParameter(cons) && consDesc.getCrossParameterDescriptor() != null) {
            if (annotationIgnores.isIgnoreAnnotationOnReturn(cons) && consDesc.getReturnValueDescriptor() != null) {

        final List<Class<?>> classHierarchy = ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), current);

            classHierarchy.remove(current);
            for (final Method method : Reflection.INSTANCE.getDeclaredMethods(current)) {
                    final Method overriden = Reflection.INSTANCE.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
                            final MethodDescriptor parentDec = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
                            if (parentDec != null) {
                                ensureNoParameterConstraint(InvocableElementDescriptor.class.cast(parentDec), "Parameter constraints can't be defined for parallel interfaces/parents");
                            ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDec, "Return value constraints should be the same for parent and children");
                        ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDesc, "Return value constraints should be at least the same for parent and children");

                        final Method m = Reflection.INSTANCE.getDeclaredMethod(i, method.getName(), method.getParameterTypes());
                        final Method overriden = Reflection.INSTANCE.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
    private void ensureNoReturnValueAddedInChild(final ReturnValueDescriptor returnValueDescriptor, final MethodDescriptor parentMtdDesc, final String msg) {
        if (parentMtdDesc == null) {
        final ReturnValueDescriptor parentReturnDesc = parentMtdDesc.getReturnValueDescriptor();
    private void processMethod(final Method method, final MethodDescriptorImpl methodDesc) throws InvocationTargetException, IllegalAccessException {
        final AnnotationIgnores annotationIgnores = factoryContext.getFactory().getAnnotationIgnores();

            if (!annotationIgnores.isIgnoreAnnotations(method)) {
                if (!annotationIgnores.isIgnoreAnnotationOnParameter(method, idx)) {
        if (annotationIgnores.isIgnoreAnnotationOnCrossParameter(method) && methodDesc.getCrossParameterDescriptor() != null) {
        if (annotationIgnores.isIgnoreAnnotationOnReturn(method) && methodDesc.getReturnValueDescriptor() != null) {
                final ConstraintAnnotationAttributes.Worker<? extends Annotation> worker = ConstraintAnnotationAttributes.VALUE.analyze(annotation.annotationType());
                if (worker.isValid()) {
                    Annotation[] children = Annotation[].class.cast(worker.read(annotation));
        if (System.getSecurityManager() == null) {
            return doNewInstance(cls);
        }
                return doNewInstance(cls);
    private <T> T doNewInstance(final Class<T> cls) {
        try {
            Constructor<T> cons = cls.getConstructor(ApacheFactoryContext.class);
            if (!cons.isAccessible()) {
                cons.setAccessible(true);
            }
            return cons.newInstance(factoryContext);
        } catch (final Exception ex) {
            throw new ValidationException("Cannot instantiate : "  cls, ex);
        }
    }

        if (System.getSecurityManager() == null) {
            return doPrivBuildValidatorFactory(this);
        }
        return AccessController.doPrivileged(new PrivilegedAction<ValidatorFactory>() {
            public ValidatorFactory run() {
                return doPrivBuildValidatorFactory(ConfigurationImpl.this);
            }
        });
    public ValidatorFactory doPrivBuildValidatorFactory(final ConfigurationImpl impl) {
            return provider.buildValidatorFactory(impl);
            return findProvider().buildValidatorFactory(impl);
import org.apache.bval.util.reflection.Reflection;
    MESSAGE(false, "message"),
    GROUPS(false, "groups"),
    PAYLOAD(false, "payload"),
    VALIDATION_APPLIES_TO(true, "validationAppliesTo"),
    VALUE(true, "value");
    private ConstraintAnnotationAttributes(final boolean permitNullDefaultValue, final String name) {
    public <C extends Annotation> Worker<C> analyze(final Class<C> clazz) {
        return new Worker<C>(clazz);
    public class Worker<C extends Annotation> {
        public final Method method;
        public final Object defaultValue;
        private RuntimeException error;
        Worker(final Class<C> constraintType) {
                method = Reflection.INSTANCE.getPublicMethod(constraintType, getAttributeName());
                    error = new ConstraintDefinitionException(String.format("Annotation %1$s has no %2$s() method", constraintType, getAttributeName()));
                    return;
                    error = new ConstraintDefinitionException(String.format("Return type for %1$s() must be of type %2$s", getAttributeName(), getType()));
                    return;
                    error = new ConstraintDefinitionException(String.format("Default value for %1$s() must be an empty array", getAttributeName()));
        public boolean isValid() {
            return error == null;
        }

        public Worker<C> valid() {
            if (!isValid()) {
                throw error;
            }
            return this;
        }

        public Object read(final Annotation constraint) {
            if (System.getSecurityManager() == null) {
                return doInvoke(constraint);
            }
            return AccessController.doPrivileged(new PrivilegedAction<Object>() {
                    return doInvoke(constraint);
        }

        private Object doInvoke(final Annotation constraint) {
            try {
                method.setAccessible(true);
                return method.invoke(constraint);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Properties;
import java.util.StringTokenizer;
     * @param annotationType the annotation type
        final Map<String, Class<? extends ConstraintValidator<?, ?>>[]> loadedConstraints = new HashMap<String, Class<? extends ConstraintValidator<?,?>>[]>();
        for (final Map.Entry<Object, Object> entry : constraintProperties.entrySet()) {
            final StringTokenizer tokens = new StringTokenizer((String) entry.getValue(), ", ");
            final LinkedList<Class<?>> classes = new LinkedList<Class<?>>();
                Class<?> constraintValidatorClass;
                if (System.getSecurityManager() == null) {
                    try {
                        constraintValidatorClass = Class.forName(eachClassName, true, classloader);
                    } catch (final ClassNotFoundException e) {
                        log.log(Level.SEVERE, String.format("Cannot find class %s", eachClassName), e);
                        constraintValidatorClass = null;
                    }
                } else {
                    constraintValidatorClass = AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {
                              } catch (final ClassNotFoundException e) {
                }
                if (constraintValidatorClass != null) {
                    classes.add(constraintValidatorClass);
                }
            loadedConstraints.put((String) entry.getKey(), classes.toArray(new Class[classes.size()]));
    void setGroups(final Set<Class<?>> groups) {
        ConstraintAnnotationAttributes.GROUPS.put(attributes, groups.toArray(new Class<?>[groups.size()]));
    }

    void setGroups(final Class<?>[] groups) {
        this.groups = new HashSet<Class<?>>();
        Collections.addAll(this.groups, groups);
        ConstraintAnnotationAttributes.GROUPS.put(attributes, groups);
import org.apache.bval.util.reflection.Reflection;
    private static final boolean LOG_FINEST = log.isLoggable(Level.FINEST);
        final ClassLoader classLoader = Reflection.INSTANCE.getClassLoader(DefaultMessageInterpolator.class);
            rb = loadBundle(getClass().getClassLoader(), locale, USER_VALIDATION_MESSAGES  " not found by validator classloader");
        if (LOG_FINEST) {
            if (rb != null) {
                log.log(Level.FINEST, String.format("%s found", USER_VALIDATION_MESSAGES));
            } else {
                log.log(Level.FINEST, String.format("%s not found. Delegating to %s", USER_VALIDATION_MESSAGES, DEFAULT_VALIDATION_MESSAGES));
            }
        } catch (final MissingResourceException e) {
        "META-INF/services/javax.validation.spi.ValidationProvider";
                                final ValidationProvider<?> vp;
                                if (System.getSecurityManager() == null) {
                                    try {
                                        vp = (ValidationProvider<?>) provider.newInstance();
                                    } catch (final Exception ex) {
                                        throw new ValidationException("Cannot instantiate : "  provider, ex);
                                    }
                                } else {
                                    vp = AccessController.doPrivileged(new PrivilegedAction<ValidationProvider<?>>() {
                                        public ValidationProvider<?> run() {
                                            try {
                                                return (ValidationProvider<?>) provider.newInstance();
                                            } catch (final Exception ex) {
                                                throw new ValidationException("Cannot instantiate : "  provider, ex);
                                        }
                                    });
                                }
                                providers.add(vp);
                                    line  " configured in file "  url, e);
import org.apache.bval.util.reflection.Reflection;
        final Field[] fields = Reflection.INSTANCE.getDeclaredFields(beanClass);
        final Method[] methods = Reflection.INSTANCE.getDeclaredMethods(beanClass);
    private boolean hasValidationConstraintsDefined(final Annotation annot) {
        final ConstraintAnnotationAttributes.Worker<?> worker = ConstraintAnnotationAttributes.VALUE.analyze(annot.annotationType());
        if (worker.isValid()) {
            Annotation[] children = Annotation[].class.cast(worker.read(annot));
                for (final Annotation child : children) {
    public static final Class<?>[] DEFAULT_GROUP = new Class<?>[]{Default.class};

        DEFAULT_GROUPS = new GroupsComputer().computeGroups(Arrays.asList(DEFAULT_GROUP));
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.lang3.ClassUtils;
import java.lang.annotation.ElementType;
import java.util.logging.Level;
import java.util.logging.Logger;
    private static final boolean LOG_FINEST = log.isLoggable(Level.FINEST);
            Reflection.INSTANCE.getClass(classLoader, PERSISTENCE_UTIL_CLASSNAME);
            if (LOG_FINEST) {
                log.log(Level.FINEST, String.format("Found %s on classpath.", PERSISTENCE_UTIL_CLASSNAME));
            }
        } catch (final Exception e) {
            if (LOG_FINEST) {
                log.log(Level.FINEST, String.format("Instantiated an instance of %s.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME));
            }
        } catch (final Exception e) {
			log.log(Level.WARNING, String.format("Unable to load or instantiate JPA aware resolver %s. All properties will per default be traversable.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME), e);
      return Reflection.INSTANCE.getClassLoader(DefaultTraversableResolver.class);
import org.apache.bval.jsr303.ConstraintAnnotationAttributes;

        ConstraintAnnotationAttributes.GROUPS.analyze(type).valid();
        ConstraintAnnotationAttributes.PAYLOAD.analyze(type).valid();
        ConstraintAnnotationAttributes.MESSAGE.analyze(type).valid();
        final ConstraintAnnotationAttributes.Worker<? extends Annotation> validationAppliesToWorker = ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.analyze(type);

        if (validationAppliesToWorker.isValid() && !ConstraintTarget.IMPLICIT.equals(validationAppliesToWorker.defaultValue)) {
import org.apache.bval.util.reflection.Reflection;

import javax.validation.Valid;
        final Method[] declaredMethods = Reflection.INSTANCE.getDeclaredMethods(annotationType);
import org.apache.bval.util.reflection.Reflection;
        final Method[] methods = Reflection.INSTANCE.getDeclaredMethods(annot.annotationType());
        ClassLoader classLoader = Reflection.INSTANCE.getClassLoader(getType());
        if (System.getSecurityManager() == null) {
            return doCreateAnnotation(proxyClass, handler);
        }
        return AccessController.doPrivileged(new PrivilegedAction<A>() {
                return doCreateAnnotation(proxyClass, handler);
    private A doCreateAnnotation(final Class<A> proxyClass, final InvocationHandler handler) {
        try {
            Constructor<A> constructor = proxyClass.getConstructor(InvocationHandler.class);
            return constructor.newInstance(handler);
        } catch (Exception e) {
            throw new ValidationException("Unable to create annotation for configured constraint", e);
import org.apache.bval.util.reflection.Reflection;
        final Method m = Reflection.INSTANCE.getPublicMethod(annotationClass, name);
            final Method method = Reflection.INSTANCE.getDeclaredMethod(beanClass, methodName, toTypes(methodType.getParameter(), defaultPackage));
            final Constructor<?> constructor = Reflection.INSTANCE.getDeclaredConstructor(beanClass, toTypes(constructorType.getParameter(), defaultPackage));
            final Field field = Reflection.INSTANCE.getDeclaredField(beanClass, fieldName);
        if (System.getSecurityManager() == null) {
            return doGetGetter(propertyName, clazz);
        }
        return AccessController.doPrivileged(new PrivilegedAction<Method>() {
                return doGetGetter(propertyName, clazz);
    private static Method doGetGetter(String propertyName, Class<?> clazz) {
        try {
            final String p = StringUtils.capitalize(propertyName);
            try {
                return clazz.getMethod("get"  p);
            } catch (NoSuchMethodException e) {
                return clazz.getMethod("is"  p);
            }
        } catch (NoSuchMethodException e) {
            return null;
        }
    }
        ClassLoader loader = Reflection.INSTANCE.getClassLoader(ValidationMappingParser.class);
import org.apache.bval.util.reflection.Reflection;
        ClassLoader loader = Reflection.INSTANCE.getClassLoader(ValidationParser.class);
    static Schema getSchema(final String xsd) {
        final ClassLoader loader = Reflection.INSTANCE.getClassLoader(ValidationParser.class);
        final SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
        final URL schemaUrl = loader.getResource(xsd);
        if (System.getSecurityManager() == null) {
            return doNewInstance(cls);
        }
                return doNewInstance(cls);
    private <T> T doNewInstance(final Class<T> cls) {
        try {
            try {
                final BValExtension.Releasable<T> releasable = BValExtension.inject(cls);
                releasables.add(releasable);
                return releasable.getInstance();
            } catch (final Exception e) {
                return cls.newInstance();
            } catch (final NoClassDefFoundError error) {
                return cls.newInstance();
            }
        } catch (final Exception ex) {
            exceptions.add(new ValidationException("Cannot instantiate : "  cls, ex));
            return null; // ensure BootstrapConfiguration can be read even if class can't be instantiated
        }
    }

        final ClassLoader loader = Reflection.INSTANCE.getClassLoader(ValidationParser.class);
        } catch (final ClassNotFoundException ex) {
import org.apache.bval.util.reflection.Reflection;
        addLoader(new XMLMetaBeanURLLoader(Reflection.INSTANCE.getClassLoader(getClass()).getResource(resource)));
        final Class<?> beanClass = getMetaBean().getBeanClass();
        final List<Class<?>> classHierarchy = ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), beanClass);
        Class<?> current = beanClass;

                if (Modifier.isStatic(method.getModifiers()) || method.isSynthetic()) {
                    continue;
                }

                final MethodDescriptorImpl methodDesc = new MethodDescriptorImpl(getMetaBean(), EMPTY_VALIDATION, method);
                        processMethod(overriden, methodDesc);
                if (current == beanClass && parents != null) { // only valid beanClass, other validations are done through inheritance meta building

    private static final Validation[] EMPTY_VALIDATION = new Validation[0];

        super(bean, metaMethod.getMethod().getReturnType(), EMPTY_VALIDATION);
                    return null;
            if (beanManager == null) {
                return null;
            }
            final Class<? extends Annotation> aClass = a.annotationType();
            if (aClass.getName().startsWith("java.lang.annotation.")) {
                continue;
            }

            final Constraint inheritedConstraint = aClass.getAnnotation(Constraint.class);
            if (inheritedConstraint != null && !aClass.getName().startsWith("javax.validation.constraints.")) {
            if (type.getName().startsWith("java.lang.annotation.")) {
                if (each.annotationType().getName().startsWith("java.lang.annotation")) {
                    continue;
                }

    private Map<String, MethodDescriptor> methodConstraints = new HashMap<String, MethodDescriptor>();
    private Map<String, ConstructorDescriptor> contructorConstraints = new HashMap<String, ConstructorDescriptor>();
    private Boolean isBeanConstrained = null;
    private Boolean hasAnyContraints = null;
                    Reflection.INSTANCE.getDeclaredMethod(current, "is"  name),
                    Reflection.INSTANCE.getDeclaredMethod(current, "get"  name))) {
        if (isBeanConstrained == null) {
            synchronized (this) {
                if (isBeanConstrained == null) {
                    if (hasAnyConstraints()) {
                        isBeanConstrained = true;
                    } else {
                        isBeanConstrained = false;
                        for (final MetaProperty mprop : metaBean.getProperties()) {
                            if (mprop.getMetaBean() != null || mprop.getFeature(Features.Property.REF_CASCADE) != null) {
                                isBeanConstrained = true;
                                break;
                            }
                        }
                    }
                }
            }
        return isBeanConstrained;
        if (hasAnyContraints == null) {
            synchronized (this) {
                if (hasAnyContraints == null) {
                    if (hasConstraints()) {
                        hasAnyContraints = true;
                    } else {
                        hasAnyContraints = false;
                        for (final MetaProperty mprop : metaBean.getProperties()) {
                            if (getConstraintDescriptors(mprop.getValidations()).size() > 0) {
                                hasAnyContraints = true;
                                break;
                            }
                        }
                    }
                }
            }
        return hasAnyContraints;
                || (prop.getMetaBean() != null || prop.getFeature(Features.Property.REF_CASCADE) != null)) {
    public MethodDescriptor getConstraintsForMethod(final String methodName, final Class<?>... parameterTypes) {
        final MethodDescriptor methodDescriptor = methodConstraints.get(methodName  Arrays.toString(parameterTypes));
        if (methodDescriptor != null && (methodDescriptor.hasConstrainedParameters() || methodDescriptor.hasConstrainedReturnValue())) {
            return methodDescriptor;
                    break;
    public ConstructorDescriptor getConstraintsForConstructor(final Class<?>... parameterTypes) {
        final ConstructorDescriptor descriptor = contructorConstraints.get(Arrays.toString(parameterTypes));
            contructorConstraints.put(Arrays.toString(cons.getParameterTypes()), consDesc);
        final Class<?> current = getMetaBean().getBeanClass();
        final List<Class<?>> classHierarchy = ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), current);
        classHierarchy.remove(current);
        for (final Method method : Reflection.INSTANCE.getDeclaredMethods(current)) {
            if (Modifier.isStatic(method.getModifiers()) || method.isSynthetic()) {
                continue;
            }
            final boolean getter = (method.getName().startsWith("get") || method.getName().startsWith("is")) && method.getParameterTypes().length == 0 && method.getReturnType() != Void.TYPE;
            final String key = method.getName()  Arrays.toString(method.getParameterTypes());
            MethodDescriptorImpl methodDesc = MethodDescriptorImpl.class.cast(methodConstraints.get(key));
            if (methodDesc == null) {
                methodDesc = new MethodDescriptorImpl(getMetaBean(), EMPTY_VALIDATION, method);
                methodConstraints.put(key, methodDesc);
            } else {
                continue;
            }
            final Collection<Method> parents = new ArrayList<Method>();
            for (final Class<?> clazz : classHierarchy) {
                final Method overriden = Reflection.INSTANCE.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
                if (overriden != null) {
                    parents.add(overriden);
                    processMethod(overriden, methodDesc);
            processMethod(method, methodDesc);

            ensureNotNullDescriptors(method.getReturnType(), methodDesc);

            if (parents != null) {
                if (parents.size() > 1) {
                    for (final Method parent : parents) {
                        final MethodDescriptor parentDec = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
                        if (parentDec != null) {
                            ensureNoParameterConstraint(InvocableElementDescriptor.class.cast(parentDec), "Parameter constraints can't be defined for parallel interfaces/parents");
                        } else {
                            ensureMethodDoesntDefineParameterConstraint(methodDesc);
                        }
                        ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDec, "Return value constraints should be the same for parent and children");
                    }
                } else if (!parents.isEmpty()) {
                    final Method parent = parents.iterator().next();
                    final MethodDescriptor parentDesc = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
                    ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDesc, "Return value constraints should be at least the same for parent and children");

                    if (parentDesc != null) {
                        final Iterator<ParameterDescriptor> parentPd = parentDesc.getParameterDescriptors().iterator();
                        for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
                            final ParameterDescriptor next = parentPd.next();
                            if (pd.getConstraintDescriptors().size() != next.getConstraintDescriptors().size()) {
                                throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
                            }
                            if (pd.isCascaded() != next.isCascaded()) { // @Valid
                                throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
                            }
                        }
                    } else {
                        ensureMethodDoesntDefineParameterConstraint(methodDesc);
                    }
                }

                final Class<?>[] interfaces = method.getDeclaringClass().getInterfaces();
                final Collection<Method> itfWithThisMethod = new ArrayList<Method>();
                for (final Class<?> i : interfaces) {
                    final Method m = Reflection.INSTANCE.getDeclaredMethod(i, method.getName(), method.getParameterTypes());
                    if (m != null) {
                        itfWithThisMethod.add(m);
                    }
                }
                if (itfWithThisMethod.size() > 1) {
                    for (final Method m : itfWithThisMethod) {
                        ensureNoConvertGroup(m, "ConvertGroup can't be used in parallel interfaces");
                    }
                } else if (itfWithThisMethod.size() == 1) {
                    ensureNoConvertGroup(itfWithThisMethod.iterator().next(), "ConvertGroup can't be used in interface AND parent class");
                }

                int returnValid = 0;
                if (method.getAnnotation(Valid.class) != null) {
                    returnValid;
                }
                for (final Class<?> clazz : classHierarchy) {
                    final Method overriden = Reflection.INSTANCE.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
                    if (overriden != null) {
                        if (overriden.getAnnotation(Valid.class) != null) {
                            returnValid;
                        }
                    }
                }
                if (returnValid > 1 && !(interfaces.length == returnValid && method.getAnnotation(Valid.class) == null)) {
                    throw new ConstraintDeclarationException("@Valid on returned value can't be set more than once");
                }
            }

            if (getter) {
                final MetaProperty prop = metaBean.getProperty(Introspector.decapitalize(method.getName().substring(3)));
                if (prop != null && prop.getFeature(Features.Property.REF_CASCADE) != null) {
                    methodDesc.setCascaded(true);
                }
            }

            if (!methodDesc.getGroupConversions().isEmpty() && !methodDesc.isCascaded()) {
                throw new ConstraintDeclarationException("@Valid is needed to define a group conversion");
            }
        }

        for (final Class<?> parent : classHierarchy) {
            final BeanDescriptorImpl desc = BeanDescriptorImpl.class.cast(factoryContext.getValidator().getConstraintsForClass(parent));
            for (final String s : desc.methodConstraints.keySet()) {
                if (!methodConstraints.containsKey(s)) { // method from the parent only
                    methodConstraints.put(s, desc.methodConstraints.get(s));
                }
            }
        }
        throws InvocationTargetException, IllegalAccessException {
                validations.getValidations().toArray(new Validation[validations.getValidations().size()]), name);
        // return MethodDescriptorImpl.class.cast(getConstraintsForClass(Proxies.classFor(object.getClass())).getConstraintsForMethod(method.getName(), method.getParameterTypes()));
        return MethodDescriptorImpl.class.cast(getConstraintsForClass(Proxies.classFor(method.getDeclaringClass())).getConstraintsForMethod(method.getName(), method.getParameterTypes()));
    private Boolean useCdi = null; // store it to avoid NoClassDefFoundError when cdi is not present (it is slow)  lazily (to wait cdi is started)
        if (useCdi == null) {
            synchronized (this) {
                if (useCdi == null) {
                    try {
                        useCdi = BValExtension.getInstance() != null && BValExtension.getInstance().getBeanManager() != null;
                    } catch (final NoClassDefFoundError error) {
                        useCdi = false;
                    } catch (final Exception e) {
                        useCdi = false;
                    }
                }
            }
        }

            if (useCdi) {
                try {
                    final BValExtension.Releasable<T> instance = BValExtension.inject(constraintClass);
                    releasables.add(instance);
                    return instance.getInstance();
                } catch (final Exception e) {
                    return constraintClass.newInstance();
                } catch (final NoClassDefFoundError error) {
                    return constraintClass.newInstance();
                }
            return constraintClass.newInstance();
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import static org.apache.bval.model.Features.Property.REF_BEAN_ID;
import static org.apache.bval.model.Features.Property.REF_BEAN_TYPE;
import static org.apache.bval.model.Features.Property.REF_CASCADE;
    protected final ConcurrentMap<Object, Object> cacheLocks = new ConcurrentHashMap<Object, Object>();

    public MetaBean findForId(final String beanInfoId) {
        if (beanInfo != null) {

        synchronized (getLockFor(beanInfoId)) {
            beanInfo = cache.findForId(beanInfoId);
            if (beanInfo != null) {
                return beanInfo;
            }

            try {
                beanInfo = builder.buildForId(beanInfoId);
                cache.cache(beanInfo);
                computeRelationships(beanInfo);
                return beanInfo;
            } catch (final RuntimeException e) {
                throw e; // do not wrap runtime exceptions
            } catch (final Exception e) {
                throw new IllegalArgumentException("error creating beanInfo with id: "  beanInfoId, e);
            }
        }
    }

    private Object getLockFor(final Object key) {
        final Object newLock = new Object();
        Object lock = cacheLocks.putIfAbsent(key, newLock);
        if (lock == null) {
            lock = newLock;
        }
        return lock;
    public MetaBean findForClass(final Class<?> clazz) {
        if (clazz == null) {
        }

        if (beanInfo != null) {
        }

        synchronized (getLockFor(clazz)) {
            beanInfo = cache.findForClass(clazz);
            if (beanInfo != null) {
                return beanInfo;
            }

            try {
                beanInfo = builder.buildForClass(clazz);
                cache.cache(beanInfo);
                computeRelationships(beanInfo);
                return beanInfo;
            } catch (final RuntimeException e) {
                throw e; // do not wrap runtime exceptions
            } catch (final Exception e) {
                throw new IllegalArgumentException("error creating beanInfo for "  clazz, e);
            }
        for (final MetaProperty prop : beanInfo.getProperties()) {
            final String beanRef = prop.getFeature(REF_BEAN_ID);
    private final MetaBeanFinder metaBeanFinder;

        metaBeanFinder = factoryContext.getMetaBeanFinder();
            final MetaBean objectMetaBean = metaBeanFinder.findForClass(objectClass);
            MetaBean metaBean = metaBeanFinder.findForClass(clazz); // don't throw an exception because of a missing validator here
            final MetaBean initialMetaBean = new DynamicMetaBean(metaBeanFinder);
                    context.setMetaBean(metaBeanFinder.findForClass(value.getClass()));

        String EXECUTABLES = "executables";
    private final ExecutableMeta meta;
        ExecutableMeta executables = metaBean.getFeature(Jsr303Features.Bean.EXECUTABLES);
        if (executables == null) { // caching the result of it is important to avoid to compute it for each Validator
            executables = new ExecutableMeta(factoryContext, metaBean, getConstraintDescriptors());
            metaBean.putFeature(Jsr303Features.Bean.EXECUTABLES, executables);
        }

        meta = executables;
        isBeanConstrained = meta.isBeanConstrained;
        hasAnyContraints = meta.hasAnyContraints;
        setConstrained(containedMethods, meta.methodConstraints.values());
        setConstrained(constrainedConstructors, meta.contructorConstraints.values());

        final MethodDescriptor methodDescriptor = meta.methodConstraints.get(methodName  Arrays.toString(parameterTypes));
        final ConstructorDescriptor descriptor = meta.contructorConstraints.get(Arrays.toString(parameterTypes));
    private static class ExecutableMeta {
        private final ApacheFactoryContext factoryContext;
        private final AnnotationProcessor annotationProcessor;
        private final MetaBean metaBean;
        private final Map<String, MethodDescriptor> methodConstraints = new HashMap<String, MethodDescriptor>();
        private final Map<String, ConstructorDescriptor> contructorConstraints = new HashMap<String, ConstructorDescriptor>();
        private Boolean isBeanConstrained = null;
        private Boolean hasAnyContraints = null;
        private ExecutableMeta(final ApacheFactoryContext factoryContext, final MetaBean metaBean1, final Collection<ConstraintDescriptor<?>> constraintDescriptors) {
            this.metaBean = metaBean1;
            this.factoryContext = factoryContext;
            this.annotationProcessor = new AnnotationProcessor(factoryContext);
            buildExecutableDescriptors();
            // cache hasAnyContraints
            if (!constraintDescriptors.isEmpty()) {
                hasAnyContraints = true;
            } else {
                hasAnyContraints = false;
                for (final MetaProperty mprop : metaBean.getProperties()) {
                    if (getConstraintDescriptors(mprop.getValidations()).size() > 0) {
                        hasAnyContraints = true;
                        break;
                    }
                }
            }
            // cache isBeanConstrained
            if (hasAnyContraints) {
                isBeanConstrained = true;
            } else {
                isBeanConstrained = false;
                for (final MetaProperty mprop : metaBean.getProperties()) {
                    if (mprop.getMetaBean() != null || mprop.getFeature(Features.Property.REF_CASCADE) != null) {
                        isBeanConstrained = true;
                        break;
                    }
                }
            }
        }

        private void buildConstructorConstraints() throws InvocationTargetException, IllegalAccessException {
            for (final Constructor<?> cons : Reflection.INSTANCE.getDeclaredConstructors(metaBean.getBeanClass())) {
                final ConstructorDescriptorImpl consDesc = new ConstructorDescriptorImpl(metaBean, new Validation[0]);
                contructorConstraints.put(Arrays.toString(cons.getParameterTypes()), consDesc);

                final List<String> names = factoryContext.getParameterNameProvider().getParameterNames(cons);
                final boolean isInnerClass = cons.getDeclaringClass().getEnclosingClass() != null && !Modifier.isStatic(cons.getDeclaringClass().getModifiers());

                final AnnotationIgnores annotationIgnores = factoryContext.getFactory().getAnnotationIgnores();

                {
                    final Annotation[][] paramsAnnos = cons.getParameterAnnotations();

                    int idx = 0;
                    if (isInnerClass) { // paramsAnnos.length = parameterTypes.length - 1 in this case
                        final ParameterDescriptorImpl paramDesc = new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx));
                        consDesc.getParameterDescriptors().add(paramDesc);
                        idx;
                    }

                    for (final Annotation[] paramAnnos : paramsAnnos) {
                        if (annotationIgnores.isIgnoreAnnotationOnParameter(cons, idx)) {
                            consDesc.getParameterDescriptors().add(new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx)));
                        } else if (cons.getParameterTypes().length > idx) {
                            ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
                            consDesc.addValidations(processAnnotations(consDesc, paramAnnos, access, idx, names.get(idx)).getValidations());
                        } // else anonymous class so that's fine
                        idx;
                    }

                    if (!annotationIgnores.isIgnoreAnnotations(cons)) {
                        for (final Annotation anno : cons.getAnnotations()) {
                            if (!Valid.class.isInstance(anno)) {
                                processAnnotations(null, consDesc, cons.getDeclaringClass(), anno);
                            } else {
                                consDesc.setCascaded(true);
                            }
                        }
                    }
                if (annotationIgnores.isIgnoreAnnotationOnCrossParameter(cons) && consDesc.getCrossParameterDescriptor() != null) {
                    consDesc.setCrossParameterDescriptor(null);
                }
                if (annotationIgnores.isIgnoreAnnotationOnReturn(cons) && consDesc.getReturnValueDescriptor() != null) {
                    consDesc.setReturnValueDescriptor(null);
                final MetaConstructor metaConstructor = metaBean.getConstructor(cons);
                if (metaConstructor != null) {
                    for (final Annotation anno : metaConstructor.getAnnotations()) {
                    // parameter validations
                    final Collection<MetaParameter> paramsAnnos = metaConstructor.getParameters();
                    for (final MetaParameter paramAnnos : paramsAnnos) {
                        final int idx = paramAnnos.getIndex();
                        final ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
                        processAnnotations(consDesc, paramAnnos.getAnnotations(), access, idx, names.get(idx));
                if (!consDesc.getGroupConversions().isEmpty() && !consDesc.isCascaded()) {
                    throw new ConstraintDeclarationException("@Valid is needed to define a group conversion");
                }

                ensureNotNullDescriptors(cons.getDeclaringClass(), consDesc);
            }
        }

        private void ensureNotNullDescriptors(final Class<?> returnType, final InvocableElementDescriptor consDesc) {
            // can't be null
            if (consDesc.getCrossParameterDescriptor() == null) {
                consDesc.setCrossParameterDescriptor(new CrossParameterDescriptorImpl(metaBean, NO_CONSTRAINTS));
            }
            if (consDesc.getReturnValueDescriptor() == null) {
                consDesc.setReturnValueDescriptor(new ReturnValueDescriptorImpl(metaBean, returnType, NO_CONSTRAINTS, consDesc.isCascaded()));
            }
            // enforce it since ReturnValueDescriptor can be created before cascaded is set to true
            final ReturnValueDescriptorImpl returnValueDescriptor = ReturnValueDescriptorImpl.class.cast(consDesc.getReturnValueDescriptor());
            returnValueDescriptor.setCascaded(consDesc.isCascaded());
            if (returnValueDescriptor.getGroupConversions().isEmpty()) {
                // loop to not forget to map calling addGroupConversion()
                for (final GroupConversionDescriptor c : consDesc.getGroupConversions()) {
                    returnValueDescriptor.addGroupConversion(c);
        private void processAnnotations(final Method mtd, final InvocableElementDescriptor consDesc, final Class<?> clazz, final Annotation anno) throws InvocationTargetException, IllegalAccessException {
            if (mtd == null || !factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnReturn(mtd)) {
                final ReturnAccess returnAccess = new ReturnAccess(clazz);
                final AppendValidationToList validations = new AppendValidationToList();
                processAnnotation(anno, consDesc, returnAccess, validations);
                final List<ConstraintValidation<?>> list = removeFromListValidationAppliesTo(validations.getValidations(), ConstraintTarget.PARAMETERS);
                consDesc.addValidations(list);
                ReturnValueDescriptorImpl returnValueDescriptor = ReturnValueDescriptorImpl.class.cast(consDesc.getReturnValueDescriptor());
                if (consDesc.getReturnValueDescriptor() != null) {
                    returnValueDescriptor.getMutableConstraintDescriptors().addAll(list);
                } else {
                    returnValueDescriptor = new ReturnValueDescriptorImpl(metaBean, clazz, list, consDesc.isCascaded());
                    consDesc.setReturnValueDescriptor(returnValueDescriptor);
            if (mtd == null || !factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnCrossParameter(mtd)) {
                final ParametersAccess parametersAccess = new ParametersAccess();
                final AppendValidationToList validations = new AppendValidationToList();
                processAnnotation(anno, consDesc, parametersAccess, validations);
                final List<ConstraintValidation<?>> list = removeFromListValidationAppliesTo(validations.getValidations(), ConstraintTarget.RETURN_VALUE);
                consDesc.addValidations(list);
                if (consDesc.getCrossParameterDescriptor() != null) {
                    CrossParameterDescriptorImpl.class.cast(consDesc.getCrossParameterDescriptor()).getMutableConstraintDescriptors().addAll(list);
                } else {
                    consDesc.setCrossParameterDescriptor(new CrossParameterDescriptorImpl(metaBean, list));
                }
            }
        }
        private static List<ConstraintValidation<?>> removeFromListValidationAppliesTo(final List<ConstraintValidation<?>> validations, final ConstraintTarget constraint) {
            final Iterator<ConstraintValidation<?>> i = validations.iterator();
            while (i.hasNext()) {
                if (constraint.equals(i.next().getValidationAppliesTo())) {
                    i.remove();
                }
            }
            return validations;
        }
        private void buildMethodConstraints() throws InvocationTargetException, IllegalAccessException {
            final Class<?> current = metaBean.getBeanClass();
            final List<Class<?>> classHierarchy = ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), current);
            classHierarchy.remove(current);

            for (final Method method : Reflection.INSTANCE.getDeclaredMethods(current)) {
                if (Modifier.isStatic(method.getModifiers()) || method.isSynthetic()) {
                    continue;
                final boolean getter = (method.getName().startsWith("get") || method.getName().startsWith("is")) && method.getParameterTypes().length == 0 && method.getReturnType() != Void.TYPE;

                final String key = method.getName()  Arrays.toString(method.getParameterTypes());
                MethodDescriptorImpl methodDesc = MethodDescriptorImpl.class.cast(methodConstraints.get(key));
                if (methodDesc == null) {
                    methodDesc = new MethodDescriptorImpl(metaBean, EMPTY_VALIDATION, method);
                    methodConstraints.put(key, methodDesc);
                } else {
                    continue;
                final Collection<Method> parents = new ArrayList<Method>();
                        parents.add(overriden);
                        processMethod(overriden, methodDesc);

                processMethod(method, methodDesc);

                ensureNotNullDescriptors(method.getReturnType(), methodDesc);

                if (parents != null) {
                    if (parents.size() > 1) {
                        for (final Method parent : parents) {
                            final MethodDescriptor parentDec = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
                            if (parentDec != null) {
                                ensureNoParameterConstraint(InvocableElementDescriptor.class.cast(parentDec), "Parameter constraints can't be defined for parallel interfaces/parents");
                            } else {
                                ensureMethodDoesntDefineParameterConstraint(methodDesc);
                            }
                            ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDec, "Return value constraints should be the same for parent and children");
                        }
                    } else if (!parents.isEmpty()) {
                        final Method parent = parents.iterator().next();
                        final MethodDescriptor parentDesc = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
                        ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDesc, "Return value constraints should be at least the same for parent and children");

                        if (parentDesc != null) {
                            final Iterator<ParameterDescriptor> parentPd = parentDesc.getParameterDescriptors().iterator();
                            for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
                                final ParameterDescriptor next = parentPd.next();
                                if (pd.getConstraintDescriptors().size() != next.getConstraintDescriptors().size()) {
                                    throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
                                }
                                if (pd.isCascaded() != next.isCascaded()) { // @Valid
                                    throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
                                }
                            }
                        } else {
                            ensureMethodDoesntDefineParameterConstraint(methodDesc);
                        }
                    }

                    final Class<?>[] interfaces = method.getDeclaringClass().getInterfaces();
                    final Collection<Method> itfWithThisMethod = new ArrayList<Method>();
                    for (final Class<?> i : interfaces) {
                        final Method m = Reflection.INSTANCE.getDeclaredMethod(i, method.getName(), method.getParameterTypes());
                        if (m != null) {
                            itfWithThisMethod.add(m);
                        }
                    }
                    if (itfWithThisMethod.size() > 1) {
                        for (final Method m : itfWithThisMethod) {
                            ensureNoConvertGroup(m, "ConvertGroup can't be used in parallel interfaces");
                        }
                    } else if (itfWithThisMethod.size() == 1) {
                        ensureNoConvertGroup(itfWithThisMethod.iterator().next(), "ConvertGroup can't be used in interface AND parent class");
                    }

                    int returnValid = 0;
                    if (method.getAnnotation(Valid.class) != null) {
                        returnValid;
                    }
                    for (final Class<?> clazz : classHierarchy) {
                        final Method overriden = Reflection.INSTANCE.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
                        if (overriden != null) {
                            if (overriden.getAnnotation(Valid.class) != null) {
                                returnValid;
                            }
                        }
                    }
                    if (returnValid > 1 && !(interfaces.length == returnValid && method.getAnnotation(Valid.class) == null)) {
                        throw new ConstraintDeclarationException("@Valid on returned value can't be set more than once");
                    }
                }

                if (getter) {
                    final MetaProperty prop = metaBean.getProperty(Introspector.decapitalize(method.getName().substring(3)));
                    if (prop != null && prop.getFeature(Features.Property.REF_CASCADE) != null) {
                        methodDesc.setCascaded(true);
                    }
                }

                if (!methodDesc.getGroupConversions().isEmpty() && !methodDesc.isCascaded()) {
                    throw new ConstraintDeclarationException("@Valid is needed to define a group conversion");
            for (final Class<?> parent : classHierarchy) {
                final BeanDescriptorImpl desc = BeanDescriptorImpl.class.cast(factoryContext.getValidator().getConstraintsForClass(parent));
                for (final String s : desc.meta.methodConstraints.keySet()) {
                    if (!methodConstraints.containsKey(s)) { // method from the parent only
                        methodConstraints.put(s, desc.meta.methodConstraints.get(s));
                    }
        private void ensureMethodDoesntDefineParameterConstraint(MethodDescriptorImpl methodDesc) {
            for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
                if (!pd.getConstraintDescriptors().isEmpty()) {
                    throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
                }
                if (pd.isCascaded()) { // @Valid
                    throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
                }
        private void ensureNoReturnValueAddedInChild(final ReturnValueDescriptor returnValueDescriptor, final MethodDescriptor parentMtdDesc, final String msg) {
            if (parentMtdDesc == null) {
                return;
            }
            final ReturnValueDescriptor parentReturnDesc = parentMtdDesc.getReturnValueDescriptor();
            if (parentReturnDesc.isCascaded() && !returnValueDescriptor.isCascaded() || parentReturnDesc.getConstraintDescriptors().size() > returnValueDescriptor.getConstraintDescriptors().size()) {
        private static void ensureNoParameterConstraint(final InvocableElementDescriptor constraintsForMethod, final String msg) {
            for (final ParameterDescriptor parameterDescriptor : constraintsForMethod.getParameterDescriptors()) {
                if (!parameterDescriptor.getConstraintDescriptors().isEmpty() || parameterDescriptor.isCascaded()) {
        private static void ensureNoConvertGroup(final Method method, final String msg) {
            for (final Annotation[] annotations : method.getParameterAnnotations()) {
                for (final Annotation a : annotations) {
                    if (ConvertGroup.class.isInstance(a)) {
                        throw new ConstraintDeclarationException(msg);
            if (method.getAnnotation(ConvertGroup.class) != null) {
                throw new ConstraintDeclarationException(msg);
        private void processMethod(final Method method, final MethodDescriptorImpl methodDesc) throws InvocationTargetException, IllegalAccessException {
            final AnnotationIgnores annotationIgnores = factoryContext.getFactory().getAnnotationIgnores();
            { // reflection
                if (!annotationIgnores.isIgnoreAnnotations(method)) {
                    // return value validations and/or cross-parameter validation
                    for (Annotation anno : method.getAnnotations()) {
                        if (anno instanceof Valid || anno instanceof Validate) {
                            methodDesc.setCascaded(true);
                        } else {
                            processAnnotations(method, methodDesc, method.getReturnType(), anno);

                // parameter validations
                final Annotation[][] paramsAnnos = method.getParameterAnnotations();
                int idx = 0;
                final List<String> names = factoryContext.getParameterNameProvider().getParameterNames(method);
                for (final Annotation[] paramAnnos : paramsAnnos) {
                    if (!annotationIgnores.isIgnoreAnnotationOnParameter(method, idx)) {
                        final ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
                        processAnnotations(methodDesc, paramAnnos, access, idx, names.get(idx));
                    } else {
                        final ParameterDescriptorImpl parameterDescriptor = new ParameterDescriptorImpl(metaBean, new Validation[0], names.get(idx));
                        parameterDescriptor.setIndex(idx);
                        methodDesc.getParameterDescriptors().add(parameterDescriptor);
                    }
                    idx;
                }
            }

            if (annotationIgnores.isIgnoreAnnotationOnCrossParameter(method) && methodDesc.getCrossParameterDescriptor() != null) {
                methodDesc.setCrossParameterDescriptor(null);
            }
            if (annotationIgnores.isIgnoreAnnotationOnReturn(method) && methodDesc.getReturnValueDescriptor() != null) {
                methodDesc.setReturnValueDescriptor(null);
            }

            final MetaMethod metaMethod = metaBean.getMethod(method);
            if (metaMethod != null) {
                for (final Annotation anno : metaMethod.getAnnotations()) {
                    if (anno instanceof Valid) {
                        methodDesc.setCascaded(true);
                    } else {
                        // set first param as null to force it to be read
                        processAnnotations(null, methodDesc, method.getReturnType(), anno);
                    }
                }

                // parameter validations
                final Collection<MetaParameter> paramsAnnos = metaMethod.getParameters();
                final List<String> names = factoryContext.getParameterNameProvider().getParameterNames(method);
                for (final MetaParameter paramAnnos : paramsAnnos) {
                    final int idx = paramAnnos.getIndex();
                    final ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
                    processAnnotations(methodDesc, paramAnnos.getAnnotations(), access, idx, names.get(idx));
                }

            }

        }

        private AppendValidationToList processAnnotations(InvocableElementDescriptor methodDesc, Annotation[] paramAnnos, AccessStrategy access, int idx, String name)
            throws InvocationTargetException, IllegalAccessException {
            final AppendValidationToList validations = new AppendValidationToList();
            boolean cascaded = false;

            Group[] from = null;
            Group[] to = null;

            for (final Annotation anno : paramAnnos) {
                if (anno instanceof Valid || anno instanceof Validate) {
                    cascaded = true;
                } else if (ConvertGroup.class.isInstance(anno)) {
                    final ConvertGroup cg = ConvertGroup.class.cast(anno);
                    from = new Group[]{new Group(cg.from())};
                    to = new Group[]{new Group(cg.to())};
                } else if (ConvertGroup.List.class.isInstance(anno)) {
                    final ConvertGroup.List cgl = ConvertGroup.List.class.cast(anno);
                    final ConvertGroup[] groups = cgl.value();
                    from = new Group[groups.length];
                    to = new Group[groups.length];
                    for (int i = 0; i < to.length; i) {
                        from[i] = new Group(groups[i].from());
                        to[i] = new Group(groups[i].to());
                    }
                } else {
                    processAnnotation(anno, methodDesc, access, validations);
                }
            }

            ParameterDescriptorImpl paramDesc = null;
            for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
                if (pd.getIndex() == idx) {
                    paramDesc = ParameterDescriptorImpl.class.cast(pd);
                }
            }

            if (paramDesc == null) {
                paramDesc = new ParameterDescriptorImpl(Class.class.cast(access.getJavaType()), // set from getParameterTypes() so that's a Class<?>
                    validations.getValidations().toArray(new Validation[validations.getValidations().size()]), name);
                paramDesc.setIndex(idx);
                final List<ParameterDescriptor> parameterDescriptors = methodDesc.getParameterDescriptors();
                if (!parameterDescriptors.contains(paramDesc)) {
                    parameterDescriptors.add(paramDesc);
                }
                paramDesc.setCascaded(cascaded);
            } else {
                final List<ConstraintValidation<?>> newValidations = validations.getValidations();
                for (final ConstraintValidation<?> validation : newValidations) { // don't add it if exactly the same is already here
                    boolean alreadyHere = false;
                    for (final ConstraintDescriptor<?> existing : paramDesc.getMutableConstraintDescriptors()) {
                        if (existing.getAnnotation().annotationType().equals(validation.getAnnotation().annotationType())) { // TODO: make it a bit finer
                            alreadyHere = true;
                            break;
                        }
                    }
                    if (!alreadyHere) {
                        paramDesc.getMutableConstraintDescriptors().add(validation);
                    }
                }

                if (cascaded) {
                    paramDesc.setCascaded(true);
                } // else keep previous config
            }
            if (paramDesc.isCascaded() && from != null) {
                for (int i = 0; i < from.length; i) {
                    paramDesc.addGroupConversion(new GroupConversionDescriptorImpl(from[i], to[i]));
                }
            } else if (from != null) {
                throw new ConstraintDeclarationException("Group conversion is only relevant for @Valid cases");
            }

            return validations;
        }

        private <A extends Annotation> void processAnnotation(final A annotation, final InvocableElementDescriptor desc,
                                                              final AccessStrategy access, final AppendValidation validations) throws InvocationTargetException, IllegalAccessException {
            if (annotation.annotationType().getName().startsWith("java.lang.annotation.")) {
                return;
            }

            if (annotation instanceof Valid || annotation instanceof Validate) {
                desc.setCascaded(true);
            } else if (ConvertGroup.class.isInstance(annotation) && ReturnAccess.class.isInstance(access)) { // access is just tested to ensure to not read it twice with cross parameter
                final ConvertGroup cg = ConvertGroup.class.cast(annotation);
                desc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(cg.from()), new Group(cg.to())));
            } else if (ConvertGroup.List.class.isInstance(annotation) && ReturnAccess.class.isInstance(access)) {
                final ConvertGroup.List cgl = ConvertGroup.List.class.cast(annotation);
                for (final ConvertGroup cg : cgl.value()) {
                    desc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(cg.from()), new Group(cg.to())));
                }
            } else {
                Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
                if (vcAnno != null) {
                    annotationProcessor.processAnnotation(annotation, null, ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations, true);
                } else {
                    /**
                     * Multi-valued constraints
                     */
                    final ConstraintAnnotationAttributes.Worker<? extends Annotation> worker = ConstraintAnnotationAttributes.VALUE.analyze(annotation.annotationType());
                    if (worker.isValid()) {
                        Annotation[] children = Annotation[].class.cast(worker.read(annotation));
                        if (children != null) {
                            for (Annotation child : children) {
                                processAnnotation(child, desc, access, validations); // recursion
                            }
                        }
                    }
                }
            }
        }

        private void buildExecutableDescriptors() {
            try {
                buildMethodConstraints();
                buildConstructorConstraints();
            } catch (final Exception ex) {
                if (RuntimeException.class.isInstance(ex)) {
                    throw RuntimeException.class.cast(ex);
                }

                throw new IllegalArgumentException(ex.getMessage(), ex);
        // feed the cache with defaults at least
        findDefaultResourceBundle(defaultLocale);
            findUserResourceBundle(defaultLocale);
    protected static Set<ConstraintDescriptor<?>> getConstraintDescriptors(final Validation[] validations) {
    private static final ELResolver RESOLVER = initResolver();
                final BValELContext context = new BValELContext();
                final VariableMapper variables = context.getVariableMapper();
                for (final Map.Entry<String, Object> var : annotationParameters.entrySet()) {
                    variables.setVariable(var.getKey(), EXPRESSION_FACTORY.createValueExpression(var.getValue(), Object.class));
                }
                variables.setVariable("validatedValue", EXPRESSION_FACTORY.createValueExpression(validatedValue, Object.class));

        public BValELContext() {
            return RESOLVER;
                return EXPRESSION_FACTORY.createValueExpression(new BValFormatter(), Object.class);
    private final int hashCode;
        this.hashCode = computeHashCode();
        return hashCode;
    }

    public int computeHashCode() {
    private final int hashCode;
        this.hashCode = computeHashCode();
        return hashCode;
    }

    public int computeHashCode() {
        String PROPERTIES = "properties";
    private final Set<ConstructorDescriptor> constrainedConstructors;
    private final Set<MethodDescriptor> containedMethods;
    private final Boolean isBeanConstrained;
    private final Set<PropertyDescriptor> validatedProperties;
    protected BeanDescriptorImpl(final ApacheFactoryContext factoryContext, final MetaBean metaBean) {
        Set<PropertyDescriptor> procedureDescriptors = metaBean.getFeature(Jsr303Features.Bean.PROPERTIES);
        if (procedureDescriptors == null) {
            procedureDescriptors = new HashSet<PropertyDescriptor>();
            for (final MetaProperty prop : metaBean.getProperties()) {
                if (prop.getValidations().length > 0
                    || (prop.getMetaBean() != null || prop.getFeature(Features.Property.REF_CASCADE) != null)) {
                    procedureDescriptors.add(getPropertyDescriptor(prop));
                }
            }
            metaBean.putFeature(Jsr303Features.Bean.PROPERTIES, procedureDescriptors);
        }

        validatedProperties = Collections.unmodifiableSet(procedureDescriptors);
        containedMethods = toConstrained(meta.methodConstraints.values());
        constrainedConstructors = toConstrained(meta.contructorConstraints.values());
    private static <A extends ExecutableDescriptor> Set<A> toConstrained(final Collection<A> src) {
        final Set<A> dest = new HashSet<A>();
        return Collections.unmodifiableSet(dest);
            boolean hasAnyContraints = false;
     * @param builder meta bean builder
        try {
            beanInfo = builder.buildForId(beanInfoId);
            cache.cache(beanInfo);
            computeRelationships(beanInfo);
            return beanInfo;
        } catch (final RuntimeException e) {
            throw e; // do not wrap runtime exceptions
        } catch (final Exception e) {
            throw new IllegalArgumentException("error creating beanInfo with id: "  beanInfoId, e);
        try {
            beanInfo = builder.buildForClass(clazz);
            cache.cache(beanInfo);
            computeRelationships(beanInfo);
            return beanInfo;
        } catch (final RuntimeException e) {
            throw e; // do not wrap runtime exceptions
        } catch (final Exception e) {
            throw new IllegalArgumentException("error creating beanInfo for "  clazz, e);
     * @param prop meta property
     * @param beanRef bean reference
import org.apache.commons.lang3.ArrayUtils;

        final T value = (T) features.get(key);
        if (value == null) {
            return defaultValue;
        return value;
     *
    public <T> void putFeature(final String key, final T value) {
        features.put(key, value);
    }

    public <T> T initFeature(final String key, final T value) {
        final T old = (T) features.putIfAbsent(key, value);
        if (old != null) {
            return old;
        return value;
        if (result == null && bmi.cdi == null) {
                    bmi.cdi = false;
                bmi.cdi = true;
        private Boolean cdi = null;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
    private final ConcurrentMap<Class<?>, List<AccessStrategy>> validAccesses;
    private final ConcurrentMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>> constraintMap;
    public static ApacheValidatorFactory getDefault() {
            synchronized (ApacheValidatorFactory.class) {
                if (DEFAULT_FACTORY == null) {
                    DEFAULT_FACTORY = Validation.byProvider(ApacheValidationProvider.class).configure()
                        .buildValidatorFactory().unwrap(ApacheValidatorFactory.class);
                }
            }
        validAccesses = new ConcurrentHashMap<Class<?>, List<AccessStrategy>>();
        constraintMap = new ConcurrentHashMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>>();
        List<MetaConstraint<?, ? extends Annotation>> slot = constraintMap.get(beanClass);
        if (slot == null) {
            slot = new ArrayList<MetaConstraint<?, ? extends Annotation>>();
            final List<MetaConstraint<?, ? extends Annotation>> old = constraintMap.putIfAbsent(beanClass, slot);
            if (old != null) {
                slot = old;
        List<AccessStrategy> slot = validAccesses.get(beanClass);
        if (slot == null) {
            slot = new ArrayList<AccessStrategy>();
            final List<AccessStrategy> old = validAccesses.putIfAbsent(beanClass, slot);
            if (old != null) {
                slot = old;
            procedureDescriptors = metaBean.initFeature(Jsr303Features.Bean.PROPERTIES, procedureDescriptors);
            executables = metaBean.initFeature(Jsr303Features.Bean.EXECUTABLES, executables);
    private volatile ValidationParser parser;
        return createBootstrapConfiguration();
        createBootstrapConfiguration();
    private BootstrapConfiguration createBootstrapConfiguration() {
        if (parser == null) {
            parser = parseValidationXml(); // already done if BootstrapConfiguration already looked up
            bootstrapConfiguration = parser.getBootstrap();
        }
        return bootstrapConfiguration;
    }

            groupSeq = metabean.initFeature(key, new ArrayList<Group>(annotation == null ? 1 : annotation.value().length));
import java.util.concurrent.ConcurrentHashMap;
    private final Map<Class<?>, List<Group>> resolvedSequences = new ConcurrentHashMap<Class<?>, List<Group>>();
            boolean hasAnyContraints;
                method = Reflection.INSTANCE.getPublicMethod(constraintType, attributeName);
                    error = new ConstraintDefinitionException("Annotation "  constraintType  " has no "  attributeName  " method");
                 if (!TypeUtils.isAssignable(method.getReturnType(), type)) {
                    error = new ConstraintDefinitionException("Return type for "  attributeName  "() must be of type "  type);
                if (TypeUtils.isArrayType(type) && Array.getLength(_defaultValue) > 0) {
                    error = new ConstraintDefinitionException("Default value for "  attributeName  "() must be an empty array");
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
    // this is static but related to Worker
    private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Method>> METHOD_BY_NAME_AND_CLASS = new ConcurrentHashMap<Class<?>, ConcurrentMap<String, Method>>();
    private static final Method NULL_METHOD;
    static {
        try {
            NULL_METHOD = Object.class.getMethod("hashCode"); // whatever, the only constraint here is to not use a constraint method, this value is used to cache null
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("Impossible normally");
        }
    }

                method = findMethod(constraintType, attributeName);
                if (method == null || method == NULL_METHOD) {
        private Method findMethod(final Class<C> constraintType, final String attributeName) {
            ConcurrentMap<String, Method> cache = METHOD_BY_NAME_AND_CLASS.get(constraintType);
            if (cache == null) {
                cache = new ConcurrentHashMap<String, Method>();
                final ConcurrentMap<String, Method> old = METHOD_BY_NAME_AND_CLASS.putIfAbsent(constraintType, cache);
                if (old != null) {
                    cache = old;
                }
            }

            final Method found = cache.get(attributeName);
            if (found != null) {
                return found;
            }
            final Method m = Reflection.INSTANCE.getPublicMethod(constraintType, attributeName);
            if (m == null) {
                cache.putIfAbsent(attributeName, NULL_METHOD);
                return null;
            }
            final Method oldMtd = cache.putIfAbsent(attributeName, m);
            if (oldMtd != null) {
                return oldMtd;
            }
            return m;
        }

        final Map<String, Object> result = new HashMap<String, Object>();
        for (final Method m : descriptor.getMethods()) {
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
    private static final ConcurrentMap<Class<?>, Method[]> METHODS_CACHE = new ConcurrentHashMap<Class<?>, Method[]>();

    private final Method[] methods;
    public AnnotationProxyBuilder(final Class<A> annotationType) {
        if (annotationType.getName().startsWith("javax.validation.constraints.")) { // cache built-in constraints only to avoid mem leaks
            Method[] mtd = METHODS_CACHE.get(annotationType);
            if (mtd == null) {
                final Method[] value = Reflection.INSTANCE.getDeclaredMethods(type);
                mtd = METHODS_CACHE.putIfAbsent(annotationType, value);
                if (mtd == null) {
                    mtd = value;
                }
            }
            this.methods = mtd;
        } else {
            this.methods = Reflection.INSTANCE.getDeclaredMethods(type);
        }
    public Method[] getMethods() {
        return methods;
    }

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
    private static final String VALIDATION_CONFIGURATION_XSD = "META-INF/validation-configuration-1.1.xsd";
    private static final ConcurrentMap<String, Schema> SCHEMA_CACHE = new ConcurrentHashMap<String, Schema>(1);
    protected static InputStream getInputStream(final String path) throws IOException {
        final ClassLoader loader = Reflection.INSTANCE.getClassLoader(ValidationParser.class);
        final InputStream inputStream = loader.getResourceAsStream(path);
            final Enumeration<URL> urls = loader.getResources(path);
                final String url = urls.nextElement().toString();
        final Schema schema = SCHEMA_CACHE.get(xsd);
        if (schema != null) {
            return schema;
        }

            Schema s = sf.newSchema(schemaUrl);
            final Schema old = SCHEMA_CACHE.putIfAbsent(xsd, s);
            if (old != null) {
                s = old;
            }
            return s;
        for (final Method method : AnnotationProxyBuilder.findMethods(annotationType)) {
        this.methods = findMethods(annotationType);
    }

    public static <A> Method[] findMethods(final Class<A> annotationType) {
                final Method[] value = Reflection.INSTANCE.getDeclaredMethods(annotationType);
            return mtd;
        return Reflection.INSTANCE.getDeclaredMethods(annotationType);
    private ConstraintMappingsType parseXmlMappings(final InputStream in) {
            final JAXBContext jc = JAXBContext.newInstance(ConstraintMappingsType.class);
            final Unmarshaller unmarshaller = jc.createUnmarshaller();
            final StreamSource stream = new StreamSource(in);
            final JAXBElement<ConstraintMappingsType> root = unmarshaller.unmarshal(stream, ConstraintMappingsType.class);
        } catch (final JAXBException e) {
import java.lang.reflect.AccessibleObject;
                    processConvertGroup(edesc, field);
                Method m = Reflection.INSTANCE.getDeclaredMethod(current, "get"  name);
                if (m != null) {
                    processConvertGroup(edesc, m);
                    methodFound = true;
                } else {
                    m = Reflection.INSTANCE.getDeclaredMethod(current, "is"  name);
                    if (m != null) {
                        processConvertGroup(edesc, m);
    private static void processConvertGroup(final ElementDescriptorImpl edesc, final AccessibleObject accessible) {
        final ConvertGroup.List convertGroupList = accessible.getAnnotation(ConvertGroup.List.class);
        if (convertGroupList != null) {
            for (final ConvertGroup convertGroup : convertGroupList.value()) {
                edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
            }
        }

        final ConvertGroup convertGroup = accessible.getAnnotation(ConvertGroup.class);
        if (convertGroup != null) {
            edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
        }
    }

    private PropertyDescriptor getPropertyDescriptor(final MetaProperty prop) {
                final ConstructorDescriptorImpl consDesc = new ConstructorDescriptorImpl(metaBean, EMPTY_VALIDATION);

                    for (final Annotation anno : method.getAnnotations()) {
                        final ParameterDescriptorImpl parameterDescriptor = new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx));
                    processConstraint(anno, methodDesc, access, validations);
                processConstraint(annotation, desc, access, validations);
            }
        }

        private <A extends Annotation> void processConstraint(final A annotation, final InvocableElementDescriptor desc,
                                                              final AccessStrategy access, final AppendValidation validations) throws IllegalAccessException, InvocationTargetException {
            Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
            if (vcAnno != null) {
                annotationProcessor.processAnnotation(annotation, null, ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations, true);
            } else {
                /**
                 * Multi-valued constraints
                 */
                final ConstraintAnnotationAttributes.Worker<? extends Annotation> worker = ConstraintAnnotationAttributes.VALUE.analyze(annotation.annotationType());
                if (worker.isValid()) {
                    Annotation[] children = Annotation[].class.cast(worker.read(annotation));
                    if (children != null) {
                        for (Annotation child : children) {
                            processAnnotation(child, desc, access, validations); // recursion
    public BeanDescriptor getConstraintsForClass(final Class<?> clazz) {
            final MetaBean metaBean = metaBeanFinder.findForClass(clazz); // don't throw an exception because of a missing validator here
                edesc = metaBean.initFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR, createBeanDescriptor(metaBean));
    private final Map<Class<?>, Boolean> ignoreAnnotationDefaults = new HashMap<Class<?>, Boolean>();
import javax.validation.ConstraintValidatorFactory;
    public AnnotationConstraintBuilder(ConstraintValidatorFactory factory, Class<? extends ConstraintValidator<A, ?>>[] validatorClasses,
                                        A annotation, Class<?> owner, AccessStrategy access, ConstraintTarget target) {
        constraintValidation = new ConstraintValidation<A>(factory, validatorClasses, annotation, owner, access, reportFromComposite, target);
            new AnnotationConstraintBuilder<A>(factoryContext.getConstraintValidatorFactory(), constraintClasses, annotation, owner, access, null);
    public final <T extends Annotation> void append(final ConstraintValidation<T> validation) {
    public abstract <T extends Annotation> void performAppend(final ConstraintValidation<T> validation);
    public <T extends Annotation> void preProcessValidation(final ConstraintValidation<T> validation) {
     * Post-process the validation once it postProcessValidationhas been appended.
    public <T extends Annotation> void postProcessValidation(final ConstraintValidation<T> validation) {
        // done lazily to ensure CDI is available
        // validation.initialize();
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.reflect.TypeUtils;
import javax.validation.ConstraintValidatorFactory;
import javax.validation.UnexpectedTypeException;
import javax.validation.constraintvalidation.SupportedValidationTarget;
import javax.validation.constraintvalidation.ValidationTarget;
import java.lang.reflect.Array;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collection;
    private final ConstraintValidatorFactory factory;
    private T annotation; // for metadata request API
    private ConstraintValidator<T, ?> validator;
    public ConstraintValidation(ConstraintValidatorFactory factory,
                                Class<? extends ConstraintValidator<T, ?>>[] validatorClasses,
                                T annotation, Class<?> owner, AccessStrategy access,
                                boolean reportFromComposite, ConstraintTarget target) {
        this.factory = factory;
     *
     *
     * @param aConstraintValidation to add
     *
     * @param context root
    public void validate(final GroupValidationContext<?> context) {
        if (validator == null) {
            synchronized (this) {
                if (validator == null) {
                    try {
                        validator = getConstraintValidator(annotation, validatorClasses, owner, access);
                        if (validator != null) {
                            validator.initialize(annotation);
                        }
                    } catch (final RuntimeException re) {
                        if (ValidationException.class.isInstance(re)) {
                            throw re;
                        }
                        throw new ConstraintDefinitionException(re);
                    }
                }
            }
                for (Iterator<ConstraintValidation<?>> composed = getComposingValidations().iterator(); !failed && composed.hasNext(); ) {
    private <A extends Annotation, T> ConstraintValidator<A, ? super T> getConstraintValidator(A annotation,
                                                                                               Class<? extends ConstraintValidator<A, ?>>[] constraintClasses, Class<?> owner, AccessStrategy access) {
        if (constraintClasses != null && constraintClasses.length > 0) {
            Type type = determineTargetedType(owner, access);

            /**
             * spec says in chapter 3.5.3.: The ConstraintValidator chosen to
             * validate a declared type T is the one where the type supported by
             * the ConstraintValidator is a supertype of T and where there is no
             * other ConstraintValidator whose supported type is a supertype of
             * T and not a supertype of the chosen ConstraintValidator supported
             * type.
             */
            final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validatorTypes = getValidatorsTypes(constraintClasses);
            reduceTarget(validatorTypes, access);

            final List<Type> assignableTypes = new ArrayList<Type>(constraintClasses.length);
            fillAssignableTypes(type, validatorTypes.keySet(), assignableTypes);
            reduceAssignableTypes(assignableTypes);
            checkOneType(assignableTypes, type, owner, annotation, access);

            if ((type == Object.class || type == Object[].class) && validatorTypes.containsKey(Object.class) && validatorTypes.containsKey(Object[].class)) {
                throw new ConstraintDefinitionException("Only a validator for Object or Object[] should be provided for cross parameter validators");
            }

            final Collection<Class<? extends ConstraintValidator<A, ?>>> key = validatorTypes.get(assignableTypes.get(0));
            if (key.size() > 1) {
                final String message = "Factory returned "  key.size()  " validators";
                if (ParametersAccess.class.isInstance(access)) { // cross parameter
                    throw new ConstraintDefinitionException(message);
                }
                throw new UnexpectedTypeException(message);
            }

            @SuppressWarnings("unchecked")
            final ConstraintValidator<A, ? super T> validator = (ConstraintValidator<A, ? super T>) factory.getInstance(key.iterator().next());
            if (validator == null) {
                throw new ValidationException("Factory returned null validator for: "  key);

            }
            return validator;
            // NOTE: validator initialization deferred until append phase
        }
        return null;
    }

    private <A extends Annotation> void reduceTarget(final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validator, final AccessStrategy access) {
        for (final Map.Entry<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> entry : validator.entrySet()) {
            final Collection<Class<? extends ConstraintValidator<A, ?>>> validators = entry.getValue();
            final Iterator<Class<? extends ConstraintValidator<A, ?>>> it = validators.iterator();
            while (it.hasNext()) {
                final Type v = it.next();
                if (!Class.class.isInstance(v)) {
                    continue; // TODO: handle this case
                }

                final Class<?> clazz = Class.class.cast(v);
                final SupportedValidationTarget target = clazz.getAnnotation(SupportedValidationTarget.class);
                if (target != null) {
                    final Collection<ValidationTarget> targets = Arrays.asList(target.value());
                    final boolean isParameter = ParameterAccess.class.isInstance(access) || ParametersAccess.class.isInstance(access);
                    if ((isParameter && !targets.contains(ValidationTarget.PARAMETERS))
                        || (!isParameter && !targets.contains(ValidationTarget.ANNOTATED_ELEMENT))) {
                        it.remove();
                    }
                }
            }
            if (validators.isEmpty()) {
                validator.remove(entry.getKey());
            }
        }
    }

    private static void checkOneType(List<Type> types, Type targetType, Class<?> owner, Annotation anno,
                                     AccessStrategy access) {

        if (types.isEmpty()) {
            final String message = "No validator could be found for type "  stringForType(targetType)
                 ". See: @"  anno.annotationType().getSimpleName()  " at "  stringForLocation(owner, access);
            if (Object[].class.equals(targetType)) { // cross parameter
                throw new ConstraintDefinitionException(message);
            }
            throw new UnexpectedTypeException(message);
        } else if (types.size() > 1) {
            StringBuilder buf = new StringBuilder();
            buf.append("Ambiguous validators for type ");
            buf.append(stringForType(targetType));
            buf.append(". See: @").append(anno.annotationType().getSimpleName()).append(" at ").append(
                stringForLocation(owner, access));
            buf.append(". Validators are: ");
            boolean comma = false;
            for (Type each : types) {
                if (comma)
                    buf.append(", ");
                comma = true;
                buf.append(each);
            }
            throw new UnexpectedTypeException(buf.toString());
        }
    }

    private static String stringForType(Type clazz) {
        if (clazz instanceof Class<?>) {
            if (((Class<?>) clazz).isArray()) {
                return ((Class<?>) clazz).getComponentType().getName()  "[]";
            } else {
                return ((Class<?>) clazz).getName();
            }
        } else {
            return clazz.toString();
        }
    }

    private static String stringForLocation(Class<?> owner, AccessStrategy access) {
        if (access != null) {
            return access.toString();
        } else {
            return owner.getName();
        }
    }

    private static void fillAssignableTypes(Type type, Set<Type> validatorsTypes, List<Type> suitableTypes) {
        for (final Type validatorType : validatorsTypes) {
            if (org.apache.commons.lang3.reflect.TypeUtils.isAssignable(type, validatorType)
                && !suitableTypes.contains(validatorType)) {
                suitableTypes.add(validatorType);
            }
        }
    }

    /**
     * Tries to reduce all assignable classes down to a single class.
     *
     * @param assignableTypes The set of all classes which are assignable to the class of
     *                        the value to be validated and which are handled by at least
     *                        one of the validators for the specified constraint.
     */
    private static void reduceAssignableTypes(List<Type> assignableTypes) {
        if (assignableTypes.size() <= 1) {
            return; // no need to reduce
        }
        boolean removed;
        do {
            removed = false;
            final Type type = assignableTypes.get(0);
            for (int i = 1; i < assignableTypes.size(); i) {
                Type nextType = assignableTypes.get(i);
                if (TypeUtils.isAssignable(nextType, type)) {
                    assignableTypes.remove(0);
                    i--;
                    removed = true;
                } else if (TypeUtils.isAssignable(type, nextType)) {
                    assignableTypes.remove(i--);
                    removed = true;
                }
            }
        } while (removed && assignableTypes.size() > 1);

    }

    private static <A extends Annotation> Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> getValidatorsTypes(
        Class<? extends ConstraintValidator<A, ?>>[] constraintValidatorClasses) {
        final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validatorsTypes = new HashMap<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>>();
        for (Class<? extends ConstraintValidator<A, ?>> validatorType : constraintValidatorClasses) {
            Type validatedType = TypeUtils.getTypeArguments(validatorType, ConstraintValidator.class).get(ConstraintValidator.class.getTypeParameters()[1]);
            if (validatedType == null) {
                throw new ValidationException(String.format("Could not detect validated type for %s", validatorType));
            }
            if (validatedType instanceof GenericArrayType) {
                Type componentType = TypeUtils.getArrayComponentType(validatedType);
                if (componentType instanceof Class<?>) {
                    validatedType = Array.newInstance((Class<?>) componentType, 0).getClass();
                }
            }
            if (!validatorsTypes.containsKey(validatedType)) {
                validatorsTypes.put(validatedType, new ArrayList<Class<? extends ConstraintValidator<A, ?>>>());
            }
            validatorsTypes.get(validatedType).add(validatorType);
        }
        return validatorsTypes;
    }

    /**
     * implements spec chapter 3.5.3. ConstraintValidator resolution algorithm.
     */
    private static Type determineTargetedType(Class<?> owner, AccessStrategy access) {
        // if the constraint declaration is hosted on a class or an interface,
        // the targeted type is the class or the interface.
        if (access == null)
            return owner;
        Type type = access.getJavaType();
        if (type == null)
            return Object.class;
        if (type instanceof Class<?>)
            type = ClassUtils.primitiveToWrapper((Class<?>) type);
        return type;
    }

     *
     *
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Collection;

import static org.apache.bval.model.Features.Property.HIDDEN;
import static org.apache.bval.model.Features.Property.PREFERRED;
import static org.apache.bval.model.Features.Property.READONLY;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.bval.model.MetaBean;

import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import org.apache.commons.lang3.reflect.TypeUtils;

import org.apache.commons.lang3.reflect.TypeUtils;

import java.util.List;
import java.util.Map;

import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.Character.getNumericValue;

import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Annotation;

import static java.lang.Character.getNumericValue;
import static java.lang.Character.isDigit;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.Character.getNumericValue;

import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.io.File;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.io.File;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.io.File;
import java.io.IOException;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import static java.util.Arrays.asList;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.util.regex.Pattern;
import org.apache.bval.jsr303.ConfigurationImpl;

import com.google.inject.Injector;

import com.google.inject.BindingAnnotation;

import javax.validation.ConstraintViolationException;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import com.google.inject.AbstractModule;
import com.google.inject.Scopes;
import com.google.inject.TypeLiteral;
import com.google.inject.matcher.Matchers;
import org.aopalliance.intercept.MethodInterceptor;
import org.apache.bval.jsr303.ApacheValidationProvider;
import org.apache.bval.jsr303.DefaultMessageInterpolator;
import org.apache.bval.jsr303.resolver.DefaultTraversableResolver;

import org.apache.bval.jsr303.ApacheValidationProvider;

import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import org.apache.bval.model.MetaBean;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import org.apache.commons.lang3.reflect.TypeUtils;
        boolean foundPayload = false;
        boolean foundGroups = false;
        Method validationAppliesTo = null;
        boolean foundMessage = false;

                        foundPayload = true;
                        foundGroups = true;
                        validationAppliesTo = method;
                        if (ConstraintAnnotationAttributes.MESSAGE.getAttributeName().equals(name)) {
                            foundMessage = true;
                            if (!TypeUtils.isAssignable(method.getReturnType(), ConstraintAnnotationAttributes.MESSAGE.getType())) {
                                throw new ConstraintDefinitionException("Return type for message() must be of type "  ConstraintAnnotationAttributes.MESSAGE.getType());
                            }
                        }
        if (!foundMessage) {
            throw new ConstraintDefinitionException("Annotation "  annotationType.getName()  " has no message method");
        }
        if (!foundPayload) {
            throw new ConstraintDefinitionException("Annotation "  annotationType.getName()  " has no payload method");
        }
        if (!foundGroups) {
            throw new ConstraintDefinitionException("Annotation "  annotationType.getName()  " has no groups method");
        }
        if (validationAppliesTo != null && !ConstraintTarget.IMPLICIT.equals(validationAppliesTo.getDefaultValue())) {
            throw new ConstraintDefinitionException("validationAppliesTo default value should be IMPLICIT");
        }

        if (!TypeUtils.isAssignable(method.getReturnType(), ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getType())) {
            throw new ConstraintDefinitionException("Return type for validationAppliesTo() must be of type "  ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getType());
        }
        if (!TypeUtils.isAssignable(method.getReturnType(), ConstraintAnnotationAttributes.GROUPS.getType())) {
            throw new ConstraintDefinitionException("Return type for groups() must be of type "  ConstraintAnnotationAttributes.GROUPS.getType());
        }

            if (Object[].class.cast(method.getDefaultValue()).length > 0) {
                throw new ConstraintDefinitionException("Default value for groups() must be an empty array");
            }
    private void buildPayload(final Method method) throws IllegalAccessException, InvocationTargetException {
        if (!TypeUtils.isAssignable(method.getReturnType(), ConstraintAnnotationAttributes.PAYLOAD.getType())) {
            throw new ConstraintDefinitionException("Return type for payload() must be of type "  ConstraintAnnotationAttributes.PAYLOAD.getType());
        }
        if (Object[].class.cast(method.getDefaultValue()).length > 0) {
            throw new ConstraintDefinitionException("Default value for payload() must be an empty array");
        }

import org.apache.commons.lang3.ClassUtils;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Set;
        if (clazz.getName().startsWith("javax.validation.constraint.")) { // cache only APIs classes to avoid memory leaks
            Worker<C> w = Worker.class.cast(WORKER_CACHE.get(clazz));
            if (w == null) {
                w = new Worker<C>(clazz);
                WORKER_CACHE.putIfAbsent(clazz, w);
                return w;
            }
        }
    private static final ConcurrentMap<Class<?>, Worker<?>> WORKER_CACHE = new ConcurrentHashMap<Class<?>, Worker<?>>();
            method = findMethod(constraintType, attributeName);
            if (!m.isAccessible()) {
                m.setAccessible(true);
            }
            return method != null && method != NULL_METHOD;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import javax.validation.groups.Default;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.lang3.StringEscapeUtils;
import java.io.StringWriter;
import java.text.ParsePosition;
import java.lang.reflect.Type;

import org.apache.bval.jsr303.example.Address;
import org.apache.bval.jsr303.example.Author;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.xml.XMLMetaValue;

import java.util.Collection;
import java.util.Date;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import org.apache.bval.MetaBeanFactory;
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.routines.StandardValidation;
import static org.apache.bval.model.Features.Property.JAVASCRIPT_VALIDATION_FUNCTIONS;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import com.thoughtworks.xstream.annotations.XStreamOmitField;
import org.apache.bval.model.Validation;
import org.apache.commons.lang3.ClassUtils;

import static org.apache.bval.model.Features.Property.DENIED;
import static org.apache.bval.model.Features.Property.HIDDEN;
import static org.apache.bval.model.Features.Property.MANDATORY;
import static org.apache.bval.model.Features.Property.MAX_LENGTH;
import static org.apache.bval.model.Features.Property.MIN_LENGTH;
import static org.apache.bval.model.Features.Property.READONLY;
import static org.apache.bval.model.Features.Property.MAX_VALUE;
import static org.apache.bval.model.Features.Property.MIN_VALUE;
import static org.apache.bval.model.Features.Property.REG_EXP;
import static org.apache.bval.model.Features.Property.TIME_LAG;
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
    public MethodDescriptor getInternalConstraintsForMethod(final String methodName, final Class<?>... parameterTypes) {
        if (methodName == null) {
            throw new IllegalArgumentException("Method name can't be null");
        }
        return meta.methodConstraints.get(methodName  Arrays.toString(parameterTypes));
    }

                    final Object value = worker.read(annotation);
                    if (Annotation[].class.isInstance(value)) {
                        final Annotation[] children = Annotation[].class.cast(value);
                        if (children != null) {
                            for (Annotation child : children) {
                                processAnnotation(child, desc, access, validations); // recursion
                            }
        if (methodDescriptor == null || !(methodDescriptor.hasConstrainedParameters() || methodDescriptor.hasConstrainedReturnValue())) { // no constraint
        return MethodDescriptorImpl.class.cast(
            BeanDescriptorImpl.class.cast(getConstraintsForClass(Proxies.classFor(method.getDeclaringClass())))
                .getInternalConstraintsForMethod(method.getName(), method.getParameterTypes()));
        if (resolver == null) {
            return this;
        }
        if (resolver == null) {
            return this;
        }
        if (constraintFactory == null) {
            return this;
        }

        if (parameterNameProvider == null) {
            return this;
        }
        if (stream == null) {
            return this;
        }
                    validation.validateGroupContext(parametersContext);
                validation.validateGroupContext(crossParameterContext);
                        validation.validateGroupContext(parametersContext);
                    validation.validateGroupContext(crossParameterContext);
                validation.validateGroupContext(context);
                    validation.validateGroupContext(context);
                validation.validateGroupContext(context);
                    validation.validateGroupContext(context);
        validateGroupContext((GroupValidationContext<?>) context);
    public void validateGroupContext(final GroupValidationContext<?> context) {
        if (clazz == null || clazz == Object.class || clazz == Serializable.class || clazz == Cloneable.class) {
            if (method.isSynthetic() || method.isBridge()) {
                continue;
            }
            } finally {
                try {
                    stream.close();
                } catch (final IOException e) {
                    // no-op
                }
        if (bmpSingleton.bmInfos != null) {
            bmpSingleton.bmInfos.remove(loader());
        }
    private boolean validatorFound = Boolean.getBoolean("bval.in-container");
    private boolean validatorFactoryFound = Boolean.getBoolean("bval.in-container");
import org.apache.bval.jsr.parameter.DefaultParameterNameProvider;

import javax.enterprise.inject.spi.AnnotatedCallable;
import javax.validation.ValidationException;
import javax.validation.executable.ValidateOnExecution;
import javax.validation.metadata.BeanDescriptor;
import javax.validation.metadata.MethodType;
import java.util.Collection;
    private boolean validBean;
    private boolean validConstructors;
    private boolean validBusinessMethods;
    private boolean validGetterMethods;

    private ValidatorFactory factory;
    private Validator validator;

            validBean = globalExecutableTypes.contains(ExecutableType.IMPLICIT) || globalExecutableTypes.contains(ExecutableType.ALL);
            validConstructors =validBean || globalExecutableTypes.contains(ExecutableType.CONSTRUCTORS);
            validBusinessMethods = validBean || globalExecutableTypes.contains(ExecutableType.NON_GETTER_METHODS);
            validGetterMethods = globalExecutableTypes.contains(ExecutableType.ALL) || globalExecutableTypes.contains(ExecutableType.GETTER_METHODS);
    // lazily to get a small luck to have CDI in place
    private void ensureFactoryValidator() {
        if (validator != null) {
            return;
        }
        config.addProperty("bval.before.cdi", "true"); // ignore parts of the config relying on CDI since we didn't start yet
        factory = factory != null ? factory : config.buildValidatorFactory();
        validator = factory.getValidator();
    }

        final AnnotatedType<A> annotatedType = pat.getAnnotatedType();
        final Class<A> javaClass = annotatedType.getJavaClass();
            ensureFactoryValidator();
            try {
                final BeanDescriptor classConstraints = validator.getConstraintsForClass(javaClass);
                if (annotatedType.isAnnotationPresent(ValidateOnExecution.class)
                    || hasValidationAnnotation(annotatedType.getMethods())
                    || hasValidationAnnotation(annotatedType.getConstructors())
                    || (validBean && classConstraints.isBeanConstrained())
                    || (validConstructors && !classConstraints.getConstrainedConstructors().isEmpty())
                    || (validBusinessMethods && !classConstraints.getConstrainedMethods(MethodType.NON_GETTER).isEmpty())
                    || (validGetterMethods && !classConstraints.getConstrainedMethods(MethodType.GETTER).isEmpty())) {
                    // TODO: keep track of bValAnnotatedType and remove @BValBinding in
                    // ProcessBean event if needed cause here we can't really add @ValidateOnExecution
                    // through an extension
                    final BValAnnotatedType<A> bValAnnotatedType = new BValAnnotatedType<A>(annotatedType);
                    pat.setAnnotatedType(bValAnnotatedType);
                }
            } catch (final ValidationException ve) {
                LOGGER.log(Level.SEVERE, ve.getMessage(), ve);
            }
    private static <A> boolean hasValidationAnnotation(final Collection<? extends AnnotatedCallable<? super A>> methods) {
        for (final AnnotatedCallable<? super A> m : methods) {
            if (m.isAnnotationPresent(ValidateOnExecution.class)) {
                return true;
            }
        }
        return false;
    }

        if (factory != null) { // cleanup cache used to discover ValidateOnException before factory is recreated
            factory.close();
        }

        captureBeanManager(beanManager); // next method will need it
            synchronized (LOGGER) { // a static instance
                if (bmpSingleton == null) {
                    bmpSingleton = this;
                }
            }

        try {
            config.addProperty("bval.before.cdi", "false"); // now take into account all the config
        } catch (final Exception e) {
            // no-op: sadly tck does it
        }

            try { // recreate the factory
                afterBeanDiscovery.addBean(new ValidatorFactoryBean(factory = config.buildValidatorFactory()));
                if (validatorFactoryFound) {
                } // else fresh factory already created in previous if
    public void cleanupFinalBeanManagers(final @Observes AfterDeploymentValidation ignored) {
    public void cleanupStoredBeanManagerOnShutdown(final @Observes BeforeShutdown ignored) {
        if (bmpSingleton != null && bmpSingleton.bmInfos != null) {
    private static final ConstraintDefaults DEFAULT_CONSTRAINTS = new ConstraintDefaults();
    private volatile boolean init;

        parameterNameProvider = configuration.getParameterNameProvider();
        messageResolver = configuration.getMessageInterpolator();
        traversableResolver = configuration.getTraversableResolver();
        constraintValidatorFactory = configuration.getConstraintValidatorFactory();
        return DEFAULT_CONSTRAINTS;
import org.apache.bval.cdi.BValExtension;
import java.io.IOException;
import java.util.concurrent.CopyOnWriteArrayList;
    protected Class<? extends MessageInterpolator> messageInterpolatorClass = null;
    protected Class<? extends ConstraintValidatorFactory> constraintValidatorFactoryClass = null;
    protected TraversableResolver defaultTraversableResolver = new DefaultTraversableResolver();
    protected TraversableResolver traversableResolver = defaultTraversableResolver;
    protected Class<? extends TraversableResolver> traversableResolverClass = null;
    protected Class<? extends ParameterNameProvider> parameterNameProviderClass = null;
    private Collection<BValExtension.Releasable> releasables = new CopyOnWriteArrayList<BValExtension.Releasable>();

    private boolean beforeCdi = false;

     * @param aState bootstrap state
     * @param aProvider provider

        this.traversableResolverClass = null;
        this.traversableResolver = resolver;

        this.messageInterpolatorClass = null;
        this.constraintValidatorFactoryClass = null;
        this.parameterNameProviderClass = null;
        if ("bval.before.cdi".equals(name)) {
            beforeCdi = Boolean.parseBoolean(value);
        } else {
            properties.put(name, value);
        }
        if (beforeCdi) {
            return defaultMessageInterpolator;
        }

        if (messageInterpolator == defaultMessageInterpolator && messageInterpolatorClass != null) {
            synchronized (this) {
                if (messageInterpolator == defaultMessageInterpolator && messageInterpolatorClass != null) {
                    messageInterpolator = newInstance(messageInterpolatorClass);
                }
            }
        }
        if (beforeCdi) {
            return constraintValidatorFactory;
        }

        if (constraintValidatorFactory == defaultConstraintValidatorFactory && constraintValidatorFactoryClass != null) {
            synchronized (this) {
                if (constraintValidatorFactory == defaultConstraintValidatorFactory && constraintValidatorFactoryClass != null) {
                    constraintValidatorFactory = newInstance(constraintValidatorFactoryClass);
                }
            }
        }
        if (beforeCdi) {
            return defaultTraversableResolver;
        }

        if (traversableResolver == defaultTraversableResolver && traversableResolverClass != null) {
            synchronized (this) {
                if (traversableResolver == defaultTraversableResolver && traversableResolverClass != null) {
                    traversableResolver = newInstance(traversableResolverClass);
                }
            }
        }
        if (beforeCdi) {
            return defaultParameterNameProvider;
        }

        if (parameterNameProvider == defaultParameterNameProvider && parameterNameProviderClass != null) {
            synchronized (this) {
                if (parameterNameProvider == defaultParameterNameProvider && parameterNameProviderClass != null) {
                    parameterNameProvider = newInstance(parameterNameProviderClass);
                }
            }
        }
     * @param providerClass the provider type
        return new Closeable() {
            public void close() throws IOException {
                for (final BValExtension.Releasable<?> releasable : releasables) {
                    releasable.release();
                }
                releasables.clear();
            }
        };
    private <T> T newInstance(final Class<T> cls) {
        if (System.getSecurityManager() == null) {
            return createInstance(cls);
        }
        return AccessController.doPrivileged(new PrivilegedAction<T>() {
            public T run() {
                return createInstance(cls);
            }
        });
    private <T> T createInstance(final Class<T> cls) {
        try {
            final BValExtension.Releasable<T> releasable = BValExtension.inject(cls);
            releasables.add(releasable);
            return releasable.getInstance();
        } catch (final Exception e) {
            try {
                return cls.newInstance();
            } catch (final InstantiationException e1) {
                throw new ValidationException(e1.getMessage(), e1);
            } catch (final IllegalAccessException e1) {
                throw new ValidationException(e1.getMessage(), e1);
            }
        } catch (final NoClassDefFoundError error) {
            try {
                return cls.newInstance();
            } catch (final InstantiationException e1) {
                throw new ValidationException(e1.getMessage(), e1);
            } catch (final IllegalAccessException e1) {
                throw new ValidationException(e1.getMessage(), e1);
            }
        }
    }

    public void traversableResolverClass(final Class<TraversableResolver> clazz) {
        traversableResolverClass = clazz;
    }

    public void constraintValidatorFactoryClass(final Class<ConstraintValidatorFactory> clazz) {
        constraintValidatorFactoryClass = clazz;
    }

    public void messageInterpolatorClass(final Class<MessageInterpolator> clazz) {
        messageInterpolatorClass = clazz;
    }

    public void parameterNameProviderClass(final Class<? extends ParameterNameProvider> clazz) {
        parameterNameProviderClass = clazz;
public class ValidationParser {
                targetConfig.parameterNameProviderClass(clazz);
                target.messageInterpolatorClass(clazz);
                target.traversableResolverClass(clazz);
                target.constraintValidatorFactoryClass(clazz);
                ensureFactoryValidator();
                LOGGER.log(Level.FINEST, ve.getMessage(), ve);
                    || (validBean && classConstraints != null && classConstraints.isBeanConstrained())
                    || (validConstructors && classConstraints != null && !classConstraints.getConstrainedConstructors().isEmpty())
                    || (validBusinessMethods && classConstraints != null && !classConstraints.getConstrainedMethods(MethodType.NON_GETTER).isEmpty())
                    || (validGetterMethods && classConstraints != null && !classConstraints.getConstrainedMethods(MethodType.GETTER).isEmpty())) {
                    if (instance != null) {
                        releasables.add(instance);
                    }
            final Set<ConstraintViolation<?>> violations = executableValidator.validateConstructorReturnValue(constructor, context.getTarget());
        // force ByteArrayOutputStream since we close the stream ATM
        /*if (stream.markSupported()) {
        } else {*/
        /*}*/
                afterBeanDiscovery.addBean(new ValidatorBean(factory, factory.getValidator()));
                afterBeanDiscovery.addBean(new ValidatorBean(factory, null));
                validatorFound = true;
import javax.validation.ValidatorFactory;
    private final ValidatorFactory factory;
    private volatile Validator instance;
    public ValidatorBean(final ValidatorFactory factory, final Validator validator) {
        this.factory = factory;
        if (instance == null) {
            synchronized (this) {
                if (instance == null) {
                    instance = factory.getValidator();
                }
            }
        }
        builder.service(TestEnricher.class, EJBEnricher.class);
import java.util.HashSet;
    // extension point, we can add a SPI if needed, today mainly a fallback "API" for TomEE if we encounter an issue
    public static Collection<String> SKIPPED_PREFIXES = new HashSet<String>();
    static {
        SKIPPED_PREFIXES.add("java.");
        SKIPPED_PREFIXES.add("javax.");
        SKIPPED_PREFIXES.add("org.apache.bval.");
        SKIPPED_PREFIXES.add("org.apache.openejb.");
        SKIPPED_PREFIXES.add("org.apache.deltaspike."); // should be checked when upgrading
        SKIPPED_PREFIXES.add("org.apache.myfaces."); // should be checked when upgrading
    }

    protected boolean skip(final String name) {
        for (final String p : SKIPPED_PREFIXES) {
            if (name.startsWith(p)) {
                return true;
            }
        }
        return false;
    }

        final String name = javaClass.getName();
        if (skip(name)) {
            return;
        }

        if (!javaClass.isInterface() && !Modifier.isFinal(modifiers) && !Modifier.isAbstract(modifiers)) {

import org.apache.bval.util.AccessStrategy;
        setAccessible(constructor);
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
                for (final Field f : Reflection.getDeclaredFields(clazz)) {
                for (final Method m : Reflection.getDeclaredMethods(clazz)) {
            for (final Constructor<?> c : Reflection.getDeclaredConstructors(beanClass)) {
import java.lang.reflect.AccessibleObject;
import org.apache.commons.weaver.privilizer.Privileged;


    /**
     * Set {@code accessibleObject} as being accessible
     * @param accessibleObject
     */
    protected boolean setAccessible(AccessibleObject accessibleObject) {
        if (accessibleObject.isAccessible()) {
            return false;
        }
        doSetAccessible(accessibleObject);
        return true;
    }

    @Privileged
    private void doSetAccessible(AccessibleObject accessibleObject) {
        accessibleObject.setAccessible(true);
    }
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
        final StringBuilder buf = new StringBuilder(80 * 40);
        final StringTokenizer tok = new StringTokenizer(Reflection.getProperty("java.class.path"));
        return buf.append(prop).append(": ").append(Reflection.getProperty(prop));
        setAccessible(field);
import org.apache.commons.lang3.ObjectUtils;
 */ 
            return ObjectUtils.defaultIfNull(TypeUtils.unrollVariables(typeArguments, ITERABLE_TYPE), Object.class);
    private final Type containerType;
    private final Integer index;
import org.apache.commons.lang3.ObjectUtils;
            return ObjectUtils.defaultIfNull(TypeUtils.unrollVariables(typeArguments, MAP_TYPEVARS[1]), Object.class);
    private final Type containerType;
    private final Object key;
            Type keyType = TypeUtils.unrollVariables(typeArguments, MAP_TYPEVARS[0]);
        final Type result = getJavaElementType(containerType);
        setAccessible(method);
        final String methodName = member.getName();
            return Introspector.decapitalize(methodName.substring(2));
        if (methodName.startsWith("get")) {
            return Introspector.decapitalize(methodName.substring(3));
        }
        return null;
import java.lang.reflect.Modifier;
import org.apache.commons.lang3.ClassUtils;
/**
 * Security-agnostic "blueprint" class for reflection-related operations.
 * 
 * @version $Rev$ $Date$
 */
public class Reflection {
    private static void setAccessibility(final Field field) {
        // FIXME 2011-03-27 jw:
        // - Why not simply call field.setAccessible(true)?
        // - Fields can not be abstract.
        if (!Modifier.isPublic(field.getModifiers())
            || (Modifier.isPublic(field.getModifiers()) && Modifier.isAbstract(field.getModifiers()))) {
            field.setAccessible(true);

    public static Class<?> getClass(final ClassLoader classLoader, final String className) throws Exception {
        return ClassUtils.getClass(classLoader, className, true);
    }

    public static Object getAnnotationValue(final Annotation annotation, final String name)
        throws IllegalAccessException, InvocationTargetException {
        Method valueMethod;
        try {
            valueMethod = annotation.annotationType().getDeclaredMethod(name);
        } catch (final NoSuchMethodException ex) {
            // do nothing
            valueMethod = null;
        }
        if (null != valueMethod) {
            if (!valueMethod.isAccessible()) {
                valueMethod.setAccessible(true);
            }
            return valueMethod.invoke(annotation);
        }
        return null;
    }

    public static ClassLoader getClassLoader(final Class<?> clazz) {
        final ClassLoader cl = Thread.currentThread().getContextClassLoader();
        if (cl != null) {
            return cl;
        }
        return clazz.getClassLoader();
    }

    public static String getProperty(final String name) {
        return System.getProperty(name);
    }

    public static Field getDeclaredField(final Class<?> clazz, final String fieldName) {
        final Field f;
        try {
            f = clazz.getDeclaredField(fieldName);
        } catch (final NoSuchFieldException e) {
            return null;
        }
        setAccessibility(f);
        return f;
    }

    public static Field[] getDeclaredFields(final Class<?> clazz) {
        final Field[] fields = clazz.getDeclaredFields();
        if (fields.length > 0) {
            for (final Field f : fields) {
                if (!f.isAccessible()) {
                    f.setAccessible(true);
                }
            }
        }
        return fields;
    }

    public static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>... parameters) {
        try {
            return clazz.getDeclaredConstructor(parameters);
        } catch (final NoSuchMethodException e) {
            return null;
        }
    }

    public static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>... parameters) {
        try {
            return clazz.getDeclaredMethod(name, parameters);
        } catch (final NoSuchMethodException e) {
            return null;
        }
    }

    public static Method[] getDeclaredMethods(final Class<?> clazz) {
        return clazz.getDeclaredMethods();
    }

    public static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz) {
        return clazz.getDeclaredConstructors();
    }

    public static Method getPublicMethod(final Class<?> clazz, final String methodName) {
        try {
            return clazz.getMethod(methodName);
        } catch (final NoSuchMethodException e) {
            return null;
        }
    }

    public static <T> T newInstance(final Class<T> cls) {
        try {
            return cls.newInstance();
        } catch (final Exception ex) {
            throw new RuntimeException("Cannot instantiate : "  cls, ex);
        }
    }

import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.bval.jsr.groups.GroupsComputer;
import org.apache.bval.jsr.xml.AnnotationProxyBuilder;
import org.apache.bval.util.AccessStrategy;
import org.apache.commons.lang3.reflect.TypeUtils;
import org.apache.commons.weaver.privilizer.Privileged;
    @Privileged
        if (constraintValidation.getAnnotation() == null) {
            return;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
        final Object result =
            Reflection.getAnnotationValue(annotation, ConstraintAnnotationAttributes.VALUE.getAttributeName());
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;

import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.ParameterNameProvider;
import javax.validation.TraversableResolver;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.ValidatorContext;

import org.apache.commons.weaver.privilizer.Privileged;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
    @Privileged
            return Class.forName(className, true, Reflection.getClassLoader(ApacheFactoryContext.class));

import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.weaver.privilizer.Privileged;
        return instantiateValidatorFactory(validatorFactoryClass, configuration);
    @Privileged
        String VALIDATOR_FACTORY_CLASSNAME = "apache.bval.validator-factory-classname";
        String METABEAN_FACTORY_CLASSNAMES = "apache.bval.metabean-factory-classnames";
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
            return Reflection.newInstance(cls);
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
                final Field field = Reflection.getDeclaredField(current, prop.getName());
                Method m = Reflection.getDeclaredMethod(current, "get"  name);
                    m = Reflection.getDeclaredMethod(current, "is"  name);
            for (final Constructor<?> cons : Reflection.getDeclaredConstructors(metaBean.getBeanClass())) {
            for (final Method method : Reflection.getDeclaredMethods(current)) {
                    final Method overridden = Reflection.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
                    if (overridden != null) {
                        parents.add(overridden);
                        processMethod(overridden, methodDesc);
                        final Method m = Reflection.getDeclaredMethod(i, method.getName(), method.getParameterTypes());
                        final Method overridden = Reflection.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
                        if (overridden != null) {
                            if (overridden.getAnnotation(Valid.class) != null) {
import java.lang.reflect.Constructor;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintDefinitionException;
import javax.validation.ConstraintTarget;
import javax.validation.ConstraintViolation;
import javax.validation.ElementKind;
import javax.validation.ValidationException;
import javax.validation.executable.ExecutableValidator;
import javax.validation.groups.Default;
import javax.validation.metadata.BeanDescriptor;
import javax.validation.metadata.ConstraintDescriptor;
import javax.validation.metadata.ElementDescriptor;
import javax.validation.metadata.ParameterDescriptor;
import javax.validation.metadata.PropertyDescriptor;

import org.apache.commons.weaver.privilizer.Privileged;
    @Privileged
                    
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;

import org.apache.bval.cdi.BValExtension;
import org.apache.bval.jsr.parameter.DefaultParameterNameProvider;
import org.apache.bval.jsr.resolver.DefaultTraversableResolver;
import org.apache.bval.jsr.util.IOs;
import org.apache.bval.jsr.xml.ValidationParser;
import org.apache.commons.weaver.privilizer.Privileged;
    private Collection<BValExtension.Releasable<?>> releasables = new CopyOnWriteArrayList<BValExtension.Releasable<?>>();
            return doBuildValidatorFactory();
    @Privileged
    private ValidatorFactory doBuildValidatorFactory() {
        final ValidationProvider<?> useProvider = provider == null ? findProvider() : provider;
        return useProvider.buildValidatorFactory(this);
    private ConfigurationImpl prepare() {
    @Privileged
        }
        try {
            return cls.newInstance();
        } catch (final Exception e) {
            throw new ValidationException(e.getMessage(), e);
import org.apache.commons.weaver.privilizer.Privileged;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

    MESSAGE("message"),
    GROUPS("groups"),
    PAYLOAD("payload"),
    VALIDATION_APPLIES_TO("validationAppliesTo"),
    VALUE("value");
    private ConstraintAnnotationAttributes(final String name) {
            @SuppressWarnings("unchecked")

    @Privilizing(@CallTo(Reflection.class))
            final Method m = Reflection.getPublicMethod(constraintType, attributeName);
        public <T> T read(final Annotation constraint) {
            @SuppressWarnings("unchecked")
            final T result = (T) doInvoke(constraint);
            return result;
        @Privileged
import javax.validation.ConstraintValidator;

import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
                try {
                    classes.add(Reflection.getClass(classloader, eachClassName));
                } catch (Exception e) {
                    log.log(Level.SEVERE, String.format("Cannot find class %s", eachClassName), e);
        Class<? extends ConstraintValidator<A, ?>>[] constraintClasses, Class<?> owner, AccessStrategy access) {
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
        final ClassLoader classLoader = Reflection.getClassLoader(DefaultMessageInterpolator.class);
import javax.validation.ValidationException;
import javax.validation.ValidationProviderResolver;
import javax.validation.spi.ValidationProvider;

import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
                final URL url = cfgs.nextElement();
                                @SuppressWarnings("rawtypes")
                                final Class<? extends ValidationProvider> providerType =
                                    cl.loadClass(line).asSubclass(ValidationProvider.class);
                                providers.add(Reflection.newInstance(providerType.asSubclass(ValidationProvider.class)));
                    if (br != null) {
                    }
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
            final List<Class<?>> classSequence =
                ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), beanClass);
        final Field[] fields = Reflection.getDeclaredFields(beanClass);
        final Method[] methods = Reflection.getDeclaredMethods(beanClass);
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
        final ClassLoader classLoader = Reflection.getClassLoader(DefaultTraversableResolver.class);
            Reflection.getClass(classLoader, PERSISTENCE_UTIL_CLASSNAME);
    @Deprecated
import org.apache.commons.weaver.privilizer.Privileged;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
                final Method[] value = Reflection.getDeclaredMethods(annotationType);
        return Reflection.getDeclaredMethods(annotationType);
        final ClassLoader classLoader = Reflection.getClassLoader(getType());
        return doCreateAnnotation(proxyClass, handler);
    @Privileged
    public static final class ConvertGroupAnnotation implements ConvertGroup {
        public ConvertGroupAnnotation(final Class<?> from, final Class<?> to) {
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.bval.jsr.ApacheValidatorFactory;
import org.apache.bval.jsr.ConstraintAnnotationAttributes;
import org.apache.bval.jsr.util.EnumerationConverter;
import org.apache.bval.jsr.util.IOs;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.beanutils.ConvertUtils;
import org.apache.commons.beanutils.Converter;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.weaver.privilizer.Privileged;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
        final Method m = Reflection.getPublicMethod(annotationClass, name);
            final Method method = Reflection.getDeclaredMethod(beanClass, methodName, toTypes(methodType.getParameter(), defaultPackage));
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
            final Constructor<?> constructor = Reflection.getDeclaredConstructor(beanClass, toTypes(constructorType.getParameter(), defaultPackage));
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
            final Field field = Reflection.getDeclaredField(beanClass, fieldName);
                final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, field, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
    @Privileged
    private static Method getGetter(Class<?> clazz,String propertyName) {
        ClassLoader loader = Reflection.getClassLoader(ValidationMappingParser.class);
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.bval.jsr.BootstrapConfigurationImpl;
import org.apache.bval.jsr.ConfigurationImpl;
import org.apache.bval.jsr.util.IOs;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privileged;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
import org.xml.sax.SAXException;
@Privilizing(@CallTo(Reflection.class))
    @Privileged
        final ClassLoader loader = Reflection.getClassLoader(ValidationParser.class);
        final ClassLoader loader = Reflection.getClassLoader(ValidationParser.class);
                final Class<? extends ParameterNameProvider> clazz =
                    loadClass(parameterNameProvider).asSubclass(ParameterNameProvider.class);
        final ClassLoader loader = Reflection.getClassLoader(ValidationParser.class);
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
        addLoader(new XMLMetaBeanURLLoader(Reflection.getClassLoader(getClass()).getResource(resource)));
    private static final long serialVersionUID = 1L;

    /**
     * Statically available instance.
     */

        annotations.add(BValBindingLiteral.INSTANCE);
                @SuppressWarnings("unchecked")
                final T result = (T) ann;
                return result;
    public static class BValBindingLiteral extends AnnotationLiteral<BValBinding> implements BValBinding {
        private static final long serialVersionUID = 1L;

        public static final Annotation INSTANCE = new BValBindingLiteral();
//TODO javadoc

    private Collection<ExecutableType> classConfiguration;
    private Boolean constructorValidated;
    private ExecutableValidator executableValidator;
        @SuppressWarnings("rawtypes")
        final ConstructorDescriptor constraints =
            validator.getConstraintsForClass(targetClass).getConstraintsForConstructor(constructor.getParameterTypes());
            @SuppressWarnings("unchecked")
            @SuppressWarnings("unchecked")
        final MethodDescriptor constraintsForMethod =
            validator.getConstraintsForClass(targetClass).getConstraintsForMethod(method.getName(),
                method.getParameterTypes());
            final Set<ConstraintViolation<Object>> violations =
                executableValidator.validateParameters(context.getTarget(), method, context.getParameters());
            final Set<ConstraintViolation<Object>> violations =
                executableValidator.validateReturnValue(context.getTarget(), method, result);
                    final ValidateOnExecution annotation =
                        targetClass.getConstructor(constructor.getParameterTypes()).getAnnotation(
                            ValidateOnExecution.class);
                        constructorValidated =
                            types.contains(ExecutableType.CONSTRUCTORS) || types.contains(ExecutableType.IMPLICIT)
                                || types.contains(ExecutableType.ALL);
        return constructorValidated.booleanValue();
                    final List<Class<?>> classHierarchy =
                        ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), targetClass);
                            validateOnExecution =
                                c.getDeclaredMethod(method.getName(), method.getParameterTypes()).getAnnotation(
                                    ValidateOnExecution.class);
                            if (ExecutableType.IMPLICIT == type) { // on method it just means validate, even on getters
                            } else if (ExecutableType.ALL == type) {
                            } else if (ExecutableType.NONE != type) {
                            if (ExecutableType.IMPLICIT ==type) {
                            } else if (ExecutableType.ALL == type) {
                            } else if (ExecutableType.NONE != type) {
        return (!getter && config.contains(ExecutableType.NON_GETTER_METHODS))
            || (getter && config.contains(ExecutableType.GETTER_METHODS));
        return (name.startsWith("get") || name.startsWith("is")) && Void.TYPE.equals(method.getReturnType())
            && method.getParameterTypes().length == 0;
        injectionPoints =
            Collections.singleton(InjectionPoint.class.cast(new BValInterceptorInjectionPoint(this, injectionTarget
                .getInjectionPoints().iterator().next())));
    private static final long serialVersionUID = 1L;

import org.apache.commons.lang3.ArrayUtils;
    public AnnotationConstraintBuilder(ConstraintValidatorFactory factory,
        Class<? extends ConstraintValidator<A, ?>>[] validatorClasses, A annotation, Class<?> owner,
        AccessStrategy access, ConstraintTarget target) {
        final boolean reportFromComposite =
        constraintValidation =
            new ConstraintValidation<A>(factory, validatorClasses, annotation, owner, access, reportFromComposite,
                target);
        }
        if (param >= 1 && annotatedElt >= 1 && constraintValidation.getValidationAppliesTo() == null) { // generic and cross param
            throw new ConstraintDefinitionException("cross parameter AND generic constraints should get validationAppliesTo attribute");
        }
        if (param == 0 && constraintValidation.getValidationAppliesTo() != null) { // pure generic
            throw new ConstraintDefinitionException("pure generic constraints shouldn't get validationAppliesTo attribute");
            throw new ConstraintDefinitionException("Return type for validationAppliesTo() must be of type "
                 ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getType());
        if (!ConstraintTarget.class.isInstance(validationAppliesTo)) {
        constraintValidation.setValidationAppliesTo(ConstraintTarget.class.cast(validationAppliesTo));
            throw new ConstraintDefinitionException("Return type for groups() must be of type "
                 ConstraintAnnotationAttributes.GROUPS.getType());
        if (ArrayUtils.isEmpty(garr)) {
            throw new ConstraintDefinitionException("Return type for payload() must be of type "
                 ConstraintAnnotationAttributes.PAYLOAD.getType());
        final Class<? extends Payload>[] payload_raw =

        final Set<Class<? extends Payload>> payloadSet;
            final int index = computeIndex(composite);
            final ConstraintOverrides generalOverride = findOverride(composite.getAnnotation().annotationType(), -1);
            final ConstraintOverrides override = findOverride(composite.getAnnotation().annotationType(), index);
            final OverridesAttribute.List overridesAttributeList = method.getAnnotation(OverridesAttribute.List.class);
            if (overridesAttributeList != null) {
                for (OverridesAttribute overridesAttribute : overridesAttributeList.value()) {
                    parseConstraintOverride(method.getName(), overridesAttribute);
            final OverridesAttribute overridesAttribute = method.getAnnotation(OverridesAttribute.class);
            if (overridesAttribute != null) {
                parseConstraintOverride(method.getName(), overridesAttribute);
            final Annotation originalAnnot = composite.getAnnotation();
            final AnnotationProxyBuilder<Annotation> apb = new AnnotationProxyBuilder<Annotation>(originalAnnot);
            final Annotation newAnnot = apb.createAnnotation();
    public boolean processAnnotations(Meta prop, Class<?> owner, AnnotatedElement element, AccessStrategy access,
        AppendValidation appender) throws IllegalAccessException, InvocationTargetException {
        AccessStrategy access, AppendValidation appender, boolean reflection) throws IllegalAccessException,
        InvocationTargetException {
        final Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
        } else if (ArrayUtils.contains(strategies, access)) {
            return false;
        } else {
            strategies = ArrayUtils.add(strategies, access);
        prop.putFeature(Features.Property.REF_CASCADE, strategies);
        final Class<A> annotationType = (Class<A>) annotation.annotationType();
        Class<? extends ConstraintValidator<A, ?>>[] validatorClasses =
            factoryContext.getFactory().getConstraintsCache().getConstraintValidators(annotationType);
        final Class<? extends ConstraintValidator<A, ?>>[] constraintClasses = select(rawConstraintClasses, access);
            new AnnotationConstraintBuilder<A>(factoryContext.getConstraintValidatorFactory(), constraintClasses,
                annotation, owner, access, null);
            final MetaBean parentMetaBean = prop.getParentMetaBean();
        final Class<? extends ConstraintValidator<A, ?>>[] rawConstraintClasses, final AccessStrategy access) {
            final Collection<Class<? extends ConstraintValidator<A, ?>>> selected =
                new ArrayList<Class<? extends ConstraintValidator<A, ?>>>();
                        if (isReturn && ValidationTarget.ANNOTATED_ELEMENT == validationTarget) {
                        } else if (isParam && ValidationTarget.PARAMETERS == validationTarget) {
                }
            @SuppressWarnings("unchecked")
            final Class<? extends ConstraintValidator<A, ?>>[] result = selected.toArray(new Class[selected.size()]);
            return result;
        final List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>();
        final String[] factoryClassNames =
            StringUtils.split(factory.getProperties().get(
                ApacheValidatorConfiguration.Properties.METABEAN_FACTORY_CLASSNAMES));
                final Class<? extends MetaBeanFactory> factoryClass = (Class<? extends MetaBeanFactory>) loadClass(clsName);
        final boolean enableMetaBeansXml =
            Boolean.parseBoolean(factory.getProperties().get(
                ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML));
            final String validatorFactoryClassname =
        return (name.startsWith("get") || name.startsWith("is")) && method.getParameterTypes().length == 0;
import javax.enterprise.inject.spi.CDI;
            final BeanManager beanManager = CDI.current().getBeanManager();
    public static BeanManager getBeanManager() {
        return CDI.current().getBeanManager();
                        useCdi = BValExtension.getBeanManager() != null;
                        return instance.getInstance();
                    throw new IllegalStateException("Can't create "  constraintClass.getName());
                try {
                    final BeanDescriptor classConstraints = validator.getConstraintsForClass(javaClass);
                    if (annotatedType.isAnnotationPresent(ValidateOnExecution.class)
                            || hasValidationAnnotation(annotatedType.getMethods())
                            || hasValidationAnnotation(annotatedType.getConstructors())
                            || (validBean && classConstraints != null && classConstraints.isBeanConstrained())
                            || (validConstructors && classConstraints != null && !classConstraints.getConstrainedConstructors().isEmpty())
                            || (validBusinessMethods && classConstraints != null && !classConstraints.getConstrainedMethods(MethodType.NON_GETTER).isEmpty())
                            || (validGetterMethods && classConstraints != null && !classConstraints.getConstrainedMethods(MethodType.GETTER).isEmpty())) {
                        // TODO: keep track of bValAnnotatedType and remove @BValBinding in
                        // ProcessBean event if needed cause here we can't really add @ValidateOnExecution
                        // through an extension
                        final BValAnnotatedType<A> bValAnnotatedType = new BValAnnotatedType<A>(annotatedType);
                        pat.setAnnotatedType(bValAnnotatedType);
                    }
                } catch (final NoClassDefFoundError ncdfe) {
                    // skip
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
        final boolean mustUnset = Reflection.setAccessible(field, true);
        } finally {
            if (mustUnset) {
                Reflection.setAccessible(field, false);
            }
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
        final boolean mustUnset = Reflection.setAccessible(method, true);
        } finally {
            if (mustUnset) {
                Reflection.setAccessible(method, false);
            }
import org.apache.bval.util.reflection.Reflection;
    private static Object readField(Field field, Object bean) throws IllegalAccessException {
        final boolean mustUnset = Reflection.setAccessible(field, true);
        try {
            return field.get(bean);
        } finally {
            if (mustUnset) {
                Reflection.setAccessible(field, false);
            }
        }
    }

                return readField(rememberField, bean);
            return readField(rememberField, bean);
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Member;
import org.apache.commons.weaver.privilizer.Privilizing;
 * Security-agnostic "blueprint" class for reflection-related operations. Intended for use by Apache BVal code.
    /**
     * Get the named {@link Class} from the specified {@link ClassLoader}.
     * @param classLoader
     * @param className
     * @return Class
     * @throws Exception
     */
    /**
     * Get the named value from the specified {@link Annotation}.
     * @param annotation
     * @param name
     * @return Object value
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
        final Method valueMethod;
            return null;
        final boolean mustUnset = setAccessible(valueMethod, true);
        try {
        } finally {
            if (mustUnset) {
                setAccessible(valueMethod, false);
            }
    /**
     * Get a usable {@link ClassLoader}: that of {@code clazz} if {@link Thread#getContextClassLoader()} returns {@code null}.
     * @param clazz
     * @return {@link ClassLoader}
     */
        return cl == null ? clazz.getClassLoader() : cl;
    /**
     * Convenient point for {@link Privilizing} {@link System#getProperty(String)}.
     * @param name
     * @return String
     */
    /**
     * Get the declared field from {@code clazz}.
     * @param clazz
     * @param fieldName
     * @return {@link Field} or {@code null}
     */
            return clazz.getDeclaredField(fieldName);
    /**
     * Convenient point for {@link Privilizing} {@link Class#getDeclaredFields()}.
     * @param clazz
     * @return {@link Field} array
     */
        return clazz.getDeclaredFields();
    /**
     * Get the declared constructor from {@code clazz}.
     * @param T generic type
     * @param clazz
     * @param parameters
     * @return {@link Constructor} or {@code null}
     */
    public static <T> Constructor<T> getDeclaredConstructor(final Class<T> clazz, final Class<?>... parameters) {
    /**
     * Get the declared method from {@code clazz}.
     * @param clazz
     * @param name
     * @param parameters
     * @return {@link Method} or {@code null}
     */
    /**
     * Convenient point for {@link Privilizing} {@link Class#getDeclaredMethods()}.
     * @param clazz
     * @return {@link Method} array
     */
    /**
     * Convenient point for {@link Privilizing} {@link Class#getDeclaredConstructors()}.
     * @param clazz
     * @return {@link Constructor} array
     */
    /**
     * Get the specified {@code public} {@link Method} from {@code clazz}.
     * @param clazz
     * @param methodName
     * @return {@link Method} or {@code null}
     */
    public static Method getPublicMethod(final Class<?> clazz, final String methodName, Class<?>... parameterTypes) {
            return clazz.getMethod(methodName, parameterTypes);
    /**
     * Construct a new instance of {@code cls} using its default constructor.
     * @param cls
     * @return T
     */
    /**
     * Set the accessibility of {@code o} to {@code accessible}.
     * @param o
     * @param accessible
     * @return whether a change was made.
     */
    public static boolean setAccessible(final AccessibleObject o, boolean accessible) {
        if (o == null || o.isAccessible() == accessible) {
            return false;
        }
        final Member m = (Member) o;
        if (Modifier.isPublic(m.getModifiers())) {
            /*
             * For objects with public accessibility, we do nothing and return with one exception.
             * 
             * Following explanation copied from Apache Commons [lang] MemberUtils:
             * When a {@code public} class has a default access superclass with {@code public} members,
             * these members are accessible. Calling them from compiled code works fine.
             * Unfortunately, on some JVMs, using reflection to invoke these members
             * seems to (wrongly) prevent access even when the modifier is {@code public}.
             * Calling {@code setAccessible(true)} solves the problem but will only work from
             * sufficiently privileged code.
             */
            if (!isPackageAccess(m.getDeclaringClass().getModifiers())) {
                return false;
            }
        }
        o.setAccessible(accessible);
        return true;
    }

    private static boolean isPackageAccess(final int modifiers) {
        return (modifiers & (Modifier.PRIVATE | Modifier.PROTECTED | Modifier.PUBLIC)) == 0;
    }

// TODO move this guy up to org.apache.bval.jsr or org.apache.bval.jsr.model
            final boolean mustUnset = Reflection.setAccessible(m, true);
            } catch (Exception e) {
                throw new ValidationException("Cannot access annotation "  annot  " element: "  m.getName(), e);
            } finally {
                if (mustUnset) {
                    Reflection.setAccessible(m, false);
                }
import org.apache.commons.lang3.ArrayUtils;
                    throw new ValidationException(beanClass.getName()  " has already be configured in xml.");
        Class<?>[] groupSequence = createGroupSequence(classType.getGroupSequence(), defaultPackage);
    private <A extends Annotation> Class<?> getAnnotationParameterType(final Class<A> annotationClass, final String name) {
        List<Object> values = new ArrayList<Object>();
        for (Serializable s : elementType.getContent()) {
            values.add(getSingleValue(s, returnType.getComponentType(), defaultPackage));
        }
        return values.toArray((Object[]) Array.newInstance(returnType.getComponentType(), values.size()));
    private Object getSingleValue(Serializable serializable, Class<?> returnType, String defaultPackage) {
            return convertToResultType(returnType, value, defaultPackage);
        if (serializable instanceof JAXBElement<?>) {
            JAXBElement<?> elem = (JAXBElement<?>) serializable;
            if (String.class.equals(elem.getDeclaredType())) {
                String value = (String) elem.getValue();
                return convertToResultType(returnType, value, defaultPackage);
            }
            if (AnnotationType.class.equals(elem.getDeclaredType())) {
                AnnotationType annotationType = (AnnotationType) elem.getValue();
                try {
                    Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) returnType;
                    return createAnnotation(annotationType, annotationClass, defaultPackage);
                } catch (ClassCastException e) {
                    throw new ValidationException("Unexpected parameter value");
                }
            }
        }
        throw new ValidationException("Unexpected parameter value");
    private Object convertToResultType(Class<?> returnType, String value, String defaultPackage) {
        }
        if (Byte.class.equals(returnType) || byte.class.equals(returnType)) { // spec mandates it
        }
        if (Short.class.equals(returnType) || short.class.equals(returnType)) {
        }
        if (Integer.class.equals(returnType) || int.class.equals(returnType)) {
        }
        if (Long.class.equals(returnType) || long.class.equals(returnType)) {
        }
        if (Float.class.equals(returnType) || float.class.equals(returnType)) {
        }
        if (Double.class.equals(returnType) || double.class.equals(returnType)) {
        }
        if (Boolean.class.equals(returnType) || boolean.class.equals(returnType)) {
        }
        if (Character.class.equals(returnType) || char.class.equals(returnType)) {
        if (converter == null) {
        return converter.convert(returnType, value);
            return ArrayUtils.EMPTY_CLASS_ARRAY;
    private Class<? extends Payload>[] getPayload(PayloadType payloadType, String defaultPackage) {
            payloadList.add((Class<? extends Payload>) payload);
    private Class<?>[] createGroupSequence(GroupSequenceType groupSequenceType, String defaultPackage) {
        return null;
    private <A> void processMethodLevel(final List<MethodType> methods, final Class<A> beanClass,
        final String defaultPackage, final boolean parentIgnoreAnn, final Collection<String> getters) {
            } 
            methodNames.add(methodName);

            if (methodType.getIgnoreAnnotations() == null) {
            } else {
                ignoreAnn = methodType.getIgnoreAnnotations();
                    final MetaConstraint<?, ?> constraint =
                        new MetaConstraint<A, Annotation>(beanClass, method,
                            AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint =
                            new MetaConstraint<A, Annotation>(beanClass, method,
                                new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                    final MetaConstraint<?, ?> constraint =
                        new MetaConstraint<A, Annotation>(beanClass, method,
                            AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint =
                            new MetaConstraint<A, Annotation>(beanClass, method,
                                new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(method,
                    returnValue.getIgnoreAnnotations() == null ? ignoreAnn : returnValue.getIgnoreAnnotations());
                factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(method,
                    crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
    private <A> void processConstructorLevel(final List<ConstructorType> constructors, final Class<A> beanClass,
        final String defaultPackage, final boolean parentIgnore) {
            final Constructor<?> constructor =
                Reflection.getDeclaredConstructor(beanClass, toTypes(constructorType.getParameter(), defaultPackage));
            final boolean ignoreMethodAnnotation =
                constructorType.getIgnoreAnnotations() == null ? parentIgnore : constructorType.getIgnoreAnnotations();
            if (constructorType.getIgnoreAnnotations() == null) {
            } else {
                ignoreAnn = constructorType.getIgnoreAnnotations();
                    final MetaConstraint<?, ?> constraint =
                        new MetaConstraint<A, Annotation>(beanClass, constructor,
                            AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint =
                            new MetaConstraint<A, Annotation>(beanClass, constructor,
                                new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                boolean ignoreParametersAnnotation =
                    p.getIgnoreAnnotations() == null ? ignoreMethodAnnotation : p.getIgnoreAnnotations();
                    // TODO what ?
                factory.getAnnotationIgnores().setIgnoreAnnotationsOnParameter(constructor, i,
                    p.getIgnoreAnnotations() != null ? p.getIgnoreAnnotations() : ignoreAnn);
                    final MetaConstraint<?, ?> constraint =
                        new MetaConstraint<A, Annotation>(beanClass, constructor,
                            AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint =
                            new MetaConstraint<A, Annotation>(beanClass, constructor,
                                new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(constructor,
                    returnValue.getIgnoreAnnotations() != null ? returnValue.getIgnoreAnnotations() : ignoreAnn);
                factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(constructor,
                    crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
                throw new ValidationException(fieldName  " is defined more than once in mapping xml for bean "
                     beanClass.getName());
            } 
            fieldNames.add(fieldName);

                throw new ValidationException(beanClass.getName()  " does not contain the fieldType  "  fieldName);
            getterNames.add(methodName);

        if (validator == null) {
            /* Collections.addAll() would be more straightforward here, but there is an Oracle compiler bug of some sort
             * that precludes this:
             */
            Class<? extends ConstraintValidator<?, ?>>[] validatedBy = annotationType.getAnnotation(Constraint.class).validatedBy();
        } else {
            Collections.addAll(classes, validator);
    private static Method getGetter(Class<?> clazz, String propertyName) {
        setAccessible(constructor);
import java.lang.reflect.AccessibleObject;
import org.apache.commons.weaver.privilizer.Privileged;

    /**
     * Set {@code accessibleObject} as being accessible
     * @param accessibleObject
     */
    protected boolean setAccessible(AccessibleObject accessibleObject) {
        if (accessibleObject.isAccessible()) {
            return false;
        }
        doSetAccessible(accessibleObject);
        return true;
    }

    @Privileged
    private void doSetAccessible(AccessibleObject accessibleObject) {
        accessibleObject.setAccessible(true);
    }
        setAccessible(field);
        setAccessible(method);
                return rememberField.get(bean);
            return rememberField.get(bean);
        if (!field.isAccessible()) {
            field.setAccessible(true);
        }
 * Security-agnostic "blueprint" class for reflection-related operations.
    private static void setAccessibility(final Field field) {
        // FIXME 2011-03-27 jw:
        // - Why not simply call field.setAccessible(true)?
        // - Fields can not be abstract.
        if (!Modifier.isPublic(field.getModifiers())
            || (Modifier.isPublic(field.getModifiers()) && Modifier.isAbstract(field.getModifiers()))) {
            field.setAccessible(true);
        }
    }

        Method valueMethod;
            valueMethod = null;
        if (null != valueMethod) {
            if (!valueMethod.isAccessible()) {
                valueMethod.setAccessible(true);
            return valueMethod.invoke(annotation);
        return null;
        if (cl != null) {
            return cl;
        }
        return clazz.getClassLoader();
        final Field f;
            f = clazz.getDeclaredField(fieldName);
        setAccessibility(f);
        return f;
        final Field[] fields = clazz.getDeclaredFields();
        if (fields.length > 0) {
            for (final Field f : fields) {
                if (!f.isAccessible()) {
                    f.setAccessible(true);
                }
            }
        }
        return fields;
    public static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>... parameters) {
    public static Method getPublicMethod(final Class<?> clazz, final String methodName) {
            return clazz.getMethod(methodName);
import java.lang.reflect.InvocationTargetException;
// TODO move this guy up to org.apache.bval.jsr or
// org.apache.bval.jsr.model
            if (!m.isAccessible()) {
                m.setAccessible(true);
            }
            } catch (IllegalArgumentException e) {
                // No args, so should not happen
                throw new ValidationException("Cannot access annotation "  annot  " element: "  m.getName());
            } catch (IllegalAccessException e) {
                throw new ValidationException("Cannot access annotation "  annot  " element: "  m.getName());
            } catch (InvocationTargetException e) {
                throw new ValidationException("Cannot access annotation "  annot  " element: "  m.getName());
                    throw new ValidationException(
                          beanClass.getName()  " has already be configured in xml.");
        Class<?>[] groupSequence =
              createGroupSequence(classType.getGroupSequence(), defaultPackage);
    private <A extends Annotation> Class<?> getAnnotationParameterType(
          final Class<A> annotationClass, final String name) {
        } else {
            List<Object> values = new ArrayList<Object>();
            for (Serializable s : elementType.getContent()) {
                values.add(getSingleValue(s, returnType.getComponentType(), defaultPackage));
            }
            return values.toArray(
                  (Object[]) Array.newInstance(returnType.getComponentType(), values.size()));
    private Object getSingleValue(Serializable serializable, Class<?> returnType,
                                  String defaultPackage) {

        Object returnValue;
            returnValue = convertToResultType(returnType, value, defaultPackage);
        } else if (serializable instanceof JAXBElement<?> &&
              ((JAXBElement<?>) serializable).getDeclaredType()
                    .equals(String.class)) {
            String value = (String) elem.getValue();
            returnValue = convertToResultType(returnType, value, defaultPackage);
        } else if (serializable instanceof JAXBElement<?> &&
              ((JAXBElement<?>) serializable).getDeclaredType()
                    .equals(AnnotationType.class)) {
            JAXBElement<?> elem = (JAXBElement<?>) serializable;
            AnnotationType annotationType = (AnnotationType) elem.getValue();
            try {
                Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) returnType;
                returnValue =
                      createAnnotation(annotationType, annotationClass, defaultPackage);
            } catch (ClassCastException e) {
                throw new ValidationException("Unexpected parameter value");
        } else {
            throw new ValidationException("Unexpected parameter value");
        return returnValue;

    private Object convertToResultType(Class<?> returnType, String value,
                                       String defaultPackage) {
        } else if (Byte.class.equals(returnType) || byte.class.equals(returnType)) { // spec mandates it
        } else if (Short.class.equals(returnType) || short.class.equals(returnType)) {
        } else if (Integer.class.equals(returnType) || int.class.equals(returnType)) {
        } else if (Long.class.equals(returnType) || long.class.equals(returnType)) {
        } else if (Float.class.equals(returnType) || float.class.equals(returnType)) {
        } else if (Double.class.equals(returnType) || double.class.equals(returnType)) {
        } else if (Boolean.class.equals(returnType) || boolean.class.equals(returnType)) {
        } else if (Character.class.equals(returnType) || char.class.equals(returnType)) {
        if (converter != null) {
            return converter.convert(returnType, value);
        } else {
            return new Class[]{};

    private Class<? extends Payload>[] getPayload(PayloadType payloadType,
                                                  String defaultPackage) {
            } else {
                payloadList.add((Class<? extends Payload>) payload);
    private Class<?>[] createGroupSequence(GroupSequenceType groupSequenceType,
                                               String defaultPackage) {
        } else {
            return null;
    private <A> void processMethodLevel(final List<MethodType> methods, final Class<A> beanClass, final String defaultPackage, final boolean parentIgnoreAnn, final Collection<String> getters) {
            } else {
                methodNames.add(methodName);
            }
            if (methodType.getIgnoreAnnotations() != null) {
            } else {
                ignoreAnn = parentIgnoreAnn;
                    final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                    final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(method, returnValue.getIgnoreAnnotations() == null ? ignoreAnn : returnValue.getIgnoreAnnotations());
                factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(method, crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
    private <A> void processConstructorLevel(final List<ConstructorType> constructors, final Class<A> beanClass, final String defaultPackage, final boolean parentIgnore) {
            final Constructor<?> constructor = Reflection.getDeclaredConstructor(beanClass, toTypes(constructorType.getParameter(), defaultPackage));
            final boolean ignoreMethodAnnotation = constructorType.getIgnoreAnnotations() == null ? parentIgnore : constructorType.getIgnoreAnnotations();
            if (constructorType.getIgnoreAnnotations() != null) {
            } else {
                ignoreAnn = parentIgnore;
                    final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                boolean ignoreParametersAnnotation = p.getIgnoreAnnotations() == null ? ignoreMethodAnnotation : p.getIgnoreAnnotations();

                factory.getAnnotationIgnores().setIgnoreAnnotationsOnParameter(constructor, i, p.getIgnoreAnnotations() != null ? p.getIgnoreAnnotations() : ignoreAnn);
                    final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(constructor, returnValue.getIgnoreAnnotations() != null ? returnValue.getIgnoreAnnotations() : ignoreAnn);
                factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(constructor, crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
                throw new ValidationException(fieldName 
                      " is defined more than once in mapping xml for bean " 
                      beanClass.getName());
            } else {
                fieldNames.add(fieldName);
            }
                throw new ValidationException(
                      beanClass.getName()  " does not contain the fieldType  "  fieldName);
            } else {
                getterNames.add(methodName);
        if (validator != null) {
            classes
                  .addAll(Arrays.asList(validator));
            Class<? extends ConstraintValidator<?, ?>>[] validatedBy = annotationType
                  .getAnnotation(Constraint.class)
                  .validatedBy();
            classes.addAll(Arrays.asList(validatedBy));
    private static Method getGetter(Class<?> clazz,String propertyName) {
import org.apache.commons.lang3.ArrayUtils;
                    throw new ValidationException(beanClass.getName()  " has already be configured in xml.");
        Class<?>[] groupSequence = createGroupSequence(classType.getGroupSequence(), defaultPackage);
    private <A extends Annotation> Class<?> getAnnotationParameterType(final Class<A> annotationClass, final String name) {
        List<Object> values = new ArrayList<Object>();
        for (Serializable s : elementType.getContent()) {
            values.add(getSingleValue(s, returnType.getComponentType(), defaultPackage));
        }
        return values.toArray((Object[]) Array.newInstance(returnType.getComponentType(), values.size()));
    private Object getSingleValue(Serializable serializable, Class<?> returnType, String defaultPackage) {
            return convertToResultType(returnType, value, defaultPackage);
        if (serializable instanceof JAXBElement<?>) {
            JAXBElement<?> elem = (JAXBElement<?>) serializable;
            if (String.class.equals(elem.getDeclaredType())) {
                String value = (String) elem.getValue();
                return convertToResultType(returnType, value, defaultPackage);
            }
            if (AnnotationType.class.equals(elem.getDeclaredType())) {
                AnnotationType annotationType = (AnnotationType) elem.getValue();
                try {
                    Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) returnType;
                    return createAnnotation(annotationType, annotationClass, defaultPackage);
                } catch (ClassCastException e) {
                    throw new ValidationException("Unexpected parameter value");
                }
            }
        }
        throw new ValidationException("Unexpected parameter value");
    private Object convertToResultType(Class<?> returnType, String value, String defaultPackage) {
        }
        if (Byte.class.equals(returnType) || byte.class.equals(returnType)) { // spec mandates it
        }
        if (Short.class.equals(returnType) || short.class.equals(returnType)) {
        }
        if (Integer.class.equals(returnType) || int.class.equals(returnType)) {
        }
        if (Long.class.equals(returnType) || long.class.equals(returnType)) {
        }
        if (Float.class.equals(returnType) || float.class.equals(returnType)) {
        }
        if (Double.class.equals(returnType) || double.class.equals(returnType)) {
        }
        if (Boolean.class.equals(returnType) || boolean.class.equals(returnType)) {
        }
        if (Character.class.equals(returnType) || char.class.equals(returnType)) {
        if (converter == null) {
        return converter.convert(returnType, value);
            return ArrayUtils.EMPTY_CLASS_ARRAY;
    private Class<? extends Payload>[] getPayload(PayloadType payloadType, String defaultPackage) {
            payloadList.add((Class<? extends Payload>) payload);
    private Class<?>[] createGroupSequence(GroupSequenceType groupSequenceType, String defaultPackage) {
        return null;
    private <A> void processMethodLevel(final List<MethodType> methods, final Class<A> beanClass,
        final String defaultPackage, final boolean parentIgnoreAnn, final Collection<String> getters) {
            } 
            methodNames.add(methodName);

            if (methodType.getIgnoreAnnotations() == null) {
            } else {
                ignoreAnn = methodType.getIgnoreAnnotations();
                    final MetaConstraint<?, ?> constraint =
                        new MetaConstraint<A, Annotation>(beanClass, method,
                            AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint =
                            new MetaConstraint<A, Annotation>(beanClass, method,
                                new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                    final MetaConstraint<?, ?> constraint =
                        new MetaConstraint<A, Annotation>(beanClass, method,
                            AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint =
                            new MetaConstraint<A, Annotation>(beanClass, method,
                                new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(method,
                    returnValue.getIgnoreAnnotations() == null ? ignoreAnn : returnValue.getIgnoreAnnotations());
                factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(method,
                    crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
    private <A> void processConstructorLevel(final List<ConstructorType> constructors, final Class<A> beanClass,
        final String defaultPackage, final boolean parentIgnore) {
            final Constructor<?> constructor =
                Reflection.getDeclaredConstructor(beanClass, toTypes(constructorType.getParameter(), defaultPackage));
            final boolean ignoreMethodAnnotation =
                constructorType.getIgnoreAnnotations() == null ? parentIgnore : constructorType.getIgnoreAnnotations();
            if (constructorType.getIgnoreAnnotations() == null) {
            } else {
                ignoreAnn = constructorType.getIgnoreAnnotations();
                    final MetaConstraint<?, ?> constraint =
                        new MetaConstraint<A, Annotation>(beanClass, constructor,
                            AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint =
                            new MetaConstraint<A, Annotation>(beanClass, constructor,
                                new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                boolean ignoreParametersAnnotation =
                    p.getIgnoreAnnotations() == null ? ignoreMethodAnnotation : p.getIgnoreAnnotations();
                    // TODO what ?
                factory.getAnnotationIgnores().setIgnoreAnnotationsOnParameter(constructor, i,
                    p.getIgnoreAnnotations() != null ? p.getIgnoreAnnotations() : ignoreAnn);
                    final MetaConstraint<?, ?> constraint =
                        new MetaConstraint<A, Annotation>(beanClass, constructor,
                            AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint =
                            new MetaConstraint<A, Annotation>(beanClass, constructor,
                                new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(constructor,
                    returnValue.getIgnoreAnnotations() != null ? returnValue.getIgnoreAnnotations() : ignoreAnn);
                factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(constructor,
                    crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
                throw new ValidationException(fieldName  " is defined more than once in mapping xml for bean "
                     beanClass.getName());
            } 
            fieldNames.add(fieldName);

                throw new ValidationException(beanClass.getName()  " does not contain the fieldType  "  fieldName);
            getterNames.add(methodName);

        if (validator == null) {
            /* Collections.addAll() would be more straightforward here, but there is an Oracle compiler bug of some sort
             * that precludes this:
             */
            Class<? extends ConstraintValidator<?, ?>>[] validatedBy = annotationType.getAnnotation(Constraint.class).validatedBy();
        } else {
            Collections.addAll(classes, validator);
    private static Method getGetter(Class<?> clazz, String propertyName) {
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
        final boolean mustUnset = Reflection.setAccessible(field, true);
        } finally {
            if (mustUnset) {
                Reflection.setAccessible(field, false);
            }
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
        final boolean mustUnset = Reflection.setAccessible(method, true);
        } finally {
            if (mustUnset) {
                Reflection.setAccessible(method, false);
            }
import org.apache.bval.util.reflection.Reflection;
    private static Object readField(Field field, Object bean) throws IllegalAccessException {
        final boolean mustUnset = Reflection.setAccessible(field, true);
        try {
            return field.get(bean);
        } finally {
            if (mustUnset) {
                Reflection.setAccessible(field, false);
            }
        }
    }

                return readField(rememberField, bean);
            return readField(rememberField, bean);
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Member;
import org.apache.commons.weaver.privilizer.Privilizing;
 * Security-agnostic "blueprint" class for reflection-related operations. Intended for use by Apache BVal code.
    /**
     * Get the named {@link Class} from the specified {@link ClassLoader}.
     * @param classLoader
     * @param className
     * @return Class
     * @throws Exception
     */
    /**
     * Get the named value from the specified {@link Annotation}.
     * @param annotation
     * @param name
     * @return Object value
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
        final Method valueMethod;
            return null;
        final boolean mustUnset = setAccessible(valueMethod, true);
        try {
        } finally {
            if (mustUnset) {
                setAccessible(valueMethod, false);
            }
    /**
     * Get a usable {@link ClassLoader}: that of {@code clazz} if {@link Thread#getContextClassLoader()} returns {@code null}.
     * @param clazz
     * @return {@link ClassLoader}
     */
        return cl == null ? clazz.getClassLoader() : cl;
    /**
     * Convenient point for {@link Privilizing} {@link System#getProperty(String)}.
     * @param name
     * @return String
     */
    /**
     * Get the declared field from {@code clazz}.
     * @param clazz
     * @param fieldName
     * @return {@link Field} or {@code null}
     */
            return clazz.getDeclaredField(fieldName);
    /**
     * Convenient point for {@link Privilizing} {@link Class#getDeclaredFields()}.
     * @param clazz
     * @return {@link Field} array
     */
        return clazz.getDeclaredFields();
    /**
     * Get the declared constructor from {@code clazz}.
     * @param T generic type
     * @param clazz
     * @param parameters
     * @return {@link Constructor} or {@code null}
     */
    public static <T> Constructor<T> getDeclaredConstructor(final Class<T> clazz, final Class<?>... parameters) {
    /**
     * Get the declared method from {@code clazz}.
     * @param clazz
     * @param name
     * @param parameters
     * @return {@link Method} or {@code null}
     */
    /**
     * Convenient point for {@link Privilizing} {@link Class#getDeclaredMethods()}.
     * @param clazz
     * @return {@link Method} array
     */
    /**
     * Convenient point for {@link Privilizing} {@link Class#getDeclaredConstructors()}.
     * @param clazz
     * @return {@link Constructor} array
     */
    /**
     * Get the specified {@code public} {@link Method} from {@code clazz}.
     * @param clazz
     * @param methodName
     * @return {@link Method} or {@code null}
     */
    public static Method getPublicMethod(final Class<?> clazz, final String methodName, Class<?>... parameterTypes) {
            return clazz.getMethod(methodName, parameterTypes);
    /**
     * Construct a new instance of {@code cls} using its default constructor.
     * @param cls
     * @return T
     */
    /**
     * Set the accessibility of {@code o} to {@code accessible}.
     * @param o
     * @param accessible
     * @return whether a change was made.
     */
    public static boolean setAccessible(final AccessibleObject o, boolean accessible) {
        if (o == null || o.isAccessible() == accessible) {
            return false;
        }
        final Member m = (Member) o;
        if (Modifier.isPublic(m.getModifiers())) {
            /*
             * For objects with public accessibility, we do nothing and return with one exception.
             * 
             * Following explanation copied from Apache Commons [lang] MemberUtils:
             * When a {@code public} class has a default access superclass with {@code public} members,
             * these members are accessible. Calling them from compiled code works fine.
             * Unfortunately, on some JVMs, using reflection to invoke these members
             * seems to (wrongly) prevent access even when the modifier is {@code public}.
             * Calling {@code setAccessible(true)} solves the problem but will only work from
             * sufficiently privileged code.
             */
            if (!isPackageAccess(m.getDeclaringClass().getModifiers())) {
                return false;
            }
        }
        o.setAccessible(accessible);
        return true;
    }

    private static boolean isPackageAccess(final int modifiers) {
        return (modifiers & (Modifier.PRIVATE | Modifier.PROTECTED | Modifier.PUBLIC)) == 0;
    }

// TODO move this guy up to org.apache.bval.jsr or org.apache.bval.jsr.model
            final boolean mustUnset = Reflection.setAccessible(m, true);
            } catch (Exception e) {
                throw new ValidationException("Cannot access annotation "  annot  " element: "  m.getName(), e);
            } finally {
                if (mustUnset) {
                    Reflection.setAccessible(m, false);
                }
            return getPropertyValue(new PropertyAccess(bean.getClass(), metaProperty.getName()));
        return getPropertyValue(access);
    public Object getPropertyValue(AccessStrategy access) throws IllegalArgumentException, IllegalStateException {
        return "BeanValidationContext{ bean="  bean  ", metaProperty="  metaProperty  ", propertyValue="
             propertyValue  '}';
                        if (context == null) {
                        }
            return context == null ? null : context.getListener();
        if (validate.value().isEmpty()) {
            if (parameter == null) {
            }
            if (parameter instanceof Collection<?>) { // do not validate empty collection
                if (coll.isEmpty()) {
                }
                beanClass = coll.iterator().next().getClass(); // get first object
        if (access == null && prop.getMetaBean() != null) { // single property access strategy
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        return bean instanceof Class<?> ? finder.findForClass((Class<?>) bean) : finder.findForClass(bean.getClass());
        if (beanInfo.getBeanClass() != null && beanInfo.getId().equals(beanInfo.getBeanClass().getName())) {
        if (beanInfo.getBeanClass() != null && beanInfo.getId().equals(beanInfo.getBeanClass().getName())) {
        if (beanType == null) {
            if (prop.getFeature(REF_CASCADE) != null) { // dynamic type resolution:
                prop.setMetaBean(new DynamicMetaBean(this));
            }
        } else {
        if (error.getReason() == null) {
            return;
        }
        if (error.getOwner() == null) {
            return;
        }
        if (errorsByReason == null) {
            return Collections.emptyMap();
        }
        if (errorsByOwner == null) {
            return Collections.emptyMap();
        }
        if (errorsByReason == null || (errorsByReason.isEmpty() && errorsByOwner.isEmpty())) {
            return true;
        }
            if (!list.isEmpty()) {
                return false;
            }
                if (!list.isEmpty()) {
                    return false;
                }
        if (errorsByReason == null)
            return false;
        if (errorsByOwner == null) {
            return false;
        }
        if (errors == null) {
            return false;
        }
        if (propertyName == null) {
                if (!list.isEmpty()) {
                    return true;
                }
        List<Error> list = errors.get(propertyName);
        return list != null && !list.isEmpty();
        @SuppressWarnings("unchecked")
        final T faster = (T) features.putIfAbsent(key, value);
        return faster == null ? value : faster;
        if (validations == null) {
        }
            if (validation.equals(aValidation)) {
            }
public abstract class Meta extends FeaturesCapable {
    private static final long serialVersionUID = 1L;

        return methods == null ? null : methods.get(method);
        return constructors == null ? null : constructors.get(constructor);
            if (idx == null) {
                return Integer.MIN_VALUE; // to avoid collision and false positive in get() due to equals
            return idx;
            return i == 0 ? methods.get(o1) - methods.get(o2) : i;
            return i == 0 ? constructors.get(o1) - constructors.get(o2) : i;
    private static final long serialVersionUID = 1L;

public abstract class MetaInvocable extends MetaAnnotated {
    private static final long serialVersionUID = 1L;

    private static final long serialVersionUID = 1L;

public class MetaParameter extends MetaAnnotated {
    private static final long serialVersionUID = 1L;
    @Override
    public MetaBean getParentMetaBean() {
        return invocable.getParentMetaBean();
public class MetaProperty extends Meta implements Cloneable, Features.Property {
        Type targetType = type instanceof DynaType ? ((DynaType) type).getRawType() : type;
        Type assigningType = getParentMetaBean() == null ? null : getParentMetaBean().getBeanClass();
        if (value == null) {
        }
        if (!(value instanceof CharSequence)) {
        }
        if (seq.length() == 0) {
        }
        return aPattern.matcher(seq).matches();
import org.apache.commons.lang3.StringUtils;
            InputStream in = BValVersion.class.getResourceAsStream("/META-INF/org.apache.bval.revision.properties");
        if (StringUtils.isBlank(revision)) {
            if (strTok != null) {
            }
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        if (this == o) {
        }
        if (o == null || getClass() != o.getClass()) {
        }
                if (dyn == null) {
                } else {
                    context.setBean(each, dyn.resolveMetaBean(each));
                if (dyn == null) {
                } else {
                    context.setBean(each, dyn.resolveMetaBean(each));
        if (errorsByReason == null) {
        }

        // For public members whose declaring classes are public, we need do nothing:
        if (Modifier.isPublic(m.getModifiers()) && Modifier.isPublic(m.getDeclaringClass().getModifiers())) {
            return false;
    public static List<Class<?>> fillFullClassHierarchyAsList(List<Class<?>> allClasses, Class<?> clazz) {
                final Class<?> loaded = loadClass(parameterNameProvider);
                if (loaded != null) {
                    final Class<? extends ParameterNameProvider> clazz = loaded.asSubclass(ParameterNameProvider.class);
                    targetConfig.parameterNameProviderClass(clazz);
                    log.log(Level.INFO, String.format("Using %s as validation provider.", parameterNameProvider));
                } else {
                    log.log(Level.SEVERE, "Can't load "  parameterNameProvider);
                }
        return value == null || Boolean.FALSE.equals(value);
        return value == null || Boolean.TRUE.equals(value);
public class DecimalMaxValidatorForNumber implements ConstraintValidator<DecimalMax, Number> {
        if (value instanceof BigDecimal) {
            return ((BigDecimal) value).compareTo(maxValue) != 1;
        }
        if (value instanceof BigInteger) {
            return (new BigDecimal((BigInteger) value)).compareTo(maxValue) != 1;
        }
        return (new BigDecimal(value.doubleValue()).compareTo(maxValue)) != 1;
public class DecimalMaxValidatorForString implements ConstraintValidator<DecimalMax, String> {
            throw new IllegalArgumentException(annotation.value()  " does not represent a valid BigDecimal format");
public class DecimalMinValidatorForNumber implements ConstraintValidator<DecimalMin, Number> {
            throw new IllegalArgumentException(annotation.value()  " does not represent a valid BigDecimal format");
        if (value instanceof BigDecimal) {
            return ((BigDecimal) value).compareTo(minValue) != -1;
        }
        if (value instanceof BigInteger) {
            return (new BigDecimal((BigInteger) value)).compareTo(minValue) != -1;
        }
        return (new BigDecimal(value.doubleValue()).compareTo(minValue)) != -1;
public class DecimalMinValidatorForString implements ConstraintValidator<DecimalMin, String> {
            throw new IllegalArgumentException(annotation.value()  " does not represent a valid BigDecimal format");
            throw new IllegalArgumentException("The length of the integer part cannot be negative.");
            throw new IllegalArgumentException("The length of the fraction part cannot be negative.");
        final int intLength = bigDecimal.precision() - bigDecimal.scale();
        return false;
            throw new IllegalArgumentException("The length of the integer part cannot be negative.");
            throw new IllegalArgumentException("The length of the fraction part cannot be negative.");
        final BigDecimal bigDecimal = getBigDecimalValue(str);
        return false;
            return new BigDecimal(str);
        if (value instanceof BigDecimal) {
            return ((BigDecimal) value).compareTo(BigDecimal.valueOf(max)) != 1;
        }
        if (value instanceof BigInteger) {
            return ((BigInteger) value).compareTo(BigInteger.valueOf(max)) != 1;
        }
        return value.longValue() <= max;
        if (value instanceof BigDecimal) {
            return ((BigDecimal) value).compareTo(BigDecimal.valueOf(minValue)) != -1;
        }
        if (value instanceof BigInteger) {
            return ((BigInteger) value).compareTo(BigInteger.valueOf(minValue)) != -1;
        }
        return value.longValue() >= minValue;
        if (value == null) {
            return true;
        }
        try {
            final Method isEmptyMethod = value.getClass().getMethod("isEmpty");
            if (isEmptyMethod != null) {
                return !((Boolean) isEmptyMethod.invoke(value)).booleanValue();
            }
        } catch (IllegalAccessException iae) {
            // do nothing
        } catch (NoSuchMethodException nsme) {
            // do nothing
        } catch (InvocationTargetException ite) {
            // do nothing
        }
        return !value.toString().isEmpty();
        return value == null || !value.isEmpty();
        final Pattern.Flag flags[] = annotation.flags();
        if (min < 0) {
            throw new ValidationException("Min cannot be negative");
        }
        if (max < 0) {
            throw new ValidationException("Max cannot be negative");
        }
        if (max < min) {
            throw new ValidationException("Max cannot be less than Min");
        }
public class SizeValidatorForArrayOfBoolean extends SizeValidator implements ConstraintValidator<Size, boolean[]> {
        final int length = Array.getLength(array);
public class SizeValidatorForArrayOfByte extends SizeValidator implements ConstraintValidator<Size, byte[]> {
        final int length = Array.getLength(array);
public class SizeValidatorForArrayOfChar extends SizeValidator implements ConstraintValidator<Size, char[]> {
        final int length = Array.getLength(array);
public class SizeValidatorForArrayOfDouble extends SizeValidator implements ConstraintValidator<Size, double[]> {
        final int length = Array.getLength(array);
public class SizeValidatorForArrayOfFloat extends SizeValidator implements ConstraintValidator<Size, float[]> {
        final int length = Array.getLength(array);
public class SizeValidatorForArrayOfInt extends SizeValidator implements ConstraintValidator<Size, int[]> {
        final int length = Array.getLength(array);
public class SizeValidatorForArrayOfLong extends SizeValidator implements ConstraintValidator<Size, long[]> {
        final int length = Array.getLength(array);
public class SizeValidatorForArrayOfObject extends SizeValidator implements ConstraintValidator<Size, Object[]> {
        final int length = Array.getLength(array);
public class SizeValidatorForArrayOfShort extends SizeValidator implements ConstraintValidator<Size, short[]> {
        final int length = Array.getLength(array);
public class SizeValidatorForCharSequence extends SizeValidator implements ConstraintValidator<Size, CharSequence> {
        final int length = s.length();
public class SizeValidatorForCollection extends SizeValidator implements ConstraintValidator<Size, Collection<?>> {
        final int length = collection.size();
public class SizeValidatorForMap extends SizeValidator implements ConstraintValidator<Size, Map<?, ?>> {
        final int size = map.size();
    private static final boolean hasSecurityManager = System.getSecurityManager() != null;
     * Set the accessibility of {@code o} to {@code accessible}. If running without a {@link SecurityManager}
     * and {@code accessible == false}, this call is ignored (because any code could reflectively make any
     * object accessible at any time).
        if (!accessible && !hasSecurityManager) {
            return false;
        }
            throw new IllegalArgumentException(annotation.value()  " does not represent a valid BigDecimal format");
        if (!accessible && System.getSecurityManager() == null) {
/**
 * Custom {@link InterceptorBinding} to invoke executable validations on CDI beans.
 */

import java.util.EnumSet;
/**
 * CDI {@link Extension} for Apache BVal setup.
 */
    public static final Set<String> SKIPPED_PREFIXES;
        final Set<String> s = new HashSet<String>();
        s.add("java.");
        s.add("javax.");
        s.add("org.apache.bval.");
        s.add("org.apache.openejb.");
        s.add("org.apache.deltaspike."); // should be checked when upgrading
        s.add("org.apache.myfaces."); // should be checked when upgrading
        SKIPPED_PREFIXES = Collections.unmodifiableSet(s);
            globalExecutableTypes = Collections.unmodifiableSet(convertToRuntimeTypes(bootstrap.getDefaultValidatedExecutableTypes()));
            // TODO we never contain IMPLICIT or ALL
            validConstructors = validBean || globalExecutableTypes.contains(ExecutableType.CONSTRUCTORS);
        if (factory == null) {
            factory = config.buildValidatorFactory();
        }
        final Set<ExecutableType> types = EnumSet.noneOf(ExecutableType.class);
            if (ExecutableType.NONE == type) {
                continue;
            }
            if (ExecutableType.ALL == type) {
            }
            if (ExecutableType.IMPLICIT == type) {
                types.add(ExecutableType.CONSTRUCTORS);
                types.add(ExecutableType.NON_GETTER_METHODS);
            } else {
                            || classConstraints != null
                            && (validBean && classConstraints.isBeanConstrained()
                                || validConstructors && !classConstraints.getConstrainedConstructors().isEmpty()
                                || validBusinessMethods && !classConstraints.getConstrainedMethods(MethodType.NON_GETTER).isEmpty()
                                || validGetterMethods && !classConstraints.getConstrainedMethods(MethodType.GETTER).isEmpty())
                            ) {
    /**
     * Request that an instance of the specified type be provided by the container.
     * @param clazz
     * @return the requested instance wrapped in a {@link Releasable}.
     */
    /**
     * Represents an item that can be released from a {@link CreationalContext} at some point in the future.
     * @param <T>
     */
import javax.interceptor.InterceptorBinding;
import java.util.EnumSet;
/**
 * Interceptor class for the {@link BValBinding} {@link InterceptorBinding}.
 */
@Priority(4800)
// TODO: maybe add it through ASM to be compliant with CDI 1.0 containers using simply this class as a template to
// generate another one for CDI 1.1 impl
    private Set<ExecutableType> classConfiguration;
    @AroundConstruct
    // TODO: see previous one
            final Set<ConstraintViolation<?>> violations =
                executableValidator.validateConstructorParameters(constructor, context.getParameters());
            final Set<ConstraintViolation<?>> violations =
                executableValidator.validateConstructorReturnValue(constructor, context.getTarget());
    private boolean isConstructorValidated(final Class<?> targetClass, final Constructor<?> constructor)
        throws NoSuchMethodException {
                        final Set<ExecutableType> config = EnumSet.noneOf(ExecutableType.class);
                            if (ExecutableType.NONE == type) {
                                continue;
                            }
                            if (ExecutableType.ALL == type) {
                                config.add(ExecutableType.NON_GETTER_METHODS);
                                config.add(ExecutableType.GETTER_METHODS);
                                break;
                            }
                            } else {
                    classConfiguration = EnumSet.noneOf(ExecutableType.class);
                            if (ExecutableType.NONE == type) {
                                continue;
                            }
                            if (ExecutableType.ALL == type) {
                            }
                            if (ExecutableType.IMPLICIT == type) {
                                classConfiguration.add(ExecutableType.CONSTRUCTORS);
                                classConfiguration.add(ExecutableType.NON_GETTER_METHODS);
                            } else {
    private static boolean doValidMethod(final Method method, final Set<ExecutableType> config) {
        return isGetter(method) ? config.contains(ExecutableType.GETTER_METHODS) : config
            .contains(ExecutableType.NON_GETTER_METHODS);
        return method.getParameterTypes().length == 0 && !Void.TYPE.equals(method.getReturnType())
            && (name.startsWith("get") || name.startsWith("is") && boolean.class.equals(method.getReturnType()));
   }
/**
 * {@link BValInterceptor} CDI {@link Bean}.
 */
        final Set<Type> t = new HashSet<Type>();
        t.add(BValInterceptor.class);
        t.add(Object.class);
        types = Collections.unmodifiableSet(t);
        final Set<Annotation> q = new HashSet<Annotation>();
        q.add(DefaultLiteral.INSTANCE);
        q.add(AnyLiteral.INSTANCE);
        qualifiers = Collections.unmodifiableSet(q);
/**
 * {@link Validator} CDI {@link Bean}.
 */
public class ValidatorBean implements Bean<Validator> , PassivationCapable {
        final Set<Type> t = new HashSet<Type>();
        t.add(Validator.class);
        t.add(Object.class);
        types = Collections.unmodifiableSet(t);
        final Set<Annotation> q = new HashSet<Annotation>();
        q.add(DefaultLiteral.INSTANCE);
        q.add(AnyLiteral.INSTANCE);
        qualifiers = Collections.unmodifiableSet(q);
/**
 * {@link ValidatorFactory} CDI {@link Bean}.
 */
        final Set<Type> t = new HashSet<Type>();
        t.add(ValidatorFactory.class);
        t.add(Object.class);
        types = Collections.unmodifiableSet(t);
        final Set<Annotation> q = new HashSet<Annotation>();
        q.add(DefaultLiteral.INSTANCE);
        q.add(AnyLiteral.INSTANCE);
        qualifiers = Collections.unmodifiableSet(q);
    private final Collection<BValExtension.Releasable<?>> releasables = new CopyOnWriteArrayList<BValExtension.Releasable<?>>();
                        useCdi = Boolean.valueOf(BValExtension.getBeanManager() != null);
                        useCdi = Boolean.FALSE;
                        useCdi = Boolean.FALSE;
            if (useCdi.booleanValue()) {
import org.apache.commons.lang3.Validate;

    private static final AnnotatedTypeFilter DEFAULT_ANNOTATED_TYPE_FILTER = new AnnotatedTypeFilter() {
        
        @Override
        public boolean accept(AnnotatedType<?> annotatedType) {
            if (annotatedType.getJavaClass().getName().startsWith("org.apache.bval.")) {
                return false;
            }
            return true;
        }
    };

    private static AnnotatedTypeFilter annotatedTypeFilter = DEFAULT_ANNOTATED_TYPE_FILTER;

    public static void setAnnotatedTypeFilter(AnnotatedTypeFilter annotatedTypeFilter) {
        BValExtension.annotatedTypeFilter = Validate.notNull(annotatedTypeFilter);

        if (!annotatedTypeFilter.accept(annotatedType)) {
        final Class<A> javaClass = annotatedType.getJavaClass();
        final int modifiers = javaClass.getModifiers();

    /**
     * Defines an item that can determine whether a given {@link AnnotatedType} will be processed
     * by the {@link BValExtension} for executable validation. May be statically applied before
     * container startup.
     * @see BValExtension#setAnnotatedTypeFilter(AnnotatedTypeFilter)
     */
    public interface AnnotatedTypeFilter {
        boolean accept(AnnotatedType<?> annotatedType);
    }
            changed = processAnnotation(annotation, prop, owner, access, appender, true) || changed;
        if (ArrayUtils.contains(strategies, access)) {
            return false;
        }
        return new ClassValidator(this);
    boolean isTreatMapsLikeBeans() {
        return Boolean.parseBoolean(factory.getProperties().get(
            ApacheValidatorConfiguration.Properties.TREAT_MAPS_LIKE_BEANS));
    }

public interface ApacheValidatorConfiguration extends Configuration<ApacheValidatorConfiguration> {
         * - true (validate maps like beans, so that
         *     you can use Maps to validate dynamic classes or
         *     beans for which you have the MetaBean but no instances)
         * - false (default), validate maps like collections
         *     (validating the values only)
            @SuppressWarnings("unchecked")
            final T result = (T) this;
            return result;
            final Class<?> cls = ClassUtils.getClass(type.getName()  "Impl");
        final Set<Class<?>> inheritedGroups = builder.getConstraintValidation().getGroups();
        final Set<Class<? extends Payload>> inheritedPayload = builder.getConstraintValidation().getPayload();
        final T originalAnnot = validation.getAnnotation();
        final AnnotationProxyBuilder<T> apb = new AnnotationProxyBuilder<T>(originalAnnot);
        final T newAnnot = apb.createAnnotation();


                if (m == null) {
                    final Method isAccessor = Reflection.getDeclaredMethod(current, "is"  name);
                    if (isAccessor != null && boolean.class.equals(isAccessor.getReturnType())) {
                        m = isAccessor;
                    }
                }
        final MetaProperty prop = metaBean.getProperty(propertyName);
        if (prop == null) {
        }
            final boolean getter =
                d.getParameterDescriptors().isEmpty()
                    && (d.getName().startsWith("get") || (d.getName().startsWith("is") && boolean.class.equals(d
                        .getReturnValueDescriptor().getElementClass())));
            if (constraintDescriptors.isEmpty()) {
                    if (!getConstraintDescriptors(mprop.getValidations()).isEmpty()) {
            } else {
                hasAnyContraints = true;
                            if (Valid.class.isInstance(anno)) {
                            } else {
                                processAnnotations(null, consDesc, cons.getDeclaringClass(), anno);
                        if (Valid.class.isInstance(anno)) {
                        } else {
                            processAnnotations(null, consDesc, cons.getDeclaringClass(), anno);
                if (consDesc.getGroupConversions().isEmpty() || consDesc.isCascaded()) {
                    ensureNotNullDescriptors(cons.getDeclaringClass(), consDesc);
                } else {
                if (consDesc.getReturnValueDescriptor() == null) {
                } else {
                    returnValueDescriptor.getMutableConstraintDescriptors().addAll(list);
                if (consDesc.getCrossParameterDescriptor() == null) {
                } else {
                    CrossParameterDescriptorImpl.class.cast(consDesc.getCrossParameterDescriptor()).getMutableConstraintDescriptors().addAll(list);
                final boolean propertyAccessor =
                    method.getParameterTypes().length == 0
                        && (method.getName().startsWith("get") && !Void.TYPE.equals(method.getReturnType()) || method
                            .getName().startsWith("is") && Boolean.TYPE.equals(method.getReturnType()));
                    } else if (parents.size() == 1) {
                        if (parentDesc == null) {
                            ensureMethodDoesntDefineParameterConstraint(methodDesc);
                        } else {
                if (propertyAccessor) {
                    if (annotationIgnores.isIgnoreAnnotationOnParameter(method, idx)) {
                    } else {
                        final ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
                        processAnnotations(methodDesc, paramAnnos, access, idx, names.get(idx));
            if (from != null) {
                if (paramDesc.isCascaded()) {
                    for (int i = 0; i < from.length; i) {
                        paramDesc.addGroupConversion(new GroupConversionDescriptorImpl(from[i], to[i]));
                    }
                } else {
                    throw new ConstraintDeclarationException("Group conversion is only relevant for @Valid cases");
        private <A extends Annotation> void processConstraint(final A annotation,
            final InvocableElementDescriptor desc, final AccessStrategy access, final AppendValidation validations)
            throws IllegalAccessException, InvocationTargetException {
            final Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
            if (vcAnno == null) {
                /*
            } else {
                annotationProcessor.processAnnotation(annotation, null, ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations, true);
    <T extends Object> Set<javax.validation.ConstraintViolation<T>> validateProperty(T object, String propertyName,
        boolean cascade, Class<?>... groups);
    <T extends Object> Set<javax.validation.ConstraintViolation<T>> validateValue(Class<T> beanType,
        String propertyName, Object value, boolean cascade, Class<?>... groups);
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
        if (object == null) {
        }
        final Set<ConstraintViolation<T>> result =
            @SuppressWarnings("unchecked")
            final T result = (T) this;
            return result;
        if (!(type.isInterface() || Modifier.isAbstract(type.getModifiers()))) {
            return newInstance(type);
        }
        try {
            final Class<?> cls = ClassUtils.getClass(type.getName()  "Impl");
            if (type.isAssignableFrom(cls)) {
                @SuppressWarnings("unchecked")
                final Class<? extends T> implClass = (Class<? extends T>) cls;
                return newInstance(implClass);
            }
        } catch (ClassNotFoundException e) {
        }
        throw new ValidationException("Type "  type  " not supported");
        final Constructor<T> cons = Reflection.getDeclaredConstructor(cls, ApacheFactoryContext.class);
        if (cons == null) {
            throw new ValidationException("Cannot instantiate "  cls);
        }
        final boolean mustUnset = Reflection.setAccessible(cons, true);
            throw new ValidationException("Cannot instantiate "  cls, ex);
        } finally {
            if (mustUnset) {
                Reflection.setAccessible(cons, false);
            }
            if (feature == null) {
            } else {
                mappedGroup = PropertyDescriptorImpl.class.cast(feature).mapGroup(group);
            if (group == mappedGroup) {
                validateCascadedBean(context, prop, null);
            } else {
                final ConstraintValidation<?> constraintValidation = ConstraintValidation.class.cast(validation);
        final AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
                        ValidationHelper.validateContext(context, new JsrValidationCallback(context), factoryContext.isTreatMapsLikeBeans());
                        }, factoryContext.isTreatMapsLikeBeans());
                context.getRootMetaBean().getBeanClass(), beanPath, access.getElementType())) {
            }
            final List<Group> groupSeq = context.getMetaBean().getFeature(JsrFeatures.Bean.GROUP_SEQUENCE);
        return null;
        }
        if (ex instanceof ValidationException) {
            return ex; // do not wrap specific ValidationExceptions (or instances from subclasses)
        }
        String objectId;
        if (object == null) {
            objectId = "<null>";
                objectId = object.toString();
        return new ValidationException("error during validation of "  objectId, ex);
        final List<Group> defaultGroups = expandDefaultGroup(context);
        if (defaultGroups == null) {
            helper.run();
        } else {
            final Group currentGroup = context.getCurrentGroup();
        if (Collections.singletonList(Group.DEFAULT).equals(computedGroup.getGroups()) && metaBean.getFeature(JsrFeatures.Bean.GROUP_SEQUENCE) != null) {
            @SuppressWarnings("unchecked")
            final List<? extends Group> sequenceGroups = List.class.cast(metaBean.getFeature(JsrFeatures.Bean.GROUP_SEQUENCE));
            sequence.getGroups().addAll(sequenceGroups);
        if (propertyName == null || propertyName.trim().isEmpty()) {
            if (parameterValues.length == 0) {
            } else {
                checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()), ConstraintTarget.IMPLICIT);
                checkValidationAppliesTo(constructorDescriptor.getParameterDescriptors(), ConstraintTarget.IMPLICIT);
        @SuppressWarnings("unchecked")
        final GroupValidationContext<ConstraintValidationListener<?>> parametersContext =
            createInvocableContext(constructorDescriptor.getMetaBean(), rootBean,
                Class.class.cast(invocable.getDeclaringClass()), gps);
        @SuppressWarnings("unchecked")
        final GroupValidationContext<Object> crossParameterContext =
            createContext(constructorDescriptor.getMetaBean(), rootBean,
                Class.class.cast(invocable.getDeclaringClass()), gps);

        if (rootBean == null) {
        } else { // could be more sexy but that's ok for now
            final Method m = Method.class.cast(invocable);
            parametersContext.setMethod(m);
            crossParameterContext.setMethod(m);
                    ValidationHelper.validateContext(parametersContext, new JsrValidationCallback(parametersContext), factoryContext.isTreatMapsLikeBeans());
                        ValidationHelper.validateContext(parametersContext, new JsrValidationCallback(parametersContext), factoryContext.isTreatMapsLikeBeans());
                    ValidationHelper.validateContext(parametersContext, new JsrValidationCallback(parametersContext), factoryContext.isTreatMapsLikeBeans());
                        ValidationHelper.validateContext(parametersContext, new JsrValidationCallback(parametersContext), factoryContext.isTreatMapsLikeBeans());
                    ValidationHelper.validateContext(crossParameterContext, new JsrValidationCallback(crossParameterContext), factoryContext.isTreatMapsLikeBeans());
                        ValidationHelper.validateContext(crossParameterContext, new JsrValidationCallback(crossParameterContext), factoryContext.isTreatMapsLikeBeans());
        @SuppressWarnings("unchecked")
        final Set<ConstraintViolation<T>> parameterViolations = Set.class.cast(parametersContext.getListener().getConstraintViolations());
        violations.addAll(parameterViolations);
        @SuppressWarnings("unchecked")
        final Set<ConstraintViolation<T>> crossParameterViolations = Set.class.cast(crossParameterContext.getListener().getConstraintViolations());
        violations.addAll(crossParameterViolations);
        @SuppressWarnings("unchecked")
        final GroupValidationContext<T> context =
            createInvocableContext(methodDescriptor.getMetaBean(), createdObject,
                Class.class.cast(Proxies.classFor(clazz)), gps);
                ValidationHelper.validateContext(context, new JsrValidationCallback(context), factoryContext.isTreatMapsLikeBeans());
                    ValidationHelper.validateContext(context, new JsrValidationCallback(context), factoryContext.isTreatMapsLikeBeans());
        return validateInvocationParameters(method, parameterValues, methodDescriptor, groups,
            new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())), object);
        final MethodDescriptorImpl methodDescriptor = findMethodDescriptor(object, method);
        @SuppressWarnings("unchecked")
        final Set<ConstraintViolation<T>> result =
            Set.class.cast(validaReturnedValue(
                new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())), returnValue,
                object.getClass(), methodDescriptor, groups, object));
        return result;
    final List<Group> groups = new LinkedList<Group>();
    final List<List<Group>> sequences = new LinkedList<List<Group>>();
        if (providerClass == null) {
            return providerResolver.getValidationProviders().get(0);
        } 
        for (ValidationProvider<?> provider : providerResolver.getValidationProviders()) {
            if (providerClass.isAssignableFrom(provider.getClass())) {
                return provider;
        throw new ValidationException("Unable to find suitable provider: "  providerClass);
@Privilizing(@CallTo(Reflection.class))
        if (TypeUtils.isInstance(result, getType())) {
            return result;
        throw new IllegalStateException(String.format("Invalid '%s' value: %s", getAttributeName(), result));
            final boolean unset = Reflection.setAccessible(method, true);
            } finally {
                if (unset) {
                    Reflection.setAccessible(method, false);
                }
 * Description: hold the relationship annotation->validatedBy[] ConstraintValidator classes that are already parsed in a
 * cache.<br/>
        new HashMap<Class<? extends Annotation>, Class<? extends ConstraintValidator<?, ?>>[]>();
     * 
        Class<? extends ConstraintValidator<A, ?>>[] definitionClasses) {
     * 
     * @param annotationClass
     *            to look up
     * 
     * @param annotationClass
     *            to look up
        Class<A> annotationClass) {
import java.util.List;
import org.apache.commons.lang3.StringUtils;
    private static final String DEFAULT_CONSTRAINTS = "org/apache/bval/jsr/DefaultConstraints.properties";
    private Map<String, Class<? extends ConstraintValidator<?, ?>>[]> defaultConstraints;
        final Properties constraintProperties = new Properties();
        final InputStream stream = classloader.getResourceAsStream(resource);
        if (stream == null) {
            log.log(Level.WARNING, String.format("Cannot find %s", resource));
        } else {
        final Map<String, Class<? extends ConstraintValidator<?, ?>>[]> loadedConstraints =
            new HashMap<String, Class<? extends ConstraintValidator<?, ?>>[]>();

            final List<Class<?>> classes = new LinkedList<Class<?>>();
            for (String className : StringUtils.split((String) entry.getValue(), ',')) {
                    classes.add(Reflection.getClass(classloader, className.trim()));
                    log.log(Level.SEVERE, String.format("Cannot find class %s", className), e);
        final ClassLoader classloader = Thread.currentThread().getContextClassLoader();
        return classloader == null ? getClass().getClassLoader() : classloader;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;

 * Immutable, {@link Serializable} {@link ConstraintDescriptor} implementation.
 *
        if (this == o) {
            return true;
        }
        if (o == null || !getClass().equals(o.getClass())) {
            return false;
        }
        @SuppressWarnings("rawtypes")
        return new EqualsBuilder()
            .append(reportAsSingleViolation, that.reportAsSingleViolation)
            .append(annotation.annotationType(), that.annotation.annotationType())
            .append(attributes, that.attributes)
            .append(composingConstraints, that.composingConstraints)
            .append(constraintValidatorClasses, that.constraintValidatorClasses)
            .append(groups, that.groups)
            .append(payload, that.payload)
            .append(template, that.template)
            .append(validationAppliesTo, that.validationAppliesTo)
            .build();
    private int computeHashCode() {
        return new HashCodeBuilder(1, 31)
            .append(annotation.annotationType())
            .append(groups)
            .append(payload)
            .append(constraintValidatorClasses)
            .append(attributes)
            .append(composingConstraints)
            .append(reportAsSingleViolation)
            .append(validationAppliesTo)
            .append(template)
            .build();
        final Set<ConstraintValidation<?>> matchingDescriptors =
        final Groups groupChain = new GroupsComputer().computeGroups(groups);
                for (Group defaultGroupMember : metaBean.<List<Group>>getFeature(JsrFeatures.Bean.GROUP_SEQUENCE)) {
        if (scope == Scope.LOCAL_ELEMENT) {
                if (!it.next().getOwner().equals(metaBean.getBeanClass())) {
        final Set<ConstraintValidation<?>> matchingDescriptors =
         {
        }
            final boolean isOwner = descriptor.getOwner().equals(metaBean.getBeanClass());
                    case LOCAL_ELEMENT:
                        if (isOwner) {
                            return true;
                        }
                        break;
                    case HIERARCHY:
                        if (!isOwner) {
                            return true;
                        }
                        break;
        return Collections.<ConstraintDescriptor<?>> unmodifiableSet(constraintDescriptors);
import org.apache.commons.lang3.StringUtils;

        if (context.getCurrentOwner() != null && !this.owner.equals(context.getCurrentOwner())) {
            final ConstraintValidationListener<?> listener = context.getListener();
                for (Iterator<ConstraintValidation<?>> composed = getComposingValidations().iterator(); !failed
                    && composed.hasNext();) {
                addErrors(context, new ConstraintValidatorContextImpl(context, this)); // add defaultErrorMessage only
            final ConstraintValidatorContextImpl jsrContext = new ConstraintValidatorContextImpl(context, this);
    private <A extends Annotation> ConstraintValidator<A, ? super T> getConstraintValidator(A annotation,
        if (ArrayUtils.isNotEmpty(constraintClasses)) {
            final Type type = determineTargetedType(owner, access);
            if ((type.equals(Object.class) || type.equals(Object[].class)) && validatorTypes.containsKey(Object.class)
                && validatorTypes.containsKey(Object[].class)) {
                throw new ConstraintDefinitionException(
                    "Only a validator for Object or Object[] should be provided for cross-parameter validators");
        AccessStrategy access) {
        }
        if (types.size() > 1) {
            throw new UnexpectedTypeException(String.format(
                "Ambiguous validators for type %s. See: @%s at %s. Validators are: %s", stringForType(targetType), anno
                    .annotationType().getSimpleName(), stringForLocation(owner, access), StringUtils.join(types, ", ")));
            return ((Class<?>) clazz).isArray() ? ((Class<?>) clazz).getComponentType().getName()  "[]" : ((Class<?>) clazz).getName();
        return clazz.toString();
        return access == null ? owner.getName() : access.toString();
            if (TypeUtils.isAssignable(type, validatorType) && !suitableTypes.contains(validatorType)) {
        boolean removed = false;
                final Type nextType = assignableTypes.get(i);
        final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validatorsTypes =
            new HashMap<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>>();
            Type validatedType =
                TypeUtils.getTypeArguments(validatorType, ConstraintValidator.class).get(
                    ConstraintValidator.class.getTypeParameters()[1]);
                final Type componentType = TypeUtils.getArrayComponentType(validatedType);
        if (access == null) {
        }
        final Type type = access.getJavaType();
        if (type == null) {
        }
        return type instanceof Class<?> ? ClassUtils.primitiveToWrapper((Class<?>) type) : type;
                context.getRootMetaBean().getBeanClass(), beanPath, access.getElementType())) {
            }
        return composedConstraints == null ? Collections.<ConstraintValidation<?>> emptySet() : composedConstraints;
        return validatorClasses == null ? Collections.<Class<? extends ConstraintValidator<T, ?>>> emptyList() : Arrays.asList(validatorClasses);
import javax.validation.Payload;
import javax.validation.Valid;
import javax.validation.ValidationException;
import javax.validation.groups.ConvertGroup;
            Reflection.setAccessible(constructor, true); // java 8
            return !annotatedType.getJavaClass().getName().startsWith("org.apache.bval.");
            } catch (final Exception e) { // just info
                LOGGER.log(Level.INFO, e.getMessage());
import javax.enterprise.inject.spi.WithAnnotations;
    // @WithAnnotations(ValidateOnExecution.class) doesn't check interfaces so not enough
import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import javax.enterprise.inject.spi.AnnotatedConstructor;
import javax.enterprise.inject.spi.AnnotatedMethod;
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.CDI;
import static java.util.Arrays.asList;
public class BValInterceptor implements Serializable {
    private transient volatile Map<Method, Boolean> methodConfiguration = new ConcurrentHashMap<Method, Boolean>();
    private transient volatile Set<ExecutableType> classConfiguration;
    private transient volatile Boolean constructorValidated;
    private transient volatile ExecutableValidator executableValidator;
    @AroundConstruct // TODO: see previous one
                    final AnnotatedType<?> annotatedType = CDI.current().getBeanManager().createAnnotatedType(constructor.getDeclaringClass());
                    AnnotatedConstructor<?> annotatedConstructor = null;
                    for (final AnnotatedConstructor<?> ac : annotatedType.getConstructors()) {
                        if (!constructor.equals(ac.getJavaMember())) {
                            continue;
                        }
                        annotatedConstructor = ac;
                        break;
                    }
                    final ValidateOnExecution annotation = annotatedConstructor != null ?
                            annotatedConstructor.getAnnotation(ValidateOnExecution.class) :
                            targetClass.getConstructor(constructor.getParameterTypes()).getAnnotation(ValidateOnExecution.class);
        return constructorValidated;
        if (methodConfiguration == null) {
            synchronized (this) {
                if (methodConfiguration == null) {
                    methodConfiguration = new ConcurrentHashMap<Method, Boolean>();
                }
            }
        }

                            ClassHelper.fillFullClassHierarchyAsList(new LinkedList<Class<?>>(), targetClass);
                    Collections.reverse(classHierarchy);
                    ValidateOnExecution validateOnExecutionType = null;
                        final AnnotatedType<?> annotatedType = CDI.current().getBeanManager().createAnnotatedType(c);
                        AnnotatedMethod<?> annotatedMethod = null;
                        for (final AnnotatedMethod<?> m : annotatedType.getMethods()) {
                            if (!m.getJavaMember().getName().equals(method.getName())
                                    || !asList(method.getGenericParameterTypes()).equals(asList(m.getJavaMember().getGenericParameterTypes()))) {
                                continue;
                            annotatedMethod = m;
                            break;
                        }
                        try {
                            if (annotatedMethod == null) {
                                continue;
                            }
                            if (validateOnExecutionType == null) {
                                final ValidateOnExecution vat = annotatedType.getAnnotation(ValidateOnExecution.class);
                                if (vat != null) {
                                    validateOnExecutionType = vat;
                                }
                            }
                            final ValidateOnExecution mvat = annotatedMethod.getAnnotation(ValidateOnExecution.class);
                            if (mvat != null) {
                                validateOnExecution = mvat;
                    boolean classMeta = false;
                    if (validateOnExecution == null) {
                        validateOnExecution = validateOnExecutionType;
                        classMeta = validateOnExecution != null;
                                if (!classMeta) {
                    final AnnotatedType<?> annotatedType = CDI.current().getBeanManager().createAnnotatedType(targetClass);
                    final ValidateOnExecution annotation = annotatedType.getAnnotation(ValidateOnExecution.class);
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
            return getPropertyValue(new PropertyAccess(bean.getClass(), metaProperty.getName()));
        return getPropertyValue(access);
    public Object getPropertyValue(AccessStrategy access) throws IllegalArgumentException, IllegalStateException {
        return "BeanValidationContext{ bean="  bean  ", metaProperty="  metaProperty  ", propertyValue="
             propertyValue  '}';
    public void moveDown(String prop) {
        // no-op: not supported
    }

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Collection;

                        if (context == null) {
                        }
            return context == null ? null : context.getListener();
        if (validate.value().isEmpty()) {
            if (parameter == null) {
            }
            if (parameter instanceof Collection<?>) { // do not validate empty collection
                if (coll.isEmpty()) {
                }
                beanClass = coll.iterator().next().getClass(); // get first object
        if (access == null && prop.getMetaBean() != null) { // single property access strategy
        return bean instanceof Class<?> ? finder.findForClass((Class<?>) bean) : finder.findForClass(bean.getClass());
import static org.apache.bval.model.Features.Property.HIDDEN;
import static org.apache.bval.model.Features.Property.PREFERRED;
import static org.apache.bval.model.Features.Property.READONLY;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.bval.model.MetaBean;

        if (beanInfo.getBeanClass() != null && beanInfo.getId().equals(beanInfo.getBeanClass().getName())) {
        if (beanInfo.getBeanClass() != null && beanInfo.getId().equals(beanInfo.getBeanClass().getName())) {
import static org.apache.bval.model.Features.Property.REF_BEAN_ID;
import static org.apache.bval.model.Features.Property.REF_BEAN_TYPE;
import static org.apache.bval.model.Features.Property.REF_CASCADE;
     * @param builder meta bean builder
    public MetaBean findForId(final String beanInfoId) {
        if (beanInfo != null) {
        }

        } catch (final RuntimeException e) {
        } catch (final Exception e) {
    public MetaBean findForClass(final Class<?> clazz) {
        if (clazz == null) {
        }

        if (beanInfo != null) {
        }

        } catch (final RuntimeException e) {
        } catch (final Exception e) {
        for (final MetaProperty prop : beanInfo.getProperties()) {
            final String beanRef = prop.getFeature(REF_BEAN_ID);
     * @param prop meta property
     * @param beanRef bean reference
        if (beanType == null) {
            if (prop.getFeature(REF_CASCADE) != null) { // dynamic type resolution:
                prop.setMetaBean(new DynamicMetaBean(this));
            }
        } else {
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
        if (error.getReason() == null) {
            return;
        }
        if (error.getOwner() == null) {
            return;
        }
        if (errorsByReason == null) {
            return Collections.emptyMap();
        }
        if (errorsByOwner == null) {
            return Collections.emptyMap();
        }
        if (errorsByReason == null || (errorsByReason.isEmpty() && errorsByOwner.isEmpty())) {
            return true;
        }
            if (!list.isEmpty()) {
                return false;
            }
                if (!list.isEmpty()) {
                    return false;
                }
        if (errorsByReason == null) {
            return false;
        }
        if (errorsByOwner == null) {
            return false;
        }
        if (errors == null) {
            return false;
        }
        if (propertyName == null) {
                if (!list.isEmpty()) {
                    return true;
                }
        List<Error> list = errors.get(propertyName);
        return list != null && !list.isEmpty();

        String EXECUTABLES = "executables";
        String PROPERTIES = "properties";
import org.apache.commons.lang3.ArrayUtils;

        final T value = (T) features.get(key);
        if (value == null) {
            return defaultValue;
        return value;
     *
    public <T> void putFeature(final String key, final T value) {
        features.put(key, value);
    }

    public <T> T initFeature(final String key, final T value) {
        @SuppressWarnings("unchecked")
        final T faster = (T) features.putIfAbsent(key, value);
        return faster == null ? value : faster;
        if (validations == null) {
        }
            if (validation.equals(aValidation)) {
            }
 b/bval-core/src/main/java/org/apache/bval/model/Meta.java
package org.apache.bval.model;
public abstract class Meta extends FeaturesCapable {
    private static final long serialVersionUID = 1L;

    protected MetaBean parentMetaBean;

    public MetaBean getParentMetaBean() {
        return parentMetaBean;
    }
 b/bval-core/src/main/java/org/apache/bval/model/MetaAnnotated.java
package org.apache.bval.model;
import org.apache.commons.lang3.ArrayUtils;

public abstract class MetaAnnotated extends Meta {
    private static final long serialVersionUID = 1L;

    private Annotation[] annotations = new Annotation[0];

    public Annotation[] getAnnotations() {
        return annotations;
    }

    public void addAnnotation(final Annotation annotation) {
        this.annotations = ArrayUtils.add(annotations, annotation);
    }

import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

import java.beans.Introspector;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
@Privilizing(@CallTo(Reflection.class))

    private Map<String, MetaProperty> properties = null;
    private Map<Method, MetaMethod> methods = null;
    private Map<Constructor<?>, MetaConstructor> constructors = null;
     * @return Class
        if (beanClass != null) {
            // order of fields to ensure correct failling order
            final Map<String, MetaProperty> oldProperties = properties;
            final Map<Method, MetaMethod> oldMethods = methods;
            final Map<Constructor<?>, MetaConstructor> oldConstructors = constructors;

            properties = new TreeMap<String, MetaProperty>(new FieldComparator(beanClass));
            if (oldProperties != null) {
                properties.putAll(oldProperties);
            }
            methods = new TreeMap<Method, MetaMethod>(new MethodComparator(beanClass));
            if (oldMethods != null) {
                methods.putAll(oldMethods);
            }
            constructors = new TreeMap<Constructor<?>, MetaConstructor>(new ConstructorComparator(beanClass));
            if (oldConstructors != null) {
                constructors.putAll(oldConstructors);
            }
        }
        if (properties == null) {
            return new MetaProperty[0];
        }
    public MetaMethod[] getMethods() {
        if (methods == null) {
            return new MetaMethod[0];
        }
        return methods.values().toArray(new MetaMethod[this.methods.size()]);
    }

    public void addMethod(final Method method, final MetaMethod meta) {
        if (methods == null) {
            methods = new HashMap<Method, MetaMethod>();
        }
        methods.put(method, meta);
    }

    public void addConstructor(final Constructor<?> constructor, final MetaConstructor meta) {
        if (constructors == null) {
            constructors = new HashMap<Constructor<?>, MetaConstructor>();
        }
        constructors.put(constructor, meta);
    }

        this.properties = new HashMap<String, MetaProperty>();
        for (final MetaProperty property : properties) {
     * @param name property name
        if (properties == null) {
            return null;
        }
        if (properties == null) {
            return false;
        }
     * @param name property name
        if (properties == null) {
            properties = new HashMap<String, MetaProperty>();
        }
     * @param bean instance
    public MetaMethod getMethod(final Method method) {
        return methods == null ? null : methods.get(method);
    }

    public MetaConstructor getConstructor(final Constructor<?> constructor) {
        return constructors == null ? null : constructors.get(constructor);
    }

    protected static class FieldComparator implements Comparator<String> {
        private final Map<String, Integer> fields = new HashMap<String, Integer>();

        protected FieldComparator(final Class<?> beanClass) {
            int i = 0;
            Class<?> clazz = beanClass;
            while (clazz != null && clazz != Object.class) {
                for (final Field f : Reflection.getDeclaredFields(clazz)) {
                    i;
                    final String name = f.getName();
                    if (!fields.containsKey(name)) {
                        fields.put(name, i);
                    }
                }
                for (final Method m : clazz.getDeclaredMethods()) {
                    if (m.getName().startsWith("get") && Void.TYPE != m.getReturnType() && m.getParameterTypes().length == 0) {
                        final String name = Introspector.decapitalize(m.getName().substring("get".length()));
                        if (!name.isEmpty()) {
                            i;
                            if (!fields.containsKey(name)) {
                                fields.put(name, i);
                            }
                        }
                    }
                }
                clazz = clazz.getSuperclass();
            }
        }

        public int compare(final String o1, final String o2) {
            return fieldIndex(o1) - fieldIndex(o2);
        }

        private int fieldIndex(final String o2) {
            final Integer idx = fields.get(o2);
            if (idx == null) {
                return Integer.MIN_VALUE; // to avoid collision and false positive in get() due to equals
            }
            return idx;
        }
    }

    protected static class MethodComparator implements Comparator<Method> {
        private final Map<Method, Integer> methods = new HashMap<Method, Integer>();

        protected MethodComparator(final Class<?> beanClass) {
            Class<?> clazz = beanClass;
            while (clazz != null && clazz != Object.class) {
                for (final Method m : Reflection.getDeclaredMethods(clazz)) {
                    methods.put(m, Arrays.hashCode(m.getParameterTypes()));
                }
                clazz = clazz.getSuperclass();
            }
        }

        public int compare(final Method o1, final Method o2) {
            if (o1 == o2) {
                return 0;
            }

            final int i = o1.getName().compareTo(o2.getName());
            return i == 0 ? methods.get(o1) - methods.get(o2) : i;
        }
    }

    protected static class ConstructorComparator implements Comparator<Constructor<?>> {
        private final Map<Constructor<?>, Integer> constructors = new HashMap<Constructor<?>, Integer>();

        protected ConstructorComparator(final Class<?> beanClass) {
            for (final Constructor<?> c : Reflection.getDeclaredConstructors(beanClass)) {
                constructors.put(c, Arrays.hashCode(c.getParameterTypes()));
            }
        }

        public int compare(final Constructor<?> o1, final Constructor<?> o2) {
            if (o1 == o2) {
                return 0;
            }

            final int i = o1.getName().compareTo(o2.getName());
            return i == 0 ? constructors.get(o1) - constructors.get(o2) : i;
        }
    }
 b/bval-core/src/main/java/org/apache/bval/model/MetaConstructor.java
package org.apache.bval.model;
import java.lang.reflect.Constructor;
public class MetaConstructor extends MetaInvocable {
    private static final long serialVersionUID = 1L;

    private final Constructor<?> constructor;

    public MetaConstructor(final MetaBean metabean, final Constructor<?> constructor) {
        this.parentMetaBean = metabean;
        this.constructor = constructor;
    }

    public Constructor<?> getConstructor() {
        return constructor;
    }
 b/bval-core/src/main/java/org/apache/bval/model/MetaMethod.java
package org.apache.bval.model;
import java.lang.reflect.Method;
public class MetaMethod extends MetaInvocable {
    private static final long serialVersionUID = 1L;

    private final Method method;

    public MetaMethod(final MetaBean parent, final Method method) {
        this.parentMetaBean = parent;
        this.method = method;
    }

    public Method getMethod() {
        return method;
    }
import java.lang.reflect.Type;

public class MetaProperty extends Meta implements Cloneable, Features.Property {
        Type targetType = type instanceof DynaType ? ((DynaType) type).getRawType() : type;
        Type assigningType = getParentMetaBean() == null ? null : getParentMetaBean().getBeanClass();
    void moveDown(String prop);

     * Error notification added from a {@link org.apache.bval.model.Validation} with context information
     * taken from the given {@link org.apache.bval.model.ValidationContext}.
        if (value == null) {
        }
        if (!(value instanceof CharSequence)) {
        }
        if (seq.length() == 0) {
        }
        return aPattern.matcher(seq).matches();

import java.io.InputStream;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
            InputStream in = BValVersion.class.getResourceAsStream("/META-INF/org.apache.bval.revision.properties");
        if (StringUtils.isBlank(revision)) {
            if (strTok != null) {
            }
        final StringBuilder buf = new StringBuilder(80 * 40);
        final StringTokenizer tok = new StringTokenizer(Reflection.getProperty("java.class.path"));
        return buf.append(prop).append(": ").append(Reflection.getProperty(prop));

import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
        final boolean mustUnset = Reflection.setAccessible(field, true);
        } finally {
            if (mustUnset) {
                Reflection.setAccessible(field, false);
            }
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.reflect.TypeUtils;

 */ 
            return ObjectUtils.defaultIfNull(TypeUtils.unrollVariables(typeArguments, ITERABLE_TYPE), Object.class);
    private final Type containerType;
    private final Integer index;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.reflect.TypeUtils;

            return ObjectUtils.defaultIfNull(TypeUtils.unrollVariables(typeArguments, MAP_TYPEVARS[1]), Object.class);
    private final Type containerType;
    private final Object key;
            Type keyType = TypeUtils.unrollVariables(typeArguments, MAP_TYPEVARS[0]);
        final Type result = getJavaElementType(containerType);

import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
        final String methodName = member.getName();
            return Introspector.decapitalize(methodName.substring(2));
        if (methodName.startsWith("get")) {
            return Introspector.decapitalize(methodName.substring(3));
        }
        return null;
        final boolean mustUnset = Reflection.setAccessible(method, true);
        } finally {
            if (mustUnset) {
                Reflection.setAccessible(method, false);
            }
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
import org.apache.bval.util.reflection.Reflection;
    private static Object readField(Field field, Object bean) throws IllegalAccessException {
        final boolean mustUnset = Reflection.setAccessible(field, true);
        try {
            return field.get(bean);
        } finally {
            if (mustUnset) {
                Reflection.setAccessible(field, false);
            }
        }
    }

                return readField(rememberField, bean);
            return readField(rememberField, bean);
        if (this == o) {
        }
        if (o == null || getClass() != o.getClass()) {
        }
import java.util.List;
import java.util.Map;

                if (dyn == null) {
                } else {
                    context.setBean(each, dyn.resolveMetaBean(each));
                if (dyn == null) {
                } else {
                    context.setBean(each, dyn.resolveMetaBean(each));
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.Character.getNumericValue;

import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Annotation;

import static java.lang.Character.getNumericValue;
import static java.lang.Character.isDigit;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.Character.getNumericValue;

import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.io.File;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.io.File;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.io.File;
import java.io.IOException;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import static java.util.Arrays.asList;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.util.regex.Pattern;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import org.apache.bval.model.MetaBean;

 b/bval-jsr/src/main/java/org/apache/bval/cdi/AnyLiteral.java
package org.apache.bval.cdi;
import javax.enterprise.inject.Any;
import javax.enterprise.util.AnnotationLiteral;
public class AnyLiteral extends AnnotationLiteral<Any> implements Any {
    private static final long serialVersionUID = 1L;

     * Statically available instance.
    public static final AnyLiteral INSTANCE = new AnyLiteral();

    @Override
    public String toString() {
        return "@javax.enterprise.inject.Any()";
    }
 b/bval-jsr/src/main/java/org/apache/bval/cdi/BValBinding.java
package org.apache.bval.cdi;

import javax.interceptor.InterceptorBinding;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
 * Custom {@link InterceptorBinding} to invoke executable validations on CDI beans.
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
@InterceptorBinding
public @interface BValBinding {
 b/bval-jsr/src/main/java/org/apache/bval/cdi/DefaultLiteral.java
package org.apache.bval.cdi;
import javax.enterprise.inject.Default;
import javax.enterprise.util.AnnotationLiteral;

public class DefaultLiteral extends AnnotationLiteral<Default> implements Default {
    private static final long serialVersionUID = 1L;

    public static final DefaultLiteral INSTANCE = new DefaultLiteral();

    @Override
    public String toString() {
        return "@javax.enterprise.inject.Default()";
    }
 b/bval-jsr/src/main/java/org/apache/bval/constraints/AssertFalseValidator.java
        return value == null || Boolean.FALSE.equals(value);
 b/bval-jsr/src/main/java/org/apache/bval/constraints/AssertTrueValidator.java
        return value == null || Boolean.TRUE.equals(value);
 b/bval-jsr/src/main/java/org/apache/bval/constraints/DecimalMaxValidatorForNumber.java
public class DecimalMaxValidatorForNumber implements ConstraintValidator<DecimalMax, Number> {
            throw new IllegalArgumentException(annotation.value()  " does not represent a valid BigDecimal format");
        if (value instanceof BigDecimal) {
            return ((BigDecimal) value).compareTo(maxValue) != 1;
        }
        if (value instanceof BigInteger) {
            return (new BigDecimal((BigInteger) value)).compareTo(maxValue) != 1;
        }
        return (new BigDecimal(value.doubleValue()).compareTo(maxValue)) != 1;
 b/bval-jsr/src/main/java/org/apache/bval/constraints/DecimalMaxValidatorForString.java
public class DecimalMaxValidatorForString implements ConstraintValidator<DecimalMax, String> {
            throw new IllegalArgumentException(annotation.value()  " does not represent a valid BigDecimal format");
 b/bval-jsr/src/main/java/org/apache/bval/constraints/DecimalMinValidatorForNumber.java
public class DecimalMinValidatorForNumber implements ConstraintValidator<DecimalMin, Number> {
            throw new IllegalArgumentException(annotation.value()  " does not represent a valid BigDecimal format");
        if (value instanceof BigDecimal) {
            return ((BigDecimal) value).compareTo(minValue) != -1;
        }
        if (value instanceof BigInteger) {
            return (new BigDecimal((BigInteger) value)).compareTo(minValue) != -1;
        }
        return (new BigDecimal(value.doubleValue()).compareTo(minValue)) != -1;
 b/bval-jsr/src/main/java/org/apache/bval/constraints/DecimalMinValidatorForString.java
public class DecimalMinValidatorForString implements ConstraintValidator<DecimalMin, String> {
            throw new IllegalArgumentException(annotation.value()  " does not represent a valid BigDecimal format");
 b/bval-jsr/src/main/java/org/apache/bval/constraints/DigitsValidatorForNumber.java
            throw new IllegalArgumentException("The length of the integer part cannot be negative.");
            throw new IllegalArgumentException("The length of the fraction part cannot be negative.");
        final int intLength = bigDecimal.precision() - bigDecimal.scale();
        return false;
 b/bval-jsr/src/main/java/org/apache/bval/constraints/DigitsValidatorForString.java
            throw new IllegalArgumentException("The length of the integer part cannot be negative.");
            throw new IllegalArgumentException("The length of the fraction part cannot be negative.");
        final BigDecimal bigDecimal = getBigDecimalValue(str);
        return false;
            return new BigDecimal(str);
 b/bval-jsr/src/main/java/org/apache/bval/constraints/Email.java
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
 b/bval-jsr/src/main/java/org/apache/bval/constraints/MaxValidatorForNumber.java
        if (value instanceof BigDecimal) {
            return ((BigDecimal) value).compareTo(BigDecimal.valueOf(max)) != 1;
        }
        if (value instanceof BigInteger) {
            return ((BigInteger) value).compareTo(BigInteger.valueOf(max)) != 1;
        }
        return value.longValue() <= max;
 b/bval-jsr/src/main/java/org/apache/bval/constraints/MinValidatorForNumber.java
        if (value instanceof BigDecimal) {
            return ((BigDecimal) value).compareTo(BigDecimal.valueOf(minValue)) != -1;
        }
        if (value instanceof BigInteger) {
            return ((BigInteger) value).compareTo(BigInteger.valueOf(minValue)) != -1;
        }
        return value.longValue() >= minValue;
 b/bval-jsr/src/main/java/org/apache/bval/constraints/NotEmpty.java
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
 b/bval-jsr/src/main/java/org/apache/bval/constraints/NotEmptyValidator.java
        if (value == null) {
            return true;
        }
        try {
            final Method isEmptyMethod = value.getClass().getMethod("isEmpty");
            if (isEmptyMethod != null) {
                return !((Boolean) isEmptyMethod.invoke(value)).booleanValue();
            }
        } catch (IllegalAccessException iae) {
            // do nothing
        } catch (NoSuchMethodException nsme) {
            // do nothing
        } catch (InvocationTargetException ite) {
            // do nothing
        }
        return !value.toString().isEmpty();
 b/bval-jsr/src/main/java/org/apache/bval/constraints/NotEmptyValidatorForString.java
        return value == null || !value.isEmpty();
 b/bval-jsr/src/main/java/org/apache/bval/constraints/PatternValidator.java
 * based on the jsr Pattern constraint annotation.
        final Pattern.Flag flags[] = annotation.flags();
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidator.java
        if (min < 0) {
            throw new ValidationException("Min cannot be negative");
        }
        if (max < 0) {
            throw new ValidationException("Max cannot be negative");
        }
        if (max < min) {
            throw new ValidationException("Max cannot be less than Min");
        }
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfBoolean.java
public class SizeValidatorForArrayOfBoolean extends SizeValidator implements ConstraintValidator<Size, boolean[]> {
        final int length = Array.getLength(array);
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfByte.java
public class SizeValidatorForArrayOfByte extends SizeValidator implements ConstraintValidator<Size, byte[]> {
        final int length = Array.getLength(array);
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfChar.java
public class SizeValidatorForArrayOfChar extends SizeValidator implements ConstraintValidator<Size, char[]> {
        final int length = Array.getLength(array);
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfDouble.java
public class SizeValidatorForArrayOfDouble extends SizeValidator implements ConstraintValidator<Size, double[]> {
        final int length = Array.getLength(array);
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfFloat.java
public class SizeValidatorForArrayOfFloat extends SizeValidator implements ConstraintValidator<Size, float[]> {
        final int length = Array.getLength(array);
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfInt.java
public class SizeValidatorForArrayOfInt extends SizeValidator implements ConstraintValidator<Size, int[]> {
        final int length = Array.getLength(array);
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfLong.java
public class SizeValidatorForArrayOfLong extends SizeValidator implements ConstraintValidator<Size, long[]> {
        final int length = Array.getLength(array);
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfObject.java
public class SizeValidatorForArrayOfObject extends SizeValidator implements ConstraintValidator<Size, Object[]> {
        final int length = Array.getLength(array);
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidatorForArrayOfShort.java
public class SizeValidatorForArrayOfShort extends SizeValidator implements ConstraintValidator<Size, short[]> {
        final int length = Array.getLength(array);
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidatorForCharSequence.java
public class SizeValidatorForCharSequence extends SizeValidator implements ConstraintValidator<Size, CharSequence> {
    public boolean isValid(CharSequence s, ConstraintValidatorContext context) {
        final int length = s.length();
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidatorForCollection.java
public class SizeValidatorForCollection extends SizeValidator implements ConstraintValidator<Size, Collection<?>> {
        final int length = collection.size();
 b/bval-jsr/src/main/java/org/apache/bval/constraints/SizeValidatorForMap.java
public class SizeValidatorForMap extends SizeValidator implements ConstraintValidator<Size, Map<?, ?>> {
        final int size = map.size();
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ApacheFactoryContext.java
package org.apache.bval.jsr;
import javax.validation.ParameterNameProvider;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privileged;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
    private ParameterNameProvider parameterNameProvider;
     * @param factory validator factory
     * @param factory validator factory
     * @param metaBeanFinder meta finder
    public ValidatorContext parameterNameProvider(ParameterNameProvider parameterNameProvider) {
        this.parameterNameProvider = parameterNameProvider;
        return this;
    }

        return new ClassValidator(this);
    public ParameterNameProvider getParameterNameProvider() {
        return parameterNameProvider == null ? factory.getParameterNameProvider() : parameterNameProvider;
    }

    boolean isTreatMapsLikeBeans() {
        return Boolean.parseBoolean(factory.getProperties().get(
            ApacheValidatorConfiguration.Properties.TREAT_MAPS_LIKE_BEANS));
    }

     * <li>if no {@link JsrMetaBeanFactory} has yet been specified (this
     * allows factory order customization), a {@link JsrMetaBeanFactory}
        final List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>();
        final String[] factoryClassNames =
            StringUtils.split(factory.getProperties().get(
                ApacheValidatorConfiguration.Properties.METABEAN_FACTORY_CLASSNAMES));
                final Class<? extends MetaBeanFactory> factoryClass = (Class<? extends MetaBeanFactory>) loadClass(clsName);
        boolean jsrFound = false;
            jsrFound |= builder instanceof JsrMetaBeanFactory;
        if (!jsrFound) {
            builders.add(new JsrMetaBeanFactory(this));
        final boolean enableMetaBeansXml =
            Boolean.parseBoolean(factory.getProperties().get(
                ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML));
        // as long as we support both: jsr (in the builders list) and xstream-xml metabeans:
    @Privileged
        try {
            Constructor<F> c = ConstructorUtils.getMatchingAccessibleConstructor(cls, ApacheFactoryContext.this.getClass());
            if (c != null) {
                return c.newInstance(ApacheFactoryContext.this);
            c = ConstructorUtils.getMatchingAccessibleConstructor(cls, getFactory().getClass());
            if (c != null) {
                return c.newInstance(getFactory());
            }
            return cls.newInstance();
        } catch (Exception e) {
            throw new ValidationException(e);
        }
         * @param builders meta bean builders
            return Class.forName(className, true, Reflection.getClassLoader(ApacheFactoryContext.class));
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ApacheValidationProvider.java
package org.apache.bval.jsr;
 * Description: Implementation of {@link ValidationProvider} for jsr
            final String validatorFactoryClassname =
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ApacheValidatorConfiguration.java
package org.apache.bval.jsr;
public interface ApacheValidatorConfiguration extends Configuration<ApacheValidatorConfiguration> {
         * we keep it as long as we support both: jsr and xstream-xml meta data at
         * - true (validate maps like beans, so that
         *     you can use Maps to validate dynamic classes or
         *     beans for which you have the MetaBean but no instances)
         * - false (default), validate maps like collections
         *     (validating the values only)
        String VALIDATOR_FACTORY_CLASSNAME = "apache.bval.validator-factory-classname";
        String METABEAN_FACTORY_CLASSNAMES = "apache.bval.metabean-factory-classnames";
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ApacheValidatorFactory.java
package org.apache.bval.jsr;
import org.apache.bval.jsr.xml.AnnotationIgnores;
import org.apache.bval.jsr.xml.MetaConstraint;
import org.apache.bval.jsr.xml.ValidationMappingParser;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
import javax.validation.ParameterNameProvider;
import java.io.Closeable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
@Privilizing(@CallTo(Reflection.class))
    private static final ConstraintDefaults DEFAULT_CONSTRAINTS = new ConstraintDefaults();
    private ParameterNameProvider parameterNameProvider;
    private final ConcurrentMap<Class<?>, List<AccessStrategy>> validAccesses;
    private final ConcurrentMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>> constraintMap;

    private final Collection<Closeable> toClose = new ArrayList<Closeable>();
    public static ApacheValidatorFactory getDefault() {
            synchronized (ApacheValidatorFactory.class) {
                if (DEFAULT_FACTORY == null) {
                    DEFAULT_FACTORY = Validation.byProvider(ApacheValidationProvider.class).configure()
                        .buildValidatorFactory().unwrap(ApacheValidatorFactory.class);
                }
            }
        validAccesses = new ConcurrentHashMap<Class<?>, List<AccessStrategy>>();
        constraintMap = new ConcurrentHashMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>>();
    protected void configure(final ConfigurationState configuration) {

        parameterNameProvider = configuration.getParameterNameProvider();
        messageResolver = configuration.getMessageInterpolator();
        traversableResolver = configuration.getTraversableResolver();
        constraintValidatorFactory = configuration.getConstraintValidatorFactory();

        if (ConfigurationImpl.class.isInstance(configuration)) {
            final ConfigurationImpl impl = ConfigurationImpl.class.cast(configuration);
            toClose.add(impl.getClosable());
        }

        new ValidationMappingParser(this).processMappingConfig(configuration.getMappingStreams());
        if (messageResolver != null) {
            this.messageResolver = messageResolver;
        }
        if (traversableResolver != null) {
            this.traversableResolver = traversableResolver;
        }
    }

    public void setParameterNameProvider(final ParameterNameProvider parameterNameProvider) {
        if (parameterNameProvider != null) {
            this.parameterNameProvider = parameterNameProvider;
        }
        if (constraintValidatorFactory != null) {
            this.constraintValidatorFactory = constraintValidatorFactory;
            if (DefaultConstraintValidatorFactory.class.isInstance(constraintValidatorFactory)) {
                toClose.add(Closeable.class.cast(constraintValidatorFactory));
            }
        }
    public ParameterNameProvider getParameterNameProvider() {
        return parameterNameProvider;
    }

    public void close() {
        try {
            for (final Closeable c : toClose) {
                c.close();
            }
            toClose.clear();
        } catch (final Exception e) {
            // no-op
        }
    }

            final T result = (T) this;
            final Class<?> cls = ClassUtils.getClass(type.getName()  "Impl");
        try {
            return Reflection.newInstance(cls);
        } catch (final RuntimeException e) {
            throw new ValidationException(e.getCause());
        }
        return DEFAULT_CONSTRAINTS;
    public void addMetaConstraint(final Class<?> beanClass,
                                  final MetaConstraint<?, ?> metaConstraint) {
        List<MetaConstraint<?, ? extends Annotation>> slot = constraintMap.get(beanClass);
        if (slot == null) {
            slot = new ArrayList<MetaConstraint<?, ? extends Annotation>>();
            final List<MetaConstraint<?, ? extends Annotation>> old = constraintMap.putIfAbsent(beanClass, slot);
            if (old != null) {
                slot = old;
        List<AccessStrategy> slot = validAccesses.get(beanClass);
        if (slot == null) {
            slot = new ArrayList<AccessStrategy>();
            final List<AccessStrategy> old = validAccesses.putIfAbsent(beanClass, slot);
            if (old != null) {
                slot = old;
 b/bval-jsr/src/main/java/org/apache/bval/jsr/AppendValidation.java
package org.apache.bval.jsr;
 b/bval-jsr/src/main/java/org/apache/bval/jsr/AppendValidationToBuilder.java
package org.apache.bval.jsr;
import org.apache.bval.jsr.xml.AnnotationProxyBuilder;
        final Set<Class<?>> inheritedGroups = builder.getConstraintValidation().getGroups();
        final Set<Class<? extends Payload>> inheritedPayload = builder.getConstraintValidation().getPayload();
        final T originalAnnot = validation.getAnnotation();
        final AnnotationProxyBuilder<T> apb = new AnnotationProxyBuilder<T>(originalAnnot);
        final T newAnnot = apb.createAnnotation();
 b/bval-jsr/src/main/java/org/apache/bval/jsr/AppendValidationToList.java
package org.apache.bval.jsr;
 * Description: {@link org.apache.bval.jsr.AppendValidation} implementation that acts as an intermediate
     * @return {@link java.util.List} of {@link org.apache.bval.jsr.ConstraintValidation}
 b/bval-jsr/src/main/java/org/apache/bval/jsr/AppendValidationToMeta.java
package org.apache.bval.jsr;
 b/bval-jsr/src/main/java/org/apache/bval/jsr/BaseAppendValidation.java
package org.apache.bval.jsr;
    public final <T extends Annotation> void append(final ConstraintValidation<T> validation) {
    public abstract <T extends Annotation> void performAppend(final ConstraintValidation<T> validation);
    public <T extends Annotation> void preProcessValidation(final ConstraintValidation<T> validation) {

     * Post-process the validation once it postProcessValidationhas been appended.
    public <T extends Annotation> void postProcessValidation(final ConstraintValidation<T> validation) {

 b/bval-jsr/src/main/java/org/apache/bval/jsr/CascadingPropertyValidator.java
package org.apache.bval.jsr;
import java.util.Set;
    <T extends Object> Set<javax.validation.ConstraintViolation<T>> validateProperty(T object, String propertyName,
        boolean cascade, Class<?>... groups);
    <T extends Object> Set<javax.validation.ConstraintViolation<T>> validateValue(Class<T> beanType,
        String propertyName, Object value, boolean cascade, Class<?>... groups);
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ConstraintCached.java
package org.apache.bval.jsr;
 * Description: hold the relationship annotation->validatedBy[] ConstraintValidator classes that are already parsed in a
 * cache.<br/>
        new HashMap<Class<? extends Annotation>, Class<? extends ConstraintValidator<?, ?>>[]>();
     * 
        Class<? extends ConstraintValidator<A, ?>>[] definitionClasses) {
     * 
     * @param annotationClass
     *            to look up
     * 
     * @param annotationClass
     *            to look up
        Class<A> annotationClass) {
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ConstraintDescriptorImpl.java
package org.apache.bval.jsr;
import javax.validation.ConstraintTarget;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;

 * Immutable, {@link Serializable} {@link ConstraintDescriptor} implementation.
 *
    private final ConstraintTarget validationAppliesTo;
    private final String template;
    private final int hashCode;
    public ConstraintDescriptorImpl(final ConstraintDescriptor<T> descriptor) {
            descriptor.isReportAsSingleViolation(), descriptor.getValidationAppliesTo(), descriptor.getMessageTemplate());
        boolean reportAsSingleViolation, ConstraintTarget validationAppliesTo, String messageTemplate) {
        this.validationAppliesTo = validationAppliesTo;
        this.template = messageTemplate;
        this.hashCode = computeHashCode();
    public String getMessageTemplate() {
        return template;
    }

    public ConstraintTarget getValidationAppliesTo() {
        return validationAppliesTo;
    }


    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || !getClass().equals(o.getClass())) {
            return false;
        }

        @SuppressWarnings("rawtypes")
        final ConstraintDescriptorImpl that = (ConstraintDescriptorImpl) o;

        return new EqualsBuilder()
            .append(reportAsSingleViolation, that.reportAsSingleViolation)
            .append(annotation.annotationType(), that.annotation.annotationType())
            .append(attributes, that.attributes)
            .append(composingConstraints, that.composingConstraints)
            .append(constraintValidatorClasses, that.constraintValidatorClasses)
            .append(groups, that.groups)
            .append(payload, that.payload)
            .append(template, that.template)
            .append(validationAppliesTo, that.validationAppliesTo)
            .build();
    }

    @Override
    public int hashCode() {
        return hashCode;
    }

    private int computeHashCode() {
        return new HashCodeBuilder(1, 31)
            .append(annotation.annotationType())
            .append(groups)
            .append(payload)
            .append(constraintValidatorClasses)
            .append(attributes)
            .append(composingConstraints)
            .append(reportAsSingleViolation)
            .append(validationAppliesTo)
            .append(template)
            .build();
    }
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ConstraintFinderImpl.java
package org.apache.bval.jsr;
import org.apache.bval.jsr.groups.Group;
import org.apache.bval.jsr.groups.Groups;
import org.apache.bval.jsr.groups.GroupsComputer;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
        final Set<ConstraintValidation<?>> matchingDescriptors =
        final Groups groupChain = new GroupsComputer().computeGroups(groups);
                for (Group defaultGroupMember : metaBean.<List<Group>>getFeature(JsrFeatures.Bean.GROUP_SEQUENCE)) {
        if (scope == Scope.LOCAL_ELEMENT) {
                if (!it.next().getOwner().equals(metaBean.getBeanClass())) {
        final Set<ConstraintValidation<?>> matchingDescriptors =
         {
        }
            final boolean isOwner = descriptor.getOwner().equals(metaBean.getBeanClass());
                    case LOCAL_ELEMENT:
                        if (isOwner) {
                            return true;
                        }
                        break;
                    case HIERARCHY:
                        if (!isOwner) {
                            return true;
                        }
                        break;
        if (constraintDescriptors.isEmpty()) {
            return Collections.emptySet();
        }
        return Collections.<ConstraintDescriptor<?>> unmodifiableSet(constraintDescriptors);
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ConstraintValidationListener.java
package org.apache.bval.jsr;
import org.apache.bval.jsr.util.PathImpl;
import javax.validation.ElementKind;
import java.util.Iterator;
 * @version $Rev: 1503686 $ $Date: 2013-07-16 14:38:56 0200 (mar., 16 juil. 2013) $

        final Object[] parameters;
        Object leaf;
        Object returnValue;
        T rootBean;
        if (GroupValidationContext.class.isInstance(context)) { // TODO: clean up it but it would need to rework completely our context - get rid of it would be the best
            final GroupValidationContext<T> ctx = GroupValidationContext.class.cast(context);
            final ElementKind elementKind = ctx.getElementKind();
            final Iterator<Path.Node> it = propPath.iterator();
            final ElementKind kind = propPath.iterator().next().getKind();

            returnValue = ctx.getReturnValue();

            if (ElementKind.CONSTRUCTOR.equals(kind)) {
                rootBean = null;
                leaf = context.getBean();
                returnValue = this.rootBean; // switch back return value and rootBean
            } else if (ElementKind.METHOD.equals(kind)) {
                if (ElementKind.RETURN_VALUE.equals(elementKind)) { // switch back return value and rootBean
                    rootBean = (T) returnValue;
                    if (kindOf(propPath, ElementKind.RETURN_VALUE)) {
                        leaf = returnValue;
                        returnValue = this.rootBean;
                    } else {
                        leaf = this.rootBean;
                        returnValue = this.rootBean;
                    }
                } else {
                    rootBean = this.rootBean;
                    if (kindOf(propPath, ElementKind.PARAMETER, ElementKind.CROSS_PARAMETER)) {
                        leaf = rootBean;
                    } else {
                        leaf = context.getBean();
                    }
                }
            } else {
                rootBean = this.rootBean;
                leaf = context.getBean();
            }

            if (ElementKind.CONSTRUCTOR.equals(kind)
                    && (ElementKind.CROSS_PARAMETER.equals(elementKind)
                        || ElementKind.PARAMETER.equals(elementKind))
                    && (it.hasNext() && it.next() != null && it.hasNext() && it.next() != null && !it.hasNext())) { // means inherited validation use real value
                leaf = null;
            }

            parameters = ctx.getParameters();
        } else {
            leaf = context.getBean();
            returnValue = null;
            parameters = null;
            rootBean = this.rootBean;
        }

        constraintViolations.add(new ConstraintViolationImpl<T>(
                messageTemplate, message,
                rootBean, leaf,
                propPath, value, descriptor,
                rootBeanType,
                elementType, returnValue, parameters));
    }

    private static boolean kindOf(final Path propPath, final ElementKind... kinds) {
        final Iterator<Path.Node> node = propPath.iterator();
        boolean isParam = false;
        while (node.hasNext()) {
            final ElementKind current = node.next().getKind();
            isParam = false;
            for (final ElementKind k : kinds) {
                if (k.equals(current)) {
                    isParam = true;
                    break;
                }
            }
        }
        return isParam;
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ConstraintValidatorContextImpl.java
package org.apache.bval.jsr;
import org.apache.bval.jsr.util.LeafNodeBuilderCustomizableContextImpl;
import org.apache.bval.jsr.util.NodeBuilderDefinedContextImpl;
import org.apache.bval.jsr.util.NodeImpl;
import org.apache.bval.jsr.util.PathImpl;
import javax.validation.ElementKind;
import java.lang.reflect.Method;
        return new ConstraintViolationBuilderImpl(this, messageTemplate, validationContext.getPropertyPath());
    }

    public <T> T unwrap(Class<T> type) {
        if (type.isInstance(this)) {
            return type.cast(this);
        }
        throw new ValidationException("Type "  type  " not supported");
                path = PathImpl.create();
                path.getLeafNode().setName(name);
        public NodeBuilderCustomizableContext addPropertyNode(String name) {
            final NodeImpl node;
            if (!propertyPath.isRootPath()) {
                if (propertyPath.getLeafNode().getKind() != null) {
                    node = new NodeImpl.PropertyNodeImpl(name);
                    propertyPath.addNode(node);
                } else {
                    node = propertyPath.getLeafNode();
                }
            } else {
                node = new NodeImpl.PropertyNodeImpl(name);
                propertyPath.addNode(node);
            }
            node.setName(name);
            node.setKind(ElementKind.PROPERTY); // enforce it
            return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
        }

        public LeafNodeBuilderCustomizableContext addBeanNode() {
            final NodeImpl node = new NodeImpl.BeanNodeImpl();
            node.setKind(ElementKind.BEAN);
            propertyPath.addNode(node);
            return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
        }

        public NodeBuilderDefinedContext addParameterNode(int index) {
            final Method method = parent.validationContext.getMethod();
            final List<String> parameters = parent.validationContext.getParameterNameProvider().getParameterNames(method);
            final NodeImpl node = new NodeImpl.ParameterNodeImpl(parameters.get(index), index);
            node.setParameterIndex(index);
            node.setKind(ElementKind.PARAMETER);
            if (!propertyPath.isRootPath()) {
                propertyPath.removeLeafNode();
            }
            propertyPath.addNode(node);
            return new NodeBuilderDefinedContextImpl(parent, messageTemplate, propertyPath);
        }

 b/bval-jsr/src/main/java/org/apache/bval/jsr/ConstraintValidatorIdentity.java
package org.apache.bval.jsr;
 b/bval-jsr/src/main/java/org/apache/bval/jsr/DefaultMessageInterpolator.java
package org.apache.bval.jsr;
import org.apache.bval.el.MessageEvaluator;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

import javax.validation.MessageInterpolator;

@Privilizing(@CallTo(Reflection.class))
    private static final boolean LOG_FINEST = log.isLoggable(Level.FINEST);
    private static final String DEFAULT_VALIDATION_MESSAGES = "org.apache.bval.jsr.ValidationMessages";
    private static final Pattern messageParameterPattern = Pattern.compile("(\\{[\\w\\.]\\})");
    private final Map<Locale, ResourceBundle> defaultBundlesMap = new ConcurrentHashMap<Locale, ResourceBundle>();

    private final MessageEvaluator evaluator;
        // feed the cache with defaults at least
        findDefaultResourceBundle(defaultLocale);
            findUserResourceBundle(defaultLocale);
        MessageEvaluator ev = null;
        try {
            ev = MessageEvaluator.class.cast(getClass().getClassLoader().loadClass("org.apache.bval.el.ELFacade").newInstance());
        } catch (final Throwable e) { // can be exception or error
            // no-op
        }
        evaluator = ev;
                context.getConstraintDescriptor().getAttributes(), locale, context.getValidatedValue());
                                      Locale locale, Object validatedValue) {
        resolvedMessage = replaceAnnotationAttributes(resolvedMessage, annotationParameters);

        // EL handling
        if (evaluator != null) {
            resolvedMessage = evaluator.interpolate(resolvedMessage, annotationParameters, validatedValue);
        }
        resolvedMessage = resolvedMessage.replace( "\\{", "{" ).replace( "\\}", "}" ).replace( "\\\\", "\\" ).replace( "\\$", "$" );
        final ClassLoader classLoader = Reflection.getClassLoader(DefaultMessageInterpolator.class);
            rb = loadBundle(getClass().getClassLoader(), locale, USER_VALIDATION_MESSAGES  " not found by validator classloader");
        if (LOG_FINEST) {
            if (rb != null) {
                log.log(Level.FINEST, String.format("%s found", USER_VALIDATION_MESSAGES));
            } else {
                log.log(Level.FINEST, String.format("%s not found. Delegating to %s", USER_VALIDATION_MESSAGES, DEFAULT_VALIDATION_MESSAGES));
            }
        } catch (final MissingResourceException e) {
        final Matcher matcher = messageParameterPattern.matcher(message);
        final StringBuffer sb = new StringBuffer(64);
            final String parameter = matcher.group(1);
    private String replaceAnnotationAttributes(final String message,
                                               final Map<String, Object> annotationParameters) {
                    parameterValue = replaceVariables(parameterValue, bundle, locale, recurse);
        } catch (final MissingResourceException e) {

 b/bval-jsr/src/main/java/org/apache/bval/jsr/DefaultValidationProviderResolver.java
package org.apache.bval.jsr;
import javax.validation.ValidationException;
import javax.validation.ValidationProviderResolver;
import javax.validation.spi.ValidationProvider;

import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

@Privilizing(@CallTo(Reflection.class))
        "META-INF/services/javax.validation.spi.ValidationProvider";
                final URL url = cfgs.nextElement();
                                @SuppressWarnings("rawtypes")
                                final Class<? extends ValidationProvider> providerType =
                                    cl.loadClass(line).asSubclass(ValidationProvider.class);
                                providers.add(Reflection.newInstance(providerType.asSubclass(ValidationProvider.class)));
                                    line  " configured in file "  url, e);
                    if (br != null) {
                    }
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ElementDescriptorImpl.java
package org.apache.bval.jsr;
import org.apache.bval.jsr.groups.Group;
import javax.validation.ConstraintDeclarationException;
import javax.validation.metadata.GroupConversionDescriptor;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArraySet;
    private final Set<GroupConversionDescriptor> groupConversions = new CopyOnWriteArraySet<GroupConversionDescriptor>();
    private boolean cascaded;
    private final Collection<Object> validated = new CopyOnWriteArraySet<Object>();
    protected static Set<ConstraintDescriptor<?>> getConstraintDescriptors(final Validation[] validations) {
    private final Map<Group, Group> groupMapping = new HashMap<Group, Group>();

     *
    public Set<ConstraintDescriptor<?>> getMutableConstraintDescriptors() {

    public void addGroupMapping(final Group from, final Group to) {
        groupMapping.put(from, to);
    }

    public Group mapGroup(final Group current) {
        final Group mapping = groupMapping.get(current);
        if (mapping != null) {
            return mapping;
        }
        return current;
    }

    public Set<GroupConversionDescriptor> getGroupConversions() {
        return groupConversions;
    }

    public void addGroupConversion(final GroupConversionDescriptor descriptor) {
        groupConversions.add(descriptor);
        final Group from = new Group(descriptor.getFrom());
        if (mapGroup(from) != from) { // ref == is fine
            throw new ConstraintDeclarationException("You can't map twice from the same group");
        }
        addGroupMapping(from, new Group(descriptor.getTo()));
    }

    public boolean isCascaded() {
        return cascaded;
    }

    public void setCascaded(final boolean cascaded) {
        this.cascaded = cascaded;
    }

    public boolean isValidated(final Object object) {
        return validated.contains(object);
    }

    public void setValidated(final Object object) {
        this.validated.add(object);
    }
 b/bval-jsr/src/main/java/org/apache/bval/jsr/GraphBeanIdentity.java
package org.apache.bval.jsr;
 b/bval-jsr/src/main/java/org/apache/bval/jsr/GroupValidationContext.java
package org.apache.bval.jsr;
import org.apache.bval.jsr.groups.Group;
import org.apache.bval.jsr.groups.Groups;
import org.apache.bval.jsr.util.PathImpl;
import javax.validation.ElementKind;
import javax.validation.ParameterNameProvider;
import javax.validation.Path;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
    void setCurrentGroups(Groups groups);

    void setKind(ElementKind type);

    ElementKind getElementKind();

    Object getReturnValue();

    Object[] getParameters();

    void setParameters(Object[] parameters);

    void setReturnValue(Object returnValue);

    ParameterNameProvider getParameterNameProvider();

    void setMethod(Method method);

    Method getMethod();

    void setConstructor(Constructor<?> method);

    Constructor<?> getConstructor();

    void moveDown(Path.Node node);
 b/bval-jsr/src/main/java/org/apache/bval/jsr/GroupValidationContextImpl.java
package org.apache.bval.jsr;
import org.apache.bval.jsr.groups.Group;
import org.apache.bval.jsr.groups.Groups;
import org.apache.bval.jsr.resolver.CachingTraversableResolver;
import org.apache.bval.jsr.util.NodeImpl;
import org.apache.bval.jsr.util.PathImpl;
import javax.validation.ElementKind;
import javax.validation.ParameterNameProvider;
import javax.validation.Path;
import javax.validation.ValidationException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
    private final ParameterNameProvider parameterNameProvider;
    private Object[] parameters;
    private Object returnValue;
    private Method method;
    private Constructor<?> constructor;

     *
     * @param parameterNameProvider
                                      TraversableResolver traversableResolver, ParameterNameProvider parameterNameProvider, MetaBean rootMetaBean) {
        this.parameterNameProvider = parameterNameProvider;
        this.path = PathImpl.create();
    public void setKind(final ElementKind type) {
        path.getLeafNode().setKind(type);
    }

        moveDown(prop.getName());
    @Override
    public void moveDown(final String prop) {
        path.addProperty(prop);
    }

    public void moveDown(final Path.Node node) {
        path.addNode(node);
    }

    public void setCurrentGroups(final Groups g) {
        groups = g;
    }

    public <T> T unwrap(Class<T> type) {
        if (type.isInstance(this)) {
            return type.cast(this);
        }
        throw new ValidationException("Type "  type  " not supported");
    }


    public ElementKind getElementKind() {
        return path.getLeafNode().getKind();
    }

    public Object getReturnValue() {
        return returnValue;
    }

    public Object[] getParameters() {
        return parameters;
    }

    public void setParameters(final Object[] parameters) {
        this.parameters = parameters;
    }

    public void setReturnValue(final Object returnValue) {
        this.returnValue = returnValue;
    }

    public ParameterNameProvider getParameterNameProvider() {
        return parameterNameProvider;
    }

    public void setMethod(final Method method) {
        this.method = method;
    }

    public Method getMethod() {
        return method;
    }

    public Constructor<?> getConstructor() {
        return constructor;
    }

    public void setConstructor(final Constructor<?> constructor) {
        this.constructor = constructor;
    }
 b/bval-jsr/src/main/java/org/apache/bval/jsr/IncompatiblePropertyValueException.java
package org.apache.bval.jsr;
 b/bval-jsr/src/main/java/org/apache/bval/jsr/JsrFeatures.java
package org.apache.bval.jsr;
public interface JsrFeatures {
    interface Method extends Features.Property {
        String MethodDescriptor = "MethodDescriptor";
    }

    interface Constructor extends Features.Property {
        String ConstructorDescriptor = "ConstructorDescriptor";
    }


        // Collection<Annotation>
        String ANNOTATIONS_TO_PROCESS = "annotationToProcess";
 b/bval-jsr/src/main/java/org/apache/bval/jsr/JsrMetaBeanFactory.java
package org.apache.bval.jsr;
import org.apache.bval.jsr.groups.Group;
import org.apache.bval.jsr.util.ClassHelper;
import org.apache.bval.jsr.xml.MetaConstraint;
import org.apache.bval.model.Meta;
import org.apache.bval.model.MetaConstructor;
import org.apache.bval.model.MetaMethod;
import org.apache.bval.model.MetaParameter;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

import javax.validation.ConstraintDeclarationException;
import javax.validation.GroupDefinitionException;
import javax.validation.GroupSequence;
import javax.validation.groups.ConvertGroup;
import javax.validation.groups.Default;

import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.annotation.ElementType;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
@Privilizing(@CallTo(Reflection.class))
public class JsrMetaBeanFactory implements MetaBeanFactory {
    protected static final Logger log = Logger.getLogger(JsrMetaBeanFactory.class.getName());
    public JsrMetaBeanFactory(ApacheFactoryContext factoryContext) {
            final List<Class<?>> classSequence =
                ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), beanClass);
            annotationProcessor.processAnnotations(null, beanClass, beanClass, null, new AppendValidationToMeta(metabean));
        final Collection<String> missingValid = new ArrayList<String>();

        final Field[] fields = Reflection.getDeclaredFields(beanClass);
        for (final Field field : fields) {

                if (field.getAnnotation(ConvertGroup.class) != null) {
                    missingValid.add(field.getName());
                }
        final Method[] methods = Reflection.getDeclaredMethods(beanClass);
        for (final Method method : methods) {
            if (method.isSynthetic() || method.isBridge()) {
                continue;
            }
        for (final String name : missingValid) {
            final MetaProperty metaProperty = metabean.getProperty(name);
            if (metaProperty != null && metaProperty.getFeature(JsrFeatures.Property.REF_CASCADE) == null) {
                throw new ConstraintDeclarationException("@ConvertGroup needs @Valid");
        missingValid.clear();
        for (final MetaConstraint<?, ? extends Annotation> metaConstraint : factoryContext.getFactory().getMetaConstraints(beanClass)) {
            Meta meta;
            AccessStrategy access = metaConstraint.getAccessStrategy();
                meta = null;
            } else if (access.getElementType() == ElementType.METHOD && !metaConstraint.getMember().getName().startsWith("get")) { // TODO: better getter test
                final Method method = Method.class.cast(metaConstraint.getMember());
                meta = metabean.getMethod(method);
                final MetaMethod metaMethod;
                if (meta == null) {
                    meta = new MetaMethod(metabean, method);
                    metaMethod = MetaMethod.class.cast(meta);
                    metabean.addMethod(method, metaMethod);
                } else {
                    metaMethod = MetaMethod.class.cast(meta);
                }
                final Integer index = metaConstraint.getIndex();
                if (index != null && index >= 0) {
                    MetaParameter param = metaMethod.getParameter(index);
                    if (param == null) {
                        param = new MetaParameter(metaMethod, index);
                        metaMethod.addParameter(index, param);
                    }
                    param.addAnnotation(metaConstraint.getAnnotation());
                } else {
                    metaMethod.addAnnotation(metaConstraint.getAnnotation());
                }
                continue;
            } else if (access.getElementType() == ElementType.CONSTRUCTOR){
                final Constructor<?> constructor = Constructor.class.cast(metaConstraint.getMember());
                meta = metabean.getConstructor(constructor);
                final MetaConstructor metaConstructor;
                if (meta == null) {
                    meta = new MetaConstructor(metabean, constructor);
                    metaConstructor = MetaConstructor.class.cast(meta);
                    metabean.addConstructor(constructor, metaConstructor);
                } else {
                    metaConstructor = MetaConstructor.class.cast(meta);
                }
                final Integer index = metaConstraint.getIndex();
                if (index != null && index >= 0) {
                    MetaParameter param = metaConstructor.getParameter(index);
                    if (param == null) {
                        param = new MetaParameter(metaConstructor, index);
                        metaConstructor.addParameter(index, param);
                    }
                    param.addAnnotation(metaConstraint.getAnnotation());
                } else {
                    metaConstructor.addAnnotation(metaConstraint.getAnnotation());
                }
                continue;
                meta = metabean.getProperty(access.getPropertyName());
                create = meta == null;
                    meta = addMetaProperty(metabean, access);
            if (!annotationProcessor.processAnnotation(metaConstraint.getAnnotation(), meta, beanClass,
                metaConstraint.getAccessStrategy(), new AppendValidationToMeta(meta == null ? metabean : meta), false)
        for (final AccessStrategy access : factoryContext.getFactory().getValidAccesses(beanClass)) {
            if (access.getElementType() == ElementType.PARAMETER) {
                continue;
            }

        processGroupSequence(beanClass, metabean, JsrFeatures.Bean.GROUP_SEQUENCE);
            groupSeq = metabean.initFeature(key, new ArrayList<Group>(annotation == null ? 1 : annotation.value().length));
        for (final Class<?> groupClass : groupClasses) {
 b/bval-jsr/src/main/java/org/apache/bval/jsr/MethodDescriptor.java
package org.apache.bval.jsr;
import javax.validation.metadata.ParameterDescriptor;
     * Get the {@link javax.validation.metadata.ParameterDescriptor}s for this {@link org.apache.bval.jsr.MethodDescriptor}.
     * @return {@link java.util.List} of {@link javax.validation.metadata.ParameterDescriptor}
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ParameterAccess.java
package org.apache.bval.jsr;
 * Implementation of {@link org.apache.bval.util.AccessStrategy} for method parameters.
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        final ParameterAccess that = (ParameterAccess) o;
        return paramIdx == that.paramIdx && paramType.equals(that.paramType);
    }

    @Override
    public int hashCode() {
        int result = paramType.hashCode();
        result = 31 * result  paramIdx;
        return result;
    }
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ProcedureDescriptor.java
package org.apache.bval.jsr;
import org.apache.bval.jsr.groups.Group;
import javax.validation.metadata.ParameterDescriptor;
 * Description: superinterface of {@link javax.validation.metadata.ConstructorDescriptor} and {@link org.apache.bval.jsr.MethodDescriptor}.<br/>
     * @return {@link java.util.List} of {@link javax.validation.metadata.ParameterDescriptor}

    void addGroupMapping(Group from, Group to);

    Group mapGroup(Group current);
 b/bval-jsr/src/main/java/org/apache/bval/jsr/PropertyDescriptorImpl.java
package org.apache.bval.jsr;
 *
 * TODO: use it instead of MetaProperty!
 b/bval-jsr/src/main/java/org/apache/bval/jsr/ReturnAccess.java
package org.apache.bval.jsr;
 * Implementation of {@link org.apache.bval.util.AccessStrategy} for method return values.
 b/bval-jsr/src/main/java/org/apache/bval/jsr/UnknownPropertyException.java
package org.apache.bval.jsr;
 * @version $Rev: 1166451 $ $Date: 2011-09-08 00:32:26 0200 (jeu., 08 sept. 2011) $
 b/bval-jsr/src/main/java/org/apache/bval/jsr/groups/Group.java
package org.apache.bval.jsr.groups;
import javax.validation.groups.Default;

    public boolean equals(final Object o) {
        return this == o || o instanceof Group && ObjectUtils.equals(group, ((Group) o).group);
 b/bval-jsr/src/main/java/org/apache/bval/jsr/groups/Groups.java
package org.apache.bval.jsr.groups;
    final List<Group> groups = new LinkedList<Group>();
    final List<List<Group>> sequences = new LinkedList<List<Group>>();
 b/bval-jsr/src/main/java/org/apache/bval/jsr/groups/GroupsComputer.java
package org.apache.bval.jsr.groups;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
    public static final Class<?>[] DEFAULT_GROUP = new Class<?>[]{Default.class};

        DEFAULT_GROUPS = new GroupsComputer().computeGroups(Arrays.asList(DEFAULT_GROUP));
    private final Map<Class<?>, List<Group>> resolvedSequences = new ConcurrentHashMap<Class<?>, List<Group>>();
        for (final Class<?> clazz : groups) {
            if (clazz == null) {
                throw new IllegalArgumentException("At least one group has to be specified.");
            }

                throw new ValidationException("A group has to be an interface. "  clazz.getName()  " is not.");
 b/bval-jsr/src/main/java/org/apache/bval/jsr/resolver/CachingRelevant.java
package org.apache.bval.jsr.resolver;
 b/bval-jsr/src/main/java/org/apache/bval/jsr/resolver/CachingTraversableResolver.java
package org.apache.bval.jsr.resolver;
 b/bval-jsr/src/main/java/org/apache/bval/jsr/resolver/DefaultTraversableResolver.java
package org.apache.bval.jsr.resolver;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
import java.lang.annotation.ElementType;
import java.util.logging.Level;
import java.util.logging.Logger;
@Privilizing(@CallTo(Reflection.class))
    private static final boolean LOG_FINEST = log.isLoggable(Level.FINEST);
          "org.apache.bval.jsr.resolver.JPATraversableResolver";
        final ClassLoader classLoader = Reflection.getClassLoader(DefaultTraversableResolver.class);
            Reflection.getClass(classLoader, PERSISTENCE_UTIL_CLASSNAME);
            if (LOG_FINEST) {
                log.log(Level.FINEST, String.format("Found %s on classpath.", PERSISTENCE_UTIL_CLASSNAME));
            }
        } catch (final Exception e) {
            if (LOG_FINEST) {
                log.log(Level.FINEST, String.format("Instantiated an instance of %s.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME));
            }
        } catch (final Exception e) {
			log.log(Level.WARNING, String.format("Unable to load or instantiate JPA aware resolver %s. All properties will per default be traversable.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME), e);
 b/bval-jsr/src/main/java/org/apache/bval/jsr/resolver/JPATraversableResolver.java
package org.apache.bval.jsr.resolver;
 b/bval-jsr/src/main/java/org/apache/bval/jsr/resolver/SimpleTraversableResolver.java
package org.apache.bval.jsr.resolver;
 b/bval-jsr/src/main/java/org/apache/bval/jsr/util/EnumerationConverter.java
package org.apache.bval.jsr.util;
 * $Id: EnumerationConverter.java 1226560 2012-01-02 22:18:19Z mbenson $
 b/bval-jsr/src/main/java/org/apache/bval/jsr/util/NodeBuilderCustomizableContextImpl.java
package org.apache.bval.jsr.util;
import org.apache.bval.jsr.ConstraintValidatorContextImpl;
import javax.validation.ElementKind;
 * Description: implementation of {@link javax.validation.ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext}.<br/>
        node.setKind(ElementKind.PROPERTY);
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addNode(String name) {
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(String name) {
        propertyPath.addNode(node);
        node = new NodeImpl.PropertyNodeImpl(name);
        node.setKind(ElementKind.PROPERTY);
        return null;
    }

    public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext addBeanNode() {
        propertyPath.addNode(node);
        node = new NodeImpl((String) null);
        node.setKind(ElementKind.BEAN);
        return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
    }

 b/bval-jsr/src/main/java/org/apache/bval/jsr/util/NodeBuilderDefinedContextImpl.java
package org.apache.bval.jsr.util;
import org.apache.bval.jsr.ConstraintValidatorContextImpl;
import javax.validation.ElementKind;
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addNode(String name) {
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(String name) {
        return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, name);
    }

    public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext addBeanNode() {
        final NodeImpl node = new NodeImpl((String) null);
        node.setKind(ElementKind.BEAN);
        propertyPath.addNode(node);
        return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
    }

 b/bval-jsr/src/main/java/org/apache/bval/jsr/util/NodeContextBuilderImpl.java
package org.apache.bval.jsr.util;
import org.apache.bval.jsr.ConstraintValidatorContextImpl;
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(String name) {
        propertyPath.addProperty(name);
        return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, node.getName());
    }

    public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext addBeanNode() {
        return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
    }

 b/bval-jsr/src/main/java/org/apache/bval/jsr/util/PathImpl.java
package org.apache.bval.jsr.util;
 * @version $Rev: 1498347 $ $Date: 2013-07-01 12:06:18 0200 (lun., 01 juil. 2013) $
            return create();
     *
    public static PathImpl create() {
        final PathImpl path = new PathImpl();
        final NodeImpl node = new NodeImpl.BeanNodeImpl();
        for (final Object aPath : path) {
            nodeList.add(newNode(Node.class.cast(aPath)));
    private static Node newNode(final Node cast) {
        if (PropertyNode.class.isInstance(cast)) {
            return new NodeImpl.PropertyNodeImpl(cast);
        }
        if (BeanNode.class.isInstance(cast)) {
            return new NodeImpl.BeanNodeImpl(cast);
        }
        if (MethodNode.class.isInstance(cast)) {
            return new NodeImpl.MethodNodeImpl(cast);
        }
        if (ConstructorNode.class.isInstance(cast)) {
            return new NodeImpl.ConstructorNodeImpl(cast);
        }
        if (ConstructorNode.class.isInstance(cast)) {
            return new NodeImpl.ConstructorNodeImpl(cast);
        }
        if (ReturnValueNode.class.isInstance(cast)) {
            return new NodeImpl.ReturnValueNodeImpl(cast);
        }
        if (ParameterNode.class.isInstance(cast)) {
            return new NodeImpl.ParameterNodeImpl(cast);
        }
        if (CrossParameterNode.class.isInstance(cast)) {
            return new NodeImpl.CrossParameterNodeImpl(cast);
        }
        return new NodeImpl(cast);
    }

            if (leaf != null && leaf.isInIterable() && leaf.getName() == null) { // TODO: avoid to be here
                if (!PropertyNode.class.isInstance(leaf)) {
                    final NodeImpl tmp = new NodeImpl.PropertyNodeImpl(leaf);
                    removeLeafNode();
                    addNode(tmp);
                    leaf = tmp;
                }

        final NodeImpl node;
        if ("<cross-parameter>".equals(name)) {
            node = new NodeImpl.CrossParameterNodeImpl();
        } else {
            node = new NodeImpl.PropertyNodeImpl(name);
        }
        addNode(node);

 b/bval-jsr/src/main/java/org/apache/bval/jsr/util/PathNavigation.java
package org.apache.bval.jsr.util;
import javax.validation.ValidationException;
import java.io.StringWriter;
import java.text.ParsePosition;

 b/bval-jsr/src/main/java/org/apache/bval/jsr/util/Proxies.java
package org.apache.bval.jsr.util;
public final class Proxies {
    // get rid of proxies which probably contains wrong annotation metamodel
    public static <T> Class<?> classFor(final Class<?> clazz) { // TODO: do we want a SPI with impl for guice, owb, openejb, ...?
        if (!clazz.getSimpleName().contains("$$")) { // a lot of proxies use this convention to avoid conflicts with inner/anonymous classes
            return clazz;
        }
        return classFor(clazz.getSuperclass());
    private Proxies() {
        // no-op
 b/bval-jsr/src/main/java/org/apache/bval/jsr/util/ValidationContextTraversal.java
package org.apache.bval.jsr.util;
import org.apache.bval.jsr.JsrMetaBeanFactory;
import org.apache.bval.jsr.UnknownPropertyException;
import org.apache.bval.jsr.util.PathNavigation.CallbackProcedure;
import java.lang.reflect.Type;

                mp = JsrMetaBeanFactory.addMetaProperty(metaBean, access);
 b/bval-jsr/src/main/java/org/apache/bval/jsr/xml/AnnotationProxy.java
package org.apache.bval.jsr.xml;
import javax.validation.Valid;
        final Map<String, Object> result = new HashMap<String, Object>();
        for (final Method m : descriptor.getMethods()) {
        if (processedValuesFromDescriptor != descriptor.size()
                && !Valid.class.equals(annotationType)) {
 b/bval-jsr/src/main/java/org/apache/bval/jsr/xml/MetaConstraint.java
package org.apache.bval.jsr.xml;
import org.apache.bval.ConstructorAccess;
import java.lang.reflect.Constructor;
//TODO move this guy up to org.apache.bval.jsr or org.apache.bval.jsr.model
    private Integer index; // for parameters

            /*TODO: see if can really be removed
            if (accessStrategy == null || accessStrategy.getPropertyName() == null) { // can happen if method does not follow the bean convention
                throw new ValidationException("Annotated method does not follow the JavaBeans naming convention: "  member);
            */
        } else if (member instanceof Constructor<?>) {
            return new ConstructorAccess((Constructor<?>) member);

    public Integer getIndex() {
        return index;
    }

    public void setIndex(final int index) {
        this.index = index;
    }
 b/bval-jsr/src/test/java/org/apache/bval/constraints/AuthorAddressKnown.java
import org.apache.bval.jsr.example.Address;
import org.apache.bval.jsr.example.Author;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
 b/bval-jsr/src/test/java/org/apache/bval/constraints/CompanyEmail.java
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
 b/bval-jsr/src/test/java/org/apache/bval/constraints/FrenchZipCode.java
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
 b/bval-jsr/src/test/java/org/apache/bval/constraints/HasValue.java
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
 b/bval-jsr/src/test/java/org/apache/bval/constraints/ZipCodeCityCoherenceValidator.java
import org.apache.bval.jsr.example.ZipCodeCityCarrier;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/Address.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/Author.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/Book.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/BusinessAddress.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/CompanyAddress.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/Continent.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/Country.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/Customer.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/Employee.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/Engine.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/First.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/FrenchAddress.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/IllustratedBook.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/Last.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/Library.java
package org.apache.bval.jsr.example;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/Person.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/PreferredGuest.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/RecursiveFoo.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/Second.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/XmlEntitySampleBean.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/example/ZipCodeCityCarrier.java
package org.apache.bval.jsr.example;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/extensions/ExampleMethodService.java
package org.apache.bval.jsr.extensions;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/Billable.java
package org.apache.bval.jsr.groups;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/BillableCreditCard.java
package org.apache.bval.jsr.groups;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/BillableUser.java
package org.apache.bval.jsr.groups;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/BuyInOneClick.java
package org.apache.bval.jsr.groups;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/CyclicGroupSequence.java
package org.apache.bval.jsr.groups;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/CyclicGroupSequence1.java
package org.apache.bval.jsr.groups;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/CyclicGroupSequence2.java
package org.apache.bval.jsr.groups;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/GClass1.java
package org.apache.bval.jsr.groups;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/GClass2.java
package org.apache.bval.jsr.groups;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/GClass3.java
package org.apache.bval.jsr.groups;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/GInterface1.java
package org.apache.bval.jsr.groups;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/implicit/Auditable.java
package org.apache.bval.jsr.groups.implicit;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/implicit/Order.java
package org.apache.bval.jsr.groups.implicit;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/inheritance/BillableUser.java
package org.apache.bval.jsr.groups.inheritance;
import org.apache.bval.jsr.groups.Billable;
import org.apache.bval.jsr.groups.BillableCreditCard;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/inheritance/BuyInOneClick.java
package org.apache.bval.jsr.groups.inheritance;
import org.apache.bval.jsr.groups.Billable;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/redefining/Address.java
package org.apache.bval.jsr.groups.redefining;
import org.apache.bval.jsr.example.ZipCodeCityCarrier;
 b/bval-jsr/src/test/java/org/apache/bval/jsr/groups/redefining/InvalidRedefinedDefaultGroupAddress.java
package org.apache.bval.jsr.groups.redefining;
 b/bval-tck11/src/main/java/org/apache/bval/arquillian/BValArquillianExtension.java
package org.apache.bval.arquillian;
import org.jboss.arquillian.core.spi.LoadableExtension;
import org.jboss.arquillian.test.spi.TestEnricher;

public class BValArquillianExtension implements LoadableExtension {
    public void register(final ExtensionBuilder builder) {
        builder.service(TestEnricher.class, EJBEnricher.class);
    }
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.xml.XMLMetaValue;

import java.util.Collection;
import java.util.Date;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import org.apache.bval.MetaBeanFactory;
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.routines.StandardValidation;
import static org.apache.bval.model.Features.Property.JAVASCRIPT_VALIDATION_FUNCTIONS;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import com.thoughtworks.xstream.annotations.XStreamOmitField;
import org.apache.bval.model.Validation;
import org.apache.commons.lang3.ClassUtils;

import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
        addLoader(new XMLMetaBeanURLLoader(Reflection.getClassLoader(getClass()).getResource(resource)));
import static org.apache.bval.model.Features.Property.DENIED;
import static org.apache.bval.model.Features.Property.HIDDEN;
import static org.apache.bval.model.Features.Property.MANDATORY;
import static org.apache.bval.model.Features.Property.MAX_LENGTH;
import static org.apache.bval.model.Features.Property.MIN_LENGTH;
import static org.apache.bval.model.Features.Property.READONLY;
import static org.apache.bval.model.Features.Property.MAX_VALUE;
import static org.apache.bval.model.Features.Property.MIN_VALUE;
import static org.apache.bval.model.Features.Property.REG_EXP;
import static org.apache.bval.model.Features.Property.TIME_LAG;
        }
    <T> Set<javax.validation.ConstraintViolation<T>> validateProperty(T object, String propertyName,
    <T> Set<javax.validation.ConstraintViolation<T>> validateValue(Class<T> beanType,
    public Object construct(InvocationContext context) throws Exception {
    public Object invoke(final InvocationContext context) throws Exception {
import org.apache.bval.jsr.groups.GroupsComputer;
import org.apache.bval.jsr.xml.AnnotationProxyBuilder;
import org.apache.bval.util.AccessStrategy;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.reflect.TypeUtils;
import org.apache.commons.weaver.privilizer.Privileged;

import javax.validation.Constraint;
import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintDefinitionException;
import javax.validation.ConstraintTarget;
import javax.validation.ConstraintValidator;
import javax.validation.OverridesAttribute;
import javax.validation.Payload;
import javax.validation.ReportAsSingleViolation;
import javax.validation.constraintvalidation.SupportedValidationTarget;
import javax.validation.constraintvalidation.ValidationTarget;
     *
    public AnnotationConstraintBuilder(
            Class<? extends ConstraintValidator<A, ?>>[] validatorClasses, A annotation, Class<?> owner,
            AccessStrategy access, ConstraintTarget target) {
            new ConstraintValidation<A>(validatorClasses, annotation, owner, access, reportFromComposite,
     *
     *
    private final ApacheValidatorFactory factory;
     * @param factory the validator factory.
    public AnnotationProcessor(ApacheValidatorFactory factory) {
        this.factory = factory;
            AccessStrategy access, AppendValidation appender, boolean reflection) throws IllegalAccessException,
            factory.getConstraintsCache().getConstraintValidators(annotationType);
                validatorClasses = factory.getDefaultConstraints().getValidatorClasses(annotationType);
    private <A extends Annotation> boolean applyConstraint(
        A annotation,
            new AnnotationConstraintBuilder<A>(
                constraintClasses,
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
    private volatile MetaBeanFinder metaBeanFinder;
    public ApacheFactoryContext(ApacheValidatorFactory factory, MetaBeanFinder metaBeanFinder) {
    private synchronized void resetMeta() { // ensure to ingnore the cache and rebuild constraint with new model
        metaBeanFinder = factory.buildMetaBeanFinder();
    }

        resetMeta();
        resetMeta();
        resetMeta();
        resetMeta();
import org.apache.bval.IntrospectorMetaBeanFactory;
import org.apache.bval.MetaBeanBuilder;
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.MetaBeanManager;
import org.apache.bval.xml.XMLMetaBeanBuilder;
import org.apache.bval.xml.XMLMetaBeanFactory;
import org.apache.bval.xml.XMLMetaBeanManager;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.reflect.ConstructorUtils;
import org.apache.commons.weaver.privilizer.Privileged;
import java.lang.reflect.Constructor;
    private final MetaBeanFinder defaultMetaBeanFinder;

    /**
     * Create MetaBeanManager that uses factories:
     * <ol>
     * <li>if enabled by
     * {@link ApacheValidatorConfiguration.Properties#ENABLE_INTROSPECTOR}, an
     * {@link IntrospectorMetaBeanFactory}</li>
     * <li>{@link MetaBeanFactory} types (if any) specified by
     * {@link ApacheValidatorConfiguration.Properties#METABEAN_FACTORY_CLASSNAMES}
     * </li>
     * <li>if no {@link JsrMetaBeanFactory} has yet been specified (this
     * allows factory order customization), a {@link JsrMetaBeanFactory}
     * which handles both JSR303-XML and JSR303-Annotations</li>
     * <li>if enabled by
     * {@link ApacheValidatorConfiguration.Properties#ENABLE_METABEANS_XML}, an
     * {@link XMLMetaBeanFactory}</li>
     * </ol>
     *
     * @return a new instance of MetaBeanManager with adequate MetaBeanFactories
     */
    protected MetaBeanFinder buildMetaBeanFinder() {
        final List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>();
        if (Boolean.parseBoolean(getProperties().get(
                ApacheValidatorConfiguration.Properties.ENABLE_INTROSPECTOR))) {
            builders.add(new IntrospectorMetaBeanFactory());
        }
        final String[] factoryClassNames =
                StringUtils.split(getProperties().get(
                        ApacheValidatorConfiguration.Properties.METABEAN_FACTORY_CLASSNAMES));
        if (factoryClassNames != null) {
            for (String clsName : factoryClassNames) {
                // cast, relying on #createMetaBeanFactory to throw the exception if incompatible:
                @SuppressWarnings("unchecked")
                final Class<? extends MetaBeanFactory> factoryClass = (Class<? extends MetaBeanFactory>) loadClass(clsName);
                builders.add(createMetaBeanFactory(factoryClass));
            }
        }
        boolean jsrFound = false;
        for (MetaBeanFactory builder : builders) {
            jsrFound |= builder instanceof JsrMetaBeanFactory;
        }
        if (!jsrFound) {
            builders.add(new JsrMetaBeanFactory(this));
        }
        @SuppressWarnings("deprecation")
        final boolean enableMetaBeansXml =
                Boolean.parseBoolean(getProperties().get(
                        ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML));
        if (enableMetaBeansXml) {
            XMLMetaBeanManagerCreator.addFactory(builders);
        }
        return createMetaBeanManager(builders);
    }
    public ApacheValidatorFactory(ConfigurationState configuration) {
        properties = new HashMap<String, String>(configuration.getProperties());

        defaultMetaBeanFinder = buildMetaBeanFinder();
        return new ApacheFactoryContext(this, defaultMetaBeanFinder);

    /**
     * Create a {@link MetaBeanManager} using the specified builders.
     *
     * @param builders
     *            {@link MetaBeanFactory} {@link List}
     * @return {@link MetaBeanManager}
     */
    @SuppressWarnings("deprecation")
    protected MetaBeanFinder createMetaBeanManager(List<MetaBeanFactory> builders) {
        // as long as we support both: jsr (in the builders list) and xstream-xml metabeans:
        if (Boolean.parseBoolean(getProperties().get(
                ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML))) {
            return XMLMetaBeanManagerCreator.createXMLMetaBeanManager(builders);
        }
        return new MetaBeanManager(new MetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
    }

    @Privileged
    private <F extends MetaBeanFactory> F createMetaBeanFactory(final Class<F> cls) {
        try {
            Constructor<F> c = ConstructorUtils.getMatchingAccessibleConstructor(cls, ApacheValidatorFactory.this.getClass());
            if (c != null) {
                return c.newInstance(this);
            }
            c = ConstructorUtils.getMatchingAccessibleConstructor(cls, getClass());
            if (c != null) {
                return c.newInstance(this);
            }
            return cls.newInstance();
        } catch (Exception e) {
            throw new ValidationException(e);
        }
    }

    /**
     * separate class to prevent the classloader to immediately load optional
     * classes: XMLMetaBeanManager, XMLMetaBeanFactory, XMLMetaBeanBuilder that
     * might not be available in the classpath
     */
    private static class XMLMetaBeanManagerCreator {

        static void addFactory(List<MetaBeanFactory> builders) {
            builders.add(new XMLMetaBeanFactory());
        }

        /**
         * Create the {@link MetaBeanManager} to process JSR303 XML. Requires
         * bval-xstream at RT.
         *
         * @param builders meta bean builders
         * @return {@link MetaBeanManager}
         */
        // NOTE - We return MetaBeanManager instead of XMLMetaBeanManager to
        // keep
        // bval-xstream an optional module.
        protected static MetaBeanManager createXMLMetaBeanManager(List<MetaBeanFactory> builders) {
            return new XMLMetaBeanManager(
                    new XMLMetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
        }
    }

    private Class<?> loadClass(final String className) {
        try {
            return Class.forName(className, true, Reflection.getClassLoader(ApacheValidatorFactory.class));
        } catch (ClassNotFoundException ex) {
            throw new ValidationException("Unable to load class: "  className, ex);
        }
    }
            this.annotationProcessor = new AnnotationProcessor(factoryContext.getFactory());
                annotationProcessor.processAnnotation(
                        annotation, null, ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()),
                        access, validations, true);
            new GroupValidationContextImpl<T>(listener, factoryContext.getMessageInterpolator(),
                factoryContext.getTraversableResolver(), factoryContext.getParameterNameProvider(),
                factoryContext.getConstraintValidatorFactory(), metaBean);
                new GroupValidationContextImpl<T>(listener, factoryContext.getMessageInterpolator(),
                        factoryContext.getTraversableResolver(), factoryContext.getParameterNameProvider(),
                        factoryContext.getConstraintValidatorFactory(), metaBean);
    public ConstraintValidation(Class<? extends ConstraintValidator<T, ?>>[] validatorClasses,
                        validator = getConstraintValidator(
                                context.getConstraintValidatorFactory(), annotation, validatorClasses, owner, access);
    private <A extends Annotation> ConstraintValidator<A, ? super T> getConstraintValidator(
            ConstraintValidatorFactory factory, A annotation,
import javax.validation.ConstraintValidatorFactory;
     * Get the {@link ConstraintValidatorFactory}.
     * @return {@link ConstraintValidatorFactory}
     */
    ConstraintValidatorFactory getConstraintValidatorFactory();

    /**
import javax.validation.ConstraintValidatorFactory;
    private final ConstraintValidatorFactory constraintValidatorFactory;
                                      TraversableResolver traversableResolver, ParameterNameProvider parameterNameProvider,
                                      ConstraintValidatorFactory constraintValidatorFactory,
                                      MetaBean rootMetaBean) {
        this.constraintValidatorFactory = constraintValidatorFactory;
    @Override
    public ConstraintValidatorFactory getConstraintValidatorFactory() {
        return constraintValidatorFactory;
    }

    /** {@link javax.validation.ValidatorFactory} used */
    protected final ApacheValidatorFactory factory;
     * @param factory the validator factory.
    public JsrMetaBeanFactory(ApacheValidatorFactory factory) {
        this.factory = factory;
        this.annotationProcessor = new AnnotationProcessor(factory);
        if (!factory.getAnnotationIgnores().isIgnoreAnnotations(beanClass)) {
            if (!factory.getAnnotationIgnores().isIgnoreAnnotations(field)) {
                if (!factory.getAnnotationIgnores().isIgnoreAnnotations(method)) {
        for (final MetaConstraint<?, ? extends Annotation> metaConstraint : factory.getMetaConstraints(beanClass)) {
        for (final AccessStrategy access : factory.getValidAccesses(beanClass)) {
        Class<?>[] groupClasses = factory.getDefaultSequence(beanClass);
        // resetMeta();, see traversableResolver() comment
         // meta are not affected by this so don't call resetMeta();
        // implementor note: this is what does hibernate and loosing our cache cause of resetMeta() call makes it super slow!
        // same note as traversableResolver resetMeta();
        resetMeta(); // needed since param names are capture during processing
                if (loaded == null) {
                    log.log(Level.SEVERE, "Can't load "  parameterNameProvider);
                } else {
        if (target.getTraversableResolver() == target.getDefaultTraversableResolver() && traversableResolverClass != null) {
		    Class<TraversableResolver> clazz = (Class<TraversableResolver>)
		            loadClass(traversableResolverClass);
		    target.traversableResolverClass(clazz);
		    log.log(Level.INFO, String.format("Using %s as traversable resolver.", traversableResolverClass));
		}
        if (target.getConstraintValidatorFactory() == target.getDefaultConstraintValidatorFactory() && constraintFactoryClass != null) {
		    Class<ConstraintValidatorFactory> clazz = (Class<ConstraintValidatorFactory>)
		            loadClass(constraintFactoryClass);
		    target.constraintValidatorFactoryClass(clazz);
		    log.log(Level.INFO, String.format("Using %s as constraint factory.", constraintFactoryClass));
		}
            throw exceptions.iterator().next();
public final class AnnotationProxyBuilder<A extends Annotation> {
 * {@link ClassValidator} instances.
    /**
     * Discard cached metadata. Calling this method unnecessarily has the effect of severly
     * limiting performance, therefore only do so when changes have been made that affect
     * validation metadata, i.e. particularly NOT in response to:
     * <ul>
     *   <li>{@link #messageInterpolator(MessageInterpolator)}</li>
     *   <li>{@link #traversableResolver(TraversableResolver)}</li>
     *   <li>{@link #constraintValidatorFactory(ConstraintValidatorFactory)</li>
     * </ul>
     */
    private synchronized void resetMeta() {
        resetMeta(); // needed since parameter names are a component of validation metadata
            return getPropertyValue(PropertyAccess.getInstance(bean.getClass(), metaProperty.getName()));
            context.moveDown(prop, PropertyAccess.getInstance(bean.getClass(), prop.getName()));
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.lang.reflect.Constructor;
import java.util.Collections;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.logging.Level;
import java.util.logging.Logger;
 * Description: Undefined dynamic strategy (FIELD or METHOD access). Uses Apache
 * Commons BeanUtils (if present) to support its {@code DynaBean} type. Otherwise the
 * {@code java.beans} APIs are used for Java bean property methods and we fall
 * back to accessing field values directly.
@Privilizing(@CallTo(Reflection.class))
    private static final Logger log =  Logger.getLogger(PropertyAccess.class.getName());
    private static final String BEANUTILS =
        "org.apache.commons.beanutils.BeanUtils";
    private static final String BEANUTILS_PROPERTY_ACCESS =
        "org.apache.bval.util.BeanUtilsPropertyAccess";
    private static final Constructor<? extends PropertyAccess> BEANUTILS_PROPERTY_ACCESS_CTOR;
    private static final ConcurrentMap<Class<?>, Map<String, PropertyDescriptor>> PROPERTY_DESCRIPTORS =
        new ConcurrentHashMap<Class<?>, Map<String, PropertyDescriptor>>();

    static {
        final ClassLoader cl = Reflection.getClassLoader(PropertyAccess.class);
        boolean useBeanUtils;
        try {
            Reflection.getClass(cl, BEANUTILS);
            useBeanUtils = true;
        } catch (Exception e) {
            useBeanUtils = false;
        }
        Constructor<? extends PropertyAccess> ctor;
        if (useBeanUtils) {
            try {
                final Class<?> beanUtilsPropertyAccess =
                    Reflection.getClass(cl, BEANUTILS_PROPERTY_ACCESS);

                ctor = Reflection.getDeclaredConstructor(
                    beanUtilsPropertyAccess.asSubclass(PropertyAccess.class),
                    Class.class, String.class);

            } catch (Exception e) {
                ctor = null;
            }
        } else {
            ctor = null;
        }
        BEANUTILS_PROPERTY_ACCESS_CTOR = ctor;
    }

    /**
     * Obtain a {@link PropertyAccess} instance.
     * @param clazz
     * @param propertyName
     * @return PropertyAccess
     * @since 1.1.2
     */
    public static PropertyAccess getInstance(Class<?> clazz,
        String propertyName) {
        if (BEANUTILS_PROPERTY_ACCESS_CTOR != null) {
            try {
                return BEANUTILS_PROPERTY_ACCESS_CTOR.newInstance(clazz,
                    propertyName);
            } catch (Exception e) {
                log.log(Level.WARNING,
                    String.format(
                        "Exception encountered attempting to instantiate %s(%s, %s)",
                        BEANUTILS_PROPERTY_ACCESS_CTOR, clazz, propertyName),
                    e);
            }
        }
        return new PropertyAccess(clazz, propertyName);
    }

    @Deprecated
    // keep as protected
    protected Object getPublicProperty(Object bean) throws InvocationTargetException,
            return ((Map<?, ?>) bean).get(propertyName);
        }
        final Method readMethod =
            getPropertyReadMethod(propertyName, bean.getClass());
        if (readMethod == null) {
            throw new NoSuchMethodException(toString());
        }
        final boolean unset = Reflection.setAccessible(readMethod, true);
        try {
            return readMethod.invoke(bean);
        } finally {
            if (unset) {
                Reflection.setAccessible(readMethod, false);
            }
    public static Object getProperty(Object bean, String propertyName)
        throws InvocationTargetException, NoSuchMethodException,
        IllegalAccessException {
        return getInstance(bean.getClass(), propertyName).get(bean);
    private static Method getPropertyReadMethod(String propertyName,
        Class<?> beanClass) {
        final Map<String, PropertyDescriptor> propertyDescriptors =
            getPropertyDescriptors(beanClass);
        if (propertyDescriptors.containsKey(propertyName)) {
            return propertyDescriptors.get(propertyName).getReadMethod();
                return getPublicProperty(bean);
    
    private static Map<String, PropertyDescriptor> getPropertyDescriptors(Class<?> type) {
        if (PROPERTY_DESCRIPTORS.containsKey(type)) {
            return PROPERTY_DESCRIPTORS.get(type);
        }
        Map<String, PropertyDescriptor> m;
        try {
            final PropertyDescriptor[] propertyDescriptors = Introspector.getBeanInfo(type).getPropertyDescriptors();
            if (propertyDescriptors == null) {
                m = Collections.emptyMap();
            } else {
                m = new HashMap<String, PropertyDescriptor>();
                for (PropertyDescriptor pd : propertyDescriptors) {
                    m.put(pd.getName(), pd);
                }
            }
        } catch (IntrospectionException e) {
            log.log(Level.SEVERE, String.format("Cannot locate %s for ", BeanInfo.class.getSimpleName(), type), e);
            m = Collections.emptyMap();
        }
        final Map<String, PropertyDescriptor> faster = PROPERTY_DESCRIPTORS.putIfAbsent(type, m);
        return faster == null ? m : faster;
    }
@Deprecated
import java.lang.annotation.ElementType;
    private static class NullSafePropertyAccess extends AccessStrategy {
        private final PropertyAccess wrapped;
            wrapped = PropertyAccess.getInstance(clazz, propertyName);
            return bean == null ? null : wrapped.get(bean);
        }

        @Override
        public ElementType getElementType() {
            return wrapped.getElementType();
        }

        @Override
        public Type getJavaType() {
            return wrapped.getJavaType();
        }

        @Override
        public String getPropertyName() {
            return wrapped.getPropertyName();
            PropertyAccess access = PropertyAccess.getInstance(rawType, token);
        if (returnType.equals(String.class)) {
            return value;
        }
            ClassLoader cl = Reflection.getClassLoader(ValidationMappingParser.class);
            try {
                return Reflection.getClass(cl, toQualifiedClassName(value, defaultPackage));
            } catch (Exception e) {
                throw new ValidationException(e);
            }
        }
        if (returnType.isEnum()) {
            try {
                @SuppressWarnings({ "rawtypes", "unchecked" })
                final Enum e = Enum.valueOf(returnType.asSubclass(Enum.class), value);
                return e;
            } catch (IllegalArgumentException e) {
                throw new ValidationException(e);
            }
        throw new ValidationException(String.format("Unknown annotation value type %s", returnType.getName()));
    protected volatile MessageInterpolator messageInterpolator = defaultMessageInterpolator;
    protected volatile ConstraintValidatorFactory constraintValidatorFactory = defaultConstraintValidatorFactory;
    protected volatile TraversableResolver traversableResolver = defaultTraversableResolver;
    protected volatile ParameterNameProvider parameterNameProvider = defaultParameterNameProvider;
    private volatile ConstraintValidator<T, ?> validator;
    private volatile Boolean useCdi = null; // store it to avoid NoClassDefFoundError when cdi is not present (it is slow)  lazily (to wait cdi is started)
                        useCdi = BValExtension.getBeanManager() != null;
            if (useCdi) {
        notNull("validated object", object);
        notNull("validated object", object);
        return validateValueImpl(notNull("bean type", beanType), null, propertyName, value, cascade, groups);
        notNull("class", clazz);
        for (final Class<?> c : notNull("groups", groups)) {
            notNull("group", c);
        notNull("Constructor", constructor);
        notNull("Returned value", createdObject);
        return validateReturnedValue(new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(), Arrays.asList(constructor.getParameterTypes())), createdObject, declaringClass, methodDescriptor, gps, null);
    private <T> Set<ConstraintViolation<T>> validateReturnedValue(final NodeImpl rootNode, final T createdObject, final Class<?> clazz,
        notNull("Object", object);
        notNull("Parameters", parameterValues);
        notNull("Method", method);
        notNull("Groups", groups);
        for (final Class<?> g : groups) {
            notNull("Each group", g);
            if (method.getParameterTypes().length == 0) {
                checkValidationAppliesTo(Collections.singleton(methodDescriptor.getCrossParameterDescriptor()),
                    ConstraintTarget.PARAMETERS);
            } else if (!Void.TYPE.equals(method.getReturnType())) {
                checkValidationAppliesTo(Collections.singleton(methodDescriptor.getCrossParameterDescriptor()),
                    ConstraintTarget.IMPLICIT);
                checkValidationAppliesTo(methodDescriptor.getParameterDescriptors(), ConstraintTarget.IMPLICIT);
    private static <T> T notNull(final String entity, final T shouldntBeNull) {
            throw new IllegalArgumentException(entity  " cannot be null");
        return shouldntBeNull;
            Set.class.cast(validateReturnedValue(
        if (directValueClass.isArray()) {
            return;
        if (Collection.class.isAssignableFrom(directValueClass)) {
            final Collection<?> coll = Collection.class.cast(context.getValidatedValue());
            if (!coll.isEmpty()) {
                context.setMetaBean(metaBeanFinder.findForClass(coll.iterator().next().getClass()));
                return;
            }
        }
        if (Map.class.isAssignableFrom(directValueClass)) {
            final Map<?, ?> m = Map.class.cast(context.getValidatedValue());
            if (!m.isEmpty()) {
                context.setMetaBean(metaBeanFinder.findForClass(m.values().iterator().next().getClass()));
                return;
            }
        }
        context.setMetaBean(metaBeanFinder.findForClass(directValueClass));
    @Override
    @Override
    @Override
    @Override
    @Override
        @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
        @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
        @Override
        @Override
        @Override
    @Override
    @Override
        @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
        @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
        @Override
        @Override
        @Override
        @Override
        @Override
        @Override
        @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
        @Deprecated
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
import org.apache.bval.model.Features.Bean;
        Set<PropertyDescriptor> procedureDescriptors = metaBean.getFeature(Bean.PROPERTIES);
            procedureDescriptors = metaBean.initFeature(Bean.PROPERTIES, procedureDescriptors);
        ExecutableMeta executables = metaBean.getFeature(Bean.EXECUTABLES);
            executables = metaBean.initFeature(Bean.EXECUTABLES, executables);
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
        @Override
    @Override
    @Override
    @Override
                            @Override
                @Override
                @Override
    @Override
    @Override
    @Override
    @Override
        @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
            @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
        @Override
        @Override
        @Override
        @Override
        @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
        return new ConstraintFinderImpl(metaBean, new HashSet(constraintDescriptors));
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
import org.apache.bval.model.Features.Property;
    @Override
            if (metaProperty != null && metaProperty.getFeature(Property.REF_CASCADE) == null) {
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
        final Class<Enum> enumClass = type;
    @Override
    @Override
        @Override
        @Override
        @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
        @Override
        @Override
        @Override
        @Override
        @Override
        @Override
        @Override
        @Override
        @Override
        @Override
        @Override
    @Override
        @Override
        @Override
        @Override
        @Override
        @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
        @Override
        @Override
        @Override
        @Override
        @Override
        @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
            @Override
            @Override
    @Override
                @Override
                @Override
    @Override
            @Override
            @Override
    @Override
    @Override
    @Override
    @Override
    @Override
            context.buildConstraintViolationWithTemplate("city not OK").addPropertyNode("city").addConstraintViolation();
        if (isProxyClass(clazz)) {
            final Class<?> parent = clazz.getSuperclass();
            if (parent != null) {
                return classFor(clazz.getSuperclass());
            }
        return clazz;
    }

    private static boolean isProxyClass(Class<?> clazz) {
        return clazz.getSimpleName().contains("$$");// a lot of proxies use this convention to avoid conflicts with inner/anonymous classes
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

    private static final Set<String> KNOWN_PROXY_CLASSNAMES;

    static {
        final Set<String> s = new HashSet<String>();
        s.add("org.jboss.weld.bean.proxy.ProxyObject");
        KNOWN_PROXY_CLASSNAMES = Collections.unmodifiableSet(s); 
    }

        final String simpleName = clazz.getSimpleName();
        if (KNOWN_PROXY_CLASSNAMES.contains(simpleName)) {
            return true;
        }
        return simpleName.contains("$$");// a lot of proxies use this convention to avoid conflicts with inner/anonymous classes
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;

                        fields.put(name, Integer.valueOf(i));
                    final String name = getPropertyName(m);
                    if (StringUtils.isNotEmpty(name)) {
                        if (!fields.containsKey(name)) {
                            fields.put(name, Integer.valueOf(i));
        private String getPropertyName(Method potentialAccessor) {
            if (potentialAccessor.getParameterTypes().length == 0) {
                final String name = potentialAccessor.getName();
                if (Boolean.TYPE.equals(potentialAccessor.getReturnType())
                    && potentialAccessor.getName().startsWith("is")) {
                    return Introspector.decapitalize(name.substring(2));
                }
                if (!Void.TYPE.equals(potentialAccessor.getReturnType())
                    && potentialAccessor.getName().startsWith("get")) {
                    return Introspector.decapitalize(name.substring(3));
                }
            }
            return null;
        @Override
        public int compare(final String o1, final String o2) {
            final Integer i1 = fields.get(o1);
            final Integer i2 = fields.get(o2);
            if (i1 == null) {
                if (i2 == null) {
                    // java.util.TreeMap requires that the comparator be consistent with #equals(),
                    // therefore we must not incorrectly report 0 comparison for different property names
                    return StringUtils.compare(o1, o2);
                }
                return -1;
            if (i2 == null) {
                return 1;
            }
            return i1.intValue() - i2.intValue();

        if (KNOWN_PROXY_CLASSNAMES.contains(clazz.getName())) {
        return clazz.getSimpleName().contains("$$");// a lot of proxies use this convention to avoid conflicts with inner/anonymous classes

import javax.enterprise.util.AnnotationLiteral;
    public static final class ValidAnnotation extends AnnotationLiteral<Valid> implements Valid {
        private static final long serialVersionUID = 1L;
        public static final ValidAnnotation INSTANCE = new ValidAnnotation();
    public static final class ConvertGroupAnnotation extends AnnotationLiteral<ConvertGroup> implements ConvertGroup {
        private static final long serialVersionUID = 1L;

 * not implemented! simple dummy implementation for tests only! <br/>
    @FrenchZipCode
    String zipCode2 = "123456";


    public String getZipCode2() {
        return zipCode2;
    }

    public void setZipCode2(String zipCode2) {
        this.zipCode2 = zipCode2;
    }
    private static String ATOM = "[^\\x00-\\x1F\\(\\)\\<\\>\\@\\,\\;\\:\\\\\\\"\\.\\[\\]\\s]";
public class AnyLiteral extends EmptyAnnotationLiteral<Any> implements Any {

    public static class BValBindingLiteral extends EmptyAnnotationLiteral<BValBinding> implements BValBinding {
        public String toString() {
            return "@org.apache.bval.cdi.BValBinding()";

public class DefaultLiteral extends EmptyAnnotationLiteral<Default> implements Default {
import org.apache.bval.cdi.EmptyAnnotationLiteral;
    public static final class ValidAnnotation extends EmptyAnnotationLiteral<Valid> implements Valid {
import org.apache.bval.util.reflection.Reflection;
        return factories != null ? factories.clone() : null;
        this.factories = factories != null ? factories.clone() : null;
                return Reflection.toClass(className);
                log.log(Level.FINE, String.format("Class not found: %s", className), e);
        return enumConstants != null ? enumConstants.clone() : null;
        target.validations = validations != null ? validations.clone() : null;
        return validations != null ? validations.clone() : null;
        this.validations = validations != null ? validations.clone() : null;
import java.util.HashSet;
import java.util.Set;
import org.apache.bval.util.ObjectUtils;

    private Set<Annotation> annotations = new HashSet<Annotation>();
    private Annotation[] annArray = null;
        if (annArray == null) {
            annArray = annotations.isEmpty() ? ObjectUtils.EMPTY_ANNOTATION_ARRAY : annotations.toArray(new Annotation[annotations.size()]);
        }
        return annArray;
        this.annotations.add(annotation);
        annArray = null;
                    if (name != null && !name.isEmpty()) {
                    // Both o1 and o2 cannot be null as they would have blown up with a NPE in fields.get already
                    return o1.compareTo(o2);
import org.apache.bval.util.reflection.TypeUtils;

import org.apache.bval.util.reflection.TypeUtils;

            Type type = TypeUtils.unrollVariables(typeArguments, ITERABLE_TYPE);
            return type != null ? type : Object.class;
import org.apache.bval.util.reflection.TypeUtils;
            Reflection.toClass(BEANUTILS, cl);
                    Reflection.toClass(BEANUTILS_PROPERTY_ACCESS, cl);
import java.util.HashMap;
import java.util.Map;
    private static final Object[][] NATIVE_CODES = new Object[][]{
            {byte.class, "byte", "B"},
            {char.class, "char", "C"},
            {double.class, "double", "D"},
            {float.class, "float", "F"},
            {int.class, "int", "I"},
            {long.class, "long", "J"},
            {short.class, "short", "S"},
            {boolean.class, "boolean", "Z"},
            {void.class, "void", "V"}
    };

     * Maps primitive {@code Class}es to their corresponding wrapper {@code Class}.
    private static final Map<Class<?>, Class<?>> PRIMITIVE_WRAPPER_MAP = new HashMap<Class<?>, Class<?>>();
    static {
        PRIMITIVE_WRAPPER_MAP.put(Boolean.TYPE, Boolean.class);
        PRIMITIVE_WRAPPER_MAP.put(Byte.TYPE, Byte.class);
        PRIMITIVE_WRAPPER_MAP.put(Character.TYPE, Character.class);
        PRIMITIVE_WRAPPER_MAP.put(Short.TYPE, Short.class);
        PRIMITIVE_WRAPPER_MAP.put(Integer.TYPE, Integer.class);
        PRIMITIVE_WRAPPER_MAP.put(Long.TYPE, Long.class);
        PRIMITIVE_WRAPPER_MAP.put(Double.TYPE, Double.class);
        PRIMITIVE_WRAPPER_MAP.put(Float.TYPE, Float.class);
        PRIMITIVE_WRAPPER_MAP.put(Void.TYPE, Void.TYPE);
    }



    /**
     * <p>Converts the specified primitive Class object to its corresponding
     * wrapper Class object.</p>
     *
     * <p>NOTE: From v2.2, this method handles {@code Void.TYPE},
     * returning {@code Void.TYPE}.</p>
     *
     * @param cls  the class to convert, may be null
     * @return the wrapper class for {@code cls} or {@code cls} if
     * {@code cls} is not a primitive. {@code null} if null input.
     * @since 2.1
     */
    public static Class<?> primitiveToWrapper(final Class<?> cls) {
        Class<?> convertedClass = cls;
        if (cls != null && cls.isPrimitive()) {
            convertedClass = PRIMITIVE_WRAPPER_MAP.get(cls);
        }
        return convertedClass;
    }

    public static Class<?> wrapperToPrimitive(final Class<?> cls) {
        for (Map.Entry<Class<?>, Class<?>> primitiveEntry : PRIMITIVE_WRAPPER_MAP.entrySet()) {
            if (primitiveEntry.getValue().equals(cls)) {
                return primitiveEntry.getKey();
            }
        }
        return null;
    public static Class<?> toClass(String className) throws ClassNotFoundException
    {
        ClassLoader cl = getClassLoader(Reflection.class);
        return toClass(className, cl);
    }

    /**
     * Return the class for the given string, correctly handling
     * primitive types. If the given class loader is null, the context
     * loader of the current thread will be used.
     *
     * @throws RuntimeException on load error
     */
    public static Class toClass(String className, ClassLoader loader) throws ClassNotFoundException {
        return toClass(className, false, loader);
    }

    /**
     * Return the class for the given string, correctly handling
     * primitive types. If the given class loader is null, the context
     * loader of the current thread will be used.
     *
     * @throws RuntimeException on load error
     */
    public static Class toClass(String className, boolean resolve, ClassLoader loader) throws ClassNotFoundException {
        if (className == null) {
            throw new NullPointerException("className == null");
        }

        // array handling
        int dims = 0;
        while (className.endsWith("[]")) {
            dims;
            className = className.substring(0, className.length() - 2);
        }

        // check against primitive types
        boolean primitive = false;
        if (className.indexOf('.') == -1) {
            for (int i = 0; !primitive && (i < NATIVE_CODES.length); i) {
                if (NATIVE_CODES[i][1].equals(className)) {
                    if (dims == 0) {
                        return (Class) NATIVE_CODES[i][0];
                    }
                    className = (String) NATIVE_CODES[i][2];
                    primitive = true;
                }
            }
        }

        if (dims > 0) {
            StringBuilder buf = new StringBuilder(className.length()  dims  2);
            for (int i = 0; i < dims; i) {
                buf.append('[');
            }
            if (!primitive) {
                buf.append('L');
            }
            buf.append(className);
            if (!primitive) {
                buf.append(';');
            }
            className = buf.toString();
        }

        if (loader == null) {
            loader = Thread.currentThread().getContextClassLoader();
        }

        return Class.forName(className, resolve, loader);
    }


import org.apache.bval.util.Validate;

import org.apache.bval.util.reflection.TypeUtils;
        if (garr == null || garr.length == 0) {
import org.apache.bval.util.ObjectUtils;
        if (ObjectUtils.arrayContains(strategies, access)) {
            strategies = ObjectUtils.arrayAdd(strategies, access);
import org.apache.bval.util.reflection.Reflection;
                validatorFactoryClass = Reflection.toClass(validatorFactoryClassname).asSubclass(ValidatorFactory.class);
import org.apache.bval.util.ObjectUtils;
import org.apache.bval.util.StringUtils;

            final Class<?> cls = Reflection.toClass(type.getName()  "Impl");
        return array == null || array.length == 0 ? ObjectUtils. EMPTY_CLASS_ARRAY : array.clone();
            Constructor<F> c = Reflection.getDeclaredConstructor(cls, ApacheValidatorFactory.this.getClass());
            c = Reflection.getDeclaredConstructor(cls, getClass());
                        annotation, null, Reflection.primitiveToWrapper((Class<?>) access.getJavaType()),
import org.apache.bval.util.ObjectUtils;
import org.apache.bval.util.reflection.TypeUtils;
            final Class<?> cls = Reflection.toClass(type.getName()  "Impl");

                    Validation[] validations = meta.getValidations();
                    if (validations == null || validations.length == 0) {
import org.apache.bval.util.reflection.TypeUtils;
import org.apache.bval.util.StringUtils;
                    classes.add(Reflection.toClass(className.trim(), classloader));

    /**
     * generated equals on all fields except hashCode
     */
        if (this == o) { return true; }
        if (o == null || getClass() != o.getClass()) { return false; }
        ConstraintDescriptorImpl<?> that = (ConstraintDescriptorImpl<?>) o;
        if (reportAsSingleViolation != that.reportAsSingleViolation) { return false; }
        if (annotation != null ? !annotation.equals(that.annotation) : that.annotation != null) { return false; }
        if (groups != null ? !groups.equals(that.groups) : that.groups != null) { return false; }
        if (payload != null ? !payload.equals(that.payload) : that.payload != null) { return false; }
        if (constraintValidatorClasses != null ? !constraintValidatorClasses.equals(that.constraintValidatorClasses) : that.constraintValidatorClasses != null) { return false; }
        if (attributes != null ? !attributes.equals(that.attributes) : that.attributes != null) { return false; }
        if (composingConstraints != null ? !composingConstraints.equals(that.composingConstraints) : that.composingConstraints != null) { return false; }
        if (validationAppliesTo != that.validationAppliesTo) { return false; }
        return template != null ? template.equals(that.template) : that.template == null;


    /**
     * generated hashCode on all fields except hashCode
     */
        int result = annotation != null ? annotation.hashCode() : 0;
        result = 31 * result  (groups != null ? groups.hashCode() : 0);
        result = 31 * result  (payload != null ? payload.hashCode() : 0);
        result = 31 * result  (constraintValidatorClasses != null ? constraintValidatorClasses.hashCode() : 0);
        result = 31 * result  (attributes != null ? attributes.hashCode() : 0);
        result = 31 * result  (composingConstraints != null ? composingConstraints.hashCode() : 0);
        result = 31 * result  (reportAsSingleViolation ? 1 : 0);
        result = 31 * result  (validationAppliesTo != null ? validationAppliesTo.hashCode() : 0);
        result = 31 * result  (template != null ? template.hashCode() : 0);
        return result;
import org.apache.bval.util.ObjectUtils;
import org.apache.bval.util.StringUtils;
import org.apache.bval.util.reflection.Reflection;
import org.apache.bval.util.reflection.TypeUtils;
        this.validatorClasses = validatorClasses != null ? validatorClasses.clone() : null;
        if (ObjectUtils.isNotEmpty(constraintClasses)) {
        return type instanceof Class<?> ? Reflection.primitiveToWrapper((Class<?>) type) : type;
import java.util.Arrays;
                    resolvedParameterValue = Arrays.toString((Object[]) variable);

    public boolean isDefault() {
        return Default.class.equals(group);
    }
    /**
     * {@inheritDoc}
     */
    public boolean equals(Object o) {
        if (this == o) { return true; }
        if (o == null || getClass() != o.getClass()) { return false; }

        Group group1 = (Group) o;

        return group != null ? group.equals(group1.group) : group1.group == null;
            Reflection.toClass(PERSISTENCE_UTIL_CLASSNAME, classLoader);
              (Class<? extends TraversableResolver>) Reflection.toClass(JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME, classLoader);
            log.log(Level.WARNING, String.format("Unable to load or instantiate JPA aware resolver %s. All properties will per default be traversable.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME), e);
     * string which may contain Java escape sequences. This function is only available if commons-lang3 is available on the classpath!
                try {
                    int codePoints = org.apache.commons.lang3.StringEscapeUtils.UNESCAPE_JAVA.translate(path, here, w);
                    if (codePoints == 0) {
                        w.write(Character.toChars(Character.codePointAt(path, here)));
                        pos.next();
                    } else {
                        for (int i = 0; i < codePoints; i) {
                            pos.plus(Character.charCount(Character.codePointAt(path, pos.getIndex())));
                        }
                catch (Exception e) {
                    throw new RuntimeException("Java escaping in quotes is only supported with Apache commons-lang3 on the classpath!");
                }
import org.apache.bval.util.ObjectUtils;
import org.apache.bval.util.reflection.TypeUtils;
import org.apache.bval.util.ObjectUtils;
import org.apache.bval.util.StringUtils;
                return Reflection.toClass(toQualifiedClassName(value, defaultPackage), cl);
            return ObjectUtils.EMPTY_CLASS_ARRAY;
import org.apache.bval.util.ObjectUtils;

        return s == null || ObjectUtils.arrayContains(values, s);
import org.apache.bval.util.reflection.Reflection;
                        (Validation) Reflection.toClass(xv.getJava()).newInstance();
import org.apache.bval.util.reflection.Reflection;
            prop.setType(Reflection.toClass(getType())); // enhancement: or use getGenericType() ?
public class BeanValidationContext<T extends ValidationListener> implements ValidationContext<T> {
    protected <VL extends ValidationListener> void validateRelatedBean(ValidationContext<VL> context,
        MetaProperty prop) {
    private static final Logger log = Logger.getLogger(MetaBeanBuilder.class.getName());
@Target({ METHOD, FIELD, CONSTRUCTOR, PARAMETER })
    /**
     *                     the validation error
            annArray = annotations.isEmpty() ? ObjectUtils.EMPTY_ANNOTATION_ARRAY
                : annotations.toArray(new Annotation[annotations.size()]);
        } else {
            copy.properties = new TreeMap<String, MetaProperty>();
            return "Error{"  "reason='"  reason  '\''  ", propertyName='"  propertyName  '\''  '}';
    public static void main(String[] args) {
        throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {
 */
    private static final Logger log = Logger.getLogger(PropertyAccess.class.getName());
    private static final String BEANUTILS = "org.apache.commons.beanutils.BeanUtils";
    private static final String BEANUTILS_PROPERTY_ACCESS = "org.apache.bval.util.BeanUtilsPropertyAccess";
                final Class<?> beanUtilsPropertyAccess = Reflection.toClass(BEANUTILS_PROPERTY_ACCESS, cl);
                ctor = Reflection.getDeclaredConstructor(beanUtilsPropertyAccess.asSubclass(PropertyAccess.class),
    public static PropertyAccess getInstance(Class<?> clazz, String propertyName) {
                return BEANUTILS_PROPERTY_ACCESS_CTOR.newInstance(clazz, propertyName);
                log.log(Level.WARNING, String.format("Exception encountered attempting to instantiate %s(%s, %s)",
                    BEANUTILS_PROPERTY_ACCESS_CTOR, clazz, propertyName), e);
    protected Object getPublicProperty(Object bean)
        throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {
        final Method readMethod = getPropertyReadMethod(propertyName, bean.getClass());
        throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {
    private static Method getPropertyReadMethod(String propertyName, Class<?> beanClass) {
        final Map<String, PropertyDescriptor> propertyDescriptors = getPropertyDescriptors(beanClass);

            } else {
    public static void validateContext(ValidationContext<?> context, ValidateCallback s, boolean treatMapsLikeBeans) {
    protected static <VL extends ValidationListener> void validateBeanInContext(ValidationContext<VL> context,
        ValidateCallback s) {
    protected static <VL extends ValidationListener> void validateArrayInContext(ValidationContext<VL> context,
        ValidateCallback s) {
    protected static <VL extends ValidationListener> void validateIterableInContext(ValidationContext<VL> context,
        ValidateCallback s) {
    protected static <VL extends ValidationListener> void validateMapInContext(ValidationContext<VL> context,
        ValidateCallback s) {
    private static <VL extends ValidationListener> DynamicMetaBean getDynamicMetaBean(ValidationContext<VL> context) {
    public static <VL extends ValidationListener> void validateBean(ValidationContext<VL> context) {
    public static <VL extends ValidationListener> void validateProperty(ValidationContext<VL> context) {
 * @since 1.1.2
    /**
     * <p>Checks if the subject type may be implicitly cast to the target
     * parameterized type following the Java generics rules.</p>
     *
     * @param type the subject type to be assigned to the target type
     * @param toParameterizedType the target parameterized type
     * @param typeVarAssigns a map with type variables
     * @return {@code true} if {@code type} is assignable to {@code toType}.
     */
@Constraint(validatedBy = ABANumberValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class ABANumberValidator extends ModulusValidator<ABANumber> {
    private static final int[] POSITION_WEIGHT = new int[] { 3, 1, 7 };
    protected int weightedValue(int charValue, int leftPos, int rightPos) throws Exception {
@Constraint(validatedBy = CUSIPValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class CUSIPValidator extends ModulusValidator<CUSIP> {
    private static final int[] POSITION_WEIGHT = new int[] { 2, 1 };
    protected int weightedValue(int charValue, int leftPos, int rightPos) throws Exception {
            throw new IllegalArgumentException("Invalid Character["  leftPos  "] = '"  charValue  "'");
@Constraint(validatedBy = EAN13Validator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class EAN13Validator extends ModulusValidator<EAN13> {
    private static final int[] POSITION_WEIGHT = new int[] { 3, 1 };
    protected int weightedValue(int charValue, int leftPos, int rightPos) throws Exception {
@Constraint(validatedBy = IBANValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class IBANValidator implements ConstraintValidator<IBAN, String> {
    public void initialize(IBAN iban) {
@Constraint(validatedBy = ISBN10Validator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class ISBN10Validator extends ModulusValidator<ISBN10> {
    protected int weightedValue(int charValue, int leftPos, int rightPos) throws Exception {
@Constraint(validatedBy = LuhnValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class LuhnValidator extends ModulusValidator<Luhn> {
    private static final int[] POSITION_WEIGHT = new int[] { 2, 1 };
    protected int weightedValue(int charValue, int leftPos, int rightPos) throws Exception {
abstract class ModulusValidator<A extends Annotation> implements ConstraintValidator<A, String> {
            int leftPos = i  1;
    protected abstract int weightedValue(int charValue, int leftPos, int rightPos) throws Exception;
        throw new IllegalArgumentException("Invalid Character["  leftPos  "] = '"  character  "'");
            todo = todo / 10;
@Constraint(validatedBy = SedolValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class SedolValidator extends ModulusValidator<Sedol> {
    private static final int[] POSITION_WEIGHT = new int[] { 1, 3, 1, 7, 3, 9, 1 };
    protected int weightedValue(int charValue, int leftPos, int rightPos) throws Exception {
    protected int toInt(char character, int leftPos, int rightPos) {
            throw new IllegalArgumentException("Invalid Character["  leftPos  "] = '"  charValue  "'");
@Constraint(validatedBy = VerhoeffValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class VerhoeffValidator implements ConstraintValidator<Verhoeff, String> {
    //@formatter:off
    //@formatter:on
@Pattern(regexp = "^(3[47]\\d{13})$")
@Constraint(validatedBy = {})
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Pattern(regexp = "^(30[0-5]\\d{11}|3095\\d{10}|36\\d{12}|3[8-9]\\d{12})$")
@Constraint(validatedBy = {})
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Pattern(regexp = "^((6011\\d{12})|(64[4-9]\\d{13})|(65\\d{14}))$")
@Constraint(validatedBy = {})
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Pattern(regexp = "^(5[1-5]\\d{14})$")
@Constraint(validatedBy = {})
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Pattern(regexp = "^(4)(\\d{12}|\\d{15})$")
@Constraint(validatedBy = {})
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Constraint(validatedBy = DirectoryValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Constraint(validatedBy = DirectoryValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Constraint(validatedBy = SymlinkValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Constraint(validatedBy = DomainValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
    private static final Pattern DOMAIN_NAME_REGEX =
        Pattern.compile("^(?:"  DOMAIN_LABEL.pattern()  "\\.)(\\p{Alpha}{2,})$");
            return true;
            return true;
        return isValidInfrastructureTld(tld) || isValidGenericTld(tld) || isValidCountryCodeTld(tld);
    private static final List<String> INFRASTRUCTURE_TLDS = asList("arpa", // internet infrastructure
        "root" // diagnostic marker for non-truncated root zone
    private static final List<String> GENERIC_TLDS = asList("aero", // air transport industry
        "asia", // Pan-Asia/Asia Pacific
        "biz", // businesses
        "cat", // Catalan linguistic/cultural community
        "com", // commercial enterprises
        "coop", // cooperative associations
        "info", // informational sites
        "jobs", // Human Resource managers
        "mobi", // mobile products and services
        "museum", // museums, surprisingly enough
        "name", // individuals' sites
        "net", // internet support infrastructure/business
        "org", // noncommercial organizations
        "pro", // credentialed professionals and entities
        "tel", // contact data for businesses and individuals
        "travel", // entities in the travel industry
        "gov", // United States Government
        "edu", // accredited postsecondary US education entities
        "mil", // United States Military
        "int" // organizations established by international treaty
    private static final List<String> COUNTRY_CODE_TLDS = asList("ac", // Ascension Island
        "ad", // Andorra
        "ae", // United Arab Emirates
        "af", // Afghanistan
        "ag", // Antigua and Barbuda
        "ai", // Anguilla
        "al", // Albania
        "am", // Armenia
        "an", // Netherlands Antilles
        "ao", // Angola
        "aq", // Antarctica
        "ar", // Argentina
        "as", // American Samoa
        "at", // Austria
        "au", // Australia (includes Ashmore and Cartier Islands and Coral Sea Islands)
        "aw", // Aruba
        "ax", // Åland
        "az", // Azerbaijan
        "ba", // Bosnia and Herzegovina
        "bb", // Barbados
        "bd", // Bangladesh
        "be", // Belgium
        "bf", // Burkina Faso
        "bg", // Bulgaria
        "bh", // Bahrain
        "bi", // Burundi
        "bj", // Benin
        "bm", // Bermuda
        "bn", // Brunei Darussalam
        "bo", // Bolivia
        "br", // Brazil
        "bs", // Bahamas
        "bt", // Bhutan
        "bv", // Bouvet Island
        "bw", // Botswana
        "by", // Belarus
        "bz", // Belize
        "ca", // Canada
        "cc", // Cocos (Keeling) Islands
        "cd", // Democratic Republic of the Congo (formerly Zaire)
        "cf", // Central African Republic
        "cg", // Republic of the Congo
        "ch", // Switzerland
        "ci", // Côte d'Ivoire
        "ck", // Cook Islands
        "cl", // Chile
        "cm", // Cameroon
        "cn", // China, mainland
        "co", // Colombia
        "cr", // Costa Rica
        "cu", // Cuba
        "cv", // Cape Verde
        "cx", // Christmas Island
        "cy", // Cyprus
        "cz", // Czech Republic
        "de", // Germany
        "dj", // Djibouti
        "dk", // Denmark
        "dm", // Dominica
        "do", // Dominican Republic
        "dz", // Algeria
        "ec", // Ecuador
        "ee", // Estonia
        "eg", // Egypt
        "er", // Eritrea
        "es", // Spain
        "et", // Ethiopia
        "eu", // European Union
        "fi", // Finland
        "fj", // Fiji
        "fk", // Falkland Islands
        "fm", // Federated States of Micronesia
        "fo", // Faroe Islands
        "fr", // France
        "ga", // Gabon
        "gb", // Great Britain (United Kingdom)
        "gd", // Grenada
        "ge", // Georgia
        "gf", // French Guiana
        "gg", // Guernsey
        "gh", // Ghana
        "gi", // Gibraltar
        "gl", // Greenland
        "gm", // The Gambia
        "gn", // Guinea
        "gp", // Guadeloupe
        "gq", // Equatorial Guinea
        "gr", // Greece
        "gs", // South Georgia and the South Sandwich Islands
        "gt", // Guatemala
        "gu", // Guam
        "gw", // Guinea-Bissau
        "gy", // Guyana
        "hk", // Hong Kong
        "hm", // Heard Island and McDonald Islands
        "hn", // Honduras
        "hr", // Croatia (Hrvatska)
        "ht", // Haiti
        "hu", // Hungary
        "id", // Indonesia
        "ie", // Ireland (Éire)
        "il", // Israel
        "im", // Isle of Man
        "in", // India
        "io", // British Indian Ocean Territory
        "iq", // Iraq
        "ir", // Iran
        "is", // Iceland
        "it", // Italy
        "je", // Jersey
        "jm", // Jamaica
        "jo", // Jordan
        "jp", // Japan
        "ke", // Kenya
        "kg", // Kyrgyzstan
        "kh", // Cambodia (Khmer)
        "ki", // Kiribati
        "km", // Comoros
        "kn", // Saint Kitts and Nevis
        "kp", // North Korea
        "kr", // South Korea
        "kw", // Kuwait
        "ky", // Cayman Islands
        "kz", // Kazakhstan
        "la", // Laos (currently being marketed as the official domain for Los Angeles)
        "lb", // Lebanon
        "lc", // Saint Lucia
        "li", // Liechtenstein
        "lk", // Sri Lanka
        "lr", // Liberia
        "ls", // Lesotho
        "lt", // Lithuania
        "lu", // Luxembourg
        "lv", // Latvia
        "ly", // Libya
        "ma", // Morocco
        "mc", // Monaco
        "md", // Moldova
        "me", // Montenegro
        "mg", // Madagascar
        "mh", // Marshall Islands
        "mk", // Republic of Macedonia
        "ml", // Mali
        "mm", // Myanmar
        "mn", // Mongolia
        "mo", // Macau
        "mp", // Northern Mariana Islands
        "mq", // Martinique
        "mr", // Mauritania
        "ms", // Montserrat
        "mt", // Malta
        "mu", // Mauritius
        "mv", // Maldives
        "mw", // Malawi
        "mx", // Mexico
        "my", // Malaysia
        "mz", // Mozambique
        "na", // Namibia
        "nc", // New Caledonia
        "ne", // Niger
        "nf", // Norfolk Island
        "ng", // Nigeria
        "ni", // Nicaragua
        "nl", // Netherlands
        "no", // Norway
        "np", // Nepal
        "nr", // Nauru
        "nu", // Niue
        "nz", // New Zealand
        "om", // Oman
        "pa", // Panama
        "pe", // Peru
        "pf", // French Polynesia With Clipperton Island
        "pg", // Papua New Guinea
        "ph", // Philippines
        "pk", // Pakistan
        "pl", // Poland
        "pm", // Saint-Pierre and Miquelon
        "pn", // Pitcairn Islands
        "pr", // Puerto Rico
        "ps", // Palestinian territories (PA-controlled West Bank and Gaza Strip)
        "pt", // Portugal
        "pw", // Palau
        "py", // Paraguay
        "qa", // Qatar
        "re", // Réunion
        "ro", // Romania
        "rs", // Serbia
        "ru", // Russia
        "rw", // Rwanda
        "sa", // Saudi Arabia
        "sb", // Solomon Islands
        "sc", // Seychelles
        "sd", // Sudan
        "se", // Sweden
        "sg", // Singapore
        "sh", // Saint Helena
        "si", // Slovenia
        "sj", // Svalbard and Jan Mayen Islands Not in use (Norwegian dependencies; see .no)
        "sk", // Slovakia
        "sl", // Sierra Leone
        "sm", // San Marino
        "sn", // Senegal
        "so", // Somalia
        "sr", // Suriname
        "st", // São Tomé and Príncipe
        "su", // Soviet Union (deprecated)
        "sv", // El Salvador
        "sy", // Syria
        "sz", // Swaziland
        "tc", // Turks and Caicos Islands
        "td", // Chad
        "tf", // French Southern and Antarctic Lands
        "tg", // Togo
        "th", // Thailand
        "tj", // Tajikistan
        "tk", // Tokelau
        "tl", // East Timor (deprecated old code)
        "tm", // Turkmenistan
        "tn", // Tunisia
        "to", // Tonga
        "tp", // East Timor
        "tr", // Turkey
        "tt", // Trinidad and Tobago
        "tv", // Tuvalu
        "tw", // Taiwan, Republic of China
        "tz", // Tanzania
        "ua", // Ukraine
        "ug", // Uganda
        "uk", // United Kingdom
        "um", // United States Minor Outlying Islands
        "us", // United States of America
        "uy", // Uruguay
        "uz", // Uzbekistan
        "va", // Vatican City State
        "vc", // Saint Vincent and the Grenadines
        "ve", // Venezuela
        "vg", // British Virgin Islands
        "vi", // U.S. Virgin Islands
        "vn", // Vietnam
        "vu", // Vanuatu
        "wf", // Wallis and Futuna
        "ws", // Samoa (formerly Western Samoa)
        "ye", // Yemen
        "yt", // Mayotte
        "yu", // Serbia and Montenegro (originally Yugoslavia)
        "za", // South Africa
        "zm", // Zambia
        "zw" // Zimbabwe
    private static final List<String> LOCAL_TLDS = asList("localhost", // RFC2606 defined
        "localdomain" // Also widely used as localhost.localdomain
    );
@Constraint(validatedBy = InetAddressValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
    private static final Pattern IPV4_PATTERN =
        Pattern.compile("^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\."  "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\."
             "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\."  "([01]?\\d\\d?|2[0-4]\\d|25[0-5])$");
        freemarker.setNumberFormat("0.######"); // prevent locale-sensitive number format
    public String toJSON(Collection<MetaBean> metaBeans) throws IOException, TemplateException {
    public void toJSON(Collection<MetaBean> metaBeans, Writer out) throws IOException, TemplateException {
@Target({ ElementType.TYPE })

            globalExecutableTypes =
                Collections.unmodifiableSet(convertToRuntimeTypes(bootstrap.getDefaultValidatedExecutableTypes()));
            validBean = globalExecutableTypes.contains(ExecutableType.IMPLICIT)
                || globalExecutableTypes.contains(ExecutableType.ALL);
            validGetterMethods = globalExecutableTypes.contains(ExecutableType.ALL)
                || globalExecutableTypes.contains(ExecutableType.GETTER_METHODS);
    private static Set<ExecutableType> convertToRuntimeTypes(
        final Set<ExecutableType> defaultValidatedExecutableTypes) {
                        || hasValidationAnnotation(annotatedType.getMethods())
                        || hasValidationAnnotation(annotatedType.getConstructors())
                        || classConstraints != null && (validBean && classConstraints.isBeanConstrained()
                            || validConstructors && !classConstraints.getConstrainedConstructors().isEmpty()
                            || validBusinessMethods
                                && !classConstraints.getConstrainedMethods(MethodType.NON_GETTER).isEmpty()
                            || validGetterMethods
                                && !classConstraints.getConstrainedMethods(MethodType.GETTER).isEmpty())) {
    private static <A> boolean hasValidationAnnotation(
        final Collection<? extends AnnotatedCallable<? super A>> methods) {
        private Releasable(final CreationalContext<T> context, final InjectionTarget<T> injectionTarget,
            final T instance) {
        final MethodDescriptor constraintsForMethod = validator.getConstraintsForClass(targetClass)
            .getConstraintsForMethod(method.getName(), method.getParameterTypes());
                    final AnnotatedType<?> annotatedType =
                        CDI.current().getBeanManager().createAnnotatedType(constructor.getDeclaringClass());
                    final ValidateOnExecution annotation = annotatedConstructor != null
                        ? annotatedConstructor.getAnnotation(ValidateOnExecution.class) : targetClass
                            .getConstructor(constructor.getParameterTypes()).getAnnotation(ValidateOnExecution.class);
                        constructorValidated = types.contains(ExecutableType.CONSTRUCTORS)
                            || types.contains(ExecutableType.IMPLICIT) || types.contains(ExecutableType.ALL);
                        ClassHelper.fillFullClassHierarchyAsList(new LinkedList<Class<?>>(), targetClass);
                                || !asList(method.getGenericParameterTypes())
                                    .equals(asList(m.getJavaMember().getGenericParameterTypes()))) {
                    final AnnotatedType<?> annotatedType =
                        CDI.current().getBeanManager().createAnnotatedType(targetClass);
        return isGetter(method) ? config.contains(ExecutableType.GETTER_METHODS)
            : config.contains(ExecutableType.NON_GETTER_METHODS);
    }
        injectionPoints = Collections.singleton(InjectionPoint.class
            .cast(new BValInterceptorInjectionPoint(this, injectionTarget.getInjectionPoints().iterator().next())));
public abstract class EmptyAnnotationLiteral<T extends Annotation> extends AnnotationLiteral<T> {
    protected EmptyAnnotationLiteral() {
    public Class<? extends Annotation> annotationType() {
        if (annotationType == null) {
    public int hashCode() {
    public boolean equals(final Object other) {
        return Annotation.class.isInstance(other)
            && Annotation.class.cast(other).annotationType().equals(annotationType());
    private Class<T> getAnnotationType(Class<?> definedClazz) {
        if (superClazz.equals(Object.class)) {
        } else if (superClazz instanceof ParameterizedType) {
            if (actualArgs.length == 1) {
                if (type instanceof Class) {
                } else {
            } else {
        } else {
public class ValidatorBean implements Bean<Validator>, PassivationCapable {
public class ValidatorFactoryBean implements Bean<ValidatorFactory>, PassivationCapable {
    }
@Target({ METHOD, FIELD, ANNOTATION_TYPE, PARAMETER })
@Constraint(validatedBy = { NotEmptyValidatorForCollection.class, NotEmptyValidatorForMap.class,
    NotEmptyValidatorForString.class, NotEmptyValidator.class })
@Target({ METHOD, FIELD, ANNOTATION_TYPE, PARAMETER })
    }
    }
    }
    }
    }
    }
    }
    }
    }
    public String interpolate(final String message, final Map<String, Object> annotationParameters,
        final Object validatedValue) {
                    variables.setVariable(var.getKey(),
                        EXPRESSION_FACTORY.createValueExpression(var.getValue(), Object.class));
                variables.setVariable("validatedValue",
                    EXPRESSION_FACTORY.createValueExpression(validatedValue, Object.class));
                return EXPRESSION_FACTORY.createValueExpression(context, message.replace("#{", "\\#{"), String.class)
                    .getValue(context).toString();
        public Formatter format(final String format, final Object... args) {
    public AnnotationConstraintBuilder(Class<? extends ConstraintValidator<A, ?>>[] validatorClasses, A annotation,
        Class<?> owner, AccessStrategy access, ConstraintTarget target) {
            new ConstraintValidation<A>(validatorClasses, annotation, owner, access, reportFromComposite, target);
                        throw new ConstraintDefinitionException(
                            "constraints parameters can't start with valid: "  name);
                            if (!TypeUtils.isAssignable(method.getReturnType(),
                                ConstraintAnnotationAttributes.MESSAGE.getType())) {
                                throw new ConstraintDefinitionException("Return type for message() must be of type "
                                     ConstraintAnnotationAttributes.MESSAGE.getType());
                        constraintValidation.getAttributes().put(name,
                            method.invoke(constraintValidation.getAnnotation()));
                    log.log(Level.WARNING,
                        String.format("Error processing annotation: %s ", constraintValidation.getAnnotation()), e);
            throw new ConstraintDefinitionException(
                "Annotation "  annotationType.getName()  " has no message method");
            throw new ConstraintDefinitionException(
                "Annotation "  annotationType.getName()  " has no payload method");
                    || (validationTarget.b > 0 && validationTargetInherited.a > 0 && validationTarget.a == 0)) {
            final SupportedValidationTarget supportedAnnotationTypes =
                validator.getAnnotation(SupportedValidationTarget.class);
            throw new ConstraintDefinitionException(
                "pure cross parameter constraints shouldn't get validationAppliesTo attribute");
            throw new ConstraintDefinitionException(
                "cross parameter AND generic constraints should get validationAppliesTo attribute");
            throw new ConstraintDefinitionException(
                "pure generic constraints shouldn't get validationAppliesTo attribute");
    private void buildValidationAppliesTo(final Method method)
        throws InvocationTargetException, IllegalAccessException {
        if (!TypeUtils.isAssignable(method.getReturnType(),
            ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getType())) {
            throw new ConstraintDefinitionException(
                "Return type for groups() must be of type "  ConstraintAnnotationAttributes.GROUPS.getType());
            throw new ConstraintDefinitionException(
                "Return type for payload() must be of type "  ConstraintAnnotationAttributes.PAYLOAD.getType());
                    throw new ConstraintDeclarationException(
                        "Wrong OverridesAttribute declaration for "  generalOverride.constraintType
                             ", it needs a defined index when there is a list of constraints");
        AccessStrategy access, AppendValidation appender, boolean reflection)
        throws IllegalAccessException, InvocationTargetException {
    private <A extends Annotation> boolean applyConstraint(A annotation,
            new AnnotationConstraintBuilder<A>(constraintClasses, annotation, owner, access, null);
        return Boolean
            .parseBoolean(factory.getProperties().get(ApacheValidatorConfiguration.Properties.TREAT_MAPS_LIKE_BEANS));
                validatorFactoryClass =
                    Reflection.toClass(validatorFactoryClassname).asSubclass(ValidatorFactory.class);
        if (Boolean.parseBoolean(getProperties().get(ApacheValidatorConfiguration.Properties.ENABLE_INTROSPECTOR))) {
            StringUtils.split(getProperties().get(ApacheValidatorConfiguration.Properties.METABEAN_FACTORY_CLASSNAMES));
                final Class<? extends MetaBeanFactory> factoryClass =
                    (Class<? extends MetaBeanFactory>) loadClass(clsName);
            Boolean.parseBoolean(getProperties().get(ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML));
    public final void setTraversableResolver(TraversableResolver traversableResolver) {
    public final void setConstraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory) {

        if (!(type.isInterface() || Modifier.isAbstract(type.getModifiers()))) {
    public void addMetaConstraint(final Class<?> beanClass, final MetaConstraint<?, ?> metaConstraint) {
    public <T> List<MetaConstraint<T, ? extends Annotation>> getMetaConstraints(Class<T> beanClass) {
        return array == null || array.length == 0 ? ObjectUtils.EMPTY_CLASS_ARRAY : array.clone();
        if (Boolean.parseBoolean(getProperties().get(ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML))) {
                new XMLMetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));

    private static final CopyOnWriteArraySet<ConstraintValidation<?>> NO_CONSTRAINTS =
        new CopyOnWriteArraySet<ConstraintValidation<?>>();
                        edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()),
                            new Group(convertGroup.to())));
                    edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()),
                        new Group(convertGroup.to())));
                edesc.addGroupConversion(
                    new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
            edesc.addGroupConversion(
                new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
        final MethodDescriptor methodDescriptor =
            meta.methodConstraints.get(methodName  Arrays.toString(parameterTypes));
        if (methodDescriptor != null
            && (methodDescriptor.hasConstrainedParameters() || methodDescriptor.hasConstrainedReturnValue())) {
    private static Collection<MethodDescriptor> filter(final Set<MethodDescriptor> containedMethods,
        final MethodType type) {
                d.getParameterDescriptors().isEmpty() && (d.getName().startsWith("get") || (d.getName().startsWith("is")
                    && boolean.class.equals(d.getReturnValueDescriptor().getElementClass())));
            case GETTER:
                if (getter) {
                    list.add(d);
                }
                break;
            case NON_GETTER:
                if (!getter) {
                    list.add(d);
                }
        private final Map<String, ConstructorDescriptor> contructorConstraints =
            new HashMap<String, ConstructorDescriptor>();
        private ExecutableMeta(final ApacheFactoryContext factoryContext, final MetaBean metaBean1,
            final Collection<ConstraintDescriptor<?>> constraintDescriptors) {
                final boolean isInnerClass = cons.getDeclaringClass().getEnclosingClass() != null
                    && !Modifier.isStatic(cons.getDeclaringClass().getModifiers());
                        final ParameterDescriptorImpl paramDesc =
                            new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx));
                            consDesc.getParameterDescriptors()
                                .add(new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx)));
                            consDesc.addValidations(
                                processAnnotations(consDesc, paramAnnos, access, idx, names.get(idx)).getValidations());
                if (annotationIgnores.isIgnoreAnnotationOnCrossParameter(cons)
                    && consDesc.getCrossParameterDescriptor() != null) {
                consDesc.setReturnValueDescriptor(
                    new ReturnValueDescriptorImpl(metaBean, returnType, NO_CONSTRAINTS, consDesc.isCascaded()));
            final ReturnValueDescriptorImpl returnValueDescriptor =
                ReturnValueDescriptorImpl.class.cast(consDesc.getReturnValueDescriptor());
        private void processAnnotations(final Method mtd, final InvocableElementDescriptor consDesc,
            final Class<?> clazz, final Annotation anno) throws InvocationTargetException, IllegalAccessException {
                final List<ConstraintValidation<?>> list =
                    removeFromListValidationAppliesTo(validations.getValidations(), ConstraintTarget.PARAMETERS);
                ReturnValueDescriptorImpl returnValueDescriptor =
                    ReturnValueDescriptorImpl.class.cast(consDesc.getReturnValueDescriptor());
            if (mtd == null
                || !factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnCrossParameter(mtd)) {
                final List<ConstraintValidation<?>> list =
                    removeFromListValidationAppliesTo(validations.getValidations(), ConstraintTarget.RETURN_VALUE);
                    CrossParameterDescriptorImpl.class.cast(consDesc.getCrossParameterDescriptor())
                        .getMutableConstraintDescriptors().addAll(list);
        private static List<ConstraintValidation<?>> removeFromListValidationAppliesTo(
            final List<ConstraintValidation<?>> validations, final ConstraintTarget constraint) {
            final List<Class<?>> classHierarchy =
                ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), current);
                final boolean propertyAccessor = method.getParameterTypes().length == 0
                    && (method.getName().startsWith("get") && !Void.TYPE.equals(method.getReturnType())
                        || method.getName().startsWith("is") && Boolean.TYPE.equals(method.getReturnType()));
                    final Method overridden =
                        Reflection.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
                            final MethodDescriptor parentDec =
                                factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass())
                                    .getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
                                ensureNoParameterConstraint(InvocableElementDescriptor.class.cast(parentDec),
                                    "Parameter constraints can't be defined for parallel interfaces/parents");
                            ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDec,
                                "Return value constraints should be the same for parent and children");
                        final MethodDescriptor parentDesc =
                            factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass())
                                .getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
                        ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDesc,
                            "Return value constraints should be at least the same for parent and children");
                            final Iterator<ParameterDescriptor> parentPd =
                                parentDesc.getParameterDescriptors().iterator();
                                    throw new ConstraintDeclarationException(
                                        "child shouldn't get more constraint than parent");
                                    throw new ConstraintDeclarationException(
                                        "child shouldn't get more constraint than parent");
                        ensureNoConvertGroup(itfWithThisMethod.iterator().next(),
                            "ConvertGroup can't be used in interface AND parent class");
                        final Method overridden =
                            Reflection.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
                    if (returnValid > 1
                        && !(interfaces.length == returnValid && method.getAnnotation(Valid.class) == null)) {
                        throw new ConstraintDeclarationException(
                            "@Valid on returned value can't be set more than once");
                    final MetaProperty prop =
                        metaBean.getProperty(Introspector.decapitalize(method.getName().substring(3)));
                final BeanDescriptorImpl desc =
                    BeanDescriptorImpl.class.cast(factoryContext.getValidator().getConstraintsForClass(parent));
        private void ensureNoReturnValueAddedInChild(final ReturnValueDescriptor returnValueDescriptor,
            final MethodDescriptor parentMtdDesc, final String msg) {
            if (parentReturnDesc.isCascaded() && !returnValueDescriptor.isCascaded() || parentReturnDesc
                .getConstraintDescriptors().size() > returnValueDescriptor.getConstraintDescriptors().size()) {
        private static void ensureNoParameterConstraint(final InvocableElementDescriptor constraintsForMethod,
            final String msg) {
        private void processMethod(final Method method, final MethodDescriptorImpl methodDesc)
            throws InvocationTargetException, IllegalAccessException {
                        final ParameterDescriptorImpl parameterDescriptor =
                            new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx));
            if (annotationIgnores.isIgnoreAnnotationOnCrossParameter(method)
                && methodDesc.getCrossParameterDescriptor() != null) {
        private AppendValidationToList processAnnotations(InvocableElementDescriptor methodDesc,
            Annotation[] paramAnnos, AccessStrategy access, int idx, String name)
                    from = new Group[] { new Group(cg.from()) };
                    to = new Group[] { new Group(cg.to()) };
                        if (existing.getAnnotation().annotationType()
                            .equals(validation.getAnnotation().annotationType())) { // TODO: make it a bit finer
            final AccessStrategy access, final AppendValidation validations)
            throws InvocationTargetException, IllegalAccessException {
                    desc.addGroupConversion(
                        new GroupConversionDescriptorImpl(new Group(cg.from()), new Group(cg.to())));
        private <A extends Annotation> void processConstraint(final A annotation, final InvocableElementDescriptor desc,
            final AccessStrategy access, final AppendValidation validations)
                final ConstraintAnnotationAttributes.Worker<? extends Annotation> worker =
                    ConstraintAnnotationAttributes.VALUE.analyze(annotation.annotationType());
                annotationProcessor.processAnnotation(annotation, null,
                    Reflection.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations, true);
        final String constraintValidatorFactoryClassName, final String messageInterpolatorClassName,
        final String traversableResolverClassName, final String parameterNameProviderClassName,
        final Set<String> constraintMappingResourcePaths, final boolean executableValidationEnabled,
        final Set<ExecutableType> defaultValidatedExecutableTypes, final Map<String, String> properties) {
    <T> Set<javax.validation.ConstraintViolation<T>> validateProperty(T object, String propertyName, boolean cascade,
        Class<?>... groups);
    <T> Set<javax.validation.ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value,
        boolean cascade, Class<?>... groups);
    private <T> Set<ConstraintViolation<T>> validateBeanWithGroups(final GroupValidationContext<T> context,
        final Groups sequence) {

                    final List<Group> ownerDefaultGroups =
                        context.getMetaBean().getFeature("{GroupSequence:"  owner.getCanonicalName()  "}");
                final Groups propertyGroup = groupsComputer.computeGroups(new Class<?>[] { mappedGroup.getGroup() });
        for (final PropertyDescriptor prop : getConstraintsForClass(context.getMetaBean().getBeanClass())
            .getConstrainedProperties()) {
                    checkValidationAppliesTo(constraintValidation.getValidationAppliesTo(),
                        ConstraintTarget.PARAMETERS);
                    checkValidationAppliesTo(constraintValidation.getValidationAppliesTo(),
                        ConstraintTarget.RETURN_VALUE);
    private void validateCascadedBean(final GroupValidationContext<?> context, final MetaProperty prop,
        final Groups groups) {
            //            Class[] groups = prop.getFeature(JsrFeatures.Property.REF_GROUPS);
                        ValidationHelper.validateContext(context, new JsrValidationCallback(context),
                            factoryContext.isTreatMapsLikeBeans());
    protected <T> GroupValidationContext<T> createContext(MetaBean metaBean, T object, Class<T> objectClass,
        Class<?>... groups) {
        final GroupValidationContextImpl<T> context = new GroupValidationContextImpl<T>(listener,
            factoryContext.getMessageInterpolator(), factoryContext.getTraversableResolver(),
            factoryContext.getParameterNameProvider(), factoryContext.getConstraintValidatorFactory(), metaBean);
    protected <T> GroupValidationContext<T> createInvocableContext(MetaBean metaBean, T object, Class<T> objectClass,
        Class<?>... groups) {
        final GroupValidationContextImpl<T> context = new GroupValidationContextImpl<T>(listener,
            factoryContext.getMessageInterpolator(), factoryContext.getTraversableResolver(),
            factoryContext.getParameterNameProvider(), factoryContext.getConstraintValidatorFactory(), metaBean);
        if (Collections.singletonList(Group.DEFAULT).equals(computedGroup.getGroups())
            && metaBean.getFeature(JsrFeatures.Bean.GROUP_SEQUENCE) != null) {
            final List<? extends Group> sequenceGroups =
                List.class.cast(metaBean.getFeature(JsrFeatures.Bean.GROUP_SEQUENCE));
    public <T> Set<ConstraintViolation<T>> validateConstructorParameters(Constructor<? extends T> constructor,
        Object[] parameterValues, Class<?>... gps) {
        final ConstructorDescriptorImpl constructorDescriptor = ConstructorDescriptorImpl.class
            .cast(getConstraintsForClass(declaringClass).getConstraintsForConstructor(constructor.getParameterTypes()));
                checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()),
                    ConstraintTarget.PARAMETERS);
                checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()),
                    ConstraintTarget.IMPLICIT);
        return validateInvocationParameters(constructor, parameterValues, constructorDescriptor, gps,
            new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(),
                Arrays.asList(constructor.getParameterTypes())),
            null);
    private <T> Set<ConstraintViolation<T>> validateInvocationParameters(final Member invocable,
        final Object[] parameterValues, final InvocableElementDescriptor constructorDescriptor, final Class<?>[] gps,
        final NodeImpl rootNode, final Object rootBean) {
        final GroupValidationContext<ConstraintValidationListener<?>> parametersContext = createInvocableContext(
            constructorDescriptor.getMetaBean(), rootBean, Class.class.cast(invocable.getDeclaringClass()), gps);
        final GroupValidationContext<Object> crossParameterContext = createContext(constructorDescriptor.getMetaBean(),
            rootBean, Class.class.cast(invocable.getDeclaringClass()), gps);
        final ElementDescriptorImpl crossParamDescriptor =
            ElementDescriptorImpl.class.cast(constructorDescriptor.getCrossParameterDescriptor());
                final ParameterDescriptorImpl paramDesc =
                    ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
            if (gps.length == 0 && parametersContext.getListener().getConstraintViolations().size()
                 crossParameterContext.getListener().getConstraintViolations().size() > 0) {
                final ParameterDescriptorImpl paramDesc =
                    ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
                    ValidationHelper.validateContext(parametersContext, new JsrValidationCallback(parametersContext),
                        factoryContext.isTreatMapsLikeBeans());
                    final ParameterDescriptorImpl paramDesc =
                        ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
                        final ConstraintValidation<?> validation =
                            ConstraintValidation.class.cast(constraintDescriptor);
                if (parametersContext.getListener().getConstraintViolations().size()
                     crossParameterContext.getListener().getConstraintViolations().size() > 0) {
                    final ParameterDescriptorImpl paramDesc =
                        ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
                        initMetaBean(parametersContext, factoryContext.getMetaBeanFinder(),
                            parameterValues[i].getClass());
                        ValidationHelper.validateContext(parametersContext,
                            new JsrValidationCallback(parametersContext), factoryContext.isTreatMapsLikeBeans());
                initMetaBean(parametersContext, factoryContext.getMetaBeanFinder(),
                    parametersContext.getValidatedValue().getClass());
                    ValidationHelper.validateContext(parametersContext, new JsrValidationCallback(parametersContext),
                        factoryContext.isTreatMapsLikeBeans());
                        ValidationHelper.validateContext(parametersContext,
                            new JsrValidationCallback(parametersContext), factoryContext.isTreatMapsLikeBeans());
                initMetaBean(crossParameterContext, factoryContext.getMetaBeanFinder(),
                    crossParameterContext.getValidatedValue().getClass());
                    ValidationHelper.validateContext(crossParameterContext,
                        new JsrValidationCallback(crossParameterContext), factoryContext.isTreatMapsLikeBeans());
                        ValidationHelper.validateContext(crossParameterContext,
                            new JsrValidationCallback(crossParameterContext), factoryContext.isTreatMapsLikeBeans());
        final Set<ConstraintViolation<T>> parameterViolations =
            Set.class.cast(parametersContext.getListener().getConstraintViolations());
        final Set<ConstraintViolation<T>> crossParameterViolations =
            Set.class.cast(crossParameterContext.getListener().getConstraintViolations());
    private static void checkValidationAppliesTo(final Collection<? extends ElementDescriptor> descriptors,
        final ConstraintTarget forbidden) {
    private static void checkValidationAppliesTo(final Set<ConstraintDescriptor<?>> constraintDescriptors,
        final ConstraintTarget forbidden) {
    public <T> Set<ConstraintViolation<T>> validateConstructorReturnValue(final Constructor<? extends T> constructor,
        final T createdObject, final Class<?>... gps) {
        final ConstructorDescriptorImpl methodDescriptor = ConstructorDescriptorImpl.class
            .cast(getConstraintsForClass(declaringClass).getConstraintsForConstructor(constructor.getParameterTypes()));
        return validateReturnedValue(
            new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(),
                Arrays.asList(constructor.getParameterTypes())),
            createdObject, declaringClass, methodDescriptor, gps, null);
    private <T> Set<ConstraintViolation<T>> validateReturnedValue(final NodeImpl rootNode, final T createdObject,
        final Class<?> clazz, final InvocableElementDescriptor methodDescriptor, final Class<?>[] gps,
        final Object rootBean) {
        final ElementDescriptorImpl returnedValueDescriptor =
            ElementDescriptorImpl.class.cast(methodDescriptor.getReturnValueDescriptor());
        final Set<ConstraintDescriptor<?>> returnedValueConstraints =
            returnedValueDescriptor.getConstraintDescriptors();
        final GroupValidationContext<T> context = createInvocableContext(methodDescriptor.getMetaBean(), createdObject,
            Class.class.cast(Proxies.classFor(clazz)), gps);
                ValidationHelper.validateContext(context, new JsrValidationCallback(context),
                    factoryContext.isTreatMapsLikeBeans());
                    ValidationHelper.validateContext(context, new JsrValidationCallback(context),
                        factoryContext.isTreatMapsLikeBeans());
    public <T> Set<ConstraintViolation<T>> validateParameters(T object, Method method, Object[] parameterValues,
        Class<?>... groups) {
        if (methodDescriptor == null
            || !(methodDescriptor.hasConstrainedParameters() || methodDescriptor.hasConstrainedReturnValue())) { // no constraint
    public <T> Set<ConstraintViolation<T>> validateReturnValue(T object, Method method, Object returnValue,
        Class<?>... groups) {
            checkValidationAppliesTo(methodDescriptor.getReturnValueDescriptor().getConstraintDescriptors(),
                ConstraintTarget.RETURN_VALUE);
        final Set<ConstraintViolation<T>> result = Set.class.cast(validateReturnedValue(
            new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())), returnValue,
            object.getClass(), methodDescriptor, groups, object));
        return MethodDescriptorImpl.class
            .cast(BeanDescriptorImpl.class.cast(getConstraintsForClass(Proxies.classFor(method.getDeclaringClass())))
    private <T> void initMetaBean(final GroupValidationContext<T> context, final MetaBeanFinder metaBeanFinder,
        final Class<?> directValueClass) {
    protected BootstrapConfiguration bootstrapConfiguration;
    private Collection<BValExtension.Releasable<?>> releasables =
        new CopyOnWriteArrayList<BValExtension.Releasable<?>>();
    public ConfigurationImpl constraintValidatorFactory(ConstraintValidatorFactory constraintFactory) {
        return doBuildValidatorFactory();
        return ValidationParser.processValidationConfig(getProperties().get(Properties.VALIDATION_XML_PATH), this,
            ignoreXmlConfiguration);
        if (constraintValidatorFactory == defaultConstraintValidatorFactory
            && constraintValidatorFactoryClass != null) {
                if (constraintValidatorFactory == defaultConstraintValidatorFactory
                    && constraintValidatorFactoryClass != null) {
        }
    private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Method>> METHOD_BY_NAME_AND_CLASS =
        new ConcurrentHashMap<Class<?>, ConcurrentMap<String, Method>>();

        Class<A> annotationType) {
        this(descriptor.getAnnotation(), descriptor.getGroups(), descriptor.getPayload(),
            descriptor.getConstraintValidatorClasses(), descriptor.getAttributes(),
            descriptor.getComposingConstraints(), descriptor.isReportAsSingleViolation(),
            descriptor.getValidationAppliesTo(), descriptor.getMessageTemplate());
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        if (reportAsSingleViolation != that.reportAsSingleViolation) {
            return false;
        }
        if (annotation != null ? !annotation.equals(that.annotation) : that.annotation != null) {
            return false;
        }
        if (groups != null ? !groups.equals(that.groups) : that.groups != null) {
            return false;
        }
        if (payload != null ? !payload.equals(that.payload) : that.payload != null) {
            return false;
        }
        if (constraintValidatorClasses != null ? !constraintValidatorClasses.equals(that.constraintValidatorClasses)
            : that.constraintValidatorClasses != null) {
            return false;
        }
        if (attributes != null ? !attributes.equals(that.attributes) : that.attributes != null) {
            return false;
        }
        if (composingConstraints != null ? !composingConstraints.equals(that.composingConstraints)
            : that.composingConstraints != null) {
            return false;
        }
        if (validationAppliesTo != that.validationAppliesTo) {
            return false;
        }
                for (Group defaultGroupMember : metaBean.<List<Group>> getFeature(JsrFeatures.Bean.GROUP_SEQUENCE)) {
        if (findInScopes.size() == Scope.values().length) {
                case LOCAL_ELEMENT:
                    if (isOwner) {
                        return true;
                    }
                    break;
                case HIERARCHY:
                    if (!isOwner) {
                        return true;
                    }
                    break;
    public ConstraintValidation(Class<? extends ConstraintValidator<T, ?>>[] validatorClasses, T annotation,
        Class<?> owner, AccessStrategy access, boolean reportFromComposite, ConstraintTarget target) {
                        validator = getConstraintValidator(context.getConstraintValidatorFactory(), annotation,
                            validatorClasses, owner, access);
        ConstraintValidatorFactory factory, A annotation,
            final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validatorTypes =
                getValidatorsTypes(constraintClasses);
            final Collection<Class<? extends ConstraintValidator<A, ?>>> key =
                validatorTypes.get(assignableTypes.get(0));
            final ConstraintValidator<A, ? super T> validator =
                (ConstraintValidator<A, ? super T>) factory.getInstance(key.iterator().next());
    private <A extends Annotation> void reduceTarget(
        final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validator,
        final AccessStrategy access) {
        for (final Map.Entry<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> entry : validator
            .entrySet()) {
                    final boolean isParameter =
                        ParameterAccess.class.isInstance(access) || ParametersAccess.class.isInstance(access);
            final String message = "No validator could be found for type "  stringForType(targetType)  ". See: @"
                 anno.annotationType().getSimpleName()  " at "  stringForLocation(owner, access);
            throw new UnexpectedTypeException(
                String.format("Ambiguous validators for type %s. See: @%s at %s. Validators are: %s",
                    stringForType(targetType), anno.annotationType().getSimpleName(), stringForLocation(owner, access),
                    StringUtils.join(types, ", ")));
            return ((Class<?>) clazz).isArray() ? ((Class<?>) clazz).getComponentType().getName()  "[]"
                : ((Class<?>) clazz).getName();
            Type validatedType = TypeUtils.getTypeArguments(validatorType, ConstraintValidator.class)
                .get(ConstraintValidator.class.getTypeParameters()[1]);
                throw new ConstraintDefinitionException(
                    "Incorrect validator ["  validator.getClass().getCanonicalName()  "] for annotation "
                         annotation.annotationType().getCanonicalName(),
                    e);
        return validatorClasses == null ? Collections.<Class<? extends ConstraintValidator<T, ?>>> emptyList()
            : Arrays.asList(validatorClasses);
    private void addError(String messageTemplate, Path propPath, ValidationContext<?> context) {
                    gcontext.getMessageResolver().interpolate(messageTemplate, (MessageInterpolator.Context) gcontext);
            } else {
                message = gcontext.getMessageResolver().interpolate(messageTemplate, null);
            if (propPath == null)
                propPath = gcontext.getPropertyPath();
            if (context.getMetaProperty() == null)
                value = context.getBean();
            else
                value = context.getPropertyValue();
                && (ElementKind.CROSS_PARAMETER.equals(elementKind) || ElementKind.PARAMETER.equals(elementKind))
                && (it.hasNext() && it.next() != null && it.hasNext() && it.next() != null && !it.hasNext())) { // means inherited validation use real value
        constraintViolations.add(new ConstraintViolationImpl<T>(messageTemplate, message, rootBean, leaf, propPath,
            value, descriptor, rootBeanType, elementType, returnValue, parameters));

        if (endOutMostReportAsSingle) {
    private final List<ValidationListener.Error> errorMessages = new LinkedList<ValidationListener.Error>();
        ConstraintValidation<?> aConstraintValidation) {
    public ConstraintViolationBuilder buildConstraintViolationWithTemplate(String messageTemplate) {
        implements ConstraintValidatorContext.ConstraintViolationBuilder {
        ConstraintViolationBuilderImpl(ConstraintValidatorContextImpl contextImpl, String template, PathImpl path) {
            final List<String> parameters =
                parent.validationContext.getParameterNameProvider().getParameterNames(method);
                "At least one custom message must be created if the default error message gets disabled.");
        List<ValidationListener.Error> returnedErrorMessages = new ArrayList<ValidationListener.Error>(errorMessages);
            returnedErrorMessages.add(new ValidationListener.Error(getDefaultConstraintMessageTemplate(),
                validationContext.getPropertyPath(), null));
        result = prime * result  ((this.bean == null) ? 0 : this.bean.hashCode());
        result = prime * result  ((this.path == null) ? 0 : this.path.hashCode());
        result = prime * result  ((this.constraintValidator == null) ? 0 : this.constraintValidator.hashCode());
        Path propertyPath, Object value, ConstraintDescriptor<?> constraintDescriptor, Class<T> rootBeanClass,
        ElementType elementType, Object returnValue, Object[] parameters) {
        return "ConstraintViolationImpl{"  "rootBean="  rootBean  ", propertyPath='"  propertyPath  '\''
             ", message='"  message  '\''  ", leafBean="  leafBean  ", value="  value  '}';
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        if (constraintDescriptor != null ? !constraintDescriptor.equals(that.constraintDescriptor)
            : that.constraintDescriptor != null)
        if (elementType != that.elementType)
            return false;
        if (leafBean != null ? !leafBean.equals(that.leafBean) : that.leafBean != null)
            return false;
        if (message != null ? !message.equals(that.message) : that.message != null)
            return false;
        if (!Arrays.equals(parameters, that.parameters))
            return false;
        if (propertyPath != null ? !propertyPath.equals(that.propertyPath) : that.propertyPath != null)
            return false;
        if (returnValue != null ? !returnValue.equals(that.returnValue) : that.returnValue != null)
            return false;
        if (rootBean != null ? !rootBean.equals(that.rootBean) : that.rootBean != null)
            return false;
        if (value != null ? !value.equals(that.value) : that.value != null)
            return false;
    implements ConstructorDescriptor, ProcedureDescriptor {
    private final Collection<BValExtension.Releasable<?>> releasables =
        new CopyOnWriteArrayList<BValExtension.Releasable<?>>();
    private final Map<Locale, ResourceBundle> userBundlesMap = new ConcurrentHashMap<Locale, ResourceBundle>();
            ev = MessageEvaluator.class
                .cast(getClass().getClassLoader().loadClass("org.apache.bval.el.ELFacade").newInstance());
        return interpolateMessage(message, context.getConstraintDescriptor().getAttributes(), locale,
            context.getValidatedValue());
    private String interpolateMessage(String message, Map<String, Object> annotationParameters, Locale locale,
        Object validatedValue) {
            userBundleResolvedMessage = replaceVariables(resolvedMessage, userResourceBundle, locale, true);
            if (evaluatedDefaultBundleOnce && !hasReplacementTakenPlace(userBundleResolvedMessage, resolvedMessage)) {
            resolvedMessage = replaceVariables(userBundleResolvedMessage, defaultResourceBundle, locale, false);
        resolvedMessage =
            resolvedMessage.replace("\\{", "{").replace("\\}", "}").replace("\\\\", "\\").replace("\\$", "$");
            rb = loadBundle(classLoader, locale, USER_VALIDATION_MESSAGES  " not found by thread local classloader");
            rb = loadBundle(getClass().getClassLoader(), locale,
                USER_VALIDATION_MESSAGES  " not found by validator classloader");
                log.log(Level.FINEST, String.format("%s not found. Delegating to %s", USER_VALIDATION_MESSAGES,
                    DEFAULT_VALIDATION_MESSAGES));
    private ResourceBundle loadBundle(ClassLoader classLoader, Locale locale, String message) {
    private String replaceVariables(String message, ResourceBundle bundle, Locale locale, boolean recurse) {
    private String replaceAnnotationAttributes(final String message, final Map<String, Object> annotationParameters) {
    private String resolveParameter(String parameterName, ResourceBundle bundle, Locale locale, boolean recurse) {
        if (bundle == null) {
        if (bundle == null) {
    private static final String SPI_CFG = "META-INF/services/javax.validation.spi.ValidationProvider";
                                providers
                                    .add(Reflection.newInstance(providerType.asSubclass(ValidationProvider.class)));
                                throw new ValidationException(
                                    "Failed to load provider "  line  " configured in file "  url, e);
    private final Set<GroupConversionDescriptor> groupConversions =
        new CopyOnWriteArraySet<GroupConversionDescriptor>();
    @SuppressWarnings({ "unchecked", "rawtypes" })
        return constraintDescriptors.isEmpty() ? Collections.<ConstraintDescriptor<?>> emptySet()
            : Collections.unmodifiableSet(constraintDescriptors);


        result = prime * result  ((this.bean == null) ? 0 : this.bean.hashCode());
        result = prime * result  ((this.group == null) ? 0 : this.group.hashCode());
public interface GroupValidationContext<T> extends ValidationContext<ConstraintValidationListener<T>> {

final class GroupValidationContextImpl<T> extends BeanValidationContext<ConstraintValidationListener<T>>
    implements GroupValidationContext<T>, MessageInterpolator.Context {
        TraversableResolver traversableResolver, ParameterNameProvider parameterNameProvider,
        ConstraintValidatorFactory constraintValidatorFactory, MetaBean rootMetaBean) {
    private static final CopyOnWriteArraySet<ConstraintValidation<?>> NO_CONSTRAINTS =
        new CopyOnWriteArraySet<ConstraintValidation<?>>();
    protected InvocableElementDescriptor(final MetaBean metaBean, final Class<?> elementClass,
        final Validation[] validations) {
        return getReturnValueDescriptor().isCascaded()
            || !getReturnValueDescriptor().getConstraintDescriptors().isEmpty();
    private void processClass(Class<?> beanClass, MetaBean metabean)
        throws IllegalAccessException, InvocationTargetException {
            annotationProcessor.processAnnotations(null, beanClass, beanClass, null,
                new AppendValidationToMeta(metabean));
    private void addXmlConstraints(Class<?> beanClass, MetaBean metabean)
        throws IllegalAccessException, InvocationTargetException {
            } else if (access.getElementType() == ElementType.METHOD
                && !metaConstraint.getMember().getName().startsWith("get")) { // TODO: better getter test
            } else if (access.getElementType() == ElementType.CONSTRUCTOR) {
            groupSeq =
                metabean.initFeature(key, new ArrayList<Group>(annotation == null ? 1 : annotation.value().length));
        log.log(Level.FINEST,
            String.format("Default group sequence for bean %s is: %s", beanClass.getName(), groupSeq));
public class MethodDescriptorImpl extends InvocableElementDescriptor
    implements javax.validation.metadata.MethodDescriptor, ProcedureDescriptor {
public class NodeBuilderCustomizableContextImpl
    implements ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext {
    public NodeBuilderCustomizableContextImpl(final ConstraintValidatorContextImpl parent, final String messageTemplate,
        final PathImpl propertyPath) {
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(
        String name) {
public class NodeContextBuilderImpl
    implements ConstraintValidatorContext.ConstraintViolationBuilder.NodeContextBuilder {
    public NodeContextBuilderImpl(final ConstraintValidatorContextImpl context, final String template,
        final PathImpl path) {
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(
        String name) {
    public ParameterAccess(Type paramType, int paramIdx) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
    private final Set<GroupConversionDescriptor> groupConversions =
        new CopyOnWriteArraySet<GroupConversionDescriptor>();
    public ReturnValueDescriptorImpl(final MetaBean metaBean, Class<?> returnType,
        final Collection<ConstraintValidation<?>> list, boolean cascaded) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
    private void ensureExpandable(List<Group> groupList, List<Group> defaultGroupList, int defaultGroupIndex) {
            int index = groupList.indexOf(group); // sequence contains group of default group sequence
            if ((i == 0 && index == defaultGroupIndex - 1)
                || (i == defaultGroupList.size() - 1 && index == defaultGroupIndex  1)) {
            throw new GroupDefinitionException(
                "Unable to expand default group list"  defaultGroupList  " into sequence "  groupList);
    public static final Class<?>[] DEFAULT_GROUP = new Class<?>[] { Default.class };
        Set<Class<?>> processedSequences) {
                List<Group> tmpSequence = resolveSequence(clazz, anno, processedSequences); // recursion!
        return !(resolver instanceof CachingRelevant) || ((CachingRelevant) resolver).needsCaching();
    public boolean isReachable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
        Path pathToTraversableObject, ElementType elementType) {
        CacheEntry currentLH =
            new CacheEntry(traversableObject, traversableProperty, rootBeanType, pathToTraversableObject, elementType);
            currentLH.reachable = delegate.isReachable(traversableObject, traversableProperty, rootBeanType,
                pathToTraversableObject, elementType);
            cachedLH.reachable = delegate.isReachable(traversableObject, traversableProperty, rootBeanType,
                pathToTraversableObject, elementType);
    public boolean isCascadable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
        Path pathToTraversableObject, ElementType elementType) {
        CacheEntry currentLH =
            new CacheEntry(traversableObject, traversableProperty, rootBeanType, pathToTraversableObject, elementType);
            currentLH.cascadable = delegate.isCascadable(traversableObject, traversableProperty, rootBeanType,
                pathToTraversableObject, elementType);
            cachedLH.cascadable = delegate.isCascadable(traversableObject, traversableProperty, rootBeanType,
                pathToTraversableObject, elementType);
        return false; // I am the cache. Do not need cache for cache
        private CacheEntry(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
            Path pathToTraversableObject, ElementType elementType) {
            return elementType == that.elementType && path.equals(that.path) && type.equals(that.type)
                && !(object != null ? !object.equals(that.object) : that.object != null) && node.equals(that.node);
    private static final String PERSISTENCE_UTIL_CLASSNAME = "javax.persistence.PersistenceUtil";
        "org.apache.bval.jsr.resolver.JPATraversableResolver";
    public boolean isReachable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
        Path pathToTraversableObject, ElementType elementType) {
        return jpaTR == null || jpaTR.isReachable(traversableObject, traversableProperty, rootBeanType,
            pathToTraversableObject, elementType);
    public boolean isCascadable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
        Path pathToTraversableObject, ElementType elementType) {
        return jpaTR == null || jpaTR.isCascadable(traversableObject, traversableProperty, rootBeanType,
            pathToTraversableObject, elementType);
            log.log(Level.FINEST,
                String.format("Cannot find %s on classpath. All properties will per default be traversable.",
                    PERSISTENCE_UTIL_CLASSNAME));
                (Class<? extends TraversableResolver>) Reflection.toClass(JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME,
                    classLoader);
                log.log(Level.FINEST,
                    String.format("Instantiated an instance of %s.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME));
            log.log(Level.WARNING,
                String.format(
                    "Unable to load or instantiate JPA aware resolver %s. All properties will per default be traversable.",
                    JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME),
                e);
    public boolean isReachable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
        Path pathToTraversableObject, ElementType elementType) {
        return traversableObject == null
            || Persistence.getPersistenceUtil().isLoaded(traversableObject, traversableProperty.getName());
    public boolean isCascadable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
        Path pathToTraversableObject, ElementType elementType) {
    public boolean isReachable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
        Path pathToTraversableObject, java.lang.annotation.ElementType elementType) {
    public boolean isCascadable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
        Path pathToTraversableObject, ElementType elementType) {
        return false; // no
        try {
            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
            final byte[] buffer = new byte[1024];
            int length;
            while ((length = stream.read(buffer)) != -1) {
                baos.write(buffer, 0, length);
            return new ByteArrayInputStream(baos.toByteArray());
        } catch (final IOException e) {
            throw new RuntimeException(e);
        }
public class LeafNodeBuilderCustomizableContextImpl
    implements ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext {
    public LeafNodeBuilderCustomizableContextImpl(final ConstraintValidatorContextImpl parent, String messageTemplate,
        PathImpl propertyPath) {
    private class LeafNodeContextBuilderImpl
        implements ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeContextBuilder {
        public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderDefinedContext atIndex(
            Integer index) {
public class LeafNodeBuilderDefinedContextImpl
    implements ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderDefinedContext {
    public LeafNodeBuilderDefinedContextImpl(final ConstraintValidatorContextImpl context, final String tpl,
        final PathImpl path) {
    implements ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext {
    NodeBuilderCustomizableContextImpl(ConstraintValidatorContextImpl contextImpl, String template, PathImpl path,
        String name) {
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(
        String name) {

    implements ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderDefinedContext {
    public NodeBuilderDefinedContextImpl(ConstraintValidatorContextImpl contextImpl, String template, PathImpl path) {
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(
        String name) {
final class NodeContextBuilderImpl implements ConstraintValidatorContext.ConstraintViolationBuilder.NodeContextBuilder {
    NodeContextBuilderImpl(ConstraintValidatorContextImpl contextImpl, String template, PathImpl path, NodeImpl node) {
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderDefinedContext atKey(Object key) {
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderDefinedContext atIndex(Integer index) {
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addNode(String name) {
    public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(
        String name) {

    public NodeImpl(String name) {
                    throw new IllegalStateException(
                        String.format("Position %s: expected property, index/key, or end of expression", here));
                    throw new IllegalStateException(String.format(
                        "Position %s: expected property path separator, index/key, or end of expression", here));
                } catch (Exception e) {
                    throw new RuntimeException(
                        "Java escaping in quotes is only supported with Apache commons-lang3 on the classpath!");

        KNOWN_PROXY_CLASSNAMES = Collections.unmodifiableSet(s);
                throw new UnknownPropertyException(
                    String.format("Property %s.%s is not cascaded", mp.getParentMetaBean().getId(), mp.getName()));
            validationContext.moveDown(mp,
                new NullSafePropertyAccess(validationContext.getMetaBean().getBeanClass(), mp.getName()));
            validationContext.setMetaBean(validationContext.getMetaBean()
                .resolveMetaBean(ObjectUtils.defaultIfNull(validationContext.getBean(), rawType)));
    private final Map<Class<?>, Map<Member, Boolean>> ignoreAnnotationOnMember =
        new HashMap<Class<?>, Map<Member, Boolean>>();
    private final Map<Class<?>, Map<Member, Map<Integer, Boolean>>> ignoreAnnotationOnParameter =
        new HashMap<Class<?>, Map<Member, Map<Integer, Boolean>>>();
        return ignoreAnnotationDefaults.containsKey(clazz) && ignoreAnnotationDefaults.get(clazz);
        log.log(Level.FINEST, String.format("%s level annotations are getting ignored for %s.%s", type, clazz.getName(),
            member.getName()));
            log.log(Level.FINEST, String.format("Class level annotation are getting ignored for %s", clazz.getName()));
        if (processedValuesFromDescriptor != descriptor.size() && !Valid.class.equals(annotationType)) {
    private static final Set<ConstraintAnnotationAttributes> RESERVED_PARAMS = Collections
        .unmodifiableSet(EnumSet.of(ConstraintAnnotationAttributes.GROUPS, ConstraintAnnotationAttributes.MESSAGE,
            ConstraintAnnotationAttributes.PAYLOAD, ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO));
                final Collection<String> potentialMethodName =
                    processPropertyLevel(bean.getGetter(), beanClass, defaultPackage, ignoreAnnotations);
            final JAXBElement<ConstraintMappingsType> root =
                unmarshaller.unmarshal(stream, ConstraintMappingsType.class);
    private void processClassLevel(ClassType classType, Class<?> beanClass, String defaultPackage) {
            MetaConstraint<?, ?> metaConstraint = createConstraint(constraint, beanClass, null, defaultPackage);
    private <A extends Annotation, T> MetaConstraint<?, ?> createConstraint(final ConstraintType constraint,
        final Class<T> beanClass, final Member member, final String defaultPackage) {
    private <A extends Annotation> Class<?> getAnnotationParameterType(final Class<A> annotationClass,
        final String name) {
            throw new ValidationException(
                "Annotation of type "  annotationClass.getName()  " does not contain a parameter "  name  ".");
    private Object getElementValue(ElementType elementType, Class<?> returnType, String defaultPackage) {
                throw new ValidationException("Attempt to specify an array where single value is expected.");
    private <A extends Annotation> Annotation createAnnotation(AnnotationType annotationType, Class<A> returnType,
        String defaultPackage) {
            return new Class[] {};
                throw new ValidationException(
                    "Specified payload class "  payload.getName()  " does not implement javax.validation.Payload");
            int i = 0;
                throw new ValidationException(
                    methodName  " is defined more than once in mapping xml for bean "  beanClass.getName());
            }
            final Method method =
                Reflection.getDeclaredMethod(beanClass, methodName, toTypes(methodType.getParameter(), defaultPackage));
            final boolean ignoreMethodAnnotation =
                methodType.getIgnoreAnnotations() == null ? parentIgnoreAnn : methodType.getIgnoreAnnotations();
                    final MetaConstraint<?, ?> constraint =
                        createConstraint(constraintType, beanClass, method, defaultPackage);
                    final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method,
                        AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method,
                            new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                boolean ignoreParametersAnnotation =
                    p.getIgnoreAnnotations() == null ? ignoreMethodAnnotation : p.getIgnoreAnnotations();
                    final MetaConstraint<?, ?> constraint =
                        createConstraint(constraintType, beanClass, method, defaultPackage);
                    final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method,
                        AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method,
                            new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                    final MetaConstraint<?, ?> constraint =
                        createConstraint(constraintType, beanClass, method, defaultPackage);
                throw new ValidationException(
                    beanClass.getName()  " does not contain the constructor  "  constructorType);
                    final MetaConstraint<?, ?> constraint =
                        createConstraint(constraintType, beanClass, constructor, defaultPackage);
                    final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor,
                        AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass,
                            constructor, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                    final MetaConstraint<?, ?> constraint =
                        createConstraint(constraintType, beanClass, constructor, defaultPackage);
                    final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor,
                        AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
                        final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass,
                            constructor, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                    final MetaConstraint<?, ?> constraint =
                        createConstraint(constraintType, beanClass, constructor, defaultPackage);
    private <A> void processFieldLevel(List<FieldType> fields, Class<A> beanClass, String defaultPackage,
        boolean ignoreAnnotations) {
                throw new ValidationException(
                    fieldName  " is defined more than once in mapping xml for bean "  beanClass.getName());
            }
            final boolean ignoreFieldAnnotation =
                fieldType.getIgnoreAnnotations() == null ? ignoreAnnotations : fieldType.getIgnoreAnnotations();
                final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, field,
                    new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, field, defaultPackage);
        String defaultPackage, boolean ignoreAnnotatino) {
                throw new ValidationException(
                    getterName  " is defined more than once in mapping xml for bean "  beanClass.getName());
                throw new ValidationException(beanClass.getName()  " does not contain the property  "  getterName);
            final boolean ignoreGetterAnnotation =
                getterType.getIgnoreAnnotations() == null ? ignoreAnnotatino : getterType.getIgnoreAnnotations();
                final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method,
                    new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
                    createConstraint(constraintType, beanClass, method, defaultPackage);
    private void processConstraintDefinitions(List<ConstraintDefinitionType> constraintDefinitionList,
        String defaultPackage) {
            if (validatedByType.getIncludeExistingValidators() != null
                && validatedByType.getIncludeExistingValidators()) {
                validatorClass = (Class<? extends ConstraintValidator<?, ?>>) loadClass(validatorClassName);
                    throw new ValidationException(validatorClass  " is not a constraint validator class");
                if (!classes.contains(validatorClass))
                    classes.add(validatorClass);
                throw new ValidationException(
                    "Constraint validator for "  annotationClass.getName()  " already configured.");
                    classes.toArray(new Class[classes.size()]));
        Class<? extends Annotation> annotationType) {
            new ArrayList<Class<? extends ConstraintValidator<? extends Annotation, ?>>>();
            factory.getDefaultConstraints().getValidatorClasses(annotationType);
            Class<? extends ConstraintValidator<?, ?>>[] validatedBy =
                annotationType.getAnnotation(Constraint.class).validatedBy();
@Target({ ANNOTATION_TYPE, METHOD, FIELD })
    Class<? extends Payload>[] payload() default {};
    @Pattern(regexp = ".*?COMPANY.*?") })
@Target({ ANNOTATION_TYPE, METHOD, FIELD, CONSTRUCTOR, PARAMETER })
    @OverridesAttribute(constraint = Pattern.class, name = "message", constraintIndex = 0)
    String emailMessage() default "Not an email";
    @OverridesAttribute(constraint = Pattern.class, name = "message", constraintIndex = 1)
    String agimatecMessage() default "Not COMPANY";
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @interface List {
@Target({ ANNOTATION_TYPE, METHOD, FIELD })
    @OverridesAttribute.List({ @OverridesAttribute(constraint = Size.class, name = "min"),
        @OverridesAttribute(constraint = Size.class, name = "max") })
    @OverridesAttribute(constraint = Size.class, name = "message")
    Class<? extends Payload>[] payload() default {};
@Target({ ANNOTATION_TYPE, METHOD, FIELD })
@Constraint(validatedBy = { HasStringValidator.class })
    Class<? extends Payload>[] payload() default {};
    Class<? extends Payload>[] payload() default {};
@Target({ TYPE })
    String message() default "{validator.zipCodeCityCoherence}";


    Class<? extends Payload>[] payload() default {};
public class ZipCodeCityCoherenceValidator implements ConstraintValidator<ZipCodeCityCoherence, ZipCodeCityCarrier> {
            context.buildConstraintViolationWithTemplate("city not OK").addPropertyNode("city")
                .addConstraintViolation();
    @GroupSequence(value = { Default.class, HighLevelCoherence.class })
@GroupSequence({ First.class, Author.class, Last.class })
@GroupSequence({ First.class, Second.class, Book.class, Last.class })
    @GroupSequence(value = { First.class, Second.class, Last.class })


        return null; // not supported
        @Pattern(regexp = "^[A-Z0-9-]$", flags = Pattern.Flag.CASE_INSENSITIVE, message = "must contain alphabetical characters only"),
        @Pattern(regexp = "^....-....-....$", message = "must match ....-....-....") })


    public void save(@Pattern(regexp = "[a-f0-9]{4}") String data) {
        return;

    @Size(min = 3, max = 10)
    public String echo(@NotNull @Size(min = 3, max = 10) String str) {
        return str;




    @NotNull(groups = { Billable.class, BuyInOneClick.class })
@GroupSequence(value = CyclicGroupSequence1.class)
@GroupSequence({ GClass1.class, GClass2.class })
@GroupSequence({ GClass3.class, GClass1.class })
    @NotNull
    String getCreationDate();


    @NotNull
    String getLastModifier();

    @NotNull
    String getLastReader();
    @Size(min = 10, max = 10)
    @NotNull(groups = { Billable.class })
@GroupSequence({ Address.class, Address.HighLevelCoherence.class, Address.ExtraCareful.class })

    public interface HighLevelCoherence {
    }

    public interface ExtraCareful {
    }
    @NotNull

@GroupSequence({ Address.class, Address.HighLevelCoherence.class })
    public interface HighLevelCoherence {
    }
                                f.set(instance,
                                    Validation.byDefaultProvider().configure().buildValidatorFactory().getValidator());
            new Class<?>[] { Context.class }, new InvocationHandler() {
                public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {
                    if (method.getName().equals("lookup") && args != null && args.length == 1
                        && String.class.isInstance(args[0])) {
                        if ("java:comp/ValidatorFactory".equals(args[0])) {
                            return Validation.byDefaultProvider().configure().buildValidatorFactory();
                        }
                        if ("java:comp/Validator".equals(args[0])) {
                            return Validation.byDefaultProvider().configure().buildValidatorFactory().getValidator();
                        }
                    return null;
            }));
        if (context.getPropertyValue() == null)
            return;
        if (lag == null)
            return;
        if (context.getPropertyValue() == null)
            return;
        if (regExp == null)
            return;
        if (context.getPropertyValue() == null)
            return;
            throw new IllegalArgumentException("regular expression malformed. regexp "  regExp  " at "  context, e);
        if (minValue == null || context.getPropertyValue() == null)
            return;
        if (maxValue == null || context.getPropertyValue() == null)
            return;
        Object currentValue) {
        Integer maxLength = (Integer) context.getMetaProperty().getFeature(Features.Property.MAX_LENGTH);
        if (maxLength == null)
            return;
        if (context.getPropertyValue() == null)
            return;
        Integer maxLength = (Integer) context.getMetaProperty().getFeature(Features.Property.MIN_LENGTH);
        if (maxLength == null)
            return;
        if (context.getPropertyValue() == null)
            return;
        if (features == null)
            features = new ArrayList<XMLMetaFeature>();
        if (features == null)
            return null;
            if (key.equals(anno.getKey()))
                return anno;
        if (validators == null)
            validators = new ArrayList<XMLMetaValidatorReference>();
        xStream.processAnnotations(new Class[] { XMLFeaturesCapable.class, XMLMetaFeature.class, XMLMetaBean.class,
            XMLMetaBeanInfos.class, XMLMetaBeanReference.class, XMLMetaElement.class, XMLMetaProperty.class,
            XMLMetaValidator.class, XMLMetaValidatorReference.class });
        if (properties == null)
            properties = new ArrayList<XMLMetaProperty>();
        if (properties == null)
            return null;
            if (name.equals(prop.getName()))
                return prop;
        if (beanRelations == null)
            beanRelations = new ArrayList<XMLMetaBeanReference>();
        if (beanRelations == null)
            return null;
            if (name.equals(relation.getName()))
                return relation;
        new LinkedHashMap<XMLMetaBeanLoader, XMLMetaBeanInfos>();
        if (metaBean.getId() == null)
            return;
        visitXMLBeanMeta(metaBean.getId(), new Visitor() {
            public void visit(XMLMetaBean xmlMeta, XMLMetaBeanInfos xmlInfos) throws Exception {
        /*        if (meta.getBeanClass() == null && result.xmlMeta.getImpl() != null) {
    protected void enrichValidations(FeaturesCapable prop, XMLFeaturesCapable xmlProp, XMLResult result,
        boolean addStandard) throws Exception {
            List<String> jsValidators =
                new ArrayList<String>(xmlProp.getValidators().size()  (func == null ? 0 : func.length));
            } // <--- to here
                if (standardValidation != null && valRef.getRefId().equals(standardValidation.getValidationId())) {
                XMLMetaValidator validator = result.xmlInfos.getValidator(valRef.getRefId());
                    if (validator.getJsFunction() != null && !jsValidators.contains(validator.getJsFunction())) {
                prop.putFeature(JAVASCRIPT_VALIDATION_FUNCTIONS, jsValidators.toArray(new String[jsValidators.size()]));
        } else if (addStandard && standardValidation != null && !prop.hasValidation(standardValidation)) {
    protected MetaProperty enrichElement(MetaBean meta, XMLMetaElement xmlProp, XMLResult result) throws Exception {
        for (Map.Entry<XMLMetaBeanLoader, XMLMetaBeanInfos> entry : resources.entrySet()) {
        for (Map.Entry<XMLMetaBeanLoader, XMLMetaBeanInfos> entry : resources.entrySet()) {
        if (beans == null)
            return null;
        if (beanLookup == null)
            initBeanLookup();
                Validation validation = (Validation) Reflection.toClass(xv.getJava()).newInstance();
        if (beans == null)
            beans = new ArrayList<XMLMetaBean>();
        if (validators == null)
            return null;
        if (validationLookup == null)
            initValidationLookup();
        if (validators == null)
            validators = new ArrayList<XMLMetaValidator>();

    /**
    * global meta bean finder.
    * @return
    */
        super.mergeInto(prop); // call super!
        if (url == null)
            throw new NullPointerException("URL required");
            XMLMetaBeanInfos beanInfos = (XMLMetaBeanInfos) XMLMapper.getInstance().getXStream().fromXML(stream);
        super.mergeInto(prop); // call super!
    private String java; // implementation of Validation
                          VALUE1, VALUE2, VALUE3
        return new BeanInfo[] { bi };
            PropertyDescriptor numericValue =
                new PropertyDescriptor("numericValue", targetClass, "getNumericValue", "setNumericValue");
            return new PropertyDescriptor[] { numericValue };

import org.apache.commons.lang3.StringEscapeUtils;

import java.util.logging.Logger;
    private static final Logger LOG = Logger.getLogger(PathNavigation.class.getName());

    private static final boolean COMMONS_LANG3_AVAILABLE;
    static {
        boolean b = true;
        try {
            new StringEscapeUtils();
        } catch (Exception e) {
            b = false;
            LOG.warning("Apache commons-lang3 is not on the classpath; Java escaping in quotes will not be available.");
        }
        COMMONS_LANG3_AVAILABLE = b;
    }

                final int codePoints;
                if (COMMONS_LANG3_AVAILABLE) {
                    codePoints = StringEscapeUtils.UNESCAPE_JAVA.translate(path, here, w);
                } else {
                    codePoints = 0;                    
                }
                if (codePoints == 0) {
                    w.write(Character.toChars(Character.codePointAt(path, here)));
                    pos.next();
                } else {
                    for (int i = 0; i < codePoints; i) {
                        pos.plus(Character.charCount(Character.codePointAt(path, pos.getIndex())));
import java.io.IOException;
import java.io.Writer;
    private static class QuotedStringParser {
        String parseQuotedString(CharSequence path, PathPosition pos) throws Exception {
            final int len = path.length();
            final int start = pos.getIndex();
            if (start < len) {
                final char quote = path.charAt(start);
                pos.next();
                final StringWriter w = new StringWriter();
                while (pos.getIndex() < len) {
                    final int here = pos.getIndex();
                    // look for matching quote
                    if (path.charAt(here) == quote) {
                        pos.next();
                        return w.toString();
                    }
                    handleNextChar(path, pos, w);
                }
                // if reached, reset due to no ending quote found
                pos.setIndex(start);
            }
            return null;
        }

        protected void handleNextChar(CharSequence path, PathPosition pos, Writer target) throws IOException {
            target.write(Character.toChars(Character.codePointAt(path, pos.getIndex())));
            pos.next();
        }
    }

    private static class FullQuotedStringParser extends QuotedStringParser {

        @Override
        protected void handleNextChar(CharSequence path, PathPosition pos, Writer target) throws IOException {
            final int 
                codePoints = StringEscapeUtils.UNESCAPE_JAVA.translate(path, pos.getIndex(), target);
            if (codePoints == 0) {
                super.handleNextChar(path, pos, target);
            } else {
                for (int i = 0; i < codePoints; i) {
                    pos.plus(Character.charCount(Character.codePointAt(path, pos.getIndex())));
                }
            }
        }

    }

    private static final QuotedStringParser QUOTED_STRING_PARSER;
    
        QuotedStringParser quotedStringParser;
            quotedStringParser = new FullQuotedStringParser();
            quotedStringParser = new QuotedStringParser();
        QUOTED_STRING_PARSER = quotedStringParser;
                String s = QUOTED_STRING_PARSER.parseQuotedString(path, pos);
 * and template resource file "bean-infos-json.ftl" with it.
