if (log.isDebugEnabled())
if (log.isDebugEnabled())
if (log.isDebugEnabled())
log.debug("Instantiated an instance of "
if (log.isDebugEnabled()) {
log.debug(
package org.apache.bval;
import org.apache.bval.model.*;
import java.util.IdentityHashMap;
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.PropertyAccess;
public class BeanValidationContext<T extends ValidationListener>
implements ValidationContext<T> {
private static final Object UNKNOWN = new Object();
private MetaBean metaBean;
private Object bean;
private MetaProperty metaProperty;
private Object propertyValue = UNKNOWN;
private AccessStrategy access;
protected IdentityHashMap validatedObjects = new IdentityHashMap();
private boolean fixed;
private T listener;
public BeanValidationContext(T listener) {
this.listener = listener;
}
public T getListener() {
return listener;
}
public void setListener(T listener) {
this.listener = listener;
}
public boolean collectValidated() {
return validatedObjects.put(getBean(), Boolean.TRUE) == null;
}
public boolean isValidated(Object object) {
return validatedObjects.containsKey(object);
}
public void resetValidated() {
validatedObjects.clear();
}
public void setBean(Object aBean, MetaBean aMetaBean) {
bean = aBean;
metaBean = aMetaBean;
metaProperty = null;
unknownValue();
}
public Object getPropertyValue() {
return getPropertyValue(
new PropertyAccess(bean.getClass(), metaProperty.getName()));
} else {
return getPropertyValue(access);
}
}
public Object getPropertyValue(AccessStrategy access)
throws IllegalArgumentException, IllegalStateException {
if (propertyValue == UNKNOWN || (this.access != access && !fixed)) {
propertyValue = access.get(bean);
this.access = access;
}
return propertyValue;
}
public String getPropertyName() {
return metaProperty == null ? null : metaProperty.getName();
}
public void setPropertyValue(Object propertyValue) {
this.propertyValue = propertyValue;
}
public void setFixedValue(Object value) {
setPropertyValue(value);
fixed = true;
}
public boolean isFixed() {
return fixed;
}
public void setFixed(boolean fixed) {
this.fixed = fixed;
}
public FeaturesCapable getMeta() {
return (metaProperty == null) ? metaBean : metaProperty;
}
public void unknownValue() {
propertyValue = UNKNOWN;
access = null;
}
public MetaBean getMetaBean() {
return metaBean;
}
public Object getBean() {
return bean;
}
public MetaProperty getMetaProperty() {
return metaProperty;
}
public void setMetaBean(MetaBean metaBean) {
this.metaBean = metaBean;
}
public void setBean(Object bean) {
this.bean = bean;
unknownValue();
}
public void setMetaProperty(MetaProperty metaProperty) {
this.metaProperty = metaProperty;
unknownValue();
}
public String toString() {
}
public void moveDown(MetaProperty prop, AccessStrategy access) {
setMetaProperty(prop);
setBean(getPropertyValue(access), prop.getMetaBean());
}
public void moveUp(Object bean, MetaBean aMetaBean) {
}
public void setCurrentIndex(int index) {
}
public void setCurrentKey(Object key) {
}
}
package org.apache.bval;
import org.apache.bval.model.*;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.PropertyAccess;
public class BeanValidator<T extends ValidationListener> {
private boolean treatMapsLikeBeans = false;
private final MetaBeanFinder metaBeanFinder;
public BeanValidator() {
this(MetaBeanManagerFactory.getFinder());
}
public BeanValidator(MetaBeanFinder metaBeanFinder) {
this.metaBeanFinder = metaBeanFinder;
}
public boolean isTreatMapsLikeBeans() {
return treatMapsLikeBeans;
}
public void setTreatMapsLikeBeans(boolean treatMapsLikeBeans) {
this.treatMapsLikeBeans = treatMapsLikeBeans;
}
public T validate(Object bean) {
MetaBean metaBean =
getMetaBeanFinder().findForClass(bean.getClass());
return validate(bean, metaBean);
}
public T validate(Object bean, MetaBean metaBean) {
ValidationContext<T> context = createContext();
context.setBean(bean, metaBean);
validateContext(context);
return context.getListener();
}
public T validateCall(Method method, Object[] parameters) {
if (parameters.length > 0) {
Annotation[][] annotations = method.getParameterAnnotations();
ValidationContext<T> context = null;
for (Annotation anno : annotations[i]) {
if (anno instanceof Validate) {
if(context == null) context = createContext();
if (determineMetaBean((Validate) anno, parameters[i], context)) {
validateContext(context);
}
}
}
}
return context != null ? context.getListener() : null;
}
return null;
}
protected boolean determineMetaBean(Validate validate, Object parameter,
ValidationContext context) {
if (validate.value().length() == 0) {
if (parameter == null) return false;
Class beanClass;
Collection coll = ((Collection) parameter);
if (coll.isEmpty()) return false;
} else if (parameter.getClass().isArray()) {
beanClass = parameter.getClass().getComponentType();
} else {
beanClass = parameter.getClass();
}
context.setBean(parameter,getMetaBeanFinder().findForClass(beanClass));
} else {
context.setBean(parameter,getMetaBeanFinder().findForId(validate.value()));
}
return true;
}
protected T createResults() {
return (T) new ValidationResults();
}
protected ValidationContext<T> createContext() {
return new BeanValidationContext<T>(createResults());
}
public T validateProperty(Object bean, MetaProperty metaProperty) {
ValidationContext<T> context = createContext();
context.setBean(bean);
context.setMetaProperty(metaProperty);
validateProperty(context);
return context.getListener();
}
public void validateProperty(ValidationContext context) {
for (Validation validation : context.getMetaProperty().getValidations()) {
validation.validate(context);
}
}
public void validateContext(ValidationContext context) {
if (context.getBean() != null) {
if (!treatMapsLikeBeans && context.getBean() instanceof Map) {
validateMapInContext(context);
} else if (context.getBean() instanceof Iterable) {
validateIteratableInContext(context);
} else if (context.getBean() instanceof Object[]) {
validateArrayInContext(context);
validateBeanInContext(context);
}
}
}
private void validateBeanInContext(ValidationContext context) {
if (getDynamicMetaBean(context) != null) {
context.setMetaBean(
getDynamicMetaBean(context).resolveMetaBean(context.getBean()));
}
validateBeanNet(context);
}
private void validateArrayInContext(ValidationContext context) {
int index = 0;
DynamicMetaBean dyn = getDynamicMetaBean(context);
for (Object each : ((Object[]) context.getBean())) {
if (dyn != null) {
context.setBean(each, dyn.resolveMetaBean(each));
} else {
context.setBean(each);
}
validateBeanNet(context);
}
}
private DynamicMetaBean getDynamicMetaBean(ValidationContext context) {
return context.getMetaBean() instanceof DynamicMetaBean ?
(DynamicMetaBean) context.getMetaBean() : null;
}
private void validateIteratableInContext(ValidationContext context) {
Iterator it = ((Iterable) context.getBean()).iterator();
int index = 0;
final DynamicMetaBean dyn = getDynamicMetaBean(context);
Object each = it.next();
if (each == null)
if (dyn != null) {
context.setBean(each, dyn.resolveMetaBean(each));
} else {
context.setBean(each);
}
validateBeanNet(context);
}
}
private void validateMapInContext(ValidationContext context) {
Iterator<Map.Entry> it = ((Map) context.getBean()).entrySet().iterator();
final DynamicMetaBean dyn = getDynamicMetaBean(context);
Map.Entry entry = it.next();
context.setCurrentKey(entry.getKey());
if (entry.getValue() == null)
if (dyn != null) {
context.setBean(entry.getValue(), dyn.resolveMetaBean(entry.getValue()));
} else {
context.setBean(entry.getValue());
}
validateBeanNet(context);
}
}
protected void validateBeanNet(ValidationContext context) {
if (context.collectValidated()) {
validateBean(context);
for (MetaProperty prop : context.getMetaBean().getProperties()) {
validateRelatedBean(context, prop);
}
}
}
private void validateRelatedBean(ValidationContext context, MetaProperty prop) {
AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
final Object bean = context.getBean();
final MetaBean mbean = context.getMetaBean();
context.moveDown(prop, new PropertyAccess(bean.getClass(), prop.getName()));
validateContext(context);
context.moveUp(bean, mbean);
final Object bean = context.getBean();
final MetaBean mbean = context.getMetaBean();
for (AccessStrategy each : access) {
context.moveDown(prop, each);
validateContext(context);
context.moveUp(bean, mbean);
}
}
}
public void validateBean(ValidationContext context) {
for (MetaProperty prop : context.getMetaBean().getProperties()) {
context.setMetaProperty(prop);
validateProperty(context);
}
context.setMetaProperty(null);
for (Validation validation : context.getMetaBean().getValidations()) {
validation.validate(context);
}
}
public MetaBeanFinder getMetaBeanFinder() {
return metaBeanFinder;
}
}
package org.apache.bval;
import org.apache.bval.model.MetaBean;
final class DynamicMetaBean extends MetaBean {
private final MetaBeanFinder finder;
public DynamicMetaBean(MetaBeanFinder finder) {
this.finder = finder;
}
@Override
public MetaBean resolveMetaBean(Object bean) {
return bean instanceof Class ?
finder.findForClass((Class) bean) : finder.findForClass(bean.getClass());
}
}
package org.apache.bval;
import static org.apache.bval.model.Features.Property.*;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
package org.apache.bval;
import org.apache.bval.model.MetaBean;
import org.apache.bval.xml.XMLMetaBean;
import org.apache.bval.xml.XMLMetaBeanFactory;
import org.apache.bval.xml.XMLMetaBeanInfos;
import org.apache.bval.xml.XMLMetaBeanLoader;
import org.apache.commons.lang.ClassUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
public class MetaBeanBuilder {
private static final Log log = LogFactory.getLog(MetaBeanBuilder.class);
private MetaBeanFactory[] factories;
private XMLMetaBeanFactory xmlFactory;
public MetaBeanBuilder() {
this(new MetaBeanFactory[]{new IntrospectorMetaBeanFactory(),
new XMLMetaBeanFactory()});
}
public MetaBeanBuilder(MetaBeanFactory[] factories) {
setFactories(factories);
}
private void setFactories(MetaBeanFactory[] factories) {
this.factories = factories;
updateXmlFactory();
}
private void updateXmlFactory() {
for (MetaBeanFactory each : factories) {
xmlFactory = (XMLMetaBeanFactory) each;
return;
}
}
}
public XMLMetaBeanFactory getXmlFactory() {
return xmlFactory;
}
else {
}
updateXmlFactory();
}
else {
}
updateXmlFactory();
public void addLoader(XMLMetaBeanLoader loader) {
assertXmlFactory();
xmlFactory.addLoader(loader);
}
public Map<String, MetaBean> buildAll() throws Exception {
final Map<String, MetaBean> all = new HashMap<String, MetaBean>();
if (xmlFactory != null) {
xmlFactory.visitXMLBeanMeta(null, new XMLMetaBeanFactory.Visitor() {
public void visit(XMLMetaBean empty, XMLMetaBeanInfos xmlInfos)
throws Exception {
XMLMetaBeanFactory.XMLResult carrier =
new XMLMetaBeanFactory.XMLResult(null, xmlInfos);
for (XMLMetaBean xmlMeta : xmlInfos.getBeans()) {
MetaBean meta = all.get(xmlMeta.getId());
if (meta == null) {
meta = createMetaBean(xmlMeta);
all.put(xmlMeta.getId(), meta);
}
carrier.xmlMeta = xmlMeta;
xmlFactory.enrichMetaBean(meta, carrier);
}
}
public MetaBean getMetaBean() {
}
});
}
return all;
}
public Map<String, MetaBean> enrichCopies(Map<String, MetaBean> all,
XMLMetaBeanInfos... infosArray)
throws Exception {
assertXmlFactory();
final Map<String, MetaBean> copies = new HashMap<String, MetaBean>(all.size());
boolean nothing = true;
XMLMetaBeanFactory.XMLResult carrier = new XMLMetaBeanFactory.XMLResult();
for (XMLMetaBeanInfos xmlMetaBeanInfos : infosArray) {
carrier.xmlInfos = xmlMetaBeanInfos;
if (xmlMetaBeanInfos == null) continue;
try {
for (XMLMetaBean xmlMeta : xmlMetaBeanInfos.getBeans()) {
nothing = false;
MetaBean copy = copies.get(xmlMeta.getId());
MetaBean meta = all.get(xmlMeta.getId());
copy = createMetaBean(xmlMeta);
copy = meta.copy();
}
copies.put(xmlMeta.getId(), copy);
}
carrier.xmlMeta = xmlMeta;
xmlFactory.enrichMetaBean(copy, carrier);
}
} catch (IOException e) {
xmlFactory.handleLoadException(xmlMetaBeanInfos, e);
}
}
if (nothing) return all;
for (Map.Entry<String, MetaBean> entry : all.entrySet()) {
if (!copies.containsKey(entry.getKey())) {
if (entry.getValue().hasRelationships()) {
copies.put(entry.getKey(), (MetaBean) entry.getValue().copy());
copies.put(entry.getKey(), entry.getValue());
}
}
}
return copies;
}
private void assertXmlFactory() {
if (xmlFactory == null) {
throw new IllegalStateException("no xmlFactory available");
}
}
public MetaBean buildForId(String beanInfoId) throws Exception {
final XMLMetaBeanFactory.Visitor v;
assertXmlFactory();
xmlFactory.visitXMLBeanMeta(beanInfoId, v = new XMLMetaBeanFactory.Visitor() {
private MetaBean meta;
public MetaBean getMetaBean() {
return meta;
}
public void visit(XMLMetaBean xmlMeta, XMLMetaBeanInfos xmlInfos)
throws Exception {
if (meta == null) {
meta = createMetaBean(xmlMeta);
}
xmlFactory.enrichMetaBean(meta,
new XMLMetaBeanFactory.XMLResult(xmlMeta, xmlInfos));
}
});
if (v.getMetaBean() == null) {
}
return v.getMetaBean();
}
private MetaBean createMetaBean(XMLMetaBean xmlMeta) throws Exception {
return buildForClass(findLocalClass(xmlMeta.getImpl()));
}
protected Class findLocalClass(String className) {
if (className != null) {
try {
return ClassUtils.getClass(className);
} catch (ClassNotFoundException e) {
}
}
return null;
}
public MetaBean buildForClass(Class clazz) throws Exception {
MetaBean meta = new MetaBean();
meta.setBeanClass(clazz);
}
for (MetaBeanFactory factory : factories) {
factory.buildMetaBean(meta);
}
return meta;
}
package org.apache.bval;
import org.apache.bval.model.MetaBean;
import org.apache.commons.collections.FastHashMap;
import java.io.Serializable;
import java.util.Map;
public class MetaBeanCache implements MetaBeanFinder, Serializable {
protected final FastHashMap cacheById;
protected final FastHashMap cacheByClass;
public MetaBeanCache() {
this.cacheById = new FastHashMap();
cacheByClass = new FastHashMap();
cacheByClass.setFast(true);
cacheById.setFast(true);
}
public MetaBeanCache(Map<String, MetaBean> beans) {
this();
for (MetaBean bean : beans.values()) {
cache(bean);
}
}
public void clear() {
cacheById.clear();
cacheByClass.clear();
}
public MetaBean findForId(String beanInfoId) {
return (MetaBean) cacheById.get(beanInfoId);
}
public MetaBean findForClass(Class clazz) {
return (MetaBean) cacheByClass.get(clazz);
}
public Map<String, MetaBean> findAll() {
return cacheById;
}
public void cache(MetaBean beanInfo) {
cacheById.put(beanInfo.getId(), beanInfo);
if (beanInfo.getBeanClass() != null &&
beanInfo.getId().equals(beanInfo.getBeanClass().getName())) {
cacheByClass.put(beanInfo.getBeanClass(), beanInfo);
}
}
public void removeFromCache(MetaBean beanInfo) {
cacheById.remove(beanInfo.getId());
if (beanInfo.getBeanClass() != null &&
beanInfo.getId().equals(beanInfo.getBeanClass().getName())) {
cacheByClass.remove(beanInfo.getBeanClass());
}
}
}
package org.apache.bval;
import java.util.Map;
import org.apache.bval.model.MetaBean;
import org.apache.bval.xml.XMLMetaBeanInfos;
public interface MetaBeanEnricher {
Map<String, MetaBean> enrichCopies(XMLMetaBeanInfos... infos);
}
package org.apache.bval;
import org.apache.bval.model.MetaBean;
package org.apache.bval;
import java.util.Map;
import org.apache.bval.model.MetaBean;
public interface MetaBeanFinder {
MetaBean findForId(String beanInfoId);
MetaBean findForClass(Class clazz);
public Map<String, MetaBean> findAll();
}
package org.apache.bval;
import static org.apache.bval.model.Features.Property.*;
import java.util.Map;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.util.PrivilegedActions;
import org.apache.bval.xml.XMLMetaBeanInfos;
import org.apache.bval.xml.XMLMetaBeanLoader;
import org.apache.bval.xml.XMLMetaBeanRegistry;
import org.apache.bval.xml.XMLMetaBeanURLLoader;
public class MetaBeanManager implements MetaBeanFinder, XMLMetaBeanRegistry, MetaBeanEnricher {
protected final MetaBeanCache cache = new MetaBeanCache();
protected final MetaBeanBuilder builder;
private boolean complete = false;
public MetaBeanManager() {
builder = new MetaBeanBuilder();
}
public MetaBeanManager(MetaBeanBuilder builder) {
this.builder = builder;
}
public void addResourceLoader(String resource) {
addLoader(new XMLMetaBeanURLLoader(
PrivilegedActions.getClassLoader(getClass()).getResource(resource)));
}
public synchronized void addLoader(XMLMetaBeanLoader loader) {
builder.addLoader(loader);
complete = false;
}
public MetaBeanBuilder getBuilder() {
return builder;
}
public MetaBeanCache getCache() {
return cache;
}
public Map<String, MetaBean> findAll() {
if (!complete) {
try {
Map<String, MetaBean> allBuilt = builder.buildAll();
for (MetaBean meta : allBuilt.values()) {
MetaBean cached = cache.findForId(meta.getId());
if (cached == null) {
cache.cache(meta);
}
}
Map<String, MetaBean> map = cache.findAll();
for (Object oentry : map.values()) {
MetaBean meta = (MetaBean) oentry;
computeRelationships(meta, map);
}
complete = true;
return map;
} catch (RuntimeException e) {
} catch (Exception e) {
throw new IllegalArgumentException("error creating beanInfos", e);
}
} else {
return cache.findAll();
}
}
public Map<String, MetaBean> enrichCopies(XMLMetaBeanInfos... infos) {
Map<String, MetaBean> cached = findAll();
try {
Map<String, MetaBean> patched = builder.enrichCopies(cached, infos);
for (Object oentry : patched.values()) {
MetaBean meta = (MetaBean) oentry;
computeRelationships(meta, patched);
}
return patched;
} catch (RuntimeException e) {
} catch (Exception e) {
throw new IllegalArgumentException("error enriching beanInfos", e);
}
}
public MetaBean findForId(String beanInfoId) {
MetaBean beanInfo = cache.findForId(beanInfoId);
if (beanInfo != null) return beanInfo;
try {
beanInfo = builder.buildForId(beanInfoId);
cache.cache(beanInfo);
computeRelationships(beanInfo);
return beanInfo;
} catch (RuntimeException e) {
} catch (Exception e) {
throw new IllegalArgumentException(
}
}
public MetaBean findForClass(Class clazz) {
if (clazz == null) return null;
MetaBean beanInfo = cache.findForClass(clazz);
if (beanInfo != null) return beanInfo;
try {
beanInfo = builder.buildForClass(clazz);
cache.cache(beanInfo);
computeRelationships(beanInfo);
return beanInfo;
} catch (RuntimeException e) {
} catch (Exception e) {
}
}
protected void computeRelationships(MetaBean beanInfo) {
for (MetaProperty prop : beanInfo.getProperties()) {
String beanRef = (String) prop.getFeature(REF_BEAN_ID);
if (beanRef != null) {
prop.setMetaBean(findForId(beanRef));
} else {
Class beanType = prop.getFeature(REF_BEAN_TYPE);
if (beanType != null) {
prop.setMetaBean(findForClass(beanType));
else if (prop.getFeature(REF_CASCADE) != null) {
prop.setMetaBean(new DynamicMetaBean(this));
}
}
}
}
private void computeRelationships(MetaBean beanInfo, Map<String, MetaBean> cached) {
for (MetaProperty prop : beanInfo.getProperties()) {
String beanRef = (String) prop.getFeature(REF_BEAN_ID);
if (beanRef != null) {
prop.setMetaBean(cached.get(beanRef));
}
}
}
}
package org.apache.bval;
import org.apache.bval.xml.XMLMetaBeanRegistry;
public class MetaBeanManagerFactory {
private static MetaBeanManager manager = new MetaBeanManager();
public static MetaBeanFinder getFinder() {
return manager;
}
public static XMLMetaBeanRegistry getRegistry() {
return manager;
}
public static MetaBeanEnricher getEnricher() {
return manager;
}
public static void setManager(MetaBeanManager finder) {
manager = finder;
}
}
package org.apache.bval;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER, ElementType.METHOD})
public @interface Validate {
String value() default "";
}
package org.apache.bval;
import java.io.Serializable;
import java.util.*;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
public class ValidationResults implements ValidationListener, Serializable {
private Map<String, List<Error>> errorsByReason;
private Map<Object, Map<String, List<Error>>> errorsByOwner;
public void addError(String reason, ValidationContext context) {
Error error = createError(reason, context.getBean(), context.getPropertyName());
addError(error, context);
}
public void addError(Error error, ValidationContext context) {
if (errorsByReason == null) {
initialize();
}
addToReasonBucket(error);
addToOwnerBucket(error);
}
public void addError(String reason, Object bean, String propertyName) {
addError(createError(reason, bean, propertyName), null);
}
protected Error createError(String reason, Object owner, String propertyName) {
return new Error(reason, owner, propertyName);
}
protected void initialize() {
errorsByReason = new LinkedHashMap();
errorsByOwner = new LinkedHashMap();
}
protected void addToReasonBucket(Error error) {
if (error.getReason() == null) return;
List<Error> errors = errorsByReason.get(error.getReason());
if (errors == null) {
errors = new ArrayList<Error>();
errorsByReason.put(error.getReason(), errors);
}
errors.add(error);
}
protected void addToOwnerBucket(Error error) {
if (error.getOwner() == null) return;
Map<String, List<Error>> errors = errorsByOwner.get(error.getOwner());
if (errors == null) {
errors = new HashMap<String, List<Error>>();
errorsByOwner.put(error.getOwner(), errors);
}
List<Error> list = errors.get(error.getPropertyName());
if (list == null) {
list = new ArrayList<Error>();
errors.put(error.getPropertyName(), list);
}
list.add(error);
}
public Map<String, List<Error>> getErrorsByReason() {
if (errorsByReason == null) return Collections.emptyMap();
return errorsByReason;
}
public Map<Object, Map<String, List<Error>>> getErrorsByOwner() {
if (errorsByOwner == null) return Collections.emptyMap();
return errorsByOwner;
}
public boolean isEmpty() {
if (errorsByReason == null ||
(errorsByReason.isEmpty() && errorsByOwner.isEmpty())) return true;
for (List<Error> list : errorsByReason.values()) {
if (!list.isEmpty()) return false;
}
for (Map<String, List<Error>> map : errorsByOwner.values()) {
for (List<Error> list : map.values()) {
if (!list.isEmpty()) return false;
}
}
return true;
}
public boolean hasErrorForReason(String reason) {
if (errorsByReason == null) return false;
List<Error> errors = errorsByReason.get(reason);
return errors != null && !errors.isEmpty();
}
public boolean hasError(Object bean, String propertyName) {
if (errorsByOwner == null) return false;
Map<String, List<Error>> errors = errorsByOwner.get(bean);
if (errors == null) return false;
if (propertyName != null) {
List<Error> list = errors.get(propertyName);
return list != null && !list.isEmpty();
} else {
for (List<Error> list : errors.values()) {
if (!list.isEmpty()) return true;
}
return false;
}
}
public String toString() {
}
}
package org.apache.bval.integration;
import org.apache.bval.BeanValidator;
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.model.ValidationContext;
public class ThreadBeanValidator extends BeanValidator {
public ThreadBeanValidator() {
}
public ThreadBeanValidator(MetaBeanFinder metaBeanFinder) {
super(metaBeanFinder);
}
@Override
protected ValidationContext createContext() {
ThreadValidationContext context = ThreadValidationContext.getCurrent();
if (context == null) {
context = new ThreadValidationContext(createResults());
ThreadValidationContext.setCurrent(context);
}
return context;
}
}
package org.apache.bval.integration;
import org.apache.bval.BeanValidationContext;
import org.apache.bval.model.ValidationListener;
public class ThreadValidationContext extends BeanValidationContext {
protected static final ThreadLocal<ThreadValidationContext> current =
new ThreadLocal<ThreadValidationContext>();
public ThreadValidationContext(ValidationListener listener) {
super(listener);
}
public static ThreadValidationContext getCurrent() {
return current.get();
}
public static void setCurrent(ThreadValidationContext aValidationContext) {
if (aValidationContext == null) {
current.remove();
} else {
current.set(aValidationContext);
}
}
}
package org.apache.bval.json;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;
import java.util.*;
import org.apache.bval.model.MetaBean;
public class JSONGenerator {
private final Template template;
public JSONGenerator() throws IOException {
this("bean-infos-json.ftl");
}
public JSONGenerator(String templateName) throws IOException {
Configuration freemarker = new Configuration();
freemarker.setClassForTemplateLoading(getClass(), "");
template = freemarker.getTemplate(templateName);
}
public JSONGenerator(Template template) {
this.template = template;
}
public String toJSON(MetaBean metaBean) throws IOException, TemplateException {
List<MetaBean> metaBeans = new ArrayList(1);
metaBeans.add(metaBean);
return toJSON(metaBeans);
}
public String toJSON(Collection<MetaBean> metaBeans)
throws IOException, TemplateException {
final StringWriter out = new StringWriter();
toJSON(metaBeans, out);
return out.toString();
}
public void toJSON(Collection<MetaBean> metaBeans, Writer out)
throws IOException, TemplateException {
Map rootMap = new HashMap();
rootMap.put("metaBeans", metaBeans);
rootMap.put("generator", this);
template.process(rootMap, out);
}
}
package org.apache.bval.model;
package org.apache.bval.model;
package org.apache.bval.model;
public interface Features {
public interface Bean {
String MAIN_KEY = "mainKey";
String DOMAIN = "domain";
String UNIQUE_KEY = "uniqueKey";
}
public interface Property {
String ENUM = "enum";
String UNIQUE_KEY = "uniqueKey";
String MANDATORY = "mandatory";
String MAX_LENGTH = "maxLen";
String MAX_VALUE = "maxValue";
String MIN_LENGTH = "minLen";
String MIN_VALUE = "minValue";
String DEFAULT_VALUE = "defValue";
String READONLY = "readonly";
String DENIED = "denied";
String REG_EXP = "regExp";
String TIME_LAG = "timeLag";
String HIDDEN = "hidden";
String PREFERRED = "preferred";
String REF_BEAN_ID = "refBeanId";
String REF_BEAN_TYPE = "refBeanType";
String REF_CASCADE = "refCascade";
String JAVASCRIPT_VALIDATION_FUNCTIONS = "jsFunctions";
}
}
package org.apache.bval.model;
import org.apache.commons.collections.FastHashMap;
import java.io.Serializable;
import java.util.Map;
public abstract class FeaturesCapable implements Serializable {
private FastHashMap features = new FastHashMap();
private Validation[] validations = new Validation[0];
public FeaturesCapable() {
features.setFast(true);
}
public Map<String, Object> getFeatures() {
return features;
}
public void optimizeRead(boolean fast) {
features.setFast(fast);
}
public <T> T getFeature(String key) {
return (T) features.get(key);
}
public <T> T getFeature(String key, T defaultValue) {
final T v = (T) features.get(key);
if (v == null) {
return (features.containsKey(key)) ? null : defaultValue;
} else {
return v;
}
}
public <T> void putFeature(String key, T value) {
features.put(key, value);
}
public <T extends FeaturesCapable> T copy() {
try {
T self = (T) clone();
copyInto(self);
return self;
} catch (CloneNotSupportedException e) {
}
}
protected <T extends FeaturesCapable> void copyInto(T target) {
target.features = (FastHashMap) features.clone();
if (validations != null) {
target.validations = validations.clone();
}
}
public Validation[] getValidations() {
return validations;
}
public void addValidation(Validation validation) {
if (validations.length == 0) {
validations = new Validation[1];
} else {
System.arraycopy(validations, 0, newvalidations, 0, validations.length);
validations = newvalidations;
}
validations[validations.length - 1] = validation;
}
public boolean hasValidation(Validation aValidation) {
if (validations == null) return false;
for (Validation validation : validations) {
if (validation.equals(aValidation)) return true;
}
return false;
}
}
package org.apache.bval.model;
import org.apache.commons.lang.ArrayUtils;
public class MetaBean extends FeaturesCapable implements Cloneable, Features.Bean {
private String id;
private String name;
private Class beanClass;
private MetaProperty[] properties = new MetaProperty[0];
public String getId() {
return id;
}
public void setId(String id) {
this.id = id;
}
public String getName() {
return name;
}
public Class getBeanClass() {
return beanClass;
}
public void setName(String name) {
this.name = name;
}
public void setBeanClass(Class beanClass) {
this.beanClass = beanClass;
}
public MetaProperty[] getProperties() {
return properties;
}
public void setProperties(MetaProperty[] properties) {
this.properties = properties;
}
public MetaProperty getProperty(String name) {
for (MetaProperty p : properties) {
if (name.equals(p.getName())) return p;
}
return null;
}
public boolean hasRelationships() {
for (MetaProperty p : properties) {
if (p.isRelationship()) return true;
}
return false;
}
public boolean hasProperties() {
return properties.length > 0;
}
public void putProperty(String name, MetaProperty property) {
final MetaProperty oldProperty = getProperty(name);
if (properties.length == 0) {
properties = new MetaProperty[1];
} else {
System.arraycopy(properties, 0, newproperties, 0, properties.length);
properties = newproperties;
}
properties[properties.length - 1] = property;
int idx = ArrayUtils.indexOf(properties, oldProperty);
properties[idx] = property;
}
}
public String toString() {
}
@Override
protected <T extends FeaturesCapable> void copyInto(T target) {
super.copyInto(target);
final MetaBean copy = (MetaBean) target;
if (properties != null) {
copy.properties = properties.clone();
for (int i = copy.properties.length - 1; i >= 0; i--) {
copy.properties[i] = copy.properties[i].copy();
}
}
}
public MetaBean resolveMetaBean(Object bean) {
return bean == null || bean == beanClass || beanClass.isInstance(bean) ? this : null;
}
}
package org.apache.bval.model;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
public class MetaProperty extends FeaturesCapable
implements Cloneable, Features.Property {
private String name;
private Type type;
private MetaBean metaBean;
public MetaProperty() {
}
public MetaBean getMetaBean() {
return metaBean;
}
public void setMetaBean(MetaBean metaBean) {
this.metaBean = metaBean;
}
public boolean isRelationship() {
return metaBean != null;
}
public void setType(Type type) {
this.type = type;
}
public Type getType() {
return type;
}
public Class<?> getTypeClass() {
return getTypeClass(type);
}
private Class<?> getTypeClass(Type rawType) {
if (rawType instanceof Class) {
return (Class) rawType;
} else if (rawType instanceof ParameterizedType) {
} else if(rawType instanceof DynaType) {
} else {
}
}
public String getName() {
return name;
}
public boolean isMandatory() {
return getFeature(MANDATORY, Boolean.FALSE).booleanValue();
}
public void setMandatory(boolean mandatory) {
putFeature(MANDATORY, Boolean.valueOf(mandatory));
}
public String[] getJavaScriptValidations() {
return getFeature(JAVASCRIPT_VALIDATION_FUNCTIONS);
}
public void setName(String name) {
this.name = name;
}
public String toString() {
}
}
package org.apache.bval.model;
public interface Validation {
void validate(ValidationContext context);
}
package org.apache.bval.model;
import org.apache.bval.util.AccessStrategy;
public interface ValidationContext<T extends ValidationListener> {
Object getPropertyValue();
Object getPropertyValue(AccessStrategy access);
String getPropertyName();
T getListener();
Object getBean();
MetaBean getMetaBean();
void setMetaBean(MetaBean metaBean);
MetaProperty getMetaProperty();
void setBean(Object bean);
boolean collectValidated();
void setBean(Object aBean, MetaBean aMetaBean);
void setMetaProperty(MetaProperty metaProperty);
void moveDown(MetaProperty prop, AccessStrategy access);
void moveUp(Object bean, MetaBean metaBean);
void setCurrentIndex(int index);
void setCurrentKey(Object key);
}
package org.apache.bval.model;
import java.io.Serializable;
import org.apache.bval.ValidationResults;
public interface ValidationListener {
void addError(String reason, ValidationContext context);
void addError(Error error, ValidationContext context);
public class Error implements Serializable {
final String reason;
final Object owner;
final String propertyName;
public Error(String aReason, Object aOwner, String aPropertyName) {
this.reason = aReason;
this.owner = aOwner;
this.propertyName = aPropertyName;
}
public String getReason() {
return reason;
}
public Object getOwner() {
return owner;
}
public String getPropertyName() {
return propertyName;
}
public String toString() {
}
}
}
package org.apache.bval.routines;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
public class EMailValidation implements Validation {
private static String ATOM =
"[^\\x00-\\x1F^\\(^\\)^\\<^\\>^\\@^\\,^\\;^\\:^\\\\^\\\"^\\.^\\[^\\]^\\s]";
private static String IP_DOMAIN = "\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\]";
private static final java.util.regex.Pattern DEFAULT_PATTERN;
static {
DEFAULT_PATTERN = java.util.regex.Pattern.compile(
DOMAIN
"|"
IP_DOMAIN
")$",
java.util.regex.Pattern.CASE_INSENSITIVE
);
}
private java.util.regex.Pattern pattern = DEFAULT_PATTERN;
public void validate(ValidationContext context) {
if (context.getPropertyValue() == null) return;
if (!isValid(context.getPropertyValue(), pattern)) {
context.getListener().addError(Reasons.EMAIL_ADDRESS, context);
}
}
public Pattern getPattern() {
return pattern;
}
public void setPattern(Pattern pattern) {
this.pattern = pattern;
}
public static boolean isValid(Object value) {
return isValid(value, DEFAULT_PATTERN);
}
private static boolean isValid(Object value, Pattern aPattern) {
if (value == null) return true;
if (!(value instanceof String)) return false;
String string = (String) value;
if (string.length() == 0) return true;
Matcher m = aPattern.matcher(string);
return m.matches();
}
}
package org.apache.bval.routines;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
public class NOPValidation implements Validation {
public void validate(ValidationContext context) {
}
}
package org.apache.bval.routines;
import org.apache.bval.model.Features;
public interface Reasons extends Features.Property {
String EMAIL_ADDRESS = "emailAddress";
}
package org.apache.bval.routines;
import static org.apache.bval.routines.Reasons.*;
import java.util.Collection;
import java.util.Date;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.xml.XMLMetaValue;
public class StandardValidation implements Validation {
public String getValidationId() {
return "standard";
}
public void validate(ValidationContext context) {
validateMandatory(context);
validateMaxLength(context);
validateMinLength(context);
validateMaxValue(context);
validateMinValue(context);
validateRegExp(context);
validateTimeLag(context);
}
protected void validateTimeLag(ValidationContext context) {
String lag = (String) context.getMetaProperty().getFeature(TIME_LAG);
if (lag == null) return;
if (context.getPropertyValue() == null) return;
long date = ((Date) context.getPropertyValue()).getTime();
long now = System.currentTimeMillis();
if (XMLMetaValue.TIMELAG_Future.equals(lag)) {
if (date < now) {
context.getListener().addError(TIME_LAG, context);
}
} else if (XMLMetaValue.TIMELAG_Past.equals(lag)) {
if (date > now) {
context.getListener().addError(TIME_LAG, context);
}
} else {
}
}
private static final String REG_EXP_PATTERN = "cachedRegExpPattern";
protected void validateRegExp(ValidationContext context) {
final MetaProperty meta = context.getMetaProperty();
final String regExp = (String) meta.getFeature(REG_EXP);
if (regExp == null) return;
if (context.getPropertyValue() == null) return;
final String value = String.valueOf(context.getPropertyValue());
try {
Pattern pattern = (Pattern) meta.getFeature(REG_EXP_PATTERN);
if (pattern == null) {
pattern = Pattern.compile(regExp);
meta.putFeature(REG_EXP_PATTERN, pattern);
}
if (!pattern.matcher(value).matches()) {
context.getListener().addError(REG_EXP, context);
}
} catch (PatternSyntaxException e) {
throw new IllegalArgumentException(
}
}
protected void validateMinValue(ValidationContext context) {
Comparable minValue = (Comparable) context.getMetaProperty().getFeature(MIN_VALUE);
if (minValue == null || context.getPropertyValue() == null) return;
if (compare(context, minValue, context.getPropertyValue()) > 0) {
context.getListener().addError(MIN_VALUE, context);
}
}
protected void validateMaxValue(ValidationContext context) {
Comparable maxValue = (Comparable) context.getMetaProperty().getFeature(MAX_VALUE);
if (maxValue == null || context.getPropertyValue() == null) return;
if (compare(context, maxValue, context.getPropertyValue()) < 0) {
context.getListener().addError(MAX_VALUE, context);
}
}
private int compare(ValidationContext context, Comparable constraintValue,
Object currentValue) {
int r;
if (constraintValue.getClass().isAssignableFrom(currentValue.getClass())) {
r = constraintValue.compareTo(context.getPropertyValue());
} else if (currentValue instanceof Number) {
double dv = ((Number) currentValue).doubleValue();
double mdv = ((Number) constraintValue).doubleValue();
r = mdv > dv ? 1 : -1;
} else {
r = String.valueOf(constraintValue).compareTo(String.valueOf(currentValue));
}
return r;
}
protected void validateMaxLength(ValidationContext context) {
Integer maxLength = (Integer) context.getMetaProperty()
.getFeature(Features.Property.MAX_LENGTH);
if (maxLength == null) return;
if (context.getPropertyValue() == null) return;
final Object value = context.getPropertyValue();
int length = 0;
if (value instanceof String) {
length = ((String) value).length();
} else if (value instanceof Collection) {
length = ((Collection) value).size();
}
if (length > maxLength) {
context.getListener().addError(MAX_LENGTH, context);
}
}
protected void validateMinLength(ValidationContext context) {
Integer maxLength = (Integer) context.getMetaProperty()
.getFeature(Features.Property.MIN_LENGTH);
if (maxLength == null) return;
if (context.getPropertyValue() == null) return;
final Object value = context.getPropertyValue();
int length = 0;
if (value instanceof String) {
length = ((String) value).length();
} else if (value instanceof Collection) {
length = ((Collection) value).size();
}
if (length < maxLength) {
context.getListener().addError(MIN_LENGTH, context);
}
}
protected void validateMandatory(ValidationContext context) {
if (context.getMetaProperty().isMandatory()) {
if (context.getPropertyValue() == null) {
context.getListener().addError(MANDATORY, context);
}
}
}
public static StandardValidation getInstance() {
return new StandardValidation();
}
}
package org.apache.bval.util;
package org.apache.bval.util;
package org.apache.bval.util;
package org.apache.bval.util;
package org.apache.bval.util;
package org.apache.bval.xml;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import org.apache.bval.model.FeaturesCapable;
public class XMLFeaturesCapable implements Serializable {
@XStreamImplicit
private List<XMLMetaFeature> features;
@XStreamImplicit(itemFieldName = "validator")
private List<XMLMetaValidatorReference> validators;
public List<XMLMetaFeature> getFeatures() {
return features;
}
public void setFeatures(List<XMLMetaFeature> features) {
this.features = features;
}
public void putFeature(String key, Object value) {
XMLMetaFeature anno = findFeature(key);
if (features == null) features = new ArrayList<XMLMetaFeature>();
if (anno == null) {
features.add(new XMLMetaFeature(key, value));
} else {
anno.setValue(value);
}
}
public void removeFeature(String key) {
XMLMetaFeature anno = findFeature(key);
if (anno != null) {
getFeatures().remove(anno);
}
}
public Object getFeature(String key) {
XMLMetaFeature anno = findFeature(key);
return anno == null ? null : anno.getValue();
}
private XMLMetaFeature findFeature(String key) {
if (features == null) return null;
for (XMLMetaFeature anno : features) {
if (key.equals(anno.getKey())) return anno;
}
return null;
}
public List<XMLMetaValidatorReference> getValidators() {
return validators;
}
public void setValidators(List<XMLMetaValidatorReference> validators) {
this.validators = validators;
}
public void addValidator(String validatorId) {
if (validators == null) validators = new ArrayList<XMLMetaValidatorReference>();
validators.add(new XMLMetaValidatorReference(validatorId));
}
public void mergeFeaturesInto(FeaturesCapable fc) {
if (getFeatures() != null) {
fc.optimizeRead(false);
for (XMLMetaFeature each : getFeatures()) {
fc.putFeature(each.getKey(), each.getValue());
}
fc.optimizeRead(true);
}
}
}
package org.apache.bval.xml;
import com.thoughtworks.xstream.XStream;
public class XMLMapper {
private static final XMLMapper instance = new XMLMapper();
private final XStream xStream;
private XMLMapper() {
xStream = new XStream();
xStream.processAnnotations(new Class[] {XMLFeaturesCapable.class,
XMLMetaFeature.class, XMLMetaBean.class, XMLMetaBeanInfos.class,
XMLMetaBeanReference.class, XMLMetaElement.class, XMLMetaProperty.class,
XMLMetaValidator.class, XMLMetaValidatorReference.class});
xStream.setMode(XStream.NO_REFERENCES);
}
public static XMLMapper getInstance() {
return instance;
}
public XStream getXStream() {
return xStream;
}
}
package org.apache.bval.xml;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import java.util.ArrayList;
import java.util.List;
@XStreamAlias("bean")
public class XMLMetaBean extends XMLFeaturesCapable {
@XStreamAsAttribute()
private String id;
@XStreamAsAttribute()
private String name;
@XStreamAsAttribute()
private String impl;
@XStreamImplicit
private List<XMLMetaProperty> properties;
@XStreamImplicit
private List<XMLMetaBeanReference> beanRelations;
public String getId() {
return id;
}
public void setId(String id) {
this.id = id;
}
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public String getImpl() {
return impl;
}
public void setImpl(String impl) {
this.impl = impl;
}
public List<XMLMetaProperty> getProperties() {
return properties;
}
public void setProperties(List<XMLMetaProperty> properties) {
this.properties = properties;
}
public void addProperty(XMLMetaProperty property) {
if (properties == null) properties = new ArrayList();
properties.add(property);
}
public void putProperty(XMLMetaProperty property) {
if (property.getName() != null) {
XMLMetaProperty prop = findProperty(property.getName());
if (prop != null) {
properties.remove(prop);
}
}
addProperty(property);
}
public XMLMetaProperty removeProperty(String name) {
XMLMetaProperty prop = findProperty(name);
if (prop != null) {
properties.remove(prop);
}
return prop;
}
public XMLMetaProperty getProperty(String name) {
return findProperty(name);
}
private XMLMetaProperty findProperty(String name) {
if (properties == null) return null;
for (XMLMetaProperty prop : properties) {
if (name.equals(prop.getName())) return prop;
}
return null;
}
public List<XMLMetaBeanReference> getBeanRefs() {
return beanRelations;
}
public void setBeanRefs(List<XMLMetaBeanReference> beanRelations) {
this.beanRelations = beanRelations;
}
public void addBeanRef(XMLMetaBeanReference beanRelation) {
if (beanRelations == null) beanRelations = new ArrayList();
beanRelations.add(beanRelation);
}
public void putBeanRef(XMLMetaBeanReference beanRelation) {
if (beanRelation.getName() != null) {
XMLMetaBeanReference relation = findBeanRef(beanRelation.getName());
if (relation != null) {
beanRelations.remove(relation);
}
}
addBeanRef(beanRelation);
}
public XMLMetaBeanReference removeBeanRef(String name) {
XMLMetaBeanReference relation = findBeanRef(name);
if (relation != null) {
beanRelations.remove(relation);
}
return relation;
}
public XMLMetaBeanReference getBeanRef(String name) {
return findBeanRef(name);
}
private XMLMetaBeanReference findBeanRef(String name) {
if (beanRelations == null) return null;
for (XMLMetaBeanReference relation : beanRelations) {
if (name.equals(relation.getName())) return relation;
}
return null;
}
}
package org.apache.bval.xml;
import static org.apache.bval.model.Features.Property.JAVASCRIPT_VALIDATION_FUNCTIONS;
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.routines.StandardValidation;
package org.apache.bval.xml;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import com.thoughtworks.xstream.annotations.XStreamOmitField;
import org.apache.bval.model.Validation;
import org.apache.commons.collections.FastHashMap;
import org.apache.commons.lang.ClassUtils;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
@XStreamAlias("beanInfos")
public class XMLMetaBeanInfos {
@XStreamAsAttribute
private String id;
@XStreamAsAttribute
private String version;
@XStreamImplicit
private List<XMLMetaValidator> validators;
@XStreamImplicit
private List<XMLMetaBean> beans;
@XStreamOmitField
private Map<String, XMLMetaBean> beanLookup;
@XStreamOmitField
private Map<String, XMLMetaValidator> validationLookup;
public String getId() {
return id;
}
public void setId(String id) {
this.id = id;
}
public String getVersion() {
return version;
}
public void setVersion(String version) {
this.version = version;
}
public List<XMLMetaValidator> getValidators() {
return validators;
}
public void setValidators(List<XMLMetaValidator> validators) {
this.validators = validators;
}
public List<XMLMetaBean> getBeans() {
return beans;
}
public void setBeans(List<XMLMetaBean> beans) {
this.beans = beans;
}
public XMLMetaBean getBean(String id) {
if (beans == null) return null;
if (beanLookup == null) initBeanLookup();
return beanLookup.get(id);
}
private void initBeanLookup() {
beanLookup = new FastHashMap();
for (XMLMetaBean bean : beans) {
beanLookup.put(bean.getId(), bean);
}
((FastHashMap) beanLookup).setFast(true);
}
private void initValidationLookup() throws Exception {
validationLookup = new FastHashMap();
for (XMLMetaValidator xv : validators) {
if (xv.getJava() != null) {
Validation validation =
(Validation) ClassUtils.getClass(xv.getJava()).newInstance();
xv.setValidation(validation);
validationLookup.put(xv.getId(), xv);
}
}
((FastHashMap) validationLookup).setFast(true);
}
public void addBean(XMLMetaBean bean) {
if (beans == null) beans = new ArrayList();
beans.add(bean);
}
public XMLMetaValidator getValidator(String id) throws Exception {
if (validators == null) return null;
if (validationLookup == null) initValidationLookup();
return validationLookup.get(id);
}
public void addValidator(XMLMetaValidator validator) {
if (validators == null) validators = new ArrayList();
validators.add(validator);
}
}
package org.apache.bval.xml;
import java.io.IOException;
public interface XMLMetaBeanLoader {
XMLMetaBeanInfos load() throws IOException;
}
package org.apache.bval.xml;
import static org.apache.bval.model.Features.Property.REF_BEAN_ID;
import org.apache.bval.model.MetaProperty;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
@XStreamAlias("relationship")
public class XMLMetaBeanReference extends XMLMetaElement {
@XStreamAsAttribute
private String beanId;
public XMLMetaBeanReference(String refId) {
this.beanId = refId;
}
public XMLMetaBeanReference() {
}
public String getBeanId() {
return beanId;
}
public void setBeanId(String beanId) {
this.beanId = beanId;
}
@Override
public void mergeInto(MetaProperty prop) throws ClassNotFoundException {
if (getBeanId() != null) {
prop.putFeature(REF_BEAN_ID, getBeanId());
}
}
}
package org.apache.bval.xml;
public interface XMLMetaBeanRegistry {
void addLoader(XMLMetaBeanLoader loader);
void addResourceLoader(String resource);
}
package org.apache.bval.xml;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
public class XMLMetaBeanURLLoader implements XMLMetaBeanLoader {
private final URL url;
public XMLMetaBeanURLLoader(URL url) {
if (url == null) throw new NullPointerException("URL required");
this.url = url;
}
public XMLMetaBeanInfos load() throws IOException {
InputStream stream = url.openStream();
try {
XMLMetaBeanInfos beanInfos = (XMLMetaBeanInfos) XMLMapper.getInstance()
.getXStream().fromXML(stream);
beanInfos.setId(url.toExternalForm());
return beanInfos;
} finally {
stream.close();
}
}
}
package org.apache.bval.xml;
import static org.apache.bval.model.Features.Property.*;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import org.apache.bval.model.MetaProperty;
import org.apache.commons.lang.ClassUtils;
public class XMLMetaElement extends XMLFeaturesCapable {
@XStreamAsAttribute()
private String name;
@XStreamAsAttribute()
private String mandatory;
@XStreamAsAttribute()
private Integer minLength;
@XStreamAsAttribute()
private Integer maxLength;
@XStreamAsAttribute()
private Boolean readonly;
@XStreamAsAttribute()
private Boolean hidden;
@XStreamAsAttribute()
private Boolean denied;
@XStreamAsAttribute()
private String type;
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public String getMandatory() {
return mandatory;
}
public void setMandatory(String mandatory) {
this.mandatory = mandatory;
}
public Integer getMinLength() {
return minLength;
}
public void setMinLength(Integer minLength) {
this.minLength = minLength;
}
public Integer getMaxLength() {
return maxLength;
}
public void setMaxLength(Integer maxLength) {
this.maxLength = maxLength;
}
public Boolean getReadonly() {
return readonly;
}
public void setReadonly(Boolean readonly) {
this.readonly = readonly;
}
public Boolean getDenied() {
return denied;
}
public void setDenied(Boolean denied) {
this.denied = denied;
}
public Boolean getHidden() {
return hidden;
}
public void setHidden(Boolean hidden) {
this.hidden = hidden;
}
public String getType() {
return type;
}
public void setType(String type) {
this.type = type;
}
public void mergeInto(MetaProperty prop) throws ClassNotFoundException {
mergeFeaturesInto(prop);
if (getType() != null && getType().length() > 0) {
}
if (getHidden() != null) {
prop.putFeature(HIDDEN, getHidden().booleanValue());
}
if (getMandatory() != null) {
prop.putFeature(MANDATORY, getMandatory().equals("true"));
}
if (getMaxLength() != null) {
prop.putFeature(MAX_LENGTH, getMaxLength());
}
if (getMinLength() != null) {
prop.putFeature(MIN_LENGTH, getMinLength());
}
if (getReadonly() != null) {
prop.putFeature(READONLY, getReadonly());
}
if (getDenied() != null) {
prop.putFeature(DENIED, getDenied());
}
}
}
package org.apache.bval.xml;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import java.io.Serializable;
@XStreamAlias("feature")
public class XMLMetaFeature implements Serializable {
@XStreamAsAttribute
private String key;
@XStreamAsAttribute
private Object value;
public XMLMetaFeature(String key, Object value) {
this.key = key;
this.value = value;
}
public XMLMetaFeature() {
}
public String getKey() {
return key;
}
public void setKey(String key) {
this.key = key;
}
public Object getValue() {
return value;
}
public void setValue(Object value) {
this.value = value;
}
}
package org.apache.bval.xml;
import static org.apache.bval.model.Features.Property.*;
import org.apache.bval.model.MetaProperty;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
@XStreamAlias("property")
public class XMLMetaProperty extends XMLMetaElement {
@XStreamAsAttribute()
@XStreamAsAttribute()
private String regexp;
@XStreamAsAttribute()
private String timeLag;
public Integer getMaxValue() {
return maxValue;
}
public void setMaxValue(Integer maxValue) {
this.maxValue = maxValue;
}
public Integer getMinValue() {
return minValue;
}
public void setMinValue(Integer minValue) {
this.minValue = minValue;
}
public String getRegexp() {
return regexp;
}
public void setRegexp(String regexp) {
this.regexp = regexp;
}
public String getTimeLag() {
return timeLag;
}
public void setTimeLag(String timeLag) {
this.timeLag = timeLag;
}
@Override
public void mergeInto(MetaProperty prop) throws ClassNotFoundException {
if (getMaxValue() != null) {
prop.putFeature(MAX_VALUE, getMaxValue());
}
if (getMinValue() != null) {
prop.putFeature(MIN_VALUE, getMinValue());
}
if (getRegexp() != null) {
prop.putFeature(REG_EXP, getRegexp());
}
if (getTimeLag() != null) {
prop.putFeature(TIME_LAG, getTimeLag());
}
}
}
package org.apache.bval.xml;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import com.thoughtworks.xstream.annotations.XStreamOmitField;
import java.io.Serializable;
import org.apache.bval.model.Validation;
@XStreamAlias("validator")
public class XMLMetaValidator implements Serializable {
@XStreamAsAttribute
private String id;
@XStreamAsAttribute
@XStreamAsAttribute
@XStreamOmitField
private Validation validation;
public String getId() {
return id;
}
public void setId(String id) {
this.id = id;
}
public String getJava() {
return java;
}
public void setJava(String java) {
this.java = java;
}
public void setValidation(Validation validation) {
this.validation = validation;
}
public Validation getValidation() {
return validation;
}
public String getJsFunction() {
return jsFunction;
}
public void setJsFunction(String jsFunction) {
this.jsFunction = jsFunction;
}
}
package org.apache.bval.xml;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import java.io.Serializable;
@XStreamAlias("validator-ref")
public class XMLMetaValidatorReference implements Serializable {
@XStreamAsAttribute
private String refId;
public XMLMetaValidatorReference(String id) {
this.refId = id;
}
public XMLMetaValidatorReference() {
}
public String getRefId() {
return refId;
}
public void setRefId(String refId) {
this.refId = refId;
}
}
package org.apache.bval.xml;
public interface XMLMetaValue {
public static final String ANNOKEY_Widget = "WIDGET";
public static final String ANNOKEY_TableColumn = "TABLE_COLUMN";
public static final String TIMELAG_Past = "PAST";
public static final String TIMELAG_Future = "FUTURE";
public static final String MANDATORY = "true";
public static final String OPTIONAL = "false";
}
package org.apache.bval.example;
public enum BusinessEnum {
VALUE1, VALUE2, VALUE3
}
package org.apache.bval.example;
import java.sql.Timestamp;
import java.util.Date;
import java.util.List;
public class BusinessObject {
private long userId;
private int numericValue;
private String firstName, lastName, title;
private Date dateBirth;
private Timestamp validTo;
private String email;
private BusinessEnum choice;
private BusinessObjectAddress address;
private List<BusinessObjectAddress> addresses;
private List properties;
public BusinessEnum getChoice() {
return choice;
}
public void setChoice(BusinessEnum choice) {
this.choice = choice;
}
public String getTitle() {
return title;
}
public void setTitle(String title) {
this.title = title;
}
public Date getDateBirth() {
return dateBirth;
}
public void setDateBirth(Date dateBirth) {
this.dateBirth = dateBirth;
}
public Timestamp getValidTo() {
return validTo;
}
public void setValidTo(Timestamp validTo) {
this.validTo = validTo;
}
public String getEmail() {
return email;
}
public void setEmail(String email) {
this.email = email;
}
public BusinessObjectAddress getAddress() {
return address;
}
public void setAddress(BusinessObjectAddress address) {
this.address = address;
}
public void setNumericValue(int newNumericValue) {
numericValue = newNumericValue;
}
public int getNumericValue() {
return numericValue;
}
public String getFirstName() {
return firstName;
}
public void setFirstName(String firstName) {
this.firstName = firstName;
}
public String getLastName() {
return lastName;
}
public void setLastName(String lastName) {
this.lastName = lastName;
}
public long getUserId() {
return userId;
}
public void setUserId(long userId) {
this.userId = userId;
}
public List<BusinessObjectAddress> getAddresses() {
return addresses;
}
public void setAddresses(List<BusinessObjectAddress> addresses) {
this.addresses = addresses;
}
public List getProperties() {
return properties;
}
public void setProperties(List properties) {
this.properties = properties;
}
package org.apache.bval.example;
public class BusinessObjectAddress {
private String city, country;
private BusinessObject owner;
public String getCity() {
return city;
}
public void setCity(String city) {
this.city = city;
}
public String getCountry() {
return country;
}
public void setCountry(String country) {
this.country = country;
}
public BusinessObject getOwner() {
return owner;
}
public void setOwner(BusinessObject owner) {
this.owner = owner;
}
}
package org.apache.bval.example;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.beans.SimpleBeanInfo;
import org.apache.bval.model.Features;
public class BusinessObjectBeanInfo extends SimpleBeanInfo {
Class targetClass = BusinessObject.class;
@Override
public BeanInfo[] getAdditionalBeanInfo() {
ExplicitBeanInfo bi = new ExplicitBeanInfo();
bi.setPropertyDescriptors(_getPropertyDescriptors());
return new BeanInfo[]{bi};
}
public PropertyDescriptor[] _getPropertyDescriptors() {
try {
PropertyDescriptor numericValue = new PropertyDescriptor("numericValue",
targetClass, "getNumericValue", "setNumericValue");
numericValue.setValue(Features.Property.MAX_VALUE, new Integer(100));
numericValue.setValue(Features.Property.MIN_VALUE, new Integer(-100));
return new PropertyDescriptor[]{numericValue};
} catch (IntrospectionException ex) {
ex.printStackTrace();
return null;
}
}
}
class ExplicitBeanInfo extends SimpleBeanInfo {
private PropertyDescriptor[] propertyDescriptors;
@Override
public PropertyDescriptor[] getPropertyDescriptors() {
return propertyDescriptors;
}
public void setPropertyDescriptors(PropertyDescriptor[] propertyDescriptors) {
this.propertyDescriptors = propertyDescriptors;
}
package org.apache.bval.example;
import java.util.List;
import org.apache.bval.Validate;
import org.apache.bval.ValidationResults;
public interface ExampleBusinessObjectService {
@Validate
public void saveBusinessObject(@Validate BusinessObject object, Object other);
@Validate
public void saveBusinessObjects(@Validate BusinessObject[] object);
public ValidationResults validateBusinessObject(
@Validate("BusinessObject")BusinessObject object);
public List<BusinessObject> findBusinessObjects(BusinessObject example);
}
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Documented;
import static java.lang.annotation.ElementType.*;
import java.lang.annotation.Retention;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Target;
@Documented
@Constraint(validatedBy = EmailValidator.class)
@Target({METHOD, FIELD, ANNOTATION_TYPE, PARAMETER})
@Retention(RUNTIME)
public @interface Email {
Class<?>[] groups() default {};
String message() default "{org.apache.bval.constraints.Email.message}";
Class<? extends Payload>[] payload() default {};
}
package org.apache.bval.constraints;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import org.apache.bval.routines.EMailValidation;
public class EmailValidator implements ConstraintValidator<Email, String> {
protected final EMailValidation validation = new EMailValidation();
public boolean isValid(String value, ConstraintValidatorContext context) {
return validation.isValid(value);
}
public void initialize(Email parameters) {
}
}
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Documented;
import static java.lang.annotation.ElementType.*;
import java.lang.annotation.Retention;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Target;
@Documented
@Constraint(
validatedBy = {NotEmptyValidatorForCollection.class, NotEmptyValidatorForMap.class,
NotEmptyValidatorForString.class, NotEmptyValidator.class})
@Target({METHOD, FIELD, ANNOTATION_TYPE, PARAMETER})
@Retention(RUNTIME)
public @interface NotEmpty {
Class<?>[] groups() default {};
String message() default "{org.apache.bval.constraints.NotEmpty.message}";
Class<? extends Payload>[] payload() default {};
}
package org.apache.bval.constraints;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import java.lang.reflect.Array;
import java.lang.reflect.Method;
public class NotEmptyValidator implements ConstraintValidator<NotEmpty, Object> {
public void initialize(NotEmpty constraintAnnotation) {
}
public boolean isValid(Object value, ConstraintValidatorContext context) {
if (value == null) return true;
if (value.getClass().isArray()) {
return Array.getLength(value) > 0;
} else {
try {
Method isEmptyMethod = value.getClass().getMethod("isEmpty");
if (isEmptyMethod != null) {
return !((Boolean) isEmptyMethod.invoke(value)).booleanValue();
}
} catch (Exception ex) {
}
return value.toString().length() > 0;
}
}
}
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import javax.validation.constraints.NotNull;
public class NotNullValidator implements ConstraintValidator<NotNull, Object> {
public void initialize(NotNull constraintAnnotation) {
}
public boolean isValid(Object value, ConstraintValidatorContext context) {
return value != null;
}
}
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import javax.validation.constraints.Pattern;
import java.util.regex.PatternSyntaxException;
public class PatternValidator implements ConstraintValidator<Pattern, String> {
protected java.util.regex.Pattern pattern;
public void initialize(Pattern annotation) {
Pattern.Flag flags[] = annotation.flags();
int intFlag = 0;
for (Pattern.Flag flag : flags) {
intFlag = intFlag | flag.getValue();
}
try {
pattern = java.util.regex.Pattern.compile(annotation.regexp(), intFlag);
} catch (PatternSyntaxException e) {
throw new IllegalArgumentException("Invalid regular expression.", e);
}
}
public boolean isValid(String value, ConstraintValidatorContext context) {
return value == null || pattern.matcher(value).matches();
}
}
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.jsr303;
import org.apache.bval.*;
import org.apache.bval.IntrospectorMetaBeanFactory;
import org.apache.bval.MetaBeanBuilder;
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.MetaBeanManager;
import org.apache.bval.xml.XMLMetaBeanFactory;
package org.apache.bval.jsr303;
import javax.validation.Configuration;
import javax.validation.ValidationException;
import javax.validation.spi.BootstrapState;
import javax.validation.spi.ConfigurationState;
import javax.validation.spi.ValidationProvider;
public class AgimatecValidationProvider
implements ValidationProvider<AgimatecValidatorConfiguration> {
public boolean isSuitable(Class<? extends Configuration<?>> builderClass) {
return AgimatecValidatorConfiguration.class == builderClass;
}
public ConfigurationImpl createSpecializedConfiguration(BootstrapState state) {
return new ConfigurationImpl(state, this);
}
public Configuration<?> createGenericConfiguration(BootstrapState state) {
return new ConfigurationImpl(state, null);
}
public AgimatecValidatorFactory buildValidatorFactory(ConfigurationState configuration) {
try {
AgimatecValidatorFactory factory = new AgimatecValidatorFactory();
factory.configure(configuration);
return factory;
} catch (RuntimeException ex) {
throw new ValidationException("error building ValidatorFactory", ex);
}
}
}
package org.apache.bval.jsr303;
import javax.validation.Configuration;
public interface AgimatecValidatorConfiguration
extends Configuration<AgimatecValidatorConfiguration> {
public interface Properties {
String VALIDATION_XML_PATH = "agimatec.validation-xml-path";
String ENABLE_INTROSPECTOR = "agimatec.enable-introspector";
String ENABLE_METABEANS_XML = "agimatec.enable-metabeans-xml";
String TREAT_MAPS_LIKE_BEANS = "agimatec.treat-maps-like-beans";
}
}
package org.apache.bval.jsr303;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.jsr303.xml.AnnotationIgnores;
import org.apache.bval.jsr303.xml.MetaConstraint;
import org.apache.bval.jsr303.xml.ValidationMappingParser;
import org.apache.bval.util.AccessStrategy;
import org.apache.commons.lang.ClassUtils;
import javax.validation.*;
import javax.validation.bootstrap.ProviderSpecificBootstrap;
import javax.validation.spi.ConfigurationState;
import java.lang.annotation.Annotation;
import java.util.*;
public class AgimatecValidatorFactory implements ValidatorFactory, Cloneable {
private static AgimatecValidatorFactory DEFAULT_FACTORY;
private static final ConstraintDefaults defaultConstraints = new ConstraintDefaults();
private MessageInterpolator messageResolver;
private TraversableResolver traversableResolver;
private ConstraintValidatorFactory constraintValidatorFactory;
private final Map<String, String> properties;
private final AnnotationIgnores annotationIgnores = new AnnotationIgnores();
private final ConstraintCached constraintsCache = new ConstraintCached();
private final Map<Class<?>, Class<?>[]> defaultSequences;
private final Map<Class<?>, List<AccessStrategy>> validAccesses;
private final Map<Class<?>, List<MetaConstraint<?, ? extends Annotation>>> constraintMap;
public static AgimatecValidatorFactory getDefault() {
if (DEFAULT_FACTORY == null) {
ProviderSpecificBootstrap<AgimatecValidatorConfiguration> provider =
Validation.byProvider(AgimatecValidationProvider.class);
AgimatecValidatorConfiguration configuration = provider.configure();
DEFAULT_FACTORY = (AgimatecValidatorFactory) configuration
.buildValidatorFactory();
}
return DEFAULT_FACTORY;
}
public AgimatecValidatorFactory() {
properties = new HashMap<String, String>();
defaultSequences = new HashMap();
validAccesses = new HashMap();
constraintMap = new HashMap();
}
public void configure(ConfigurationState configuration) {
getProperties().putAll(configuration.getProperties());
setMessageInterpolator(configuration.getMessageInterpolator());
setTraversableResolver(configuration.getTraversableResolver());
setConstraintValidatorFactory(configuration.getConstraintValidatorFactory());
ValidationMappingParser parser = new ValidationMappingParser(this);
parser.processMappingConfig(configuration.getMappingStreams());
}
public Map<String, String> getProperties() {
return properties;
}
protected MessageInterpolator getDefaultMessageInterpolator() {
return messageResolver;
}
public Validator getValidator() {
return usingContext().getValidator();
}
public AgimatecFactoryContext usingContext() {
return new AgimatecFactoryContext(this);
}
@SuppressWarnings({"CloneDoesntDeclareCloneNotSupportedException"})
@Override
public synchronized AgimatecValidatorFactory clone() {
try {
return (AgimatecValidatorFactory) super.clone();
} catch (CloneNotSupportedException e) {
}
}
public final void setMessageInterpolator(MessageInterpolator messageResolver) {
this.messageResolver = messageResolver;
}
public MessageInterpolator getMessageInterpolator() {
return ((messageResolver != null) ? messageResolver : getDefaultMessageInterpolator());
}
public final void setTraversableResolver(TraversableResolver traversableResolver) {
this.traversableResolver = traversableResolver;
}
public TraversableResolver getTraversableResolver() {
return traversableResolver;
}
public ConstraintValidatorFactory getConstraintValidatorFactory() {
return constraintValidatorFactory;
}
public final void setConstraintValidatorFactory(
ConstraintValidatorFactory constraintValidatorFactory) {
this.constraintValidatorFactory = constraintValidatorFactory;
}
public <T> T unwrap(Class<T> type) {
if (type.isAssignableFrom(getClass())) {
return (T) this;
} else if (!type.isInterface()) {
return SecureActions.newInstance(type);
} else {
try {
return SecureActions.newInstance(cls);
} catch (ClassNotFoundException e) {
}
}
}
public ConstraintDefaults getDefaultConstraints() {
return defaultConstraints;
}
public AnnotationIgnores getAnnotationIgnores() {
return annotationIgnores;
}
public ConstraintCached getConstraintsCache() {
return constraintsCache;
}
public void addMetaConstraint(Class<?> beanClass, MetaConstraint<?, ?> metaConstraint) {
List<MetaConstraint<?,? extends Annotation>> slot = constraintMap.get(beanClass);
if (slot != null) {
slot.add(metaConstraint);
} else {
List<MetaConstraint<?, ? extends Annotation>> constraintList =
new ArrayList<MetaConstraint<?, ? extends Annotation>>();
constraintList.add(metaConstraint);
constraintMap.put(beanClass, constraintList);
}
}
public void addValid(Class<?> beanClass, AccessStrategy accessStategy) {
List<AccessStrategy> slot = validAccesses.get(beanClass);
if (slot != null) {
slot.add(accessStategy);
} else {
List<AccessStrategy> tmpList = new ArrayList();
tmpList.add(accessStategy);
validAccesses.put(beanClass, tmpList);
}
}
public void addDefaultSequence(Class<?> beanClass, Class<?>[] groupSequence) {
defaultSequences.put(beanClass, groupSequence);
}
public <T> List<MetaConstraint<T, ? extends Annotation>> getMetaConstraints(
Class<T> beanClass) {
List<MetaConstraint<?,? extends Annotation>> slot = constraintMap.get(beanClass);
if (slot != null) {
return (List)slot;
} else {
return Collections.EMPTY_LIST;
}
}
public List<AccessStrategy> getValidAccesses(Class<?> beanClass) {
List<AccessStrategy> slot = validAccesses.get(beanClass);
if (slot != null) {
return slot;
} else {
return Collections.EMPTY_LIST;
}
}
public Class<?>[] getDefaultSequence(Class<?> beanClass) {
return defaultSequences.get(beanClass);
}
}
package org.apache.bval.jsr303;
import org.apache.bval.jsr303.groups.GroupsComputer;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.AccessStrategy;
package org.apache.bval.jsr303;
package org.apache.bval.jsr303;
package org.apache.bval.jsr303;
import org.apache.bval.model.FeaturesCapable;
package org.apache.bval.jsr303;
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
package org.apache.bval.jsr303;
import org.apache.bval.BeanValidator;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.Groups;
import org.apache.bval.jsr303.groups.GroupsComputer;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.ValidationContext;
import org.apache.commons.lang.ClassUtils;
import javax.validation.ConstraintViolation;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.metadata.BeanDescriptor;
import java.util.List;
import java.util.Set;
public class ClassValidator extends BeanValidator implements Validator {
protected final AgimatecFactoryContext factoryContext;
protected final GroupsComputer groupsComputer = new GroupsComputer();
public ClassValidator(AgimatecFactoryContext factoryContext) {
super(factoryContext.getMetaBeanFinder());
this.factoryContext = factoryContext;
}
public ClassValidator(AgimatecValidatorFactory factory) {
this(factory.usingContext());
}
public <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groupArray) {
if (object == null) throw new IllegalArgumentException("cannot validate null");
try {
final GroupValidationContext<ConstraintValidationListener<T>> context =
createContext(factoryContext.getMetaBeanFinder()
.findForClass(object.getClass()), object, groupArray);
final ConstraintValidationListener result = context.getListener();
final Groups groups = context.getGroups();
for (Group current : groups.getGroups()) {
context.setCurrentGroup(current);
validateContext(context);
}
for (List<Group> eachSeq : groups.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validateContext(context);
if (!result.isEmpty()) break;
}
}
return result.getConstaintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, object);
}
}
@Override
public void validateBeanNet(ValidationContext vcontext) {
GroupValidationContext context = (GroupValidationContext) vcontext;
List<Group> defaultGroups = expandDefaultGroup(context);
if (defaultGroups != null) {
Group currentGroup = context.getCurrentGroup();
for (Group each : defaultGroups) {
context.setCurrentGroup(each);
super.validateBeanNet(context);
}
} else {
super.validateBeanNet(context);
}
}
private List<Group> expandDefaultGroup(GroupValidationContext context) {
if (context.getCurrentGroup().isDefault()) {
List<Group> groupSeq =
context.getMetaBean().getFeature(Jsr303Features.Bean.GROUP_SEQUENCE);
if (groupSeq != null) {
context.getGroups().assertDefaultGroupSequenceIsExpandable(groupSeq);
}
return groupSeq;
} else {
return null;
}
}
protected ValidationException unrecoverableValidationError(RuntimeException ex,
Object object) {
if (ex instanceof ValidationException) {
} else {
}
}
public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName,
Class<?>... groups) {
if (object == null) throw new IllegalArgumentException("cannot validate null");
try {
MetaBean metaBean =
factoryContext.getMetaBeanFinder().findForClass(object.getClass());
GroupValidationContext<ConstraintValidationListener<T>> context =
createContext(metaBean, object, groups);
ConstraintValidationListener result = context.getListener();
NestedMetaProperty nestedProp = getNestedProperty(metaBean, object, propertyName);
context.setMetaProperty(nestedProp.getMetaProperty());
if (nestedProp.isNested()) {
context.setFixedValue(nestedProp.getValue());
} else {
context.setMetaProperty(nestedProp.getMetaProperty());
}
if (context.getMetaProperty() == null) throw new IllegalArgumentException(
Groups sequence = context.getGroups();
for (Group current : sequence.getGroups()) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
}
for (List<Group> eachSeq : sequence.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
if (!result.isEmpty()) break;
}
}
return result.getConstaintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, object);
}
}
private void validatePropertyInGroup(GroupValidationContext context) {
Group currentGroup = context.getCurrentGroup();
List<Group> defaultGroups = expandDefaultGroup(context);
if (defaultGroups != null) {
for (Group each : defaultGroups) {
context.setCurrentGroup(each);
validateProperty(context);
}
} else {
validateProperty(context);
}
}
private NestedMetaProperty getNestedProperty(MetaBean metaBean, Object t,
String propertyName) {
NestedMetaProperty nested = new NestedMetaProperty(propertyName, t);
nested.setMetaBean(metaBean);
nested.parse();
return nested;
}
public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType,
String propertyName, Object value,
Class<?>... groups) {
try {
MetaBean metaBean = factoryContext.getMetaBeanFinder().findForClass(beanType);
GroupValidationContext<ConstraintValidationListener<T>> context =
createContext(metaBean, null, groups);
ConstraintValidationListener result = context.getListener();
context.setMetaProperty(
getNestedProperty(metaBean, null, propertyName).getMetaProperty());
context.setFixedValue(value);
Groups sequence = context.getGroups();
for (Group current : sequence.getGroups()) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
}
for (List<Group> eachSeq : sequence.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
if (!result.isEmpty()) break;
}
}
return result.getConstaintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, value);
}
}
protected <T> GroupValidationContext<ConstraintValidationListener<T>> createContext(
MetaBean metaBean, T object, Class<?>[] groups) {
ConstraintValidationListener<T> listener = new ConstraintValidationListener<T>(object);
GroupValidationContextImpl<ConstraintValidationListener<T>> context =
new GroupValidationContextImpl(listener,
this.factoryContext.getMessageInterpolator(),
this.factoryContext.getTraversableResolver(), metaBean);
context.setBean(object, metaBean);
context.setGroups(groupsComputer.computeGroups(groups));
return context;
}
public BeanDescriptor getConstraintsForClass(Class<?> clazz) {
try {
MetaBean metaBean = factoryContext.getMetaBeanFinder().findForClass(clazz);
BeanDescriptorImpl edesc =
metaBean.getFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR);
if (edesc == null) {
edesc = createBeanDescriptor(metaBean);
metaBean.putFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR, edesc);
}
return edesc;
} catch (RuntimeException ex) {
}
}
protected BeanDescriptorImpl createBeanDescriptor(MetaBean metaBean) {
return new BeanDescriptorImpl(factoryContext, metaBean, metaBean.getValidations());
}
public <T> T unwrap(Class<T> type) {
if (type.isAssignableFrom(getClass())) {
return (T) this;
} else if (!type.isInterface()) {
return SecureActions.newInstance(type, new Class[]{AgimatecFactoryContext.class},
new Object[]{factoryContext});
} else {
try {
return SecureActions.newInstance(cls,
new Class[]{AgimatecFactoryContext.class}, new Object[]{factoryContext});
} catch (ClassNotFoundException e) {
}
}
}
}
package org.apache.bval.jsr303;
import org.apache.bval.jsr303.resolver.DefaultTraversableResolver;
import org.apache.bval.jsr303.xml.ValidationParser;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.validation.*;
import javax.validation.spi.BootstrapState;
import javax.validation.spi.ConfigurationState;
import javax.validation.spi.ValidationProvider;
import java.io.InputStream;
import java.util.*;
public class ConfigurationImpl implements AgimatecValidatorConfiguration, ConfigurationState {
private static final Log log = LogFactory.getLog(ConfigurationImpl.class);
protected final ValidationProvider provider;
protected final ValidationProviderResolver providerResolver;
protected Class<? extends ValidationProvider<?>> providerClass;
protected MessageInterpolator messageInterpolator;
protected ConstraintValidatorFactory constraintValidatorFactory;
private TraversableResolver traversableResolver;
private boolean prepared = false;
private final TraversableResolver defaultTraversableResolver =
new DefaultTraversableResolver();
protected final MessageInterpolator defaultMessageInterpolator =
new DefaultMessageInterpolator();
private final ConstraintValidatorFactory defaultConstraintValidatorFactory =
new DefaultConstraintValidatorFactory();
private Set<InputStream> mappingStreams = new HashSet<InputStream>();
private Map<String, String> properties = new HashMap<String, String>();
private boolean ignoreXmlConfiguration = false;
public ConfigurationImpl(BootstrapState aState, ValidationProvider aProvider) {
if (aProvider != null) {
this.provider = aProvider;
this.providerResolver = null;
} else if (aState != null) {
this.provider = null;
if (aState.getValidationProviderResolver() == null) {
providerResolver = aState.getDefaultValidationProviderResolver();
} else {
providerResolver = aState.getValidationProviderResolver();
}
} else {
throw new ValidationException("either provider or state are required");
}
}
public AgimatecValidatorConfiguration traversableResolver(TraversableResolver resolver) {
traversableResolver = resolver;
this.prepared = false;
return this;
}
public AgimatecValidatorConfiguration ignoreXmlConfiguration() {
ignoreXmlConfiguration = true;
return this;
}
public ConfigurationImpl messageInterpolator(MessageInterpolator resolver) {
this.messageInterpolator = resolver;
this.prepared = false;
return this;
}
public ConfigurationImpl constraintValidatorFactory(
ConstraintValidatorFactory constraintFactory) {
this.constraintValidatorFactory = constraintFactory;
this.prepared = false;
return this;
}
public AgimatecValidatorConfiguration addMapping(InputStream stream) {
mappingStreams.add(stream);
return this;
}
public AgimatecValidatorConfiguration addProperty(String name, String value) {
properties.put(name, value);
return this;
}
public Map<String, String> getProperties() {
return properties;
}
public boolean isIgnoreXmlConfiguration() {
return ignoreXmlConfiguration;
}
public Set<InputStream> getMappingStreams() {
return mappingStreams;
}
public MessageInterpolator getMessageInterpolator() {
return messageInterpolator;
}
public MessageInterpolator getDefaultMessageInterpolator() {
return defaultMessageInterpolator;
}
public TraversableResolver getDefaultTraversableResolver() {
return defaultTraversableResolver;
}
public ConstraintValidatorFactory getDefaultConstraintValidatorFactory() {
return defaultConstraintValidatorFactory;
}
public ValidatorFactory buildValidatorFactory() {
prepare();
if (provider != null) {
return provider.buildValidatorFactory(this);
} else {
return findProvider().buildValidatorFactory(this);
}
}
private void prepare() {
if (prepared) return;
parseValidationXml();
applyDefaults();
prepared = true;
}
private void parseValidationXml() {
if (isIgnoreXmlConfiguration()) {
log.info("ignoreXmlConfiguration == true");
} else {
new ValidationParser(getProperties().get(Properties.VALIDATION_XML_PATH))
.processValidationConfig(this);
}
}
private void applyDefaults() {
if (traversableResolver == null) {
traversableResolver = getDefaultTraversableResolver();
}
if (messageInterpolator == null) {
messageInterpolator = getDefaultMessageInterpolator();
}
if (constraintValidatorFactory == null) {
constraintValidatorFactory = getDefaultConstraintValidatorFactory();
}
}
public ConstraintValidatorFactory getConstraintValidatorFactory() {
return constraintValidatorFactory;
}
public TraversableResolver getTraversableResolver() {
return traversableResolver;
}
public ValidationProvider getProvider() {
return provider;
}
private ValidationProvider findProvider() {
if (providerClass != null) {
for (ValidationProvider provider : providerResolver
.getValidationProviders()) {
if (providerClass.isAssignableFrom(provider.getClass())) {
return provider;
}
}
throw new ValidationException(
} else {
List<ValidationProvider<?>> providers = providerResolver.getValidationProviders();
return providers.get(0);
}
}
public void setProviderClass(Class<? extends ValidationProvider<?>> providerClass) {
this.providerClass = providerClass;
}
}
package org.apache.bval.jsr303;
package org.apache.bval.jsr303;
import org.apache.bval.jsr303.util.SecureActions;
package org.apache.bval.jsr303;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.Groups;
import org.apache.bval.jsr303.groups.GroupsComputer;
import org.apache.bval.model.MetaBean;
package org.apache.bval.jsr303;
import org.apache.bval.BeanValidationContext;
import org.apache.bval.ValidationResults;
import org.apache.bval.jsr303.util.NodeImpl;
import org.apache.bval.jsr303.util.PathImpl;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.util.AccessStrategy;
package org.apache.bval.jsr303;
import javax.validation.ConstraintViolation;
import javax.validation.MessageInterpolator;
import javax.validation.Path;
import javax.validation.metadata.ConstraintDescriptor;
import org.apache.bval.jsr303.util.PathImpl;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import java.util.HashSet;
import java.util.Set;
public final class ConstraintValidationListener<T> implements ValidationListener {
private final Set<ConstraintViolation<T>> constaintViolations = new HashSet();
private final T rootBean;
public ConstraintValidationListener(T aRootBean) {
this.rootBean = aRootBean;
}
@SuppressWarnings({"ManualArrayToCollectionCopy"})
public void addError(String reason, ValidationContext context) {
addError(reason, null, context);
}
public void addError(Error error, ValidationContext context) {
if (error.getOwner() instanceof Path) {
addError(error.getReason(), (Path) error.getOwner(), context);
} else {
addError(error.getReason(), null, context);
}
}
private void addError(String messageTemplate, Path propPath,
ValidationContext context) {
final Object value;
final ConstraintDescriptor constraint;
final String message;
if (context instanceof GroupValidationContext) {
GroupValidationContext gcontext = (GroupValidationContext) context;
value = gcontext.getValidatedValue();
if (gcontext instanceof MessageInterpolator.Context) {
message = gcontext.getMessageResolver()
.interpolate(messageTemplate,
(MessageInterpolator.Context) gcontext);
} else {
message =
gcontext.getMessageResolver().interpolate(messageTemplate, null);
}
constraint = gcontext.getConstraintDescriptor();
if (propPath == null) propPath = gcontext.getPropertyPath();
} else {
if (context.getMetaProperty() == null) value = context.getBean();
else value = context.getPropertyValue();
message = messageTemplate;
if (propPath == null)
propPath = PathImpl.createPathFromString(context.getPropertyName());
constraint = null;
}
ConstraintViolationImpl<T> ic = new ConstraintViolationImpl<T>(messageTemplate,
message, rootBean, context.getBean(), propPath, value, constraint);
constaintViolations.add(ic);
}
public Set<ConstraintViolation<T>> getConstaintViolations() {
return constaintViolations;
}
public boolean isEmpty() {
return constaintViolations.isEmpty();
}
public T getRootBean() {
return rootBean;
}
}
package org.apache.bval.jsr303;
import org.apache.bval.jsr303.util.NodeBuilderDefinedContextImpl;
import org.apache.bval.jsr303.util.NodeImpl;
import org.apache.bval.jsr303.util.PathImpl;
import org.apache.bval.model.ValidationListener;
package org.apache.bval.jsr303;
import javax.validation.ConstraintViolation;
import javax.validation.Path;
import javax.validation.metadata.ConstraintDescriptor;
class ConstraintViolationImpl<T> implements ConstraintViolation<T> {
private final String messageTemplate;
private final String message;
private final T rootBean;
private final Object leafBean;
private final Object value;
private final Path propertyPath;
private final ConstraintDescriptor constraintDescriptor;
public ConstraintViolationImpl(String messageTemplate, String message, T rootBean, Object leafBean,
Path propertyPath, Object value,
ConstraintDescriptor constraintDescriptor) {
this.messageTemplate = messageTemplate;
this.message = message;
this.rootBean = rootBean;
this.propertyPath = propertyPath;
this.leafBean = leafBean;
this.value = value;
this.constraintDescriptor = constraintDescriptor;
}
public String getMessage() {
return message;
}
public String getMessageTemplate() {
return messageTemplate;
}
public T getRootBean() {
return rootBean;
}
public Class getRootBeanClass() {
return rootBean == null ? null : rootBean.getClass();
}
public Object getLeafBean() {
return leafBean;
}
public Object getInvalidValue() {
return value;
}
public Path getPropertyPath() {
return propertyPath;
}
public ConstraintDescriptor getConstraintDescriptor() {
return constraintDescriptor;
}
public String toString() {
}
}
package org.apache.bval.jsr303;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorFactory;
import org.apache.bval.jsr303.util.SecureActions;
public class DefaultConstraintValidatorFactory implements ConstraintValidatorFactory {
public <T extends ConstraintValidator<?, ?>> T getInstance(Class<T> constraintClass) {
return SecureActions.newInstance(constraintClass);
}
}
package org.apache.bval.jsr303;
"org.apache.bval.jsr303.ValidationMessages";
package org.apache.bval.jsr303;
import org.apache.bval.jsr303.util.SecureActions;
package org.apache.bval.jsr303;
import javax.validation.metadata.ConstraintDescriptor;
import javax.validation.metadata.ElementDescriptor;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.Validation;
import java.util.HashSet;
import java.util.Set;
public abstract class ElementDescriptorImpl implements ElementDescriptor {
protected final MetaBean metaBean;
protected final Class elementClass;
private Set<ConstraintDescriptor<?>> constraintDescriptors;
protected ElementDescriptorImpl(MetaBean metaBean,
Validation[] validations) {
this.metaBean = metaBean;
this.elementClass = metaBean.getBeanClass();
createConstraintDescriptors(validations);
}
protected ElementDescriptorImpl(Class elementClass, Validation[] validations) {
this.metaBean = null;
this.elementClass = elementClass;
createConstraintDescriptors(validations);
}
public Class getElementClass() {
return elementClass;
}
public ElementDescriptor.ConstraintFinder findConstraints() {
return new ConstraintFinderImpl(metaBean, constraintDescriptors);
}
public Set<ConstraintDescriptor<?>> getConstraintDescriptors() {
return constraintDescriptors;
}
public boolean hasConstraints() {
return !constraintDescriptors.isEmpty();
}
private void createConstraintDescriptors(Validation[] validations) {
final Set<ConstraintDescriptor<?>> cds = new HashSet(validations.length);
for (Validation validation : validations) {
if (validation instanceof ConstraintValidation) {
ConstraintValidation cval = (ConstraintValidation) validation;
cds.add(cval);
}
}
setConstraintDescriptors(cds);
}
public void setConstraintDescriptors(Set<ConstraintDescriptor<?>> constraintDescriptors) {
this.constraintDescriptors = constraintDescriptors;
}
public MetaBean getMetaBean() {
return metaBean;
}
}
package org.apache.bval.jsr303;
import javax.validation.ConstraintValidator;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.Groups;
import org.apache.bval.jsr303.util.PathImpl;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
public interface GroupValidationContext<T extends ValidationListener>
extends ValidationContext<T> {
Groups getGroups();
void setCurrentGroup(Group group);
Group getCurrentGroup();
PathImpl getPropertyPath();
MetaBean getRootMetaBean();
void setConstraintDescriptor(ConstraintValidation constraint);
public ConstraintValidation getConstraintDescriptor();
public Object getValidatedValue();
void setFixedValue(Object value);
MessageInterpolator getMessageResolver();
TraversableResolver getTraversableResolver();
boolean collectValidated(Object bean, ConstraintValidator constraint);
}
package org.apache.bval.jsr303;
import org.apache.bval.BeanValidationContext;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.Groups;
import org.apache.bval.jsr303.resolver.CachingTraversableResolver;
import org.apache.bval.jsr303.util.NodeImpl;
import org.apache.bval.jsr303.util.PathImpl;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.util.AccessStrategy;
package org.apache.bval.jsr303;
import org.apache.bval.model.Features;
public interface Jsr303Features {
interface Property extends Features.Property {
String PropertyDescriptor = "PropertyDescriptor";
}
interface Bean extends Features.Bean {
String GROUP_SEQUENCE = "GroupSequence";
String VALIDATION_SEQUENCE = "ValidationSequence";
String BEAN_DESCRIPTOR = "BeanDescriptor";
}
}
package org.apache.bval.jsr303;
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.jsr303.util.TypeUtils;
import org.apache.bval.jsr303.xml.MetaConstraint;
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.ClassUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.validation.*;
import javax.validation.groups.Default;
import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
public class Jsr303MetaBeanFactory implements MetaBeanFactory {
protected static final Log log = LogFactory.getLog(Jsr303MetaBeanFactory.class);
protected static final String ANNOTATION_VALUE = "value";
protected final AgimatecFactoryContext factoryContext;
public Jsr303MetaBeanFactory(AgimatecFactoryContext factoryContext) {
this.factoryContext = factoryContext;
}
private ConstraintValidatorFactory getConstraintValidatorFactory() {
return factoryContext.getConstraintValidatorFactory();
}
private ConstraintDefaults getDefaultConstraints() {
return factoryContext.getFactory().getDefaultConstraints();
}
public void buildMetaBean(MetaBean metabean) {
try {
final Class<?> beanClass = metabean.getBeanClass();
processGroupSequence(beanClass, metabean);
for (Class interfaceClass : beanClass.getInterfaces()) {
processClass(interfaceClass, metabean);
}
List<Class> classSequence = new ArrayList<Class>();
Class theClass = beanClass;
while (theClass != null && theClass != Object.class) {
classSequence.add(theClass);
theClass = theClass.getSuperclass();
}
for (int i = classSequence.size() - 1; i >= 0; i--) {
Class eachClass = classSequence.get(i);
processClass(eachClass, metabean);
}
} catch (IllegalAccessException e) {
throw new IllegalArgumentException(e);
} catch (InvocationTargetException e) {
throw new IllegalArgumentException(e.getTargetException());
}
}
private void processClass(Class<?> beanClass, MetaBean metabean)
throws IllegalAccessException, InvocationTargetException {
if (!factoryContext.getFactory().getAnnotationIgnores()
processAnnotations(null, beanClass, beanClass, null,
new AppendValidationToMeta(metabean));
Field[] fields = beanClass.getDeclaredFields();
for (Field field : fields) {
MetaProperty metaProperty = metabean.getProperty(field.getName());
if (!factoryContext.getFactory().getAnnotationIgnores()
.isIgnoreAnnotations(field)) {
if (metaProperty == null) {
metaProperty = createMetaProperty(field.getName(), field.getType());
processAnnotations(metaProperty, beanClass, field,
new FieldAccess(field),
metabean.putProperty(metaProperty.getName(), metaProperty);
} else {
processAnnotations(metaProperty, beanClass, field,
new FieldAccess(field),
new AppendValidationToMeta(metaProperty));
}
}
}
Method[] methods = beanClass.getDeclaredMethods();
for (Method method : methods) {
String propName = null;
if (method.getParameterTypes().length == 0) {
propName = MethodAccess.getPropertyName(method);
}
if (propName != null) {
if (!factoryContext.getFactory().getAnnotationIgnores()
.isIgnoreAnnotations(method)) {
MetaProperty metaProperty = metabean.getProperty(propName);
if (metaProperty == null) {
metaProperty =
createMetaProperty(propName, method.getReturnType());
processAnnotations(metaProperty, beanClass, method,
new MethodAccess(propName, method),
metabean.putProperty(propName, metaProperty);
} else {
processAnnotations(metaProperty, beanClass, method,
new MethodAccess(propName, method),
new AppendValidationToMeta(metaProperty));
}
}
}
}
}
addXmlConstraints(beanClass, metabean);
}
private void addXmlConstraints(Class<?> beanClass, MetaBean metabean)
throws IllegalAccessException, InvocationTargetException {
for (MetaConstraint<?, ? extends Annotation> meta : factoryContext.getFactory()
.getMetaConstraints(beanClass)) {
MetaProperty metaProperty;
metaProperty = null;
metaProperty =
metabean.getProperty(meta.getAccessStrategy().getPropertyName());
if (metaProperty == null) {
metaProperty = createMetaProperty(
meta.getAccessStrategy().getPropertyName(),
meta.getAccessStrategy().getJavaType());
metabean.putProperty(metaProperty.getName(), metaProperty);
}
}
Class<? extends ConstraintValidator<?, ?>>[] constraintClasses =
findConstraintValidatorClasses(meta.getAnnotation(), null);
applyConstraint(meta.getAnnotation(), constraintClasses, metaProperty, beanClass,
meta.getAccessStrategy(), new AppendValidationToMeta(
metaProperty == null ? metabean : metaProperty));
}
for (AccessStrategy access : factoryContext.getFactory().getValidAccesses(beanClass)) {
MetaProperty metaProperty = metabean.getProperty(access.getPropertyName());
if (metaProperty == null) {
metaProperty =
createMetaProperty(access.getPropertyName(), access.getJavaType());
metabean.putProperty(metaProperty.getName(), metaProperty);
}
processValid(metaProperty, access);
}
}
private MetaProperty createMetaProperty(String propName, Type type) {
MetaProperty metaProperty;
metaProperty = new MetaProperty();
metaProperty.setName(propName);
metaProperty.setType(type);
return metaProperty;
}
private boolean processAnnotations(MetaProperty prop, Class owner,
AnnotatedElement element, AccessStrategy access,
AppendValidation appender)
throws IllegalAccessException, InvocationTargetException {
boolean changed = false;
for (Annotation annotation : element.getDeclaredAnnotations()) {
changed |= processAnnotation(annotation, prop, owner, access, appender);
}
return changed;
}
private boolean processAnnotation(Annotation annotation, MetaProperty prop, Class owner,
AccessStrategy access, AppendValidation appender)
throws IllegalAccessException, InvocationTargetException {
if (annotation instanceof Valid) {
return processValid(prop, access);
} else {
Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
if (vcAnno != null) {
Class<? extends ConstraintValidator<?, ?>>[] validatorClasses;
validatorClasses = findConstraintValidatorClasses(annotation, vcAnno);
return applyConstraint(annotation, validatorClasses, prop, owner, access,
appender);
} else {
Object result = SecureActions.getAnnotationValue(annotation, ANNOTATION_VALUE);
if (result != null && result instanceof Annotation[]) {
boolean changed = false;
for (Annotation each : (Annotation[]) result) {
changed |= processAnnotation(each, prop, owner, access, appender);
}
return changed;
}
}
}
return false;
}
protected Class<? extends ConstraintValidator<?, ?>>[] findConstraintValidatorClasses(
Annotation annotation, Constraint vcAnno) {
if (vcAnno == null) {
vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
}
Class<? extends ConstraintValidator<?, ?>>[] validatorClasses;
validatorClasses = factoryContext.getFactory()
.getConstraintsCache()
.getConstraintValidators(annotation.annotationType());
if (validatorClasses == null) {
validatorClasses = vcAnno.validatedBy();
if (validatorClasses.length == 0) {
validatorClasses = getDefaultConstraints()
.getValidatorClasses(annotation.annotationType());
}
}
return validatorClasses;
}
private boolean processValid(MetaProperty prop, AccessStrategy access) {
AccessStrategy[] strategies = prop.getFeature(Features.Property.REF_CASCADE);
if (strategies == null) {
strategies = new AccessStrategy[]{access};
prop.putFeature(Features.Property.REF_CASCADE, strategies);
} else {
if (!ArrayUtils.contains(strategies, access)) {
AccessStrategy[] strategies_new =
System.arraycopy(strategies, 0, strategies_new, 0, strategies.length);
strategies_new[strategies.length] = access;
prop.putFeature(Features.Property.REF_CASCADE, strategies_new);
}
}
return true;
}
return false;
}
private void processGroupSequence(Class<?> beanClass, MetaBean metabean) {
GroupSequence annotation = beanClass.getAnnotation(GroupSequence.class);
List<Group> groupSeq = metabean.getFeature(Jsr303Features.Bean.GROUP_SEQUENCE);
if (groupSeq == null) {
groupSeq = new ArrayList(annotation == null ? 1 : annotation.value().length);
metabean.putFeature(Jsr303Features.Bean.GROUP_SEQUENCE, groupSeq);
}
Class<?>[] groupClasses = factoryContext.getFactory().getDefaultSequence(beanClass);
if (groupClasses == null || groupClasses.length == 0) {
if (annotation == null) {
groupSeq.add(Group.DEFAULT);
return;
} else {
groupClasses = annotation.value();
}
}
boolean containsDefault = false;
for (Class<?> groupClass : groupClasses) {
if (groupClass.getName().equals(beanClass.getName())) {
groupSeq.add(Group.DEFAULT);
containsDefault = true;
} else if (groupClass.getName().equals(Default.class.getName())) {
throw new GroupDefinitionException(
"'Default.class' must not appear in @GroupSequence! Use '"
} else {
groupSeq.add(new Group(groupClass));
}
}
if (!containsDefault) {
throw new GroupDefinitionException(
}
if (log.isDebugEnabled()) {
groupSeq);
}
}
protected boolean applyConstraint(Annotation annotation,
Class<? extends ConstraintValidator<?, ?>>[] constraintClasses,
MetaProperty prop, Class owner, AccessStrategy access,
AppendValidation appender)
throws IllegalAccessException, InvocationTargetException {
final ConstraintValidator validator;
if (constraintClasses != null) {
Type type = determineTargetedType(owner, access);
Map<Type, Class<? extends ConstraintValidator<?, ?>>> validatorTypes =
TypeUtils.getValidatorsTypes(constraintClasses);
final List<Type> assignableTypes = new ArrayList(constraintClasses.length);
fillAssignableTypes(type, validatorTypes.keySet(), assignableTypes);
reduceAssignableTypes(assignableTypes);
checkOneType(assignableTypes, type, owner, annotation, access);
validator = getConstraintValidatorFactory()
.getInstance(validatorTypes.get(assignableTypes.get(0)));
validator.initialize(annotation);
} else {
validator = null;
}
final AnnotationConstraintBuilder builder = new AnnotationConstraintBuilder(
constraintClasses, validator, annotation, owner, access);
if (processAnnotations(prop, owner, annotation.annotationType(), access,
appender.append(builder.getConstraintValidation());
return true;
} else {
return false;
}
}
private void checkOneType(List<Type> types, Type targetType, Class owner, Annotation anno,
AccessStrategy access) {
if (types.isEmpty()) {
StringBuilder buf = new StringBuilder()
.append("No validator could be found for type ")
.append(stringForType(targetType))
.append(". See: @")
.append(anno.annotationType().getSimpleName())
.append(" at ").append(stringForLocation(owner, access));
throw new UnexpectedTypeException(buf.toString());
} else if (types.size() > 1) {
StringBuilder buf = new StringBuilder();
buf.append("Ambiguous validators for type ");
buf.append(stringForType(targetType));
buf.append(". See: @")
.append(anno.annotationType().getSimpleName())
.append(" at ").append(stringForLocation(owner, access));
buf.append(". Validators are: ");
boolean comma = false;
for (Type each : types) {
if (comma) buf.append(", ");
comma = true;
buf.append(each);
}
throw new UnexpectedTypeException(buf.toString());
}
}
private Type determineTargetedType(Class owner, AccessStrategy access) {
if (access == null) return owner;
Type type = access.getJavaType();
if (type == null) return Object.class;
if (type instanceof Class) type = ClassUtils.primitiveToWrapper((Class) type);
return type;
}
private String stringForType(Type clazz) {
if (clazz instanceof Class) {
if (((Class) clazz).isArray()) {
} else {
return ((Class) clazz).getName();
}
} else {
return clazz.toString();
}
}
private String stringForLocation(Class owner, AccessStrategy access) {
if (access != null) {
return access.toString();
} else {
return owner.getName();
}
}
private void fillAssignableTypes(Type type, Set<Type> validatorsTypes,
List<Type> suitableTypes) {
for (Type validatorType : validatorsTypes) {
if (TypeUtils.isAssignable(validatorType, type) &&
!suitableTypes.contains(validatorType)) {
suitableTypes.add(validatorType);
}
}
}
private void reduceAssignableTypes(List<Type> assignableTypes) {
if (assignableTypes.size() <= 1) {
}
boolean removed;
do {
removed = false;
final Type type = assignableTypes.get(0);
Type nextType = assignableTypes.get(i);
if (TypeUtils.isAssignable(type, nextType)) {
assignableTypes.remove(0);
i--;
removed = true;
} else if (TypeUtils.isAssignable(nextType, type)) {
assignableTypes.remove(i--);
removed = true;
}
}
} while (removed && assignableTypes.size() > 1);
}
}
package org.apache.bval.jsr303;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.util.PropertyAccess;
import org.apache.commons.lang.StringUtils;
import javax.validation.ValidationException;
import java.lang.reflect.*;
import java.util.*;
final class NestedMetaProperty {
private MetaBean metaBean;
private MetaProperty metaProperty;
private final String propertyPath;
private boolean nested;
private Object value;
public NestedMetaProperty(String path, Object value) {
this.propertyPath = path;
this.value = value;
}
void parse() {
try {
StringTokenizer tokens = new StringTokenizer(propertyPath, ".[]", true);
while (tokens.hasMoreTokens()) {
String token = tokens.nextToken();
if ("[".equals(token)) {
String sindex = tokens.nextToken();
int idx = Integer.parseInt(sindex);
token = tokens.nextToken();
if (!"]".equals(token)) {
throw new ValidationException(
}
useIndexedValue(idx);
resolveMetaBean();
MetaProperty mp = getMetaBean().getProperty(token);
if (mp == null) {
throw new ValidationException(
}
if (getValue() != null) {
setValue(
PropertyAccess.getProperty(getValue(), token));
}
setMetaProperty(mp);
resolveMetaBean();
}
}
} catch (ValidationException ex) {
throw new ValidationException(
}
}
public MetaProperty getMetaProperty() {
return metaProperty;
}
public String getPropertyPath() {
return propertyPath;
}
public boolean isNested() {
return nested;
}
public void setMetaProperty(MetaProperty aMetaProperty) {
if (this.metaProperty != null) {
this.nested = true;
}
this.metaProperty = aMetaProperty;
}
public MetaBean getMetaBean() {
return metaBean;
}
public void setMetaBean(MetaBean metaBean) {
this.metaBean = metaBean;
}
public Object getValue() {
return value;
}
public void setValue(Object value) {
this.value = value;
}
private void useIndexedValue(int idx) {
setValue(getAtIndex(getValue(), idx));
}
private Object getAtIndex(Object value, int idx) {
if (value == null) return null;
if (value instanceof Iterable) {
Iterator iter = ((Iterable) value).iterator();
value = iter.next();
}
return value;
} else if (value.getClass().isArray()) {
return getAtIndex(Arrays.asList(value), idx);
} else {
}
}
static Type typeOf(Member member) {
if (member instanceof Field) {
return ((Field) member).getGenericType();
}
if (member instanceof Method) {
return ((Method) member).getGenericReturnType();
}
}
static Type getIndexedType(Type type) {
Type indexedType = type;
if (isCollection(type) && type instanceof ParameterizedType) {
ParameterizedType paramType = (ParameterizedType) type;
Class collectionClass = getCollectionClass(type);
if (Collection.class.isAssignableFrom(collectionClass)) {
indexedType = paramType.getActualTypeArguments()[0];
} else if (Map.class.isAssignableFrom(collectionClass)) {
indexedType = paramType.getActualTypeArguments()[1];
}
} else if (isArray(type) && type instanceof GenericArrayType) {
GenericArrayType arrayTye = (GenericArrayType) type;
indexedType = arrayTye.getGenericComponentType();
}
return indexedType;
}
static Class<? extends Collection> getCollectionClass(Type type) {
if (type instanceof Class && isCollectionClass((Class) type)) {
return (Class<? extends Collection>) type;
}
if (type instanceof ParameterizedType) {
return getCollectionClass(((ParameterizedType) type).getRawType());
}
if (type instanceof WildcardType) {
Type[] upperBounds = ((WildcardType) type).getUpperBounds();
if (upperBounds.length == 0) {
return null;
}
return getCollectionClass(upperBounds[0]);
}
return null;
}
static boolean isArray(Type type) {
if (type instanceof Class) {
return ((Class) type).isArray();
}
return type instanceof GenericArrayType;
}
static boolean isCollection(Type type) {
return getCollectionClass(type) != null;
}
static boolean isCollectionClass(Class<?> clazz) {
return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);
}
private void resolveMetaBean() {
if (metaProperty.getMetaBean() == null) {
return;
}
if (getValue() != null) {
metaBean = metaProperty.getMetaBean().resolveMetaBean(getValue());
} else {
Member member = null;
try {
member = metaBean.getBeanClass().getDeclaredField(metaProperty.getName());
} catch (NoSuchFieldException e) {
try {
member = metaBean.getBeanClass().getDeclaredMethod(getter);
} catch (NoSuchMethodException e1) {
try {
member = metaBean.getBeanClass().getField(metaProperty.getName());
} catch (NoSuchFieldException e2) {
try {
member = metaBean.getBeanClass().getMethod(getter);
} catch (NoSuchMethodException e3) {
}
}
}
}
if (member != null) {
Type type = getIndexedType(typeOf(member));
if (type != null) {
metaBean = metaProperty.getMetaBean().resolveMetaBean(type);
}
}
}
}
}
package org.apache.bval.jsr303;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.Validation;
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.AppendValidation;
import org.apache.bval.jsr303.ConstraintValidation;
package org.apache.bval.jsr303.extensions;
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.ElementDescriptorImpl;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.Validation;
package org.apache.bval.jsr303.extensions;
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.AgimatecFactoryContext;
import org.apache.bval.jsr303.BeanDescriptorImpl;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.Validation;
package org.apache.bval.jsr303.extensions;
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.ElementDescriptorImpl;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.Validation;
package org.apache.bval.jsr303.extensions;
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.*;
import org.apache.bval.jsr303.AgimatecFactoryContext;
import org.apache.bval.jsr303.BeanDescriptorImpl;
import org.apache.bval.jsr303.ClassValidator;
import org.apache.bval.jsr303.ConstraintValidation;
import org.apache.bval.jsr303.ConstraintValidationListener;
import org.apache.bval.jsr303.GroupValidationContext;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.Groups;
import org.apache.bval.model.MetaBean;
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.AgimatecFactoryContext;
import org.apache.bval.jsr303.AppendValidation;
import org.apache.bval.jsr303.Jsr303MetaBeanFactory;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.model.Validation;
package org.apache.bval.jsr303.extensions;
package org.apache.bval.jsr303.extensions;
import org.apache.bval.jsr303.ElementDescriptorImpl;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.Validation;
package org.apache.bval.jsr303.extensions;
import org.apache.bval.model.MetaBean;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.resolver;
package org.apache.bval.jsr303.resolver;
package org.apache.bval.jsr303.resolver;
import org.apache.bval.jsr303.util.SecureActions;
"org.apache.bval.jsr303.resolver.JPATraversableResolver";
package org.apache.bval.jsr303.resolver;
package org.apache.bval.jsr303.resolver;
package org.apache.bval.jsr303.util;
package org.apache.bval.jsr303.util;
import org.apache.bval.jsr303.ConstraintValidatorContextImpl;
package org.apache.bval.jsr303.util;
import org.apache.bval.jsr303.ConstraintValidatorContextImpl;
package org.apache.bval.jsr303.util;
import org.apache.bval.jsr303.ConstraintValidatorContextImpl;
package org.apache.bval.jsr303.util;
package org.apache.bval.jsr303.util;
package org.apache.bval.jsr303.util;
import org.apache.bval.util.PrivilegedActions;
package org.apache.bval.jsr303.util;
package org.apache.bval.jsr303.xml;
package org.apache.bval.jsr303.xml;
import org.apache.bval.jsr303.util.SecureActions;
package org.apache.bval.jsr303.xml;
import org.apache.bval.jsr303.util.SecureActions;
package org.apache.bval.jsr303.xml;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;
package org.apache.bval.jsr303.xml;
import org.apache.bval.jsr303.AgimatecValidatorFactory;
import org.apache.bval.jsr303.util.ConverterUtils;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;
package org.apache.bval.jsr303.xml;
import org.apache.bval.jsr303.ConfigurationImpl;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.PrivilegedActions;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
import org.apache.bval.constraints.NotEmpty;
package org.apache.bval.constraints;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
public class FrenchZipcodeValidator implements ConstraintValidator<FrenchZipCode, Object> {
public void initialize(FrenchZipCode constraintAnnotation) {
}
public boolean isValid(Object object, ConstraintValidatorContext validationContext) {
return null != object;
}
}
package org.apache.bval.constraints;
package org.apache.bval.constraints;
package org.apache.bval.constraints;
import javax.validation.Constraint;
import javax.validation.Payload;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import org.apache.bval.constraints.NotEmpty;
import java.lang.annotation.Retention;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
@NotEmpty
@NotNull
@Size(min = 4, max = 5)
@Retention(RUNTIME)
@Constraint(validatedBy = {})
public @interface Password {
String[] groups() default {};
String message() default "Wrong password";
int robustness() default 8;
Class<? extends Payload>[] payload() default { };
}
package org.apache.bval.constraints;
import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Documented;
import static java.lang.annotation.ElementType.TYPE;
import java.lang.annotation.Retention;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Target;
@Documented
@Constraint(validatedBy = ZipCodeCityCoherenceValidator.class)
@Target({TYPE})
@Retention(RUNTIME)
public @interface ZipCodeCityCoherence {
String message() default "{validator.zipCodeCityCoherence}";
Class<?>[] groups() default {};
Class<? extends Payload>[] payload() default { };
}
package org.apache.bval.constraints;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import org.apache.bval.jsr303.example.ZipCodeCityCarrier;
public class ZipCodeCityCoherenceValidator
implements ConstraintValidator<ZipCodeCityCoherence, ZipCodeCityCarrier> {
public void initialize(ZipCodeCityCoherence constraintAnnotation) {
}
public boolean isValid(ZipCodeCityCarrier adr, ConstraintValidatorContext context) {
boolean r = true;
if ("error".equals(adr.getZipCode())) {
context.disableDefaultConstraintViolation();
context.buildConstraintViolationWithTemplate("zipcode not OK").addConstraintViolation();
r = false;
}
if ("error".equals(adr.getCity())) {
context.disableDefaultConstraintViolation();
context.buildConstraintViolationWithTemplate("city not OK").addNode("city").addConstraintViolation();
r = false;
}
return r;
}
}
package org.apache.bval.jsr303.example;
import javax.validation.GroupSequence;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import javax.validation.groups.Default;
import org.apache.bval.constraints.ZipCodeCityCoherence;
@ZipCodeCityCoherence
public class Address implements ZipCodeCityCarrier {
@NotNull
@Size(max = 30)
private String addressline1;
@Size(max = 30)
private String addressline2;
@Size(max = 11)
private String zipCode;
@NotNull
@Valid
private Country country;
private String city;
public String getAddressline1() {
return addressline1;
}
public void setAddressline1(String addressline1) {
this.addressline1 = addressline1;
}
public String getAddressline2() {
return addressline2;
}
public void setAddressline2(String addressline2) {
this.addressline2 = addressline2;
}
public String getZipCode() {
return zipCode;
}
public void setZipCode(String zipCode) {
this.zipCode = zipCode;
}
@Size(max = 30)
@NotNull
public String getCity() {
return city;
}
public void setCity(String city) {
this.city = city;
}
public Country getCountry() {
return country;
}
public void setCountry(Country country) {
this.country = country;
}
public interface HighLevelCoherence {
}
@GroupSequence(value = {Default.class, HighLevelCoherence.class})
public interface Complete {
}
package org.apache.bval.jsr303.example;
import org.apache.bval.constraints.AgimatecEmail;
package org.apache.bval.jsr303.example;
import javax.validation.GroupSequence;
import javax.validation.Valid;
import javax.validation.constraints.Size;
import org.apache.bval.constraints.NotEmpty;
import java.util.List;
@GroupSequence({First.class, Author.class, Last.class})
public class Author {
@NotEmpty(groups = Last.class)
private String firstName;
@NotEmpty(groups = First.class)
private String lastName;
@Size(max = 40, groups = First.class)
private String company;
@Valid
private List<Address> addresses;
public List<Address> getAddresses() {
return addresses;
}
public void setAddresses(List<Address> addresses) {
this.addresses = addresses;
}
public String getFirstName() {
return firstName;
}
public void setFirstName(String firstName) {
this.firstName = firstName;
}
public String getLastName() {
return lastName;
}
public void setLastName(String lastName) {
this.lastName = lastName;
}
public String getCompany() {
return company;
}
public void setCompany(String company) {
this.company = company;
}
package org.apache.bval.jsr303.example;
import javax.validation.GroupSequence;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import org.apache.bval.constraints.NotEmpty;
@GroupSequence({First.class, Second.class, Book.class, Last.class})
public class Book {
@NotNull(groups = First.class)
@NotEmpty(groups = First.class)
private String title;
@Size(max = 30, groups = Second.class)
private String subtitle;
@Valid
@NotNull(groups = First.class)
private Author author;
@NotNull
private int uselessField;
private int unconstraintField;
public int getUnconstraintField() {
return unconstraintField;
}
public void setUnconstraintField(int unconstraintField) {
this.unconstraintField = unconstraintField;
}
public String getTitle() {
return title;
}
public void setTitle(String title) {
this.title = title;
}
public String getSubtitle() {
return subtitle;
}
public void setSubtitle(String subtitle) {
this.subtitle = subtitle;
}
public Author getAuthor() {
return author;
}
public void setAuthor(Author author) {
this.author = author;
}
@GroupSequence(value = {First.class, Second.class, Last.class})
public interface All {
}
package org.apache.bval.jsr303.example;
import javax.validation.constraints.NotNull;
public class BusinessAddress extends Address {
private String company;
@NotNull
public String getCompany() {
return company;
}
public void setCompany(String company) {
this.company = company;
}
}
package org.apache.bval.jsr303.example;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
public class Country {
@NotNull
private String name;
@Size(max = 2)
private String ISO2Code;
@Size(max = 3)
private String ISO3Code;
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public String getISO2Code() {
return ISO2Code;
}
public void setISO2Code(String ISO2Code) {
this.ISO2Code = ISO2Code;
}
public String getISO3Code() {
return ISO3Code;
}
public void setISO3Code(String ISO3Code) {
this.ISO3Code = ISO3Code;
}
package org.apache.bval.jsr303.example;
import javax.validation.constraints.NotNull;
import org.apache.bval.constraints.Email;
import org.apache.bval.constraints.Password;
public class Customer implements Person {
private String firstName;
private String middleName;
private String lastName;
@NotNull
private String customerId;
@Password(robustness = 5)
private String password;
@Email
private String emailAddress;
public String getEmailAddress() {
return emailAddress;
}
public void setEmailAddress(String emailAddress) {
this.emailAddress = emailAddress;
}
public String getFirstName() {
return firstName;
}
public void setFirstName(String firstName) {
this.firstName = firstName;
}
public String getMiddleName() {
return middleName;
}
public void setMiddleName(String middleName) {
this.middleName = middleName;
}
public String getLastName() {
return lastName;
}
public void setLastName(String lastName) {
this.lastName = lastName;
}
public String getCustomerId() {
return customerId;
}
public void setCustomerId(String customerId) {
this.customerId = customerId;
}
public String getPassword() {
return password;
}
public void setPassword(String password) {
this.password = password;
}
package org.apache.bval.jsr303.example;
package org.apache.bval.jsr303.example;
import javax.validation.constraints.Pattern;
public class Engine {
@Pattern.List({
message = "must contain alphabetical characters only"),
@Pattern(
regexp = "^....-....-....$", message = "must match ....-....-....")})
public String serialNumber;
package org.apache.bval.jsr303.example;
public interface First {
}
package org.apache.bval.jsr303.example;
import org.apache.bval.constraints.FrenchZipCode;
public class FrenchAddress {
@FrenchZipCode(size = 7)
String zipCode;
public FrenchAddress() {
}
public FrenchAddress(String zipCode) {
this.zipCode = zipCode;
}
public String getZipCode() {
return zipCode;
}
public void setZipCode(String zipCode) {
this.zipCode = zipCode;
}
}
package org.apache.bval.jsr303.example;
public interface Last {
}
package org.apache.bval.jsr303.example;
package org.apache.bval.jsr303.example;
import org.apache.bval.constraints.NotEmpty;
public interface Person {
@NotEmpty
String getFirstName();
String getMiddleName();
@NotEmpty
String getLastName();
package org.apache.bval.jsr303.example;
import javax.validation.constraints.Digits;
public class PreferredGuest extends Customer {
@Digits(integer = 10, fraction = 0)
private String guestCreditCardNumber;
public String getGuestCreditCardNumber() {
return guestCreditCardNumber;
}
public void setGuestCreditCardNumber(String guestCreditCardNumber) {
this.guestCreditCardNumber = guestCreditCardNumber;
}
package org.apache.bval.jsr303.example;
import javax.validation.Valid;
import org.apache.bval.constraints.NotEmpty;
import java.util.ArrayList;
import java.util.Collection;
public class RecursiveFoo {
@NotEmpty
@Valid
Collection<RecursiveFoo> foos = new ArrayList();
public Collection<RecursiveFoo> getFoos() {
return foos;
}
public void setFoos(Collection<RecursiveFoo> foos) {
this.foos = foos;
}
}
package org.apache.bval.jsr303.example;
public interface Second {
}
package org.apache.bval.jsr303.example;
package org.apache.bval.jsr303.example;
package org.apache.bval.jsr303.extensions;
import org.apache.bval.constraints.NotEmpty;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups;
package org.apache.bval.jsr303.groups.implicit;
package org.apache.bval.jsr303.groups.implicit;
package org.apache.bval.jsr303.groups.inheritance;
import org.apache.bval.jsr303.groups.Billable;
import org.apache.bval.jsr303.groups.BillableCreditCard;
package org.apache.bval.jsr303.groups.inheritance;
import org.apache.bval.jsr303.groups.Billable;
package org.apache.bval.jsr303.groups.redefining;
import org.apache.bval.constraints.ZipCodeCityCoherence;
import org.apache.bval.jsr303.example.ZipCodeCityCarrier;
package org.apache.bval.jsr303.groups.redefining;
public class ApacheFactoryContext implements ValidatorContext {
private final ApacheValidatorFactory factory;
public ApacheFactoryContext(ApacheValidatorFactory factory) {
protected ApacheFactoryContext(ApacheValidatorFactory factory,
public ApacheValidatorFactory getFactory() {
ApacheValidatorConfiguration.Properties.TREAT_MAPS_LIKE_BEANS))) {
ApacheValidatorConfiguration.Properties.ENABLE_INTROSPECTOR))) {
ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML))) {
public class ApacheValidationProvider
implements ValidationProvider<ApacheValidatorConfiguration> {
return ApacheValidatorConfiguration.class == builderClass;
public ApacheValidatorFactory buildValidatorFactory(ConfigurationState configuration) {
ApacheValidatorFactory factory = new ApacheValidatorFactory();
public interface ApacheValidatorConfiguration
extends Configuration<ApacheValidatorConfiguration> {
String VALIDATION_XML_PATH = "apache.bval.validation-xml-path";
String ENABLE_INTROSPECTOR = "apache.bval.enable-introspector";
String ENABLE_METABEANS_XML = "apache.bval.enable-metabeans-xml";
String TREAT_MAPS_LIKE_BEANS = "apache.bval.treat-maps-like-beans";
public class ApacheValidatorFactory implements ValidatorFactory, Cloneable {
private static ApacheValidatorFactory DEFAULT_FACTORY;
public static ApacheValidatorFactory getDefault() {
ProviderSpecificBootstrap<ApacheValidatorConfiguration> provider =
Validation.byProvider(ApacheValidationProvider.class);
ApacheValidatorConfiguration configuration = provider.configure();
DEFAULT_FACTORY = (ApacheValidatorFactory) configuration
public ApacheValidatorFactory() {
public ApacheFactoryContext usingContext() {
return new ApacheFactoryContext(this);
public synchronized ApacheValidatorFactory clone() {
return (ApacheValidatorFactory) super.clone();
protected final ApacheFactoryContext factoryContext;
protected BeanDescriptorImpl(ApacheFactoryContext factoryContext, MetaBean metaBean,
protected final ApacheFactoryContext factoryContext;
public ClassValidator(ApacheFactoryContext factoryContext) {
public ClassValidator(ApacheValidatorFactory factory) {
return SecureActions.newInstance(type, new Class[]{ApacheFactoryContext.class},
new Class[]{ApacheFactoryContext.class}, new Object[]{factoryContext});
public class ConfigurationImpl implements ApacheValidatorConfiguration, ConfigurationState {
public ApacheValidatorConfiguration traversableResolver(TraversableResolver resolver) {
public ApacheValidatorConfiguration ignoreXmlConfiguration() {
public ApacheValidatorConfiguration addMapping(InputStream stream) {
public ApacheValidatorConfiguration addProperty(String name, String value) {
"org/apache/bval/jsr303/DefaultConstraints.properties";
protected final ApacheFactoryContext factoryContext;
public Jsr303MetaBeanFactory(ApacheFactoryContext factoryContext) {
import org.apache.bval.jsr303.ApacheFactoryContext;
protected MethodBeanDescriptorImpl(ApacheFactoryContext factoryContext,
import org.apache.bval.jsr303.ApacheFactoryContext;
public MethodValidatorImpl(ApacheFactoryContext factoryContext) {
import org.apache.bval.jsr303.ApacheFactoryContext;
public MethodValidatorMetaBeanFactory(ApacheFactoryContext factoryContext) {
import org.apache.bval.jsr303.ApacheValidatorFactory;
private final ApacheValidatorFactory factory;
public ValidationMappingParser(ApacheValidatorFactory factory) {
return EMailValidation.isValid(value);
public class NotEmptyValidatorForCollection implements ConstraintValidator<NotEmpty, Collection<?>> {
public boolean isValid(Collection<?> value, ConstraintValidatorContext context) {
public class NotEmptyValidatorForMap implements ConstraintValidator<NotEmpty, Map<?, ?>> {
public boolean isValid(Map<?, ?> value, ConstraintValidatorContext context) {
implements ConstraintValidator<Size, Collection<?>> {
public boolean isValid(Collection<?> collection, ConstraintValidatorContext context) {
implements ConstraintValidator<Size, Map<?, ?>> {
public boolean isValid(Map<?, ?> map, ConstraintValidatorContext context) {
import java.io.InputStream;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.apache.bval.jsr303.util.EnumerationConverter;
import org.apache.commons.beanutils.ConvertUtils;
import org.apache.commons.beanutils.Converter;
Converter converter = ConvertUtils.lookup(returnType);
if (converter == null && returnType.isEnum()) {
converter = EnumerationConverter.getInstance();
}
return ConvertUtils.convert(value, returnType);
import java.io.Closeable;
InputStream inputStream = null;
inputStream = getInputStream(validationXmlFile);
} finally {
closeQuietly(inputStream);
InputStream in = null;
} finally {
closeQuietly(in);
private static void closeQuietly(Closeable closeable) {
if (closeable != null) {
try {
closeable.close();
} catch (IOException e) {
}
}
}
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Enumeration;
import org.apache.bval.jsr303.ConfigurationImpl;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.PrivilegedActions;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.xml.sax.SAXException;
protected final Class<?> elementClass;
protected ElementDescriptorImpl(Class<?> elementClass, Validation[] validations) {
public Class<?> getElementClass() {
final Set<ConstraintDescriptor<?>> cds = new HashSet<ConstraintDescriptor<?>>(validations.length);
import org.apache.bval.jsr303.util.IOUtils;
} finally {
IOUtils.closeQuietly(in);
import org.apache.bval.jsr303.util.IOUtils;
IOUtils.closeQuietly(inputStream);
private static final long serialVersionUID = 1L;
private static final long serialVersionUID = 1L;
public static <T> T newInstance(final Class<T> cls, final Class<?>[] paramTypes,
public static Field getDeclaredField(final Class<?> clazz, final String fieldName) {
} else if (type instanceof Class<?>) {
Class<?> clazz = (Class<?>) type;
if (!(paramType.getRawType() instanceof Class<?>)) {
private final List<ParameterDescriptor> parameterDescriptors = new ArrayList<ParameterDescriptor>();
protected ConstructorDescriptorImpl(Class<?> elementClass, Validation[] validations) {
ConstructorDescriptor getConstraintsForConstructor(Constructor<?> constructor);
private Map<Constructor<?>, ConstructorDescriptor> constructorConstraints;
Map<Constructor<?>, ConstructorDescriptor> constructorConstraints) {
public ConstructorDescriptor getConstraintsForConstructor(Constructor<?> constructor) {
return new HashSet<MethodDescriptor>(methodConstraints.values());
return new HashSet<ConstructorDescriptor>(this.constructorConstraints.values());
public void putConstructorDescriptor(Constructor<?> cons, ConstructorDescriptorImpl desc) {
public Map<Constructor<?>, ConstructorDescriptor> getConstructorConstraints() {
private final List<ParameterDescriptor> parameterDescriptors = new ArrayList<ParameterDescriptor>();
protected MethodDescriptorImpl(Class<?> elementClass, Validation[] validations) {
public ParameterDescriptorImpl(Class<?> elementClass, Validation[] validations) {
import org.apache.bval.model.MetaBean;
import static org.apache.bval.model.Features.Property.JAVASCRIPT_VALIDATION_FUNCTIONS;
public static void setDefault(ApacheValidatorFactory aDefaultFactory) {
DEFAULT_FACTORY = aDefaultFactory;
}
public ApacheValidatorFactory() {
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
@Pattern(regexp = ".*?COMPANY.*?")
public @interface CompanyEmail {
String message() default "Not an email of COMPANY";
constraintIndex = 1) String agimatecMessage() default "Not COMPANY";
CompanyEmail[] value();
import org.apache.bval.constraints.CompanyEmail;
public class CompanyAddress {
@CompanyEmail
public CompanyAddress() {
public CompanyAddress(String email) {
import org.apache.bval.*;
import javax.validation.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.xml.XMLMetaValue;
import static org.apache.bval.routines.Reasons.*;
import org.apache.bval.model.ValidationListener;
import javax.validation.ConstraintValidator;
import javax.validation.Payload;
import javax.validation.ValidationException;
import javax.validation.metadata.ConstraintDescriptor;
for (ValidationListener.Error each : jsrContext.getErrorMessages()) {
PropertyDescriptorImpl(Class<?> elementClass, Validation[] validations) {
private static final long serialVersionUID = 1L;
private Class<?> beanClass;
public Class<?> getBeanClass() {
public void setBeanClass(Class<?> beanClass) {
private final Class<?> enumClass;
public DynaTypeEnum(Class<?> enumClass) {
public DynaTypeEnum(Class<?> enumClass, String... names) {
public Class<?> getRawType() {
public boolean isAssignableFrom(Class<?> cls) {
private static final long serialVersionUID = 1L;
private static final long serialVersionUID = 1L;
if (rawType instanceof Class<?>) {
return (Class<?>) rawType;
if (value instanceof Iterable<?>) {
Iterator<?> iter = ((Iterable<?>) value).iterator();
Class<?> collectionClass = getCollectionClass(type);
static Class<? extends Collection<?>> getCollectionClass(Type type) {
if (type instanceof Class<?> && isCollectionClass((Class<?>) type)) {
return (Class<? extends Collection<?>>) type;
if (type instanceof Class<?>) {
return ((Class<?>) type).isArray();
} catch (NoSuchMethodException e3) {
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.bval.model.MetaBean;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
List<MetaBean> metaBeans = new ArrayList<MetaBean>(1);
Map<String, Object> rootMap = new HashMap<String, Object>();
final Class<?>[] paramTypes,
return run(new PrivilegedAction<Object>() {
public static ClassLoader getClassLoader(final Class<?> clazz) {
private final Class<?> beanClass;
public PropertyAccess(Class<?> clazz, String propertyName) {
if (bean instanceof Map<?, ?>) {
return ((Map<?, ?>) bean).get(property);
Class<?> theClass = beanClass;
Class<?> theClass = bean.getClass();
MetaBean findForClass(Class<?> clazz);
public MetaBean findForClass(Class<?> clazz) {
Class<?> beanType = prop.getFeature(REF_BEAN_TYPE);
private static final long serialVersionUID = 1L;
public MetaBean findForClass(Class<?> clazz) {
protected Class<?> findLocalClass(String className) {
public MetaBean buildForClass(Class<?> clazz) throws Exception {
private static final long serialVersionUID = 1L;
return bean instanceof Class<?> ?
finder.findForClass((Class<?>) bean) : finder.findForClass(bean.getClass());
import org.apache.bval.util.AccessStrategy;
import javax.validation.Constraint;
import javax.validation.ConstraintValidator;
import javax.validation.Valid;
ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
processAnnotations(consDesc, paramAnnos, access, idx);
ReturnAccess returnAccess = new ReturnAccess(method.getReturnType());
processAnnotation(anno, methodDesc, returnAccess, validations);
ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
processAnnotations(methodDesc, paramAnnos, access, idx);
AccessStrategy access, int idx)
processAnnotation(anno, methodDesc, access, validations);
AccessStrategy access, AppendValidation validations)
desc.getMetaBean().getBeanClass(), access, validations);
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;
public void save(@Pattern(regexp="[a-f0-9]{4}") String data) {
return;
}
@NotNull
@Size(min=3,max=10)
public String echo(@NotNull @Size(min=3,max=10) String str) {
return str;
}
protected <VL extends ValidationListener> boolean determineMetaBean(Validate validate, Object parameter,
ValidationContext<VL> context) {
Class<?> beanClass;
Collection<?> coll = ((Collection<?>) parameter);
public <VL extends ValidationListener> void validateProperty(ValidationContext<VL> context) {
public <VL extends ValidationListener> void validateContext(ValidationContext<VL> context) {
if (!treatMapsLikeBeans && context.getBean() instanceof Map<?, ?>) {
} else if (context.getBean() instanceof Iterable<?>) {
private <VL extends ValidationListener> void validateBeanInContext(ValidationContext<VL> context) {
private <VL extends ValidationListener> void validateArrayInContext(ValidationContext<VL> context) {
private <VL extends ValidationListener> DynamicMetaBean getDynamicMetaBean(ValidationContext<VL> context) {
private <VL extends ValidationListener> void validateIteratableInContext(ValidationContext<VL> context) {
Iterator<?> it = ((Iterable<?>) context.getBean()).iterator();
private <VL extends ValidationListener> void validateMapInContext(ValidationContext<VL> context) {
Iterator<Map.Entry<Object, Object>> it = ((Map<Object, Object>) context.getBean()).entrySet().iterator();
Map.Entry<Object, Object> entry = it.next();
protected <VL extends ValidationListener> void validateBeanNet(ValidationContext<VL> context) {
private <VL extends ValidationListener> void validateRelatedBean(ValidationContext<VL> context, MetaProperty prop) {
public <VL extends ValidationListener> void validateBean(ValidationContext<VL> context) {
private static final long serialVersionUID = 1L;
public <T extends ValidationListener> void addError(String reason, ValidationContext<T> context) {
public <T extends ValidationListener> void addError(Error error, ValidationContext<T> context) {
errorsByReason = new LinkedHashMap<String, List<Error>>();
errorsByOwner = new LinkedHashMap<Object, Map<String, List<Error>>>();
<T extends ValidationListener> void validate(ValidationContext<T> context);
<T extends ValidationListener> void addError(String reason, ValidationContext<T> context);
<T extends ValidationListener> void addError(Error error, ValidationContext<T> context);
private static final long serialVersionUID = 1L;
import org.apache.bval.model.ValidationListener;
public <T extends ValidationListener> void validate(ValidationContext<T> context) {
import org.apache.bval.model.ValidationListener;
public <T extends ValidationListener> void validate(ValidationContext<T> context) {
import org.apache.bval.model.ValidationListener;
public <T extends ValidationListener> void validate(ValidationContext<T> context) {
protected <T extends ValidationListener> void validateTimeLag(ValidationContext<T> context) {
protected <T extends ValidationListener> void validateRegExp(ValidationContext<T> context) {
protected <T extends ValidationListener> void validateMinValue(ValidationContext<T> context) {
protected <T extends ValidationListener> void validateMaxValue(ValidationContext<T> context) {
private <T extends ValidationListener> int compare(ValidationContext<T> context, Comparable constraintValue,
protected <T extends ValidationListener> void validateMaxLength(ValidationContext<T> context) {
protected <T extends ValidationListener> void validateMinLength(ValidationContext<T> context) {
protected <T extends ValidationListener> void validateMandatory(ValidationContext<T> context) {
Comparable<Object> minValue = (Comparable<Object>) context.getMetaProperty().getFeature(MIN_VALUE);
Comparable<Object> maxValue = (Comparable<Object>) context.getMetaProperty().getFeature(MAX_VALUE);
private <T extends ValidationListener> int compare(ValidationContext<T> context, Comparable<Object> constraintValue,
} else if (value instanceof Collection<?>) {
length = ((Collection<?>) value).size();
} else if (value instanceof Collection<?>) {
length = ((Collection<?>) value).size();
protected IdentityHashMap<Object, Object> validatedObjects = new IdentityHashMap<Object, Object>();
import java.lang.annotation.Annotation;
<T extends Annotation> void append(ConstraintValidation<T> validation);
import java.lang.annotation.Annotation;
public <T extends Annotation> void append(ConstraintValidation<T> validation) {
import java.lang.annotation.Annotation;
public <T extends Annotation> void append(ConstraintValidation<T> validation) {
import java.lang.annotation.Annotation;
private final List<ConstraintValidation<? extends Annotation>> validations = new ArrayList<ConstraintValidation<? extends Annotation>>();
public <T extends Annotation> void append(ConstraintValidation<T> validation) {
public List<ConstraintValidation<? extends Annotation>> getValidations() {
public <A extends Annotation> AnnotationProxy(AnnotationProxyBuilder<A> descriptor) {
private <A extends Annotation> Map<String, Object> getAnnotationValues(AnnotationProxyBuilder<A> descriptor) {
Map<String, Object> result = new HashMap<String, Object>();
SortedSet<String> result = new TreeSet<String>();
Set<PropertyDescriptor> validatedProperties = new HashSet<PropertyDescriptor>();
private Map<Method, MethodDescriptor> methodConstraints;
public void setMethodConstraints(Map<Method, MethodDescriptor> methodConstraints) {
public void putMethodDescriptor(Method method, MethodDescriptor desc) {
public void putConstructorDescriptor(Constructor<?> cons, ConstructorDescriptor desc) {
public Map<Method, MethodDescriptor> getMethodConstraints() {
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import javax.validation.Constraint;
import javax.validation.ConstraintValidator;
import javax.validation.Valid;
beanDesc.setConstructorConstraints(new HashMap<Constructor<?>, ConstructorDescriptor>());
for (Constructor<?> cons : beanDesc.getMetaBean().getBeanClass()
ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
beanDesc.setMethodConstraints(new HashMap<Method, MethodDescriptor>());
methodDesc.getConstraintDescriptors().addAll(validations.getValidations());
ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
Constructor<T> constructor,
Constructor<T> constructor,
Constructor<T> constructor,
Constructor<T> constructor,
List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>(3);
for (Class<?> interfaceClass : beanClass.getInterfaces()) {
List<Class<?>> classSequence = new ArrayList<Class<?>>();
Class<?> theClass = beanClass;
Class<?> eachClass = classSequence.get(i);
private boolean processAnnotations(MetaProperty prop, Class<?> owner,
private boolean processAnnotation(Annotation annotation, MetaProperty prop, Class<?> owner,
groupSeq = new ArrayList<Group>(annotation == null ? 1 : annotation.value().length);
MetaProperty prop, Class<?> owner, AccessStrategy access,
final List<Type> assignableTypes = new ArrayList<Type>(constraintClasses.length);
private void checkOneType(List<Type> types, Type targetType, Class<?> owner, Annotation anno,
private Type determineTargetedType(Class<?> owner, AccessStrategy access) {
if (type instanceof Class<?>) type = ClassUtils.primitiveToWrapper((Class<?>) type);
if (clazz instanceof Class<?>) {
if (((Class<?>) clazz).isArray()) {
return ((Class<?>) clazz).getName();
private String stringForLocation(Class<?> owner, AccessStrategy access) {
defaultSequences = new HashMap<Class<?>, Class<?>[]>();
validAccesses = new HashMap<Class<?>, List<AccessStrategy>>();
constraintMap = new HashMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>>();
List<AccessStrategy> tmpList = new ArrayList<AccessStrategy>();
return (List) slot;
private Type paramType;
private int paramIdx;
public ParameterAccess(Type paramType, int paramIdx ) {
this.paramType = paramType;
this.paramIdx = paramIdx;
}
@Override
public Object get(Object instance) {
throw new NotImplementedException("Obtaining a parameter value not yet implemented");
}
@Override
public ElementType getElementType() {
return ElementType.PARAMETER;
}
@Override
public Type getJavaType() {
return this.paramType;
}
@Override
public String getPropertyName() {
}
private Type returnType;
public ReturnAccess(Type returnType) {
this.returnType = returnType;
}
@Override
public Object get(Object instance) {
throw new NotImplementedException("Obtaining a method return value not yet implemented");
}
@Override
public ElementType getElementType() {
return ElementType.METHOD;
}
@Override
public Type getJavaType() {
return this.returnType;
}
@Override
public String getPropertyName() {
return "Return value";
}
if ( isRootPath() && nodeList.get(0).getIndex() == null ) {
nodeList.set(0, node);
}
else {
nodeList.add(node);
}
}
return value.longValue() <= max;
return value.longValue() >= minValue;
resolvedParameterValue = parameter;
checkGroups(groupArray);
.findForClass(object.getClass()), object, (Class<T>)object.getClass(), groupArray);
if (ex instanceof ValidationException || ex instanceof IllegalArgumentException) {
checkPropertyName(propertyName);
checkGroups(groups);
createContext(metaBean, object, (Class<T>)object.getClass(), groups);
checkBeanType(beanType);
checkPropertyName(propertyName);
checkGroups(groups);
createContext(metaBean, null, beanType, groups);
MetaBean metaBean, T object, Class<T> objectClass, Class<?>[] groups) {
ConstraintValidationListener<T> listener = new ConstraintValidationListener<T>(object, objectClass);
private void checkBeanType(Class<?> beanType) {
if (beanType == null) {
throw new IllegalArgumentException("Bean type cannot be null.");
}
}
private void checkPropertyName(String propertyName) {
if (propertyName == null || propertyName.isEmpty() ) {
throw new IllegalArgumentException("Property path cannot be null or empty.");
}
}
private void checkGroups(Class<?>[] groups) {
if ( groups == null ) {
throw new IllegalArgumentException("Groups cannot be null.");
}
}
new ConstraintValidationListener(oldListener.getRootBean(), oldListener.getRootBeanType());
private final Class<T> rootBeanType;
public ConstraintValidationListener(T aRootBean, Class<T> rootBeanType) {
this.rootBeanType = rootBeanType;
message, rootBean, context.getBean(), propPath, value, constraint, rootBeanType);
public Class<T> getRootBeanType() {
return rootBeanType;
}
private final Class<T> rootBeanClass;
ConstraintDescriptor constraintDescriptor, Class<T> rootBeanClass) {
this.rootBeanClass = rootBeanClass;
public Class<T> getRootBeanClass() {
return rootBeanClass;
throw new IllegalArgumentException(
} catch (IllegalArgumentException ex) {
createContext(methodDescriptor.getMetaBean(), returnedValue, null, groupArray);
createContext(metaBean, null, null, groupArray);
createContext(paramDesc.getMetaBean(), parameter, null, groupArray);
import java.util.*;
fillFullClassHierarchyAsList(classSequence, beanClass);
private void fillFullClassHierarchyAsList(List<Class<?>> allClasses, Class<?> clazz) {
if ( clazz == null || clazz == Object.class ) {
return;
}
if ( allClasses.contains(clazz) ) {
return;
}
allClasses.add(clazz);
List<Class<?>> subClasses = new ArrayList<Class<?>>(Arrays.asList(clazz.getInterfaces()));
subClasses.add(0, clazz.getSuperclass());
for ( Class<?> subClass : subClasses ) {
fillFullClassHierarchyAsList(allClasses, subClass);
}
}
private final Class<?> beanClass;
private final String propertyName;
private Field rememberField;
public PropertyAccess(Class<?> clazz, String propertyName) {
this.beanClass = clazz;
this.propertyName = propertyName;
}
public ElementType getElementType() {
return ElementType.METHOD;
}
private static Object getPublicProperty(Object bean, String property) throws
InvocationTargetException, NoSuchMethodException, IllegalAccessException {
if (bean instanceof Map<?, ?>) {
return ((Map<?, ?>) bean).get(property);
return PropertyUtils.getSimpleProperty(bean, property);
}
public static Object getProperty(Object bean, String propertyName) throws
InvocationTargetException, NoSuchMethodException, IllegalAccessException {
return new PropertyAccess(bean.getClass(), propertyName).get(bean);
}
public String toString() {
}
public Type getJavaType() {
return beanClass.
return rememberField.getGenericType();
for (PropertyDescriptor each : PropertyUtils.getPropertyDescriptors(beanClass)) {
if (each.getName().equals(propertyName) && each.getReadMethod() != null) {
return each.getReadMethod().getGenericReturnType();
}
return beanClass.getField(propertyName).getGenericType();
} catch (NoSuchFieldException ex2) {
Class<?> theClass = beanClass;
while (theClass != null) {
return theClass.getDeclaredField(propertyName).getGenericType();
} catch (NoSuchFieldException ex3) {
theClass = theClass.getSuperclass();
}
}
public String getPropertyName() {
return propertyName;
}
public Object get(Object bean) {
try {
return rememberField.get(bean);
}
return getPublicProperty(bean, propertyName);
} catch (NoSuchMethodException ex) {
return getFieldValue(bean);
}
} catch (IllegalArgumentException e) {
throw e;
} catch (Exception e) {
}
private Object getFieldValue(Object bean) throws IllegalAccessException {
Object value;
Field aField = bean.getClass().getField(propertyName);
value = aField.get(bean);
rememberField = aField;
return value;
} catch (NoSuchFieldException ex2) {
Class<?> theClass = bean.getClass();
while (theClass != null) {
try {
Field aField = theClass
.getDeclaredField(propertyName);
if (!aField.isAccessible()) {
aField.setAccessible(true);
}
value = aField.get(bean);
rememberField = aField;
return value;
} catch (NoSuchFieldException ex3) {
}
theClass = theClass.getSuperclass();
}
throw new IllegalArgumentException(
}
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
PropertyAccess that = (PropertyAccess) o;
return beanClass.equals(that.beanClass) && propertyName.equals(that.propertyName);
}
public int hashCode() {
int result;
result = beanClass.hashCode();
return result;
}
if (!result.isEmpty()) break;
if (!result.isEmpty()) break;
if (!result.isEmpty()) break;
setValue(PropertyAccess.getProperty(getValue(), token));
import org.apache.bval.model.*;
import java.util.IdentityHashMap;
public AccessStrategy getAccess() {
return this.access;
}
AccessStrategy getAccess();
return (rememberField != null) ? ElementType.FIELD : ElementType.METHOD;
}
public ConstraintDescriptor<T> asSerializableDescriptor() {
return new ConstraintDescriptorImpl(this);
context.setConstraintValidation(this);
import javax.validation.ConstraintViolation;
import javax.validation.MessageInterpolator;
import javax.validation.Path;
import javax.validation.metadata.ConstraintDescriptor;
import java.lang.annotation.ElementType;
final ConstraintDescriptor descriptor;
descriptor = gcontext.getConstraintValidation().asSerializableDescriptor();
else value = context.getPropertyValue();
descriptor = null;
ElementType elementType = (context.getAccess() != null) ? context.getAccess().getElementType() : null;
message, rootBean, context.getBean(), propPath, value, descriptor, rootBeanType, elementType);
import javax.validation.ConstraintValidatorContext;
import javax.validation.Path;
import javax.validation.ValidationException;
import java.io.Serializable;
import java.lang.annotation.ElementType;
class ConstraintViolationImpl<T> implements ConstraintViolation<T>, Serializable {
private final ElementType elementType;
ConstraintDescriptor constraintDescriptor, Class<T> rootBeanClass, ElementType elementType) {
this.elementType = elementType;
@Override
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result
((this.leafBean == null) ? 0 : this.leafBean.hashCode());
result = prime * result
((this.message == null) ? 0 : this.message.hashCode());
result = prime
* result
((this.propertyPath == null) ? 0 : this.propertyPath
.hashCode());
result = prime * result
((this.rootBean == null) ? 0 : this.rootBean.hashCode());
result = prime * result
((this.value == null) ? 0 : this.value.hashCode());
result = prime * result
((this.elementType == null) ? 0 : this.elementType.hashCode());
return result;
}
@Override
public boolean equals(Object obj) {
if (this == obj) {
return true;
}
if (obj == null) {
return false;
}
if (!(obj instanceof ConstraintViolationImpl<?>)) {
return false;
}
ConstraintViolationImpl<?> other = (ConstraintViolationImpl<?>) obj;
if (this.leafBean == null) {
if (other.leafBean != null) {
return false;
}
} else if (!this.leafBean.equals(other.leafBean)) {
return false;
}
if (this.message == null) {
if (other.message != null) {
return false;
}
} else if (!this.message.equals(other.message)) {
return false;
}
if (this.propertyPath == null) {
if (other.propertyPath != null) {
return false;
}
} else if (!this.propertyPath.equals(other.propertyPath)) {
return false;
}
if (this.rootBean == null) {
if (other.rootBean != null) {
return false;
}
} else if (!this.rootBean.equals(other.rootBean)) {
return false;
}
if (this.rootBeanClass != other.rootBeanClass) {
return false;
}
if (this.value == null) {
if (other.value != null) {
return false;
}
} else if (!this.value.equals(other.value)) {
return false;
}
if (this.elementType != other.elementType) {
return false;
}
return true;
}
import javax.validation.ConstraintValidator;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;
void setConstraintValidation(ConstraintValidation constraint);
public ConstraintValidation getConstraintValidation();
import javax.validation.ConstraintValidator;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;
import javax.validation.metadata.ConstraintDescriptor;
extends BeanValidationContext<T>
implements GroupValidationContext<T>, MessageInterpolator.Context {
private final MessageInterpolator messageResolver;
private final PathImpl path;
private final MetaBean rootMetaBean;
private Groups groups;
private Group currentGroup;
private IdentityHashMap<Object, IdentityHashMap<ConstraintValidator, Object>> validatedConstraints =
new IdentityHashMap();
private ConstraintValidation constraintValidation;
private final TraversableResolver traversableResolver;
public GroupValidationContextImpl(T listener, MessageInterpolator aMessageResolver,
TraversableResolver traversableResolver,
MetaBean rootMetaBean) {
super(listener);
this.messageResolver = aMessageResolver;
this.traversableResolver = CachingTraversableResolver.cacheFor(traversableResolver);
this.rootMetaBean = rootMetaBean;
this.path = PathImpl.create(null);
}
@Override
public void setCurrentIndex(int index) {
path.getLeafNode().setIndex(index);
}
@Override
public void setCurrentKey(Object key) {
path.getLeafNode().setKey(key);
}
@Override
public void moveDown(MetaProperty prop, AccessStrategy access) {
path.addNode(new NodeImpl(prop.getName()));
super.moveDown(prop, access);
}
@Override
public void moveUp(Object bean, MetaBean metaBean) {
path.removeLeafNode();
}
@Override
public boolean collectValidated() {
Set<Group> groupSet = (Set<Group>) validatedObjects.get(getBean());
if (groupSet == null) {
groupSet = new HashSet(10);
validatedObjects.put(getBean(), groupSet);
return groupSet.add(getCurrentGroup());
}
public boolean collectValidated(Object bean, ConstraintValidator constraint) {
IdentityHashMap<ConstraintValidator, Object> beanConstraints =
validatedConstraints.get(bean);
if (beanConstraints == null) {
beanConstraints = new IdentityHashMap();
validatedConstraints.put(bean, beanConstraints);
return beanConstraints.put(constraint, Boolean.TRUE) == null;
}
public boolean isValidated(Object bean, ConstraintValidator constraint) {
IdentityHashMap<ConstraintValidator, Object> beanConstraints =
validatedConstraints.get(bean);
return beanConstraints != null && beanConstraints.containsKey(constraint);
}
public void resetValidatedConstraints() {
validatedConstraints.clear();
}
public PathImpl getPropertyPath() {
PathImpl currentPath = PathImpl.copy(path);
if (getMetaProperty() != null) {
currentPath.addNode(new NodeImpl(getMetaProperty().getName()));
return currentPath;
}
public MetaBean getRootMetaBean() {
return rootMetaBean;
}
public void setGroups(Groups groups) {
this.groups = groups;
}
public Groups getGroups() {
return groups;
}
public Group getCurrentGroup() {
return currentGroup;
}
public void setCurrentGroup(Group currentGroup) {
this.currentGroup = currentGroup;
}
public void setConstraintValidation(ConstraintValidation constraint) {
constraintValidation = constraint;
}
public ConstraintValidation getConstraintValidation() {
return constraintValidation;
}
public ConstraintDescriptor getConstraintDescriptor() {
return constraintValidation;
}
public Object getValidatedValue() {
if (getMetaProperty() != null) {
return getPropertyValue(constraintValidation.getAccess());
} else {
return getBean();
}
public MessageInterpolator getMessageResolver() {
return messageResolver;
}
public TraversableResolver getTraversableResolver() {
return traversableResolver;
}
import javax.validation.Constraint;
import javax.validation.ConstraintValidator;
import javax.validation.Valid;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
if (clazz == null) {
throw new IllegalArgumentException("Class cannot be null");
}
if (validator != null && !context.collectValidated(context.getPropertyPath(), validator))
matcher.appendReplacement(sb, sanitizeForAppendReplacement(resolvedParameterValue));
matcher.appendReplacement(sb, sanitizeForAppendReplacement(resolvedParameterValue));
private String sanitizeForAppendReplacement(String src) {
return src.replace("\\", "\\\\").replace("$", "\\$");
}
import java.util.*;
private HashMap<PathImpl, IdentityHashMap<ConstraintValidator, Object>> validatedConstraints =
new HashMap<PathImpl, IdentityHashMap<ConstraintValidator, Object>>();
@Override
public boolean collectValidated() {
Map<Group, Set<PathImpl>> groupMap = (Map<Group, Set<PathImpl>>) validatedObjects
.get(getBean());
if (groupMap == null) {
groupMap = new HashMap<Group, Set<PathImpl>>();
validatedObjects.put(getBean(), groupMap);
}
Set<PathImpl> validatedPathsForGroup = groupMap.get(getCurrentGroup());
if (validatedPathsForGroup == null) {
validatedPathsForGroup = new HashSet<PathImpl>();
groupMap.put(getCurrentGroup(), validatedPathsForGroup);
}
for (PathImpl validatedPath : validatedPathsForGroup) {
if (path.isSubPathOf(validatedPath)) {
return false;
}
}
validatedPathsForGroup.add(PathImpl.copy(path));
return true;
}
public boolean collectValidated(Object path, ConstraintValidator constraint) {
IdentityHashMap<ConstraintValidator, Object> constraints = this.validatedConstraints
.get(path);
if (constraints == null) {
constraints = new IdentityHashMap<ConstraintValidator, Object>();
this.validatedConstraints.put((PathImpl) path, constraints);
}
return (constraints.put(constraint, Boolean.TRUE) == null);
}
if ( ((PathImpl)path).isRootPath() ) {
return true;
}
protected RuntimeException unrecoverableValidationError(RuntimeException ex,
if (ex instanceof UnknownPropertyException) {
return new IllegalArgumentException(ex.getMessage(), ex);
}
else if (ex instanceof ValidationException) {
throw new UnknownPropertyException(
valueMethod.setAccessible(true);
import javax.validation.metadata.BeanDescriptor;
import javax.validation.metadata.PropertyDescriptor;
if (propertyName == null || propertyName.isEmpty()) {
throw new IllegalArgumentException("propertyName cannot be null or empty");
}
public void setCurrentIndex(Integer index) {
import org.apache.bval.model.*;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.PropertyAccess;
import java.util.List;
} else if (context.getBean() instanceof List<?>) {
validateIteratableInContext(context);
validateNonPositionalIteratableInContext(context);
private <VL extends ValidationListener> void validateNonPositionalIteratableInContext(ValidationContext<VL> context) {
Iterator<?> it = ((Iterable<?>) context.getBean()).iterator();
context.setCurrentIndex(null);
final DynamicMetaBean dyn = getDynamicMetaBean(context);
Object each = it.next();
if (each == null)
if (dyn != null) {
context.setBean(each, dyn.resolveMetaBean(each));
} else {
context.setBean(each);
}
validateBeanNet(context);
}
}
void setCurrentIndex(Integer index);
if (validator != null && !context.collectValidated(validator))
boolean collectValidated(ConstraintValidator constraint);
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
private HashSet<ConstraintValidatorIdentity> validatedConstraints =
new HashSet<ConstraintValidatorIdentity>();
public void setCurrentIndex(Integer index) {
@Override
public boolean collectValidated() {
Map<Group, Set<PathImpl>> groupMap = (Map<Group, Set<PathImpl>>) validatedObjects
.get(getBean());
if (groupMap == null) {
groupMap = new HashMap<Group, Set<PathImpl>>();
validatedObjects.put(getBean(), groupMap);
Set<PathImpl> validatedPathsForGroup = groupMap.get(getCurrentGroup());
if (validatedPathsForGroup == null) {
validatedPathsForGroup = new HashSet<PathImpl>();
groupMap.put(getCurrentGroup(), validatedPathsForGroup);
for (PathImpl validatedPath : validatedPathsForGroup) {
if (path.isSubPathOf(validatedPath)) {
return false;
}
}
validatedPathsForGroup.add(PathImpl.copy(path));
return true;
}
public boolean collectValidated(ConstraintValidator constraint) {
ConstraintValidatorIdentity cvi = new ConstraintValidatorIdentity(getBean(), getPropertyPath(), constraint);
return this.validatedConstraints.add(cvi);
}
PathImpl path, String name) {
lastNodeName = name;
this.propertyPath.getLeafNode().setInIterable( true );
return new NodeContextBuilderImpl(parent, messageTemplate, propertyPath, lastNodeName);
addLastNodeIfNeeded();
lastNodeName = name;
addLastNodeIfNeeded();
private void addLastNodeIfNeeded() {
if (lastNodeName != null) {
NodeImpl node = new NodeImpl(lastNodeName);
propertyPath.addNode(node);
}
}
return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, name);
private final String lastNodeName;
String template, PathImpl path, String name) {
lastNodeName = name;
addLastNodeIfNeeded();
addLastNodeIfNeeded();
addLastNodeIfNeeded();
return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, lastNodeName);
addLastNodeIfNeeded();
private void addLastNodeIfNeeded() {
if (lastNodeName != null) {
NodeImpl node = new NodeImpl(lastNodeName);
propertyPath.addNode(node);
}
}
import java.util.Set;
validation.setGroups(builder.getConstraintValidation().getGroups());
public Set<?> getInheritedGroups() {
return builder.getConstraintValidation().getGroups();
}
if ( appender instanceof AppendValidationToBuilder ) {
builder.getConstraintValidation().setGroups(((AppendValidationToBuilder) appender).getInheritedGroups());
}
try {
validator.initialize(annotation);
} catch (RuntimeException e) {
}
import org.apache.bval.jsr303.xml.AnnotationProxyBuilder;
Set<Class<?>> inheritedGroups = builder.getConstraintValidation().getGroups();
validation.setGroups(inheritedGroups);
T originalAnnot = validation.getAnnotation();
AnnotationProxyBuilder<T> apb = new AnnotationProxyBuilder<T>(originalAnnot);
apb.putValue("groups", inheritedGroups.toArray(new Class[inheritedGroups.size()]));
T newAnnot = apb.createAnnotation();
validation.setAnnotation(newAnnot);
public void setAnnotation(T annotation) {
this.annotation = annotation;
}
import org.apache.bval.jsr303.util.SecureActions;
import java.io.Serializable;
public class AnnotationProxy implements Annotation, InvocationHandler, Serializable {
import javax.validation.Payload;
import javax.validation.ValidationException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
final public class AnnotationProxyBuilder<A extends Annotation> {
public AnnotationProxyBuilder(A annot) {
this.type = (Class<A>) annot.annotationType();
Method[] methods = SecureActions.getDeclaredMethods(annot.annotationType());
for ( Method m : methods ) {
if ( !m.isAccessible() ) {
m.setAccessible(true);
}
try {
Object value = m.invoke(annot);
this.elements.put(m.getName(), value);
} catch (IllegalArgumentException e) {
} catch (IllegalAccessException e) {
} catch (InvocationTargetException e) {
}
}
}
import javax.validation.Payload;
Set<Class<? extends Payload>> inheritedPayload = builder.getConstraintValidation().getPayload();
validation.setPayload(inheritedPayload);
apb.putValue("payload", inheritedPayload.toArray(new Class[inheritedPayload.size()]));
public Set<?> getInheritedPayload() {
return builder.getConstraintValidation().getPayload();
}
AppendValidationToBuilder avb = (AppendValidationToBuilder) appender;
builder.getConstraintValidation().setGroups(avb.getInheritedGroups());
builder.getConstraintValidation().setPayload(avb.getInheritedPayload());
import org.apache.bval.jsr303.xml.AnnotationProxyBuilder;
private void applyOverridesAttributes(ConstraintValidation<?> composite) {
if (null == overrides) {
buildOverridesAttributes();
}
int index = computeIndex(composite);
ConstraintOverrides generalOverride = findOverride(composite.getAnnotation().annotationType(), -1);
if ( generalOverride != null ) {
if ( index > 0 ) {
}
generalOverride.applyOn(composite);
ConstraintOverrides override = findOverride(composite.getAnnotation().annotationType(), index);
if ( override != null ) {
override.applyOn(composite);
}
private int computeIndex(ConstraintValidation<?> composite) {
int idx = 0;
if (each.getAnnotation().annotationType() == composite.getAnnotation().annotationType()) {
overrides = new LinkedList<ConstraintOverrides>();
Annotation originalAnnot = composite.getAnnotation();
AnnotationProxyBuilder<Annotation> apb = new AnnotationProxyBuilder<Annotation>(originalAnnot);
for ( String key : values.keySet() ) {
apb.putValue(key, values.get(key));
}
Annotation newAnnot = apb.createAnnotation();
composite.setAnnotation(newAnnot);
public class AppendValidationToBuilder extends BaseAppendValidation {
public <T extends Annotation> void preProcessValidation(ConstraintValidation<T> validation) {
}
public <T extends Annotation> void performAppend(ConstraintValidation<T> validation) {
import java.lang.annotation.Annotation;
public class AppendValidationToMeta extends BaseAppendValidation {
public <T extends Annotation> void performAppend(ConstraintValidation<T> validation) {
import javax.validation.ConstraintDefinitionException;
context.setConstraintValidation(this);
public void initialize() {
if (null != validator) {
try {
validator.initialize(annotation);
} catch (RuntimeException e) {
}
}
}
import org.apache.bval.jsr303.BaseAppendValidation;
import org.apache.bval.jsr303.ConstraintValidation;
public class AppendValidationToList extends BaseAppendValidation {
public <T extends Annotation> void performAppend(ConstraintValidation<T> validation) {
context.setConstraintValidation(this);
context.setConstraintValidation(this);
if ( validatorClasses == null ) {
return Collections.emptyList();
}
public Set<Class<?>> getInheritedGroups() {
public Set<Class<? extends Payload>> getInheritedPayload() {
import org.apache.bval.jsr303.util.ConstraintDefinitionValidator;
ConstraintDefinitionValidator.validateConstraintDefinition(annotation);
Class<?>[] groups() default {};
constraintValidation.getAttributes()
.put(method.getName(), method.invoke(
constraintValidation.getAnnotation()));
this.attributes.put("groups", groups.toArray(new Class[groups.size()]));
this.attributes.put("payload", groups.toArray(new Class[groups.size()]));
} else {
constraintValidation.getAttributes()
.put(method.getName(), method.invoke(
constraintValidation.getAnnotation()));
private MetaBean parentMetaBean;
public MetaBean getParentMetaBean() {
return parentMetaBean;
}
public void setParentMetaBean(MetaBean parentMetaBean) {
this.parentMetaBean = parentMetaBean;
}
return groups.contains(reqGroup);
metaProperty = createMetaProperty(metabean, field.getName(), field.getType());
createMetaProperty(metabean, propName, method.getReturnType());
metaProperty = createMetaProperty(metabean,
createMetaProperty(metabean, access.getPropertyName(), access.getJavaType());
private MetaProperty createMetaProperty(MetaBean parentMetaBean, String propName, Type type) {
metaProperty.setParentMetaBean(parentMetaBean);
if ( prop != null && prop.getParentMetaBean() != null ) {
MetaBean parentMetaBean = prop.getParentMetaBean();
if ( builder.getConstraintValidation().getOwner().isInterface() &&
parentMetaBean.getBeanClass() != builder.getConstraintValidation().getOwner() &&
builder.getConstraintValidation().getGroups().size() == 1 &&
builder.getConstraintValidation().getGroups().contains(Default.class) ) {
Set<Class<?>> groups = builder.getConstraintValidation().getGroups();
groups.add(builder.getConstraintValidation().getOwner());
builder.getConstraintValidation().setGroups(groups);
}
}
private static String lineSeparator = null;
private static String pathSeparator = null;
public static final String getLineSeparator() {
if (lineSeparator == null) {
lineSeparator =
AccessController.doPrivileged(new PrivilegedAction<String>() {
public String run() {
return System.getProperty("line.separator");
}
});
}
return lineSeparator;
}
public static final String getPathSeparator() {
if (pathSeparator == null) {
pathSeparator =
AccessController.doPrivileged(new PrivilegedAction<String>() {
public String run() {
return System.getProperty("path.separator");
}
});
}
return pathSeparator;
}
public static final String getProperty(final String name) {
return AccessController.doPrivileged(new PrivilegedAction<String>() {
public String run() {
return System.getProperty(name);
}
});
}
if(property != null) property.setParentMetaBean(this);
metaProperty = createMetaProperty(field.getName(), field.getType());
metabean.putProperty(metaProperty.getName(), metaProperty);
createMetaProperty(propName, method.getReturnType());
metabean.putProperty(propName, metaProperty);
metaProperty = createMetaProperty(
createMetaProperty(access.getPropertyName(), access.getJavaType());
private MetaProperty createMetaProperty(String propName, Type type) {
final ConstraintValidationListener result = (ConstraintValidationListener) vcontext.getListener();
if ( !result.isEmpty() ) {
break;
}
metaProperty = addMetaProperty(metabean, field.getName(), field.getType());
addMetaProperty(metabean, propName, method.getReturnType());
metaProperty = addMetaProperty(metabean,
addMetaProperty(metabean, access.getPropertyName(), access.getJavaType());
private MetaProperty addMetaProperty(MetaBean parentMetaBean, String propName, Type type) {
parentMetaBean.putProperty(propName, metaProperty);
throw new RuntimeException("Only enum types supported in this version!");
throw new RuntimeException("Null values not supported in this version!");
throw new RuntimeException("Only java.lang.String values supported in this version!");
import javax.validation.GroupDefinitionException;
throw new GroupDefinitionException("Cyclic dependency in groups definition");
package org.apache.bval.optional.json;
package org.apache.bval.json;
}
else if ( hasValidationConstraintsDefined(method) ) {
}
private boolean hasValidationConstraintsDefined(Method method) {
boolean ret = false;
for ( Annotation annot : method.getDeclaredAnnotations() ) {
if ( true == (ret = hasValidationConstraintsDefined(annot)) ) {
break;
}
}
return ret;
}
private boolean hasValidationConstraintsDefined(Annotation annot) {
if ( annot.annotationType().getAnnotation(Constraint.class) != null ) {
return true;
}
boolean ret = false;
Object value = null;
try {
value = SecureActions.getAnnotationValue(annot, ANNOTATION_VALUE);
} catch (IllegalAccessException e) {
} catch (InvocationTargetException e) {
}
if ( value instanceof Annotation[] ) {
for (Annotation annot2 : (Annotation[])value ) {
if ( true == (ret = hasValidationConstraintsDefined(annot2)) ) {
break;
}
}
}
return ret;
}
import javax.validation.ValidationException;
import javax.validation.metadata.BeanDescriptor;
import org.apache.bval.jsr303.Jsr303Features;
@Override
public BeanDescriptor getConstraintsForClass(Class<?> clazz) {
MetaBean uncachedStubmetaBean = new MetaBean();
uncachedStubmetaBean.setBeanClass(clazz);
BeanDescriptorImpl edesc = createBeanDescriptor(uncachedStubmetaBean);
return edesc;
}
private static final Log log = LogFactory.getLog(MetaBeanBuilder.class);
private MetaBeanFactory[] factories;
private XMLMetaBeanFactory xmlFactory;
public MetaBeanBuilder() {
this(new MetaBeanFactory[]{new IntrospectorMetaBeanFactory(),
new XMLMetaBeanFactory()});
}
public MetaBeanBuilder(MetaBeanFactory[] factories) {
setFactories(factories);
}
public MetaBeanFactory[] getFactories() {
return factories;
}
public void setFactories(MetaBeanFactory[] factories) {
this.factories = factories;
updateXmlFactory();
}
private void updateXmlFactory() {
for (MetaBeanFactory each : factories) {
xmlFactory = (XMLMetaBeanFactory) each;
return;
}
}
public XMLMetaBeanFactory getXmlFactory() {
return xmlFactory;
}
public void addLoader(XMLMetaBeanLoader loader) {
assertXmlFactory();
xmlFactory.addLoader(loader);
}
public Map<String, MetaBean> buildAll() throws Exception {
final Map<String, MetaBean> all = new HashMap<String, MetaBean>();
if (xmlFactory != null) {
xmlFactory.visitXMLBeanMeta(null, new XMLMetaBeanFactory.Visitor() {
public void visit(XMLMetaBean empty, XMLMetaBeanInfos xmlInfos)
throws Exception {
XMLMetaBeanFactory.XMLResult carrier =
new XMLMetaBeanFactory.XMLResult(null, xmlInfos);
for (XMLMetaBean xmlMeta : xmlInfos.getBeans()) {
MetaBean meta = all.get(xmlMeta.getId());
if (meta == null) {
meta = createMetaBean(xmlMeta);
all.put(xmlMeta.getId(), meta);
carrier.xmlMeta = xmlMeta;
xmlFactory.enrichMetaBean(meta, carrier);
}
public MetaBean getMetaBean() {
}
});
}
return all;
}
public Map<String, MetaBean> enrichCopies(Map<String, MetaBean> all,
XMLMetaBeanInfos... infosArray)
throws Exception {
assertXmlFactory();
final Map<String, MetaBean> copies = new HashMap<String, MetaBean>(all.size());
boolean nothing = true;
XMLMetaBeanFactory.XMLResult carrier = new XMLMetaBeanFactory.XMLResult();
for (XMLMetaBeanInfos xmlMetaBeanInfos : infosArray) {
carrier.xmlInfos = xmlMetaBeanInfos;
if (xmlMetaBeanInfos == null) continue;
try {
for (XMLMetaBean xmlMeta : xmlMetaBeanInfos.getBeans()) {
nothing = false;
MetaBean copy = copies.get(xmlMeta.getId());
MetaBean meta = all.get(xmlMeta.getId());
copy = createMetaBean(xmlMeta);
copy = meta.copy();
copies.put(xmlMeta.getId(), copy);
}
carrier.xmlMeta = xmlMeta;
xmlFactory.enrichMetaBean(copy, carrier);
} catch (IOException e) {
xmlFactory.handleLoadException(xmlMetaBeanInfos, e);
}
if (nothing) return all;
for (Map.Entry<String, MetaBean> entry : all.entrySet()) {
if (!copies.containsKey(entry.getKey())) {
if (entry.getValue().hasRelationships()) {
copies.put(entry.getKey(), (MetaBean) entry.getValue().copy());
copies.put(entry.getKey(), entry.getValue());
}
return copies;
}
private void assertXmlFactory() {
if (xmlFactory == null) {
throw new IllegalStateException("no xmlFactory available");
}
public MetaBean buildForId(String beanInfoId) throws Exception {
final XMLMetaBeanFactory.Visitor v;
assertXmlFactory();
xmlFactory.visitXMLBeanMeta(beanInfoId, v = new XMLMetaBeanFactory.Visitor() {
private MetaBean meta;
public MetaBean getMetaBean() {
}
public void visit(XMLMetaBean xmlMeta, XMLMetaBeanInfos xmlInfos)
throws Exception {
if (meta == null) {
meta = createMetaBean(xmlMeta);
}
xmlFactory.enrichMetaBean(meta,
new XMLMetaBeanFactory.XMLResult(xmlMeta, xmlInfos));
}
});
if (v.getMetaBean() == null) {
return v.getMetaBean();
}
private MetaBean createMetaBean(XMLMetaBean xmlMeta) throws Exception {
return buildForClass(findLocalClass(xmlMeta.getImpl()));
}
protected Class<?> findLocalClass(String className) {
if (className != null) {
try {
return ClassUtils.getClass(className);
} catch (ClassNotFoundException e) {
}
}
return null;
}
public MetaBean buildForClass(Class<?> clazz) throws Exception {
MetaBean meta = new MetaBean();
meta.setBeanClass(clazz);
}
for (MetaBeanFactory factory : factories) {
factory.buildMetaBean(meta);
}
return meta;
}
public ApacheValidatorFactory getFactory() {
protected boolean hasValidationConstraintsDefined(Method method) {
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.MetaBeanManager;
import org.apache.bval.jsr303.*;
import javax.validation.ConstraintViolation;
import javax.validation.metadata.ConstraintDescriptor;
public MethodValidatorImpl(ApacheFactoryContext factoryContext) {
super(factoryContext);
patchFactoryContextForMethodValidation(factoryContext);
}
private void patchFactoryContextForMethodValidation(ApacheFactoryContext factoryContext) {
MetaBeanFactory[] factories = ((MetaBeanManager) getMetaBeanFinder()).getBuilder().getFactories();
if(factories[i] instanceof Jsr303MetaBeanFactory && !(factories[i] instanceof MethodValidatorMetaBeanFactory)) {
factories[i] = new MethodValidatorMetaBeanFactory(factoryContext);
}
}
@Override
protected BeanDescriptorImpl createBeanDescriptor(MetaBean metaBean) {
MethodBeanDescriptorImpl descriptor = new MethodBeanDescriptorImpl(factoryContext,
metaBean, metaBean.getValidations());
MethodValidatorMetaBeanFactory factory =
new MethodValidatorMetaBeanFactory(factoryContext);
factory.buildMethodDescriptor(descriptor);
return descriptor;
}
public <T> Set<ConstraintViolation<T>> validateParameters(Class<T> clazz, Method method,
Object[] parameters,
Class<?>... groupArray) {
MethodBeanDescriptorImpl beanDesc =
(MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
MethodDescriptorImpl methodDescriptor =
(MethodDescriptorImpl) beanDesc.getConstraintsForMethod(method);
return validateParameters(methodDescriptor.getMetaBean(),
methodDescriptor.getParameterDescriptors(), parameters, groupArray);
}
public <T> Set<ConstraintViolation<T>> validateParameter(Class<T> clazz, Method method,
Object parameter,
int parameterIndex,
Class<?>... groupArray) {
MethodBeanDescriptorImpl beanDesc =
(MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
MethodDescriptorImpl methodDescriptor =
(MethodDescriptorImpl) beanDesc.getConstraintsForMethod(method);
ParameterDescriptorImpl paramDesc = (ParameterDescriptorImpl) methodDescriptor
.getParameterDescriptors().get(parameterIndex);
return validateParameter(paramDesc, parameter, groupArray);
}
public <T> Set<ConstraintViolation<T>> validateParameters(Class<T> clazz,
Constructor<T> constructor,
Object[] parameters,
Class<?>... groupArray) {
MethodBeanDescriptorImpl beanDesc =
(MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
ConstructorDescriptorImpl constructorDescriptor =
(ConstructorDescriptorImpl) beanDesc.getConstraintsForConstructor(constructor);
return validateParameters(constructorDescriptor.getMetaBean(),
constructorDescriptor.getParameterDescriptors(), parameters, groupArray);
}
public <T> Set<ConstraintViolation<T>> validateParameter(Class<T> clazz,
Constructor<T> constructor,
Object parameter,
int parameterIndex,
Class<?>... groupArray) {
MethodBeanDescriptorImpl beanDesc =
(MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
ConstructorDescriptorImpl methodDescriptor =
(ConstructorDescriptorImpl) beanDesc.getConstraintsForConstructor(constructor);
ParameterDescriptorImpl paramDesc = (ParameterDescriptorImpl) methodDescriptor
.getParameterDescriptors().get(parameterIndex);
return validateParameter(paramDesc, parameter, groupArray);
}
public <T> Set<ConstraintViolation<T>> validateReturnedValue(Class<T> clazz, Method method,
Object returnedValue,
Class<?>... groupArray) {
MethodBeanDescriptorImpl beanDesc =
(MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
MethodDescriptorImpl methodDescriptor =
(MethodDescriptorImpl) beanDesc.getConstraintsForMethod(method);
final GroupValidationContext<ConstraintValidationListener<Object>> context =
createContext(methodDescriptor.getMetaBean(), returnedValue, null, groupArray);
validateReturnedValueInContext(context, methodDescriptor);
ConstraintValidationListener result = context.getListener();
return result.getConstaintViolations();
}
private <T> Set<ConstraintViolation<T>> validateParameters(MetaBean metaBean,
List<ParameterDescriptor> paramDescriptors,
Object[] parameters,
if (parameters == null) throw new IllegalArgumentException("cannot validate null");
if (parameters.length > 0) {
try {
GroupValidationContext<ConstraintValidationListener<Object[]>> context =
createContext(metaBean, null, null, groupArray);
ParameterDescriptorImpl paramDesc =
(ParameterDescriptorImpl) paramDescriptors.get(i);
context.setBean(parameters[i]);
validateParameterInContext(context, paramDesc);
}
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, parameters);
}
} else {
return Collections.EMPTY_SET;
}
private <T> Set<ConstraintViolation<T>> validateParameter(
ParameterDescriptorImpl paramDesc, Object parameter, Class<?>... groupArray) {
try {
final GroupValidationContext<ConstraintValidationListener<Object>> context =
createContext(paramDesc.getMetaBean(), parameter, null, groupArray);
final ConstraintValidationListener result = context.getListener();
validateParameterInContext(context, paramDesc);
return result.getConstaintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, parameter);
}
private <T> void validateParameterInContext(
GroupValidationContext<ConstraintValidationListener<T>> context,
ParameterDescriptorImpl paramDesc) {
final Groups groups = context.getGroups();
for (ConstraintDescriptor consDesc : paramDesc.getConstraintDescriptors()) {
ConstraintValidation validation = (ConstraintValidation) consDesc;
for (Group current : groups.getGroups()) {
context.setCurrentGroup(current);
validation.validate(context);
}
for (List<Group> eachSeq : groups.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validation.validate(context);
if (!context.getListener().isEmpty()) break;
}
if (paramDesc.isCascaded() && context.getValidatedValue() != null) {
context.setMetaBean(factoryContext.getMetaBeanFinder().
findForClass(context.getValidatedValue().getClass()));
for (Group current : groups.getGroups()) {
context.setCurrentGroup(current);
validateContext(context);
}
for (List<Group> eachSeq : groups.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validateContext(context);
if (!context.getListener().isEmpty()) break;
}
}
private <T> void validateReturnedValueInContext(
GroupValidationContext<ConstraintValidationListener<T>> context,
MethodDescriptorImpl methodDescriptor) {
final Groups groups = context.getGroups();
for (ConstraintDescriptor consDesc : methodDescriptor.getConstraintDescriptors()) {
ConstraintValidation validation = (ConstraintValidation) consDesc;
for (Group current : groups.getGroups()) {
context.setCurrentGroup(current);
validation.validate(context);
}
for (List<Group> eachSeq : groups.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validation.validate(context);
if (!context.getListener().isEmpty()) break;
}
if (methodDescriptor.isCascaded() && context.getValidatedValue() != null) {
context.setMetaBean(factoryContext.getMetaBeanFinder().
findForClass(context.getValidatedValue().getClass()));
for (Group current : groups.getGroups()) {
context.setCurrentGroup(current);
validateContext(context);
}
for (List<Group> eachSeq : groups.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validateContext(context);
if (!context.getListener().isEmpty()) break;
}
}
}
}
public MethodValidatorMetaBeanFactory(ApacheFactoryContext factoryContext) {
super(factoryContext);
}
@Override
protected boolean hasValidationConstraintsDefined(Method method) {
return false;
}
public void buildMethodDescriptor(MethodBeanDescriptorImpl descriptor) {
try {
buildMethodConstraints(descriptor);
buildConstructorConstraints(descriptor);
} catch (Exception e) {
throw new IllegalArgumentException(e.getMessage(), e);
}
}
private void buildConstructorConstraints(MethodBeanDescriptorImpl beanDesc)
throws InvocationTargetException, IllegalAccessException {
beanDesc.setConstructorConstraints(new HashMap<Constructor<?>, ConstructorDescriptor>());
for (Constructor<?> cons : beanDesc.getMetaBean().getBeanClass()
.getDeclaredConstructors()) {
if (!factoryContext.getFactory().getAnnotationIgnores()
.isIgnoreAnnotations(cons)) {
ConstructorDescriptorImpl consDesc =
new ConstructorDescriptorImpl(beanDesc.getMetaBean(), new Validation[0]);
beanDesc.putConstructorDescriptor(cons, consDesc);
Annotation[][] paramsAnnos = cons.getParameterAnnotations();
int idx = 0;
for (Annotation[] paramAnnos : paramsAnnos) {
ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
processAnnotations(consDesc, paramAnnos, access, idx);
}
}
private void buildMethodConstraints(MethodBeanDescriptorImpl beanDesc)
throws InvocationTargetException, IllegalAccessException {
beanDesc.setMethodConstraints(new HashMap<Method, MethodDescriptor>());
for (Method method : beanDesc.getMetaBean().getBeanClass().getDeclaredMethods()) {
if (!factoryContext.getFactory().getAnnotationIgnores()
.isIgnoreAnnotations(method)) {
MethodDescriptorImpl methodDesc = new MethodDescriptorImpl(
beanDesc.getMetaBean(), new Validation[0]);
beanDesc.putMethodDescriptor(method, methodDesc);
ReturnAccess returnAccess = new ReturnAccess(method.getReturnType());
for (Annotation anno : method.getAnnotations()) {
processAnnotation(anno, methodDesc, returnAccess, validations);
methodDesc.getConstraintDescriptors().addAll(validations.getValidations());
Annotation[][] paramsAnnos = method.getParameterAnnotations();
int idx = 0;
for (Annotation[] paramAnnos : paramsAnnos) {
ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
processAnnotations(methodDesc, paramAnnos, access, idx);
}
}
private void processAnnotations(ProcedureDescriptor methodDesc, Annotation[] paramAnnos,
AccessStrategy access, int idx)
throws InvocationTargetException, IllegalAccessException {
AppendValidationToList validations = new AppendValidationToList();
for (Annotation anno : paramAnnos) {
processAnnotation(anno, methodDesc, access, validations);
}
ParameterDescriptorImpl paramDesc = new ParameterDescriptorImpl(
methodDesc.getMetaBean(), validations.getValidations().toArray(
new Validation[validations.getValidations().size()]));
paramDesc.setIndex(idx);
methodDesc.getParameterDescriptors().add(paramDesc);
}
private void processAnnotation(Annotation annotation, ProcedureDescriptor desc,
AccessStrategy access, AppendValidation validations)
throws InvocationTargetException, IllegalAccessException {
if (annotation instanceof Valid) {
desc.setCascaded(true);
} else {
Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
if (vcAnno != null) {
Class<? extends ConstraintValidator<?, ?>>[] validatorClasses;
validatorClasses = findConstraintValidatorClasses(annotation, vcAnno);
applyConstraint(annotation, validatorClasses, null,
desc.getMetaBean().getBeanClass(), access, validations);
} else {
Object result = SecureActions.getAnnotationValue(annotation, ANNOTATION_VALUE);
if (result != null && result instanceof Annotation[]) {
for (Annotation each : (Annotation[]) result) {
}
}
}
}
}
this.attributes.put("payload", payload.toArray(new Class[payload.size()]));
import java.util.Map;
protected Map validatedObjects;
this(listener, new IdentityHashMap());
}
protected BeanValidationContext(T listener, Map validatedMap) {
this.validatedObjects = validatedMap;
protected <VL extends ValidationListener> void validateBeanInContext(ValidationContext<VL> context) {
protected <VL extends ValidationListener> void validateArrayInContext(ValidationContext<VL> context) {
protected <VL extends ValidationListener> void validateIteratableInContext(ValidationContext<VL> context) {
protected <VL extends ValidationListener> void validateNonPositionalIteratableInContext(ValidationContext<VL> context) {
protected <VL extends ValidationListener> void validateMapInContext(ValidationContext<VL> context) {
protected <VL extends ValidationListener> void validateRelatedBean(ValidationContext<VL> context, MetaProperty prop) {
import org.apache.bval.jsr303.util.ClassHelper;
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.PropertyAccess;
import javax.validation.groups.Default;
import java.util.ArrayList;
import java.util.Map;
validateBeanNet(context);
validateBeanNet(context);
protected void validateBeanNet(ValidationContext vcontext) {
GroupValidationContext<?> context = (GroupValidationContext<?>)vcontext;
if ( context.getBean() == null ) {
return;
}
if ( !context.collectValidated() ) {
return;
}
if ( context.getCurrentGroup().isDefault() ) {
List<Group> defaultGroups = expandDefaultGroup(context);
final ConstraintValidationListener result = (ConstraintValidationListener) context.getListener();
if ( defaultGroups.size() > 1 ) {
int numViolations = result.violationsSize();
Group currentGroup = context.getCurrentGroup();
for (Group each : defaultGroups) {
context.setCurrentGroup(each);
super.validateBean(context);
if ( result.violationsSize() > numViolations ) {
break;
}
context.setCurrentGroup(currentGroup);
else {
List<Class<?>> classHierarchy = new ArrayList<Class<?>>();
ClassHelper.fillFullClassHierarchyAsList(classHierarchy, context.getMetaBean().getBeanClass());
Class<?> initialOwner = context.getCurrentOwner();
for ( Class<?> owner : classHierarchy ) {
context.setCurrentOwner(owner);
int numViolations = result.violationsSize();
for (Group each : ownerDefaultGroups) {
context.setCurrentGroup(each);
super.validateBean(context);
if ( result.violationsSize() > numViolations ) {
break;
}
}
}
context.setCurrentOwner(initialOwner);
context.setCurrentGroup(Group.DEFAULT);
}
}
else {
super.validateBean(context);
}
for (MetaProperty prop : context.getMetaBean().getProperties()) {
validateCascadedBean(context, prop);
}
}
private void validateCascadedBean(GroupValidationContext<?> context, MetaProperty prop) {
AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
final Object bean = context.getBean();
final MetaBean mbean = context.getMetaBean();
context.moveDown(prop, new PropertyAccess(bean.getClass(), prop.getName()));
followCascadedConstraint(context);
context.moveUp(bean, mbean);
final Object bean = context.getBean();
final MetaBean mbean = context.getMetaBean();
for (AccessStrategy each : access) {
context.moveDown(prop, each);
followCascadedConstraint(context);
context.moveUp(bean, mbean);
}
private void followCascadedConstraint(GroupValidationContext<?> context) {
if ( context.getBean() != null ) {
if (context.getBean() instanceof Map<?, ?>) {
validateMapInContext(context);
} else if (context.getBean() instanceof List<?>) {
validateIteratableInContext(context);
} else if (context.getBean() instanceof Iterable<?>) {
validateNonPositionalIteratableInContext(context);
} else if (context.getBean() instanceof Object[]) {
validateArrayInContext(context);
validateBeanInContext(context);
}
}
}
implements Validation, ConstraintDescriptor<T> {
private static final String ANNOTATION_MESSAGE = "message";
private final ConstraintValidator validator;
private final AccessStrategy access;
private final boolean reportFromComposite;
private final Map<String, Object> attributes;
private Set<ConstraintValidation<?>> composedConstraints;
private final Class owner;
private Set<Class<?>> groups;
private Set<Class<? extends Payload>> payload;
private Class<? extends ConstraintValidator<T, ?>>[] validatorClasses;
public ConstraintValidation(
Class<? extends ConstraintValidator<T, ?>>[] validatorClasses,
ConstraintValidator validator, T annotation, Class owner,
AccessStrategy access, boolean reportFromComposite) {
this.attributes = new HashMap();
this.validatorClasses = validatorClasses;
this.validator = validator;
this.annotation = annotation;
this.owner = owner;
this.access = access;
this.reportFromComposite = reportFromComposite;
}
public ConstraintDescriptor<T> asSerializableDescriptor() {
return new ConstraintDescriptorImpl(this);
}
void setGroups(Set<Class<?>> groups) {
this.groups = groups;
this.attributes.put("groups", groups.toArray(new Class[groups.size()]));
}
void setPayload(Set<Class<? extends Payload>> payload) {
this.payload = payload;
this.attributes.put("payload", payload.toArray(new Class[payload.size()]));
}
public boolean isReportAsSingleViolation() {
return reportFromComposite;
}
public void addComposed(ConstraintValidation aConstraintValidation) {
if (composedConstraints == null) {
composedConstraints = new HashSet();
}
composedConstraints.add(aConstraintValidation);
}
public void validate(ValidationContext context) {
validate((GroupValidationContext) context);
}
public void validate(GroupValidationContext context) {
context.setConstraintValidation(this);
if (!isMemberOf(context.getCurrentGroup().getGroup())) {
}
if (context.getCurrentOwner() != null && this.owner != context.getCurrentOwner()) {
return;
}
if (validator != null && !context.collectValidated(validator))
if (context.getMetaProperty() != null && !isCascadeEnabled(context)) {
return;
if (isReportAsSingleViolation()) {
BeanValidationContext gctx = (BeanValidationContext) context;
ConstraintValidationListener oldListener =
((ConstraintValidationListener) gctx.getListener());
ConstraintValidationListener listener =
new ConstraintValidationListener(oldListener.getRootBean(), oldListener.getRootBeanType());
gctx.setListener(listener);
try {
for (ConstraintValidation composed : getComposingValidations()) {
composed.validate(context);
} finally {
gctx.setListener(oldListener);
}
context.setConstraintValidation(this);
if (!listener.getConstaintViolations().isEmpty()) {
ConstraintValidatorContextImpl jsrContext =
new ConstraintValidatorContextImpl(context, this);
return;
}
} else {
for (ConstraintValidation composed : getComposingValidations()) {
composed.validate(context);
}
context.setConstraintValidation(this);
if (validator != null) {
ConstraintValidatorContextImpl jsrContext =
new ConstraintValidatorContextImpl(context, this);
if (!validator.isValid(context.getValidatedValue(), jsrContext)) {
addErrors(context, jsrContext);
}
}
}
public void initialize() {
if (null != validator) {
try {
validator.initialize(annotation);
} catch (RuntimeException e) {
throw new ConstraintDefinitionException(
annotation.annotationType().getCanonicalName(), e);
}
}
}
private boolean isCascadeEnabled(GroupValidationContext context) {
PathImpl path = context.getPropertyPath();
NodeImpl node = path.getLeafNode();
PathImpl beanPath = path.getPathWithoutLeafNode();
if (beanPath == null) {
beanPath = PathImpl.create(null);
}
try {
if (!context.getTraversableResolver()
.isReachable(context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath,
access.getElementType())) return false;
} catch (RuntimeException e) {
throw new ValidationException(
try {
if (!context.getTraversableResolver()
.isCascadable(context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath,
access.getElementType())) return false;
} catch (RuntimeException e) {
throw new ValidationException(
return true;
}
private void addErrors(GroupValidationContext context,
ConstraintValidatorContextImpl jsrContext) {
for (ValidationListener.Error each : jsrContext.getErrorMessages()) {
context.getListener().addError(each, context);
}
public String toString() {
}
public String getMessageTemplate() {
return (String) attributes.get(ANNOTATION_MESSAGE);
}
public ConstraintValidator getValidator() {
return validator;
}
protected boolean isMemberOf(Class<?> reqGroup) {
return groups.contains(reqGroup);
}
public Class getOwner() {
return owner;
}
public T getAnnotation() {
return annotation;
}
public AccessStrategy getAccess() {
return access;
}
public void setAnnotation(T annotation) {
this.annotation = annotation;
}
public Map<String, Object> getAttributes() {
return attributes;
}
public Set<ConstraintDescriptor<?>> getComposingConstraints() {
return composedConstraints == null ? Collections.EMPTY_SET : composedConstraints;
}
Set<ConstraintValidation<?>> getComposingValidations() {
return composedConstraints == null ? Collections.EMPTY_SET : composedConstraints;
}
public Set<Class<?>> getGroups() {
return groups;
}
public Set<Class<? extends Payload>> getPayload() {
return payload;
}
public List<Class<? extends ConstraintValidator<T, ?>>> getConstraintValidatorClasses() {
if (validatorClasses == null) {
return Collections.emptyList();
return Arrays.asList(validatorClasses);
}
public int violationsSize() {
return constaintViolations.size();
}
Class<?> getCurrentOwner();
void setCurrentOwner(Class<?> currentOwner);
private Class<?> currentOwner;
super(listener, new HashMap<GraphBeanIdentity, Set<PathImpl>>());
GraphBeanIdentity gbi = new GraphBeanIdentity(getBean(), getCurrentGroup().getGroup(), getCurrentOwner());
Set<PathImpl> validatedPathsForGBI = (Set<PathImpl>) validatedObjects.get(gbi);
if (validatedPathsForGBI == null) {
validatedPathsForGBI = new HashSet<PathImpl>();
validatedObjects.put(gbi, validatedPathsForGBI);
for (PathImpl validatedPath : validatedPathsForGBI) {
validatedPathsForGBI.add(PathImpl.copy(path));
public Class<?> getCurrentOwner() {
return this.currentOwner;
}
public void setCurrentOwner(Class<?> currentOwner) {
this.currentOwner = currentOwner;
}
import org.apache.bval.jsr303.util.ClassHelper;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
ClassHelper.fillFullClassHierarchyAsList(classSequence, beanClass);
processGroupSequence(beanClass, metabean, Jsr303Features.Bean.GROUP_SEQUENCE);
}
private void processGroupSequence(Class<?> beanClass, MetaBean metabean, String key) {
List<Group> groupSeq = metabean.getFeature(key);
metabean.putFeature(key, groupSeq);
if ( validator == null ) {
}
import org.apache.bval.jsr303.util.NodeImpl;
import org.apache.bval.jsr303.util.PathImpl;
if (isCascadable(context, prop, each)) {
context.moveDown(prop, each);
followCascadedConstraint(context);
context.moveUp(bean, mbean);
}
private boolean isCascadable(GroupValidationContext<?> context, MetaProperty prop, AccessStrategy access) {
PathImpl beanPath = context.getPropertyPath();
NodeImpl node = new NodeImpl(prop.getName());
if (beanPath == null) {
beanPath = PathImpl.create(null);
}
try {
if (!context.getTraversableResolver().isReachable(
context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath,
access.getElementType()))
return false;
} catch (RuntimeException e) {
}
try {
if (!context.getTraversableResolver().isCascadable(
context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath,
access.getElementType()))
return false;
} catch (RuntimeException e) {
}
return true;
}
if (context.getMetaProperty() != null && !isReachable(context)) {
private boolean isReachable(GroupValidationContext context) {
super(metaBean, metaBean.getBeanClass(), validations);
edesc = new PropertyDescriptorImpl(
metaBean,
prop.getName(),
import java.util.Iterator;
import java.util.List;
if ( group.isDefault() ) {
List<Group> expandedDefaultGroup = metaBean.getFeature(Jsr303Features.Bean.GROUP_SEQUENCE);
for ( Group defaultGroupMember : expandedDefaultGroup ) {
for (ConstraintValidation descriptor : constraintDescriptors) {
if (isInScope(descriptor) && isInGroup(descriptor, defaultGroupMember)) {
matchingDescriptors.add(descriptor);
}
}
}
}
else {
for (ConstraintValidation descriptor : constraintDescriptors) {
if (isInScope(descriptor) && isInGroup(descriptor, group)) {
matchingDescriptors.add(descriptor);
}
for (Iterator<ConstraintValidation> it = constraintDescriptors.iterator(); it.hasNext(); ) {
ConstraintValidation cv = it.next();
if ( cv.getOwner() != metaBean.getBeanClass() ) {
it.remove();
}
}
protected ElementDescriptorImpl(MetaBean metaBean, Class<?> elementClass,
this.elementClass = elementClass;
PropertyDescriptorImpl(MetaBean metaBean, String propertyPath, Validation[] validations) {
super(metaBean, metaBean.getProperty(propertyPath).getTypeClass(), validations);
super(metaBean, metaBean.getBeanClass(), validations);
super(metaBean, metaBean.getClass(), validations);
super(metaBean, metaBean.getClass(), validations);
InputStream inputStream = loader.getResourceAsStream( path );
if ( inputStream != null ) {
if ( path.equals("META-INF/validation.xml") ) {
Enumeration<URL> urls = loader.getResources(path);
if ( urls.hasMoreElements() && (urls.nextElement() != null) && urls.hasMoreElements() ) {
}
return inputStream;
for (JAXBElement<String> mappingFileNameElement : xmlConfig.getConstraintMapping()) {
String mappingFileName = mappingFileNameElement.getValue();
if ( mappingFileName.startsWith("/") ) {
mappingFileName = mappingFileName.substring(1);
}
in = getInputStream(mappingFileName);
mappingFileName);
mappingFileName, e);
.isIgnoreAnnotations(beanClass)) {
}
Field[] fields = beanClass.getDeclaredFields();
for (Field field : fields) {
MetaProperty metaProperty = metabean.getProperty(field.getName());
if (!factoryContext.getFactory().getAnnotationIgnores()
.isIgnoreAnnotations(field)) {
if (metaProperty == null) {
metaProperty = addMetaProperty(metabean, field.getName(), field.getType());
processAnnotations(metaProperty, beanClass, field,
new FieldAccess(field),
} else {
processAnnotations(metaProperty, beanClass, field,
new FieldAccess(field),
new AppendValidationToMeta(metaProperty));
}
}
}
Method[] methods = beanClass.getDeclaredMethods();
for (Method method : methods) {
String propName = null;
if (method.getParameterTypes().length == 0) {
propName = MethodAccess.getPropertyName(method);
}
if (propName != null) {
.isIgnoreAnnotations(method)) {
MetaProperty metaProperty = metabean.getProperty(propName);
metaProperty =
addMetaProperty(metabean, propName, method.getReturnType());
processAnnotations(metaProperty, beanClass, method,
new MethodAccess(propName, method),
processAnnotations(metaProperty, beanClass, method,
new MethodAccess(propName, method),
else if ( hasValidationConstraintsDefined(method) ) {
return converter.convert(returnType, value);
if ( target.getMessageInterpolator() == null ) {
if (messageInterpolatorClass != null) {
Class<MessageInterpolator> clazz = (Class<MessageInterpolator>) SecureActions
.loadClass(messageInterpolatorClass, this.getClass());
target.messageInterpolator(SecureActions.newInstance(clazz));
if (log.isInfoEnabled())
}
if ( target.getTraversableResolver() == null ) {
if (traversableResolverClass != null) {
Class<TraversableResolver> clazz = (Class<TraversableResolver>) SecureActions
.loadClass(traversableResolverClass, this.getClass());
target.traversableResolver(SecureActions.newInstance(clazz));
if (log.isInfoEnabled())
}
if ( target.getConstraintValidatorFactory() == null ) {
if (constraintFactoryClass != null) {
Class<ConstraintValidatorFactory> clazz =
(Class<ConstraintValidatorFactory>) SecureActions
.loadClass(constraintFactoryClass, this.getClass());
target.constraintValidatorFactory(SecureActions.newInstance(clazz));
if (log.isInfoEnabled())
}
if ( prop.getValidations().length == 0 && prop.getFeature(Features.Property.REF_CASCADE) == null ) {
return null;
}
resolvedMessage = resolvedMessage.replace( "\\{", "{" ).replace( "\\}", "}" ).replace( "\\\\", "\\" );
if (constraintClasses != null && constraintClasses.length > 0) {
processAnnotations(prop, owner, annotation.annotationType(), access, new AppendValidationToBuilder(builder));
appender.append(builder.getConstraintValidation());
return true;
}
import org.apache.commons.lang.ClassUtils;
if (anno instanceof Valid) {
methodDesc.setCascaded(true);
} else {
processAnnotation(anno, methodDesc, returnAccess, validations);
}
boolean cascaded = false;
if (anno instanceof Valid) {
cascaded = true;
} else {
processAnnotation(anno, methodDesc, access, validations);
}
paramDesc.setCascaded( cascaded );
ClassUtils.primitiveToWrapper((Class)access.getJavaType()), access, validations);
import javax.validation.Valid;
public void personOp1(@Valid Person p) {
return;
}
public void personOp2(@NotNull @Valid Person p) {
return;
}
public static class Person {
@NotNull
String name;
}
public MetaProperty clone() throws CloneNotSupportedException {
return (MetaProperty) super.clone();
}
import java.io.IOException;
} catch (IOException ioe) {
Method valueMethod;
} catch (NoSuchMethodException ex) {
valueMethod = null;
}
@XStreamOmitField
private static final long serialVersionUID = 1L;
private transient Validation validation;
import java.lang.reflect.InvocationTargetException;
} catch (IllegalAccessException iae) {
} catch (NoSuchMethodException nsme) {
} catch (InvocationTargetException ite) {
if (garr == null || garr.length == 0) {
garr = GroupsComputer.getDefaultGroupArray();
}
private static volatile ApacheValidatorFactory DEFAULT_FACTORY;
prop.getFeature(Jsr303Features.Property.PropertyDescriptor);
prop.getFeature(Features.Property.REF_BEAN_TYPE, prop.getTypeClass());
DEFAULT_GROUPS = new GroupsComputer().computeGroups(
Arrays.asList(getDefaultGroupArray()));
}
public static Class<?>[] getDefaultGroupArray() {
return new Class<?>[]{Default.class};
if (converter != null) {
return converter.convert(returnType, value);
} else {
return converter;
}
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import static org.apache.bval.model.Features.Property.*;
this(new MetaBeanFactory[]{new IntrospectorMetaBeanFactory()});
public MetaBean buildForId(String beanInfoId) throws Exception {
return new HashMap<String, MetaBean>();
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import static org.apache.bval.model.Features.Property.*;
public class MetaBeanManager implements MetaBeanFinder {
protected boolean complete = false;
protected void computeRelationships(MetaBean beanInfo, Map<String, MetaBean> cached) {
import java.io.Serializable;
import java.util.*;
import org.apache.bval.routines.EMailValidationUtils;
return EMailValidationUtils.isValid(value);
import org.apache.bval.xml.XMLMetaBeanBuilder;
import org.apache.bval.xml.XMLMetaBeanManager;
protected MetaBeanManager buildMetaBeanManager() {
return createXMLMetaBeanManager(builders);
} else {
return createMetaBeanManager(builders);
protected MetaBeanManager createMetaBeanManager(List<MetaBeanFactory> builders) {
return new MetaBeanManager(
new MetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
}
protected MetaBeanManager createXMLMetaBeanManager(List<MetaBeanFactory> builders) {
builders.add(new XMLMetaBeanFactory());
return new XMLMetaBeanManager(
new XMLMetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
}
import org.apache.bval.model.*;
package org.apache.bval.xml;
import java.util.Map;
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaProperty;
import static org.apache.bval.model.Features.Property.REF_BEAN_ID;
import static org.apache.bval.model.Features.Property.*;
import org.apache.bval.model.MetaProperty;
import static org.apache.bval.model.Features.Property.*;
import org.apache.bval.model.Validation;
import org.apache.bval.model.Features;
protected final MetaBeanCache cache = new MetaBeanCache();
protected final MetaBeanBuilder builder;
protected boolean complete = false;
public MetaBeanManager() {
builder = new MetaBeanBuilder();
}
public MetaBeanManager(MetaBeanBuilder builder) {
this.builder = builder;
}
public MetaBeanBuilder getBuilder() {
return builder;
}
public MetaBeanCache getCache() {
return cache;
}
public MetaBean findForId(String beanInfoId) {
MetaBean beanInfo = cache.findForId(beanInfoId);
if (beanInfo != null) return beanInfo;
try {
beanInfo = builder.buildForId(beanInfoId);
cache.cache(beanInfo);
computeRelationships(beanInfo);
return beanInfo;
} catch (RuntimeException e) {
} catch (Exception e) {
throw new IllegalArgumentException(
}
public MetaBean findForClass(Class<?> clazz) {
if (clazz == null) return null;
MetaBean beanInfo = cache.findForClass(clazz);
if (beanInfo != null) return beanInfo;
try {
beanInfo = builder.buildForClass(clazz);
cache.cache(beanInfo);
computeRelationships(beanInfo);
return beanInfo;
} catch (RuntimeException e) {
} catch (Exception e) {
}
protected void computeRelationships(MetaBean beanInfo) {
for (MetaProperty prop : beanInfo.getProperties()) {
String beanRef = (String) prop.getFeature(REF_BEAN_ID);
computeRelatedMetaBean(prop, beanRef);
}
protected void computeRelatedMetaBean(MetaProperty prop, String beanRef) {
Class<?> beanType = prop.getFeature(REF_BEAN_TYPE);
if (beanType != null) {
prop.setMetaBean(findForClass(beanType));
prop.setMetaBean(new DynamicMetaBean(this));
}
private final ApacheValidatorFactory factory;
private final MetaBeanFinder metaBeanFinder;
private MessageInterpolator messageInterpolator;
private TraversableResolver traversableResolver;
private ConstraintValidatorFactory constraintValidatorFactory;
public ApacheFactoryContext(ApacheValidatorFactory factory) {
this.factory = factory;
this.metaBeanFinder = buildMetaBeanManager();
}
protected ApacheFactoryContext(ApacheValidatorFactory factory,
MetaBeanFinder metaBeanFinder) {
this.factory = factory;
this.metaBeanFinder = metaBeanFinder;
}
public ApacheValidatorFactory getFactory() {
return factory;
}
public final MetaBeanFinder getMetaBeanFinder() {
return metaBeanFinder;
}
public ValidatorContext messageInterpolator(MessageInterpolator messageInterpolator) {
this.messageInterpolator = messageInterpolator;
return this;
}
public ValidatorContext traversableResolver(TraversableResolver traversableResolver) {
this.traversableResolver = traversableResolver;
return this;
}
public ValidatorContext constraintValidatorFactory(
ConstraintValidatorFactory constraintValidatorFactory) {
this.constraintValidatorFactory = constraintValidatorFactory;
return this;
}
public ConstraintValidatorFactory getConstraintValidatorFactory() {
return constraintValidatorFactory == null ? factory.getConstraintValidatorFactory() :
constraintValidatorFactory;
}
public Validator getValidator() {
ClassValidator validator = new ClassValidator(this);
if (Boolean.getBoolean(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.TREAT_MAPS_LIKE_BEANS))) {
validator.setTreatMapsLikeBeans(true);
return validator;
}
public MessageInterpolator getMessageInterpolator() {
return messageInterpolator == null ? factory.getMessageInterpolator() :
messageInterpolator;
}
public TraversableResolver getTraversableResolver() {
return traversableResolver == null ? factory.getTraversableResolver() :
traversableResolver;
}
protected MetaBeanManager buildMetaBeanManager() {
List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>(3);
if (Boolean.parseBoolean(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.ENABLE_INTROSPECTOR))) {
builders.add(new IntrospectorMetaBeanFactory());
builders.add(new Jsr303MetaBeanFactory(this));
if (Boolean.parseBoolean(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML))) {
return XMLMetaBeanManagerCreator.createXMLMetaBeanManager(builders);
} else {
return createMetaBeanManager(builders);
}
new MetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
private static class XMLMetaBeanManagerCreator {
protected static MetaBeanManager createXMLMetaBeanManager(List<MetaBeanFactory> builders) {
builders.add(new XMLMetaBeanFactory());
return new XMLMetaBeanManager(
new XMLMetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
}
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.model.MetaProperty;
import static org.apache.bval.model.Features.Property.REF_BEAN_ID;
public class XMLMetaBeanManager extends MetaBeanManager
implements MetaBeanFinder, XMLMetaBeanRegistry, MetaBeanEnricher {
((XMLMetaBeanBuilder) builder).addLoader(loader);
Map<String, MetaBean> patched = ((XMLMetaBeanBuilder) builder).enrichCopies(cached, infos);
public Map<String, MetaBean> findAll() {
if (!complete) {
try {
Map<String, MetaBean> allBuilt = builder.buildAll();
for (MetaBean meta : allBuilt.values()) {
MetaBean cached = cache.findForId(meta.getId());
if (cached == null) {
cache.cache(meta);
}
}
Map<String, MetaBean> map = cache.findAll();
for (Object oentry : map.values()) {
MetaBean meta = (MetaBean) oentry;
computeRelationships(meta, map);
}
complete = true;
return map;
} catch (RuntimeException e) {
} catch (Exception e) {
throw new IllegalArgumentException("error creating beanInfos", e);
}
} else {
return cache.findAll();
}
}
protected void computeRelationships(MetaBean beanInfo, Map<String, MetaBean> cached) {
for (MetaProperty prop : beanInfo.getProperties()) {
String beanRef = (String) prop.getFeature(REF_BEAN_ID);
if (beanRef != null) {
prop.setMetaBean(cached.get(beanRef));
}
}
}
protected void computeRelatedMetaBean(MetaProperty prop, String beanRef) {
if (beanRef != null) {
prop.setMetaBean(findForId(beanRef));
} else {
super.computeRelatedMetaBean(prop, beanRef);
}
}
import org.apache.bval.model.Features;
prop.putFeature(Features.Property.REF_BEAN_ID, getBeanId());
public class BeanValidator<T extends ValidationListener> extends AbstractBeanValidator {
private final MetaBeanFinder metaBeanFinder;
public BeanValidator() {
this(MetaBeanManagerFactory.getFinder());
}
public BeanValidator(MetaBeanFinder metaBeanFinder) {
this.metaBeanFinder = metaBeanFinder;
}
public T validate(Object bean) {
MetaBean metaBean =
getMetaBeanFinder().findForClass(bean.getClass());
return validate(bean, metaBean);
}
public T validate(Object bean, MetaBean metaBean) {
ValidationContext<T> context = createContext();
context.setBean(bean, metaBean);
validateContext(context);
return context.getListener();
}
public T validateCall(Method method, Object[] parameters) {
if (parameters.length > 0) {
Annotation[][] annotations = method.getParameterAnnotations();
ValidationContext<T> context = null;
for (Annotation anno : annotations[i]) {
if (anno instanceof Validate) {
if (context == null) context = createContext();
if (determineMetaBean((Validate) anno, parameters[i], context)) {
validateContext(context);
}
}
}
}
return context != null ? context.getListener() : null;
return null;
}
protected <VL extends ValidationListener> boolean determineMetaBean(Validate validate, Object parameter,
ValidationContext<VL> context) {
if (validate.value().length() == 0) {
if (parameter == null) return false;
Class<?> beanClass;
Collection<?> coll = ((Collection<?>) parameter);
if (coll.isEmpty()) return false;
} else if (parameter.getClass().isArray()) {
beanClass = parameter.getClass().getComponentType();
} else {
beanClass = parameter.getClass();
}
context.setBean(parameter, getMetaBeanFinder().findForClass(beanClass));
} else {
context.setBean(parameter, getMetaBeanFinder().findForId(validate.value()));
return true;
}
protected T createResults() {
return (T) new ValidationResults();
}
protected ValidationContext<T> createContext() {
return new BeanValidationContext<T>(createResults());
}
public T validateProperty(Object bean, MetaProperty metaProperty) {
ValidationContext<T> context = createContext();
context.setBean(bean);
context.setMetaProperty(metaProperty);
validateProperty(context);
return context.getListener();
}
protected <VL extends ValidationListener> void validateBeanNet(ValidationContext<VL> context) {
if (context.collectValidated()) {
validateBean(context);
for (MetaProperty prop : context.getMetaBean().getProperties()) {
validateRelatedBean(context, prop);
}
}
protected <VL extends ValidationListener> void validateRelatedBean(ValidationContext<VL> context, MetaProperty prop) {
AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
final Object bean = context.getBean();
final MetaBean mbean = context.getMetaBean();
context.moveDown(prop, new PropertyAccess(bean.getClass(), prop.getName()));
validateContext(context);
context.moveUp(bean, mbean);
final Object bean = context.getBean();
final MetaBean mbean = context.getMetaBean();
for (AccessStrategy each : access) {
context.moveDown(prop, each);
context.moveUp(bean, mbean);
}
}
public MetaBeanFinder getMetaBeanFinder() {
return metaBeanFinder;
}
import org.apache.bval.AbstractBeanValidator;
import org.apache.bval.MetaBeanFinder;
public class ClassValidator extends AbstractBeanValidator implements Validator {
protected final ApacheFactoryContext factoryContext;
protected final GroupsComputer groupsComputer = new GroupsComputer();
public ClassValidator(ApacheFactoryContext factoryContext) {
this.factoryContext = factoryContext;
}
public ClassValidator(ApacheValidatorFactory factory) {
this(factory.usingContext());
}
public MetaBeanFinder getMetaBeanFinder() {
return factoryContext.getMetaBeanFinder();
}
public <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groupArray) {
if (object == null) throw new IllegalArgumentException("cannot validate null");
checkGroups(groupArray);
try {
final GroupValidationContext<ConstraintValidationListener<T>> context =
createContext(factoryContext.getMetaBeanFinder()
.findForClass(object.getClass()), object, (Class<T>) object.getClass(), groupArray);
final ConstraintValidationListener result = context.getListener();
final Groups groups = context.getGroups();
for (Group current : groups.getGroups()) {
context.setCurrentGroup(current);
validateBeanNet(context);
}
for (List<Group> eachSeq : groups.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validateBeanNet(context);
if (!result.isEmpty()) break;
}
if (!result.isEmpty()) break;
}
return result.getConstaintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, object);
}
}
@Override
protected void validateBeanNet(ValidationContext vcontext) {
GroupValidationContext<?> context = (GroupValidationContext<?>) vcontext;
if (context.getBean() == null) {
return;
if (!context.collectValidated()) {
return;
if (context.getCurrentGroup().isDefault()) {
List<Group> defaultGroups = expandDefaultGroup(context);
final ConstraintValidationListener result = (ConstraintValidationListener) context.getListener();
if (defaultGroups.size() > 1) {
int numViolations = result.violationsSize();
Group currentGroup = context.getCurrentGroup();
for (Group each : defaultGroups) {
context.setCurrentGroup(each);
super.validateBean(context);
if (result.violationsSize() > numViolations) {
break;
}
context.setCurrentGroup(currentGroup);
} else {
List<Class<?>> classHierarchy = new ArrayList<Class<?>>();
ClassHelper.fillFullClassHierarchyAsList(classHierarchy, context.getMetaBean().getBeanClass());
Class<?> initialOwner = context.getCurrentOwner();
for (Class<?> owner : classHierarchy) {
context.setCurrentOwner(owner);
int numViolations = result.violationsSize();
List<Group> ownerDefaultGroups =
for (Group each : ownerDefaultGroups) {
context.setCurrentGroup(each);
if (result.violationsSize() > numViolations) {
break;
}
}
context.setCurrentOwner(initialOwner);
context.setCurrentGroup(Group.DEFAULT);
}
}
else {
super.validateBean(context);
for (MetaProperty prop : context.getMetaBean().getProperties()) {
validateCascadedBean(context, prop);
}
}
private void validateCascadedBean(GroupValidationContext<?> context, MetaProperty prop) {
AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
final Object bean = context.getBean();
final MetaBean mbean = context.getMetaBean();
for (AccessStrategy each : access) {
if (isCascadable(context, prop, each)) {
context.moveDown(prop, each);
validateContext(context);
context.moveUp(bean, mbean);
}
}
}
private boolean isCascadable(GroupValidationContext<?> context, MetaProperty prop, AccessStrategy access) {
PathImpl beanPath = context.getPropertyPath();
NodeImpl node = new NodeImpl(prop.getName());
if (beanPath == null) {
beanPath = PathImpl.create(null);
}
try {
if (!context.getTraversableResolver().isReachable(
context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath,
access.getElementType()))
return false;
} catch (RuntimeException e) {
try {
if (!context.getTraversableResolver().isCascadable(
context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath,
access.getElementType()))
return false;
} catch (RuntimeException e) {
return true;
}
private List<Group> expandDefaultGroup(GroupValidationContext context) {
if (context.getCurrentGroup().isDefault()) {
List<Group> groupSeq =
context.getMetaBean().getFeature(Jsr303Features.Bean.GROUP_SEQUENCE);
if (groupSeq != null) {
context.getGroups().assertDefaultGroupSequenceIsExpandable(groupSeq);
}
return groupSeq;
} else {
return null;
}
}
protected RuntimeException unrecoverableValidationError(RuntimeException ex,
Object object) {
if (ex instanceof UnknownPropertyException) {
return new IllegalArgumentException(ex.getMessage(), ex);
} else if (ex instanceof ValidationException) {
} else {
}
}
public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName,
Class<?>... groups) {
if (object == null) throw new IllegalArgumentException("cannot validate null");
checkPropertyName(propertyName);
checkGroups(groups);
try {
MetaBean metaBean =
factoryContext.getMetaBeanFinder().findForClass(object.getClass());
GroupValidationContext<ConstraintValidationListener<T>> context =
createContext(metaBean, object, (Class<T>) object.getClass(), groups);
ConstraintValidationListener result = context.getListener();
NestedMetaProperty nestedProp = getNestedProperty(metaBean, object, propertyName);
context.setMetaProperty(nestedProp.getMetaProperty());
if (nestedProp.isNested()) {
context.setFixedValue(nestedProp.getValue());
} else {
context.setMetaProperty(nestedProp.getMetaProperty());
}
if (context.getMetaProperty() == null) throw new IllegalArgumentException(
Groups sequence = context.getGroups();
for (Group current : sequence.getGroups()) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
}
for (List<Group> eachSeq : sequence.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
if (!result.isEmpty()) break;
if (!result.isEmpty()) break;
}
return result.getConstaintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, object);
}
private void validatePropertyInGroup(GroupValidationContext context) {
Group currentGroup = context.getCurrentGroup();
List<Group> defaultGroups = expandDefaultGroup(context);
if (defaultGroups != null) {
for (Group each : defaultGroups) {
context.setCurrentGroup(each);
validateProperty(context);
}
} else {
validateProperty(context);
}
}
private NestedMetaProperty getNestedProperty(MetaBean metaBean, Object t,
String propertyName) {
NestedMetaProperty nested = new NestedMetaProperty(propertyName, t);
nested.setMetaBean(metaBean);
nested.parse();
return nested;
}
public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType,
String propertyName, Object value,
Class<?>... groups) {
checkBeanType(beanType);
checkPropertyName(propertyName);
checkGroups(groups);
try {
MetaBean metaBean = factoryContext.getMetaBeanFinder().findForClass(beanType);
GroupValidationContext<ConstraintValidationListener<T>> context =
createContext(metaBean, null, beanType, groups);
ConstraintValidationListener result = context.getListener();
context.setMetaProperty(
getNestedProperty(metaBean, null, propertyName).getMetaProperty());
context.setFixedValue(value);
Groups sequence = context.getGroups();
for (Group current : sequence.getGroups()) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
}
for (List<Group> eachSeq : sequence.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
if (!result.isEmpty()) break;
if (!result.isEmpty()) break;
}
return result.getConstaintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, value);
}
protected <T> GroupValidationContext<ConstraintValidationListener<T>> createContext(
MetaBean metaBean, T object, Class<T> objectClass, Class<?>[] groups) {
ConstraintValidationListener<T> listener = new ConstraintValidationListener<T>(object, objectClass);
GroupValidationContextImpl<ConstraintValidationListener<T>> context =
new GroupValidationContextImpl(listener,
this.factoryContext.getMessageInterpolator(),
this.factoryContext.getTraversableResolver(), metaBean);
context.setBean(object, metaBean);
context.setGroups(groupsComputer.computeGroups(groups));
return context;
}
public BeanDescriptor getConstraintsForClass(Class<?> clazz) {
if (clazz == null) {
throw new IllegalArgumentException("Class cannot be null");
try {
MetaBean metaBean = factoryContext.getMetaBeanFinder().findForClass(clazz);
BeanDescriptorImpl edesc =
metaBean.getFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR);
if (edesc == null) {
edesc = createBeanDescriptor(metaBean);
metaBean.putFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR, edesc);
}
return edesc;
} catch (RuntimeException ex) {
}
}
protected BeanDescriptorImpl createBeanDescriptor(MetaBean metaBean) {
return new BeanDescriptorImpl(factoryContext, metaBean, metaBean.getValidations());
}
public <T> T unwrap(Class<T> type) {
if (type.isAssignableFrom(getClass())) {
return (T) this;
} else if (!type.isInterface()) {
return SecureActions.newInstance(type, new Class[]{ApacheFactoryContext.class},
new Object[]{factoryContext});
} else {
try {
return SecureActions.newInstance(cls,
new Class[]{ApacheFactoryContext.class}, new Object[]{factoryContext});
} catch (ClassNotFoundException e) {
}
}
private void checkBeanType(Class<?> beanType) {
if (beanType == null) {
throw new IllegalArgumentException("Bean type cannot be null.");
}
private void checkPropertyName(String propertyName) {
if (propertyName == null || propertyName.isEmpty()) {
throw new IllegalArgumentException("Property path cannot be null or empty.");
}
private void checkGroups(Class<?>[] groups) {
if (groups == null) {
throw new IllegalArgumentException("Groups cannot be null.");
}
if (factories[i] instanceof Jsr303MetaBeanFactory && !(factories[i] instanceof MethodValidatorMetaBeanFactory)) {
}
validateBean(context);
validateBean(context);
validateBean(context);
protected <VL extends ValidationListener> void validateIterableInContext(ValidationContext<VL> context) {
final boolean positional = context.getBean() instanceof List<?>;
for ( Object each : (Iterable<?>) context.getBean() ) {
if ( positional ) {
}
if (each == null) {
}
context.setBean(each, dyn.resolveMetaBean(each));
context.setBean(each);
if (entry.getValue() == null) {
}
validateIterableInContext(context);
@Override
Class<T> objectClass = (Class<T>) object.getClass();
MetaBean objectMetaBean = factoryContext.getMetaBeanFinder().findForClass(objectClass);
createContext(objectMetaBean, object, objectClass, groupArray);
final ConstraintValidationListener<T> result = context.getListener();
final Groups sequence = context.getGroups();
for (Group current : sequence.getGroups()) {
for (List<Group> eachSeq : sequence.getSequences()) {
if (!result.isEmpty()) break;
}
if (!result.isEmpty()) break;
}
return result.getConstaintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, object);
}
}
@Override
public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName,
Class<?>... groups) {
if (object == null) throw new IllegalArgumentException("cannot validate null");
checkPropertyName(propertyName);
checkGroups(groups);
try {
Class<T> objectClass = (Class<T>) object.getClass();
MetaBean objectMetaBean = factoryContext.getMetaBeanFinder().findForClass(objectClass);
GroupValidationContext<ConstraintValidationListener<T>> context =
createContext(objectMetaBean, object, objectClass, groups);
ConstraintValidationListener<T> result = context.getListener();
NestedMetaProperty nestedProp = getNestedProperty(objectMetaBean, object, propertyName);
context.setMetaProperty(nestedProp.getMetaProperty());
if (nestedProp.isNested()) {
context.setFixedValue(nestedProp.getValue());
} else {
context.setMetaProperty(nestedProp.getMetaProperty());
}
if (context.getMetaProperty() == null) throw new IllegalArgumentException(
Groups sequence = context.getGroups();
for (Group current : sequence.getGroups()) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
}
for (List<Group> eachSeq : sequence.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
@Override
public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType,
String propertyName, Object value,
Class<?>... groups) {
checkBeanType(beanType);
checkPropertyName(propertyName);
checkGroups(groups);
try {
MetaBean metaBean = factoryContext.getMetaBeanFinder().findForClass(beanType);
GroupValidationContext<ConstraintValidationListener<T>> context =
createContext(metaBean, null, beanType, groups);
ConstraintValidationListener<T> result = context.getListener();
context.setMetaProperty(
getNestedProperty(metaBean, null, propertyName).getMetaProperty());
context.setFixedValue(value);
Groups sequence = context.getGroups();
for (Group current : sequence.getGroups()) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
}
for (List<Group> eachSeq : sequence.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
if (!result.isEmpty()) break;
}
if (!result.isEmpty()) break;
}
return result.getConstaintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, value);
}
}
@Override
public BeanDescriptor getConstraintsForClass(Class<?> clazz) {
if (clazz == null) {
throw new IllegalArgumentException("Class cannot be null");
}
try {
MetaBean metaBean = factoryContext.getMetaBeanFinder().findForClass(clazz);
BeanDescriptorImpl edesc =
metaBean.getFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR);
if (edesc == null) {
edesc = createBeanDescriptor(metaBean);
metaBean.putFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR, edesc);
}
return edesc;
} catch (RuntimeException ex) {
}
}
@SuppressWarnings("unchecked")
@Override
public <T> T unwrap(Class<T> type) {
if (type.isAssignableFrom(getClass())) {
return (T) this;
} else if (!type.isInterface()) {
return SecureActions.newInstance(type, new Class[]{ApacheFactoryContext.class},
new Object[]{factoryContext});
} else {
try {
return SecureActions.newInstance(cls,
new Class[]{ApacheFactoryContext.class}, new Object[]{factoryContext});
} catch (ClassNotFoundException e) {
}
}
}
new GroupValidationContextImpl<ConstraintValidationListener<T>>(listener,
if (propertyName == null || propertyName.trim().length() == 0) {
if (propertyName == null || propertyName.trim().length() == 0) {
List<Class<?>> subClasses = new ArrayList(Arrays.asList(clazz.getInterfaces()));
Class<? extends Throwable> rethrowExceptionsAs() default Exception.class;
import javax.validation.ConstraintViolationException;
Class<? extends Throwable> rethrowExceptionsAs() default ConstraintViolationException.class;
import java.lang.reflect.Constructor;
throw getException(new ConstraintViolationException("Validation error when calling method '"
Arrays.deepToString(arguments), constraintViolations), validate.rethrowExceptionsAs());
throw getException(new ConstraintViolationException("Method '"
returnedValue, constraintViolations), validate.rethrowExceptionsAs());
private static Throwable getException(ConstraintViolationException exception,
Class<? extends Throwable> exceptionWrapperClass) {
if (exceptionWrapperClass == ConstraintViolationException.class) {
return exception;
}
Throwable rethrowEx = null;
try {
Constructor<? extends Throwable> constructor = exceptionWrapperClass.getConstructor(Throwable.class);
rethrowEx = constructor.newInstance(exception);
} catch (Exception e) {
rethrowEx = new RuntimeException("Impossible to re-throw '"
exceptionWrapperClass
"', it needs the constructor with <Throwable> argument.", e);
}
return rethrowEx;
}
import javax.validation.Valid;
@Validate(
groups = { Update.class },
rethrowExceptionsAs = DummyException.class
)
public int updateCountry(@Valid Country country) {
return 0;
}
import javax.validation.ValidationException;
if ( methodDescriptor == null ) {
}
if ( methodDescriptor == null ) {
}
if ( constructorDescriptor == null ) {
}
ConstructorDescriptorImpl constructorDescriptor =
if ( constructorDescriptor == null ) {
}
ParameterDescriptorImpl paramDesc = (ParameterDescriptorImpl) constructorDescriptor
if ( methodDescriptor == null ) {
}
@SuppressWarnings("unchecked")
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
setFixed(true);
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
void buildMetaBean(MetaBean metaBean) throws Exception;
this(enumClass);
import org.apache.commons.lang.ArrayUtils;
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
validations = (Validation[]) ArrayUtils.add(validations, validation);
public Class<?> getBeanClass() {
return beanClass;
}
}
private static Class<?> getTypeClass(Type rawType) {
public Type getJavaType() {
return field.getGenericType();
}
public Type getJavaType() {
return method.getGenericReturnType();
}
final class AnnotationConstraintBuilder<A extends Annotation> {
Class<? extends ConstraintValidator<A, ?>>[] validatorClasses,
ConstraintValidator<A, ?> constraintValidator, A annotation, Class<?> owner,
constraintValidation = new ConstraintValidation<A>(validatorClasses,
if (raw instanceof Class<?>) {
garr = new Class[]{(Class<?>) raw};
constraintValidation.setGroups(new HashSet<Class<?>>(Arrays.asList(garr)));
@SuppressWarnings("unchecked")
Class<? extends Payload>[] payload_raw =
(Class<? extends Payload>[]) method.invoke(constraintValidation.getAnnotation());
Set<Class<? extends Payload>> payloadSet;
payloadSet = Collections.<Class<? extends Payload>>emptySet();
payloadSet = new HashSet<Class<? extends Payload>>(payload_raw.length);
payloadSet.addAll(Arrays.asList(payload_raw));
constraintValidation.setPayload(payloadSet);
public ConstraintValidation<?> getConstraintValidation() {
public void addComposed(ConstraintValidation<?> composite) {
values = new HashMap<String, Object>();
@SuppressWarnings("unchecked")
private void applyOn(ConstraintValidation<?> composite) {
((ConstraintValidation<Annotation>) composite).setAnnotation(newAnnot);
@SuppressWarnings("deprecation")
protected MetaBeanManager buildMetaBeanManager() {
protected static XMLMetaBeanManager createXMLMetaBeanManager(List<MetaBeanFactory> builders) {
public static synchronized ApacheValidatorFactory getDefault() {
public ConstraintValidatorFactory getConstraintValidatorFactory() {
return constraintValidatorFactory;
}
@SuppressWarnings("unchecked")
if (type.isInstance(this)) {
public void addValid(Class<?> beanClass, AccessStrategy accessStrategy) {
slot.add(accessStrategy);
tmpList.add(accessStrategy);
@SuppressWarnings("unchecked")
return Collections.<AccessStrategy> emptyList();
private final AnnotationConstraintBuilder<?> builder;
public AppendValidationToBuilder(AnnotationConstraintBuilder<?> builder) {
import org.apache.bval.model.ValidationListener;
@SuppressWarnings("unchecked")
public <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {
checkGroups(groups);
createContext(objectMetaBean, object, objectClass, groups);
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
protected <VL extends ValidationListener> void validateBeanNet(ValidationContext<VL> validationContext) {
GroupValidationContext<VL> context = (GroupValidationContext<VL>) validationContext;
final ConstraintValidationListener<VL> result = (ConstraintValidationListener<VL>) context.getListener();
private List<Group> expandDefaultGroup(GroupValidationContext<?> context) {
protected static RuntimeException unrecoverableValidationError(RuntimeException ex,
private void validatePropertyInGroup(GroupValidationContext<?> context) {
import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;
import javax.validation.ValidationException;
import javax.validation.ValidationProviderResolver;
import javax.validation.ValidatorFactory;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
protected final ValidationProvider<?> provider;
public ConfigurationImpl(BootstrapState aState, ValidationProvider<?> aProvider) {
public ValidationProvider<?> getProvider() {
private ValidationProvider<?> findProvider() {
for (ValidationProvider<?> provider : providerResolver
new HashMap<Class<? extends Annotation>, Class<? extends ConstraintValidator<?,?>>[]>();
Class<? extends ConstraintValidator<A, ?>>[] definitionClasses) {
@SuppressWarnings("unchecked")
public <A extends Annotation> Class<? extends ConstraintValidator<A, ?>>[] getConstraintValidators(
return (Class<? extends ConstraintValidator<A, ?>>[]) classes.get(annotationClass);
import java.lang.annotation.Annotation;
private static final String DEFAULT_CONSTRAINTS =
protected Map<String, Class<? extends ConstraintValidator<?, ?>>[]> defaultConstraints;
defaultConstraints = loadDefaultConstraints(DEFAULT_CONSTRAINTS);
public Map<String, Class<? extends ConstraintValidator<?, ?>>[]> getDefaultConstraints() {
@SuppressWarnings("unchecked")
public <A extends Annotation> Class<? extends ConstraintValidator<A, ?>>[] getValidatorClasses(
Class<A> annotationType) {
return (Class<? extends ConstraintValidator<A, ?>>[]) getDefaultConstraints().get(annotationType.getName());
@SuppressWarnings("unchecked")
private Map<String, Class<? extends ConstraintValidator<?, ?>>[]> loadDefaultConstraints(String resource) {
Map<String, Class<? extends ConstraintValidator<?, ?>>[]> loadedConstraints
= new HashMap<String, Class<? extends ConstraintValidator<?,?>>[]>();
private static final long serialVersionUID = 1L;
import javax.validation.metadata.ElementDescriptor.ConstraintFinder;
private Set<ConstraintValidation<?>> constraintDescriptors;
ConstraintFinderImpl(MetaBean metaBean, Set<ConstraintValidation<?>> constraintDescriptors) {
Set<ConstraintValidation<?>> matchingDescriptors =
new HashSet<ConstraintValidation<?>>(constraintDescriptors.size());
for (ConstraintValidation<?> descriptor : constraintDescriptors) {
for (ConstraintValidation<?> descriptor : constraintDescriptors) {
for (Iterator<ConstraintValidation<?>> it = constraintDescriptors.iterator(); it.hasNext(); ) {
ConstraintValidation<?> cv = it.next();
Set<ConstraintValidation<?>> matchingDescriptors =
new HashSet<ConstraintValidation<?>>(constraintDescriptors.size());
for (ConstraintValidation<?> descriptor : constraintDescriptors) {
private boolean isAtElement(ConstraintValidation<?> descriptor, ElementType each) {
private boolean isInScope(ConstraintValidation<?> descriptor) {
Class<?> owner = descriptor.getOwner();
private boolean isInGroup(ConstraintValidation<?> descriptor, Group group) {
Set<ConstraintValidation<?>> matchingDescriptors) {
@SuppressWarnings("unchecked")
import java.io.Serializable;
private final ConstraintValidator<T, ?> validator;
private final Class<?> owner;
ConstraintValidator<T, ?> validator, T annotation, Class<?> owner,
this.attributes = new HashMap<String, Object>();
return new ConstraintDescriptorImpl<T>(this);
public void addComposed(ConstraintValidation<?> aConstraintValidation) {
composedConstraints = new HashSet<ConstraintValidation<?>>();
public <L extends ValidationListener> void validate(ValidationContext<L> context) {
validate((GroupValidationContext<L>) context);
public <L extends ValidationListener> void validate(GroupValidationContext<L> context) {
for (ConstraintValidation<?> composed : getComposingValidations()) {
if (!((ConstraintValidator<T, Object>) validator).isValid(context.getValidatedValue(), jsrContext)) {
private boolean isReachable(GroupValidationContext<?> context) {
private void addErrors(GroupValidationContext<?> context,
public ConstraintValidator<T, ?> getValidator() {
public Class<?> getOwner() {
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
private final Set<ConstraintViolation<T>> constraintViolations = new HashSet<ConstraintViolation<T>>();
public <VL extends ValidationListener> void addError(String reason, ValidationContext<VL> context) {
public <VL extends ValidationListener> void addError(Error error, ValidationContext<VL> context) {
ValidationContext<?> context) {
final ConstraintDescriptor<?> descriptor;
if (context instanceof GroupValidationContext<?>) {
GroupValidationContext<?> gcontext = (GroupValidationContext<?>) context;
constraintViolations.add(ic);
return constraintViolations;
return constraintViolations.isEmpty();
return constraintViolations.size();
import javax.validation.ConstraintValidator;
private final ConstraintValidation<?> constraintDescriptor;
private final GroupValidationContext<?> validationContext;
public ConstraintValidatorContextImpl(GroupValidationContext<?> validationContext,
ConstraintValidation<?> aConstraintValidation) {
public GroupValidationContext<?> getValidationContext() {
private static final long serialVersionUID = 1L;
private final ConstraintDescriptor<?> constraintDescriptor;
ConstraintDescriptor<?> constraintDescriptor, Class<T> rootBeanClass, ElementType elementType) {
public ConstraintDescriptor<?> getConstraintDescriptor() {
@Override
return interpolate(message, context, defaultLocale);
List<ValidationProvider<?>> providers = new ArrayList<ValidationProvider<?>>();
providers.add((ValidationProvider<?>) SecureActions.newInstance(provider));
@SuppressWarnings("unchecked")
return new ConstraintFinderImpl(metaBean, (Set) constraintDescriptors);
if (validation instanceof ConstraintValidation<?>) {
ConstraintValidation<?> cval = (ConstraintValidation<?>) validation;
void setConstraintValidation(ConstraintValidation<?> constraint);
ConstraintValidation<?> getConstraintValidation();
Object getValidatedValue();
boolean collectValidated(ConstraintValidator<?, ?> constraint);
private ConstraintValidation<?> constraintValidation;
@SuppressWarnings("unchecked")
public boolean collectValidated(ConstraintValidator<?, ?> constraint) {
public void setConstraintValidation(ConstraintValidation<?> constraint) {
public ConstraintValidation<?> getConstraintValidation() {
public ConstraintDescriptor<?> getConstraintDescriptor() {
return constraintValidation;
}
@SuppressWarnings("unchecked")
Class<? extends ConstraintValidator<? extends Annotation, ?>>[] constraintClasses =
applyConstraint(
(Annotation) meta.getAnnotation(),
(Class<? extends ConstraintValidator<Annotation, ?>>[]) constraintClasses,
metaProperty, beanClass, meta.getAccessStrategy(),
new AppendValidationToMeta(metaProperty == null ? metabean
: metaProperty));
private <A extends Annotation> boolean processAnnotation(A annotation, MetaProperty prop, Class<?> owner,
Class<? extends ConstraintValidator<A, ?>>[] validatorClasses;
@SuppressWarnings("unchecked")
protected <A extends Annotation> Class<? extends ConstraintValidator<A, ?>>[] findConstraintValidatorClasses(
A annotation, Constraint vcAnno) {
Class<? extends ConstraintValidator<A, ?>>[] validatorClasses;
Class<A> annotationType = (Class<A>) annotation.annotationType();
.getConstraintValidators(annotationType);
validatorClasses = (Class<? extends ConstraintValidator<A, ?>>[]) vcAnno.validatedBy();
.getValidatorClasses(annotationType);
protected <A extends Annotation> boolean applyConstraint(A annotation,
Class<? extends ConstraintValidator<A, ?>>[] constraintClasses,
final ConstraintValidator<A, ?> validator;
Map<Type, Class<? extends ConstraintValidator<A, ?>>> validatorTypes =
(Map<Type, Class<? extends ConstraintValidator<A, ?>>>) TypeUtils.getValidatorsTypes(constraintClasses);
final AnnotationConstraintBuilder<A> builder = new AnnotationConstraintBuilder<A>(
void parse() {
@SuppressWarnings("unchecked")
import org.apache.bval.jsr303.AppendValidation;
@SuppressWarnings("unchecked")
ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
@SuppressWarnings("unchecked")
ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
return Collections.<ConstraintViolation<T>> emptySet();
@SuppressWarnings("unchecked")
final ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
for (ConstraintDescriptor<?> consDesc : paramDesc.getConstraintDescriptors()) {
ConstraintValidation<?> validation = (ConstraintValidation<?>) consDesc;
for (ConstraintDescriptor<?> consDesc : methodDescriptor.getConstraintDescriptors()) {
ConstraintValidation<?> validation = (ConstraintValidation<?>) consDesc;
private <A extends Annotation> void processAnnotation(A annotation, ProcedureDescriptor desc,
Class<? extends ConstraintValidator<A, ?>>[] validatorClasses;
ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations);
import javax.validation.TraversableResolver;
@SuppressWarnings("unchecked")
import javax.validation.ConstraintValidatorContext.ConstraintViolationBuilder.NodeContextBuilder;
import java.util.Map;
private static final String PROPERTY_PATH_SEPARATOR = ".";
if (path instanceof PathImpl && ((PathImpl) path).isRootPath()) {
builder.append(PROPERTY_PATH_SEPARATOR);
import java.lang.annotation.Annotation;
public static <A extends Annotation> Map<Type, Class<? extends ConstraintValidator<A, ?>>> getValidatorsTypes(
Class<? extends ConstraintValidator<A, ?>>[] validators) {
Map<Type, Class<? extends ConstraintValidator<A, ?>>> validatorsTypes =
new HashMap<Type, Class<? extends ConstraintValidator<A, ?>>>();
for (Class<? extends ConstraintValidator<A, ?>> validator : validators) {
ignoreAnnotationDefaults.put(clazz, b == null || b.booleanValue());
return ignoreAnnotationDefaults.containsKey(clazz)
&& ignoreAnnotationDefaults.get(clazz);
List<Member> memberList = ignoreAnnotationOnMember.get(beanClass);
if (memberList == null) {
memberList = new ArrayList<Member>();
ignoreAnnotationOnMember.put(beanClass, memberList);
memberList.add(member);
private static final long serialVersionUID = 1L;
this(annotationType);
@SuppressWarnings("unchecked")
this((Class<A>) annot.annotationType());
@SuppressWarnings("unchecked")
@SuppressWarnings("restriction")
private final Set<Class<?>> processedClasses;
this.processedClasses = new HashSet<Class<?>>();
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
} else if (serializable instanceof JAXBElement<?> &&
((JAXBElement<?>) serializable).getDeclaredType()
} else if (serializable instanceof JAXBElement<?> &&
((JAXBElement<?>) serializable).getDeclaredType()
Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) returnType;
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
@SuppressWarnings("restriction")
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
protected MetaBeanManager buildMetaBeanManager() {
protected static MetaBeanManager createXMLMetaBeanManager(List<MetaBeanFactory> builders) {
}
return result.getConstraintViolations();
return result.getConstraintViolations();
return result.getConstraintViolations();
if (!listener.getConstraintViolations().isEmpty()) {
public Set<ConstraintViolation<T>> getConstraintViolations() {
return result.getConstraintViolations();
return result.getConstraintViolations();
return result.getConstraintViolations();
final GroupValidationContext<T> context =
GroupValidationContext<T> context =
GroupValidationContext<T> context =
protected <T> GroupValidationContext<T> createContext(
GroupValidationContextImpl<T> context =
new GroupValidationContextImpl<T>(listener,
validate((GroupValidationContext<?>) context);
public void validate(GroupValidationContext<?> context) {
ConstraintValidationListener<?> listener = context.getListener();
listener.beginReportAsSingle();
boolean failed = false;
for (Iterator<ConstraintValidation<?>> composed = getComposingValidations().iterator(); !failed && composed.hasNext();) {
composed.next().validate(context);
failed = listener.hasViolations();
}
listener.endReportAsSingle();
context.setConstraintValidation(this);
if (failed) {
import java.util.concurrent.atomic.AtomicInteger;
private final AtomicInteger compositeDepth = new AtomicInteger(0);
private boolean hasCompositeError;
if (compositeDepth.get() > 0) {
hasCompositeError |= true;
return;
}
public boolean hasViolations() {
return compositeDepth.get() == 0 ? !constraintViolations.isEmpty() : hasCompositeError;
}
public boolean beginReportAsSingle() {
return compositeDepth.incrementAndGet() == 1;
}
public boolean endReportAsSingle() {
return compositeDepth.decrementAndGet() == 0;
}
public interface GroupValidationContext<T>
extends ValidationContext<ConstraintValidationListener<T>> {
final class GroupValidationContextImpl<T>
extends BeanValidationContext<ConstraintValidationListener<T>>
public GroupValidationContextImpl(ConstraintValidationListener<T> listener, MessageInterpolator aMessageResolver,
final GroupValidationContext<Object> context =
final GroupValidationContext<Object> context =
GroupValidationContext<T> context,
GroupValidationContext<T> context,
if (!(value instanceof CharSequence)) return false;
CharSequence seq = (CharSequence) value;
if (seq.length() == 0) return true;
Matcher m = aPattern.matcher(seq);
public class EmailValidator implements ConstraintValidator<Email, CharSequence> {
public boolean isValid(CharSequence value, ConstraintValidatorContext context) {
import org.apache.bval.util.ValidationHelper;
public class BeanValidator<T extends ValidationListener> {
ValidationHelper.validateContext(context, new BeanValidatorCallback(context), treatMapsLikeBeans);
ValidationHelper.validateContext(context, new BeanValidatorCallback(context), treatMapsLikeBeans);
ValidationHelper.validateProperty(context);
ValidationHelper.validateBean(context);
ValidationHelper.validateContext(context, new BeanValidatorCallback(context), treatMapsLikeBeans);
ValidationHelper.validateContext(context, new BeanValidatorCallback(context), treatMapsLikeBeans);
private boolean treatMapsLikeBeans = false;
public boolean isTreatMapsLikeBeans() {
return treatMapsLikeBeans;
}
public void setTreatMapsLikeBeans(boolean treatMapsLikeBeans) {
this.treatMapsLikeBeans = treatMapsLikeBeans;
}
private class BeanValidatorCallback implements ValidationHelper.ValidateCallback {
private final ValidationContext<?> context;
public BeanValidatorCallback(ValidationContext<?> context) {
this.context = context;
}
public void validate() {
validateBeanNet(context);
}
}
public final class DynamicMetaBean extends MetaBean {
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import javax.validation.ConstraintViolation;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.groups.Default;
import javax.validation.metadata.BeanDescriptor;
import org.apache.bval.util.ValidationHelper;
public class ClassValidator implements Validator {
protected void validateBeanNet(GroupValidationContext<?> context) {
final ConstraintValidationListener<?> result = (ConstraintValidationListener<?>) context.getListener();
ValidationHelper.validateBean(context);
ValidationHelper.validateBean(context);
ValidationHelper.validateBean(context);
ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), treatMapsLikeBeans);
ValidationHelper.validateProperty(context);
ValidationHelper.validateProperty(context);
private boolean treatMapsLikeBeans = false;
public boolean isTreatMapsLikeBeans() {
return treatMapsLikeBeans;
}
public void setTreatMapsLikeBeans(boolean treatMapsLikeBeans) {
this.treatMapsLikeBeans = treatMapsLikeBeans;
}
protected class Jsr303ValidationCallback implements ValidationHelper.ValidateCallback {
private final GroupValidationContext<?> context;
public Jsr303ValidationCallback(GroupValidationContext<?> context) {
this.context = context;
}
public void validate() {
validateBeanNet(context);
}
}
import org.apache.bval.util.ValidationHelper;
ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
@SuppressWarnings("unchecked")
final ConstraintValidator<T, Object> objectValidator = (ConstraintValidator<T, Object>) validator;
if (!objectValidator.isValid(context.getValidatedValue(), jsrContext)) {
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
private ValidatorProvider validatorProvider;
public void setValidatorProvider(ValidatorProvider validatorProvider) {
this.validatorProvider = validatorProvider;
Validator validator = this.validatorProvider.get();
MethodValidator methodValidator = validator.unwrap(MethodValidator.class);
final class ValidatorProvider implements Provider<Validator> {
private final ValidatorFactory validatorFactory;
this.validatorFactory = validatorFactory;
return this.validatorFactory.getValidator();
final class ValidatorFactoryProvider implements Provider<ValidatorFactory> {
method
"' with arguments "
Arrays.deepToString(arguments), constraintViolations),
validate.rethrowExceptionsAs());
private boolean inIterable;
this.inIterable = node.isInIterable();
return inIterable;
this.inIterable = inIterable;
inIterable = true;
inIterable = true;
if (inIterable) {
if (inIterable != node.inIterable) {
private static final Object UNKNOWN = new Object() {
public String toString() {
return "unknown property value";
};
};
@SuppressWarnings("unchecked")
final T result = (T) this;
return result;
if (type.isAssignableFrom(cls)) {
@SuppressWarnings("unchecked")
final Class<? extends T> implClass = (Class<? extends T>) cls;
return SecureActions.newInstance(implClass);
}
@SuppressWarnings("unchecked")
final T result = (T) this;
return result;
if (type.isAssignableFrom(cls)) {
@SuppressWarnings("unchecked")
final Class<? extends T> implClass = (Class<? extends T>) cls;
return SecureActions.newInstance(implClass,
new Class[]{ApacheFactoryContext.class}, new Object[]{factoryContext});
}
import java.lang.reflect.Modifier;
} else if (!(type.isInterface() || Modifier.isAbstract(type.getModifiers()))) {
import java.lang.reflect.Modifier;
} else if (!(type.isInterface() || Modifier.isAbstract(type.getModifiers()))) {
protected final ApacheFactoryContext factoryContext;
protected final GroupsComputer groupsComputer = new GroupsComputer();
public ClassValidator(ApacheFactoryContext factoryContext) {
this.factoryContext = factoryContext;
public ClassValidator(ApacheValidatorFactory factory) {
this(factory.usingContext());
public MetaBeanFinder getMetaBeanFinder() {
return factoryContext.getMetaBeanFinder();
}
@SuppressWarnings("unchecked")
public <T> Set<ConstraintViolation<T>> validate(T object,
Class<?>... groups) {
if (object == null)
throw new IllegalArgumentException("cannot validate null");
checkGroups(groups);
try {
Class<T> objectClass = (Class<T>) object.getClass();
MetaBean objectMetaBean =
factoryContext.getMetaBeanFinder().findForClass(objectClass);
final GroupValidationContext<T> context =
createContext(objectMetaBean, object, objectClass, groups);
final ConstraintValidationListener<T> result =
context.getListener();
final Groups sequence = context.getGroups();
for (Group current : sequence.getGroups()) {
context.setCurrentGroup(current);
validateBeanNet(context);
for (List<Group> eachSeq : sequence.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validateBeanNet(context);
if (!result.isEmpty())
break;
}
if (!result.isEmpty())
break;
}
return result.getConstraintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, object);
}
}
@SuppressWarnings("unchecked")
public <T> Set<ConstraintViolation<T>> validateProperty(T object,
String propertyName, Class<?>... groups) {
if (object == null)
throw new IllegalArgumentException("cannot validate null");
checkPropertyName(propertyName);
checkGroups(groups);
try {
Class<T> objectClass = (Class<T>) object.getClass();
MetaBean objectMetaBean =
factoryContext.getMetaBeanFinder().findForClass(objectClass);
GroupValidationContext<T> context =
createContext(objectMetaBean, object, objectClass, groups);
ConstraintValidationListener<T> result = context.getListener();
NestedMetaProperty nestedProp =
getNestedProperty(objectMetaBean, object, propertyName);
context.setMetaProperty(nestedProp.getMetaProperty());
if (nestedProp.isNested()) {
context.setFixedValue(nestedProp.getValue());
}
if (context.getMetaProperty() == null)
throw new IllegalArgumentException("Unknown property "
Groups sequence = context.getGroups();
for (Group current : sequence.getGroups()) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
}
for (List<Group> eachSeq : sequence.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
if (!result.isEmpty())
break;
}
if (!result.isEmpty())
break;
}
return result.getConstraintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, object);
}
}
public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType,
String propertyName, Object value, Class<?>... groups) {
checkBeanType(beanType);
checkPropertyName(propertyName);
checkGroups(groups);
try {
MetaBean metaBean =
factoryContext.getMetaBeanFinder().findForClass(beanType);
GroupValidationContext<T> context =
createContext(metaBean, null, beanType, groups);
ConstraintValidationListener<T> result = context.getListener();
context.setMetaProperty(getNestedProperty(metaBean, null,
propertyName).getMetaProperty());
context.setFixedValue(value);
Groups sequence = context.getGroups();
for (Group current : sequence.getGroups()) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
}
for (List<Group> eachSeq : sequence.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validatePropertyInGroup(context);
if (!result.isEmpty())
break;
}
if (!result.isEmpty())
break;
}
return result.getConstraintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, value);
}
}
public BeanDescriptor getConstraintsForClass(Class<?> clazz) {
if (clazz == null) {
throw new IllegalArgumentException("Class cannot be null");
}
try {
MetaBean metaBean =
factoryContext.getMetaBeanFinder().findForClass(clazz);
BeanDescriptorImpl edesc =
metaBean.getFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR);
if (edesc == null) {
edesc = createBeanDescriptor(metaBean);
metaBean.putFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR, edesc);
}
return edesc;
} catch (RuntimeException ex) {
throw new ValidationException("error retrieving constraints for "
clazz, ex);
}
}
public <T> T unwrap(Class<T> type) {
if (type.isAssignableFrom(getClass())) {
@SuppressWarnings("unchecked")
final T result = (T) this;
return result;
} else if (!(type.isInterface() || Modifier.isAbstract(type
.getModifiers()))) {
return SecureActions.newInstance(type,
new Class[] { ApacheFactoryContext.class },
new Object[] { factoryContext });
} else {
try {
if (type.isAssignableFrom(cls)) {
@SuppressWarnings("unchecked")
final Class<? extends T> implClass =
(Class<? extends T>) cls;
return SecureActions.newInstance(implClass,
new Class[] { ApacheFactoryContext.class },
new Object[] { factoryContext });
}
} catch (ClassNotFoundException e) {
}
}
}
protected void validateBeanNet(GroupValidationContext<?> context) {
if (context.getBean() == null) {
return;
}
if (!context.collectValidated()) {
return;
}
if (context.getCurrentGroup().isDefault()) {
List<Group> defaultGroups = expandDefaultGroup(context);
final ConstraintValidationListener<?> result =
(ConstraintValidationListener<?>) context.getListener();
if (defaultGroups.size() > 1) {
int numViolations = result.violationsSize();
Group currentGroup = context.getCurrentGroup();
for (Group each : defaultGroups) {
context.setCurrentGroup(each);
ValidationHelper.validateBean(context);
if (result.violationsSize() > numViolations) {
break;
}
}
context.setCurrentGroup(currentGroup);
} else {
List<Class<?>> classHierarchy = new ArrayList<Class<?>>();
ClassHelper.fillFullClassHierarchyAsList(classHierarchy,
context.getMetaBean().getBeanClass());
Class<?> initialOwner = context.getCurrentOwner();
for (Class<?> owner : classHierarchy) {
context.setCurrentOwner(owner);
int numViolations = result.violationsSize();
List<Group> ownerDefaultGroups =
context.getMetaBean().getFeature(
for (Group each : ownerDefaultGroups) {
context.setCurrentGroup(each);
ValidationHelper.validateBean(context);
if (result.violationsSize() > numViolations) {
break;
}
}
}
context.setCurrentOwner(initialOwner);
context.setCurrentGroup(Group.DEFAULT);
}
else {
ValidationHelper.validateBean(context);
for (MetaProperty prop : context.getMetaBean().getProperties()) {
validateCascadedBean(context, prop);
}
private void validateCascadedBean(GroupValidationContext<?> context,
MetaProperty prop) {
AccessStrategy[] access =
prop.getFeature(Features.Property.REF_CASCADE);
final Object bean = context.getBean();
final MetaBean mbean = context.getMetaBean();
for (AccessStrategy each : access) {
if (isCascadable(context, prop, each)) {
context.moveDown(prop, each);
ValidationHelper.validateContext(context,
new Jsr303ValidationCallback(context),
treatMapsLikeBeans);
context.moveUp(bean, mbean);
}
}
}
private boolean isCascadable(GroupValidationContext<?> context,
MetaProperty prop, AccessStrategy access) {
PathImpl beanPath = context.getPropertyPath();
NodeImpl node = new NodeImpl(prop.getName());
if (beanPath == null) {
beanPath = PathImpl.create(null);
}
try {
if (!context.getTraversableResolver().isReachable(
context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath,
access.getElementType()))
return false;
} catch (RuntimeException e) {
throw new ValidationException(
"Error in TraversableResolver.isReachable() for "
context.getBean(), e);
}
try {
if (!context.getTraversableResolver().isCascadable(
context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath,
access.getElementType()))
return false;
} catch (RuntimeException e) {
throw new ValidationException(
"Error TraversableResolver.isCascadable() for "
context.getBean(), e);
}
return true;
private List<Group> expandDefaultGroup(GroupValidationContext<?> context) {
if (context.getCurrentGroup().isDefault()) {
List<Group> groupSeq =
context.getMetaBean().getFeature(
Jsr303Features.Bean.GROUP_SEQUENCE);
if (groupSeq != null) {
context.getGroups().assertDefaultGroupSequenceIsExpandable(
groupSeq);
}
return groupSeq;
} else {
return null;
}
protected static RuntimeException unrecoverableValidationError(
RuntimeException ex, Object object) {
if (ex instanceof UnknownPropertyException) {
return new IllegalArgumentException(ex.getMessage(), ex);
} else if (ex instanceof ValidationException) {
} else {
return new ValidationException("error during validation of "
object, ex);
}
}
private void validatePropertyInGroup(GroupValidationContext<?> context) {
Group currentGroup = context.getCurrentGroup();
List<Group> defaultGroups = expandDefaultGroup(context);
if (defaultGroups != null) {
for (Group each : defaultGroups) {
context.setCurrentGroup(each);
ValidationHelper.validateProperty(context);
}
} else {
ValidationHelper.validateProperty(context);
}
}
private NestedMetaProperty getNestedProperty(MetaBean metaBean, Object t,
String propertyName) {
NestedMetaProperty nested = new NestedMetaProperty(propertyName, t);
nested.setMetaBean(metaBean);
nested.parse();
return nested;
}
protected <T> GroupValidationContext<T> createContext(MetaBean metaBean,
T object, Class<T> objectClass, Class<?>[] groups) {
ConstraintValidationListener<T> listener =
new ConstraintValidationListener<T>(object, objectClass);
GroupValidationContextImpl<T> context =
new GroupValidationContextImpl<T>(listener, this.factoryContext
.getMessageInterpolator(), this.factoryContext
.getTraversableResolver(), metaBean);
context.setBean(object, metaBean);
context.setGroups(groupsComputer.computeGroups(groups));
return context;
}
protected BeanDescriptorImpl createBeanDescriptor(MetaBean metaBean) {
return new BeanDescriptorImpl(factoryContext, metaBean, metaBean
.getValidations());
}
private boolean treatMapsLikeBeans = false;
public boolean isTreatMapsLikeBeans() {
return treatMapsLikeBeans;
}
public void setTreatMapsLikeBeans(boolean treatMapsLikeBeans) {
this.treatMapsLikeBeans = treatMapsLikeBeans;
}
private void checkBeanType(Class<?> beanType) {
if (beanType == null) {
throw new IllegalArgumentException("Bean type cannot be null.");
}
}
private void checkPropertyName(String propertyName) {
if (propertyName == null || propertyName.trim().length() == 0) {
throw new IllegalArgumentException(
"Property path cannot be null or empty.");
}
}
private void checkGroups(Class<?>[] groups) {
if (groups == null) {
throw new IllegalArgumentException("Groups cannot be null.");
}
}
protected class Jsr303ValidationCallback implements
ValidationHelper.ValidateCallback {
private final GroupValidationContext<?> context;
public Jsr303ValidationCallback(GroupValidationContext<?> context) {
this.context = context;
}
public void validate() {
validateBeanNet(context);
}
}
import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;
import javax.validation.Validation;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import javax.validation.bootstrap.ProviderSpecificBootstrap;
import javax.validation.spi.ConfigurationState;
private static final ConstraintDefaults defaultConstraints =
new ConstraintDefaults();
Validation.byProvider(ApacheValidationProvider.class);
DEFAULT_FACTORY =
(ApacheValidatorFactory) configuration.buildValidatorFactory();
DEFAULT_FACTORY = aDefaultFactory;
public ApacheValidatorFactory() {
constraintMap =
new HashMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>>();
setConstraintValidatorFactory(configuration
.getConstraintValidatorFactory());
return ((messageResolver != null) ? messageResolver
: getDefaultMessageInterpolator());
public final void setTraversableResolver(
TraversableResolver traversableResolver) {
ConstraintValidatorFactory constraintValidatorFactory) {
} else if (!(type.isInterface() || Modifier.isAbstract(type
.getModifiers()))) {
final Class<? extends T> implClass =
(Class<? extends T>) cls;
public void addMetaConstraint(Class<?> beanClass,
MetaConstraint<?, ?> metaConstraint) {
List<MetaConstraint<?, ? extends Annotation>> slot =
constraintMap.get(beanClass);
new ArrayList<MetaConstraint<?, ? extends Annotation>>();
Class<T> beanClass) {
List<MetaConstraint<?, ? extends Annotation>> slot =
constraintMap.get(beanClass);
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.PropertyAccess;
import org.apache.bval.util.ValidationHelper;
if (clazz == null || clazz == Object.class) {
if (allClasses.contains(clazz)) {
List<Class<?>> subClasses = new ArrayList<Class<?>>(Arrays.asList(clazz.getInterfaces()));
for (Class<?> subClass : subClasses) {
}
private final MetaBeanFinder metaBeanFinder;
public BeanValidator() {
this(MetaBeanManagerFactory.getFinder());
public BeanValidator(MetaBeanFinder metaBeanFinder) {
this.metaBeanFinder = metaBeanFinder;
public T validate(Object bean) {
MetaBean metaBean = getMetaBeanFinder().findForClass(bean.getClass());
return validate(bean, metaBean);
public T validate(Object bean, MetaBean metaBean) {
ValidationContext<T> context = createContext();
context.setBean(bean, metaBean);
return context.getListener();
public T validateCall(Method method, Object[] parameters) {
if (parameters.length > 0) {
Annotation[][] annotations = method.getParameterAnnotations();
ValidationContext<T> context = null;
for (Annotation anno : annotations[i]) {
if (anno instanceof Validate) {
if (context == null)
context = createContext();
if (determineMetaBean((Validate) anno, parameters[i], context)) {
ValidationHelper.validateContext(context, new BeanValidatorCallback(context),
treatMapsLikeBeans);
}
}
}
}
return context != null ? context.getListener() : null;
}
return null;
protected <VL extends ValidationListener> boolean determineMetaBean(Validate validate, Object parameter,
ValidationContext<VL> context) {
if (validate.value().length() == 0) {
if (parameter == null)
return false;
Class<?> beanClass;
Collection<?> coll = ((Collection<?>) parameter);
if (coll.isEmpty())
return false;
} else if (parameter.getClass().isArray()) {
beanClass = parameter.getClass().getComponentType();
} else {
beanClass = parameter.getClass();
}
context.setBean(parameter, getMetaBeanFinder().findForClass(beanClass));
} else {
context.setBean(parameter, getMetaBeanFinder().findForId(validate.value()));
}
return true;
}
@SuppressWarnings("unchecked")
protected T createResults() {
return (T) new ValidationResults();
}
protected ValidationContext<T> createContext() {
return new BeanValidationContext<T>(createResults());
}
public T validateProperty(Object bean, MetaProperty metaProperty) {
ValidationContext<T> context = createContext();
context.setBean(bean);
context.setMetaProperty(metaProperty);
ValidationHelper.validateProperty(context);
return context.getListener();
}
protected <VL extends ValidationListener> void validateBeanNet(ValidationContext<VL> context) {
if (context.collectValidated()) {
ValidationHelper.validateBean(context);
for (MetaProperty prop : context.getMetaBean().getProperties()) {
validateRelatedBean(context, prop);
}
}
}
protected <VL extends ValidationListener> void validateRelatedBean(ValidationContext<VL> context, MetaProperty prop) {
AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
final Object bean = context.getBean();
final MetaBean mbean = context.getMetaBean();
context.moveDown(prop, new PropertyAccess(bean.getClass(), prop.getName()));
ValidationHelper.validateContext(context, new BeanValidatorCallback(context), treatMapsLikeBeans);
context.moveUp(bean, mbean);
final Object bean = context.getBean();
final MetaBean mbean = context.getMetaBean();
for (AccessStrategy each : access) {
context.moveDown(prop, each);
ValidationHelper.validateContext(context, new BeanValidatorCallback(context), treatMapsLikeBeans);
context.moveUp(bean, mbean);
}
}
}
private boolean treatMapsLikeBeans = false;
public boolean isTreatMapsLikeBeans() {
return treatMapsLikeBeans;
}
public void setTreatMapsLikeBeans(boolean treatMapsLikeBeans) {
this.treatMapsLikeBeans = treatMapsLikeBeans;
}
public MetaBeanFinder getMetaBeanFinder() {
return metaBeanFinder;
}
private class BeanValidatorCallback implements ValidationHelper.ValidateCallback {
private final ValidationContext<?> context;
public BeanValidatorCallback(ValidationContext<?> context) {
this.context = context;
}
public void validate() {
validateBeanNet(context);
}
}
private static final Log log = LogFactory.getLog(MetaBeanBuilder.class);
private MetaBeanFactory[] factories;
public MetaBeanBuilder() {
this(new MetaBeanFactory[] { new IntrospectorMetaBeanFactory() });
public MetaBeanBuilder(MetaBeanFactory[] factories) {
setFactories(factories);
public MetaBeanFactory[] getFactories() {
return factories;
public void setFactories(MetaBeanFactory[] factories) {
this.factories = factories;
}
public MetaBean buildForId(String beanInfoId) throws Exception {
}
public Map<String, MetaBean> buildAll() throws Exception {
return new HashMap<String, MetaBean>();
}
protected Class<?> findLocalClass(String className) {
if (className != null) {
try {
return ClassUtils.getClass(className);
} catch (ClassNotFoundException e) {
}
}
return null;
}
public MetaBean buildForClass(Class<?> clazz) throws Exception {
MetaBean meta = new MetaBean();
meta.setBeanClass(clazz);
}
for (MetaBeanFactory factory : factories) {
factory.buildMetaBean(meta);
}
return meta;
}
protected final MetaBeanCache cache = new MetaBeanCache();
protected final MetaBeanBuilder builder;
protected boolean complete = false;
public MetaBeanManager() {
builder = new MetaBeanBuilder();
public MetaBeanManager(MetaBeanBuilder builder) {
this.builder = builder;
public MetaBeanBuilder getBuilder() {
return builder;
public MetaBeanCache getCache() {
return cache;
public MetaBean findForId(String beanInfoId) {
MetaBean beanInfo = cache.findForId(beanInfoId);
if (beanInfo != null)
return beanInfo;
try {
beanInfo = builder.buildForId(beanInfoId);
cache.cache(beanInfo);
computeRelationships(beanInfo);
return beanInfo;
} catch (RuntimeException e) {
} catch (Exception e) {
}
}
public MetaBean findForClass(Class<?> clazz) {
if (clazz == null)
return null;
MetaBean beanInfo = cache.findForClass(clazz);
if (beanInfo != null)
return beanInfo;
try {
beanInfo = builder.buildForClass(clazz);
cache.cache(beanInfo);
computeRelationships(beanInfo);
return beanInfo;
} catch (RuntimeException e) {
} catch (Exception e) {
}
}
protected void computeRelationships(MetaBean beanInfo) {
for (MetaProperty prop : beanInfo.getProperties()) {
String beanRef = (String) prop.getFeature(REF_BEAN_ID);
computeRelatedMetaBean(prop, beanRef);
}
}
protected void computeRelatedMetaBean(MetaProperty prop, String beanRef) {
Class<?> beanType = prop.getFeature(REF_BEAN_TYPE);
if (beanType != null) {
prop.setMetaBean(findForClass(beanType));
prop.setMetaBean(new DynamicMetaBean(this));
}
}
private static String ATOM = "[^\\x00-\\x1F^\\(^\\)^\\<^\\>^\\@^\\,^\\;^\\:^\\\\^\\\"^\\.^\\[^\\]^\\s]";
private static String IP_DOMAIN = "\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\]";
public static final java.util.regex.Pattern DEFAULT_EMAIL_PATTERN;
static {
DEFAULT_EMAIL_PATTERN =
java.util.regex.Pattern.CASE_INSENSITIVE);
}
public static boolean isValid(Object value) {
return isValid(value, DEFAULT_EMAIL_PATTERN);
}
public static boolean isValid(Object value, Pattern aPattern) {
if (value == null)
return true;
if (!(value instanceof CharSequence))
return false;
CharSequence seq = (CharSequence) value;
if (seq.length() == 0)
return true;
Matcher m = aPattern.matcher(seq);
return m.matches();
}
private final Class<?> beanClass;
private final String propertyName;
private Field rememberField;
public PropertyAccess(Class<?> clazz, String propertyName) {
this.beanClass = clazz;
this.propertyName = propertyName;
public ElementType getElementType() {
return (rememberField != null) ? ElementType.FIELD : ElementType.METHOD;
private static Object getPublicProperty(Object bean, String property) throws InvocationTargetException,
NoSuchMethodException, IllegalAccessException {
if (bean instanceof Map<?, ?>) {
return ((Map<?, ?>) bean).get(property);
return PropertyUtils.getSimpleProperty(bean, property);
public static Object getProperty(Object bean, String propertyName) throws InvocationTargetException,
NoSuchMethodException, IllegalAccessException {
return new PropertyAccess(bean.getClass(), propertyName).get(bean);
public String toString() {
}
public Type getJavaType() {
return rememberField.getGenericType();
for (PropertyDescriptor each : PropertyUtils.getPropertyDescriptors(beanClass)) {
if (each.getName().equals(propertyName) && each.getReadMethod() != null) {
return each.getReadMethod().getGenericReturnType();
}
}
return beanClass.getField(propertyName).getGenericType();
} catch (NoSuchFieldException ex2) {
Class<?> theClass = beanClass;
while (theClass != null) {
try {
return theClass.getDeclaredField(propertyName).getGenericType();
} catch (NoSuchFieldException ex3) {
}
theClass = theClass.getSuperclass();
}
}
public String getPropertyName() {
return propertyName;
}
public Object get(Object bean) {
try {
return rememberField.get(bean);
}
return getPublicProperty(bean, propertyName);
} catch (NoSuchMethodException ex) {
return getFieldValue(bean);
}
} catch (IllegalArgumentException e) {
throw e;
} catch (Exception e) {
}
}
private Object getFieldValue(Object bean) throws IllegalAccessException {
Object value;
Field aField = bean.getClass().getField(propertyName);
value = aField.get(bean);
rememberField = aField;
return value;
} catch (NoSuchFieldException ex2) {
Class<?> theClass = bean.getClass();
while (theClass != null) {
try {
Field aField = theClass.getDeclaredField(propertyName);
if (!aField.isAccessible()) {
aField.setAccessible(true);
}
value = aField.get(bean);
rememberField = aField;
return value;
} catch (NoSuchFieldException ex3) {
}
theClass = theClass.getSuperclass();
}
}
}
public boolean equals(Object o) {
if (this == o)
return true;
if (o == null || getClass() != o.getClass())
return false;
PropertyAccess that = (PropertyAccess) o;
return beanClass.equals(that.beanClass) && propertyName.equals(that.propertyName);
}
public int hashCode() {
int result;
result = beanClass.hashCode();
return result;
}
VALUE1, VALUE2, VALUE3
private final ApacheValidatorFactory factory;
private final MetaBeanFinder metaBeanFinder;
private MessageInterpolator messageInterpolator;
private TraversableResolver traversableResolver;
private ConstraintValidatorFactory constraintValidatorFactory;
public ApacheFactoryContext(ApacheValidatorFactory factory) {
this.factory = factory;
this.metaBeanFinder = buildMetaBeanManager();
}
protected ApacheFactoryContext(ApacheValidatorFactory factory, MetaBeanFinder metaBeanFinder) {
this.factory = factory;
this.metaBeanFinder = metaBeanFinder;
}
public ApacheValidatorFactory getFactory() {
return factory;
}
public final MetaBeanFinder getMetaBeanFinder() {
return metaBeanFinder;
}
public ValidatorContext messageInterpolator(MessageInterpolator messageInterpolator) {
this.messageInterpolator = messageInterpolator;
return this;
}
public ValidatorContext traversableResolver(TraversableResolver traversableResolver) {
this.traversableResolver = traversableResolver;
return this;
}
public ValidatorContext constraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory) {
this.constraintValidatorFactory = constraintValidatorFactory;
return this;
}
public ConstraintValidatorFactory getConstraintValidatorFactory() {
return constraintValidatorFactory == null ? factory.getConstraintValidatorFactory()
: constraintValidatorFactory;
}
public Validator getValidator() {
ClassValidator validator = new ClassValidator(this);
if (Boolean.getBoolean(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.TREAT_MAPS_LIKE_BEANS))) {
validator.setTreatMapsLikeBeans(true);
}
return validator;
}
public MessageInterpolator getMessageInterpolator() {
return messageInterpolator == null ? factory.getMessageInterpolator() : messageInterpolator;
}
public TraversableResolver getTraversableResolver() {
return traversableResolver == null ? factory.getTraversableResolver() : traversableResolver;
}
@SuppressWarnings("deprecation")
protected MetaBeanManager buildMetaBeanManager() {
List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>(3);
if (Boolean.parseBoolean(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.ENABLE_INTROSPECTOR))) {
builders.add(new IntrospectorMetaBeanFactory());
}
builders.add(new Jsr303MetaBeanFactory(this));
if (Boolean.parseBoolean(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML))) {
return XMLMetaBeanManagerCreator.createXMLMetaBeanManager(builders);
} else {
return createMetaBeanManager(builders);
}
}
protected MetaBeanManager createMetaBeanManager(List<MetaBeanFactory> builders) {
return new MetaBeanManager(new MetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
private static class XMLMetaBeanManagerCreator {
protected static MetaBeanManager createXMLMetaBeanManager(List<MetaBeanFactory> builders) {
builders.add(new XMLMetaBeanFactory());
return new XMLMetaBeanManager(
new XMLMetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
}
}
private static final long serialVersionUID = 1L;
private final T annotation;
private final Set<Class<?>> groups;
private final Set<Class<? extends javax.validation.Payload>> payload;
private final List<java.lang.Class<? extends javax.validation.ConstraintValidator<T, ?>>> constraintValidatorClasses;
private final Map<String, Object> attributes;
private final Set<ConstraintDescriptor<?>> composingConstraints;
private final boolean reportAsSingleViolation;
public ConstraintDescriptorImpl(ConstraintDescriptor<T> descriptor) {
this(descriptor.getAnnotation(), descriptor.getGroups(), descriptor.getPayload(), descriptor
.getConstraintValidatorClasses(), descriptor.getAttributes(), descriptor.getComposingConstraints(),
descriptor.isReportAsSingleViolation());
}
public ConstraintDescriptorImpl(T annotation, Set<Class<?>> groups,
Set<Class<? extends javax.validation.Payload>> payload,
List<java.lang.Class<? extends javax.validation.ConstraintValidator<T, ?>>> constraintValidatorClasses,
Map<String, Object> attributes, Set<ConstraintDescriptor<?>> composingConstraints,
boolean reportAsSingleViolation) {
this.annotation = annotation;
this.groups = groups;
this.payload = payload;
this.constraintValidatorClasses = constraintValidatorClasses;
this.attributes = attributes;
this.composingConstraints = composingConstraints;
this.reportAsSingleViolation = reportAsSingleViolation;
}
public T getAnnotation() {
return annotation;
}
public Set<Class<?>> getGroups() {
return groups;
}
public Set<Class<? extends Payload>> getPayload() {
return payload;
}
public List<java.lang.Class<? extends javax.validation.ConstraintValidator<T, ?>>> getConstraintValidatorClasses() {
return constraintValidatorClasses;
}
public Map<String, Object> getAttributes() {
return attributes;
}
public Set<ConstraintDescriptor<?>> getComposingConstraints() {
return composingConstraints;
}
public boolean isReportAsSingleViolation() {
return reportAsSingleViolation;
}
public class ConstraintValidation<T extends Annotation> implements Validation, ConstraintDescriptor<T> {
private static final String ANNOTATION_MESSAGE = "message";
private final ConstraintValidator<T, ?> validator;
private final AccessStrategy access;
private final boolean reportFromComposite;
private final Map<String, Object> attributes;
private Set<ConstraintValidation<?>> composedConstraints;
private final Class<?> owner;
private Set<Class<?>> groups;
private Set<Class<? extends Payload>> payload;
private Class<? extends ConstraintValidator<T, ?>>[] validatorClasses;
public ConstraintValidation(Class<? extends ConstraintValidator<T, ?>>[] validatorClasses,
ConstraintValidator<T, ?> validator, T annotation, Class<?> owner, AccessStrategy access,
boolean reportFromComposite) {
this.attributes = new HashMap<String, Object>();
this.validatorClasses = validatorClasses;
this.validator = validator;
this.annotation = annotation;
this.owner = owner;
this.access = access;
this.reportFromComposite = reportFromComposite;
public ConstraintDescriptor<T> asSerializableDescriptor() {
return new ConstraintDescriptorImpl<T>(this);
void setGroups(Set<Class<?>> groups) {
this.groups = groups;
this.attributes.put("groups", groups.toArray(new Class[groups.size()]));
void setPayload(Set<Class<? extends Payload>> payload) {
this.payload = payload;
this.attributes.put("payload", payload.toArray(new Class[payload.size()]));
public boolean isReportAsSingleViolation() {
return reportFromComposite;
public void addComposed(ConstraintValidation<?> aConstraintValidation) {
if (composedConstraints == null) {
composedConstraints = new HashSet<ConstraintValidation<?>>();
}
composedConstraints.add(aConstraintValidation);
}
public <L extends ValidationListener> void validate(ValidationContext<L> context) {
validate((GroupValidationContext<?>) context);
}
public void validate(GroupValidationContext<?> context) {
context.setConstraintValidation(this);
if (!isMemberOf(context.getCurrentGroup().getGroup())) {
}
if (context.getCurrentOwner() != null && this.owner != context.getCurrentOwner()) {
return;
}
if (validator != null && !context.collectValidated(validator))
if (context.getMetaProperty() != null && !isReachable(context)) {
return;
}
if (isReportAsSingleViolation()) {
ConstraintValidationListener<?> listener = context.getListener();
listener.beginReportAsSingle();
boolean failed = false;
try {
for (Iterator<ConstraintValidation<?>> composed = getComposingValidations().iterator(); !failed
&& composed.hasNext();) {
composed.next().validate(context);
failed = listener.hasViolations();
}
} finally {
listener.endReportAsSingle();
context.setConstraintValidation(this);
}
if (failed) {
ConstraintValidatorContextImpl jsrContext = new ConstraintValidatorContextImpl(context, this);
return;
}
} else {
for (ConstraintValidation<?> composed : getComposingValidations()) {
composed.validate(context);
}
context.setConstraintValidation(this);
}
if (validator != null) {
ConstraintValidatorContextImpl jsrContext = new ConstraintValidatorContextImpl(context, this);
@SuppressWarnings("unchecked")
final ConstraintValidator<T, Object> objectValidator = (ConstraintValidator<T, Object>) validator;
if (!objectValidator.isValid(context.getValidatedValue(), jsrContext)) {
addErrors(context, jsrContext);
}
}
}
public void initialize() {
if (null != validator) {
try {
validator.initialize(annotation);
} catch (RuntimeException e) {
throw new ConstraintDefinitionException("Incorrect validator ["
annotation.annotationType().getCanonicalName(), e);
}
}
}
private boolean isReachable(GroupValidationContext<?> context) {
PathImpl path = context.getPropertyPath();
NodeImpl node = path.getLeafNode();
PathImpl beanPath = path.getPathWithoutLeafNode();
if (beanPath == null) {
beanPath = PathImpl.create(null);
}
try {
if (!context.getTraversableResolver().isReachable(context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath, access.getElementType()))
return false;
} catch (RuntimeException e) {
}
return true;
}
private void addErrors(GroupValidationContext<?> context, ConstraintValidatorContextImpl jsrContext) {
for (ValidationListener.Error each : jsrContext.getErrorMessages()) {
context.getListener().addError(each, context);
}
}
public String toString() {
}
public String getMessageTemplate() {
return (String) attributes.get(ANNOTATION_MESSAGE);
}
public ConstraintValidator<T, ?> getValidator() {
return validator;
}
protected boolean isMemberOf(Class<?> reqGroup) {
return groups.contains(reqGroup);
}
public Class<?> getOwner() {
return owner;
}
public T getAnnotation() {
return annotation;
}
public AccessStrategy getAccess() {
return access;
}
public void setAnnotation(T annotation) {
this.annotation = annotation;
}
public Map<String, Object> getAttributes() {
return attributes;
}
@SuppressWarnings("unchecked")
public Set<ConstraintDescriptor<?>> getComposingConstraints() {
return composedConstraints == null ? Collections.EMPTY_SET : composedConstraints;
}
@SuppressWarnings("unchecked")
Set<ConstraintValidation<?>> getComposingValidations() {
return composedConstraints == null ? Collections.EMPTY_SET : composedConstraints;
}
public Set<Class<?>> getGroups() {
return groups;
}
public Set<Class<? extends Payload>> getPayload() {
return payload;
}
public List<Class<? extends ConstraintValidator<T, ?>>> getConstraintValidatorClasses() {
if (validatorClasses == null) {
return Collections.emptyList();
}
return Arrays.asList(validatorClasses);
}
public MethodValidatorImpl(ApacheFactoryContext factoryContext) {
super(factoryContext);
patchFactoryContextForMethodValidation(factoryContext);
private void patchFactoryContextForMethodValidation(ApacheFactoryContext factoryContext) {
MetaBeanFactory[] factories = ((MetaBeanManager) getMetaBeanFinder()).getBuilder().getFactories();
if (factories[i] instanceof Jsr303MetaBeanFactory
&& !(factories[i] instanceof MethodValidatorMetaBeanFactory)) {
factories[i] = new MethodValidatorMetaBeanFactory(factoryContext);
}
}
@Override
protected BeanDescriptorImpl createBeanDescriptor(MetaBean metaBean) {
MethodBeanDescriptorImpl descriptor =
new MethodBeanDescriptorImpl(factoryContext, metaBean, metaBean.getValidations());
MethodValidatorMetaBeanFactory factory = new MethodValidatorMetaBeanFactory(factoryContext);
factory.buildMethodDescriptor(descriptor);
return descriptor;
}
public <T> Set<ConstraintViolation<T>> validateParameters(Class<T> clazz, Method method, Object[] parameters,
Class<?>... groupArray) {
MethodBeanDescriptorImpl beanDesc = (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
MethodDescriptorImpl methodDescriptor = (MethodDescriptorImpl) beanDesc.getConstraintsForMethod(method);
if (methodDescriptor == null) {
}
return validateParameters(methodDescriptor.getMetaBean(), methodDescriptor.getParameterDescriptors(),
parameters, groupArray);
}
public <T> Set<ConstraintViolation<T>> validateParameter(Class<T> clazz, Method method, Object parameter,
int parameterIndex, Class<?>... groupArray) {
MethodBeanDescriptorImpl beanDesc = (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
MethodDescriptorImpl methodDescriptor = (MethodDescriptorImpl) beanDesc.getConstraintsForMethod(method);
if (methodDescriptor == null) {
}
ParameterDescriptorImpl paramDesc =
(ParameterDescriptorImpl) methodDescriptor.getParameterDescriptors().get(parameterIndex);
return validateParameter(paramDesc, parameter, groupArray);
}
public <T> Set<ConstraintViolation<T>> validateParameters(Class<T> clazz, Constructor<T> constructor,
Object[] parameters, Class<?>... groupArray) {
MethodBeanDescriptorImpl beanDesc = (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
ConstructorDescriptorImpl constructorDescriptor =
(ConstructorDescriptorImpl) beanDesc.getConstraintsForConstructor(constructor);
if (constructorDescriptor == null) {
}
return validateParameters(constructorDescriptor.getMetaBean(), constructorDescriptor.getParameterDescriptors(),
parameters, groupArray);
}
public <T> Set<ConstraintViolation<T>> validateParameter(Class<T> clazz, Constructor<T> constructor,
Object parameter, int parameterIndex, Class<?>... groupArray) {
MethodBeanDescriptorImpl beanDesc = (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
ConstructorDescriptorImpl constructorDescriptor =
(ConstructorDescriptorImpl) beanDesc.getConstraintsForConstructor(constructor);
if (constructorDescriptor == null) {
}
ParameterDescriptorImpl paramDesc =
(ParameterDescriptorImpl) constructorDescriptor.getParameterDescriptors().get(parameterIndex);
return validateParameter(paramDesc, parameter, groupArray);
}
@SuppressWarnings("unchecked")
public <T> Set<ConstraintViolation<T>> validateReturnedValue(Class<T> clazz, Method method, Object returnedValue,
Class<?>... groupArray) {
MethodBeanDescriptorImpl beanDesc = (MethodBeanDescriptorImpl) getConstraintsForClass(clazz);
MethodDescriptorImpl methodDescriptor = (MethodDescriptorImpl) beanDesc.getConstraintsForMethod(method);
if (methodDescriptor == null) {
}
final GroupValidationContext<Object> context =
createContext(methodDescriptor.getMetaBean(), returnedValue, null, groupArray);
validateReturnedValueInContext(context, methodDescriptor);
@SuppressWarnings("unchecked")
private <T> Set<ConstraintViolation<T>> validateParameters(MetaBean metaBean,
List<ParameterDescriptor> paramDescriptors, Object[] parameters, Class<?>... groupArray) {
if (parameters == null)
throw new IllegalArgumentException("cannot validate null");
if (parameters.length > 0) {
try {
GroupValidationContext<ConstraintValidationListener<Object[]>> context =
createContext(metaBean, null, null, groupArray);
ParameterDescriptorImpl paramDesc = (ParameterDescriptorImpl) paramDescriptors.get(i);
context.setBean(parameters[i]);
validateParameterInContext(context, paramDesc);
}
ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
return result.getConstraintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, parameters);
}
} else {
return Collections.<ConstraintViolation<T>> emptySet();
@SuppressWarnings("unchecked")
private <T> Set<ConstraintViolation<T>> validateParameter(ParameterDescriptorImpl paramDesc, Object parameter,
Class<?>... groupArray) {
try {
final GroupValidationContext<Object> context =
createContext(paramDesc.getMetaBean(), parameter, null, groupArray);
final ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
validateParameterInContext(context, paramDesc);
return result.getConstraintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, parameter);
private <T> void validateParameterInContext(GroupValidationContext<T> context, ParameterDescriptorImpl paramDesc) {
final Groups groups = context.getGroups();
for (ConstraintDescriptor<?> consDesc : paramDesc.getConstraintDescriptors()) {
ConstraintValidation<?> validation = (ConstraintValidation<?>) consDesc;
for (Group current : groups.getGroups()) {
context.setCurrentGroup(current);
validation.validate(context);
}
for (List<Group> eachSeq : groups.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validation.validate(context);
if (!context.getListener().isEmpty())
break;
}
}
if (paramDesc.isCascaded() && context.getValidatedValue() != null) {
context
.setMetaBean(factoryContext.getMetaBeanFinder().findForClass(context.getValidatedValue().getClass()));
for (Group current : groups.getGroups()) {
context.setCurrentGroup(current);
ValidationHelper
.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
}
for (List<Group> eachSeq : groups.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context),
isTreatMapsLikeBeans());
if (!context.getListener().isEmpty())
break;
}
}
}
private <T> void validateReturnedValueInContext(GroupValidationContext<T> context,
MethodDescriptorImpl methodDescriptor) {
final Groups groups = context.getGroups();
for (ConstraintDescriptor<?> consDesc : methodDescriptor.getConstraintDescriptors()) {
ConstraintValidation<?> validation = (ConstraintValidation<?>) consDesc;
for (Group current : groups.getGroups()) {
context.setCurrentGroup(current);
validation.validate(context);
}
for (List<Group> eachSeq : groups.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
validation.validate(context);
if (!context.getListener().isEmpty())
break;
}
}
}
if (methodDescriptor.isCascaded() && context.getValidatedValue() != null) {
context
.setMetaBean(factoryContext.getMetaBeanFinder().findForClass(context.getValidatedValue().getClass()));
for (Group current : groups.getGroups()) {
context.setCurrentGroup(current);
ValidationHelper
.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
}
for (List<Group> eachSeq : groups.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context),
isTreatMapsLikeBeans());
if (!context.getListener().isEmpty())
break;
}
}
}
}
public MethodValidatorMetaBeanFactory(ApacheFactoryContext factoryContext) {
super(factoryContext);
@Override
protected boolean hasValidationConstraintsDefined(Method method) {
return false;
}
public void buildMethodDescriptor(MethodBeanDescriptorImpl descriptor) {
try {
buildMethodConstraints(descriptor);
buildConstructorConstraints(descriptor);
} catch (Exception e) {
throw new IllegalArgumentException(e.getMessage(), e);
private void buildConstructorConstraints(MethodBeanDescriptorImpl beanDesc) throws InvocationTargetException,
IllegalAccessException {
beanDesc.setConstructorConstraints(new HashMap<Constructor<?>, ConstructorDescriptor>());
for (Constructor<?> cons : beanDesc.getMetaBean().getBeanClass().getDeclaredConstructors()) {
if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(cons)) {
ConstructorDescriptorImpl consDesc =
new ConstructorDescriptorImpl(beanDesc.getMetaBean(), new Validation[0]);
beanDesc.putConstructorDescriptor(cons, consDesc);
Annotation[][] paramsAnnos = cons.getParameterAnnotations();
int idx = 0;
for (Annotation[] paramAnnos : paramsAnnos) {
ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
processAnnotations(consDesc, paramAnnos, access, idx);
}
}
}
}
private void buildMethodConstraints(MethodBeanDescriptorImpl beanDesc) throws InvocationTargetException,
IllegalAccessException {
beanDesc.setMethodConstraints(new HashMap<Method, MethodDescriptor>());
for (Method method : beanDesc.getMetaBean().getBeanClass().getDeclaredMethods()) {
if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(method)) {
MethodDescriptorImpl methodDesc = new MethodDescriptorImpl(beanDesc.getMetaBean(), new Validation[0]);
beanDesc.putMethodDescriptor(method, methodDesc);
AppendValidationToList validations = new AppendValidationToList();
ReturnAccess returnAccess = new ReturnAccess(method.getReturnType());
for (Annotation anno : method.getAnnotations()) {
if (anno instanceof Valid) {
methodDesc.setCascaded(true);
} else {
processAnnotation(anno, methodDesc, returnAccess, validations);
}
}
methodDesc.getConstraintDescriptors().addAll(validations.getValidations());
Annotation[][] paramsAnnos = method.getParameterAnnotations();
int idx = 0;
for (Annotation[] paramAnnos : paramsAnnos) {
ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
processAnnotations(methodDesc, paramAnnos, access, idx);
}
}
}
}
private void processAnnotations(ProcedureDescriptor methodDesc, Annotation[] paramAnnos, AccessStrategy access,
int idx) throws InvocationTargetException, IllegalAccessException {
boolean cascaded = false;
for (Annotation anno : paramAnnos) {
if (anno instanceof Valid) {
cascaded = true;
} else {
processAnnotation(anno, methodDesc, access, validations);
}
ParameterDescriptorImpl paramDesc =
new ParameterDescriptorImpl(methodDesc.getMetaBean(), validations.getValidations().toArray(
new Validation[validations.getValidations().size()]));
paramDesc.setIndex(idx);
paramDesc.setCascaded(cascaded);
methodDesc.getParameterDescriptors().add(paramDesc);
}
private <A extends Annotation> void processAnnotation(A annotation, ProcedureDescriptor desc,
AccessStrategy access, AppendValidation validations) throws InvocationTargetException, IllegalAccessException {
if (annotation instanceof Valid) {
desc.setCascaded(true);
} else {
Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
if (vcAnno != null) {
Class<? extends ConstraintValidator<A, ?>>[] validatorClasses;
validatorClasses = findConstraintValidatorClasses(annotation, vcAnno);
applyConstraint(annotation, validatorClasses, null, ClassUtils.primitiveToWrapper((Class<?>) access
.getJavaType()), access, validations);
} else {
Object result = SecureActions.getAnnotationValue(annotation, ANNOTATION_VALUE);
if (result != null && result instanceof Annotation[]) {
for (Annotation each : (Annotation[]) result) {
}
}
}
private XMLMetaBeanFactory xmlFactory;
public XMLMetaBeanBuilder(MetaBeanFactory[] factories) {
setFactories(factories);
public XMLMetaBeanBuilder() {
setFactories(new MetaBeanFactory[] { new IntrospectorMetaBeanFactory(), new XMLMetaBeanFactory() });
}
public void setFactories(MetaBeanFactory[] factories) {
super.setFactories(factories);
updateXmlFactory();
}
public void addLoader(XMLMetaBeanLoader loader) {
assertXmlFactory();
xmlFactory.addLoader(loader);
}
public MetaBean buildForId(String beanInfoId) throws Exception {
final XMLMetaBeanFactory.Visitor v;
assertXmlFactory();
xmlFactory.visitXMLBeanMeta(beanInfoId, v = new XMLMetaBeanFactory.Visitor() {
private MetaBean meta;
public MetaBean getMetaBean() {
return meta;
public void visit(XMLMetaBean xmlMeta, XMLMetaBeanInfos xmlInfos) throws Exception {
if (meta == null) {
meta = createMetaBean(xmlMeta);
}
xmlFactory.enrichMetaBean(meta, new XMLMetaBeanFactory.XMLResult(xmlMeta, xmlInfos));
});
if (v.getMetaBean() == null) {
return v.getMetaBean();
public Map<String, MetaBean> buildAll() throws Exception {
final Map<String, MetaBean> all = super.buildAll();
if (xmlFactory != null) {
xmlFactory.visitXMLBeanMeta(null, new XMLMetaBeanFactory.Visitor() {
public void visit(XMLMetaBean empty, XMLMetaBeanInfos xmlInfos) throws Exception {
if (xmlInfos.getBeans() == null)
XMLMetaBeanFactory.XMLResult carrier = new XMLMetaBeanFactory.XMLResult(null, xmlInfos);
for (XMLMetaBean xmlMeta : xmlInfos.getBeans()) {
MetaBean meta = all.get(xmlMeta.getId());
if (meta == null) {
meta = createMetaBean(xmlMeta);
all.put(xmlMeta.getId(), meta);
}
carrier.xmlMeta = xmlMeta;
xmlFactory.enrichMetaBean(meta, carrier);
}
}
public MetaBean getMetaBean() {
}
});
return all;
public Map<String, MetaBean> enrichCopies(Map<String, MetaBean> all, XMLMetaBeanInfos... infosArray)
throws Exception {
assertXmlFactory();
final Map<String, MetaBean> copies = new HashMap<String, MetaBean>(all.size());
boolean nothing = true;
XMLMetaBeanFactory.XMLResult carrier = new XMLMetaBeanFactory.XMLResult();
for (XMLMetaBeanInfos xmlMetaBeanInfos : infosArray) {
carrier.xmlInfos = xmlMetaBeanInfos;
if (xmlMetaBeanInfos == null)
continue;
try {
for (XMLMetaBean xmlMeta : xmlMetaBeanInfos.getBeans()) {
nothing = false;
MetaBean copy = copies.get(xmlMeta.getId());
MetaBean meta = all.get(xmlMeta.getId());
copy = createMetaBean(xmlMeta);
copy = meta.copy();
}
copies.put(xmlMeta.getId(), copy);
}
carrier.xmlMeta = xmlMeta;
xmlFactory.enrichMetaBean(copy, carrier);
}
} catch (IOException e) {
xmlFactory.handleLoadException(xmlMetaBeanInfos, e);
}
}
if (nothing)
return all;
for (Map.Entry<String, MetaBean> entry : all.entrySet()) {
if (!copies.containsKey(entry.getKey())) {
if (entry.getValue().hasRelationships()) {
copies.put(entry.getKey(), (MetaBean) entry.getValue().copy());
copies.put(entry.getKey(), entry.getValue());
}
}
}
return copies;
private MetaBean createMetaBean(XMLMetaBean xmlMeta) throws Exception {
return buildForClass(findLocalClass(xmlMeta.getImpl()));
private void updateXmlFactory() {
for (MetaBeanFactory each : getFactories()) {
xmlFactory = (XMLMetaBeanFactory) each;
return;
}
}
}
public XMLMetaBeanFactory getXmlFactory() {
return xmlFactory;
}
private void assertXmlFactory() {
if (xmlFactory == null) {
throw new IllegalStateException("no xmlFactory available");
}
}
public class XMLMetaBeanManager extends MetaBeanManager implements MetaBeanFinder, XMLMetaBeanRegistry,
MetaBeanEnricher {
public XMLMetaBeanManager() {
this(new XMLMetaBeanBuilder());
public XMLMetaBeanManager(XMLMetaBeanBuilder builder) {
super(builder);
}
public void addResourceLoader(String resource) {
addLoader(new XMLMetaBeanURLLoader(PrivilegedActions.getClassLoader(getClass()).getResource(resource)));
}
public synchronized void addLoader(XMLMetaBeanLoader loader) {
((XMLMetaBeanBuilder) builder).addLoader(loader);
complete = false;
}
public Map<String, MetaBean> enrichCopies(XMLMetaBeanInfos... infos) {
Map<String, MetaBean> cached = findAll();
try {
Map<String, MetaBean> patched = ((XMLMetaBeanBuilder) builder).enrichCopies(cached, infos);
for (Object entry : patched.values()) {
MetaBean meta = (MetaBean) entry;
computeRelationships(meta, patched);
}
return patched;
} catch (RuntimeException e) {
} catch (Exception e) {
throw new IllegalArgumentException("error enriching beanInfos", e);
}
public Map<String, MetaBean> findAll() {
if (!complete) {
try {
Map<String, MetaBean> allBuilt = builder.buildAll();
for (MetaBean meta : allBuilt.values()) {
MetaBean cached = cache.findForId(meta.getId());
if (cached == null) {
cache.cache(meta);
}
}
Map<String, MetaBean> map = cache.findAll();
for (Object oentry : map.values()) {
MetaBean meta = (MetaBean) oentry;
computeRelationships(meta, map);
}
complete = true;
return map;
} catch (RuntimeException e) {
} catch (Exception e) {
throw new IllegalArgumentException("error creating beanInfos", e);
}
} else {
return cache.findAll();
protected void computeRelationships(MetaBean beanInfo, Map<String, MetaBean> cached) {
for (MetaProperty prop : beanInfo.getProperties()) {
String beanRef = (String) prop.getFeature(REF_BEAN_ID);
if (beanRef != null) {
prop.setMetaBean(cached.get(beanRef));
}
}
protected void computeRelatedMetaBean(MetaProperty prop, String beanRef) {
if (beanRef != null) {
prop.setMetaBean(findForId(beanRef));
} else {
super.computeRelatedMetaBean(prop, beanRef);
}
if (Boolean.parseBoolean(factory.getProperties().get(
List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>(2);
import org.apache.bval.jsr303.ApacheValidationProvider;
private final ValidatorFactory validatorFactory;
this.validatorFactory = new ApacheValidationProvider().buildValidatorFactory(configurationState);
import javax.validation.ValidatorFactory;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.commons.lang.ClassUtils;
public class ApacheValidationProvider implements ValidationProvider<ApacheValidatorConfiguration> {
private static final Class<?>[] VALIDATOR_FACTORY_CONSTRUCTOR_ARGS = new Class[] { ConfigurationState.class };
public ValidatorFactory buildValidatorFactory(ConfigurationState configuration) {
String validatorFactoryClassname =
configuration.getProperties().get(ApacheValidatorConfiguration.Properties.VALIDATOR_FACTORY_CLASSNAME);
@SuppressWarnings("unchecked")
final Class<? extends ValidatorFactory> validatorFactoryClass =
validatorFactoryClassname == null ? ApacheValidatorFactory.class
: (Class<? extends ValidatorFactory>) ClassUtils.getClass(validatorFactoryClassname);
return SecureActions.newInstance(validatorFactoryClass, VALIDATOR_FACTORY_CONSTRUCTOR_ARGS,
new Object[] { configuration });
} catch (ValidationException ex) {
throw ex;
} catch (Exception ex) {
import javax.validation.ValidatorFactory;
import javax.validation.spi.ConfigurationState;
String VALIDATOR_FACTORY_CLASSNAME = "apache.bval.validator-factory-classname";
public ApacheValidatorFactory(ConfigurationState configurationState) {
configure(configurationState);
protected void configure(ConfigurationState configuration) {
this.metaBeanFinder = buildMetaBeanFinder();
protected MetaBeanFinder buildMetaBeanFinder() {
Class<? extends ConstraintValidator<? extends Annotation, ?>>[] validatorClasses =
(Class<? extends ConstraintValidator<Annotation, ?>>[]) validatorClasses,
import java.util.Collections;
protected BeanDescriptorImpl(ApacheFactoryContext factoryContext, MetaBean metaBean) {
super(metaBean, metaBean.getBeanClass(), metaBean.getValidations());
if (hasAnyConstraints())
return true;
if (mprop.getMetaBean() != null || mprop.getFeature(Features.Property.REF_CASCADE) != null)
return true;
if (hasConstraints())
return true;
if (getConstraintDescriptors(mprop.getValidations()).size() > 0)
return true;
if (prop == null)
return null;
if (prop.getValidations().length == 0 && prop.getFeature(Features.Property.REF_CASCADE) == null) {
PropertyDescriptorImpl edesc = prop.getFeature(Jsr303Features.Property.PropertyDescriptor);
edesc = new PropertyDescriptorImpl(prop);
if (prop.getValidations().length > 0
|| (prop.getMetaBean() != null || prop.getFeature(Features.Property.REF_CASCADE) != null)) {
return Collections.unmodifiableSet(validatedProperties);
return new BeanDescriptorImpl(factoryContext, metaBean);
import java.util.Collections;
new HashSet<ConstraintValidation<?>>(constraintDescriptors.size());
if (group.isDefault()) {
for (Group defaultGroupMember : expandedDefaultGroup) {
} else {
for (Iterator<ConstraintValidation<?>> it = constraintDescriptors.iterator(); it.hasNext();) {
if (cv.getOwner() != metaBean.getBeanClass()) {
new HashSet<ConstraintValidation<?>>(constraintDescriptors.size());
if (findInScopes.size() == Scope.values().length)
case LOCAL_ELEMENT:
if (owner.equals(metaBean.getBeanClass()))
return true;
break;
case HIERARCHY:
if (!owner.equals(metaBean.getBeanClass()))
return true;
break;
private ElementDescriptor.ConstraintFinder thisWith(Set<ConstraintValidation<?>> matchingDescriptors) {
return constraintDescriptors.isEmpty() ? Collections.<ConstraintDescriptor<?>> emptySet() : Collections
.<ConstraintDescriptor<?>> unmodifiableSet(constraintDescriptors);
import java.util.Collections;
protected static Set<ConstraintDescriptor<?>> getConstraintDescriptors(Validation[] validations) {
final Set<ConstraintDescriptor<?>> result = new HashSet<ConstraintDescriptor<?>>(validations.length);
for (Validation validation : validations) {
if (validation instanceof ConstraintValidation<?>) {
result.add((ConstraintValidation<?>) validation);
}
}
return result;
protected final MetaBean metaBean;
protected final Class<?> elementClass;
private Set<ConstraintDescriptor<?>> constraintDescriptors;
protected ElementDescriptorImpl(MetaBean metaBean, Class<?> elementClass, Validation[] validations) {
this.metaBean = metaBean;
setConstraintDescriptors(getConstraintDescriptors(validations));
}
protected ElementDescriptorImpl(Class<?> elementClass, Validation[] validations) {
this(null, elementClass, validations);
return new ConstraintFinderImpl(metaBean, new HashSet((Set) constraintDescriptors));
return constraintDescriptors.isEmpty() ? Collections.<ConstraintDescriptor<?>> emptySet() : Collections
.unmodifiableSet(constraintDescriptors);
}
protected Set<ConstraintDescriptor<?>> getMutableConstraintDescriptors() {
return !getConstraintDescriptors().isEmpty();
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
PropertyDescriptorImpl(MetaProperty property) {
super(property.getParentMetaBean(), property.getTypeClass(), property.getValidations());
setCascaded(property.getMetaBean() != null || property.getFeature(Features.Property.REF_CASCADE) != null);
setPropertyPath(property.getName());
'}';
class MethodBeanDescriptorImpl extends BeanDescriptorImpl implements MethodBeanDescriptor {
protected MethodBeanDescriptorImpl(ApacheFactoryContext factoryContext, MetaBean metaBean) {
super(factoryContext, metaBean);
public void setConstructorConstraints(Map<Constructor<?>, ConstructorDescriptor> constructorConstraints) {
import java.util.Collection;
import org.apache.bval.jsr303.ConstraintValidation;
public class MethodDescriptorImpl extends ElementDescriptorImpl implements MethodDescriptor, ProcedureDescriptor {
public List<ParameterDescriptor> getParameterDescriptors() {
void addValidations(Collection<ConstraintValidation<?>> validations) {
getMutableConstraintDescriptors().addAll(validations);
}
MethodBeanDescriptorImpl descriptor = new MethodBeanDescriptorImpl(factoryContext, metaBean);
methodDesc.addValidations(validations.getValidations());
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger log = LoggerFactory.getLogger(MetaBeanBuilder.class);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger log = LoggerFactory.getLogger(AnnotationConstraintBuilder.class);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger log = LoggerFactory.getLogger(ConfigurationImpl.class);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger log = LoggerFactory.getLogger(ConstraintDefaults.class);
log.warn("cannot find {}", resource);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger log = LoggerFactory.getLogger(DefaultMessageInterpolator.class);
if (rb != null) {
log.debug("{} found", USER_VALIDATION_MESSAGES);
} else {
log.debug("{} not found. Delegating to {}", USER_VALIDATION_MESSAGES, DEFAULT_VALIDATION_MESSAGES);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
protected static final Logger log = LoggerFactory.getLogger(Jsr303MetaBeanFactory.class);
log.debug("Default group sequence for bean {} is: {}", beanClass.getName(), groupSeq);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger log = LoggerFactory.getLogger(DefaultTraversableResolver.class);
log.debug("Found {} on classpath.", PERSISTENCE_UTIL_CLASSNAME);
log.debug("Cannot find {} on classpath. All properties will per default be traversable.", PERSISTENCE_UTIL_CLASSNAME);
log.debug("Instantiated an instance of {}.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger log = LoggerFactory.getLogger(AnnotationIgnores.class);
log.debug("{} level annotations are getting ignored for {}.{}", new Object[]{type, clazz.getName(), member.getName()});
if (ignoreAnnotation) {
log.debug("Class level annotation are getting ignored for {}", clazz.getName());
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger log = LoggerFactory.getLogger(ValidationParser.class);
log.debug("No {} found. Using annotation based configuration only.", validationXmlFile);
log.debug("{} found.", validationXmlFile);
log.info("Using {} as validation provider.", providerClassName);
log.info("Using {} as message interpolator.", messageInterpolatorClass);
log.info("Using {} as traversable resolver.", traversableResolverClass);
log.info("Using {} as constraint factory.", constraintFactoryClass);
log.debug("Trying to open input stream for {}", mappingFileName);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
private static final Logger log = LoggerFactory.getLogger(XMLMetaBeanFactory.class);
public void setValidations(Validation[] validations) {
this.validations = validations;
}
import org.apache.commons.lang.ObjectUtils;
public final class Group {
if (o instanceof Group == false) return false;
return ObjectUtils.equals(group, ((Group) o).group);
return createMetaBeanManager(builders);
@SuppressWarnings("deprecation")
if (Boolean.parseBoolean(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML))) {
return XMLMetaBeanManagerCreator.createXMLMetaBeanManager(builders);
}
String TREAT_MAPS_LIKE_BEANS = "apache.bval.treat-maps-like-beans";
import org.apache.bval.model.*;
void setParentMetaBean(MetaBean parentMetaBean) {
if (Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD.equals(method.getName())) {
} else if (Jsr303MetaBeanFactory.ANNOTATION_GROUPS.equals(method.getName())) {
apb.putValue(Jsr303MetaBeanFactory.ANNOTATION_GROUPS, inheritedGroups.toArray(new Class[inheritedGroups.size()]));
apb.putValue(Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD, inheritedPayload.toArray(new Class[inheritedPayload.size()]));
this.attributes.put(Jsr303MetaBeanFactory.ANNOTATION_GROUPS, groups.toArray(new Class[groups.size()]));
this.attributes.put(Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD, payload.toArray(new Class[payload.size()]));
return (String) attributes.get(Jsr303MetaBeanFactory.ANNOTATION_MESSAGE);
private int compositeDepth = 0;
if (compositeDepth > 0) {
return compositeDepth == 0 ? !constraintViolations.isEmpty() : hasCompositeError;
return --compositeDepth == 0;
public static final String ANNOTATION_PAYLOAD = "payload";
public static final String ANNOTATION_GROUPS = "groups";
public static final String ANNOTATION_MESSAGE = "message";
import org.apache.bval.jsr303.Jsr303MetaBeanFactory;
Method groupsMethod = SecureActions.getMethod(annotation.annotationType(), Jsr303MetaBeanFactory.ANNOTATION_GROUPS);
Method payloadMethod = SecureActions.getMethod(annotation.annotationType(), Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD);
Method messageMethod = SecureActions.getMethod(annotation.annotationType(), Jsr303MetaBeanFactory.ANNOTATION_MESSAGE);
import org.apache.bval.jsr303.Jsr303MetaBeanFactory;
putValue(Jsr303MetaBeanFactory.ANNOTATION_MESSAGE, message);
putValue(Jsr303MetaBeanFactory.ANNOTATION_GROUPS, groups);
putValue(Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD, payload);
import org.apache.bval.jsr303.ApacheValidatorFactory;
import org.apache.bval.jsr303.Jsr303MetaBeanFactory;
import org.apache.bval.jsr303.util.EnumerationConverter;
import org.apache.bval.jsr303.util.IOUtils;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;
import org.apache.commons.beanutils.ConvertUtils;
import org.apache.commons.beanutils.Converter;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.util.*;
private static final String[] RESERVED_PARAMS = {
Jsr303MetaBeanFactory.ANNOTATION_MESSAGE,
Jsr303MetaBeanFactory.ANNOTATION_GROUPS,
Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD };
import java.beans.IndexedPropertyDescriptor;
if (!(pd instanceof IndexedPropertyDescriptor || pd.getName().equals("class"))) {
String objectId = "";
try {
if (object != null) {
objectId = object.toString();
} else {
objectId = "<null>";
}
} catch (Exception e) {
objectId = "<unknown>";
} finally {
return new ValidationException("error during validation of "
objectId, ex);
}
fixed = false;
import org.apache.bval.jsr303.util.SecureActions;
final ClassLoader classLoader = SecureActions.getContextClassLoader(Thread.currentThread());
rb = loadBundle(SecureActions.getClassLoader(this.getClass()), locale,
final Field[] fields = SecureActions.getDeclaredFields(beanClass);
final Method[] methods = SecureActions.getDeclaredMethods(beanClass);
public static Field[] getDeclaredFields(final Class<?> clazz) {
return run(new PrivilegedAction<Field[]>() {
public Field[] run() {
Field[] fs = clazz.getDeclaredFields();
for( Field f : fs ) {
setAccessibility(f);
}
return fs;
}
});
}
public static ClassLoader getClassLoader(final Class<?> clazz) {
return run(new PrivilegedAction<ClassLoader>() {
public ClassLoader run() {
return clazz.getClassLoader();
}
});
}
public static ClassLoader getContextClassLoader(final Thread thread) {
return run(new PrivilegedAction<ClassLoader>() {
public ClassLoader run() {
return thread.getContextClassLoader();
}
});
}
public FieldAccess(final Field field) {
PrivilegedActions.run( new PrivilegedAction<Object>() {
public Object run() {
field.setAccessible(true);
return (Object) null;
}
});
public MethodAccess(String propertyName, final Method method) {
PrivilegedActions.run( new PrivilegedAction<Object>() {
public Object run() {
method.setAccessible(true);
return (Object) null;
}
});
import java.lang.annotation.ElementType;
import org.apache.bval.jsr303.util.ClassHelper;
import org.apache.bval.jsr303.util.SecureActions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
ClassHelper.getClass(PERSISTENCE_UTIL_CLASSNAME);
(Class<? extends TraversableResolver>) ClassHelper
import org.apache.commons.lang.ClassUtils;
public static Class<?> getClass(String className) throws ClassNotFoundException {
return getClass(className, true);
}
public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {
ClassLoader ctxtCldr = SecureActions.getContextClassLoader(Thread.currentThread());
ClassLoader loader = (ctxtCldr != null) ? ctxtCldr : SecureActions.getClassLoader(ClassHelper.class);
return ClassUtils.getClass(loader, className, initialize);
}
public static ClassLoader getContextClassLoader(final Class<?> clazz) {
return run(new PrivilegedAction<ClassLoader>() {
public ClassLoader run() {
return clazz.getClassLoader();
}
});
}
ClassLoader classLoader = SecureActions.getClassLoader(getType());
boolean failed = listener.hasViolations();
for (Iterator<ConstraintValidation<?>> composed = getComposingValidations().iterator(); !failed && composed.hasNext();) {
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
@Target({METHOD, FIELD, CONSTRUCTOR, PARAMETER})
@Retention(RUNTIME)
Class<?>[] groups() default {};
import javax.validation.ConstraintViolation;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.groups.Default;
import javax.validation.metadata.BeanDescriptor;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
String REF_GROUPS = "refGroups";
import org.apache.bval.Validate;
} else if (annotation instanceof Validate) {
return processValid(prop, access, ((Validate)annotation).groups());
private boolean processValid(MetaProperty prop, AccessStrategy access, Class<?>... groups) {
prop.putFeature(Jsr303Features.Property.REF_GROUPS, groups);
import org.apache.bval.Validate;
if (anno instanceof Valid || anno instanceof Validate) {
if (anno instanceof Valid || anno instanceof Validate) {
if (annotation instanceof Valid || annotation instanceof Validate) {
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import org.apache.bval.model.MetaBean;
protected final ConcurrentMap<String, MetaBean> cacheById = new ConcurrentHashMap<String, MetaBean>();
protected final ConcurrentMap<Class<?>, MetaBean> cacheByClass = new ConcurrentHashMap<Class<?>, MetaBean>();
super();
return cacheById.get(beanInfoId);
return cacheByClass.get(clazz);
cacheByClass.putIfAbsent(beanInfo.getBeanClass(), beanInfo);
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.ReentrantLock;
import org.apache.commons.lang.ArrayUtils;
private static final long serialVersionUID = -4045110242904814218L;
private ConcurrentMap<String, Object> features = createFeaturesMap();
private volatile boolean locking;
private ReentrantLock lock = new ReentrantLock(true);
super();
lock.lock();
try {
this.locking = !fast;
} finally {
lock.unlock();
}
return getFeature(key, (T) null);
boolean release = acquireLockIfNeeded();
try {
return features.containsKey(key) ? (T) features.get(key) : defaultValue;
} finally {
if (release) {
lock.unlock();
}
boolean release = acquireLockIfNeeded();
try {
features.put(key, value);
} finally {
if (release) {
lock.unlock();
}
}
@SuppressWarnings("unchecked")
final T self = (T) clone();
target.features = target.createFeaturesMap();
target.features.putAll(features);
if (validations == null)
return false;
if (validation.equals(aValidation))
return true;
protected ConcurrentMap<String, Object> createFeaturesMap() {
return new ConcurrentHashMap<String, Object>();
}
private boolean acquireLockIfNeeded() {
if (locking) {
lock.lock();
if (locking) {
return true;
}
lock.unlock();
}
return false;
}
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.bval.model.Validation;
import org.apache.commons.lang.ClassUtils;
final HashMap<String, XMLMetaBean> map = new HashMap<String, XMLMetaBean>(beans.size());
map.put(bean.getId(), bean);
beanLookup = new ConcurrentHashMap<String, XMLMetaBean>(map);
final HashMap<String, XMLMetaValidator> map = new HashMap<String, XMLMetaValidator>(validators.size());
map.put(xv.getId(), xv);
validationLookup = new ConcurrentHashMap<String, XMLMetaValidator>(map);
if (beans == null) beans = new ArrayList<XMLMetaBean>();
if (validators == null) validators = new ArrayList<XMLMetaValidator>();
if (isRootPath() || nodeList.size() == 0) {
try {
return nodeList.remove(nodeList.size() - 1);
} finally {
if (nodeList.isEmpty()) {
nodeList.add(new NodeImpl((String) null));
}
}
import javax.inject.Inject;
import javax.inject.Provider;
import javax.validation.spi.BootstrapState;
@com.google.inject.Inject(optional = true)
private BootstrapState bootstrapState;
private ValidationProvider<?> validationProvider;
@Inject
private TraversableResolver traversableResolver;
@Inject
private MessageInterpolator messageInterpolator;
@Inject
private ConstraintValidatorFactory constraintValidatorFactory;
public void setBootstrapState(BootstrapState bootstrapState) {
this.bootstrapState = bootstrapState;
public void setValidationProvider(ValidationProvider<?> validationProvider) {
this.validationProvider = validationProvider;
public void setTraversableResolver(TraversableResolver traversableResolver) {
this.traversableResolver = traversableResolver;
public void setMessageInterpolator(MessageInterpolator messageInterpolator) {
this.messageInterpolator = messageInterpolator;
}
public void setConstraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory) {
this.constraintValidatorFactory = constraintValidatorFactory;
ConfigurationImpl configuration = new ConfigurationImpl(this.bootstrapState, this.validationProvider);
configuration.traversableResolver(this.traversableResolver);
configuration.messageInterpolator(this.messageInterpolator);
configuration.constraintValidatorFactory(this.constraintValidatorFactory);
return configuration;
import javax.inject.Inject;
import javax.inject.Singleton;
private Injector injector;
public void setInjector(Injector injector) {
import javax.inject.Inject;
this.bind(ConfigurationState.class).toProvider(ConfigurationStateProvider.class).in(Scopes.SINGLETON);
this.bind(ValidatorFactory.class).toProvider(ValidatorFactoryProvider.class).in(Scopes.SINGLETON);
import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
private ConfigurationState configurationState;
public void setConfigurationState(ConfigurationState configurationState) {
this.configurationState = configurationState;
return new ApacheValidationProvider().buildValidatorFactory(this.configurationState);
import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
private ValidatorFactory validatorFactory;
public void setValidatorFactory(ValidatorFactory validatorFactory) {
import javax.inject.Singleton;
String exceptionMessage() default "";
private static final Class<?>[] CAUSE_TYPES = new Class[]{ Throwable.class };
private static final Class<?>[] MESSAGE_CAUSE_TYPES = new Class[]{ String.class, Throwable.class };
throw getException(new ConstraintViolationException(
String.format("Validation error when calling method '%s' with arguments ",
method,
Arrays.deepToString(arguments)),
constraintViolations),
validate.rethrowExceptionsAs(),
validate.exceptionMessage(),
arguments);
throw getException(new ConstraintViolationException(
String.format("Method '%s' returned a not valid value ",
method,
returnedValue),
constraintViolations),
validate.rethrowExceptionsAs(),
validate.exceptionMessage(),
arguments);
Class<? extends Throwable> exceptionWrapperClass,
String exceptionMessage,
Object[] arguments) {
String errorMessage;
Object[] initargs;
Class<?>[] initargsType;
if (exceptionMessage.length() != 0) {
errorMessage = String.format(exceptionMessage, arguments);
initargs = new Object[]{ errorMessage, exception };
initargsType = MESSAGE_CAUSE_TYPES;
} else {
initargs = new Object[]{ exception };
initargsType = CAUSE_TYPES;
}
Constructor<? extends Throwable> exceptionConstructor = getMatchingConstructor(exceptionWrapperClass, initargsType);
if (exceptionConstructor != null) {
try {
rethrowEx = exceptionConstructor.newInstance(initargs);
} catch (Exception e) {
errorMessage = String.format("Impossible to re-throw '%s', it needs the constructor with %s argument(s).",
exceptionWrapperClass.getName(),
Arrays.toString(initargsType));
rethrowEx = new RuntimeException(errorMessage, e);
}
} else {
errorMessage = String.format("Impossible to re-throw '%s', it needs the constructor with %s or %s argument(s).",
exceptionWrapperClass.getName(),
Arrays.toString(CAUSE_TYPES),
Arrays.toString(MESSAGE_CAUSE_TYPES));
rethrowEx = new RuntimeException(errorMessage);
@SuppressWarnings("unchecked")
private static <E extends Throwable> Constructor<E> getMatchingConstructor(Class<E> type,
Class<?>[] argumentsType) {
Class<? super E> currentType = type;
while (Object.class != currentType) {
for (Constructor<?> constructor : currentType.getConstructors()) {
if (Arrays.equals(argumentsType, constructor.getParameterTypes())) {
return (Constructor<E>) constructor;
}
}
currentType = currentType.getSuperclass();
}
return null;
}
groups = { Insert.class },
validateReturnedValue = true
groups = { Update.class },
rethrowExceptionsAs = DummyException.class,
exceptionMessage = "This is just a dummy message %s"
public DummyException(String message, Throwable cause) {
super(message, cause);
}
import javax.validation.ValidatorFactory;
private ValidatorFactory validatorFactory;
public void setValidatorFactory(ValidatorFactory validatorFactory) {
this.validatorFactory = validatorFactory;
Validator validator = this.validatorFactory.getValidator();
import org.apache.bval.jsr303.ConfigurationImpl;
import org.apache.bval.jsr303.util.IOUtils;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.PrivilegedActions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
"META-INF/validation-configuration-1.0.xsd";
protected final String validationXmlFile;
if (file == null) {
unmarshaller.unmarshal(stream, ValidationConfigType.class);
protected InputStream getInputStream(String path) throws IOException {
InputStream inputStream = loader.getResourceAsStream(path);
if (inputStream != null) {
Enumeration<URL> urls = loader.getResources(path);
Set<String> uniqueUrls = new HashSet<String>(2);
while (urls.hasMoreElements()) {
uniqueUrls.add(urls.nextElement().toString());
uniqueUrls);
(Class<? extends ValidationProvider<?>>) SecureActions
.loadClass(providerClassName, this.getClass());
if (target.getMessageInterpolator() == null) {
.loadClass(messageInterpolatorClass, this.getClass());
if (target.getTraversableResolver() == null) {
.loadClass(traversableResolverClass, this.getClass());
if (target.getConstraintValidatorFactory() == null) {
(Class<ConstraintValidatorFactory>) SecureActions
.loadClass(constraintFactoryClass, this.getClass());
if (mappingFileName.startsWith("/")) {
"Unable to open input stream for mapping file "
mappingFileName);
mappingFileName, e);
if (urls.hasMoreElements()) {
String url = urls.nextElement().toString();
while (urls.hasMoreElements()) {
}
return doPrivileged(new PrivilegedAction<Object>() {
return doPrivileged(new PrivilegedAction<ClassLoader>() {
private static <T> T doPrivileged(final PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.reflect.Method;
import org.apache.commons.lang.ClassUtils;
import java.security.AccessController;
import java.security.PrivilegedAction;
@SuppressWarnings("unchecked")
public ValidatorFactory buildValidatorFactory(final ConfigurationState configuration) {
final Class<? extends ValidatorFactory> validatorFactoryClass;
if (validatorFactoryClassname == null)
validatorFactoryClass = ApacheValidatorFactory.class;
else
{
validatorFactoryClass
= (Class<? extends ValidatorFactory>) ClassUtils.getClass(validatorFactoryClassname);
validatorFactoryClass.asSubclass(ValidatorFactory.class);
}
return (System.getSecurityManager() == null)
? instantiateValidatorFactory(validatorFactoryClass, configuration)
: AccessController.doPrivileged(new PrivilegedAction<ValidatorFactory>() {
public ValidatorFactory run() {
return instantiateValidatorFactory(validatorFactoryClass, configuration);
}
});
private static ValidatorFactory instantiateValidatorFactory(
final Class<? extends ValidatorFactory> validatorFactoryClass,
final ConfigurationState                configuration
) {
try
{
return validatorFactoryClass.getConstructor(ConfigurationState.class).newInstance(configuration);
}
catch (final Exception ex)
{
}
}
import javax.validation.*;
import javax.validation.bootstrap.ProviderSpecificBootstrap;
import javax.validation.spi.ConfigurationState;
import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.*;
new ConstraintDefaults();
Validation.byProvider(ApacheValidationProvider.class);
(ApacheValidatorFactory) configuration.buildValidatorFactory();
new HashMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>>();
.getConstraintValidatorFactory());
: getDefaultMessageInterpolator());
TraversableResolver traversableResolver) {
ConstraintValidatorFactory constraintValidatorFactory) {
public <T> T unwrap(final Class<T> type) {
return (T) this;
.getModifiers()))) {
return newInstance(type);
return (T) newInstance(cls);
private <T> T newInstance(final Class<T> cls) {
return AccessController.doPrivileged(new PrivilegedAction<T>() {
public T run() {
try {
return cls.newInstance();
} catch (final Exception ex) {
}
}
});
}
MetaConstraint<?, ?> metaConstraint) {
constraintMap.get(beanClass);
new ArrayList<MetaConstraint<?, ? extends Annotation>>();
Class<T> beanClass) {
constraintMap.get(beanClass);
return Collections.<AccessStrategy>emptyList();
import java.lang.reflect.Constructor;
import java.security.AccessController;
import java.security.PrivilegedAction;
Class<?>... groups) {
factoryContext.getMetaBeanFinder().findForClass(objectClass);
createContext(objectMetaBean, object, objectClass, groups);
context.getListener();
String propertyName, Class<?>... groups) {
factoryContext.getMetaBeanFinder().findForClass(objectClass);
createContext(objectMetaBean, object, objectClass, groups);
getNestedProperty(objectMetaBean, object, propertyName);
String propertyName, Object value, Class<?>... groups) {
factoryContext.getMetaBeanFinder().findForClass(beanType);
createContext(metaBean, null, beanType, groups);
propertyName).getMetaProperty());
factoryContext.getMetaBeanFinder().findForClass(clazz);
metaBean.getFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR);
clazz, ex);
.getModifiers()))) {
return newInstance(type);
(Class<? extends T>) cls;
return newInstance(implClass);
private <T> T newInstance(final Class<T> cls) {
return AccessController.doPrivileged(new PrivilegedAction<T>() {
public T run() {
try {
Constructor<T> cons = cls.getConstructor(ApacheFactoryContext.class);
if (!cons.isAccessible()) {
cons.setAccessible(true);
}
return cons.newInstance(factoryContext);
} catch (final Exception ex) {
}
}
});
}
(ConstraintValidationListener<?>) context.getListener();
context.getMetaBean().getBeanClass());
context.getMetaBean().getFeature(
MetaProperty prop) {
prop.getFeature(Features.Property.REF_CASCADE);
new Jsr303ValidationCallback(context),
treatMapsLikeBeans);
MetaProperty prop, AccessStrategy access) {
context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath,
access.getElementType()))
"Error in TraversableResolver.isReachable() for "
context.getBean(), e);
context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath,
access.getElementType()))
"Error TraversableResolver.isCascadable() for "
context.getBean(), e);
context.getMetaBean().getFeature(
Jsr303Features.Bean.GROUP_SEQUENCE);
groupSeq);
RuntimeException ex, Object object) {
objectId, ex);
String propertyName) {
T object, Class<T> objectClass, Class<?>[] groups) {
new ConstraintValidationListener<T>(object, objectClass);
new GroupValidationContextImpl<T>(listener, this.factoryContext
.getMessageInterpolator(), this.factoryContext
.getTraversableResolver(), metaBean);
"Property path cannot be null or empty.");
ValidationHelper.ValidateCallback {
import javax.validation.*;
import java.util.*;
import javax.validation.metadata.ConstraintDescriptor;
import javax.validation.metadata.ElementDescriptor;
import javax.validation.metadata.ElementDescriptor.ConstraintFinder;
import javax.validation.metadata.Scope;
import java.util.*;
import javax.validation.ValidationException;
public <T extends ConstraintValidator<?, ?>> T getInstance(final Class<T> constraintClass)
{
try
{
return constraintClass.newInstance();
}
catch (final Exception ex)
{
}
import java.security.AccessController;
import java.security.PrivilegedAction;
final ClassLoader classLoader = doPrivileged(SecureActions.getContextClassLoader());
rb = loadBundle(
getClass().getClassLoader(),
locale,
);
StringBuffer sb = new StringBuffer(64);
StringBuffer sb = new StringBuffer(64);
ResourceBundle bundle = defaultBundlesMap.get(locale);
if (bundle == null)
{
bundle = ResourceBundle.getBundle(DEFAULT_VALIDATION_MESSAGES, locale);
defaultBundlesMap.put(locale, bundle);
ResourceBundle bundle = userBundlesMap.get(locale);
if (bundle == null)
{
bundle = getFileBasedResourceBundle(locale);
if (bundle != null) {
userBundlesMap.put(locale, bundle);
}
private static <T> T doPrivileged(final PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
import java.security.AccessController;
import java.security.PrivilegedAction;
"META-INF/services/javax.validation.spi.ValidationProvider";
ValidationProvider<?> vp =
AccessController.doPrivileged(new PrivilegedAction<ValidationProvider<?>>() {
public ValidationProvider<?> run() {
try {
return (ValidationProvider<?>) provider.newInstance();
} catch (final Exception ex) {
}
}
});
providers.add(vp);
import javax.validation.metadata.ConstraintDescriptor;
import javax.validation.metadata.ElementDescriptor;
import java.security.AccessController;
import java.security.PrivilegedAction;
final Field[] fields = doPrivileged(SecureActions.getDeclaredFields(beanClass));
final Method[] methods = doPrivileged(SecureActions.getDeclaredMethods(beanClass));
private static <T> T doPrivileged(final PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
import javax.validation.metadata.PropertyDescriptor;
import java.util.ArrayList;
import java.util.List;
import org.apache.bval.jsr303.ApacheFactoryContext;
import org.apache.bval.jsr303.BeanDescriptorImpl;
import org.apache.bval.model.MetaBean;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.List;
import javax.validation.groups.Default;
import org.apache.bval.jsr303.util.ClassHelper;
import org.apache.commons.lang.ClassUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.lang.annotation.ElementType;
import java.security.AccessController;
import java.security.PrivilegedAction;
final ClassLoader classLoader = getClassLoader();
ClassUtils.getClass(classLoader, PERSISTENCE_UTIL_CLASSNAME, true);
(Class<? extends TraversableResolver>)
ClassUtils.getClass(classLoader, JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME, true);
jpaTR = jpaAwareResolverClass.newInstance();
private static ClassLoader getClassLoader()
{
return (System.getSecurityManager() == null)
? getClassLoader0()
: AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
public ClassLoader run() {
return getClassLoader0();
}
});
}
private static ClassLoader getClassLoader0()
{
final ClassLoader loader = Thread.currentThread().getContextClassLoader();
return (loader != null) ? loader : ClassHelper.class.getClassLoader();
}
import java.security.AccessController;
import java.util.List;
fillFullClassHierarchyAsList(allClasses, clazz.getSuperclass());
for (Class<?> subClass : clazz.getInterfaces()) {
@Deprecated
@Deprecated
ClassLoader loader = Thread.currentThread().getContextClassLoader();
if (loader == null)
loader = ClassHelper.class.getClassLoader();
private static void validGroups(final Annotation annotation) {
final Method groupsMethod = SecureActions.doPrivileged(
SecureActions.getPublicMethod(annotation.annotationType(), Jsr303MetaBeanFactory.ANNOTATION_GROUPS)
);
if (groupsMethod == null) {
final Object defaultGroupsValue = groupsMethod.getDefaultValue();
if (defaultGroupsValue instanceof Class<?>[]) {
if (((Class[]) defaultGroupsValue).length != 0) {
private static void validPayload(final Annotation annotation) {
final Method payloadMethod = SecureActions.doPrivileged(
SecureActions.getPublicMethod(annotation.annotationType(), Jsr303MetaBeanFactory.ANNOTATION_PAYLOAD)
);
if (payloadMethod == null) {
final Object defaultPayloadValue = payloadMethod.getDefaultValue();
if (defaultPayloadValue instanceof Class<?>[]) {
if (((Class[]) defaultPayloadValue).length != 0) {
private static void validMessage(final Annotation annotation) {
final Method messageMethod = SecureActions.doPrivileged(
SecureActions.getPublicMethod(annotation.annotationType(), Jsr303MetaBeanFactory.ANNOTATION_MESSAGE)
);
if (messageMethod == null) {
final Object defaultMessageValue = messageMethod.getDefaultValue();
if (!(defaultMessageValue instanceof String)) {
private static void validAttributes(final Annotation annotation) {
final Method[] methods = SecureActions.doPrivileged(
SecureActions.getDeclaredMethods(annotation.annotationType())
);
for (Method method : methods ){
import javax.validation.ConstraintValidatorContext;
import javax.validation.ConstraintValidatorContext;
import org.apache.bval.jsr303.ConstraintValidatorContextImpl;
import java.lang.reflect.AccessibleObject;
import java.security.AccessController;
public static PrivilegedAction<ClassLoader> getContextClassLoader()
{
return SecureActions.GetContextClassLoader.instance;
public static PrivilegedAction<Field> getDeclaredField(final Class<?> clazz, final String fieldName) {
return new PrivilegedAction<Field>() {
final Field f = clazz.getDeclaredField(fieldName);
} catch (final NoSuchFieldException ex) {
};
}
public static PrivilegedAction<Field[]> getDeclaredFields(final Class<?> clazz) {
return new PrivilegedAction<Field[]>() {
public Field[] run() {
final Field[] fields = clazz.getDeclaredFields();
if (fields.length > 0)
AccessibleObject.setAccessible(fields, true);
return fields;
}
};
}
public static PrivilegedAction<Method[]> getDeclaredMethods(final Class<?> clazz) {
return new PrivilegedAction<Method[]>() {
public Method[] run() {
return clazz.getDeclaredMethods();
}
};
public static PrivilegedAction<Method> getPublicMethod(final Class<?> clazz, final String methodName) {
return new PrivilegedAction<Method>() {
public Method run() {
try {
return clazz.getMethod(methodName, (Class[]) null);
} catch (final NoSuchMethodException ex) {
return null;
}
}
};
static <T> T doPrivileged(final PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
private static final class GetContextClassLoader extends Object implements PrivilegedAction<ClassLoader> {
static final GetContextClassLoader instance = new GetContextClassLoader();
private GetContextClassLoader()
{
super();
}
public final ClassLoader run() {
return Thread.currentThread().getContextClassLoader();
}
import java.security.AccessController;
import java.security.PrivilegedAction;
final Method[] declaredMethods = doPrivileged(
SecureActions.getDeclaredMethods(annotationType)
);
private static <T> T doPrivileged(final PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
import org.apache.bval.util.PrivilegedActions;
import java.lang.reflect.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
final Method[] methods = doPrivileged(SecureActions.getDeclaredMethods(annot.annotationType()));
for (Method m : methods) {
if (!m.isAccessible()) {
final Class<A> proxyClass = (Class<A>) Proxy.getProxyClass(classLoader, getType());
final InvocationHandler handler = new AnnotationProxy(this);
return PrivilegedActions.run(new PrivilegedAction<A>() {
public A run() {
try {
Constructor<A> constructor = proxyClass.getConstructor(InvocationHandler.class);
return constructor.newInstance(handler);
} catch (Exception e) {
throw new ValidationException("Unable to create annotation for configured constraint", e);
}
}
});
}
private static <T> T doPrivileged(final PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
import javax.validation.ValidationException;
import org.apache.commons.lang.StringUtils;
import java.security.AccessController;
import java.security.PrivilegedAction;
final Class<A> annotationClass, final String name) {
final Method m = doPrivileged(SecureActions.getPublicMethod(annotationClass, name));
final Field field = doPrivileged(SecureActions.getDeclaredField(beanClass, fieldName));
final Method method = getGetter(beanClass, getterName);
validatorClass = (Class<? extends ConstraintValidator<?, ?>>)
loadClass(validatorClassName.getValue());
return loadClass(toQualifiedClassName(className, defaultPackage));
private static <T> T doPrivileged(final PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
private static Method getGetter(final Class<?> clazz, final String propertyName) {
return doPrivileged(new PrivilegedAction<Method>() {
public Method run() {
try {
final String p = StringUtils.capitalize(propertyName);
try {
} catch (NoSuchMethodException e) {
}
} catch (NoSuchMethodException e) {
return null;
}
}
});
}
private Class<?> loadClass(final String className) {
ClassLoader loader = doPrivileged(SecureActions.getContextClassLoader());
if (loader == null)
loader = getClass().getClassLoader();
try {
return Class.forName(className, true, loader);
} catch (ClassNotFoundException ex) {
}
}
import java.security.AccessController;
import java.security.PrivilegedAction;
(Class<? extends ValidationProvider<?>>) loadClass(providerClassName);
Class<MessageInterpolator> clazz = (Class<MessageInterpolator>)
loadClass(messageInterpolatorClass);
target.messageInterpolator(newInstance(clazz));
Class<TraversableResolver> clazz = (Class<TraversableResolver>)
loadClass(traversableResolverClass);
target.traversableResolver(newInstance(clazz));
private <T> T newInstance(final Class<T> cls) {
return AccessController.doPrivileged(new PrivilegedAction<T>() {
public T run() {
try {
return cls.newInstance();
} catch (final Exception ex) {
}
}
});
}
Class<ConstraintValidatorFactory> clazz = (Class<ConstraintValidatorFactory>)
loadClass(constraintFactoryClass);
target.constraintValidatorFactory(newInstance(clazz));
private static <T> T doPrivileged(final PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
private Class<?> loadClass(final String className) {
ClassLoader loader = doPrivileged(SecureActions.getContextClassLoader());
if (loader == null)
loader = getClass().getClassLoader();
try {
return Class.forName(className, true, loader);
} catch (ClassNotFoundException ex) {
}
}
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.jsr303.example.ZipCodeCityCarrier;
import org.apache.bval.constraints.ZipCodeCityCoherence;
import org.apache.bval.constraints.NotEmpty;
import org.apache.bval.constraints.NotEmpty;
import javax.validation.constraints.NotNull;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.groups.Default;
import javax.validation.groups.Default;
import org.apache.bval.constraints.ZipCodeCityCoherence;
import org.apache.bval.jsr303.example.ZipCodeCityCarrier;
try {
return field.get(instance);
} catch (IllegalAccessException e) {
throw new IllegalArgumentException(e);
}
try {
return method.invoke(instance);
} catch (IllegalAccessException e) {
throw new IllegalArgumentException(e);
} catch (InvocationTargetException e) {
throw new IllegalArgumentException(e);
}
@SuppressWarnings("unchecked")
return doPrivileged(new PrivilegedAction<A>() {
@SuppressWarnings({ "rawtypes" })
@SuppressWarnings({ "rawtypes" })
@SuppressWarnings({ "rawtypes" })
import java.lang.reflect.Method;
import java.lang.reflect.Type;
public class IntrospectorMetaBeanFactory implements MetaBeanFactory {
if (meta.getBeanClass() == null) {
}
if (meta.getName() == null && info.getBeanDescriptor() != null) {
MetaProperty metaProp = buildMetaProperty(pd, meta.getProperty(pd.getName()));
@Deprecated
return buildMetaProperty(pd, null);
}
protected MetaProperty buildMetaProperty(PropertyDescriptor pd, MetaProperty existing) {
meta.setType(determineGenericPropertyType(pd));
if (pd.isHidden()) {
meta.putFeature(HIDDEN, Boolean.TRUE);
}
if (pd.isPreferred()) {
meta.putFeature(PREFERRED, Boolean.TRUE);
}
if (pd.isConstrained()) {
meta.putFeature(READONLY, Boolean.TRUE);
}
private Type determineGenericPropertyType(PropertyDescriptor pd) {
Method m = pd.getReadMethod();
if (m != null) {
return m.getGenericReturnType();
}
m = pd.getWriteMethod();
if (m != null && m.getParameterTypes().length == 1) {
return m.getGenericParameterTypes()[0];
}
return pd.getPropertyType();
}
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.ArrayUtils;
validations = ArrayUtils.add(validations, validation);
import java.util.Arrays;
import java.util.Comparator;
import org.apache.commons.lang3.ArrayUtils;
private static class PropertyNameComparator implements Comparator<Object> {
static final PropertyNameComparator INSTANCE = new PropertyNameComparator();
public int compare(Object o1, Object o2) {
return getName(o1).compareTo(getName(o2));
}
private String getName(Object o) {
if (o == null) {
throw new NullPointerException();
}
return o instanceof MetaProperty ? ((MetaProperty) o).getName() : String.valueOf(o);
}
}
Arrays.sort(properties, PropertyNameComparator.INSTANCE);
final MetaProperty[] props = properties;
int pos = Arrays.binarySearch(props, name, PropertyNameComparator.INSTANCE);
return pos < 0 ? null : props[pos];
if (p.isRelationship()) {
return true;
}
if (property != null) {
property.setParentMetaBean(this);
Object key = property == null ? name : property;
MetaProperty[] props = properties;
int pos = Arrays.binarySearch(props, key, PropertyNameComparator.INSTANCE);
if (pos < 0) {
if (property == null) {
return;
}
props = ArrayUtils.add(props, 0 - pos - 1, property);
} else {
if (property == null) {
props = ArrayUtils.remove(props, pos);
} else {
props[pos] = property;
}
}
this.properties = props;
import org.apache.commons.lang3.reflect.TypeUtils;
Type targetType = type instanceof DynaType ? ((DynaType) type)
.getRawType() : type;
if (targetType == null) {
return null;
Type assigningType = getParentMetaBean() == null ? null
: getParentMetaBean().getBeanClass();
return TypeUtils.getRawType(targetType, assigningType);
import java.lang.reflect.Method;
return rememberField != null ? ElementType.FIELD : ElementType.METHOD;
Type result = getTypeInner();
return result == null ? Object.class : result;
}
public boolean isKnown() {
return getTypeInner() != null;
}
private Type getTypeInner() {
if (rememberField != null) {
Method readMethod = getPropertyReadMethod(propertyName, beanClass);
if (readMethod != null) {
return readMethod.getGenericReturnType();
}
Field fld = getField(propertyName, beanClass);
if (fld != null) {
cacheField(fld);
return rememberField.getGenericType();
}
return null;
}
private static Method getPropertyReadMethod(String propertyName, Class<?> beanClass) {
if (each.getName().equals(propertyName)) {
return each.getReadMethod();
return null;
}
private static Field getField(String propertyName, Class<?> beanClass) {
return beanClass.getField(propertyName);
return theClass.getDeclaredField(propertyName);
return null;
Field field = getField(propertyName, beanClass);
if (field != null) {
cacheField(field);
return rememberField.get(bean);
}
private void cacheField(Field field) {
if (!field.isAccessible()) {
field.setAccessible(true);
}
this.rememberField = field;
import org.apache.bval.model.MetaBean;
Object[] array = (Object[]) context.getBean();
MetaBean metaBean = context.getMetaBean();
context.setCurrentIndex(null);
try {
for (Object each : array) {
if (each == null) {
}
if (dyn != null) {
context.setBean(each, dyn.resolveMetaBean(each));
} else {
context.setBean(each);
}
s.validate();
} finally {
context.moveUp(array, metaBean);
Iterable<?> iterable = (Iterable<?>) context.getBean();
MetaBean metaBean = context.getMetaBean();
try {
final DynamicMetaBean dyn = getDynamicMetaBean(context);
for (Object each : iterable) {
if (positional) {
}
if (each == null) {
}
if (dyn != null) {
context.setBean(each, dyn.resolveMetaBean(each));
} else {
context.setBean(each);
}
s.validate();
} finally {
context.moveUp(iterable, metaBean);
MetaBean metaBean = context.getMetaBean();
context.setCurrentKey(null);
try {
for (Object key : currentBean.keySet()) {
context.setCurrentKey(key);
Object value = currentBean.get(key);
if (value == null) {
}
if (dyn != null) {
context.setBean(value, dyn.resolveMetaBean(value));
} else {
context.setBean(value);
}
s.validate();
} finally {
context.moveUp(currentBean, metaBean);
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.PrivilegedAction;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintValidator;
import javax.validation.OverridesAttribute;
import javax.validation.Payload;
import javax.validation.ReportAsSingleViolation;
public AnnotationConstraintBuilder(Class<? extends ConstraintValidator<A, ?>>[] validatorClasses,
ConstraintValidator<A, ?> constraintValidator, A annotation, Class<?> owner, AccessStrategy access) {
boolean reportFromComposite =
annotation != null && annotation.annotationType().isAnnotationPresent(ReportAsSingleViolation.class);
constraintValidation =
new ConstraintValidation<A>(validatorClasses, constraintValidator, annotation, owner, access,
reportFromComposite);
for (Method method : constraintValidation.getAnnotation().annotationType().getDeclaredMethods()) {
if (ConstraintAnnotationAttributes.PAYLOAD.getAttributeName().equals(method.getName())) {
} else if (ConstraintAnnotationAttributes.GROUPS.getAttributeName().equals(
method.getName())) {
constraintValidation.getAttributes().put(method.getName(),
method.invoke(constraintValidation.getAnnotation()));
private void buildGroups(Method method) throws IllegalAccessException, InvocationTargetException {
garr = new Class[] { (Class<?>) raw };
private void buildPayload(Method method) throws IllegalAccessException, InvocationTargetException {
(Class<? extends Payload>[]) method.invoke(constraintValidation.getAnnotation());
payloadSet = Collections.<Class<? extends Payload>> emptySet();
if (generalOverride != null) {
if (index > 0) {
throw new ConstraintDeclarationException("Wrong OverridesAttribute declaration for "
generalOverride.constraintType
", it needs a defined index when there is a list of constraints");
if (override != null) {
for (Method method : constraintValidation.getAnnotation().annotationType().getDeclaredMethods()) {
OverridesAttribute.List annoOAL = method.getAnnotation(OverridesAttribute.List.class);
target.values.put(oa.name(), constraintValidation.getAttributes().get(methodName));
private ConstraintOverrides findOverride(Class<? extends Annotation> constraint, int constraintIndex) {
if (each.constraintType == constraint && each.constraintIndex == constraintIndex) {
private ConstraintOverrides(Class<? extends Annotation> constraintType, int constraintIndex) {
for (String key : values.keySet()) {
import java.lang.reflect.Constructor;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;
import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.ValidatorContext;
import org.apache.bval.IntrospectorMetaBeanFactory;
import org.apache.bval.MetaBeanBuilder;
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.MetaBeanManager;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.PrivilegedActions;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.reflect.ConstructorUtils;
List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>();
String[] factoryClassNames =
StringUtils.split(
factory.getProperties().get(ApacheValidatorConfiguration.Properties.METABEAN_FACTORY_CLASSNAMES));
if (factoryClassNames != null) {
for (String clsName : factoryClassNames) {
@SuppressWarnings("unchecked")
Class<? extends MetaBeanFactory> factoryClass = (Class<? extends MetaBeanFactory>) loadClass(clsName);
builders.add(createMetaBeanFactory(factoryClass));
}
}
boolean jsr303Found = false;
for (MetaBeanFactory builder : builders) {
jsr303Found |= builder instanceof Jsr303MetaBeanFactory;
}
if (!jsr303Found) {
builders.add(new Jsr303MetaBeanFactory(this));
}
@SuppressWarnings("deprecation")
boolean enableMetaBeansXml = Boolean.parseBoolean(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML));
if (enableMetaBeansXml) {
XMLMetaBeanManagerCreator.addFactory(builders);
}
protected MetaBeanFinder createMetaBeanManager(List<MetaBeanFactory> builders) {
private <F extends MetaBeanFactory> F createMetaBeanFactory(final Class<F> cls) {
return PrivilegedActions.run(new PrivilegedAction<F>() {
public F run() {
try {
Constructor<F> c = ConstructorUtils.getMatchingAccessibleConstructor(cls, ApacheFactoryContext.this.getClass());
if (c != null) {
return c.newInstance(ApacheFactoryContext.this);
}
c = ConstructorUtils.getMatchingAccessibleConstructor(cls, getFactory().getClass());
if (c != null) {
return c.newInstance(getFactory());
}
return cls.newInstance();
} catch (Exception e) {
throw new ValidationException(e);
}
}
});
}
static void addFactory(List<MetaBeanFactory> builders) {
builders.add(new XMLMetaBeanFactory());
}
private static <T> T doPrivileged(final PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
private Class<?> loadClass(final String className) {
ClassLoader loader = doPrivileged(SecureActions.getContextClassLoader());
if (loader == null)
loader = getClass().getClassLoader();
try {
return Class.forName(className, true, loader);
} catch (ClassNotFoundException ex) {
}
}
import java.security.AccessController;
import java.security.PrivilegedAction;
import org.apache.commons.lang3.ClassUtils;
public ApacheValidatorConfiguration createSpecializedConfiguration(BootstrapState state) {
import javax.validation.ValidatorContext;
String METABEAN_FACTORY_CLASSNAMES = "apache.bval.metabean-factory-classnames";
import org.apache.commons.lang3.ClassUtils;
@SuppressWarnings({ "unchecked", "rawtypes" })
apb.putValue(ConstraintAnnotationAttributes.GROUPS.getAttributeName(),
inheritedGroups.toArray(new Class[inheritedGroups.size()]));
apb.putValue(ConstraintAnnotationAttributes.PAYLOAD.getAttributeName(),
inheritedPayload.toArray(new Class[inheritedPayload.size()]));
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import javax.validation.ConstraintViolation;
import javax.validation.ValidationException;
import javax.validation.groups.Default;
import javax.validation.metadata.BeanDescriptor;
import org.apache.bval.DynamicMetaBean;
import org.apache.bval.jsr303.util.PathNavigation;
import org.apache.bval.jsr303.util.ValidationContextTraversal;
import org.apache.bval.model.FeaturesCapable;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.reflect.TypeUtils;
public class ClassValidator implements CascadingPropertyValidator {
private static final Object VALIDATE_PROPERTY = new Object() {
public String toString() {
return "VALIDATE_PROPERTY";
}
};
protected MetaBeanFinder getMetaBeanFinder() {
public <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {
MetaBean objectMetaBean = getMetaBeanFinder().findForClass(objectClass);
final GroupValidationContext<T> context = createContext(objectMetaBean, object, objectClass, groups);
final ConstraintValidationListener<T> result = context.getListener();
public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, Class<?>... groups) {
return validateProperty(object, propertyName, false, groups);
public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, boolean cascade,
Class<?>... groups) {
if (object == null)
throw new IllegalArgumentException("cannot validate null");
@SuppressWarnings("unchecked")
Set<ConstraintViolation<T>> result =
validateValueImpl((Class<T>) object.getClass(), object, propertyName, VALIDATE_PROPERTY, cascade, groups);
return result;
}
public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value,
Class<?>... groups) {
return validateValue(beanType, propertyName, value, false, groups);
public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value,
boolean cascade, Class<?>... groups) {
return validateValueImpl(checkBeanType(beanType), null, propertyName, value, cascade, groups);
}
MetaBean metaBean = getMetaBeanFinder().findForClass(clazz);
BeanDescriptorImpl edesc = metaBean.getFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR);
} else if (!(type.isInterface() || Modifier.isAbstract(type.getModifiers()))) {
final Class<? extends T> implClass = (Class<? extends T>) cls;
final ConstraintValidationListener<?> result = (ConstraintValidationListener<?>) context.getListener();
if (defaultGroups != null && defaultGroups.size() > 1) {
ClassHelper.fillFullClassHierarchyAsList(classHierarchy, context.getMetaBean().getBeanClass());
private void validateCascadedBean(GroupValidationContext<?> context, MetaProperty prop) {
AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
ValidationHelper
.validateContext(context, new Jsr303ValidationCallback(context), treatMapsLikeBeans);
private boolean isCascadable(GroupValidationContext<?> context, MetaProperty prop, AccessStrategy access) {
if (!context.getTraversableResolver().isReachable(context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath, access.getElementType()))
if (!context.getTraversableResolver().isCascadable(context.getBean(), node,
context.getRootMetaBean().getBeanClass(), beanPath, access.getElementType()))
List<Group> groupSeq = context.getMetaBean().getFeature(Jsr303Features.Bean.GROUP_SEQUENCE);
context.getGroups().assertDefaultGroupSequenceIsExpandable(groupSeq);
@SuppressWarnings("finally")
protected static RuntimeException unrecoverableValidationError(RuntimeException ex, Object object) {
if (ex instanceof UnknownPropertyException || ex instanceof IncompatiblePropertyValueException) {
private void validatePropertyInGroup(final GroupValidationContext<?> context) {
final Runnable helper;
if (context.getMetaProperty() == null) {
helper = new Runnable() {
public void run() {
ValidationHelper.validateBean(context);
}
};
} else {
helper = new Runnable() {
public void run() {
ValidationHelper.validateProperty(context);
}
};
}
helper.run();
helper.run();
protected <T> GroupValidationContext<T> createContext(MetaBean metaBean, T object, Class<T> objectClass,
Class<?>... groups) {
ConstraintValidationListener<T> listener = new ConstraintValidationListener<T>(object, objectClass);
new GroupValidationContextImpl<T>(listener, this.factoryContext.getMessageInterpolator(),
this.factoryContext.getTraversableResolver(), metaBean);
private <T> Class<T> checkBeanType(Class<T> beanType) {
return beanType;
throw new IllegalArgumentException("Property path cannot be null or empty.");
protected class Jsr303ValidationCallback implements ValidationHelper.ValidateCallback {
protected ValidationContextTraversal createValidationContextTraversal(GroupValidationContext<?> validationContext) {
return new ValidationContextTraversal(validationContext);
}
private <T> Set<ConstraintViolation<T>> validateValueImpl(Class<T> beanType, T object, String propertyName,
Object value, final boolean cascade, Class<?>... groups) {
assert (object == null) ^ (value == VALIDATE_PROPERTY);
checkPropertyName(propertyName);
checkGroups(groups);
try {
final MetaBean initialMetaBean = new DynamicMetaBean(getMetaBeanFinder());
initialMetaBean.setBeanClass(beanType);
GroupValidationContext<T> context = createContext(initialMetaBean, object, beanType, groups);
ValidationContextTraversal contextTraversal = createValidationContextTraversal(context);
PathNavigation.navigate(propertyName, contextTraversal);
MetaProperty prop = context.getMetaProperty();
boolean fixed = false;
if (value != VALIDATE_PROPERTY) {
assert !context.getPropertyPath().isRootPath();
if (prop == null && value != null) {
context.setMetaBean(getMetaBeanFinder().findForClass(value.getClass()));
}
if (!cascade) {
FeaturesCapable meta = prop == null ? context.getMetaBean() : prop;
if (ArrayUtils.isEmpty(meta.getValidations())) {
return Collections.<ConstraintViolation<T>> emptySet();
}
}
if (!TypeUtils.isAssignable(value == null ? null : value.getClass(), contextTraversal.getType())) {
throw new IncompatiblePropertyValueException(String.format(
"%3$s is not a valid value for property %2$s of type %1$s", beanType, propertyName, value));
}
if (prop == null) {
context.setBean(value);
} else {
context.setFixedValue(value);
fixed = true;
}
}
boolean doCascade = cascade && (prop == null || prop.getMetaBean() != null);
Object bean = context.getBean();
ConstraintValidationListener<T> result = context.getListener();
Groups sequence = context.getGroups();
for (Group current : sequence.getGroups()) {
context.setCurrentGroup(current);
if (!doCascade || prop != null) {
validatePropertyInGroup(context);
}
if (doCascade) {
contextTraversal.moveDownIfNecessary();
if (context.getMetaBean() instanceof DynamicMetaBean) {
context.setMetaBean(context.getMetaBean().resolveMetaBean(
ObjectUtils.defaultIfNull(context.getBean(), contextTraversal.getRawType())));
}
validateBeanNet(context);
if (prop != null) {
context.moveUp(bean, prop.getParentMetaBean());
context.setMetaProperty(prop);
if (fixed) {
context.setFixedValue(value);
}
}
}
}
int groupViolations = result.getConstraintViolations().size();
outer: for (List<Group> eachSeq : sequence.getSequences()) {
for (Group current : eachSeq) {
context.setCurrentGroup(current);
if (!doCascade || prop != null) {
validatePropertyInGroup(context);
}
if (doCascade) {
contextTraversal.moveDownIfNecessary();
if (context.getMetaBean() instanceof DynamicMetaBean) {
context.setMetaBean(context.getMetaBean().resolveMetaBean(
ObjectUtils.defaultIfNull(context.getBean(), contextTraversal.getRawType())));
}
validateBeanNet(context);
if (prop != null) {
context.moveUp(bean, prop.getParentMetaBean());
context.setMetaProperty(prop);
if (fixed) {
context.setFixedValue(value);
}
}
}
if (result.getConstraintViolations().size() > groupViolations)
break outer;
}
}
return result.getConstraintViolations();
} catch (RuntimeException ex) {
throw unrecoverableValidationError(ex, ObjectUtils.defaultIfNull(object, value));
}
}
for (Map.Entry<Object, Object> entry : constraintProperties.entrySet()) {
LinkedList<Class<?>> classes = new LinkedList<Class<?>>();
Class<?> constraintValidatorClass =
SecureActions.run(new PrivilegedAction<Class<?>>() {
public Class<?> run() {
(Class<? extends ConstraintValidator<?, ?>>[]) classes.toArray(new Class[classes.size()]));
ConstraintAnnotationAttributes.GROUPS.put(attributes, groups.toArray(new Class[groups.size()]));
ConstraintAnnotationAttributes.PAYLOAD.put(attributes, payload.toArray(new Class[payload.size()]));
return ConstraintAnnotationAttributes.MESSAGE.get(attributes);
import javax.validation.MessageInterpolator;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.commons.lang3.ArrayUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Collections;
@SuppressWarnings({"unchecked", "rawtypes"})
final class GroupValidationContextImpl<T> extends BeanValidationContext<ConstraintValidationListener<T>> implements
GroupValidationContext<T>, MessageInterpolator.Context {
private final MessageInterpolator messageResolver;
private final PathImpl path;
private final MetaBean rootMetaBean;
private Groups groups;
private Group currentGroup;
private Class<?> currentOwner;
private HashSet<ConstraintValidatorIdentity> validatedConstraints = new HashSet<ConstraintValidatorIdentity>();
private ConstraintValidation<?> constraintValidation;
private final TraversableResolver traversableResolver;
public GroupValidationContextImpl(ConstraintValidationListener<T> listener, MessageInterpolator aMessageResolver,
TraversableResolver traversableResolver, MetaBean rootMetaBean) {
super(listener, new HashMap<GraphBeanIdentity, Set<PathImpl>>());
this.messageResolver = aMessageResolver;
this.traversableResolver = CachingTraversableResolver.cacheFor(traversableResolver);
this.rootMetaBean = rootMetaBean;
this.path = PathImpl.create(null);
@Override
public void setCurrentIndex(Integer index) {
NodeImpl leaf = path.getLeafNode();
if (leaf.getName() == null) {
leaf.setIndex(index);
} else {
path.addNode(NodeImpl.atIndex(index));
}
@Override
public void setCurrentKey(Object key) {
NodeImpl leaf = path.getLeafNode();
if (leaf.getName() == null) {
leaf.setKey(key);
} else {
path.addNode(NodeImpl.atKey(key));
}
@Override
public void moveDown(MetaProperty prop, AccessStrategy access) {
path.addProperty(prop.getName());
super.moveDown(prop, access);
@Override
public void moveUp(Object bean, MetaBean metaBean) {
NodeImpl leaf = path.getLeafNode();
if (leaf.isInIterable() && leaf.getName() != null) {
leaf.setName(null);
} else {
path.removeLeafNode();
}
}
@SuppressWarnings("unchecked")
@Override
public boolean collectValidated() {
GraphBeanIdentity gbi = new GraphBeanIdentity(getBean(), getCurrentGroup().getGroup(), getCurrentOwner());
Set<PathImpl> validatedPathsForGBI = (Set<PathImpl>) validatedObjects.get(gbi);
if (validatedPathsForGBI == null) {
validatedPathsForGBI = new HashSet<PathImpl>();
validatedObjects.put(gbi, validatedPathsForGBI);
}
for (PathImpl validatedPath : validatedPathsForGBI) {
if (path.isSubPathOf(validatedPath)) {
return false;
}
}
validatedPathsForGBI.add(PathImpl.copy(path));
return true;
}
public boolean collectValidated(ConstraintValidator<?, ?> constraint) {
ConstraintValidatorIdentity cvi = new ConstraintValidatorIdentity(getBean(), getPropertyPath(), constraint);
return this.validatedConstraints.add(cvi);
}
public void resetValidatedConstraints() {
validatedConstraints.clear();
}
public PathImpl getPropertyPath() {
PathImpl currentPath = PathImpl.copy(path);
if (getMetaProperty() != null) {
currentPath.addProperty(getMetaProperty().getName());
}
return currentPath;
}
public MetaBean getRootMetaBean() {
return rootMetaBean;
}
public void setGroups(Groups groups) {
this.groups = groups;
}
public Groups getGroups() {
return groups;
}
public Group getCurrentGroup() {
return currentGroup;
}
public void setCurrentGroup(Group currentGroup) {
this.currentGroup = currentGroup;
}
public void setConstraintValidation(ConstraintValidation<?> constraint) {
constraintValidation = constraint;
}
public ConstraintValidation<?> getConstraintValidation() {
return constraintValidation;
}
public ConstraintDescriptor<?> getConstraintDescriptor() {
return constraintValidation;
}
public Object getValidatedValue() {
if (getMetaProperty() != null) {
return getPropertyValue(constraintValidation.getAccess());
} else {
return getBean();
}
}
public MessageInterpolator getMessageResolver() {
return messageResolver;
}
public TraversableResolver getTraversableResolver() {
return traversableResolver;
}
public Class<?> getCurrentOwner() {
return this.currentOwner;
}
public void setCurrentOwner(Class<?> currentOwner) {
this.currentOwner = currentOwner;
}
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;
import javax.validation.Constraint;
import javax.validation.GroupDefinitionException;
import javax.validation.GroupSequence;
import javax.validation.ValidationException;
import javax.validation.groups.Default;
protected AnnotationProcessor annotationProcessor;
this.annotationProcessor = new AnnotationProcessor(factoryContext);
private void processClass(Class<?> beanClass, MetaBean metabean) throws IllegalAccessException,
InvocationTargetException {
if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(beanClass)) {
annotationProcessor.processAnnotations(null, beanClass, beanClass, null, new AppendValidationToMeta(
metabean));
if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(field)) {
AccessStrategy access = new FieldAccess(field);
boolean create = metaProperty == null;
if (create) {
metaProperty = addMetaProperty(metabean, access);
}
if (!annotationProcessor.processAnnotations(metaProperty, beanClass, field, access,
new AppendValidationToMeta(metaProperty)) && create) {
metabean.putProperty(metaProperty.getName(), null);
if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(method)) {
AccessStrategy access = new MethodAccess(propName, method);
boolean create = metaProperty == null;
if (create) {
metaProperty = addMetaProperty(metabean, access);
}
if (!annotationProcessor.processAnnotations(metaProperty, beanClass, method, access,
new AppendValidationToMeta(metaProperty)) && create) {
metabean.putProperty(propName, null);
} else if (hasValidationConstraintsDefined(method)) {
for (Annotation annot : method.getDeclaredAnnotations()) {
if (hasValidationConstraintsDefined(annot)) {
return true;
return false;
if (annot.annotationType().getAnnotation(Constraint.class) != null) {
if (ConstraintAnnotationAttributes.VALUE.isDeclaredOn(annot.annotationType())) {
Annotation[] children = ConstraintAnnotationAttributes.VALUE.getValue(annot);
if (children != null) {
for (Annotation child : children) {
if (hasValidationConstraintsDefined(child)) {
return true;
}
return false;
private void addXmlConstraints(Class<?> beanClass, MetaBean metabean) throws IllegalAccessException,
InvocationTargetException {
for (MetaConstraint<?, ? extends Annotation> meta : factoryContext.getFactory().getMetaConstraints(beanClass)) {
AccessStrategy access = meta.getAccessStrategy();
boolean create = false;
metaProperty = metabean.getProperty(access.getPropertyName());
create = metaProperty == null;
if (create) {
metaProperty = addMetaProperty(metabean, access);
if (!annotationProcessor.processAnnotation(meta.getAnnotation(), metaProperty, beanClass,
meta.getAccessStrategy(), new AppendValidationToMeta(metaProperty == null ? metabean : metaProperty))
&& create) {
metabean.putProperty(access.getPropertyName(), null);
}
boolean create = metaProperty == null;
if (create) {
metaProperty = addMetaProperty(metabean, access);
if (!annotationProcessor.addAccessStrategy(metaProperty, access) && create) {
metabean.putProperty(access.getPropertyName(), null);
throw new GroupDefinitionException("'Default.class' must not appear in @GroupSequence! Use '"
public static MetaProperty addMetaProperty(MetaBean parentMetaBean, AccessStrategy access) {
final MetaProperty result = new MetaProperty();
final String name = access.getPropertyName();
result.setName(name);
result.setType(access.getJavaType());
parentMetaBean.putProperty(name, result);
return result;
import javax.validation.ConstraintViolation;
import javax.validation.ValidationException;
import javax.validation.metadata.ConstraintDescriptor;
import org.apache.bval.jsr303.ApacheFactoryContext;
import org.apache.bval.jsr303.BeanDescriptorImpl;
import org.apache.bval.jsr303.ClassValidator;
import org.apache.bval.jsr303.ConstraintValidation;
import org.apache.bval.jsr303.ConstraintValidationListener;
import org.apache.bval.jsr303.GroupValidationContext;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.Groups;
import org.apache.bval.model.MetaBean;
import org.apache.bval.util.ValidationHelper;
import org.apache.bval.jsr303.ConstraintAnnotationAttributes;
import org.apache.commons.lang3.ClassUtils;
annotationProcessor.processAnnotation(annotation, null,
ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations);
if (ConstraintAnnotationAttributes.VALUE.isDeclaredOn(annotation.annotationType())) {
Annotation[] children = ConstraintAnnotationAttributes.VALUE.getValue(annotation);
if (children != null) {
for (Annotation child : children) {
}
throw new UnsupportedOperationException("Obtaining a parameter value not yet implemented");
throw new UnsupportedOperationException("Obtaining a method return value not yet implemented");
import org.apache.commons.lang3.ObjectUtils;
DEFAULT_GROUPS = new GroupsComputer().computeGroups(Arrays.asList(getDefaultGroupArray()));
return new Class<?>[] { Default.class };
private final Map<Class<?>, List<Group>> resolvedSequences = Collections
.synchronizedMap(new HashMap<Class<?>, List<Group>>());
import javax.validation.Path;
import javax.validation.TraversableResolver;
import org.apache.bval.jsr303.util.ClassHelper;
import org.apache.commons.lang3.ClassUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.commons.lang3.ClassUtils;
import org.apache.bval.jsr303.ConstraintAnnotationAttributes;
ConstraintAnnotationAttributes.GROUPS.validateOn(annotation.annotationType());
ConstraintAnnotationAttributes.PAYLOAD.validateOn(annotation.annotationType());
ConstraintAnnotationAttributes.MESSAGE.validateOn(annotation.annotationType());
if (method.getName().toLowerCase(Locale.ENGLISH).startsWith("valid")) {
throw new ConstraintDefinitionException(
"A constraint annotation cannot have methods which start with 'valid'");
private NodeImpl node;
node = new NodeImpl(name);
node.setInIterable(true);
return new NodeContextBuilderImpl(parent, messageTemplate, propertyPath, node);
propertyPath.addNode(node);
node = new NodeImpl(name);
propertyPath.addNode(node);
node = null;
private final NodeImpl node;
String template, PathImpl path, NodeImpl node) {
this.node = node;
node.setKey(key);
propertyPath.addNode(node);
node.setIndex(index);
propertyPath.addNode(node);
propertyPath.addNode(node);
return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, name);
propertyPath.addNode(node);
import javax.validation.Path.Node;
public static StringBuilder appendNode(Node node, StringBuilder to) {
if (node.isInIterable()) {
to.append(INDEX_OPEN);
if (node.getIndex() != null) {
to.append(node.getIndex());
} else if (node.getKey() != null) {
to.append(node.getKey());
}
to.append(INDEX_CLOSE);
}
if (node.getName() != null) {
if (to.length() > 0) {
to.append(PathImpl.PROPERTY_PATH_SEPARATOR);
}
to.append(node.getName());
}
return to;
}
public static NodeImpl atIndex(Integer index) {
NodeImpl result = new NodeImpl();
result.setIndex(index);
return result;
}
public static NodeImpl atKey(Object key) {
NodeImpl result = new NodeImpl();
result.setKey(key);
return result;
}
private String name;
private NodeImpl() {
}
public void setName(String name) {
this.name = name;
}
this.key = null;
this.index = null;
return appendNode(this, new StringBuilder()).toString();
static final String PROPERTY_PATH_SEPARATOR = ".";
private static class PathImplBuilder implements PathNavigation.Callback<PathImpl> {
PathImpl result = new PathImpl();
public void handleProperty(String name) {
result.addProperty(name);
}
public void handleIndexOrKey(String value) {
NodeImpl node;
try {
node = NodeImpl.atIndex(Integer.parseInt(value));
} catch (NumberFormatException e) {
node = NodeImpl.atKey(value);
}
result.addNode(node);
}
public PathImpl result() {
if (result.nodeList.isEmpty()) {
throw new IllegalStateException();
}
return result;
}
public void handleGenericInIterable() {
result.addNode(NodeImpl.atIndex(null));
}
}
return PathNavigation.navigateAndReturn(propertyPath, new PathImplBuilder());
if (nodeList.size() != 1) {
return false;
}
Path.Node first = nodeList.get(0);
return !first.isInIterable() && first.getName() == null;
if (isRootPath()) {
nodeList.set(0, node);
} else {
nodeList.add(node);
}
}
public void addProperty(String name) {
if (!nodeList.isEmpty()) {
NodeImpl leaf = getLeafNode();
if (leaf != null && leaf.isInIterable() && leaf.getName() == null) {
leaf.setName(name);
return;
}
}
addNode(new NodeImpl(name));
if (pathNode.isInIterable()) {
if (!thisNode.isInIterable()) {
return false;
}
if (pathNode.getIndex() != null && !pathNode.getIndex().equals(thisNode.getIndex())) {
return false;
}
if (pathNode.getKey() != null && !pathNode.getKey().equals(thisNode.getKey())) {
return false;
}
} else if (thisNode.isInIterable()) {
if (pathNode.getName() == null || pathNode.getName().equals(thisNode.getName())) {
continue;
}
return false;
for (Path.Node node : this) {
NodeImpl.appendNode(node, builder);
return !(nodeList != null && !nodeList.equals(path.nodeList)) && !(nodeList == null && path.nodeList != null);
import org.apache.bval.util.PrivilegedActions;
import org.apache.bval.jsr303.util.SecureActions;
class AnnotationProxy implements Annotation, InvocationHandler, Serializable {
if (comma)
result.append(", ");
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import javax.validation.Payload;
import javax.validation.ValidationException;
import org.apache.bval.jsr303.ConstraintAnnotationAttributes;
import org.apache.bval.jsr303.util.SecureActions;
ConstraintAnnotationAttributes.MESSAGE.put(elements, message);
ConstraintAnnotationAttributes.GROUPS.put(elements, groups);
ConstraintAnnotationAttributes.PAYLOAD.put(elements, payload);
import java.io.InputStream;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.apache.bval.jsr303.ApacheValidatorFactory;
import org.apache.bval.jsr303.ConstraintAnnotationAttributes;
import org.apache.bval.jsr303.util.EnumerationConverter;
import org.apache.bval.jsr303.util.IOUtils;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;
import org.apache.commons.beanutils.ConvertUtils;
import org.apache.commons.beanutils.Converter;
import org.apache.commons.lang3.StringUtils;
private static final Set<ConstraintAnnotationAttributes> RESERVED_PARAMS = Collections.unmodifiableSet(EnumSet.of(
ConstraintAnnotationAttributes.GROUPS, ConstraintAnnotationAttributes.MESSAGE,
ConstraintAnnotationAttributes.PAYLOAD));
for (ConstraintAnnotationAttributes attr : RESERVED_PARAMS) {
if (attr.getAttributeName().equals(name)) {
List<Class<? extends ConstraintValidator<?, ?>>> classes =
new ArrayList<Class<? extends ConstraintValidator<?, ?>>>();
import org.apache.commons.lang3.ArrayUtils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
private final Map<String, Book> taggedBooks = new HashMap<String, Book>();
if (persons == null)
return Collections.emptyList();
ArrayList<Employee> emps = new ArrayList<Employee>(persons.length);
for (Person each : persons) {
if (each instanceof Employee)
emps.add((Employee) each);
Collection<RecursiveFoo> foos = new ArrayList<RecursiveFoo>();
import org.apache.commons.lang3.ClassUtils;
public class XMLMetaBeanManager extends MetaBeanManager implements XMLMetaBeanRegistry, MetaBeanEnricher {
import org.apache.commons.lang3.ClassUtils;
@GroupSequence({Address.class, Address.HighLevelCoherence.class, Address.ExtraCareful.class })
public interface ExtraCareful {}
@NotNull
@Size(max = 50, min = 1, groups = ExtraCareful.class)
private String street1;
@NotNull
private String zipCode;
@NotNull
@Size(max = 30)
private String city;
validationContext.setMetaBean(metaBean);
bigDecimal = new BigDecimal(num.toString());
bigDecimal = bigDecimal.stripTrailingZeros();
int i = 0;
for (String each : names) {
import org.apache.commons.lang3.ArrayUtils;
return ArrayUtils.clone(factories);
this.factories = ArrayUtils.clone(factories);
import org.apache.commons.lang3.ArrayUtils;
return ArrayUtils.clone(enumConstants);
return ArrayUtils.clone(validations);
this.validations = ArrayUtils.clone(validations);
return ArrayUtils.clone(properties);
this.properties = ArrayUtils.clone(properties);
Arrays.sort(this.properties, PropertyNameComparator.INSTANCE);
for (Map.Entry<?, ?> entry : currentBean.entrySet()) {
Object value = entry.getValue();
continue;
context.setCurrentKey(entry.getKey());
if (dyn == null) {
} else {
context.setBean(value, dyn.resolveMetaBean(value));
String.format("Validation error when calling method '%s' with arguments %s",
String.format("Method '%s' returned a not valid value %s",
import org.apache.commons.lang3.ArrayUtils;
this.validatorClasses = ArrayUtils.clone(validatorClasses);
@Override
public boolean equals(Object obj) {
return super.equals(obj);
}
@Override
public int hashCode() {
return super.hashCode();
}
import static org.apache.bval.model.Features.Property.MANDATORY;
import static org.apache.bval.model.Features.Property.MAX_LENGTH;
import static org.apache.bval.model.Features.Property.MAX_VALUE;
import static org.apache.bval.model.Features.Property.MIN_LENGTH;
import static org.apache.bval.model.Features.Property.MIN_VALUE;
import static org.apache.bval.model.Features.Property.REG_EXP;
import static org.apache.bval.model.Features.Property.TIME_LAG;
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.xml.XMLMetaValue;
@SuppressWarnings("unchecked")
T result = (T) this;
return result;
@SuppressWarnings("unchecked")
T result = (T) newInstance(cls);
return result;
@SuppressWarnings({ "unchecked", "rawtypes" })
@SuppressWarnings("unused")
@SuppressWarnings("unused")
@SuppressWarnings("unused")
@SuppressWarnings("unused")
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
private static final long serialVersionUID = 1L;
private static final long serialVersionUID = 1L;
if (properties == null) properties = new ArrayList<XMLMetaProperty>();
if (beanRelations == null) beanRelations = new ArrayList<XMLMetaBeanReference>();
new LinkedHashMap<XMLMetaBeanLoader, XMLMetaBeanInfos>();
@SuppressWarnings("deprecation")
private static final long serialVersionUID = 1L;
private static final long serialVersionUID = 1L;
private static final long serialVersionUID = 1L;
private static final long serialVersionUID = 1L;
private static final long serialVersionUID = 1L;
Class<?> targetClass = BusinessObject.class;
String message() default "{org.apache.bval.extras.constraints.InetAddress.message}";
package org.apache.bval.extras.constraints.file;
package org.apache.bval.extras.constraints.file;
package org.apache.bval.extras.constraints.file;
package org.apache.bval.extras.constraints.file;
package org.apache.bval.extras.constraints.file;
package org.apache.bval.extras.constraints.file;
package org.apache.bval.extras.constraints.net;
package org.apache.bval.extras.constraints.net;
package org.apache.bval.extras.constraints.net;
package org.apache.bval.extras.constraints.net;
protected int toInt(char character, int leftPos, int rightPos) {
protected static int sumDigits(int number) {
int total = 0;
int todo = number;
while (todo > 0) {
todo  = todo / 10;
}
return total;
}
String message() default "{org.apache.bval.extras.constraints.checkdigit.ABANumber.message}";
String message() default "{org.apache.bval.extras.constraints.checkdigit.CUSIP.message}";
String message() default "{org.apache.bval.extras.constraints.file.Directory.message}";
String message() default "{org.apache.bval.extras.constraints.file.NotDirectory.message}";
String message() default "{org.apache.bval.extras.constraints.file.Symlink.message}";
String message() default "{org.apache.bval.extras.constraints.net.Domain.message}";
String message() default "{org.apache.bval.extras.constraints.net.InetAddress.message}";
extends ModulusValidator<ISBN10> {
import static java.lang.Character.getNumericValue;
int num = getNumericValue(code.charAt(idx));
public class BValVersion {
public static final String PROJECT_NAME = "Apache BVal";
InputStream in = BValVersion.class.getResourceAsStream
System.out.println(new BValVersion().toString());
import java.security.PrivilegedExceptionAction;
getUtilClass(classLoader);
private static Class<?> getUtilClass(final ClassLoader classLoader) throws Exception {
return (System.getSecurityManager() == null)
? getUtilClass0(classLoader)
: AccessController.doPrivileged(new PrivilegedExceptionAction<Class<?>>() {
public Class<?> run() throws Exception {
return getUtilClass0(classLoader);
}
});
}
private static Class<?> getUtilClass0(ClassLoader classLoader) throws Exception {
return ClassUtils.getClass(classLoader, PERSISTENCE_UTIL_CLASSNAME, true);
}
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import org.apache.commons.lang3.ClassUtils;
public static <T> T run(final PrivilegedExceptionAction<T> action) throws PrivilegedActionException, Exception {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
public static Class<?> getUtilClass(final ClassLoader classLoader, final String className) throws Exception {
return PrivilegedActions.run(new PrivilegedExceptionAction<Class<?>>() {
public Class<?> run() throws Exception {
return ClassUtils.getClass(classLoader, className, true);
}
});
}
return run(new PrivilegedAction<Object>() {
return run(new PrivilegedAction<ClassLoader>() {
import org.apache.bval.jsr303.util.SecureActions;
return SecureActions.run(SecureActions.doPrivBuildValidatorFactory(this));
}
public ValidatorFactory doPrivBuildValidatorFactory() {
import org.apache.bval.util.PrivilegedActions;
PrivilegedActions.getUtilClass(classLoader, PERSISTENCE_UTIL_CLASSNAME);
final Method[] methods = SecureActions.run(
import javax.validation.ValidatorFactory;
import org.apache.bval.jsr303.ConfigurationImpl;
public static PrivilegedAction<ValidatorFactory> doPrivBuildValidatorFactory(final ConfigurationImpl config) {
return new PrivilegedAction<ValidatorFactory>() {
public ValidatorFactory run() {
return config.doPrivBuildValidatorFactory();
}
};
private final List<ConstraintValidation<?>> validations = new ArrayList<ConstraintValidation<?>>();
public List<ConstraintValidation<?>> getValidations() {
import java.util.logging.Level;
import java.util.logging.Logger;
private static final Logger log =  Logger.getLogger(MetaBeanBuilder.class.getName());
log.log(Level.FINE, String.format("Class not found: %s", className), e);
import java.util.logging.Level;
import java.util.logging.Logger;
private static final Logger log = Logger.getLogger(AnnotationConstraintBuilder.class.getName());
log.log(Level.WARNING, String.format("Error processing annotation: %s ", constraintValidation.getAnnotation()), e);
import java.util.logging.Logger;
private static final Logger log = Logger.getLogger(ConfigurationImpl.class.getName());
import java.util.logging.Level;
import java.util.logging.Logger;
private static final Logger log = Logger.getLogger(ConstraintDefaults.class.getName());
log.log(Level.SEVERE, String.format("Cannot load %s", resource), e);
log.log(Level.WARNING, String.format("Cannot find %s", resource));
log.log(Level.SEVERE, String.format("Cannot find class %s", eachClassName), e);
import java.util.logging.Level;
import java.util.logging.Logger;
private static final Logger log = Logger.getLogger(DefaultMessageInterpolator.class.getName());
log.log(Level.FINEST, String.format("%s found", USER_VALIDATION_MESSAGES));
log.log(Level.FINEST, String.format("%s not found. Delegating to %s", USER_VALIDATION_MESSAGES, DEFAULT_VALIDATION_MESSAGES));
log.fine(message);
import java.util.logging.Level;
import java.util.logging.Logger;
protected static final Logger log = Logger.getLogger(Jsr303MetaBeanFactory.class.getName());
log.log(Level.FINEST, String.format("Default group sequence for bean %s is: %s", beanClass.getName(), groupSeq));
import java.util.logging.Level;
import java.util.logging.Logger;
private static final Logger log = Logger.getLogger(DefaultTraversableResolver.class.getName());
log.log(Level.FINEST, String.format("Found %s on classpath.", PERSISTENCE_UTIL_CLASSNAME));
log.log(Level.FINEST, String.format("Cannot find %s on classpath. All properties will per default be traversable.", PERSISTENCE_UTIL_CLASSNAME));
log.log(Level.FINEST, String.format("Instantiated an instance of %s.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME));
log.log(Level.WARNING,
String.format(
"Unable to load or instanciate JPA aware resolver %s. All properties will per default be traversable.",
JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME, e));
import java.util.logging.Level;
import java.util.logging.Logger;
private static final Logger log = Logger.getLogger(AnnotationIgnores.class.getName());
log.log(Level.FINEST, String.format("%s level annotations are getting ignored for %s.%s", type, clazz.getName(), member.getName()));
log.log(Level.FINEST, String.format("Class level annotation are getting ignored for %s", clazz.getName()));
import java.util.logging.Level;
import java.util.logging.Logger;
private static final Logger log = Logger.getLogger(ValidationParser.class.getName());
log.log(Level.FINEST, String.format("No %s found. Using annotation based configuration only.", validationXmlFile));
log.log(Level.FINEST, String.format("%s found.", validationXmlFile));
log.log(Level.WARNING, String.format("Unable to parse schema: %s", xsd), e);
if (log.isLoggable(Level.FINEST)) {
log.log(Level.FINEST, String.format("Found property '%s' with value '%s' in %s", property.getName(), property.getValue(), validationXmlFile));
log.log(Level.INFO, String.format("Using %s as validation provider.", providerClassName));
log.log(Level.INFO, String.format("Using %s as message interpolator.", messageInterpolatorClass));
log.log(Level.INFO, String.format("Using %s as traversable resolver.", traversableResolverClass));
log.log(Level.INFO, String.format("Using %s as constraint factory.", constraintFactoryClass));
log.log(Level.FINEST, String.format("Trying to open input stream for %s", mappingFileName));
import java.util.logging.Level;
import java.util.logging.Logger;
private static final Logger loggger = Logger.getLogger(XMLMetaBeanFactory.class.getName());
loggger.log(Level.SEVERE, String.format("Error loading %s", loader), e);
"Unable to load or instantiate JPA aware resolver %s. All properties will per default be traversable.",
import static org.apache.bval.model.Features.Property.JAVASCRIPT_VALIDATION_FUNCTIONS;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
private static final Logger logger = Logger.getLogger(XMLMetaBeanFactory.class.getName());
logger.log(Level.SEVERE, String.format("Error loading %s", loader), e);
public static Class<?> getClass(final ClassLoader classLoader, final String className) throws Exception {
return run(new PrivilegedExceptionAction<Class<?>>() {
PrivilegedActions.getClass(classLoader, PERSISTENCE_UTIL_CLASSNAME);
return run(new PrivilegedAction<String>() {
import java.security.AccessController;
if (!field.isAccessible()) {
run(new PrivilegedAction<Void>() {
public Void run() {
return null;
private static <T> T run(PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
import java.security.AccessController;
run( new PrivilegedAction<Void>() {
public Void run() {
return null;
private static <T> T run(PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
private static <T> T run(PrivilegedAction<T> action) {
private static <T> T run(final PrivilegedExceptionAction<T> action) throws PrivilegedActionException, Exception {
import java.security.AccessController;
run(new PrivilegedAction<Object>() {
private static <T> T run(PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
return run(new PrivilegedAction<F>() {
private static <T> T run(PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
import java.security.AccessController;
import java.security.PrivilegedAction;
return run(SecureActions.doPrivBuildValidatorFactory(this));
private static <T> T run(PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
import java.security.AccessController;
run(new PrivilegedAction<Class<?>>() {
private static <T> T run(PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
import java.security.AccessController;
import java.security.PrivilegedAction;
final Method[] methods = run(SecureActions.getDeclaredMethods(annotation.annotationType()));
private static <T> T run(PrivilegedAction<T> action) {
if (System.getSecurityManager() != null) {
return AccessController.doPrivileged(action);
} else {
return action.run();
}
}
protected void copyInto(FeaturesCapable target) {
protected void copyInto(FeaturesCapable target) {
}
(ConstraintValidator<A, ? super T>) factoryContext.getConstraintValidatorFactory()
import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.TraversableResolver;
import javax.validation.Validation;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import javax.validation.bootstrap.ProviderSpecificBootstrap;
import javax.validation.spi.ConfigurationState;
Validation.byProvider(ApacheValidationProvider.class).configure().buildValidatorFactory()
.unwrap(ApacheValidatorFactory.class);
return ApacheValidatorConfiguration.class.equals(builderClass);
if (validatorFactoryClassname == null) {
} else {
validatorFactoryClass =
ClassUtils.getClass(validatorFactoryClassname).asSubclass(ValidatorFactory.class);
? instantiateValidatorFactory(validatorFactoryClass, configuration) : AccessController
.doPrivileged(new PrivilegedAction<ValidatorFactory>() {
public ValidatorFactory run() {
return instantiateValidatorFactory(validatorFactoryClass, configuration);
}
});
final Class<? extends ValidatorFactory> validatorFactoryClass, final ConfigurationState configuration) {
try {
return validatorFactoryClass.getConstructor(ConfigurationState.class).newInstance(configuration);
} catch (final Exception ex) {
}
import org.apache.commons.lang3.ArrayUtils;
return messageResolver;
}
if (!(type.isInterface() || Modifier.isAbstract(type
try {
if (type.isAssignableFrom(cls)) {
@SuppressWarnings("unchecked")
T result = (T) newInstance(cls);
return result;
}
} catch (ClassNotFoundException e) {
}
List<MetaConstraint<?, ? extends Annotation>> slot;
synchronized (constraintMap) {
slot = constraintMap.get(beanClass);
if (slot == null) {
slot = new ArrayList<MetaConstraint<?, ? extends Annotation>>();
constraintMap.put(beanClass, slot);
}
slot.add(metaConstraint);
List<AccessStrategy> slot;
synchronized (validAccesses) {
slot = validAccesses.get(beanClass);
if (slot == null) {
slot = new ArrayList<AccessStrategy>();
validAccesses.put(beanClass, slot);
}
slot.add(accessStrategy);
public void addDefaultSequence(Class<?> beanClass, Class<?>... groupSequence) {
defaultSequences.put(beanClass, safeArray(groupSequence));
final List<MetaConstraint<?, ? extends Annotation>> slot = constraintMap.get(beanClass);
if (slot == null) {
return Collections.emptyList();
@SuppressWarnings({ "unchecked", "rawtypes" })
final List<MetaConstraint<T, ? extends Annotation>> result = (List) slot;
return Collections.unmodifiableList(result);
final List<AccessStrategy> slot = validAccesses.get(beanClass);
return slot == null ? Collections.<AccessStrategy> emptyList() : Collections.unmodifiableList(slot);
return safeArray(defaultSequences.get(beanClass));
private static Class<?>[] safeArray(Class<?>... array) {
return ArrayUtils.isEmpty(array) ? ArrayUtils.EMPTY_CLASS_ARRAY : ArrayUtils.clone(array);
}
log.config("ignoreXmlConfiguration == true");
return getFeature(key, null);
target.validations = ArrayUtils.clone(validations);
if (this.validations == null) {
this.validations = new Validation[] { validation };
} else {
System.arraycopy(this.validations, 0, newValidations, 0, this.validations.length);
newValidations[validations.length] = validation;
this.validations = newValidations;
}
import java.util.Map;
import java.util.TreeMap;
private static final long serialVersionUID = 2L;
private Map<String, MetaProperty> properties = new TreeMap<String, MetaProperty>();
return properties.values().toArray(new MetaProperty[this.properties.size()]);
this.properties.clear();
for (MetaProperty property : properties) {
this.properties.put(property.getName(), property);
}
return this.properties.get(name);
for (MetaProperty property : this.properties.values()) {
if (property.isRelationship()) {
return this.properties.size() > 0;
if (property == null) {
this.properties.remove(name);
} else {
this.properties.put(name, property);
copy.properties = new TreeMap<String, MetaProperty>();
for (Map.Entry<String, MetaProperty> entry : properties.entrySet()) {
copy.properties.put(entry.getKey(), (MetaProperty) entry.getValue().copy());
System.arraycopy(strategies, 0, newStrategies, 0, strategies.length);
newStrategies[strategies.length] = access;
prop.putFeature(Features.Property.REF_CASCADE, newStrategies);
return getFeature(key, (T) null);
boolean endOutMostReportAsSingle = (--compositeDepth == 0);
if( endOutMostReportAsSingle ) {
hasCompositeError = false;
}
return endOutMostReportAsSingle;
@FrenchZipCode
String zipCode2 = "123456";
public void moveDown(String prop) {
}
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Comparator;
public int compare(final String o1, final String o2) {
return fieldIndex(o1) - fieldIndex(o2);
}
private int fieldIndex(final String o2) {
final Class<?> clazz = getBeanClass();
int i = 0;
Class<?> beanClass1 = clazz;
while (beanClass1 != null && beanClass1 != Object.class) {
for (final Field f : beanClass1.getDeclaredFields()) {
i;
if (f.getName().equals(o2)) {
return i;
}
}
beanClass1 = beanClass1.getSuperclass();
}
if (clazz != null) {
for (final Method m : clazz.getMethods()) {
i;
if (m.getName().equals(getter) && m.getParameterTypes().length == 0) {
return i;
}
}
}
}
});
private Map<Method, MetaMethod> methods = new TreeMap<Method, MetaMethod>(new Comparator<Method>() {
public int compare(final Method o1, final Method o2) {
final int i = o1.getName().compareTo(o2.getName());
if (i != 0) {
return i;
}
return Arrays.hashCode(o1.getParameterTypes()) - Arrays.hashCode(o2.getParameterTypes());
}
});
private Map<Constructor<?>, MetaConstructor> constructors = new TreeMap<Constructor<?>, MetaConstructor>(new Comparator<Constructor<?>>() {
public int compare(final Constructor<?> o1, final Constructor<?> o2) {
return Arrays.hashCode(o1.getParameterTypes()) - Arrays.hashCode(o2.getParameterTypes());
}
});
public MetaMethod[] getMethods() {
return methods.values().toArray(new MetaMethod[this.methods.size()]);
}
public void addMethod(final Method method, final MetaMethod meta) {
methods.put(method, meta);
}
public MetaConstructor[] getConstructors() {
return constructors.values().toArray(new MetaConstructor[this.constructors.size()]);
}
public void addConstructor(final Constructor<?> constructor, final MetaConstructor meta) {
constructors.put(constructor, meta);
}
public MetaMethod getMethod(final Method method) {
return methods.get(method);
}
public MetaConstructor getConstructor(final Constructor<?> constructor) {
return constructors.get(constructor);
}
import java.lang.reflect.Type;
public class MetaProperty extends Meta
void moveDown(String prop);
import org.apache.bval.model.ValidationContext;
import javax.validation.executable.ExecutableType;
import java.util.Collections;
configuration.setExecutableValidation(Collections.<ExecutableType>singleton(ExecutableType.ALL));
public void releaseInstance(ConstraintValidator<?, ?> instance) {
}
import javax.validation.executable.ExecutableValidator;
ExecutableValidator methodValidator = validator.forExecutables();
constraintViolations.addAll(methodValidator.validateParameters(invocation.getThis(),
constraintViolations.addAll(methodValidator.validateReturnValue(invocation.getThis(), method, returnedValue, groups));
public class SizeValidatorForCharSequence extends SizeValidator
implements ConstraintValidator<Size, CharSequence> {
public boolean isValid(CharSequence s, ConstraintValidatorContext context) {
import org.apache.bval.jsr303.groups.GroupsComputer;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.jsr303.xml.AnnotationProxyBuilder;
import org.apache.bval.util.AccessStrategy;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.validation.Constraint;
import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintDefinitionException;
import javax.validation.ConstraintTarget;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import javax.validation.OverridesAttribute;
import javax.validation.Payload;
import javax.validation.ReportAsSingleViolation;
import javax.validation.constraintvalidation.SupportedValidationTarget;
import javax.validation.constraintvalidation.ValidationTarget;
ConstraintValidator<A, ?> constraintValidator, A annotation, Class<?> owner, AccessStrategy access,
ConstraintTarget target, RuntimeException missingValidatorException) {
reportFromComposite, target, missingValidatorException);
final String name = method.getName();
if (ConstraintAnnotationAttributes.PAYLOAD.getAttributeName().equals(name)) {
} else if (ConstraintAnnotationAttributes.GROUPS.getAttributeName().equals(name)) {
} else if (ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getAttributeName().equals(name)) {
buildValidationAppliesTo(method);
} else if (name.startsWith("valid")) {
constraintValidation.getAttributes().put(name, method.invoke(constraintValidation.getAnnotation()));
} catch (final ConstraintDefinitionException cde) {
throw cde;
final Constraint annotation = constraintValidation.getAnnotation().annotationType().getAnnotation(Constraint.class);
if (annotation == null) {
return null;
}
final Pair validationTarget = computeValidationTarget(annotation.validatedBy());
for (final Annotation a : constraintValidation.getAnnotation().annotationType().getAnnotations()) {
final Constraint inheritedConstraint = a.annotationType().getAnnotation(Constraint.class);
if (inheritedConstraint != null && !a.annotationType().getName().startsWith("javax.validation.constraints.")) {
final Pair validationTargetInherited = computeValidationTarget(inheritedConstraint.validatedBy());
if ((validationTarget.a > 0 && validationTargetInherited.b > 0 && validationTarget.b == 0)
|| (validationTarget.b > 0 && validationTargetInherited.a > 0 && validationTarget.a == 0)) {
throw new ConstraintDefinitionException("Parent and child constraint have different targets");
}
}
}
private Pair computeValidationTarget(final Class<?>[] validators) {
int param = 0;
int annotatedElt = 0;
for (final Class<?> validator : validators) {
final SupportedValidationTarget supportedAnnotationTypes = validator.getAnnotation(SupportedValidationTarget.class);
if (supportedAnnotationTypes != null) {
final List<ValidationTarget> values = Arrays.asList(supportedAnnotationTypes.value());
if (values.contains(ValidationTarget.PARAMETERS)) {
}
if (values.contains(ValidationTarget.ANNOTATED_ELEMENT)) {
}
} else {
}
}
throw new ConstraintDefinitionException("pure cross parameter constraints shouldn't get validationAppliesTo attribute");
} else {
throw new ConstraintDefinitionException("cross parameter AND generic constraints should get validationAppliesTo attribute");
throw new ConstraintDefinitionException("pure generic constraints shouldn't get validationAppliesTo attribute");
}
}
return new Pair(annotatedElt, param);
}
private void buildValidationAppliesTo(final Method method) throws InvocationTargetException, IllegalAccessException {
final Object validationAppliesTo = method.invoke(constraintValidation.getAnnotation());
if (ConstraintTarget.class.isInstance(validationAppliesTo)) {
constraintValidation.setValidationAppliesTo(ConstraintTarget.class.cast(validationAppliesTo));
} else {
}
}
if (constraintValidation.getValidationAppliesTo() != null) {
composite.setValidationAppliesTo(constraintValidation.getValidationAppliesTo());
}
private static class Pair {
private int a;
private int b;
private Pair(int a, int b) {
this.a = a;
this.b = b;
}
}
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.GroupConversionDescriptorImpl;
import org.apache.bval.jsr303.util.ConstraintDefinitionValidator;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.model.Features;
import org.apache.bval.model.Meta;
import org.apache.bval.model.MetaBean;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.PropertyAccess;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.reflect.TypeUtils;
import javax.validation.Constraint;
import javax.validation.ConstraintDefinitionException;
import javax.validation.ConstraintValidator;
import javax.validation.UnexpectedTypeException;
import javax.validation.Valid;
import javax.validation.ValidationException;
import javax.validation.constraintvalidation.SupportedValidationTarget;
import javax.validation.constraintvalidation.ValidationTarget;
import javax.validation.groups.ConvertGroup;
import javax.validation.groups.Default;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
public boolean processAnnotations(Meta prop, Class<?> owner, AnnotatedElement element,
changed |= processAnnotation(annotation, prop, owner, access, appender, true);
return processAnnotation(annotation, null, owner, null, appender, true);
public <A extends Annotation> boolean processAnnotation(A annotation, Meta prop, Class<?> owner,
AccessStrategy access, AppendValidation appender, boolean reflection) throws IllegalAccessException, InvocationTargetException {
if (ConvertGroup.class.isInstance(annotation) || ConvertGroup.List.class.isInstance(annotation)) {
if (!reflection) {
Collection<Annotation> annotations = prop.getFeature(Jsr303Features.Property.ANNOTATIONS_TO_PROCESS);
if (annotations == null) {
annotations = new ArrayList<Annotation>();
prop.putFeature(Jsr303Features.Property.ANNOTATIONS_TO_PROCESS, annotations);
}
annotations.add(annotation);
}
return true;
}
final Object result = SecureActions.getAnnotationValue(annotation, ConstraintAnnotationAttributes.VALUE.getAttributeName());
for (final Annotation each : (Annotation[]) result) {
changed |= processAnnotation(each, prop, owner, access, appender, reflection);
public boolean addAccessStrategy(Meta prop, AccessStrategy access) {
Class<? extends ConstraintValidator<A, ?>>[] rawConstraintClasses, Meta prop, Class<?> owner,
final Class<? extends ConstraintValidator<A, ?>>[] constraintClasses = select(rawConstraintClasses, access);
if (constraintClasses != null && constraintClasses.length == 0 && rawConstraintClasses.length > 0) {
return false;
}
RuntimeException missingValidatorException = null;
ConstraintValidator<A, ?> validator = null;
try {
validator = getConstraintValidator(annotation, constraintClasses, owner, access);
} catch (final RuntimeException e) {
missingValidatorException = e;
}
new AnnotationConstraintBuilder<A>(constraintClasses, validator, annotation, owner, access, null, missingValidatorException);
private static <A extends Annotation> Class<? extends ConstraintValidator<A, ?>>[] select(
final Class<? extends ConstraintValidator<A, ?>>[] rawConstraintClasses, final AccessStrategy access) {
final boolean isReturn = ReturnAccess.class.isInstance(access);
final boolean isParam = ParametersAccess.class.isInstance(access);
if (rawConstraintClasses != null && (isReturn || isParam)) {
final Collection<Class<? extends ConstraintValidator<A, ?>>> selected = new ArrayList<Class<? extends ConstraintValidator<A, ?>>>();
for (final Class<? extends ConstraintValidator<A, ?>> constraint : rawConstraintClasses) {
final SupportedValidationTarget target = constraint.getAnnotation(SupportedValidationTarget.class);
if (target == null && isReturn) {
selected.add(constraint);
} else if (target != null) {
for (final ValidationTarget validationTarget : target.value()) {
if (isReturn && ValidationTarget.ANNOTATED_ELEMENT.equals(validationTarget)) {
selected.add(constraint);
} else if (isParam && ValidationTarget.PARAMETERS.equals(validationTarget)) {
selected.add(constraint);
}
}
}
}
return selected.toArray(new Class[selected.size()]);
}
return rawConstraintClasses;
}
final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validatorTypes = getValidatorsTypes(constraintClasses);
reduceTarget(validatorTypes, access);
if ((type == Object.class || type == Object[].class) && validatorTypes.containsKey(Object.class) && validatorTypes.containsKey(Object[].class)) {
throw new ConstraintDefinitionException("Only a validator for Object or Object[] should be provided for cross parameter validators");
}
final Collection<Class<? extends ConstraintValidator<A, ?>>> key = validatorTypes.get(assignableTypes.get(0));
if (key.size() > 1) {
throw new ConstraintDefinitionException(message);
}
throw new UnexpectedTypeException(message);
}
final ConstraintValidator<A, ? super T> validator = (ConstraintValidator<A, ? super T>) factoryContext.getConstraintValidatorFactory().getInstance(key.iterator().next());
private <A extends Annotation> void reduceTarget(final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validator, final AccessStrategy access) {
for (final Map.Entry<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> entry : validator.entrySet()) {
final Collection<Class<? extends ConstraintValidator<A, ?>>> validators = entry.getValue();
final Iterator<Class<? extends ConstraintValidator<A, ?>>> it = validators.iterator();
while (it.hasNext()) {
final Type v = it.next();
if (!Class.class.isInstance(v)) {
}
final Class<?> clazz = Class.class.cast(v);
final SupportedValidationTarget target = clazz.getAnnotation(SupportedValidationTarget.class);
if (target != null) {
final Collection<ValidationTarget> targets = Arrays.asList(target.value());
final boolean isParameter = ParameterAccess.class.isInstance(access) || ParametersAccess.class.isInstance(access);
if ((isParameter && !targets.contains(ValidationTarget.PARAMETERS))
|| (!isParameter && !targets.contains(ValidationTarget.ANNOTATED_ELEMENT))) {
it.remove();
}
}
}
if (validators.isEmpty()) {
validator.remove(entry.getKey());
}
}
}
throw new ConstraintDefinitionException(message);
}
throw new UnexpectedTypeException(message);
for (final Type validatorType : validatorsTypes) {
private static <A extends Annotation> Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> getValidatorsTypes(
final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validatorsTypes = new HashMap<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>>();
Type validatedType = TypeUtils.getTypeArguments(validatorType, ConstraintValidator.class).get(ConstraintValidator.class.getTypeParameters()[1]);
if (!validatorsTypes.containsKey(validatedType)) {
validatorsTypes.put(validatedType, new ArrayList<Class<? extends ConstraintValidator<A, ?>>>());
}
validatorsTypes.get(validatedType).add(validatorType);
import javax.validation.ParameterNameProvider;
private ParameterNameProvider parameterNameProvider;
public ValidatorContext parameterNameProvider(ParameterNameProvider parameterNameProvider) {
this.parameterNameProvider = parameterNameProvider;
return this;
}
public ParameterNameProvider getParameterNameProvider() {
return parameterNameProvider == null ? factory.getParameterNameProvider() : parameterNameProvider;
}
String EXECUTABLE_VALIDATION_TYPES = "apache.bval.executable-validation.types";
import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.ParameterNameProvider;
import javax.validation.TraversableResolver;
import javax.validation.Validation;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import javax.validation.executable.ExecutableType;
import javax.validation.spi.ConfigurationState;
import java.io.Closeable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
private static final ConstraintDefaults defaultConstraints = new ConstraintDefaults();
private ParameterNameProvider parameterNameProvider;
private final Collection<ExecutableType> executableTypes = new CopyOnWriteArrayList<ExecutableType>();
private final Collection<Closeable> toClose = new ArrayList<Closeable>();
DEFAULT_FACTORY = Validation.byProvider(ApacheValidationProvider.class).configure()
.buildValidatorFactory().unwrap(ApacheValidatorFactory.class);
constraintMap = new HashMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>>();
setParameterNameProvider(configuration.getParameterNameProvider());
setConstraintValidatorFactory(configuration.getConstraintValidatorFactory());
if (ConfigurationImpl.class.isInstance(configuration)) {
final ConfigurationImpl impl = ConfigurationImpl.class.cast(configuration);
executableTypes.addAll(impl.getExecutableValidation());
toClose.add(impl.getClosable());
} else {
final String executableTypesStr = getProperties().get(ApacheValidatorConfiguration.Properties.EXECUTABLE_VALIDATION_TYPES);
if (executableTypesStr != null && !executableTypesStr.isEmpty()) {
for (final String s : executableTypesStr.split(",")) {
executableTypes.add(ExecutableType.valueOf(s.trim()));
}
}
}
new ValidationMappingParser(this).processMappingConfig(configuration.getMappingStreams());
if (messageResolver != null) {
this.messageResolver = messageResolver;
}
if (traversableResolver != null) {
this.traversableResolver = traversableResolver;
}
}
public void setParameterNameProvider(final ParameterNameProvider parameterNameProvider) {
if (parameterNameProvider != null) {
this.parameterNameProvider = parameterNameProvider;
}
if (constraintValidatorFactory != null) {
this.constraintValidatorFactory = constraintValidatorFactory;
if (DefaultConstraintValidatorFactory.class.isInstance(constraintValidatorFactory)) {
toClose.add(Closeable.class.cast(constraintValidatorFactory));
}
}
public ParameterNameProvider getParameterNameProvider() {
return parameterNameProvider;
}
public void close() {
try {
for (final Closeable c : toClose) {
c.close();
}
toClose.clear();
} catch (final Exception e) {
}
}
return (T) this;
public void addMetaConstraint(final Class<?> beanClass,
final MetaConstraint<?, ?> metaConstraint) {
public Collection<ExecutableType> getExecutableTypes() {
return executableTypes;
}
package org.apache.bval.jsr303;
import org.apache.bval.Validate;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.groups.GroupConversionDescriptorImpl;
import org.apache.bval.jsr303.util.ClassHelper;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.model.MetaConstructor;
import org.apache.bval.model.MetaMethod;
import org.apache.bval.model.MetaParameter;
import org.apache.bval.model.Validation;
import org.apache.bval.util.AccessStrategy;
import org.apache.commons.lang3.ClassUtils;
import javax.validation.Constraint;
import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintTarget;
import javax.validation.Valid;
import javax.validation.groups.ConvertGroup;
import javax.validation.metadata.ConstructorDescriptor;
import javax.validation.metadata.ExecutableDescriptor;
import javax.validation.metadata.GroupConversionDescriptor;
import javax.validation.metadata.MethodDescriptor;
import javax.validation.metadata.MethodType;
import javax.validation.metadata.ParameterDescriptor;
import javax.validation.metadata.ReturnValueDescriptor;
import java.beans.Introspector;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArraySet;
private static final CopyOnWriteArraySet<ConstraintValidation<?>> NO_CONSTRAINTS = new CopyOnWriteArraySet<ConstraintValidation<?>>();
private final AnnotationProcessor annotationProcessor;
private Set<ConstructorDescriptor> constrainedConstructors = new CopyOnWriteArraySet<ConstructorDescriptor>();
private Map<Method, MethodDescriptor> methodConstraints = new HashMap<Method, MethodDescriptor>();
private Set<MethodDescriptor> containedMethods = new CopyOnWriteArraySet<MethodDescriptor>();
private Map<Constructor<?>, ConstructorDescriptor> contructorConstraints = new HashMap<Constructor<?>, ConstructorDescriptor>();
this.annotationProcessor = new AnnotationProcessor(factoryContext);
buildExecutableDescriptors();
}
private static void addGroupConvertion(final MetaProperty prop, final PropertyDescriptorImpl edesc) {
boolean fieldFound = false;
boolean methodFound = false;
Class<?> current = prop.getParentMetaBean().getBeanClass();
while (current != null && current != Object.class && (!methodFound || !fieldFound)) {
if (!fieldFound) {
final Field field = SecureActions.getDeclaredField(current, prop.getName()).run();
if (field != null) {
final ConvertGroup.List convertGroupList = field.getAnnotation(ConvertGroup.List.class);
if (convertGroupList != null) {
for (final ConvertGroup convertGroup : convertGroupList.value()) {
edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
}
}
final ConvertGroup convertGroup = field.getAnnotation(ConvertGroup.class);
if (convertGroup != null) {
edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
}
fieldFound = true;
}
}
if (!methodFound) {
for (final Method method : Arrays.asList(
if (method != null) {
final ConvertGroup.List convertGroupList = method.getAnnotation(ConvertGroup.List.class);
if (convertGroupList != null) {
for (final ConvertGroup convertGroup : convertGroupList.value()) {
edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
}
}
final ConvertGroup convertGroup = method.getAnnotation(ConvertGroup.class);
if (convertGroup != null) {
edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
}
methodFound = true;
break;
}
}
}
current = current.getSuperclass();
}
final Collection<Annotation> annotations = prop.getFeature(Jsr303Features.Property.ANNOTATIONS_TO_PROCESS);
if (annotations != null) {
for (final Annotation a : annotations) {
if (ConvertGroup.List.class.isInstance(a)) {
for (final ConvertGroup convertGroup : ConvertGroup.List.class.cast(a).value()) {
edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
}
}
if (ConvertGroup.class.isInstance(a)) {
final ConvertGroup convertGroup = ConvertGroup.class.cast(a);
edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
}
}
annotations.clear();
}
if (!edesc.getGroupConversions().isEmpty() && !edesc.isCascaded()) {
throw new ConstraintDeclarationException("@Valid is needed for group conversion");
}
addGroupConvertion(prop, edesc);
|| (prop.getMetaBean() != null || prop.getFeature(Features.Property.REF_CASCADE) != null)) {
public MethodDescriptor getConstraintsForMethod(String methodName, Class<?>... parameterTypes) {
if (methodName == null) {
throw new IllegalArgumentException("Method name can't be null");
}
Class<?> beanClass = metaBean.getBeanClass();
Method method = null;
do {
try {
method = beanClass.getDeclaredMethod(methodName, parameterTypes);
break;
} catch (final NoSuchMethodException e) {
}
beanClass = beanClass.getSuperclass();
} while (beanClass != Object.class && beanClass != null);
if (method == null) {
return null;
}
final MethodDescriptor descriptor = methodConstraints.get(method);
if (descriptor != null) {
final boolean hasConstraint = descriptor.hasConstrainedParameters() || descriptor.hasConstrainedReturnValue();
if (!hasConstraint) {
return null;
}
return descriptor;
}
for (final MetaMethod metaMethod : metaBean.getMethods()) {
if (metaMethod.getMethod().equals(method)) {
final MethodDescriptorImpl methodDescriptor = createMethodDescriptor(metaMethod);
ensureNotNullDescriptors(metaMethod.getMethod().getReturnType(), methodDescriptor);
methodConstraints.put(method, methodDescriptor);
containedMethods.add(methodDescriptor);
return methodDescriptor;
}
}
return null;
}
private MethodDescriptorImpl createMethodDescriptor(final MetaMethod metaMethod) {
MethodDescriptorImpl edesc = metaMethod.getFeature(Jsr303Features.Method.MethodDescriptor);
if (edesc == null) {
edesc = new MethodDescriptorImpl(metaBean, metaMethod);
metaMethod.putFeature(Jsr303Features.Method.MethodDescriptor, edesc);
}
return edesc;
}
public Set<MethodDescriptor> getConstrainedMethods(MethodType methodType, MethodType... methodTypes) {
final Set<MethodDescriptor> desc = new HashSet<MethodDescriptor>();
desc.addAll(filter(containedMethods, methodType));
if (methodTypes != null) {
for (final MethodType type : methodTypes) {
desc.addAll(filter(containedMethods, type));
}
}
return desc;
}
private static Collection<MethodDescriptor> filter(final Set<MethodDescriptor> containedMethods, final MethodType type) {
final Collection<MethodDescriptor> list = new ArrayList<MethodDescriptor>();
for (final MethodDescriptor d : containedMethods) {
final boolean getter = d.getName().startsWith("get") && d.getParameterDescriptors().isEmpty();
switch (type) {
case GETTER:
if (getter) {
list.add(d);
}
break;
case NON_GETTER:
if (!getter) {
list.add(d);
}
}
}
return list;
}
public ConstructorDescriptor getConstraintsForConstructor(Class<?>... parameterTypes) {
final Constructor<?> declaredConstructor;
try {
declaredConstructor = metaBean.getBeanClass().getDeclaredConstructor(parameterTypes);
} catch (final NoSuchMethodException e) {
return null;
}
final ConstructorDescriptor descriptor = contructorConstraints.get(declaredConstructor);
if (descriptor != null && (descriptor.hasConstrainedParameters() || descriptor.hasConstrainedReturnValue())) {
return descriptor;
}
return null;
}
public Set<ConstructorDescriptor> getConstrainedConstructors() {
return constrainedConstructors;
}
public void buildExecutableDescriptors() {
try {
buildMethodConstraints();
setConstrained(containedMethods, methodConstraints.values());
buildConstructorConstraints();
setConstrained(constrainedConstructors, contructorConstraints.values());
} catch (final Exception ex) {
if (RuntimeException.class.isInstance(ex)) {
throw RuntimeException.class.cast(ex);
}
throw new IllegalArgumentException(ex.getMessage(), ex);
}
}
private <A extends ExecutableDescriptor> void setConstrained(final Set<A> dest, final Collection<A> src) {
for (final A d : src) {
if (d.hasConstrainedParameters() || d.hasConstrainedReturnValue()) {
dest.add(d);
}
}
}
private void buildConstructorConstraints() throws InvocationTargetException, IllegalAccessException {
for (final Constructor<?> cons : SecureActions.getDeclaredConstructors(getMetaBean().getBeanClass()).run()) {
final ConstructorDescriptorImpl consDesc = new ConstructorDescriptorImpl(getMetaBean(), new Validation[0]);
contructorConstraints.put(cons, consDesc);
final List<String> names = factoryContext.getParameterNameProvider().getParameterNames(cons);
final boolean isInnerClass = cons.getDeclaringClass().getEnclosingClass() != null && !Modifier.isStatic(cons.getDeclaringClass().getModifiers());
{
final Annotation[][] paramsAnnos = cons.getParameterAnnotations();
int idx = 0;
final ParameterDescriptorImpl paramDesc = new ParameterDescriptorImpl(getMetaBean(), new Validation[0], names.get(idx));
consDesc.getParameterDescriptors().add(paramDesc);
}
for (final Annotation[] paramAnnos : paramsAnnos) {
if (factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnParameter(cons, idx)) {
consDesc.getParameterDescriptors().add(new ParameterDescriptorImpl(metaBean, new Validation[0], names.get(idx)));
} else if (cons.getParameterTypes().length > idx) {
ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
consDesc.addValidations(processAnnotations(consDesc, paramAnnos, access, idx, names.get(idx)).getValidations());
}
if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(cons)) {
for (final Annotation anno : cons.getAnnotations()) {
if (!Valid.class.isInstance(anno)) {
processAnnotations(null, consDesc, cons.getDeclaringClass(), anno);
} else {
consDesc.setCascaded(true);
}
}
}
}
if (factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnCrossParameter(cons) && consDesc.getCrossParameterDescriptor() != null) {
consDesc.setCrossParameterDescriptor(null);
}
if (factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnReturn(cons) && consDesc.getReturnValueDescriptor() != null) {
consDesc.setReturnValueDescriptor(null);
}
final MetaConstructor metaConstructor = metaBean.getConstructor(cons);
if (metaConstructor != null) {
for (final Annotation anno : metaConstructor.getAnnotations()) {
if (!Valid.class.isInstance(anno)) {
processAnnotations(null, consDesc, cons.getDeclaringClass(), anno);
} else {
consDesc.setCascaded(true);
}
}
final Collection<MetaParameter> paramsAnnos = metaConstructor.getParameters();
for (final MetaParameter paramAnnos : paramsAnnos) {
final int idx = paramAnnos.getIndex();
final ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
processAnnotations(consDesc, paramAnnos.getAnnotations(), access, idx, names.get(idx));
}
}
if (!consDesc.getGroupConversions().isEmpty() && !consDesc.isCascaded()) {
throw new ConstraintDeclarationException("@Valid is needed to define a group conversion");
}
ensureNotNullDescriptors(cons.getDeclaringClass(), consDesc);
}
}
private void ensureNotNullDescriptors(final Class<?> returnType, final InvocableElementDescriptor consDesc) {
if (consDesc.getCrossParameterDescriptor() == null) {
consDesc.setCrossParameterDescriptor(new CrossParameterDescriptorImpl(getMetaBean(), NO_CONSTRAINTS));
}
if (consDesc.getReturnValueDescriptor() == null) {
consDesc.setReturnValueDescriptor(new ReturnValueDescriptorImpl(getMetaBean(), returnType, NO_CONSTRAINTS, consDesc.isCascaded()));
}
final ReturnValueDescriptorImpl returnValueDescriptor = ReturnValueDescriptorImpl.class.cast(consDesc.getReturnValueDescriptor());
returnValueDescriptor.setCascaded(consDesc.isCascaded());
if (returnValueDescriptor.getGroupConversions().isEmpty()) {
for (final GroupConversionDescriptor c : consDesc.getGroupConversions()) {
returnValueDescriptor.addGroupConversion(c);
}
}
}
private void processAnnotations(final Method mtd, final InvocableElementDescriptor consDesc, final Class<?> clazz, final Annotation anno) throws InvocationTargetException, IllegalAccessException {
if (mtd == null || !factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnReturn(mtd)) {
final ReturnAccess returnAccess = new ReturnAccess(clazz);
final AppendValidationToList validations = new AppendValidationToList();
processAnnotation(anno, consDesc, returnAccess, validations);
final List<ConstraintValidation<?>> list = removeFromListValidationAppliesTo(validations.getValidations(), ConstraintTarget.PARAMETERS);
consDesc.addValidations(list);
ReturnValueDescriptorImpl returnValueDescriptor = ReturnValueDescriptorImpl.class.cast(consDesc.getReturnValueDescriptor());
if (consDesc.getReturnValueDescriptor() != null) {
returnValueDescriptor.getMutableConstraintDescriptors().addAll(list);
} else {
returnValueDescriptor = new ReturnValueDescriptorImpl(getMetaBean(), clazz, list, consDesc.isCascaded());
consDesc.setReturnValueDescriptor(returnValueDescriptor);
}
}
if (mtd == null || !factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnCrossParameter(mtd)) {
final ParametersAccess parametersAccess = new ParametersAccess();
final AppendValidationToList validations = new AppendValidationToList();
processAnnotation(anno, consDesc, parametersAccess, validations);
final List<ConstraintValidation<?>> list = removeFromListValidationAppliesTo(validations.getValidations(), ConstraintTarget.RETURN_VALUE);
consDesc.addValidations(list);
if (consDesc.getCrossParameterDescriptor() != null) {
CrossParameterDescriptorImpl.class.cast(consDesc.getCrossParameterDescriptor()).getMutableConstraintDescriptors().addAll(list);
} else {
consDesc.setCrossParameterDescriptor(new CrossParameterDescriptorImpl(getMetaBean(), list));
}
}
}
private static List<ConstraintValidation<?>> removeFromListValidationAppliesTo(final List<ConstraintValidation<?>> validations, final ConstraintTarget constraint) {
final Iterator<ConstraintValidation<?>> i = validations.iterator();
while (i.hasNext()) {
if (constraint.equals(i.next().getValidationAppliesTo())) {
i.remove();
}
}
return validations;
}
private void buildMethodConstraints() throws InvocationTargetException, IllegalAccessException {
Class<?> current = getMetaBean().getBeanClass();
do {
for (final Method method : current.getDeclaredMethods()) {
final boolean getter = method.getName().startsWith("get") && method.getParameterTypes().length == 0;
final MethodDescriptorImpl methodDesc = new MethodDescriptorImpl(getMetaBean(), new Validation[0], method);
methodConstraints.put(method, methodDesc);
final List<Class<?>> classHierarchy = new ArrayList<Class<?>>();
ClassHelper.fillFullClassHierarchyAsList(classHierarchy, current);
classHierarchy.remove(current);
final Collection<Method> parents = new ArrayList<Method>();
for (final Class<?> clazz : classHierarchy) {
final Method overriden = SecureActions.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes()).run();
if (overriden != null) {
processMethod(overriden, methodDesc);
parents.add(overriden);
}
}
processMethod(method, methodDesc);
ensureNotNullDescriptors(method.getReturnType(), methodDesc);
if (parents != null) {
if (parents.size() > 1) {
for (final Method parent : parents) {
final InvocableElementDescriptor elementDescriptor = InvocableElementDescriptor.class.cast(factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes()));
if (elementDescriptor != null) {
ensureNoParameterConstraint(elementDescriptor, "Parameter constraints can't be defined for parallel interfaces/parents");
} else {
ensureMethodDoesntDefineParameterConstraint(methodDesc);
}
ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parent, "Return value constraints should be the same for parent and children");
}
} else if (!parents.isEmpty()) {
final Method parent = parents.iterator().next();
ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parent, "Return value constraints should be at least the same for parent and children");
final MethodDescriptor parentDesc = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
if (parentDesc != null) {
final Iterator<ParameterDescriptor> parentPd = parentDesc.getParameterDescriptors().iterator();
for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
final ParameterDescriptor next = parentPd.next();
if (pd.getConstraintDescriptors().size() != next.getConstraintDescriptors().size()) {
throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
}
throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
}
}
} else {
ensureMethodDoesntDefineParameterConstraint(methodDesc);
}
}
final Class<?>[] interfaces = method.getDeclaringClass().getInterfaces();
final Collection<Method> itfWithThisMethod = new ArrayList<Method>();
for (final Class<?> i : interfaces) {
final Method m = SecureActions.getDeclaredMethod(i, method.getName(), method.getParameterTypes()).run();
if (m != null) {
itfWithThisMethod.add(m);
}
}
if (itfWithThisMethod.size() > 1) {
for (final Method m : itfWithThisMethod) {
ensureNoConvertGroup(m, "ConvertGroup can't be used in parallel interfaces");
}
} else if (itfWithThisMethod.size() == 1) {
ensureNoConvertGroup(itfWithThisMethod.iterator().next(), "ConvertGroup can't be used in interface AND parent class");
}
int returnValid = 0;
if (method.getAnnotation(Valid.class) != null) {
}
for (final Class<?> clazz : classHierarchy) {
final Method overriden = SecureActions.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes()).run();
if (overriden != null) {
if (overriden.getAnnotation(Valid.class) != null) {
}
}
}
if (returnValid > 1 && !(interfaces.length == returnValid && method.getAnnotation(Valid.class) == null)) {
throw new ConstraintDeclarationException("@Valid on returned value can't be set more than once");
}
}
if (getter) {
final MetaProperty prop = metaBean.getProperty(Introspector.decapitalize(method.getName().substring(3)));
if (prop != null && prop.getFeature(Features.Property.REF_CASCADE) != null) {
methodDesc.setCascaded(true);
}
}
if (!methodDesc.getGroupConversions().isEmpty() && !methodDesc.isCascaded()) {
throw new ConstraintDeclarationException("@Valid is needed to define a group conversion");
}
}
current = current.getSuperclass();
} while (current != null && current != Object.class);
}
private void ensureMethodDoesntDefineParameterConstraint(MethodDescriptorImpl methodDesc) {
for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
if (!pd.getConstraintDescriptors().isEmpty()) {
throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
}
throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
}
}
}
private void ensureNoReturnValueAddedInChild(final ReturnValueDescriptor returnValueDescriptor, final Method parent, final String msg) {
final MethodDescriptor parentDesc = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
if (parentDesc == null) {
return;
}
final ReturnValueDescriptor parentReturnDesc = parentDesc.getReturnValueDescriptor();
if (parentReturnDesc.isCascaded() && !returnValueDescriptor.isCascaded() || parentReturnDesc.getConstraintDescriptors().size() > returnValueDescriptor.getConstraintDescriptors().size()) {
throw new ConstraintDeclarationException(msg);
}
}
private static void ensureNoParameterConstraint(final InvocableElementDescriptor constraintsForMethod, final String msg) {
for (final ParameterDescriptor parameterDescriptor : constraintsForMethod.getParameterDescriptors()) {
if (!parameterDescriptor.getConstraintDescriptors().isEmpty() || parameterDescriptor.isCascaded()) {
throw new ConstraintDeclarationException(msg);
}
}
}
private static void ensureNoConvertGroup(final Method method, final String msg) {
for (final Annotation[] annotations : method.getParameterAnnotations()) {
for (final Annotation a : annotations) {
if (ConvertGroup.class.isInstance(a)) {
throw new ConstraintDeclarationException(msg);
}
}
}
if (method.getAnnotation(ConvertGroup.class) != null) {
throw new ConstraintDeclarationException(msg);
}
}
private void processMethod(Method method, MethodDescriptorImpl methodDesc) throws InvocationTargetException, IllegalAccessException {
if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotations(method)) {
for (Annotation anno : method.getAnnotations()) {
if (anno instanceof Valid || anno instanceof Validate) {
methodDesc.setCascaded(true);
} else {
processAnnotations(method, methodDesc, method.getReturnType(), anno);
}
}
}
final Annotation[][] paramsAnnos = method.getParameterAnnotations();
int idx = 0;
final List<String> names = factoryContext.getParameterNameProvider().getParameterNames(method);
for (final Annotation[] paramAnnos : paramsAnnos) {
if (!factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnParameter(method, idx)) {
final ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
processAnnotations(methodDesc, paramAnnos, access, idx, names.get(idx));
} else {
final ParameterDescriptorImpl parameterDescriptor = new ParameterDescriptorImpl(metaBean, new Validation[0], names.get(idx));
parameterDescriptor.setIndex(idx);
methodDesc.getParameterDescriptors().add(parameterDescriptor);
}
}
}
if (factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnCrossParameter(method) && methodDesc.getCrossParameterDescriptor() != null) {
methodDesc.setCrossParameterDescriptor(null);
}
if (factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnReturn(method) && methodDesc.getReturnValueDescriptor() != null) {
methodDesc.setReturnValueDescriptor(null);
}
final MetaMethod metaMethod = metaBean.getMethod(method);
if (metaMethod != null) {
for (final Annotation anno : metaMethod.getAnnotations()) {
if (anno instanceof Valid) {
methodDesc.setCascaded(true);
} else {
processAnnotations(null, methodDesc, method.getReturnType(), anno);
}
}
final Collection<MetaParameter> paramsAnnos = metaMethod.getParameters();
final List<String> names = factoryContext.getParameterNameProvider().getParameterNames(method);
for (final MetaParameter paramAnnos : paramsAnnos) {
final int idx = paramAnnos.getIndex();
final ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
processAnnotations(methodDesc, paramAnnos.getAnnotations(), access, idx, names.get(idx));
}
}
}
private AppendValidationToList processAnnotations(InvocableElementDescriptor methodDesc, Annotation[] paramAnnos, AccessStrategy access, int idx, String name)
throws InvocationTargetException, IllegalAccessException {
final AppendValidationToList validations = new AppendValidationToList();
boolean cascaded = false;
Group[] from = null;
Group[] to = null;
for (final Annotation anno : paramAnnos) {
if (anno instanceof Valid || anno instanceof Validate) {
cascaded = true;
} else if (ConvertGroup.class.isInstance(anno)) {
final ConvertGroup cg = ConvertGroup.class.cast(anno);
from = new Group[]{new Group(cg.from())};
to = new Group[]{new Group(cg.to())};
} else if (ConvertGroup.List.class.isInstance(anno)) {
final ConvertGroup.List cgl = ConvertGroup.List.class.cast(anno);
final ConvertGroup[] groups = cgl.value();
from = new Group[groups.length];
to = new Group[groups.length];
from[i] = new Group(groups[i].from());
to[i] = new Group(groups[i].to());
}
} else {
processAnnotation(anno, methodDesc, access, validations);
}
}
ParameterDescriptorImpl paramDesc = null;
for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
if (pd.getIndex() == idx) {
paramDesc = ParameterDescriptorImpl.class.cast(pd);
}
}
if (paramDesc == null) {
validations.getValidations().toArray(new Validation[validations.getValidations().size()]), name);
paramDesc.setIndex(idx);
methodDesc.getParameterDescriptors().add(paramDesc);
paramDesc.setCascaded(cascaded);
} else {
paramDesc.getMutableConstraintDescriptors().addAll(validations.getValidations());
if (cascaded) {
paramDesc.setCascaded(true);
}
if (paramDesc.isCascaded() && from != null) {
paramDesc.addGroupConversion(new GroupConversionDescriptorImpl(from[i], to[i]));
}
} else if (from != null) {
throw new ConstraintDeclarationException("Group conversion is only relevant for @Valid cases");
}
return validations;
}
private <A extends Annotation> void processAnnotation(A annotation, InvocableElementDescriptor desc,
AccessStrategy access, AppendValidation validations) throws InvocationTargetException, IllegalAccessException {
if (annotation instanceof Valid || annotation instanceof Validate) {
desc.setCascaded(true);
final ConvertGroup cg = ConvertGroup.class.cast(annotation);
desc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(cg.from()), new Group(cg.to())));
} else if (ConvertGroup.List.class.isInstance(annotation) && ReturnAccess.class.isInstance(access)) {
final ConvertGroup.List cgl = ConvertGroup.List.class.cast(annotation);
for (final ConvertGroup cg : cgl.value()) {
desc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(cg.from()), new Group(cg.to())));
}
} else {
Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
if (vcAnno != null) {
annotationProcessor.processAnnotation(annotation, null, ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations, true);
} else {
if (ConstraintAnnotationAttributes.VALUE.isDeclaredOn(annotation.annotationType())) {
Annotation[] children = ConstraintAnnotationAttributes.VALUE.getValue(annotation);
if (children != null) {
for (Annotation child : children) {
}
}
}
}
}
}
import org.apache.bval.jsr303.util.Proxies;
import org.apache.bval.model.Validation;
import org.apache.commons.lang3.tuple.ImmutablePair;
import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintDefinitionException;
import javax.validation.ConstraintTarget;
import javax.validation.ConstraintViolation;
import javax.validation.ElementKind;
import javax.validation.ValidationException;
import javax.validation.executable.ExecutableValidator;
import javax.validation.groups.Default;
import javax.validation.metadata.BeanDescriptor;
import javax.validation.metadata.ConstraintDescriptor;
import javax.validation.metadata.ElementDescriptor;
import javax.validation.metadata.ParameterDescriptor;
import javax.validation.metadata.PropertyDescriptor;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
public class ClassValidator implements CascadingPropertyValidator, ExecutableValidator {
if (object == null) {
}
final Class<T> objectClass = (Class<T>) object.getClass();
final MetaBean objectMetaBean = getMetaBeanFinder().findForClass(objectClass);
return validateBeanWithGroups(context, context.getGroups());
} catch (final RuntimeException ex) {
private <T> Set<ConstraintViolation<T>> validateBeanWithGroups(final GroupValidationContext<T> context, final Groups sequence) {
final ConstraintValidationListener<T> result = context.getListener();
for (final Group current : sequence.getGroups()) {
context.setCurrentGroup(current);
validateBeanNet(context);
}
for (final List<Group> eachSeq : sequence.getSequences()) {
for (final Group current : eachSeq) {
context.setCurrentGroup(current);
validateBeanNet(context);
if (!result.isEmpty()) {
break;
}
}
if (!result.isEmpty()) {
break;
}
}
return result.getConstraintViolations();
}
} catch (final ConstraintDefinitionException definitionEx) {
throw definitionEx;
} catch (final ConstraintDeclarationException declarationEx) {
throw declarationEx;
} catch (final RuntimeException ex) {
public ExecutableValidator forExecutables() {
return this;
}
final ConstraintValidationListener<?> result = context.getListener();
final Group currentGroup = context.getCurrentGroup();
for (final Group each : defaultGroups) {
validateBean(context);
final List<Class<?>> classHierarchy = new ArrayList<Class<?>>();
final Class<?> initialOwner = context.getCurrentOwner();
for (final Class<?> owner : classHierarchy) {
validateBean(context);
validateBean(context);
for (final MetaProperty prop : context.getMetaBean().getProperties()) {
final Group group = context.getCurrentGroup();
final Group mappedGroup;
final Object feature = prop.getFeature(Jsr303Features.Property.PropertyDescriptor);
if (feature != null) {
mappedGroup = PropertyDescriptorImpl.class.cast(feature).mapGroup(group);
} else {
mappedGroup = group;
}
if (group != mappedGroup) {
final Groups propertyGroup = groupsComputer.computeGroups(new Class<?>[]{ mappedGroup.getGroup() });
validateCascadedBean(context, prop, propertyGroup);
} else {
validateCascadedBean(context, prop, null);
}
context.setCurrentGroup(group);
private void validateBean(final GroupValidationContext<?> context) {
for (final PropertyDescriptor prop : getConstraintsForClass(context.getMetaBean().getBeanClass()).getConstrainedProperties()) {
final PropertyDescriptorImpl impl = PropertyDescriptorImpl.class.cast(prop);
checkValidationAppliesTo(impl.getConstraintDescriptors(), ConstraintTarget.PARAMETERS);
checkValidationAppliesTo(impl.getConstraintDescriptors(), ConstraintTarget.RETURN_VALUE);
final MetaProperty metaProperty = context.getMetaBean().getProperty(prop.getPropertyName());
context.setMetaProperty(metaProperty);
final Group current = context.getCurrentGroup();
context.setCurrentGroup(impl.mapGroup(current));
ValidationHelper.validateProperty(context);
context.setCurrentGroup(current);
}
context.setMetaProperty(null);
for (final Validation validation : context.getMetaBean().getValidations()) {
if (ConstraintValidation.class.isInstance(validation)) {
checkValidationAppliesTo(ConstraintValidation.class.cast(validation).getValidationAppliesTo(), ConstraintTarget.PARAMETERS);
checkValidationAppliesTo(ConstraintValidation.class.cast(validation).getValidationAppliesTo(), ConstraintTarget.RETURN_VALUE);
}
validation.validate(context);
}
}
private void validateCascadedBean(final GroupValidationContext<?> context, final MetaProperty prop, final Groups groups) {
for (final AccessStrategy each : access) {
if (groups == null) {
ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), treatMapsLikeBeans);
} else {
ValidationHelper.validateContext(context, new ValidationHelper.ValidateCallback() {
public void validate() {
validateBeanWithGroups(context, groups);
}
}, treatMapsLikeBeans);
}
final NodeImpl node = new NodeImpl.PropertyNodeImpl(prop.getName());
beanPath = PathImpl.create();
context.getRootMetaBean().getBeanClass(), beanPath, access.getElementType())) {
}
protected <T> GroupValidationContext<T> createContext(MetaBean metaBean, T object, Class<T> objectClass, Class<?>... groups) {
final ConstraintValidationListener<T> listener = new ConstraintValidationListener<T>(object, objectClass);
final GroupValidationContextImpl<T> context =
this.factoryContext.getTraversableResolver(), factoryContext.getParameterNameProvider(), metaBean);
protected BeanDescriptorImpl createBeanDescriptor(MetaBean metaBean) {
return new BeanDescriptorImpl(factoryContext, metaBean);
}
for (final Class<?> c : groups) {
if (c == null) {
throw new IllegalArgumentException("Group cannot be null.");
}
}
}
public <T> Set<ConstraintViolation<T>> validateConstructorParameters(Constructor<? extends T> constructor, Object[] parameterValues, Class<?>... gps) {
notNull("Constructor", constructor);
notNull("Groups", gps);
notNull("Parameters", parameterValues);
final Class<?> declaringClass = constructor.getDeclaringClass();
final ConstructorDescriptorImpl constructorDescriptor = ConstructorDescriptorImpl.class.cast(getConstraintsForClass(declaringClass).getConstraintsForConstructor(constructor.getParameterTypes()));
return Collections.emptySet();
}
if (parameterValues.length > 0) {
checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()), ConstraintTarget.IMPLICIT);
checkValidationAppliesTo(constructorDescriptor.getParameterDescriptors(), ConstraintTarget.IMPLICIT);
} else {
checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()), ConstraintTarget.PARAMETERS);
checkValidationAppliesTo(constructorDescriptor.getParameterDescriptors(), ConstraintTarget.PARAMETERS);
}
final Set<ConstraintViolation<T>> violations = new HashSet<ConstraintViolation<T>>();
final ImmutablePair<Set<ConstraintViolation<Object>>, Group> result;
{
final GroupValidationContext<ConstraintValidationListener<?>> context = createContext(constructorDescriptor.getMetaBean(), null, Class.class.cast(constructor.getDeclaringClass()), gps);
context.moveDown(new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(), Arrays.asList(constructor.getParameterTypes())));
result = validateParameters(context, constructorDescriptor.getParameterDescriptors(), parameterValues);
violations.addAll(Set.class.cast(result.getLeft()));
context.moveUp(null, null);
}
{
final GroupValidationContext<Object> crossParameterContext;
if (result.getRight() == null) {
crossParameterContext = createContext(constructorDescriptor.getMetaBean(), parameterValues, Class.class.cast(constructor.getDeclaringClass()), gps);
} else {
crossParameterContext = createContext(constructorDescriptor.getMetaBean(), parameterValues, Class.class.cast(constructor.getDeclaringClass()), result.getRight().getGroup());
}
crossParameterContext.setBean(parameterValues);
crossParameterContext.moveDown(new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(), Arrays.asList(constructor.getParameterTypes())));
crossParameterContext.moveDown("<cross-parameter>");
crossParameterContext.setKind(ElementKind.CROSS_PARAMETER);
validateElementInContext(crossParameterContext, constructorDescriptor.getCrossParameterDescriptor());
crossParameterContext.moveUp(null, null);
crossParameterContext.moveUp(null, null);
violations.addAll(Set.class.cast(crossParameterContext.getListener().getConstraintViolations()));
}
return violations;
}
private static void checkValidationAppliesTo(final Collection<? extends ElementDescriptor> descriptors, final ConstraintTarget forbidden) {
for (final ElementDescriptor descriptor : descriptors) {
for (final ConstraintDescriptor<?> consDesc : descriptor.getConstraintDescriptors()) {
checkValidationAppliesTo(consDesc.getValidationAppliesTo(), forbidden);
}
}
}
private static void checkValidationAppliesTo(final Set<ConstraintDescriptor<?>> constraintDescriptors, final ConstraintTarget forbidden) {
for (final ConstraintDescriptor<?> descriptor : constraintDescriptors) {
checkValidationAppliesTo(descriptor.getValidationAppliesTo(), forbidden);
}
}
private static void checkValidationAppliesTo(final ConstraintTarget configured, final ConstraintTarget forbidden) {
if (forbidden.equals(configured)) {
}
}
public <T> Set<ConstraintViolation<T>> validateConstructorReturnValue(final Constructor<? extends T> constructor, final T createdObject, final Class<?>... groups) {
if (constructor == null) {
throw new IllegalArgumentException("constructor shouldn't be null");
}
if (createdObject == null) {
throw new IllegalArgumentException("returned value shouldn't be null");
}
final ConstructorDescriptorImpl methodDescriptor = ConstructorDescriptorImpl.class.cast(getConstraintsForClass(constructor.getDeclaringClass()).getConstraintsForConstructor(constructor.getParameterTypes()));
if (methodDescriptor == null) {
}
final GroupValidationContext<T> context = createContext(methodDescriptor.getMetaBean(), createdObject, (Class<T>) Proxies.classFor(createdObject.getClass()), groups);
context.moveDown(new NodeImpl.ConstructorNodeImpl(constructor.getDeclaringClass().getSimpleName(), Arrays.asList(constructor.getParameterTypes())));
context.moveDown(new NodeImpl.ReturnValueNodeImpl());
context.setReturnValue(createdObject);
validateElementInContext(context, methodDescriptor.getReturnValueDescriptor());
final Set<ConstraintViolation<T>> constraintViolations = context.getListener().getConstraintViolations();
context.moveUp(null, null);
context.moveUp(null, null);
if (methodDescriptor.isCascaded()) {
context.moveDown(new NodeImpl.ConstructorNodeImpl(constructor.getDeclaringClass().getSimpleName(), Arrays.asList(constructor.getParameterTypes())));
context.moveDown(new NodeImpl.ReturnValueNodeImpl());
context.setReturnValue(createdObject);
context.setBean(createdObject);
for (final Group group : context.getGroups().getGroups()) {
context.setCurrentGroup(methodDescriptor.mapGroup(group));
validateBeanNet(context);
}
for (final List<Group> sequence : context.getGroups().getSequences()) {
for (final Group group : sequence) {
context.setCurrentGroup(methodDescriptor.mapGroup(group));
validateBeanNet(context);
}
}
constraintViolations.addAll(Set.class.cast(context.getListener().getConstraintViolations()));
context.moveUp(null, null);
context.moveUp(null, null);
}
return constraintViolations;
}
public <T> Set<ConstraintViolation<T>> validateParameters(T object, Method method, Object[] parameterValues, Class<?>... groups) {
{
notNull("Object", object);
notNull("Parameters", parameterValues);
notNull("Method", method);
notNull("Groups", groups);
for (final Class<?> g : groups) {
notNull("Each group", g);
}
}
final MethodDescriptorImpl methodDescriptor = findMethodDescriptor(object, method);
return Collections.emptySet();
}
if (method.getParameterTypes().length > 0 && method.getReturnType() != Void.TYPE) {
checkValidationAppliesTo(Collections.singleton(methodDescriptor.getCrossParameterDescriptor()), ConstraintTarget.IMPLICIT);
checkValidationAppliesTo(methodDescriptor.getParameterDescriptors(), ConstraintTarget.IMPLICIT);
} else if (method.getParameterTypes().length == 0) {
checkValidationAppliesTo(Collections.singleton(methodDescriptor.getCrossParameterDescriptor()), ConstraintTarget.PARAMETERS);
checkValidationAppliesTo(methodDescriptor.getParameterDescriptors(), ConstraintTarget.PARAMETERS);
}
final Set<ConstraintViolation<T>> violations = new HashSet<ConstraintViolation<T>>();
final ImmutablePair<Set<ConstraintViolation<Object>>, Group> result;
final GroupValidationContext<ConstraintValidationListener<?>> context = createContext(methodDescriptor.getMetaBean(), object, Class.class.cast(object.getClass()), groups);
context.setMethod(method);
context.moveDown(new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())));
result = validateParameters(context, methodDescriptor.getParameterDescriptors(), parameterValues);
violations.addAll(Set.class.cast(result.getLeft()));
context.moveUp(null, null);
}
final GroupValidationContext<Object[]> context;
if (result.getRight() == null) {
context = createContext(methodDescriptor.getMetaBean(), object, Class.class.cast(Object[].class), groups);
} else {
context = createContext(methodDescriptor.getMetaBean(), object, Class.class.cast(Object[].class), result.getRight().getGroup());
}
context.setMethod(method);
context.setBean(parameterValues);
context.moveDown(new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())));
context.moveDown(new NodeImpl.CrossParameterNodeImpl());
validateElementInContext(context, methodDescriptor.getCrossParameterDescriptor());
violations.addAll(Set.class.cast(context.getListener().getConstraintViolations()));
context.moveUp(null, null);
context.moveUp(null, null);
}
return violations;
}
private static void notNull(final String entity, final Object shouldntBeNull) {
if (shouldntBeNull == null) {
}
}
public <T> Set<ConstraintViolation<T>> validateReturnValue(T object, Method method, Object returnValue, Class<?>... groups) {
notNull("object", object);
notNull("method", method);
notNull("groups", groups);
MethodDescriptorImpl methodDescriptor = findMethodDescriptor(object, method);
if (methodDescriptor == null) {
}
if (method.getReturnType() == Void.TYPE) {
checkValidationAppliesTo(methodDescriptor.getReturnValueDescriptor().getConstraintDescriptors(), ConstraintTarget.RETURN_VALUE);
}
final GroupValidationContext<?> context = createContext(methodDescriptor.getMetaBean(), returnValue, Class.class.cast(Proxies.classFor(object.getClass())), groups);
context.moveDown(new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())));
context.moveDown(new NodeImpl.ReturnValueNodeImpl());
initMetaBean(context, factoryContext.getMetaBeanFinder(), method.getReturnType());
validateElementInContext(context, methodDescriptor.getReturnValueDescriptor());
final ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
context.moveUp(null, null);
context.moveUp(null, null);
return result.getConstraintViolations();
}
private <T> MethodDescriptorImpl findMethodDescriptor(final T object, final Method method) {
return MethodDescriptorImpl.class.cast(getConstraintsForClass(Proxies.classFor(object.getClass())).getConstraintsForMethod(method.getName(), method.getParameterTypes()));
}
private <T> ImmutablePair<Set<ConstraintViolation<T>>, Group> validateParameters(GroupValidationContext<ConstraintValidationListener<?>> context,
List<ParameterDescriptor> paramDescriptors, Object[] parameters) {
if (parameters == null) {
throw new IllegalArgumentException("cannot validate null");
}
if (parameters.length > 0) {
try {
Group gp = null;
final ParameterDescriptorImpl paramDesc = (ParameterDescriptorImpl) paramDescriptors.get(i);
context.setBean(parameters[i]);
context.setParameters(parameters);
context.moveDown(new NodeImpl.ParameterNodeImpl(paramDesc.getName(), i));
final Group current = validateElementInContext(context, paramDesc);
if (current != null) {
gp = current;
}
context.moveUp(null, null);
}
final ConstraintValidationListener<T> result = (ConstraintValidationListener<T>) context.getListener();
return new ImmutablePair<Set<ConstraintViolation<T>>, Group>(result.getConstraintViolations(), gp);
} catch (final RuntimeException ex) {
throw unrecoverableValidationError(ex, parameters);
}
} else {
return new ImmutablePair<Set<ConstraintViolation<T>>, Group>(Collections.<ConstraintViolation<T>> emptySet(), null);
}
}
private <T> void initMetaBean(final GroupValidationContext<T> context, final MetaBeanFinder metaBeanFinder, final Class<?> directValueClass) {
final boolean collection = Collection.class.isAssignableFrom(directValueClass);
final boolean map = Map.class.isAssignableFrom(directValueClass);
if (!directValueClass.isArray()
&& (!collection || Collection.class.cast(context.getValidatedValue()).isEmpty())
&& (!map || Map.class.cast(context.getValidatedValue()).isEmpty())) {
context.setMetaBean(metaBeanFinder.findForClass(directValueClass));
} else if (collection) {
context.setMetaBean(metaBeanFinder.findForClass(Collection.class.cast(context.getValidatedValue()).iterator().next().getClass()));
} else if (map) {
context.setMetaBean(metaBeanFinder.findForClass(Map.class.cast(context.getValidatedValue()).values().iterator().next().getClass()));
} else {
context.setMetaBean(metaBeanFinder.findForClass(directValueClass.getComponentType()));
}
}
private <T> Group validateElementInContext(final GroupValidationContext<T> context,
final ElementDescriptor eltDescriptor) {
final ElementDescriptorImpl impl = ElementDescriptorImpl.class.cast(eltDescriptor);
final Groups groups = context.getGroups();
Group breakOnGroup = null;
for (final ConstraintDescriptor<?> consDesc : eltDescriptor.getConstraintDescriptors()) {
final ConstraintValidation<?> validation = (ConstraintValidation<?>) consDesc;
for (final Group current : groups.getGroups()) {
context.setCurrentGroup(current);
validation.validate(context);
}
for (final List<Group> eachSeq : groups.getSequences()) {
for (final Group current : eachSeq) {
context.setCurrentGroup(current);
validation.validate(context);
if (!context.getListener().isEmpty()) {
breakOnGroup = current;
break;
}
}
}
}
if (impl.isCascaded() && context.getValidatedValue() != null) {
initMetaBean(context, factoryContext.getMetaBeanFinder(), context.getValidatedValue().getClass());
for (final Group current : groups.getGroups()) {
context.setCurrentGroup(impl.mapGroup(current));
ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
}
for (final List<Group> eachSeq : groups.getSequences()) {
for (final Group current : eachSeq) {
context.setCurrentGroup(impl.mapGroup(current));
ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
if (!context.getListener().isEmpty()) {
breakOnGroup = current;
break;
}
}
}
}
return breakOnGroup;
import org.apache.bval.jsr303.parameter.DefaultParameterNameProvider;
import org.apache.bval.jsr303.util.IOs;
import javax.validation.BootstrapConfiguration;
import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.ParameterNameProvider;
import javax.validation.TraversableResolver;
import javax.validation.ValidationException;
import javax.validation.ValidationProviderResolver;
import javax.validation.ValidatorFactory;
import javax.validation.executable.ExecutableType;
import java.io.Closeable;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
protected MessageInterpolator defaultMessageInterpolator = new DefaultMessageInterpolator();
protected MessageInterpolator messageInterpolator = defaultMessageInterpolator;
protected ConstraintValidatorFactory defaultConstraintValidatorFactory = new DefaultConstraintValidatorFactory();
protected ConstraintValidatorFactory constraintValidatorFactory = defaultConstraintValidatorFactory;
private TraversableResolver defaultTraversableResolver = new DefaultTraversableResolver();
private TraversableResolver traversableResolver = defaultTraversableResolver;
protected ParameterNameProvider defaultParameterNameProvider = new DefaultParameterNameProvider();
protected ParameterNameProvider parameterNameProvider = defaultParameterNameProvider;
protected BootstrapConfiguration  bootstrapConfiguration;
protected Collection<ExecutableType> executableValidation;
private ValidationParser parser;
public ApacheValidatorConfiguration parameterNameProvider(ParameterNameProvider parameterNameProvider) {
this.parameterNameProvider = parameterNameProvider;
return this;
}
mappingStreams.add(IOs.convertToMarkableInputStream(stream));
public MessageInterpolator getDefaultMessageInterpolator() {
return defaultMessageInterpolator;
}
public TraversableResolver getDefaultTraversableResolver() {
return defaultTraversableResolver;
}
public ConstraintValidatorFactory getDefaultConstraintValidatorFactory() {
return defaultConstraintValidatorFactory;
}
public ParameterNameProvider getDefaultParameterNameProvider() {
return defaultParameterNameProvider;
}
public BootstrapConfiguration getBootstrapConfiguration() {
if (bootstrapConfiguration == null) {
synchronized (this) {
if (bootstrapConfiguration == null) {
parser = parseValidationXml();
bootstrapConfiguration = parser.getBootstrap();
}
}
}
return bootstrapConfiguration;
parser.ensureValidatorFactoryCanBeBuilt();
public ConfigurationImpl prepare() {
if (prepared) {
return this;
}
if (parser == null) {
if (bootstrapConfiguration == null) {
bootstrapConfiguration = parser.getBootstrap();
}
}
}
if (getBootstrapConfiguration().isExecutableValidationEnabled()) {
getProperties().put(Properties.EXECUTABLE_VALIDATION_TYPES, executableValidationTypesAsString());
}
return this;
private ValidationParser parseValidationXml() {
return ValidationParser.processValidationConfig(getProperties().get(Properties.VALIDATION_XML_PATH), this, ignoreXmlConfiguration);
public ParameterNameProvider getParameterNameProvider() {
return parameterNameProvider;
}
public void setExecutableValidation(final Collection<ExecutableType> executableValidation) {
this.executableValidation = executableValidation;
}
public Collection<ExecutableType> getExecutableValidation() {
return executableValidation;
}
private String executableValidationTypesAsString() {
if (executableValidation == null || executableValidation.isEmpty()) {
return "";
}
final StringBuilder builder = new StringBuilder();
for (final ExecutableType type : executableValidation) {
builder.append(type.name()).append(",");
}
final String s = builder.toString();
return s.substring(0, s.length() - 1);
}
public Closeable getClosable() {
return parser;
}
public ValidationParser getParser() {
return parser;
}
public void setParser(ValidationParser parser) {
this.parser = parser;
}
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.commons.lang3.reflect.TypeUtils;
import javax.validation.Constraint;
import javax.validation.ConstraintDefinitionException;
import javax.validation.ConstraintTarget;
import javax.validation.Payload;
import javax.validation.ValidationException;
MESSAGE(false, false, "message"),
GROUPS(false, false, "groups"),
PAYLOAD(false, false, "payload"),
VALIDATION_APPLIES_TO(true, true, "validationAppliesTo"),
VALUE(false, true, "value");
ConstraintTarget validationAppliesTo;
private final Type type;
private final boolean permitNullDefaultValue;
private final String attributeName;
private final boolean quiet;
private ConstraintAnnotationAttributes(final boolean quiet, final boolean permitNullDefaultValue, final String name) {
this.quiet = quiet;
this.attributeName = name;
return attributeName;
new Worker<A>(type, quiet);
return  (T) new Worker<A>(type, quiet).defaultValue;
import javax.validation.ConstraintTarget;
private final ConstraintTarget validationAppliesTo;
private final String template;
public ConstraintDescriptorImpl(final ConstraintDescriptor<T> descriptor) {
descriptor.isReportAsSingleViolation(), descriptor.getValidationAppliesTo(), descriptor.getMessageTemplate());
boolean reportAsSingleViolation, ConstraintTarget validationAppliesTo, String messageTemplate) {
this.validationAppliesTo = validationAppliesTo;
this.template = messageTemplate;
public String getMessageTemplate() {
return template;
}
public ConstraintTarget getValidationAppliesTo() {
return validationAppliesTo;
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
ConstraintDescriptorImpl that = (ConstraintDescriptorImpl) o;
if (reportAsSingleViolation != that.reportAsSingleViolation) return false;
if (!annotation.annotationType().equals(that.annotation.annotationType())) return false;
if (composingConstraints != null ? !composingConstraints.equals(that.composingConstraints) : that.composingConstraints != null)
return false;
if (constraintValidatorClasses != null ? !constraintValidatorClasses.equals(that.constraintValidatorClasses) : that.constraintValidatorClasses != null)
return false;
if (payload != null ? !payload.equals(that.payload) : that.payload != null) return false;
if (template != null ? !template.equals(that.template) : that.template != null) return false;
if (validationAppliesTo != that.validationAppliesTo) return false;
return true;
}
@Override
public int hashCode() {
int result = annotation != null ? annotation.annotationType().hashCode() : 0;
return result;
}
if (constraintDescriptors.isEmpty()) {
return Collections.emptySet();
}
return Collections.<ConstraintDescriptor<?>>unmodifiableSet(constraintDescriptors);
import javax.validation.ConstraintTarget;
private final RuntimeException missingValidatorException;
private ConstraintTarget validationAppliesTo = null;
ConstraintValidator<T, ?> validator, T annotation, Class<?> owner, AccessStrategy access,
boolean reportFromComposite, ConstraintTarget target, RuntimeException missingValidatorException) {
this.validationAppliesTo = target;
this.missingValidatorException = missingValidatorException;
if (missingValidatorException != null) {
throw missingValidatorException;
}
final PathImpl path = context.getPropertyPath();
final NodeImpl node = path.getLeafNode();
beanPath = PathImpl.create();
public ConstraintTarget getValidationAppliesTo() {
return validationAppliesTo;
}
public void setValidationAppliesTo(final ConstraintTarget validationAppliesTo) {
this.validationAppliesTo = validationAppliesTo;
}
import javax.validation.ElementKind;
import java.util.Iterator;
final Object[] parameters;
Object leaf;
Object returnValue;
T rootBean;
final GroupValidationContext<T> ctx = GroupValidationContext.class.cast(context);
final ElementKind elementKind = ctx.getElementKind();
final Iterator<Path.Node> it = propPath.iterator();
final ElementKind kind = propPath.iterator().next().getKind();
returnValue = ctx.getReturnValue();
if (ElementKind.CONSTRUCTOR.equals(kind)) {
rootBean = null;
leaf = context.getBean();
} else if (ElementKind.METHOD.equals(kind)) {
rootBean = (T) returnValue;
if (kindOf(propPath, ElementKind.RETURN_VALUE)) {
leaf = returnValue;
returnValue = this.rootBean;
} else {
leaf = this.rootBean;
returnValue = this.rootBean;
}
} else {
rootBean = this.rootBean;
if (kindOf(propPath, ElementKind.PARAMETER, ElementKind.CROSS_PARAMETER)) {
leaf = rootBean;
} else {
leaf = context.getBean();
}
}
} else {
rootBean = this.rootBean;
leaf = context.getBean();
}
if (ElementKind.CONSTRUCTOR.equals(kind)
&& (ElementKind.CROSS_PARAMETER.equals(elementKind)
|| ElementKind.PARAMETER.equals(elementKind))
leaf = null;
}
parameters = ctx.getParameters();
} else {
leaf = context.getBean();
returnValue = null;
parameters = null;
rootBean = this.rootBean;
}
constraintViolations.add(new ConstraintViolationImpl<T>(
messageTemplate, message,
rootBean, leaf,
propPath, value, descriptor,
rootBeanType,
elementType, returnValue, parameters));
}
private static boolean kindOf(final Path propPath, final ElementKind... kinds) {
final Iterator<Path.Node> node = propPath.iterator();
boolean isParam = false;
while (node.hasNext()) {
final ElementKind current = node.next().getKind();
isParam = false;
for (final ElementKind k : kinds) {
if (k.equals(current)) {
isParam = true;
break;
}
}
}
return isParam;
import org.apache.bval.jsr303.util.LeafNodeBuilderCustomizableContextImpl;
import javax.validation.ElementKind;
import javax.validation.ParameterNameProvider;
import java.lang.reflect.Method;
return new ConstraintViolationBuilderImpl(this, messageTemplate, validationContext.getPropertyPath());
}
public <T> T unwrap(Class<T> type) {
if (type.isInstance(this)) {
return type.cast(this);
}
path = PathImpl.create();
path.getLeafNode().setName(name);
public NodeBuilderCustomizableContext addPropertyNode(String name) {
final NodeImpl node;
if (!propertyPath.isRootPath()) {
if (propertyPath.getLeafNode().getKind() != null) {
node = new NodeImpl.PropertyNodeImpl(name);
propertyPath.addNode(node);
} else {
node = propertyPath.getLeafNode();
}
} else {
node = new NodeImpl.PropertyNodeImpl(name);
propertyPath.addNode(node);
}
node.setName(name);
return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
}
public LeafNodeBuilderCustomizableContext addBeanNode() {
final NodeImpl node = new NodeImpl.BeanNodeImpl();
node.setKind(ElementKind.BEAN);
propertyPath.addNode(node);
return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
}
public NodeBuilderDefinedContext addParameterNode(int index) {
final Method method = parent.validationContext.getMethod();
final List<String> parameters = parent.validationContext.getParameterNameProvider().getParameterNames(method);
final NodeImpl node = new NodeImpl.ParameterNodeImpl(parameters.get(index), index);
node.setParameterIndex(index);
node.setKind(ElementKind.PARAMETER);
if (!propertyPath.isRootPath()) {
propertyPath.removeLeafNode();
}
propertyPath.addNode(node);
return new NodeBuilderDefinedContextImpl(parent, messageTemplate, propertyPath);
}
import javax.validation.ValidationException;
import java.util.Arrays;
private final Object returnValue;
private final Object[] parameters;
ConstraintDescriptor<?> constraintDescriptor, Class<T> rootBeanClass,
ElementType elementType, Object returnValue, Object[] parameters) {
this.returnValue = returnValue;
this.parameters = parameters;
public Object[] getExecutableParameters() {
return parameters;
}
public Object getExecutableReturnValue() {
return returnValue;
}
public <U> U unwrap(Class<U> type) {
if (type.isInstance(this)) {
return type.cast(this);
}
}
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
ConstraintViolationImpl that = (ConstraintViolationImpl) o;
if (constraintDescriptor != null ? !constraintDescriptor.equals(that.constraintDescriptor) : that.constraintDescriptor != null)
return false;
if (elementType != that.elementType) return false;
if (leafBean != null ? !leafBean.equals(that.leafBean) : that.leafBean != null) return false;
if (message != null ? !message.equals(that.message) : that.message != null) return false;
if (messageTemplate != null ? !messageTemplate.equals(that.messageTemplate) : that.messageTemplate != null)
return false;
if (!Arrays.equals(parameters, that.parameters)) return false;
if (propertyPath != null ? !propertyPath.equals(that.propertyPath) : that.propertyPath != null) return false;
if (returnValue != null ? !returnValue.equals(that.returnValue) : that.returnValue != null) return false;
if (rootBean != null ? !rootBean.equals(that.rootBean) : that.rootBean != null) return false;
if (rootBeanClass != null ? !rootBeanClass.equals(that.rootBeanClass) : that.rootBeanClass != null)
return false;
if (value != null ? !value.equals(that.value) : that.value != null) return false;
@Override
public int hashCode() {
int result = messageTemplate != null ? messageTemplate.hashCode() : 0;
return result;
}
import org.apache.bval.cdi.BValExtension;
import java.io.Closeable;
import java.io.IOException;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;
public class DefaultConstraintValidatorFactory implements ConstraintValidatorFactory, Closeable {
private final Collection< BValExtension.Releasable<?>> releasables = new CopyOnWriteArrayList<BValExtension.Releasable<?>>();
public <T extends ConstraintValidator<?, ?>> T getInstance(final Class<T> constraintClass) {
try {
try {
return BValExtension.inject(constraintClass).getInstance();
} catch (final Exception e) {
return constraintClass.newInstance();
} catch (final NoClassDefFoundError error) {
return constraintClass.newInstance();
}
} catch (final Exception ex) {
}
}
public void releaseInstance(final ConstraintValidator<?, ?> instance) {
}
public void close() throws IOException {
for (final BValExtension.Releasable<?> releasable : releasables) {
releaseInstance(ConstraintValidator.class.cast(releasable.getInstance()));
releasable.release();
}
releasables.clear();
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.commons.lang3.ArrayUtils;
import javax.el.ArrayELResolver;
import javax.el.BeanELResolver;
import javax.el.CompositeELResolver;
import javax.el.ELContext;
import javax.el.ELException;
import javax.el.ELResolver;
import javax.el.ExpressionFactory;
import javax.el.FunctionMapper;
import javax.el.ListELResolver;
import javax.el.MapELResolver;
import javax.el.MethodNotFoundException;
import javax.el.PropertyNotWritableException;
import javax.el.ResourceBundleELResolver;
import javax.el.ValueExpression;
import javax.el.VariableMapper;
import javax.validation.MessageInterpolator;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Formatter;
import java.util.HashMap;
private static final ExpressionFactory EXPRESSION_FACTORY;
static {
ExpressionFactory ef;
try {
ef = ExpressionFactory.newInstance();
} catch (final Exception e) {
ef = null;
}
EXPRESSION_FACTORY = ef;
}
private static final String DEFAULT_VALIDATION_MESSAGES = "org.apache.bval.jsr303.ValidationMessages";
private final Map<Locale, ResourceBundle> defaultBundlesMap = new ConcurrentHashMap<Locale, ResourceBundle>();
private static ELResolver initResolver() {
final CompositeELResolver resolver = new CompositeELResolver();
resolver.add(new MapELResolver());
resolver.add(new ListELResolver());
resolver.add(new ArrayELResolver());
resolver.add(new ResourceBundleELResolver());
resolver.add(new BeanELResolver() {
public Object invoke(ELContext context, Object base, Object method, Class<?>[] paramTypes, Object[] params) {
if (context == null) {
throw new NullPointerException("ELContext could not be nulll");
}
if(base == null || method == null) {
return null;
}
if (params == null) {
params = new Object[0];
}
String methodName = (String) EXPRESSION_FACTORY.coerceToType(method, String.class);
if (methodName.length() == 0) {
throw new MethodNotFoundException("The parameter method could not be zero-length");
}
Class<?> targetClass = base.getClass();
if (methodName.equals("<init>") || methodName.equals("<cinit>")) {
}
Method targetMethod = null;
if (paramTypes == null) {
int paramsNumber = params.length;
for (final Method m : targetClass.getMethods()) {
if (m.getName().equals(methodName) && m.getParameterTypes().length == paramsNumber) {
targetMethod = m;
break;
}
}
if (targetMethod == null) {
for (final Method m : targetClass.getMethods()) {
if (m.getName().equals(methodName) && m.isVarArgs() && paramsNumber >= (m.getParameterTypes().length - 1)) {
targetMethod = m;
break;
}
}
}
} else {
try {
targetMethod = targetClass.getMethod(methodName, paramTypes);
} catch (SecurityException e) {
throw new ELException(e);
} catch (NoSuchMethodException e) {
throw new MethodNotFoundException(e);
}
}
if (targetMethod == null) {
}
if (paramTypes == null) {
paramTypes = targetMethod.getParameterTypes();
}
if (targetMethod.isVarArgs()) {
if (paramTypes.length - 1 > params.length) {
throw new IllegalArgumentException("Inconsistent number between argument types and values");
}
} else if (paramTypes.length != params.length) {
throw new IllegalArgumentException("Inconsistent number between argument types and values");
}
try {
Object[] finalParamValues = new Object[paramTypes.length];
if (paramTypes.length > 0) {
int iCurrentIndex = 0;
finalParamValues[iCurrentIndex] = EXPRESSION_FACTORY.coerceToType(params[iCurrentIndex], paramTypes[iCurrentIndex]);
}
if (targetMethod.isVarArgs()) {
Class<?> varArgsClassType = paramTypes[iCurrentIndex];
if (iCurrentIndex == params.length) {
finalParamValues[iCurrentIndex] = Array.newInstance(varArgsClassType.getComponentType(), 0);
} else if (iCurrentIndex == params.length - 1 && varArgsClassType == params[iCurrentIndex].getClass()
&& varArgsClassType.getClassLoader() == params[iCurrentIndex].getClass().getClassLoader()) {
finalParamValues[iCurrentIndex] = params[iCurrentIndex];
} else {
Object targetArray = Array.newInstance(varArgsClassType.getComponentType(), params.length - iCurrentIndex);
Class<?> componentClassType = varArgsClassType.getComponentType();
}
finalParamValues[iCurrentIndex] = targetArray;
}
} else {
finalParamValues[iCurrentIndex] = EXPRESSION_FACTORY.coerceToType(params[iCurrentIndex], paramTypes[iCurrentIndex]);
}
}
Object retValue = targetMethod.invoke(base, finalParamValues);
context.setPropertyResolved(true);
return retValue;
}  catch (IllegalAccessException e) {
throw new ELException(e);
} catch (InvocationTargetException e) {
throw new ELException(e.getCause());
}
}
});
return resolver;
}
context.getConstraintDescriptor().getAttributes(), locale, context.getValidatedValue());
Locale locale, Object validatedValue) {
resolvedMessage = replaceAnnotationAttributes(resolvedMessage, annotationParameters);
final ELResolver resolver = initResolver();
final BValELContext context = new BValELContext(resolver);
final VariableMapper variables = context.getVariableMapper();
for (final Map.Entry<String, Object> var : annotationParameters.entrySet()) {
variables.setVariable(var.getKey(), new ValueExpressionLiteral(var.getValue()));
}
variables.setVariable("validatedValue", new ValueExpressionLiteral(validatedValue));
try {
if (EXPRESSION_FACTORY != null) {
resolvedMessage = EXPRESSION_FACTORY.createValueExpression(context, tmp, String.class).getValue(context).toString();
}
} catch (final Exception e) {
}
resolvedMessage = resolvedMessage.replace( "\\{", "{" ).replace( "\\}", "}" ).replace( "\\\\", "\\" ).replace( "\\$", "$" );
final Matcher matcher = messageParameterPattern.matcher(message);
final StringBuffer sb = new StringBuffer(64);
final String parameter = matcher.group(1);
private String replaceAnnotationAttributes(final String message,
final Map<String, Object> annotationParameters) {
parameterValue = replaceVariables(parameterValue, bundle, locale, recurse);
} catch (final MissingResourceException e) {
private static class BValELContext extends ELContext {
private final ELResolver resolver;
private final FunctionMapper functions;
private final VariableMapper variables;
public BValELContext(final ELResolver resolver) {
this.resolver = resolver;
this.variables = new BValVariableMapper();
this.functions = new BValFunctionMapper();
}
@Override
public ELResolver getELResolver() {
return resolver;
}
@Override
public FunctionMapper getFunctionMapper() {
return functions;
}
@Override
public VariableMapper getVariableMapper() {
return variables;
}
}
private static class BValFunctionMapper extends FunctionMapper {
@Override
public Method resolveFunction(final String prefix, final String localName) {
return null;
}
}
private static class BValVariableMapper extends VariableMapper {
private final Map<String, ValueExpression> variables = new HashMap<String, ValueExpression>();
@Override
public ValueExpression resolveVariable(final String variable) {
if ("formatter".equals(variable)) {
return new ValueExpressionLiteral(new BValFormatter());
}
return variables.get(variable);
}
@Override
public ValueExpression setVariable(final String variable, final ValueExpression expression) {
variables.put(variable, expression);
return expression;
}
}
public static class BValFormatter {
private final Formatter formatter = new Formatter();
public Formatter format(final String format, final Object ... args) {
return formatter.format(format, args);
}
}
private static final class ValueExpressionLiteral extends ValueExpression {
private final Object value;
public ValueExpressionLiteral(final Object value) {
this.value = value;
}
@Override
public Object getValue(final ELContext context) {
return value;
}
@Override
public void setValue(final ELContext context, final Object value) {
throw new PropertyNotWritableException(value.toString());
}
@Override
public boolean isReadOnly(final ELContext context) {
return true;
}
@Override
public Class<?> getType(final ELContext context) {
return (this.value != null) ? this.value.getClass() : null;
}
@Override
public Class<?> getExpectedType() {
return String.class;
}
@Override
public String getExpressionString() {
return (this.value != null) ? this.value.toString() : null;
}
@Override
public boolean equals(Object obj) {
return (obj instanceof ValueExpressionLiteral && this
.equals((ValueExpressionLiteral) obj));
}
public boolean equals(final ValueExpressionLiteral ve) {
return (ve != null && (this.value != null && ve.value != null && (this.value == ve.value || this.value
.equals(ve.value))));
}
@Override
public int hashCode() {
return (this.value != null) ? this.value.hashCode() : 0;
}
@Override
public boolean isLiteralText() {
return true;
}
}
import org.apache.bval.jsr303.groups.Group;
import javax.validation.ConstraintDeclarationException;
import javax.validation.metadata.GroupConversionDescriptor;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArraySet;
private final Set<GroupConversionDescriptor> groupConversions = new CopyOnWriteArraySet<GroupConversionDescriptor>();
private boolean cascaded;
private final Map<Group, Group> groupMapping = new HashMap<Group, Group>();
public Set<ConstraintDescriptor<?>> getMutableConstraintDescriptors() {
public void addGroupMapping(final Group from, final Group to) {
groupMapping.put(from, to);
}
public Group mapGroup(final Group current) {
final Group mapping = groupMapping.get(current);
if (mapping != null) {
return mapping;
}
return current;
}
public Set<GroupConversionDescriptor> getGroupConversions() {
return groupConversions;
}
public void addGroupConversion(final GroupConversionDescriptor descriptor) {
groupConversions.add(descriptor);
final Group from = new Group(descriptor.getFrom());
throw new ConstraintDeclarationException("You can't map twice from the same group");
}
addGroupMapping(from, new Group(descriptor.getTo()));
}
public boolean isCascaded() {
return cascaded;
}
public void setCascaded(final boolean cascaded) {
this.cascaded = cascaded;
}
import javax.validation.ElementKind;
import javax.validation.ParameterNameProvider;
import javax.validation.Path;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
void setCurrentGroups(Groups groups);
void setKind(ElementKind type);
ElementKind getElementKind();
Object getReturnValue();
Object[] getParameters();
void setParameters(Object[] parameters);
void setReturnValue(Object returnValue);
ParameterNameProvider getParameterNameProvider();
void setMethod(Method method);
Method getMethod();
void setConstructor(Constructor<?> method);
Constructor<?> getConstructor();
void moveDown(Path.Node node);
import javax.validation.ElementKind;
import javax.validation.ParameterNameProvider;
import javax.validation.Path;
import javax.validation.ValidationException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
private final ParameterNameProvider parameterNameProvider;
private Object[] parameters;
private Object returnValue;
private Method method;
private Constructor<?> constructor;
TraversableResolver traversableResolver, ParameterNameProvider parameterNameProvider, MetaBean rootMetaBean) {
this.parameterNameProvider = parameterNameProvider;
this.path = PathImpl.create();
public void setKind(final ElementKind type) {
path.getLeafNode().setKind(type);
}
moveDown(prop.getName());
@Override
public void moveDown(final String prop) {
path.addProperty(prop);
}
public void moveDown(final Path.Node node) {
path.addNode(node);
}
public void setCurrentGroups(final Groups g) {
groups = g;
}
public <T> T unwrap(Class<T> type) {
if (type.isInstance(this)) {
return type.cast(this);
}
}
public ElementKind getElementKind() {
return path.getLeafNode().getKind();
}
public Object getReturnValue() {
return returnValue;
}
public Object[] getParameters() {
return parameters;
}
public void setParameters(final Object[] parameters) {
this.parameters = parameters;
}
public void setReturnValue(final Object returnValue) {
this.returnValue = returnValue;
}
public ParameterNameProvider getParameterNameProvider() {
return parameterNameProvider;
}
public void setMethod(final Method method) {
this.method = method;
}
public Method getMethod() {
return method;
}
public Constructor<?> getConstructor() {
return constructor;
}
public void setConstructor(final Constructor<?> constructor) {
this.constructor = constructor;
}
interface Method extends Features.Property {
String MethodDescriptor = "MethodDescriptor";
}
interface Constructor extends Features.Property {
String ConstructorDescriptor = "ConstructorDescriptor";
}
String ANNOTATIONS_TO_PROCESS = "annotationToProcess";
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.jsr303.groups.Group;
import org.apache.bval.jsr303.util.ClassHelper;
import org.apache.bval.jsr303.util.SecureActions;
import org.apache.bval.jsr303.xml.MetaConstraint;
import org.apache.bval.model.Meta;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaConstructor;
import org.apache.bval.model.MetaMethod;
import org.apache.bval.model.MetaParameter;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;
import javax.validation.Constraint;
import javax.validation.ConstraintDeclarationException;
import javax.validation.GroupDefinitionException;
import javax.validation.GroupSequence;
import javax.validation.groups.ConvertGroup;
import javax.validation.groups.Default;
import javax.validation.metadata.PropertyDescriptor;
import java.io.Serializable;
import java.lang.annotation.ElementType;
import java.lang.reflect.Constructor;
import java.util.Collection;
if (eachClass == Serializable.class || eachClass == Cloneable.class) {
continue;
}
annotationProcessor.processAnnotations(null, beanClass, beanClass, null, new AppendValidationToMeta(metabean));
final Collection<String> missingValid = new ArrayList<String>();
for (final Field field : fields) {
if (field.getAnnotation(ConvertGroup.class) != null) {
missingValid.add(field.getName());
}
for (final Method method : methods) {
for (final String name : missingValid) {
final MetaProperty metaProperty = metabean.getProperty(name);
if (metaProperty != null && metaProperty.getFeature(Jsr303Features.Property.REF_CASCADE) == null) {
throw new ConstraintDeclarationException("@ConvertGroup needs @Valid");
}
}
missingValid.clear();
for (final MetaConstraint<?, ? extends Annotation> metaConstraint : factoryContext.getFactory().getMetaConstraints(beanClass)) {
Meta meta;
AccessStrategy access = metaConstraint.getAccessStrategy();
meta = null;
final Method method = Method.class.cast(metaConstraint.getMember());
meta = metabean.getMethod(method);
final MetaMethod metaMethod;
if (meta == null) {
meta = new MetaMethod(metabean, method);
metaMethod = MetaMethod.class.cast(meta);
metabean.addMethod(method, metaMethod);
} else {
metaMethod = MetaMethod.class.cast(meta);
}
final Integer index = metaConstraint.getIndex();
if (index != null && index >= 0) {
MetaParameter param = metaMethod.getParameter(index);
if (param == null) {
param = new MetaParameter(metaMethod, index);
metaMethod.addParameter(index, param);
}
param.addAnnotation(metaConstraint.getAnnotation());
} else {
metaMethod.addAnnotation(metaConstraint.getAnnotation());
}
continue;
} else if (access.getElementType() == ElementType.CONSTRUCTOR){
final Constructor<?> constructor = Constructor.class.cast(metaConstraint.getMember());
meta = metabean.getConstructor(constructor);
final MetaConstructor metaConstructor;
if (meta == null) {
meta = new MetaConstructor(metabean, constructor);
metaConstructor = MetaConstructor.class.cast(meta);
metabean.addConstructor(constructor, metaConstructor);
} else {
metaConstructor = MetaConstructor.class.cast(meta);
}
final Integer index = metaConstraint.getIndex();
if (index != null && index >= 0) {
MetaParameter param = metaConstructor.getParameter(index);
if (param == null) {
param = new MetaParameter(metaConstructor, index);
metaConstructor.addParameter(index, param);
}
param.addAnnotation(metaConstraint.getAnnotation());
} else {
metaConstructor.addAnnotation(metaConstraint.getAnnotation());
}
continue;
meta = metabean.getProperty(access.getPropertyName());
create = meta == null;
meta = addMetaProperty(metabean, access);
if (!annotationProcessor.processAnnotation(metaConstraint.getAnnotation(), meta, beanClass,
metaConstraint.getAccessStrategy(), new AppendValidationToMeta(meta == null ? metabean : meta), false)
for (final AccessStrategy access : factoryContext.getFactory().getValidAccesses(beanClass)) {
if (access.getElementType() == ElementType.PARAMETER) {
continue;
}
for (final Class<?> groupClass : groupClasses) {
package org.apache.bval.jsr303;
import javax.validation.metadata.ParameterDescriptor;
package org.apache.bval.jsr303;
package org.apache.bval.jsr303;
import org.apache.bval.jsr303.groups.Group;
import javax.validation.metadata.ParameterDescriptor;
void addGroupMapping(Group from, Group to);
Group mapGroup(Group current);
import javax.validation.metadata.GroupConversionDescriptor;
import java.util.Set;
package org.apache.bval.jsr303;
public boolean equals(final Object o) {
return this == o || o instanceof Group && ObjectUtils.equals(group, ((Group) o).group);
for (final Class<?> clazz : groups) {
if (clazz == null) {
throw new IllegalArgumentException("At least one group has to be specified.");
}
import java.io.Serializable;
if (clazz == null || clazz == Object.class || clazz == Serializable.class) {
import javax.validation.ConstraintTarget;
public static void validateConstraintDefinition(final Annotation annotation) {
final Class<? extends Annotation> type = annotation.annotationType();
ConstraintAnnotationAttributes.GROUPS.validateOn(type);
ConstraintAnnotationAttributes.PAYLOAD.validateOn(type);
ConstraintAnnotationAttributes.MESSAGE.validateOn(type);
ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.validateOn(type);
final Object defaultValidationApplies = ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getDefaultValue(type);
if (ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.isDeclaredOn(type) && !ConstraintTarget.IMPLICIT.equals(defaultValidationApplies)) {
throw new ConstraintDefinitionException("validationAppliesTo default value should be IMPLICIT");
}
import javax.validation.ElementKind;
node.setKind(ElementKind.PROPERTY);
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addNode(String name) {
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(String name) {
propertyPath.addNode(node);
node = new NodeImpl.PropertyNodeImpl(name);
node.setKind(ElementKind.PROPERTY);
return null;
}
public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext addBeanNode() {
propertyPath.addNode(node);
node = new NodeImpl((String) null);
node.setKind(ElementKind.BEAN);
return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
}
import javax.validation.ElementKind;
import javax.validation.Path;
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addNode(String name) {
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(String name) {
return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, name);
}
public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext addBeanNode() {
final NodeImpl node = new NodeImpl((String) null);
node.setKind(ElementKind.BEAN);
propertyPath.addNode(node);
return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
}
import javax.validation.ElementKind;
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(String name) {
propertyPath.addProperty(name);
return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, node.getName());
}
public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext addBeanNode() {
return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
}
import javax.validation.ElementKind;
import java.util.List;
public class NodeImpl implements Path.Node, Serializable {
private List<Class<?>> parameterTypes;
private int parameterIndex;
private ElementKind kind;
public  NodeImpl(String name) {
this.kind = node.getKind();
public void setParameterIndex(final Integer parameterIndex) {
this.parameterIndex = parameterIndex;
}
public ElementKind getKind() {
return kind;
}
public void setKind(ElementKind kind) {
this.kind = kind;
}
public <T extends Node> T as(final Class<T> nodeType) {
if (nodeType.isInstance(this)) {
return nodeType.cast(this);
}
}
if (kind != null ? !kind.equals(node.kind) : node.kind != null) {
return false;
}
public int getParameterIndex() {
return parameterIndex;
}
public List<Class<?>> getParameterTypes() {
return parameterTypes;
}
public void setParameterTypes(final List<Class<?>> parameterTypes) {
this.parameterTypes = parameterTypes;
}
public static class ParameterNodeImpl extends NodeImpl implements Path.ParameterNode {
public ParameterNodeImpl(final Node cast) {
super(cast);
if (ParameterNodeImpl.class.isInstance(cast)) {
setParameterIndex(ParameterNodeImpl.class.cast(cast).getParameterIndex());
}
}
public ParameterNodeImpl(final String name, final int idx) {
super(name);
setParameterIndex(idx);
}
public ElementKind getKind() {
return ElementKind.PARAMETER;
}
}
public static class ConstructorNodeImpl extends NodeImpl implements Path.ConstructorNode {
public ConstructorNodeImpl(final Node cast) {
super(cast);
if (NodeImpl.class.isInstance(cast)) {
setParameterTypes(NodeImpl.class.cast(cast).parameterTypes);
}
}
public ConstructorNodeImpl(final String simpleName, List<Class<?>> paramTypes) {
super(simpleName);
setParameterTypes(paramTypes);
}
public ElementKind getKind() {
return ElementKind.CONSTRUCTOR;
}
}
public static class CrossParameterNodeImpl extends NodeImpl implements Path.CrossParameterNode {
public CrossParameterNodeImpl() {
super("<cross-parameter>");
}
public CrossParameterNodeImpl(final Node cast) {
super(cast);
}
public ElementKind getKind() {
return ElementKind.CROSS_PARAMETER;
}
}
public static class MethodNodeImpl extends NodeImpl implements Path.MethodNode {
public MethodNodeImpl(final Node cast) {
super(cast);
if (MethodNodeImpl.class.isInstance(cast)) {
setParameterTypes(MethodNodeImpl.class.cast(cast).getParameterTypes());
}
}
public MethodNodeImpl(final String name, final List<Class<?>> classes) {
super(name);
setParameterTypes(classes);
}
public ElementKind getKind() {
return ElementKind.METHOD;
}
}
public static class ReturnValueNodeImpl extends NodeImpl implements Path.ReturnValueNode {
public ReturnValueNodeImpl(final Node cast) {
super(cast);
}
public ReturnValueNodeImpl() {
super("<return value>");
}
public ElementKind getKind() {
return ElementKind.RETURN_VALUE;
}
}
public static class PropertyNodeImpl extends NodeImpl implements Path.PropertyNode {
public PropertyNodeImpl(final String name) {
super(name);
}
public PropertyNodeImpl(final Node cast) {
super(cast);
}
public ElementKind getKind() {
return ElementKind.PROPERTY;
}
}
public static class BeanNodeImpl extends NodeImpl implements Path.BeanNode {
public BeanNodeImpl() {
}
public BeanNodeImpl(final Node cast) {
super(cast);
}
public ElementKind getKind() {
return ElementKind.BEAN;
}
}
return create();
public static PathImpl create() {
final PathImpl path = new PathImpl();
final NodeImpl node = new NodeImpl.BeanNodeImpl();
for (final Object aPath : path) {
nodeList.add(newNode(Node.class.cast(aPath)));
private static Node newNode(final Node cast) {
if (PropertyNode.class.isInstance(cast)) {
return new NodeImpl.PropertyNodeImpl(cast);
}
if (BeanNode.class.isInstance(cast)) {
return new NodeImpl.BeanNodeImpl(cast);
}
if (MethodNode.class.isInstance(cast)) {
return new NodeImpl.MethodNodeImpl(cast);
}
if (ConstructorNode.class.isInstance(cast)) {
return new NodeImpl.ConstructorNodeImpl(cast);
}
if (ConstructorNode.class.isInstance(cast)) {
return new NodeImpl.ConstructorNodeImpl(cast);
}
if (ReturnValueNode.class.isInstance(cast)) {
return new NodeImpl.ReturnValueNodeImpl(cast);
}
if (ParameterNode.class.isInstance(cast)) {
return new NodeImpl.ParameterNodeImpl(cast);
}
if (CrossParameterNode.class.isInstance(cast)) {
return new NodeImpl.CrossParameterNodeImpl(cast);
}
return new NodeImpl(cast);
}
if (!PropertyNode.class.isInstance(leaf)) {
final NodeImpl tmp = new NodeImpl.PropertyNodeImpl(leaf);
removeLeafNode();
addNode(tmp);
leaf = tmp;
}
final NodeImpl node;
if ("<cross-parameter>".equals(name)) {
node = new NodeImpl.CrossParameterNodeImpl();
} else {
node = new NodeImpl.PropertyNodeImpl(name);
}
addNode(node);
import org.apache.bval.jsr303.ConfigurationImpl;
import org.apache.bval.util.PrivilegedActions;
import javax.validation.ValidatorFactory;
import java.lang.reflect.Constructor;
public static PrivilegedAction<Constructor<?>> getDeclaredConstructor(final Class<?> clazz, final Class<?>... parameters) {
return new PrivilegedAction<Constructor<?>>() {
public Constructor<?> run() {
try {
return clazz.getDeclaredConstructor(parameters);
} catch (final NoSuchMethodException e) {
return null;
}
}
public static PrivilegedAction<Method> getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>... parameters) {
return new PrivilegedAction<Method>() {
public Method run() {
try {
return clazz.getDeclaredMethod(name, parameters);
} catch (final NoSuchMethodException e) {
return null;
}
}
};
}
public static PrivilegedAction<Method[]> getDeclaredMethods(final Class<?> clazz) {
return new PrivilegedAction<Method[]>() {
public Method[] run() {
return clazz.getDeclaredMethods();
}
};
}
public static PrivilegedAction<Constructor<?>[]> getDeclaredConstructors(final Class<?> clazz) {
return new PrivilegedAction<Constructor<?>[]>() {
public Constructor<?>[] run() {
return clazz.getDeclaredConstructors();
}
};
}
private final Map<Class<?>, Map<Member, Boolean>> ignoreAnnotationOnMember = new HashMap<Class<?>, Map<Member, Boolean>>();
private final Map<Class<?>, Boolean> ignoreAnnotationOnClass = new HashMap<Class<?>, Boolean>();
private final Map<Class<?>, Map<Member, Map<Integer, Boolean>>> ignoreAnnotationOnParameter = new HashMap<Class<?>, Map<Member, Map<Integer, Boolean>>>();
private final Map<Member, Boolean> ignoreAnnotationOnReturn = new HashMap<Member, Boolean>();
private final Map<Member, Boolean> ignoreAnnotationOnCrossParameter = new HashMap<Member, Boolean>();
public void setIgnoreAnnotationsOnMember(Member member, boolean value) {
Map<Member, Boolean> memberList = ignoreAnnotationOnMember.get(beanClass);
memberList = new HashMap<Member, Boolean>();
memberList.put(member, value);
public boolean isIgnoreAnnotations(final Member member) {
final Class<?> clazz = member.getDeclaringClass();
final Map<Member, Boolean> ignoreAnnotationForMembers = ignoreAnnotationOnMember.get(clazz);
if (ignoreAnnotationForMembers != null && ignoreAnnotationForMembers.containsKey(member)) {
final boolean value = ignoreAnnotationForMembers.get(member);
if (value) {
logMessage(member, clazz);
}
return value;
final boolean ignoreAnnotation = getDefaultIgnoreAnnotation(clazz);
public void setIgnoreAnnotationsOnParameter(final Member method, final int i, final boolean value) {
final Class<?> beanClass = method.getDeclaringClass();
Map<Member, Map<Integer, Boolean>> memberList = ignoreAnnotationOnParameter.get(beanClass);
if (memberList == null) {
memberList = new HashMap<Member, Map<Integer, Boolean>>();
ignoreAnnotationOnParameter.put(beanClass, memberList);
}
Map<Integer, Boolean> indexes = memberList.get(method);
if (indexes == null) {
indexes = new HashMap<Integer, Boolean>();
memberList.put(method, indexes);
}
indexes.put(i, value);
}
public boolean isIgnoreAnnotationOnParameter(final Member m, final int i) {
final Map<Member, Map<Integer, Boolean>> members = ignoreAnnotationOnParameter.get(m.getDeclaringClass());
if (members != null) {
final Map<Integer, Boolean> indexes = members.get(m);
if (indexes != null && indexes.containsKey(i)) {
return indexes.get(i);
}
}
return false;
}
public void setIgnoreAnnotationOnReturn(final Member method, final boolean value) {
ignoreAnnotationOnReturn.put(method, value);
}
public boolean isIgnoreAnnotationOnReturn(final Member m) {
final Boolean value = ignoreAnnotationOnReturn.get(m);
if (value != null) {
return value;
}
return false;
}
public void setIgnoreAnnotationOnCrossParameter(final Member method, final boolean value) {
ignoreAnnotationOnCrossParameter.put(method, value);
}
public boolean isIgnoreAnnotationOnCrossParameter(final Member m) {
final Boolean value = ignoreAnnotationOnCrossParameter.get(m);
if (value != null) {
return value;
}
return false;
}
import javax.validation.Valid;
if (processedValuesFromDescriptor != descriptor.size()
&& !Valid.class.equals(annotationType)) {
import org.apache.bval.jsr303.ConstraintAnnotationAttributes;
import org.apache.bval.jsr303.util.SecureActions;
import javax.validation.Payload;
import javax.validation.Valid;
import javax.validation.ValidationException;
import javax.validation.groups.ConvertGroup;
public static final class ValidAnnotation implements Valid {
public static final ValidAnnotation INSTANCE = new ValidAnnotation();
public Class<? extends Annotation> annotationType() {
return Valid.class;
}
}
public static final class ConverGroupAnnotation implements ConvertGroup {
private final Class<?> from;
private final Class<?> to;
public ConverGroupAnnotation(final Class<?> from, final Class<?> to) {
this.from = from;
this.to = to;
}
public Class<? extends Annotation> annotationType() {
return ConvertGroup.class;
}
public Class<?> from() {
return from;
}
public Class<?> to() {
return to;
}
}
import org.apache.bval.ConstructorAccess;
import java.lang.reflect.Constructor;
} else if (member instanceof Constructor<?>) {
return new ConstructorAccess((Constructor<?>) member);
public Integer getIndex() {
return index;
}
public void setIndex(final int index) {
this.index = index;
}
import javax.validation.Constraint;
import javax.validation.ConstraintValidator;
import javax.validation.Payload;
import javax.validation.ValidationException;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
private static final String VALIDATION_MAPPING_XSD = "META-INF/validation-mapping-1.1.xsd";
ConstraintAnnotationAttributes.PAYLOAD, ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO));
for (final InputStream xmlStream : xmlStreams) {
final String defaultPackage = mapping.getDefaultPackage();
for (final BeanType bean : mapping.getBean()) {
boolean ignoreAnnotations = bean.getIgnoreAnnotations() == null ? true : bean.getIgnoreAnnotations();
factory.getAnnotationIgnores().setDefaultIgnoreAnnotation(beanClass, ignoreAnnotations);
processConstructorLevel(bean.getConstructor(), beanClass, defaultPackage, ignoreAnnotations);
processFieldLevel(bean.getField(), beanClass, defaultPackage, ignoreAnnotations);
final Collection<String> potentialMethodName = processPropertyLevel(bean.getGetter(), beanClass, defaultPackage, ignoreAnnotations);
processMethodLevel(bean.getMethod(), beanClass, defaultPackage, ignoreAnnotations, potentialMethodName);
throw new ValidationException("Failed to parse XML deployment descriptor file.", e);
try {
} catch (final IOException e) {
}
if (classType.getIgnoreAnnotations() != null) {
factory.getAnnotationIgnores().setIgnoreAnnotationsOnClass(beanClass, classType.getIgnoreAnnotations());
final ConstraintType constraint, final Class<T> beanClass,
final Member member, final String defaultPackage) {
final Class<A> annotationClass = (Class<A>) loadClass(constraint.getAnnotation(), defaultPackage);
final AnnotationProxyBuilder<A> annoBuilder = new AnnotationProxyBuilder<A>(annotationClass);
for (final ElementType elementType : constraint.getElement()) {
final String name = elementType.getName();
final Class<?> returnType = getAnnotationParameterType(annotationClass, name);
final Object elementValue = getElementValue(elementType, returnType, defaultPackage);
return Byte.parseByte(value);
} else if (Short.class.equals(returnType) || short.class.equals(returnType)) {
return Short.parseShort(value);
} else if (Integer.class.equals(returnType) || int.class.equals(returnType)) {
return Integer.parseInt(value);
} else if (Long.class.equals(returnType) || long.class.equals(returnType)) {
return Long.parseLong(value);
} else if (Float.class.equals(returnType) || float.class.equals(returnType)) {
return Float.parseFloat(value);
} else if (Double.class.equals(returnType) || double.class.equals(returnType)) {
return Double.parseDouble(value);
} else if (Boolean.class.equals(returnType) || boolean.class.equals(returnType)) {
return Boolean.parseBoolean(value);
} else if (Character.class.equals(returnType) || char.class.equals(returnType)) {
if (value.length() > 1) {
throw new IllegalArgumentException("a char has a length of 1");
}
return value.charAt(0);
for (String groupClass : groupsType.getValue()) {
groupList.add(loadClass(groupClass, defaultPackage));
for (String groupClass : payloadType.getValue()) {
Class<?> payload = loadClass(groupClass, defaultPackage);
for (String groupName : groupSequenceType.getValue()) {
Class<?> group = loadClass(groupName, defaultPackage);
private <A> void processMethodLevel(final List<MethodType> methods, final Class<A> beanClass, final String defaultPackage, final boolean parentIgnoreAnn, final Collection<String> getters) {
final List<String> methodNames = new ArrayList<String>();
for (final MethodType methodType : methods) {
final String methodName = methodType.getName();
if (methodNames.contains(methodName) || getters.contains(methodName)) {
} else {
methodNames.add(methodName);
}
final Method method = doPrivileged(SecureActions.getDeclaredMethod(beanClass, methodName, toTypes(methodType.getParameter(), defaultPackage)));
if (method == null) {
}
final boolean ignoreMethodAnnotation = methodType.getIgnoreAnnotations() == null ? parentIgnoreAnn : methodType.getIgnoreAnnotations();
factory.getAnnotationIgnores().setIgnoreAnnotationsOnMember(method, ignoreMethodAnnotation);
final boolean ignoreAnn;
if (methodType.getIgnoreAnnotations() != null) {
ignoreAnn = methodType.getIgnoreAnnotations();
} else {
ignoreAnn = parentIgnoreAnn;
}
int i = 0;
for (final ParameterType p : methodType.getParameter()) {
for (final ConstraintType constraintType : p.getConstraint()) {
final MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, method, defaultPackage);
constraint.setIndex(i);
factory.addMetaConstraint(beanClass, constraint);
}
if (p.getValid() != null) {
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
constraint.setIndex(i);
factory.addMetaConstraint(beanClass, constraint);
}
if (p.getConvertGroup() != null) {
for (final GroupConversionType groupConversion : p.getConvertGroup()) {
final Class<?> from = loadClass(groupConversion.getFrom(), defaultPackage);
final Class<?> to = loadClass(groupConversion.getTo(), defaultPackage);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConverGroupAnnotation(from, to));
constraint.setIndex(i);
factory.addMetaConstraint(beanClass, constraint);
}
}
boolean ignoreParametersAnnotation = p.getIgnoreAnnotations() == null ? ignoreMethodAnnotation : p.getIgnoreAnnotations();
factory.getAnnotationIgnores().setIgnoreAnnotationsOnParameter(method, i, ignoreParametersAnnotation);
}
final ReturnValueType returnValue = methodType.getReturnValue();
if (returnValue != null) {
for (final ConstraintType constraintType : returnValue.getConstraint()) {
final MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, method, defaultPackage);
factory.addMetaConstraint(beanClass, constraint);
}
if (returnValue.getValid() != null) {
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
factory.addMetaConstraint(beanClass, constraint);
}
if (returnValue.getConvertGroup() != null) {
for (final GroupConversionType groupConversion : returnValue.getConvertGroup()) {
final Class<?> from = loadClass(groupConversion.getFrom(), defaultPackage);
final Class<?> to = loadClass(groupConversion.getTo(), defaultPackage);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConverGroupAnnotation(from, to));
factory.addMetaConstraint(beanClass, constraint);
}
}
factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(method, returnValue.getIgnoreAnnotations() == null ? ignoreAnn : returnValue.getIgnoreAnnotations());
}
final CrossParameterType crossParameter = methodType.getCrossParameter();
if (crossParameter != null) {
for (final ConstraintType constraintType : crossParameter.getConstraint()) {
final MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, method, defaultPackage);
factory.addMetaConstraint(beanClass, constraint);
}
factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(method, crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
}
}
}
private <A> void processConstructorLevel(final List<ConstructorType> constructors, final Class<A> beanClass, final String defaultPackage, final boolean parentIgnore) {
for (final ConstructorType constructorType : constructors) {
final Constructor<?> constructor = doPrivileged(SecureActions.getDeclaredConstructor(beanClass, toTypes(constructorType.getParameter(), defaultPackage)));
if (constructor == null) {
}
final boolean ignoreMethodAnnotation = constructorType.getIgnoreAnnotations() == null ? parentIgnore : constructorType.getIgnoreAnnotations();
factory.getAnnotationIgnores().setIgnoreAnnotationsOnMember(constructor, ignoreMethodAnnotation);
final boolean ignoreAnn;
if (constructorType.getIgnoreAnnotations() != null) {
ignoreAnn = constructorType.getIgnoreAnnotations();
} else {
ignoreAnn = parentIgnore;
}
int i = 0;
for (final ParameterType p : constructorType.getParameter()) {
for (final ConstraintType constraintType : p.getConstraint()) {
final MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, constructor, defaultPackage);
constraint.setIndex(i);
factory.addMetaConstraint(beanClass, constraint);
}
if (p.getValid() != null) {
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
constraint.setIndex(i);
factory.addMetaConstraint(beanClass, constraint);
}
if (p.getConvertGroup() != null) {
for (final GroupConversionType groupConversion : p.getConvertGroup()) {
final Class<?> from = loadClass(groupConversion.getFrom(), defaultPackage);
final Class<?> to = loadClass(groupConversion.getTo(), defaultPackage);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, new AnnotationProxyBuilder.ConverGroupAnnotation(from, to));
constraint.setIndex(i);
factory.addMetaConstraint(beanClass, constraint);
}
}
boolean ignoreParametersAnnotation = p.getIgnoreAnnotations() == null ? ignoreMethodAnnotation : p.getIgnoreAnnotations();
if (ignoreParametersAnnotation || (ignoreMethodAnnotation && p.getIgnoreAnnotations() == null)) {
}
factory.getAnnotationIgnores().setIgnoreAnnotationsOnParameter(constructor, i, p.getIgnoreAnnotations() != null ? p.getIgnoreAnnotations() : ignoreAnn);
}
final ReturnValueType returnValue = constructorType.getReturnValue();
if (returnValue != null) {
for (final ConstraintType constraintType : returnValue.getConstraint()) {
final MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, constructor, defaultPackage);
constraint.setIndex(-1);
factory.addMetaConstraint(beanClass, constraint);
}
if (returnValue.getValid() != null) {
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
constraint.setIndex(-1);
factory.addMetaConstraint(beanClass, constraint);
}
if (returnValue.getConvertGroup() != null) {
for (final GroupConversionType groupConversion : returnValue.getConvertGroup()) {
final Class<?> from = loadClass(groupConversion.getFrom(), defaultPackage);
final Class<?> to = loadClass(groupConversion.getTo(), defaultPackage);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, new AnnotationProxyBuilder.ConverGroupAnnotation(from, to));
constraint.setIndex(-1);
factory.addMetaConstraint(beanClass, constraint);
}
}
factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(constructor, returnValue.getIgnoreAnnotations() != null ? returnValue.getIgnoreAnnotations() : ignoreAnn);
}
final CrossParameterType crossParameter = constructorType.getCrossParameter();
if (crossParameter != null) {
for (final ConstraintType constraintType : crossParameter.getConstraint()) {
final MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, constructor, defaultPackage);
factory.addMetaConstraint(beanClass, constraint);
}
factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(constructor, crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
}
}
}
private Class<?>[] toTypes(final List<ParameterType> parameter, final String defaultPck) {
if (parameter == null) {
return null;
}
final Class<?>[] types = new Class<?>[parameter.size()];
int i = 0;
for (final ParameterType type : parameter) {
}
return types;
}
private <A> void processFieldLevel(List<FieldType> fields, Class<A> beanClass,
String defaultPackage, boolean ignoreAnnotations) {
final List<String> fieldNames = new ArrayList<String>();
final boolean ignoreFieldAnnotation = fieldType.getIgnoreAnnotations() == null ? ignoreAnnotations : fieldType.getIgnoreAnnotations();
factory.getAnnotationIgnores().setIgnoreAnnotationsOnMember(field, ignoreFieldAnnotation);
for (final GroupConversionType conversion : fieldType.getConvertGroup()) {
final Class<?> from = loadClass(conversion.getFrom(), defaultPackage);
final Class<?> to = loadClass(conversion.getTo(), defaultPackage);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, field, new AnnotationProxyBuilder.ConverGroupAnnotation(from, to));
factory.addMetaConstraint(beanClass, constraint);
}
private <A> Collection<String> processPropertyLevel(List<GetterType> getters, Class<A> beanClass,
String defaultPackage, boolean ignoreAnnotatino) {
final String getterName = getterType.getName();
if (getterNames.contains(methodName)) {
getterNames.add(methodName);
final boolean ignoreGetterAnnotation = getterType.getIgnoreAnnotations() == null ? ignoreAnnotatino : getterType.getIgnoreAnnotations();
factory.getAnnotationIgnores().setIgnoreAnnotationsOnMember(method, ignoreGetterAnnotation);
for (final GroupConversionType conversion : getterType.getConvertGroup()) {
final Class<?> from = loadClass(conversion.getFrom(), defaultPackage);
final Class<?> to = loadClass(conversion.getTo(), defaultPackage);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConverGroupAnnotation(from, to));
factory.addMetaConstraint(beanClass, constraint);
}
return getterNames;
if (validatedByType.getIncludeExistingValidators() != null &&
validatedByType.getIncludeExistingValidators()) {
for (String validatorClassName : validatedByType.getValue()) {
loadClass(validatorClassName);
if (className.startsWith("[L") && className.endsWith(";")) {
} else {
}
import org.apache.bval.cdi.BValExtension;
import org.apache.bval.jsr303.BootstrapConfigurationImpl;
import org.apache.bval.jsr303.util.IOs;
import javax.validation.ParameterNameProvider;
import javax.validation.executable.ExecutableType;
import java.io.Closeable;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CopyOnWriteArraySet;
public class ValidationParser implements Closeable {
"META-INF/validation-configuration-1.1.xsd";
private ValidationConfigType xmlConfig;
private BootstrapConfigurationImpl bootstrap;
private Collection<ValidationException> exceptions = new CopyOnWriteArrayList<ValidationException>();
private Collection<BValExtension.Releasable> releasables = new CopyOnWriteArrayList<BValExtension.Releasable>();
private ValidationParser() {
}
public void applyConfigWithInstantiation(ConfigurationImpl targetConfig) {
if (xmlConfig == null) {
return;
applyProviderClass(xmlConfig, targetConfig);
applyMessageInterpolator(xmlConfig, targetConfig);
applyTraversableResolver(xmlConfig, targetConfig);
applyConstraintFactory(xmlConfig, targetConfig);
applyParameterNameProvider(xmlConfig, targetConfig);
applyMappingStreams(xmlConfig, targetConfig);
applyProperties(xmlConfig, targetConfig);
}
public BootstrapConfigurationImpl getBootstrap() {
return bootstrap;
}
public static String getValidationXmlFile(String file) {
if (file == null) {
return DEFAULT_VALIDATION_XML_FILE;
}
return file;
public static ValidationParser processValidationConfig(final String file, final ConfigurationImpl targetConfig, final boolean ignoreXml) {
final ValidationParser parser = new ValidationParser();
if (!ignoreXml) {
parser.xmlConfig = parseXmlConfig(file);
if (parser.xmlConfig != null) {
if (parser.xmlConfig.getExecutableValidation() == null) {
final ExecutableValidationType value = new ExecutableValidationType();
value.setEnabled(true);
final DefaultValidatedExecutableTypesType defaultValidatedExecutableTypes = new DefaultValidatedExecutableTypesType();
value.setDefaultValidatedExecutableTypes(defaultValidatedExecutableTypes);
defaultValidatedExecutableTypes.getExecutableType().add(ExecutableType.CONSTRUCTORS);
defaultValidatedExecutableTypes.getExecutableType().add(ExecutableType.NON_GETTER_METHODS);
parser.xmlConfig.setExecutableValidation(value);
}
applySimpleConfig(parser.xmlConfig, targetConfig);
parser.bootstrap = new BootstrapConfigurationImpl(
parser.xmlConfig.getDefaultProvider(),
parser.xmlConfig.getConstraintValidatorFactory(),
parser.xmlConfig.getMessageInterpolator(),
parser.xmlConfig.getTraversableResolver(),
parser.xmlConfig.getParameterNameProvider(),
new CopyOnWriteArraySet<String>(parser.xmlConfig.getConstraintMapping()),
parser.xmlConfig.getExecutableValidation().getEnabled(),
new CopyOnWriteArraySet<ExecutableType>(targetConfig.getExecutableValidation()),
toMap(parser.xmlConfig.getProperty()));
return parser;
final CopyOnWriteArraySet<ExecutableType> executableTypes = new CopyOnWriteArraySet<ExecutableType>();
executableTypes.add(ExecutableType.CONSTRUCTORS);
executableTypes.add(ExecutableType.NON_GETTER_METHODS);
parser.bootstrap = new BootstrapConfigurationImpl(
null, null, null, null, null,
new CopyOnWriteArraySet<String>(),
true,
executableTypes,
new HashMap<String, String>());
targetConfig.setExecutableValidation(executableTypes);
}
return parser;
private static Map<String, String> toMap(final List<PropertyType> property) {
final Map<String, String> map = new HashMap<String, String>();
if (property != null) {
for (final PropertyType p : property) {
map.put(p.getName(), p.getValue());
}
}
return map;
}
private static ValidationConfigType parseXmlConfig(final String validationXmlFile) {
inputStream = getInputStream(getValidationXmlFile(validationXmlFile));
protected static InputStream getInputStream(String path) throws IOException {
ClassLoader loader = PrivilegedActions.getClassLoader(ValidationParser.class);
return IOs.convertToMarkableInputStream(inputStream);
private static Schema getSchema() {
public static void applySimpleConfig(ValidationConfigType xmlConfig, ConfigurationImpl targetConfig) {
applyExecutableValidation(xmlConfig, targetConfig);
private static void applyProperties(ValidationConfigType xmlConfig, ConfigurationImpl target) {
for (final PropertyType property : xmlConfig.getProperty()) {
private static void applyExecutableValidation(final ValidationConfigType xmlConfig, final ConfigurationImpl targetConfig) {
final CopyOnWriteArrayList<ExecutableType> executableTypes = new CopyOnWriteArrayList<ExecutableType>();
if (xmlConfig.getExecutableValidation() != null && xmlConfig.getExecutableValidation().getEnabled()
&& xmlConfig.getExecutableValidation().getDefaultValidatedExecutableTypes() != null) {
executableTypes.addAll(xmlConfig.getExecutableValidation().getDefaultValidatedExecutableTypes().getExecutableType());
}
if (executableTypes.contains(ExecutableType.ALL)) {
executableTypes.clear();
executableTypes.add(ExecutableType.CONSTRUCTORS);
executableTypes.add(ExecutableType.NON_GETTER_METHODS);
executableTypes.add(ExecutableType.GETTER_METHODS);
executableTypes.clear();
}
targetConfig.setExecutableValidation(executableTypes);
}
private void applyParameterNameProvider(final ValidationConfigType xmlConfig, final ConfigurationImpl targetConfig) {
final String parameterNameProvider = xmlConfig.getParameterNameProvider();
if (parameterNameProvider != null) {
final Class<? extends ParameterNameProvider> clazz = Class.class.cast(loadClass(parameterNameProvider));
targetConfig.parameterNameProvider(newInstance(clazz));
log.log(Level.INFO, String.format("Using %s as validation provider.", parameterNameProvider));
}
}
}
(Class<? extends ValidationProvider<?>>) loadClass(providerClassName);
try {
final BValExtension.Releasable<T> releasable = BValExtension.inject(cls);
releasables.add(releasable);
return releasable.getInstance();
} catch (final Exception e) {
return cls.newInstance();
} catch (final NoClassDefFoundError error) {
return cls.newInstance();
}
private static void applyMappingStreams(ValidationConfigType xmlConfig,
for (String rawMappingFileName : xmlConfig.getConstraintMapping()) {
String mappingFileName = rawMappingFileName;
InputStream in;
loader = ValidationParser.class.getClassLoader();
return null;
public void ensureValidatorFactoryCanBeBuilt() {
if (!exceptions.isEmpty()) {
throw  exceptions.iterator().next();
}
}
public void close() throws IOException {
for (final BValExtension.Releasable<?> releasable : releasables) {
releasable.release();
}
releasables.clear();
}
ResourceBundle.getBundle(DEFAULT_VALIDATION_MESSAGES, defaultLocale));
resolver.add(new BeanELResolver());
context.getConstraintDescriptor().getAttributes(), locale, context.getValidatedValue());
import org.apache.bval.el.MessageEvaluator;
private final MessageEvaluator evaluator;
MessageEvaluator ev = null;
try {
ev = MessageEvaluator.class.cast(getClass().getClassLoader().loadClass("org.apache.bval.el.ELFacade").newInstance());
}
evaluator = ev;
if (evaluator != null) {
resolvedMessage = evaluator.interpolate(resolvedMessage, annotationParameters, validatedValue);
protected void configure(final ConfigurationState configuration) {
if (!impl.isValidated(impl)) {
checkValidationAppliesTo(impl.getConstraintDescriptors(), ConstraintTarget.PARAMETERS);
checkValidationAppliesTo(impl.getConstraintDescriptors(), ConstraintTarget.RETURN_VALUE);
}
final ConstraintValidation constraintValidation = ConstraintValidation.class.cast(validation);
if (!constraintValidation.isValidated()) {
checkValidationAppliesTo(constraintValidation.getValidationAppliesTo(), ConstraintTarget.PARAMETERS);
checkValidationAppliesTo(constraintValidation.getValidationAppliesTo(), ConstraintTarget.RETURN_VALUE);
constraintValidation.setValidated(true);
}
if (!constructorDescriptor.isValidated(constructor)) {
if (parameterValues.length > 0) {
checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()), ConstraintTarget.IMPLICIT);
checkValidationAppliesTo(constructorDescriptor.getParameterDescriptors(), ConstraintTarget.IMPLICIT);
} else {
checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()), ConstraintTarget.PARAMETERS);
checkValidationAppliesTo(constructorDescriptor.getParameterDescriptors(), ConstraintTarget.PARAMETERS);
}
constructorDescriptor.setValidated(constructor);
if (!methodDescriptor.isValidated(method)) {
if (method.getParameterTypes().length > 0 && method.getReturnType() != Void.TYPE) {
checkValidationAppliesTo(Collections.singleton(methodDescriptor.getCrossParameterDescriptor()), ConstraintTarget.IMPLICIT);
checkValidationAppliesTo(methodDescriptor.getParameterDescriptors(), ConstraintTarget.IMPLICIT);
} else if (method.getParameterTypes().length == 0) {
checkValidationAppliesTo(Collections.singleton(methodDescriptor.getCrossParameterDescriptor()), ConstraintTarget.PARAMETERS);
checkValidationAppliesTo(methodDescriptor.getParameterDescriptors(), ConstraintTarget.PARAMETERS);
}
methodDescriptor.setValidated(method);
private boolean validated = false;
public boolean isValidated() {
return validated;
}
public void setValidated(final boolean validated) {
this.validated = validated;
}
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;
private final Collection<Object> validated = new CopyOnWriteArraySet<Object>();
public boolean isValidated(final Object object) {
return validated.contains(object);
}
public void setValidated(final Object object) {
this.validated.add(object);
}
final String executableTypesStr = getProperties().remove(ApacheValidatorConfiguration.Properties.EXECUTABLE_VALIDATION_TYPES);
final ConstraintDescriptorImpl that = (ConstraintDescriptorImpl) o;
if (attributes != null ? !attributes.equals(that.attributes) : that.attributes != null) return false;
if (groups != null ? !groups.equals(that.groups) : that.groups != null) return false;
int result = annotation.annotationType().hashCode();
import java.lang.reflect.Member;
return (T) this;
protected <T> GroupValidationContext<T> createInvocableContext(MetaBean metaBean, T object, Class<T> objectClass, Class<?>... groups) {
final ConstraintValidationListener<T> listener = new ConstraintValidationListener<T>(object, objectClass);
final GroupValidationContextImpl<T> context =
new GroupValidationContextImpl<T>(listener, this.factoryContext.getMessageInterpolator(),
this.factoryContext.getTraversableResolver(), factoryContext.getParameterNameProvider(), metaBean);
context.setBean(object, metaBean);
final Groups computedGroup = groupsComputer.computeGroups(groups);
if (computedGroup.getGroups().size() == 1 && Group.DEFAULT.equals(computedGroup.getGroups().iterator().next()) && metaBean.getFeature(Jsr303Features.Bean.GROUP_SEQUENCE) != null) {
final Groups sequence = new Groups();
sequence.getGroups().addAll(List.class.cast(metaBean.getFeature(Jsr303Features.Bean.GROUP_SEQUENCE)));
context.setGroups(sequence);
} else {
context.setGroups(computedGroup);
}
return context;
}
return validateInvocationParameters(constructor, parameterValues, constructorDescriptor, gps, new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(), Arrays.asList(constructor.getParameterTypes())), null);
}
private <T> Set<ConstraintViolation<T>> validateInvocationParameters(final Member invocable, final Object[] parameterValues, final InvocableElementDescriptor constructorDescriptor,
final Class<?>[] gps, final NodeImpl rootNode, final Object rootBean) {
final GroupValidationContext<ConstraintValidationListener<?>> parametersContext = createInvocableContext(constructorDescriptor.getMetaBean(), rootBean, Class.class.cast(invocable.getDeclaringClass()), gps);
final GroupValidationContext<Object> crossParameterContext = createContext(constructorDescriptor.getMetaBean(), rootBean, Class.class.cast(invocable.getDeclaringClass()), gps);
final Method m = Method.class.cast(invocable);
parametersContext.setMethod(m);
crossParameterContext.setMethod(m);
} else {
final Constructor<?> m = Constructor.class.cast(invocable);
parametersContext.setConstructor(m);
crossParameterContext.setConstructor(m);
final Groups groups = parametersContext.getGroups();
final List<ParameterDescriptor> parameterDescriptors = constructorDescriptor.getParameterDescriptors();
final ElementDescriptorImpl crossParamDescriptor = ElementDescriptorImpl.class.cast(constructorDescriptor.getCrossParameterDescriptor());
final Set<ConstraintDescriptor<?>> crossParamConstraints = crossParamDescriptor.getConstraintDescriptors();
crossParameterContext.setBean(parameterValues);
crossParameterContext.moveDown(rootNode);
crossParameterContext.moveDown("<cross-parameter>");
crossParameterContext.setKind(ElementKind.CROSS_PARAMETER);
parametersContext.moveDown(rootNode);
parametersContext.setParameters(parameterValues);
for (final Group current : groups.getGroups()) {
final ParameterDescriptorImpl paramDesc = ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
parametersContext.setBean(parameterValues[i]);
parametersContext.moveDown(new NodeImpl.ParameterNodeImpl(paramDesc.getName(), i));
for (final ConstraintDescriptor<?> constraintDescriptor : paramDesc.getConstraintDescriptors()) {
final ConstraintValidation<?> validation = ConstraintValidation.class.cast(constraintDescriptor);
parametersContext.setCurrentGroup(paramDesc.mapGroup(current));
validation.validate(parametersContext);
}
parametersContext.moveUp(null, null);
for (final ConstraintDescriptor<?> d : crossParamConstraints) {
final ConstraintValidation<?> validation = ConstraintValidation.class.cast(d);
crossParameterContext.setCurrentGroup(crossParamDescriptor.mapGroup(current));
validation.validate(crossParameterContext);
}
break;
}
for (final Group current : groups.getGroups()) {
final ParameterDescriptorImpl paramDesc = ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
if (paramDesc.isCascaded() && parameterValues[i] != null) {
parametersContext.setBean(parameterValues[i]);
parametersContext.moveDown(new NodeImpl.ParameterNodeImpl(paramDesc.getName(), i));
initMetaBean(parametersContext, factoryContext.getMetaBeanFinder(), parameterValues[i].getClass());
parametersContext.setCurrentGroup(paramDesc.mapGroup(current));
ValidationHelper.validateContext(parametersContext, new Jsr303ValidationCallback(parametersContext), isTreatMapsLikeBeans());
parametersContext.moveUp(null, null);
}
}
}
for (final List<Group> eachSeq : groups.getSequences()) {
for (final Group current : eachSeq) {
final ParameterDescriptorImpl paramDesc = ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
parametersContext.setBean(parameterValues[i]);
parametersContext.moveDown(new NodeImpl.ParameterNodeImpl(paramDesc.getName(), i));
for (final ConstraintDescriptor<?> constraintDescriptor : paramDesc.getConstraintDescriptors()) {
final ConstraintValidation<?> validation = ConstraintValidation.class.cast(constraintDescriptor);
parametersContext.setCurrentGroup(paramDesc.mapGroup(current));
validation.validate(parametersContext);
}
parametersContext.moveUp(null, null);
}
for (final ConstraintDescriptor<?> d : crossParamConstraints) {
final ConstraintValidation<?> validation = ConstraintValidation.class.cast(d);
crossParameterContext.setCurrentGroup(crossParamDescriptor.mapGroup(current));
validation.validate(crossParameterContext);
}
break;
}
}
for (final Group current : eachSeq) {
final ParameterDescriptorImpl paramDesc = ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
if (paramDesc.isCascaded() && parameterValues[i] != null) {
parametersContext.setBean(parameterValues[i]);
parametersContext.moveDown(new NodeImpl.ParameterNodeImpl(paramDesc.getName(), i));
initMetaBean(parametersContext, factoryContext.getMetaBeanFinder(), parameterValues[i].getClass());
parametersContext.setCurrentGroup(paramDesc.mapGroup(current));
ValidationHelper.validateContext(parametersContext, new Jsr303ValidationCallback(parametersContext), isTreatMapsLikeBeans());
parametersContext.moveUp(null, null);
}
}
}
}
if (constructorDescriptor.isCascaded()) {
if (parametersContext.getValidatedValue() != null) {
initMetaBean(parametersContext, factoryContext.getMetaBeanFinder(), parametersContext.getValidatedValue().getClass());
for (final Group current : groups.getGroups()) {
parametersContext.setCurrentGroup(constructorDescriptor.mapGroup(current));
ValidationHelper.validateContext(parametersContext, new Jsr303ValidationCallback(parametersContext), isTreatMapsLikeBeans());
}
for (final List<Group> eachSeq : groups.getSequences()) {
for (final Group current : eachSeq) {
parametersContext.setCurrentGroup(constructorDescriptor.mapGroup(current));
ValidationHelper.validateContext(parametersContext, new Jsr303ValidationCallback(parametersContext), isTreatMapsLikeBeans());
if (!parametersContext.getListener().isEmpty()) {
break;
}
}
}
}
if (crossParameterContext.getValidatedValue() != null) {
initMetaBean(crossParameterContext, factoryContext.getMetaBeanFinder(), crossParameterContext.getValidatedValue().getClass());
for (final Group current : groups.getGroups()) {
crossParameterContext.setCurrentGroup(constructorDescriptor.mapGroup(current));
ValidationHelper.validateContext(crossParameterContext, new Jsr303ValidationCallback(crossParameterContext), isTreatMapsLikeBeans());
}
for (final List<Group> eachSeq : groups.getSequences()) {
for (final Group current : eachSeq) {
crossParameterContext.setCurrentGroup(constructorDescriptor.mapGroup(current));
ValidationHelper.validateContext(crossParameterContext, new Jsr303ValidationCallback(crossParameterContext), isTreatMapsLikeBeans());
if (!crossParameterContext.getListener().isEmpty()) {
break;
}
}
}
}
}
violations.addAll(Set.class.cast(parametersContext.getListener().getConstraintViolations()));
violations.addAll(Set.class.cast(crossParameterContext.getListener().getConstraintViolations()));
public <T> Set<ConstraintViolation<T>> validateConstructorReturnValue(final Constructor<? extends T> constructor, final T createdObject, final Class<?>... gps) {
{
notNull("Constructor", constructor);
notNull("Returned value", createdObject);
final Class<? extends T> declaringClass = constructor.getDeclaringClass();
final ConstructorDescriptorImpl methodDescriptor = ConstructorDescriptorImpl.class.cast(getConstraintsForClass(declaringClass).getConstraintsForConstructor(constructor.getParameterTypes()));
return validaReturnedValue(new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(), Arrays.asList(constructor.getParameterTypes())), createdObject, declaringClass, methodDescriptor, gps, null);
}
private <T> Set<ConstraintViolation<T>> validaReturnedValue(final NodeImpl rootNode, final T createdObject, final Class<?> clazz,
final InvocableElementDescriptor methodDescriptor, final Class<?>[] gps,
final Object rootBean) {
final ElementDescriptorImpl returnedValueDescriptor = ElementDescriptorImpl.class.cast(methodDescriptor.getReturnValueDescriptor());
final Set<ConstraintDescriptor<?>> returnedValueConstraints = returnedValueDescriptor.getConstraintDescriptors();
final GroupValidationContext<T> context = createInvocableContext(methodDescriptor.getMetaBean(), createdObject, Class.class.cast(Proxies.classFor(clazz)), gps);
context.moveDown(rootNode);
context.moveDown(new NodeImpl.ReturnValueNodeImpl());
context.setReturnValue(rootBean);
final Groups groups = context.getGroups();
for (final Group current : groups.getGroups()) {
for (final ConstraintDescriptor<?> d : returnedValueConstraints) {
final ConstraintValidation<?> validation = ConstraintValidation.class.cast(d);
context.setCurrentGroup(returnedValueDescriptor.mapGroup(current));
validation.validate(context);
if (gps.length == 0 && !context.getListener().getConstraintViolations().isEmpty()) {
break;
}
}
int currentViolationNumber = context.getListener().getConstraintViolations().size();
for (final Group current : groups.getGroups()) {
if (returnedValueDescriptor.isCascaded() && context.getValidatedValue() != null) {
context.setBean(createdObject);
initMetaBean(context, factoryContext.getMetaBeanFinder(), context.getValidatedValue().getClass());
context.setCurrentGroup(methodDescriptor.mapGroup(current));
ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
if (currentViolationNumber < context.getListener().getConstraintViolations().size()) {
break;
for (final List<Group> eachSeq : groups.getSequences()) {
for (final Group current : eachSeq) {
for (final ConstraintDescriptor<?> d : returnedValueConstraints) {
final ConstraintValidation<?> validation = ConstraintValidation.class.cast(d);
context.setCurrentGroup(current);
validation.validate(context);
}
if (!context.getListener().getConstraintViolations().isEmpty()) {
break;
}
}
currentViolationNumber = context.getListener().getConstraintViolations().size();
for (final Group current : eachSeq) {
if (returnedValueDescriptor.isCascaded() && context.getValidatedValue() != null) {
context.setBean(createdObject);
initMetaBean(context, factoryContext.getMetaBeanFinder(), context.getValidatedValue().getClass());
context.setCurrentGroup(methodDescriptor.mapGroup(current));
ValidationHelper.validateContext(context, new Jsr303ValidationCallback(context), isTreatMapsLikeBeans());
if (currentViolationNumber < context.getListener().getConstraintViolations().size()) {
break;
}
}
}
}
return context.getListener().getConstraintViolations();
return validateInvocationParameters(method, parameterValues, methodDescriptor, groups, new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())), object);
return Set.class.cast(validaReturnedValue(new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())), returnValue, object.getClass(), methodDescriptor, groups, object));
beforeBeanDiscovery.addAnnotatedType(beanManager.createAnnotatedType(BValInterceptor.class));
import org.jboss.arquillian.container.test.spi.client.deployment.ApplicationArchiveProcessor;
builder.service(TestEnricher.class, EJBEnricher.class)
.service(ApplicationArchiveProcessor.class, CdiMethodValidationProcessor.class);
import java.util.HashSet;
import java.util.concurrent.CopyOnWriteArraySet;
globalExecutableTypes = convertToRuntimeTypes(bootstrap.getDefaultValidatedExecutableTypes());
private static Set<ExecutableType> convertToRuntimeTypes(final Set<ExecutableType> defaultValidatedExecutableTypes) {
final Set<ExecutableType> types = new CopyOnWriteArraySet<ExecutableType>();
for (final ExecutableType type : defaultValidatedExecutableTypes) {
if (ExecutableType.IMPLICIT.equals(type)) {
types.add(ExecutableType.CONSTRUCTORS);
types.add(ExecutableType.NON_GETTER_METHODS);
} else if (ExecutableType.ALL.equals(type)) {
types.add(ExecutableType.CONSTRUCTORS);
types.add(ExecutableType.NON_GETTER_METHODS);
types.add(ExecutableType.GETTER_METHODS);
break;
} else if (!ExecutableType.NONE.equals(type)) {
types.add(type);
}
}
return types;
}
public Set<ExecutableType> getGlobalExecutableTypes() {
return globalExecutableTypes;
}
if (!isExecutableValidationEnabled) {
return;
}
if (!isExecutableValidationEnabled) {
return;
}
import javax.validation.executable.ExecutableType;
import javax.validation.executable.ValidateOnExecution;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;
private Collection<ExecutableType> classConfiguration = null;
private final Map<Method, Boolean> methodConfiguration = new ConcurrentHashMap<Method, Boolean>();
@Inject
private BValExtension globalConfiguration;
final Method method = context.getMethod();
if (!isMethodValidated(Proxies.classFor(context.getTarget().getClass()), method)) {
return context.proceed();
}
private boolean isMethodValidated(final Class<?> targetClass, final Method method) throws NoSuchMethodException {
if (classConfiguration == null) {
synchronized (this) {
if (classConfiguration == null) {
classConfiguration = new CopyOnWriteArraySet<ExecutableType>();
final ValidateOnExecution annotation = targetClass.getAnnotation(ValidateOnExecution.class);
if (annotation == null) {
classConfiguration.addAll(globalConfiguration.getGlobalExecutableTypes());
} else {
for (final ExecutableType type : annotation.type()) {
if (ExecutableType.IMPLICIT.equals(type)) {
classConfiguration.add(ExecutableType.CONSTRUCTORS);
classConfiguration.add(ExecutableType.NON_GETTER_METHODS);
} else if (ExecutableType.ALL.equals(type)) {
classConfiguration.add(ExecutableType.CONSTRUCTORS);
classConfiguration.add(ExecutableType.NON_GETTER_METHODS);
classConfiguration.add(ExecutableType.GETTER_METHODS);
break;
} else if (!ExecutableType.NONE.equals(type)) {
classConfiguration.add(type);
}
}
}
}
}
}
methodConfig = methodConfiguration.get(method);
if (methodConfig == null) {
synchronized (this) {
methodConfig = methodConfiguration.get(method);
if (methodConfig == null) {
final ValidateOnExecution annotation = targetClass.getMethod(method.getName(), method.getParameterTypes()).getAnnotation(ValidateOnExecution.class);
if (annotation == null) {
methodConfig = doValidMethod(method, classConfiguration);
} else {
final Collection<ExecutableType> config = new HashSet<ExecutableType>();
for (final ExecutableType type : annotation.type()) {
config.add(ExecutableType.CONSTRUCTORS);
config.add(ExecutableType.NON_GETTER_METHODS);
config.add(ExecutableType.GETTER_METHODS);
} else if (ExecutableType.ALL.equals(type)) {
config.add(ExecutableType.CONSTRUCTORS);
config.add(ExecutableType.NON_GETTER_METHODS);
config.add(ExecutableType.GETTER_METHODS);
break;
} else if (!ExecutableType.NONE.equals(type)) {
config.add(type);
}
}
methodConfig = doValidMethod(method, config);
}
}
methodConfiguration.put(method, methodConfig);
}
}
return methodConfig;
}
private boolean doValidMethod(final Method method, final Collection<ExecutableType> config) {
final boolean getter = isGetter(method);
return (!getter && config.contains(ExecutableType.NON_GETTER_METHODS)) || (getter && config.contains(ExecutableType.GETTER_METHODS));
}
private static boolean isGetter(final Method method) {
final String name = method.getName();
return (name.startsWith("get") || name.startsWith("is")) && method.getReturnType() != Void.TYPE && method.getParameterTypes().length == 0;
}
import org.apache.bval.jsr303.util.ClassHelper;
import javax.interceptor.AroundConstruct;
import javax.validation.metadata.ConstructorDescriptor;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
private Boolean constructorValidated = null;
private ExecutableValidator executableValidator;
public Object construct(final InvocationContext context) throws Exception {
final Constructor constructor = context.getConstructor();
final Class<?> targetClass = Proxies.classFor(context.getTarget().getClass());
if (!isConstructorValidated(targetClass, constructor)) {
final ConstructorDescriptor constraints = validator.getConstraintsForClass(targetClass).getConstraintsForConstructor(constructor.getParameterTypes());
if (constraints == null) {
initExecutableValidator();
final Set<ConstraintViolation<?>> violations = executableValidator.validateConstructorParameters(constructor, context.getParameters());
final Set<ConstraintViolation<?>> violations = executableValidator.validateConstructorReturnValue(constructor, result);
@AroundInvoke
public Object invoke(final InvocationContext context) throws Throwable {
final Method method = context.getMethod();
final Class<?> targetClass = Proxies.classFor(context.getTarget().getClass());
if (!isMethodValidated(targetClass, method)) {
return context.proceed();
}
final MethodDescriptor constraintsForMethod = validator.getConstraintsForClass(targetClass).getConstraintsForMethod(method.getName(), method.getParameterTypes());
if (constraintsForMethod == null) {
return context.proceed();
}
initExecutableValidator();
{
final Set<ConstraintViolation<Object>> violations = executableValidator.validateParameters(context.getTarget(), method, context.getParameters());
if (!violations.isEmpty()) {
throw new ConstraintViolationException(violations);
}
}
final Object result = context.proceed();
{
final Set<ConstraintViolation<Object>> violations = executableValidator.validateReturnValue(context.getTarget(), method, result);
if (!violations.isEmpty()) {
throw new ConstraintViolationException(violations);
}
}
return result;
}
private boolean isConstructorValidated(final Class<?> targetClass, final Constructor<?> constructor) throws NoSuchMethodException {
initClassConfig(targetClass);
if (constructorValidated == null) {
synchronized (this) {
if (constructorValidated == null) {
final ValidateOnExecution annotation = targetClass.getConstructor(constructor.getParameterTypes()).getAnnotation(ValidateOnExecution.class);
if (annotation == null) {
constructorValidated = classConfiguration.contains(ExecutableType.CONSTRUCTORS);
} else {
final Collection<ExecutableType> types = Arrays.asList(annotation.type());
constructorValidated = types.contains(ExecutableType.CONSTRUCTORS) || types.contains(ExecutableType.IMPLICIT) || types.contains(ExecutableType.ALL);
}
}
}
}
return constructorValidated;
}
initClassConfig(targetClass);
Boolean methodConfig = methodConfiguration.get(method);
if (methodConfig == null) {
synchronized (this) {
methodConfig = methodConfiguration.get(method);
if (methodConfig == null) {
final List<Class<?>> classHierarchy = ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), targetClass);
Class<?> lastClassWithTheMethod = null;
Collections.reverse(classHierarchy);
ValidateOnExecution validateOnExecution = null;
for (final Class<?> c : classHierarchy) {
try {
validateOnExecution = c.getDeclaredMethod(method.getName(), method.getParameterTypes()).getAnnotation(ValidateOnExecution.class);
if (lastClassWithTheMethod == null) {
lastClassWithTheMethod = c;
}
if (validateOnExecution != null) {
lastClassWithTheMethod = null;
break;
}
} catch (final Throwable h) {
}
}
if (validateOnExecution == null && lastClassWithTheMethod != null) {
validateOnExecution = lastClassWithTheMethod.getAnnotation(ValidateOnExecution.class);
}
if (validateOnExecution == null) {
methodConfig = doValidMethod(method, classConfiguration);
} else {
final Collection<ExecutableType> config = new HashSet<ExecutableType>();
for (final ExecutableType type : validateOnExecution.type()) {
config.add(ExecutableType.NON_GETTER_METHODS);
if (lastClassWithTheMethod == null) {
config.add(ExecutableType.GETTER_METHODS);
} else if (ExecutableType.ALL.equals(type)) {
config.add(ExecutableType.NON_GETTER_METHODS);
config.add(ExecutableType.GETTER_METHODS);
break;
} else if (!ExecutableType.NONE.equals(type)) {
config.add(type);
}
}
methodConfig = doValidMethod(method, config);
}
}
methodConfiguration.put(method, methodConfig);
}
}
return methodConfig;
}
private void initClassConfig(Class<?> targetClass) {
private void initExecutableValidator() {
if (executableValidator == null) {
synchronized (this) {
if (executableValidator == null) {
executableValidator = validator.forExecutables();
}
}
}
}
private static boolean doValidMethod(final Method method, final Collection<ExecutableType> config) {
import javax.validation.metadata.ConstraintDescriptor;
final boolean getter = (method.getName().startsWith("get") || method.getName().startsWith("is")) && method.getParameterTypes().length == 0 && method.getReturnType() != Void.TYPE;
final List<ParameterDescriptor> parameterDescriptors = methodDesc.getParameterDescriptors();
if (!parameterDescriptors.contains(paramDesc)) {
parameterDescriptors.add(paramDesc);
}
final List<ConstraintValidation<?>> newValidations = validations.getValidations();
boolean alreadyHere = false;
for (final ConstraintDescriptor<?> existing : paramDesc.getMutableConstraintDescriptors()) {
alreadyHere = true;
break;
}
}
if (!alreadyHere) {
paramDesc.getMutableConstraintDescriptors().add(validation);
}
}
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
final ParameterAccess that = (ParameterAccess) o;
return paramIdx == that.paramIdx && paramType.equals(that.paramType);
}
@Override
public int hashCode() {
int result = paramType.hashCode();
return result;
}
static public List<Class<?>> fillFullClassHierarchyAsList(List<Class<?>> allClasses, Class<?> clazz) {
return allClasses;
return allClasses;
return allClasses;
import javax.annotation.Priority;
private ExecutableValidator executableValidator = null;
final Class<?> targetClass = constructor.getDeclaringClass();
private static final String ValidationInterceptorPriorityTest_BEANS_XML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<beans xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"       xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee\n"
"      http://java.sun.com/xml/ns/javaee/beans_1_0.xsd\">\n"
"  <interceptors>\n"
"    <class>org.hibernate.beanvalidation.tck.tests.integration.cdi.executable.priority.LaterInterceptor</class>\n"
"    <class>org.hibernate.beanvalidation.tck.tests.integration.cdi.executable.priority.EarlierInterceptor</class>\n"
"    <class>org.apache.bval.cdi.BValInterceptor</class>\n"
"  </interceptors>\n"
"</beans>";
final String beansXmlStr;
if (testClass.getJavaClass().getSimpleName().equals("ValidationInterceptorPriorityTest")) {
beansXmlStr = ValidationInterceptorPriorityTest_BEANS_XML;
} else {
beansXmlStr = BEANS_XML;
}
ManifestContainer.class.cast(applicationArchive).addAsManifestResource(new StringAsset(beansXmlStr), "beans.xml");
WebContainer.class.cast(applicationArchive).addAsWebInfResource(new StringAsset(beansXmlStr), "beans.xml");
if (System.getSecurityManager() == null) {
constructor.setAccessible(true);
} else {
AccessController.doPrivileged(new PrivilegedAction<Void>() {
public Void run() {
constructor.setAccessible(true);
return null;
}
});
}
import org.apache.bval.util.reflection.Reflection;
import java.beans.Introspector;
import java.util.HashMap;
private Map<String, MetaProperty> properties = null;
private Map<Method, MetaMethod> methods = null;
private Map<Constructor<?>, MetaConstructor> constructors = null;
if (beanClass != null) {
final Map<String, MetaProperty> oldProperties = properties;
final Map<Method, MetaMethod> oldMethods = methods;
final Map<Constructor<?>, MetaConstructor> oldConstructors = constructors;
properties = new TreeMap<String, MetaProperty>(new FieldComparator(beanClass));
if (oldProperties != null) {
properties.putAll(oldProperties);
}
methods = new TreeMap<Method, MetaMethod>(new MethodComparator(beanClass));
if (oldMethods != null) {
methods.putAll(oldMethods);
}
constructors = new TreeMap<Constructor<?>, MetaConstructor>(new ConstructorComparator(beanClass));
if (oldConstructors != null) {
constructors.putAll(oldConstructors);
}
}
if (properties == null) {
return new MetaProperty[0];
}
if (methods == null) {
return new MetaMethod[0];
}
if (methods == null) {
methods = new HashMap<Method, MetaMethod>();
}
if (constructors == null) {
constructors = new HashMap<Constructor<?>, MetaConstructor>();
}
this.properties = new HashMap<String, MetaProperty>();
for (final MetaProperty property : properties) {
if (properties == null) {
return null;
}
if (properties == null) {
return false;
}
if (properties == null) {
properties = new HashMap<String, MetaProperty>();
}
if (methods == null) {
return null;
}
if (constructors == null) {
return null;
}
protected static class FieldComparator implements Comparator<String> {
private final Map<String, Integer> fields = new HashMap<String, Integer>();
protected FieldComparator(final Class<?> beanClass) {
int i = 0;
Class<?> clazz = beanClass;
while (clazz != null && clazz != Object.class) {
for (final Field f : Reflection.INSTANCE.getDeclaredFields(clazz)) {
i;
final String name = f.getName();
if (!fields.containsKey(name)) {
fields.put(name, i);
}
}
for (final Method m : clazz.getDeclaredMethods()) {
if (m.getName().startsWith("get") && Void.TYPE != m.getReturnType() && m.getParameterTypes().length == 0) {
final String name = Introspector.decapitalize(m.getName().substring("get".length()));
if (!name.isEmpty()) {
i;
if (!fields.containsKey(name)) {
fields.put(name, i);
}
}
}
}
clazz = clazz.getSuperclass();
}
}
public int compare(final String o1, final String o2) {
return fieldIndex(o1) - fieldIndex(o2);
}
private int fieldIndex(final String o2) {
final Integer idx = fields.get(o2);
if (idx != null) {
return idx;
}
}
}
protected static class MethodComparator implements Comparator<Method> {
private final Map<Method, Integer> methods = new HashMap<Method, Integer>();
protected MethodComparator(final Class<?> beanClass) {
Class<?> clazz = beanClass;
while (clazz != null && clazz != Object.class) {
for (final Method m : Reflection.INSTANCE.getDeclaredMethods(clazz)) {
methods.put(m, Arrays.hashCode(m.getParameterTypes()));
}
clazz = clazz.getSuperclass();
}
}
public int compare(final Method o1, final Method o2) {
if (o1 == o2) {
return 0;
}
final int i = o1.getName().compareTo(o2.getName());
if (i != 0) {
return i;
}
return methods.get(o1) - methods.get(o2);
}
}
protected static class ConstructorComparator implements Comparator<Constructor<?>> {
private final Map<Constructor<?>, Integer> constructors = new HashMap<Constructor<?>, Integer>();
protected ConstructorComparator(final Class<?> beanClass) {
for (final Constructor<?> c : Reflection.INSTANCE.getDeclaredConstructors(beanClass)) {
constructors.put(c, Arrays.hashCode(c.getParameterTypes()));
}
}
public int compare(final Constructor<?> o1, final Constructor<?> o2) {
if (o1 == o2) {
return 0;
}
final int i = o1.getName().compareTo(o2.getName());
if (i != 0) {
return i;
}
return constructors.get(o1) - constructors.get(o2);
}
}
import org.apache.bval.util.reflection.Reflection;
import java.io.InputStream;
Reflection.INSTANCE.getProperty("java.class.path"));
Reflection.INSTANCE.getProperty(prop));
if (System.getSecurityManager() == null) {
field.setAccessible(true);
} else {
AccessController.doPrivileged(new PrivilegedAction<Void>() {
public Void run() {
field.setAccessible(true);
return null;
}
});
}
if (System.getSecurityManager() == null) {
method.setAccessible(true);
} else {
AccessController.doPrivileged(new PrivilegedAction<Void>() {
public Void run() {
method.setAccessible(true);
return null;
}
});
}
import org.apache.bval.util.reflection.Reflection;
if (System.getSecurityManager() == null) {
doBuildFromAnnotations();
} else {
AccessController.doPrivileged(new PrivilegedAction<Object>() {
public Object run() {
doBuildFromAnnotations();
});
}
}
}
private void doBuildFromAnnotations() {
final Class<? extends Annotation> annotationType = constraintValidation.getAnnotation().annotationType();
for (final Method method : Reflection.INSTANCE.getDeclaredMethods(annotationType)) {
if (method.getParameterTypes().length == 0) {
try {
final String name = method.getName();
if (ConstraintAnnotationAttributes.PAYLOAD.getAttributeName().equals(name)) {
buildPayload(method);
} else if (ConstraintAnnotationAttributes.GROUPS.getAttributeName().equals(name)) {
buildGroups(method);
} else if (ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getAttributeName().equals(name)) {
buildValidationAppliesTo(method);
} else if (name.startsWith("valid")) {
} else {
constraintValidation.getAttributes().put(name, method.invoke(constraintValidation.getAnnotation()));
} catch (final ConstraintDefinitionException cde) {
throw cde;
log.log(Level.WARNING, String.format("Error processing annotation: %s ", constraintValidation.getAnnotation()), e);
}
}
final Constraint annotation = annotationType.getAnnotation(Constraint.class);
if (annotation == null) {
return;
}
final Pair validationTarget = computeValidationTarget(annotation.validatedBy());
for (final Annotation a : annotationType.getAnnotations()) {
final Constraint inheritedConstraint = a.annotationType().getAnnotation(Constraint.class);
if (inheritedConstraint != null && !a.annotationType().getName().startsWith("javax.validation.constraints.")) {
final Pair validationTargetInherited = computeValidationTarget(inheritedConstraint.validatedBy());
if ((validationTarget.a > 0 && validationTargetInherited.b > 0 && validationTarget.b == 0)
|| (validationTarget.b > 0 && validationTargetInherited.a > 0 && validationTarget.a == 0)) {
throw new ConstraintDefinitionException("Parent and child constraint have different targets");
}
}
private void buildGroups(final Method method) throws IllegalAccessException, InvocationTargetException {
final Object raw = method.invoke(constraintValidation.getAnnotation());
garr = GroupsComputer.DEFAULT_GROUP;
constraintValidation.setGroups(garr);
Collections.addAll(payloadSet, payload_raw);
import org.apache.bval.util.reflection.Reflection;
for (final Annotation annotation : element.getDeclaredAnnotations()) {
final Class<?> type = annotation.annotationType();
if (type.getName().startsWith("java.lang.annotation")) {
continue;
}
final Object result = Reflection.INSTANCE.getAnnotationValue(annotation, ConstraintAnnotationAttributes.VALUE.getAttributeName());
import org.apache.bval.IntrospectorMetaBeanFactory;
import org.apache.bval.MetaBeanBuilder;
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.MetaBeanManager;
import org.apache.bval.util.reflection.Reflection;
import org.apache.bval.xml.XMLMetaBeanBuilder;
import org.apache.bval.xml.XMLMetaBeanFactory;
import org.apache.bval.xml.XMLMetaBeanManager;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.reflect.ConstructorUtils;
import java.lang.reflect.Constructor;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;
if (System.getSecurityManager() == null) {
return doCreateMetaBeanFactory(cls);
}
return AccessController.doPrivileged(new PrivilegedAction<F>() {
return doCreateMetaBeanFactory(cls);
private <F extends MetaBeanFactory> F doCreateMetaBeanFactory(final Class<F> cls) {
try {
Constructor<F> c = ConstructorUtils.getMatchingAccessibleConstructor(cls, ApacheFactoryContext.this.getClass());
if (c != null) {
return c.newInstance(ApacheFactoryContext.this);
}
c = ConstructorUtils.getMatchingAccessibleConstructor(cls, getFactory().getClass());
if (c != null) {
return c.newInstance(getFactory());
}
return cls.newInstance();
} catch (Exception e) {
throw new ValidationException(e);
}
}
return Class.forName(className, true, Reflection.INSTANCE.getClassLoader(ApacheFactoryContext.class));
import org.apache.bval.util.reflection.Reflection;
try {
return Reflection.INSTANCE.newInstance(cls);
} catch (final RuntimeException e) {
throw new ValidationException(e.getCause());
}
import org.apache.bval.jsr303.xml.AnnotationIgnores;
import org.apache.bval.util.reflection.Reflection;
private static final Validation[] EMPTY_VALIDATION = new Validation[0];
final Field field = Reflection.INSTANCE.getDeclaredField(current, prop.getName());
for (final Constructor<?> cons : Reflection.INSTANCE.getDeclaredConstructors(getMetaBean().getBeanClass())) {
final AnnotationIgnores annotationIgnores = factoryContext.getFactory().getAnnotationIgnores();
final ParameterDescriptorImpl paramDesc = new ParameterDescriptorImpl(getMetaBean(), EMPTY_VALIDATION, names.get(idx));
if (annotationIgnores.isIgnoreAnnotationOnParameter(cons, idx)) {
consDesc.getParameterDescriptors().add(new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx)));
if (!annotationIgnores.isIgnoreAnnotations(cons)) {
if (annotationIgnores.isIgnoreAnnotationOnCrossParameter(cons) && consDesc.getCrossParameterDescriptor() != null) {
if (annotationIgnores.isIgnoreAnnotationOnReturn(cons) && consDesc.getReturnValueDescriptor() != null) {
final List<Class<?>> classHierarchy = ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), current);
classHierarchy.remove(current);
for (final Method method : Reflection.INSTANCE.getDeclaredMethods(current)) {
final Method overriden = Reflection.INSTANCE.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
final MethodDescriptor parentDec = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
if (parentDec != null) {
ensureNoParameterConstraint(InvocableElementDescriptor.class.cast(parentDec), "Parameter constraints can't be defined for parallel interfaces/parents");
ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDec, "Return value constraints should be the same for parent and children");
ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDesc, "Return value constraints should be at least the same for parent and children");
final Method m = Reflection.INSTANCE.getDeclaredMethod(i, method.getName(), method.getParameterTypes());
final Method overriden = Reflection.INSTANCE.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
private void ensureNoReturnValueAddedInChild(final ReturnValueDescriptor returnValueDescriptor, final MethodDescriptor parentMtdDesc, final String msg) {
if (parentMtdDesc == null) {
final ReturnValueDescriptor parentReturnDesc = parentMtdDesc.getReturnValueDescriptor();
private void processMethod(final Method method, final MethodDescriptorImpl methodDesc) throws InvocationTargetException, IllegalAccessException {
final AnnotationIgnores annotationIgnores = factoryContext.getFactory().getAnnotationIgnores();
if (!annotationIgnores.isIgnoreAnnotations(method)) {
if (!annotationIgnores.isIgnoreAnnotationOnParameter(method, idx)) {
if (annotationIgnores.isIgnoreAnnotationOnCrossParameter(method) && methodDesc.getCrossParameterDescriptor() != null) {
if (annotationIgnores.isIgnoreAnnotationOnReturn(method) && methodDesc.getReturnValueDescriptor() != null) {
final ConstraintAnnotationAttributes.Worker<? extends Annotation> worker = ConstraintAnnotationAttributes.VALUE.analyze(annotation.annotationType());
if (worker.isValid()) {
Annotation[] children = Annotation[].class.cast(worker.read(annotation));
if (System.getSecurityManager() == null) {
return doNewInstance(cls);
}
return doNewInstance(cls);
private <T> T doNewInstance(final Class<T> cls) {
try {
Constructor<T> cons = cls.getConstructor(ApacheFactoryContext.class);
if (!cons.isAccessible()) {
cons.setAccessible(true);
}
return cons.newInstance(factoryContext);
} catch (final Exception ex) {
}
}
if (System.getSecurityManager() == null) {
return doPrivBuildValidatorFactory(this);
}
return AccessController.doPrivileged(new PrivilegedAction<ValidatorFactory>() {
public ValidatorFactory run() {
return doPrivBuildValidatorFactory(ConfigurationImpl.this);
}
});
public ValidatorFactory doPrivBuildValidatorFactory(final ConfigurationImpl impl) {
return provider.buildValidatorFactory(impl);
return findProvider().buildValidatorFactory(impl);
import org.apache.bval.util.reflection.Reflection;
MESSAGE(false, "message"),
GROUPS(false, "groups"),
PAYLOAD(false, "payload"),
VALIDATION_APPLIES_TO(true, "validationAppliesTo"),
VALUE(true, "value");
private ConstraintAnnotationAttributes(final boolean permitNullDefaultValue, final String name) {
public <C extends Annotation> Worker<C> analyze(final Class<C> clazz) {
return new Worker<C>(clazz);
public class Worker<C extends Annotation> {
public final Method method;
public final Object defaultValue;
private RuntimeException error;
Worker(final Class<C> constraintType) {
method = Reflection.INSTANCE.getPublicMethod(constraintType, getAttributeName());
error = new ConstraintDefinitionException(String.format("Annotation %1$s has no %2$s() method", constraintType, getAttributeName()));
return;
error = new ConstraintDefinitionException(String.format("Return type for %1$s() must be of type %2$s", getAttributeName(), getType()));
return;
error = new ConstraintDefinitionException(String.format("Default value for %1$s() must be an empty array", getAttributeName()));
public boolean isValid() {
return error == null;
}
public Worker<C> valid() {
if (!isValid()) {
throw error;
}
return this;
}
public Object read(final Annotation constraint) {
if (System.getSecurityManager() == null) {
return doInvoke(constraint);
}
return AccessController.doPrivileged(new PrivilegedAction<Object>() {
return doInvoke(constraint);
}
private Object doInvoke(final Annotation constraint) {
try {
method.setAccessible(true);
return method.invoke(constraint);
} catch (Exception e) {
throw new RuntimeException(e);
}
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Properties;
import java.util.StringTokenizer;
final Map<String, Class<? extends ConstraintValidator<?, ?>>[]> loadedConstraints = new HashMap<String, Class<? extends ConstraintValidator<?,?>>[]>();
for (final Map.Entry<Object, Object> entry : constraintProperties.entrySet()) {
final StringTokenizer tokens = new StringTokenizer((String) entry.getValue(), ", ");
final LinkedList<Class<?>> classes = new LinkedList<Class<?>>();
Class<?> constraintValidatorClass;
if (System.getSecurityManager() == null) {
try {
constraintValidatorClass = Class.forName(eachClassName, true, classloader);
} catch (final ClassNotFoundException e) {
log.log(Level.SEVERE, String.format("Cannot find class %s", eachClassName), e);
constraintValidatorClass = null;
}
} else {
constraintValidatorClass = AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {
} catch (final ClassNotFoundException e) {
}
if (constraintValidatorClass != null) {
classes.add(constraintValidatorClass);
}
loadedConstraints.put((String) entry.getKey(), classes.toArray(new Class[classes.size()]));
void setGroups(final Set<Class<?>> groups) {
ConstraintAnnotationAttributes.GROUPS.put(attributes, groups.toArray(new Class<?>[groups.size()]));
}
void setGroups(final Class<?>[] groups) {
this.groups = new HashSet<Class<?>>();
Collections.addAll(this.groups, groups);
ConstraintAnnotationAttributes.GROUPS.put(attributes, groups);
import org.apache.bval.util.reflection.Reflection;
private static final boolean LOG_FINEST = log.isLoggable(Level.FINEST);
final ClassLoader classLoader = Reflection.INSTANCE.getClassLoader(DefaultMessageInterpolator.class);
if (LOG_FINEST) {
if (rb != null) {
log.log(Level.FINEST, String.format("%s found", USER_VALIDATION_MESSAGES));
} else {
log.log(Level.FINEST, String.format("%s not found. Delegating to %s", USER_VALIDATION_MESSAGES, DEFAULT_VALIDATION_MESSAGES));
}
} catch (final MissingResourceException e) {
"META-INF/services/javax.validation.spi.ValidationProvider";
final ValidationProvider<?> vp;
if (System.getSecurityManager() == null) {
try {
vp = (ValidationProvider<?>) provider.newInstance();
} catch (final Exception ex) {
}
} else {
vp = AccessController.doPrivileged(new PrivilegedAction<ValidationProvider<?>>() {
public ValidationProvider<?> run() {
try {
return (ValidationProvider<?>) provider.newInstance();
} catch (final Exception ex) {
}
});
}
providers.add(vp);
import org.apache.bval.util.reflection.Reflection;
final Field[] fields = Reflection.INSTANCE.getDeclaredFields(beanClass);
final Method[] methods = Reflection.INSTANCE.getDeclaredMethods(beanClass);
private boolean hasValidationConstraintsDefined(final Annotation annot) {
final ConstraintAnnotationAttributes.Worker<?> worker = ConstraintAnnotationAttributes.VALUE.analyze(annot.annotationType());
if (worker.isValid()) {
Annotation[] children = Annotation[].class.cast(worker.read(annot));
for (final Annotation child : children) {
public static final Class<?>[] DEFAULT_GROUP = new Class<?>[]{Default.class};
DEFAULT_GROUPS = new GroupsComputer().computeGroups(Arrays.asList(DEFAULT_GROUP));
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.lang3.ClassUtils;
import java.lang.annotation.ElementType;
import java.util.logging.Level;
import java.util.logging.Logger;
private static final boolean LOG_FINEST = log.isLoggable(Level.FINEST);
Reflection.INSTANCE.getClass(classLoader, PERSISTENCE_UTIL_CLASSNAME);
if (LOG_FINEST) {
log.log(Level.FINEST, String.format("Found %s on classpath.", PERSISTENCE_UTIL_CLASSNAME));
}
} catch (final Exception e) {
if (LOG_FINEST) {
log.log(Level.FINEST, String.format("Instantiated an instance of %s.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME));
}
} catch (final Exception e) {
log.log(Level.WARNING, String.format("Unable to load or instantiate JPA aware resolver %s. All properties will per default be traversable.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME), e);
return Reflection.INSTANCE.getClassLoader(DefaultTraversableResolver.class);
import org.apache.bval.jsr303.ConstraintAnnotationAttributes;
ConstraintAnnotationAttributes.GROUPS.analyze(type).valid();
ConstraintAnnotationAttributes.PAYLOAD.analyze(type).valid();
ConstraintAnnotationAttributes.MESSAGE.analyze(type).valid();
final ConstraintAnnotationAttributes.Worker<? extends Annotation> validationAppliesToWorker = ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.analyze(type);
if (validationAppliesToWorker.isValid() && !ConstraintTarget.IMPLICIT.equals(validationAppliesToWorker.defaultValue)) {
import org.apache.bval.util.reflection.Reflection;
import javax.validation.Valid;
final Method[] declaredMethods = Reflection.INSTANCE.getDeclaredMethods(annotationType);
import org.apache.bval.util.reflection.Reflection;
final Method[] methods = Reflection.INSTANCE.getDeclaredMethods(annot.annotationType());
ClassLoader classLoader = Reflection.INSTANCE.getClassLoader(getType());
if (System.getSecurityManager() == null) {
return doCreateAnnotation(proxyClass, handler);
}
return AccessController.doPrivileged(new PrivilegedAction<A>() {
return doCreateAnnotation(proxyClass, handler);
private A doCreateAnnotation(final Class<A> proxyClass, final InvocationHandler handler) {
try {
Constructor<A> constructor = proxyClass.getConstructor(InvocationHandler.class);
return constructor.newInstance(handler);
} catch (Exception e) {
throw new ValidationException("Unable to create annotation for configured constraint", e);
import org.apache.bval.util.reflection.Reflection;
final Method m = Reflection.INSTANCE.getPublicMethod(annotationClass, name);
final Method method = Reflection.INSTANCE.getDeclaredMethod(beanClass, methodName, toTypes(methodType.getParameter(), defaultPackage));
final Constructor<?> constructor = Reflection.INSTANCE.getDeclaredConstructor(beanClass, toTypes(constructorType.getParameter(), defaultPackage));
final Field field = Reflection.INSTANCE.getDeclaredField(beanClass, fieldName);
if (System.getSecurityManager() == null) {
return doGetGetter(propertyName, clazz);
}
return AccessController.doPrivileged(new PrivilegedAction<Method>() {
return doGetGetter(propertyName, clazz);
private static Method doGetGetter(String propertyName, Class<?> clazz) {
try {
final String p = StringUtils.capitalize(propertyName);
try {
} catch (NoSuchMethodException e) {
}
} catch (NoSuchMethodException e) {
return null;
}
}
ClassLoader loader = Reflection.INSTANCE.getClassLoader(ValidationMappingParser.class);
import org.apache.bval.util.reflection.Reflection;
ClassLoader loader = Reflection.INSTANCE.getClassLoader(ValidationParser.class);
static Schema getSchema(final String xsd) {
final ClassLoader loader = Reflection.INSTANCE.getClassLoader(ValidationParser.class);
final SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
final URL schemaUrl = loader.getResource(xsd);
if (System.getSecurityManager() == null) {
return doNewInstance(cls);
}
return doNewInstance(cls);
private <T> T doNewInstance(final Class<T> cls) {
try {
try {
final BValExtension.Releasable<T> releasable = BValExtension.inject(cls);
releasables.add(releasable);
return releasable.getInstance();
} catch (final Exception e) {
return cls.newInstance();
} catch (final NoClassDefFoundError error) {
return cls.newInstance();
}
} catch (final Exception ex) {
}
}
final ClassLoader loader = Reflection.INSTANCE.getClassLoader(ValidationParser.class);
} catch (final ClassNotFoundException ex) {
import org.apache.bval.util.reflection.Reflection;
addLoader(new XMLMetaBeanURLLoader(Reflection.INSTANCE.getClassLoader(getClass()).getResource(resource)));
final Class<?> beanClass = getMetaBean().getBeanClass();
final List<Class<?>> classHierarchy = ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), beanClass);
Class<?> current = beanClass;
if (Modifier.isStatic(method.getModifiers()) || method.isSynthetic()) {
continue;
}
final MethodDescriptorImpl methodDesc = new MethodDescriptorImpl(getMetaBean(), EMPTY_VALIDATION, method);
processMethod(overriden, methodDesc);
private static final Validation[] EMPTY_VALIDATION = new Validation[0];
super(bean, metaMethod.getMethod().getReturnType(), EMPTY_VALIDATION);
return null;
if (beanManager == null) {
return null;
}
final Class<? extends Annotation> aClass = a.annotationType();
if (aClass.getName().startsWith("java.lang.annotation.")) {
continue;
}
final Constraint inheritedConstraint = aClass.getAnnotation(Constraint.class);
if (inheritedConstraint != null && !aClass.getName().startsWith("javax.validation.constraints.")) {
if (type.getName().startsWith("java.lang.annotation.")) {
if (each.annotationType().getName().startsWith("java.lang.annotation")) {
continue;
}
private Map<String, MethodDescriptor> methodConstraints = new HashMap<String, MethodDescriptor>();
private Map<String, ConstructorDescriptor> contructorConstraints = new HashMap<String, ConstructorDescriptor>();
private Boolean isBeanConstrained = null;
private Boolean hasAnyContraints = null;
if (isBeanConstrained == null) {
synchronized (this) {
if (isBeanConstrained == null) {
if (hasAnyConstraints()) {
isBeanConstrained = true;
} else {
isBeanConstrained = false;
for (final MetaProperty mprop : metaBean.getProperties()) {
if (mprop.getMetaBean() != null || mprop.getFeature(Features.Property.REF_CASCADE) != null) {
isBeanConstrained = true;
break;
}
}
}
}
}
return isBeanConstrained;
if (hasAnyContraints == null) {
synchronized (this) {
if (hasAnyContraints == null) {
if (hasConstraints()) {
hasAnyContraints = true;
} else {
hasAnyContraints = false;
for (final MetaProperty mprop : metaBean.getProperties()) {
if (getConstraintDescriptors(mprop.getValidations()).size() > 0) {
hasAnyContraints = true;
break;
}
}
}
}
}
return hasAnyContraints;
|| (prop.getMetaBean() != null || prop.getFeature(Features.Property.REF_CASCADE) != null)) {
public MethodDescriptor getConstraintsForMethod(final String methodName, final Class<?>... parameterTypes) {
if (methodDescriptor != null && (methodDescriptor.hasConstrainedParameters() || methodDescriptor.hasConstrainedReturnValue())) {
return methodDescriptor;
break;
public ConstructorDescriptor getConstraintsForConstructor(final Class<?>... parameterTypes) {
final ConstructorDescriptor descriptor = contructorConstraints.get(Arrays.toString(parameterTypes));
contructorConstraints.put(Arrays.toString(cons.getParameterTypes()), consDesc);
final Class<?> current = getMetaBean().getBeanClass();
final List<Class<?>> classHierarchy = ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), current);
classHierarchy.remove(current);
for (final Method method : Reflection.INSTANCE.getDeclaredMethods(current)) {
if (Modifier.isStatic(method.getModifiers()) || method.isSynthetic()) {
continue;
}
final boolean getter = (method.getName().startsWith("get") || method.getName().startsWith("is")) && method.getParameterTypes().length == 0 && method.getReturnType() != Void.TYPE;
MethodDescriptorImpl methodDesc = MethodDescriptorImpl.class.cast(methodConstraints.get(key));
if (methodDesc == null) {
methodDesc = new MethodDescriptorImpl(getMetaBean(), EMPTY_VALIDATION, method);
methodConstraints.put(key, methodDesc);
} else {
continue;
}
final Collection<Method> parents = new ArrayList<Method>();
for (final Class<?> clazz : classHierarchy) {
final Method overriden = Reflection.INSTANCE.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
if (overriden != null) {
parents.add(overriden);
processMethod(overriden, methodDesc);
processMethod(method, methodDesc);
ensureNotNullDescriptors(method.getReturnType(), methodDesc);
if (parents != null) {
if (parents.size() > 1) {
for (final Method parent : parents) {
final MethodDescriptor parentDec = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
if (parentDec != null) {
ensureNoParameterConstraint(InvocableElementDescriptor.class.cast(parentDec), "Parameter constraints can't be defined for parallel interfaces/parents");
} else {
ensureMethodDoesntDefineParameterConstraint(methodDesc);
}
ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDec, "Return value constraints should be the same for parent and children");
}
} else if (!parents.isEmpty()) {
final Method parent = parents.iterator().next();
final MethodDescriptor parentDesc = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDesc, "Return value constraints should be at least the same for parent and children");
if (parentDesc != null) {
final Iterator<ParameterDescriptor> parentPd = parentDesc.getParameterDescriptors().iterator();
for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
final ParameterDescriptor next = parentPd.next();
if (pd.getConstraintDescriptors().size() != next.getConstraintDescriptors().size()) {
throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
}
throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
}
}
} else {
ensureMethodDoesntDefineParameterConstraint(methodDesc);
}
}
final Class<?>[] interfaces = method.getDeclaringClass().getInterfaces();
final Collection<Method> itfWithThisMethod = new ArrayList<Method>();
for (final Class<?> i : interfaces) {
final Method m = Reflection.INSTANCE.getDeclaredMethod(i, method.getName(), method.getParameterTypes());
if (m != null) {
itfWithThisMethod.add(m);
}
}
if (itfWithThisMethod.size() > 1) {
for (final Method m : itfWithThisMethod) {
ensureNoConvertGroup(m, "ConvertGroup can't be used in parallel interfaces");
}
} else if (itfWithThisMethod.size() == 1) {
ensureNoConvertGroup(itfWithThisMethod.iterator().next(), "ConvertGroup can't be used in interface AND parent class");
}
int returnValid = 0;
if (method.getAnnotation(Valid.class) != null) {
}
for (final Class<?> clazz : classHierarchy) {
final Method overriden = Reflection.INSTANCE.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
if (overriden != null) {
if (overriden.getAnnotation(Valid.class) != null) {
}
}
}
if (returnValid > 1 && !(interfaces.length == returnValid && method.getAnnotation(Valid.class) == null)) {
throw new ConstraintDeclarationException("@Valid on returned value can't be set more than once");
}
}
if (getter) {
final MetaProperty prop = metaBean.getProperty(Introspector.decapitalize(method.getName().substring(3)));
if (prop != null && prop.getFeature(Features.Property.REF_CASCADE) != null) {
methodDesc.setCascaded(true);
}
}
if (!methodDesc.getGroupConversions().isEmpty() && !methodDesc.isCascaded()) {
throw new ConstraintDeclarationException("@Valid is needed to define a group conversion");
}
}
for (final Class<?> parent : classHierarchy) {
final BeanDescriptorImpl desc = BeanDescriptorImpl.class.cast(factoryContext.getValidator().getConstraintsForClass(parent));
for (final String s : desc.methodConstraints.keySet()) {
methodConstraints.put(s, desc.methodConstraints.get(s));
}
}
}
throws InvocationTargetException, IllegalAccessException {
validations.getValidations().toArray(new Validation[validations.getValidations().size()]), name);
return MethodDescriptorImpl.class.cast(getConstraintsForClass(Proxies.classFor(method.getDeclaringClass())).getConstraintsForMethod(method.getName(), method.getParameterTypes()));
if (useCdi == null) {
synchronized (this) {
if (useCdi == null) {
try {
useCdi = BValExtension.getInstance() != null && BValExtension.getInstance().getBeanManager() != null;
} catch (final NoClassDefFoundError error) {
useCdi = false;
} catch (final Exception e) {
useCdi = false;
}
}
}
}
if (useCdi) {
try {
final BValExtension.Releasable<T> instance = BValExtension.inject(constraintClass);
releasables.add(instance);
return instance.getInstance();
} catch (final Exception e) {
return constraintClass.newInstance();
} catch (final NoClassDefFoundError error) {
return constraintClass.newInstance();
}
return constraintClass.newInstance();
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import static org.apache.bval.model.Features.Property.REF_BEAN_ID;
import static org.apache.bval.model.Features.Property.REF_BEAN_TYPE;
import static org.apache.bval.model.Features.Property.REF_CASCADE;
protected final ConcurrentMap<Object, Object> cacheLocks = new ConcurrentHashMap<Object, Object>();
public MetaBean findForId(final String beanInfoId) {
if (beanInfo != null) {
synchronized (getLockFor(beanInfoId)) {
beanInfo = cache.findForId(beanInfoId);
if (beanInfo != null) {
return beanInfo;
}
try {
beanInfo = builder.buildForId(beanInfoId);
cache.cache(beanInfo);
computeRelationships(beanInfo);
return beanInfo;
} catch (final RuntimeException e) {
} catch (final Exception e) {
}
}
}
private Object getLockFor(final Object key) {
final Object newLock = new Object();
Object lock = cacheLocks.putIfAbsent(key, newLock);
if (lock == null) {
lock = newLock;
}
return lock;
public MetaBean findForClass(final Class<?> clazz) {
if (clazz == null) {
}
if (beanInfo != null) {
}
synchronized (getLockFor(clazz)) {
beanInfo = cache.findForClass(clazz);
if (beanInfo != null) {
return beanInfo;
}
try {
beanInfo = builder.buildForClass(clazz);
cache.cache(beanInfo);
computeRelationships(beanInfo);
return beanInfo;
} catch (final RuntimeException e) {
} catch (final Exception e) {
}
for (final MetaProperty prop : beanInfo.getProperties()) {
final String beanRef = prop.getFeature(REF_BEAN_ID);
private final MetaBeanFinder metaBeanFinder;
metaBeanFinder = factoryContext.getMetaBeanFinder();
final MetaBean objectMetaBean = metaBeanFinder.findForClass(objectClass);
final MetaBean initialMetaBean = new DynamicMetaBean(metaBeanFinder);
context.setMetaBean(metaBeanFinder.findForClass(value.getClass()));
String EXECUTABLES = "executables";
private final ExecutableMeta meta;
ExecutableMeta executables = metaBean.getFeature(Jsr303Features.Bean.EXECUTABLES);
executables = new ExecutableMeta(factoryContext, metaBean, getConstraintDescriptors());
metaBean.putFeature(Jsr303Features.Bean.EXECUTABLES, executables);
}
meta = executables;
isBeanConstrained = meta.isBeanConstrained;
hasAnyContraints = meta.hasAnyContraints;
setConstrained(containedMethods, meta.methodConstraints.values());
setConstrained(constrainedConstructors, meta.contructorConstraints.values());
final ConstructorDescriptor descriptor = meta.contructorConstraints.get(Arrays.toString(parameterTypes));
private static class ExecutableMeta {
private final ApacheFactoryContext factoryContext;
private final AnnotationProcessor annotationProcessor;
private final MetaBean metaBean;
private final Map<String, MethodDescriptor> methodConstraints = new HashMap<String, MethodDescriptor>();
private final Map<String, ConstructorDescriptor> contructorConstraints = new HashMap<String, ConstructorDescriptor>();
private Boolean isBeanConstrained = null;
private Boolean hasAnyContraints = null;
private ExecutableMeta(final ApacheFactoryContext factoryContext, final MetaBean metaBean1, final Collection<ConstraintDescriptor<?>> constraintDescriptors) {
this.metaBean = metaBean1;
this.factoryContext = factoryContext;
this.annotationProcessor = new AnnotationProcessor(factoryContext);
buildExecutableDescriptors();
if (!constraintDescriptors.isEmpty()) {
hasAnyContraints = true;
} else {
hasAnyContraints = false;
for (final MetaProperty mprop : metaBean.getProperties()) {
if (getConstraintDescriptors(mprop.getValidations()).size() > 0) {
hasAnyContraints = true;
break;
}
}
}
if (hasAnyContraints) {
isBeanConstrained = true;
} else {
isBeanConstrained = false;
for (final MetaProperty mprop : metaBean.getProperties()) {
if (mprop.getMetaBean() != null || mprop.getFeature(Features.Property.REF_CASCADE) != null) {
isBeanConstrained = true;
break;
}
}
}
}
private void buildConstructorConstraints() throws InvocationTargetException, IllegalAccessException {
for (final Constructor<?> cons : Reflection.INSTANCE.getDeclaredConstructors(metaBean.getBeanClass())) {
final ConstructorDescriptorImpl consDesc = new ConstructorDescriptorImpl(metaBean, new Validation[0]);
contructorConstraints.put(Arrays.toString(cons.getParameterTypes()), consDesc);
final List<String> names = factoryContext.getParameterNameProvider().getParameterNames(cons);
final boolean isInnerClass = cons.getDeclaringClass().getEnclosingClass() != null && !Modifier.isStatic(cons.getDeclaringClass().getModifiers());
final AnnotationIgnores annotationIgnores = factoryContext.getFactory().getAnnotationIgnores();
{
final Annotation[][] paramsAnnos = cons.getParameterAnnotations();
int idx = 0;
final ParameterDescriptorImpl paramDesc = new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx));
consDesc.getParameterDescriptors().add(paramDesc);
}
for (final Annotation[] paramAnnos : paramsAnnos) {
if (annotationIgnores.isIgnoreAnnotationOnParameter(cons, idx)) {
consDesc.getParameterDescriptors().add(new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx)));
} else if (cons.getParameterTypes().length > idx) {
ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
consDesc.addValidations(processAnnotations(consDesc, paramAnnos, access, idx, names.get(idx)).getValidations());
}
if (!annotationIgnores.isIgnoreAnnotations(cons)) {
for (final Annotation anno : cons.getAnnotations()) {
if (!Valid.class.isInstance(anno)) {
processAnnotations(null, consDesc, cons.getDeclaringClass(), anno);
} else {
consDesc.setCascaded(true);
}
}
}
if (annotationIgnores.isIgnoreAnnotationOnCrossParameter(cons) && consDesc.getCrossParameterDescriptor() != null) {
consDesc.setCrossParameterDescriptor(null);
}
if (annotationIgnores.isIgnoreAnnotationOnReturn(cons) && consDesc.getReturnValueDescriptor() != null) {
consDesc.setReturnValueDescriptor(null);
final MetaConstructor metaConstructor = metaBean.getConstructor(cons);
if (metaConstructor != null) {
for (final Annotation anno : metaConstructor.getAnnotations()) {
final Collection<MetaParameter> paramsAnnos = metaConstructor.getParameters();
for (final MetaParameter paramAnnos : paramsAnnos) {
final int idx = paramAnnos.getIndex();
final ParameterAccess access = new ParameterAccess(cons.getParameterTypes()[idx], idx);
processAnnotations(consDesc, paramAnnos.getAnnotations(), access, idx, names.get(idx));
if (!consDesc.getGroupConversions().isEmpty() && !consDesc.isCascaded()) {
throw new ConstraintDeclarationException("@Valid is needed to define a group conversion");
}
ensureNotNullDescriptors(cons.getDeclaringClass(), consDesc);
}
}
private void ensureNotNullDescriptors(final Class<?> returnType, final InvocableElementDescriptor consDesc) {
if (consDesc.getCrossParameterDescriptor() == null) {
consDesc.setCrossParameterDescriptor(new CrossParameterDescriptorImpl(metaBean, NO_CONSTRAINTS));
}
if (consDesc.getReturnValueDescriptor() == null) {
consDesc.setReturnValueDescriptor(new ReturnValueDescriptorImpl(metaBean, returnType, NO_CONSTRAINTS, consDesc.isCascaded()));
}
final ReturnValueDescriptorImpl returnValueDescriptor = ReturnValueDescriptorImpl.class.cast(consDesc.getReturnValueDescriptor());
returnValueDescriptor.setCascaded(consDesc.isCascaded());
if (returnValueDescriptor.getGroupConversions().isEmpty()) {
for (final GroupConversionDescriptor c : consDesc.getGroupConversions()) {
returnValueDescriptor.addGroupConversion(c);
private void processAnnotations(final Method mtd, final InvocableElementDescriptor consDesc, final Class<?> clazz, final Annotation anno) throws InvocationTargetException, IllegalAccessException {
if (mtd == null || !factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnReturn(mtd)) {
final ReturnAccess returnAccess = new ReturnAccess(clazz);
final AppendValidationToList validations = new AppendValidationToList();
processAnnotation(anno, consDesc, returnAccess, validations);
final List<ConstraintValidation<?>> list = removeFromListValidationAppliesTo(validations.getValidations(), ConstraintTarget.PARAMETERS);
consDesc.addValidations(list);
ReturnValueDescriptorImpl returnValueDescriptor = ReturnValueDescriptorImpl.class.cast(consDesc.getReturnValueDescriptor());
if (consDesc.getReturnValueDescriptor() != null) {
returnValueDescriptor.getMutableConstraintDescriptors().addAll(list);
} else {
returnValueDescriptor = new ReturnValueDescriptorImpl(metaBean, clazz, list, consDesc.isCascaded());
consDesc.setReturnValueDescriptor(returnValueDescriptor);
if (mtd == null || !factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnCrossParameter(mtd)) {
final ParametersAccess parametersAccess = new ParametersAccess();
final AppendValidationToList validations = new AppendValidationToList();
processAnnotation(anno, consDesc, parametersAccess, validations);
final List<ConstraintValidation<?>> list = removeFromListValidationAppliesTo(validations.getValidations(), ConstraintTarget.RETURN_VALUE);
consDesc.addValidations(list);
if (consDesc.getCrossParameterDescriptor() != null) {
CrossParameterDescriptorImpl.class.cast(consDesc.getCrossParameterDescriptor()).getMutableConstraintDescriptors().addAll(list);
} else {
consDesc.setCrossParameterDescriptor(new CrossParameterDescriptorImpl(metaBean, list));
}
}
}
private static List<ConstraintValidation<?>> removeFromListValidationAppliesTo(final List<ConstraintValidation<?>> validations, final ConstraintTarget constraint) {
final Iterator<ConstraintValidation<?>> i = validations.iterator();
while (i.hasNext()) {
if (constraint.equals(i.next().getValidationAppliesTo())) {
i.remove();
}
}
return validations;
}
private void buildMethodConstraints() throws InvocationTargetException, IllegalAccessException {
final Class<?> current = metaBean.getBeanClass();
final List<Class<?>> classHierarchy = ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), current);
classHierarchy.remove(current);
for (final Method method : Reflection.INSTANCE.getDeclaredMethods(current)) {
if (Modifier.isStatic(method.getModifiers()) || method.isSynthetic()) {
continue;
final boolean getter = (method.getName().startsWith("get") || method.getName().startsWith("is")) && method.getParameterTypes().length == 0 && method.getReturnType() != Void.TYPE;
MethodDescriptorImpl methodDesc = MethodDescriptorImpl.class.cast(methodConstraints.get(key));
if (methodDesc == null) {
methodDesc = new MethodDescriptorImpl(metaBean, EMPTY_VALIDATION, method);
methodConstraints.put(key, methodDesc);
} else {
continue;
final Collection<Method> parents = new ArrayList<Method>();
parents.add(overriden);
processMethod(overriden, methodDesc);
processMethod(method, methodDesc);
ensureNotNullDescriptors(method.getReturnType(), methodDesc);
if (parents != null) {
if (parents.size() > 1) {
for (final Method parent : parents) {
final MethodDescriptor parentDec = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
if (parentDec != null) {
ensureNoParameterConstraint(InvocableElementDescriptor.class.cast(parentDec), "Parameter constraints can't be defined for parallel interfaces/parents");
} else {
ensureMethodDoesntDefineParameterConstraint(methodDesc);
}
ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDec, "Return value constraints should be the same for parent and children");
}
} else if (!parents.isEmpty()) {
final Method parent = parents.iterator().next();
final MethodDescriptor parentDesc = factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass()).getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDesc, "Return value constraints should be at least the same for parent and children");
if (parentDesc != null) {
final Iterator<ParameterDescriptor> parentPd = parentDesc.getParameterDescriptors().iterator();
for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
final ParameterDescriptor next = parentPd.next();
if (pd.getConstraintDescriptors().size() != next.getConstraintDescriptors().size()) {
throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
}
throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
}
}
} else {
ensureMethodDoesntDefineParameterConstraint(methodDesc);
}
}
final Class<?>[] interfaces = method.getDeclaringClass().getInterfaces();
final Collection<Method> itfWithThisMethod = new ArrayList<Method>();
for (final Class<?> i : interfaces) {
final Method m = Reflection.INSTANCE.getDeclaredMethod(i, method.getName(), method.getParameterTypes());
if (m != null) {
itfWithThisMethod.add(m);
}
}
if (itfWithThisMethod.size() > 1) {
for (final Method m : itfWithThisMethod) {
ensureNoConvertGroup(m, "ConvertGroup can't be used in parallel interfaces");
}
} else if (itfWithThisMethod.size() == 1) {
ensureNoConvertGroup(itfWithThisMethod.iterator().next(), "ConvertGroup can't be used in interface AND parent class");
}
int returnValid = 0;
if (method.getAnnotation(Valid.class) != null) {
}
for (final Class<?> clazz : classHierarchy) {
final Method overriden = Reflection.INSTANCE.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
if (overriden != null) {
if (overriden.getAnnotation(Valid.class) != null) {
}
}
}
if (returnValid > 1 && !(interfaces.length == returnValid && method.getAnnotation(Valid.class) == null)) {
throw new ConstraintDeclarationException("@Valid on returned value can't be set more than once");
}
}
if (getter) {
final MetaProperty prop = metaBean.getProperty(Introspector.decapitalize(method.getName().substring(3)));
if (prop != null && prop.getFeature(Features.Property.REF_CASCADE) != null) {
methodDesc.setCascaded(true);
}
}
if (!methodDesc.getGroupConversions().isEmpty() && !methodDesc.isCascaded()) {
throw new ConstraintDeclarationException("@Valid is needed to define a group conversion");
for (final Class<?> parent : classHierarchy) {
final BeanDescriptorImpl desc = BeanDescriptorImpl.class.cast(factoryContext.getValidator().getConstraintsForClass(parent));
for (final String s : desc.meta.methodConstraints.keySet()) {
methodConstraints.put(s, desc.meta.methodConstraints.get(s));
}
private void ensureMethodDoesntDefineParameterConstraint(MethodDescriptorImpl methodDesc) {
for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
if (!pd.getConstraintDescriptors().isEmpty()) {
throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
}
throw new ConstraintDeclarationException("child shouldn't get more constraint than parent");
}
private void ensureNoReturnValueAddedInChild(final ReturnValueDescriptor returnValueDescriptor, final MethodDescriptor parentMtdDesc, final String msg) {
if (parentMtdDesc == null) {
return;
}
final ReturnValueDescriptor parentReturnDesc = parentMtdDesc.getReturnValueDescriptor();
if (parentReturnDesc.isCascaded() && !returnValueDescriptor.isCascaded() || parentReturnDesc.getConstraintDescriptors().size() > returnValueDescriptor.getConstraintDescriptors().size()) {
private static void ensureNoParameterConstraint(final InvocableElementDescriptor constraintsForMethod, final String msg) {
for (final ParameterDescriptor parameterDescriptor : constraintsForMethod.getParameterDescriptors()) {
if (!parameterDescriptor.getConstraintDescriptors().isEmpty() || parameterDescriptor.isCascaded()) {
private static void ensureNoConvertGroup(final Method method, final String msg) {
for (final Annotation[] annotations : method.getParameterAnnotations()) {
for (final Annotation a : annotations) {
if (ConvertGroup.class.isInstance(a)) {
throw new ConstraintDeclarationException(msg);
if (method.getAnnotation(ConvertGroup.class) != null) {
throw new ConstraintDeclarationException(msg);
private void processMethod(final Method method, final MethodDescriptorImpl methodDesc) throws InvocationTargetException, IllegalAccessException {
final AnnotationIgnores annotationIgnores = factoryContext.getFactory().getAnnotationIgnores();
if (!annotationIgnores.isIgnoreAnnotations(method)) {
for (Annotation anno : method.getAnnotations()) {
if (anno instanceof Valid || anno instanceof Validate) {
methodDesc.setCascaded(true);
} else {
processAnnotations(method, methodDesc, method.getReturnType(), anno);
final Annotation[][] paramsAnnos = method.getParameterAnnotations();
int idx = 0;
final List<String> names = factoryContext.getParameterNameProvider().getParameterNames(method);
for (final Annotation[] paramAnnos : paramsAnnos) {
if (!annotationIgnores.isIgnoreAnnotationOnParameter(method, idx)) {
final ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
processAnnotations(methodDesc, paramAnnos, access, idx, names.get(idx));
} else {
final ParameterDescriptorImpl parameterDescriptor = new ParameterDescriptorImpl(metaBean, new Validation[0], names.get(idx));
parameterDescriptor.setIndex(idx);
methodDesc.getParameterDescriptors().add(parameterDescriptor);
}
}
}
if (annotationIgnores.isIgnoreAnnotationOnCrossParameter(method) && methodDesc.getCrossParameterDescriptor() != null) {
methodDesc.setCrossParameterDescriptor(null);
}
if (annotationIgnores.isIgnoreAnnotationOnReturn(method) && methodDesc.getReturnValueDescriptor() != null) {
methodDesc.setReturnValueDescriptor(null);
}
final MetaMethod metaMethod = metaBean.getMethod(method);
if (metaMethod != null) {
for (final Annotation anno : metaMethod.getAnnotations()) {
if (anno instanceof Valid) {
methodDesc.setCascaded(true);
} else {
processAnnotations(null, methodDesc, method.getReturnType(), anno);
}
}
final Collection<MetaParameter> paramsAnnos = metaMethod.getParameters();
final List<String> names = factoryContext.getParameterNameProvider().getParameterNames(method);
for (final MetaParameter paramAnnos : paramsAnnos) {
final int idx = paramAnnos.getIndex();
final ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
processAnnotations(methodDesc, paramAnnos.getAnnotations(), access, idx, names.get(idx));
}
}
}
private AppendValidationToList processAnnotations(InvocableElementDescriptor methodDesc, Annotation[] paramAnnos, AccessStrategy access, int idx, String name)
throws InvocationTargetException, IllegalAccessException {
final AppendValidationToList validations = new AppendValidationToList();
boolean cascaded = false;
Group[] from = null;
Group[] to = null;
for (final Annotation anno : paramAnnos) {
if (anno instanceof Valid || anno instanceof Validate) {
cascaded = true;
} else if (ConvertGroup.class.isInstance(anno)) {
final ConvertGroup cg = ConvertGroup.class.cast(anno);
from = new Group[]{new Group(cg.from())};
to = new Group[]{new Group(cg.to())};
} else if (ConvertGroup.List.class.isInstance(anno)) {
final ConvertGroup.List cgl = ConvertGroup.List.class.cast(anno);
final ConvertGroup[] groups = cgl.value();
from = new Group[groups.length];
to = new Group[groups.length];
from[i] = new Group(groups[i].from());
to[i] = new Group(groups[i].to());
}
} else {
processAnnotation(anno, methodDesc, access, validations);
}
}
ParameterDescriptorImpl paramDesc = null;
for (final ParameterDescriptor pd : methodDesc.getParameterDescriptors()) {
if (pd.getIndex() == idx) {
paramDesc = ParameterDescriptorImpl.class.cast(pd);
}
}
if (paramDesc == null) {
validations.getValidations().toArray(new Validation[validations.getValidations().size()]), name);
paramDesc.setIndex(idx);
final List<ParameterDescriptor> parameterDescriptors = methodDesc.getParameterDescriptors();
if (!parameterDescriptors.contains(paramDesc)) {
parameterDescriptors.add(paramDesc);
}
paramDesc.setCascaded(cascaded);
} else {
final List<ConstraintValidation<?>> newValidations = validations.getValidations();
boolean alreadyHere = false;
for (final ConstraintDescriptor<?> existing : paramDesc.getMutableConstraintDescriptors()) {
alreadyHere = true;
break;
}
}
if (!alreadyHere) {
paramDesc.getMutableConstraintDescriptors().add(validation);
}
}
if (cascaded) {
paramDesc.setCascaded(true);
}
if (paramDesc.isCascaded() && from != null) {
paramDesc.addGroupConversion(new GroupConversionDescriptorImpl(from[i], to[i]));
}
} else if (from != null) {
throw new ConstraintDeclarationException("Group conversion is only relevant for @Valid cases");
}
return validations;
}
private <A extends Annotation> void processAnnotation(final A annotation, final InvocableElementDescriptor desc,
final AccessStrategy access, final AppendValidation validations) throws InvocationTargetException, IllegalAccessException {
if (annotation.annotationType().getName().startsWith("java.lang.annotation.")) {
return;
}
if (annotation instanceof Valid || annotation instanceof Validate) {
desc.setCascaded(true);
final ConvertGroup cg = ConvertGroup.class.cast(annotation);
desc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(cg.from()), new Group(cg.to())));
} else if (ConvertGroup.List.class.isInstance(annotation) && ReturnAccess.class.isInstance(access)) {
final ConvertGroup.List cgl = ConvertGroup.List.class.cast(annotation);
for (final ConvertGroup cg : cgl.value()) {
desc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(cg.from()), new Group(cg.to())));
}
} else {
Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
if (vcAnno != null) {
annotationProcessor.processAnnotation(annotation, null, ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations, true);
} else {
final ConstraintAnnotationAttributes.Worker<? extends Annotation> worker = ConstraintAnnotationAttributes.VALUE.analyze(annotation.annotationType());
if (worker.isValid()) {
Annotation[] children = Annotation[].class.cast(worker.read(annotation));
if (children != null) {
for (Annotation child : children) {
}
}
}
}
}
}
private void buildExecutableDescriptors() {
try {
buildMethodConstraints();
buildConstructorConstraints();
} catch (final Exception ex) {
if (RuntimeException.class.isInstance(ex)) {
throw RuntimeException.class.cast(ex);
}
throw new IllegalArgumentException(ex.getMessage(), ex);
findDefaultResourceBundle(defaultLocale);
findUserResourceBundle(defaultLocale);
protected static Set<ConstraintDescriptor<?>> getConstraintDescriptors(final Validation[] validations) {
private static final ELResolver RESOLVER = initResolver();
final BValELContext context = new BValELContext();
final VariableMapper variables = context.getVariableMapper();
for (final Map.Entry<String, Object> var : annotationParameters.entrySet()) {
variables.setVariable(var.getKey(), EXPRESSION_FACTORY.createValueExpression(var.getValue(), Object.class));
}
variables.setVariable("validatedValue", EXPRESSION_FACTORY.createValueExpression(validatedValue, Object.class));
public BValELContext() {
return RESOLVER;
return EXPRESSION_FACTORY.createValueExpression(new BValFormatter(), Object.class);
private final int hashCode;
this.hashCode = computeHashCode();
return hashCode;
}
public int computeHashCode() {
private final int hashCode;
this.hashCode = computeHashCode();
return hashCode;
}
public int computeHashCode() {
String PROPERTIES = "properties";
private final Set<ConstructorDescriptor> constrainedConstructors;
private final Set<MethodDescriptor> containedMethods;
private final Boolean isBeanConstrained;
private final Set<PropertyDescriptor> validatedProperties;
protected BeanDescriptorImpl(final ApacheFactoryContext factoryContext, final MetaBean metaBean) {
Set<PropertyDescriptor> procedureDescriptors = metaBean.getFeature(Jsr303Features.Bean.PROPERTIES);
if (procedureDescriptors == null) {
procedureDescriptors = new HashSet<PropertyDescriptor>();
for (final MetaProperty prop : metaBean.getProperties()) {
if (prop.getValidations().length > 0
|| (prop.getMetaBean() != null || prop.getFeature(Features.Property.REF_CASCADE) != null)) {
procedureDescriptors.add(getPropertyDescriptor(prop));
}
}
metaBean.putFeature(Jsr303Features.Bean.PROPERTIES, procedureDescriptors);
}
validatedProperties = Collections.unmodifiableSet(procedureDescriptors);
containedMethods = toConstrained(meta.methodConstraints.values());
constrainedConstructors = toConstrained(meta.contructorConstraints.values());
private static <A extends ExecutableDescriptor> Set<A> toConstrained(final Collection<A> src) {
final Set<A> dest = new HashSet<A>();
return Collections.unmodifiableSet(dest);
boolean hasAnyContraints = false;
try {
beanInfo = builder.buildForId(beanInfoId);
cache.cache(beanInfo);
computeRelationships(beanInfo);
return beanInfo;
} catch (final RuntimeException e) {
} catch (final Exception e) {
try {
beanInfo = builder.buildForClass(clazz);
cache.cache(beanInfo);
computeRelationships(beanInfo);
return beanInfo;
} catch (final RuntimeException e) {
} catch (final Exception e) {
import org.apache.commons.lang3.ArrayUtils;
final T value = (T) features.get(key);
if (value == null) {
return defaultValue;
return value;
public <T> void putFeature(final String key, final T value) {
features.put(key, value);
}
public <T> T initFeature(final String key, final T value) {
final T old = (T) features.putIfAbsent(key, value);
if (old != null) {
return old;
return value;
if (result == null && bmi.cdi == null) {
bmi.cdi = false;
bmi.cdi = true;
private Boolean cdi = null;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private final ConcurrentMap<Class<?>, List<AccessStrategy>> validAccesses;
private final ConcurrentMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>> constraintMap;
public static ApacheValidatorFactory getDefault() {
synchronized (ApacheValidatorFactory.class) {
if (DEFAULT_FACTORY == null) {
DEFAULT_FACTORY = Validation.byProvider(ApacheValidationProvider.class).configure()
.buildValidatorFactory().unwrap(ApacheValidatorFactory.class);
}
}
validAccesses = new ConcurrentHashMap<Class<?>, List<AccessStrategy>>();
constraintMap = new ConcurrentHashMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>>();
List<MetaConstraint<?, ? extends Annotation>> slot = constraintMap.get(beanClass);
if (slot == null) {
slot = new ArrayList<MetaConstraint<?, ? extends Annotation>>();
final List<MetaConstraint<?, ? extends Annotation>> old = constraintMap.putIfAbsent(beanClass, slot);
if (old != null) {
slot = old;
List<AccessStrategy> slot = validAccesses.get(beanClass);
if (slot == null) {
slot = new ArrayList<AccessStrategy>();
final List<AccessStrategy> old = validAccesses.putIfAbsent(beanClass, slot);
if (old != null) {
slot = old;
procedureDescriptors = metaBean.initFeature(Jsr303Features.Bean.PROPERTIES, procedureDescriptors);
executables = metaBean.initFeature(Jsr303Features.Bean.EXECUTABLES, executables);
private volatile ValidationParser parser;
return createBootstrapConfiguration();
createBootstrapConfiguration();
private BootstrapConfiguration createBootstrapConfiguration() {
if (parser == null) {
bootstrapConfiguration = parser.getBootstrap();
}
return bootstrapConfiguration;
}
groupSeq = metabean.initFeature(key, new ArrayList<Group>(annotation == null ? 1 : annotation.value().length));
import java.util.concurrent.ConcurrentHashMap;
private final Map<Class<?>, List<Group>> resolvedSequences = new ConcurrentHashMap<Class<?>, List<Group>>();
boolean hasAnyContraints;
method = Reflection.INSTANCE.getPublicMethod(constraintType, attributeName);
if (!TypeUtils.isAssignable(method.getReturnType(), type)) {
if (TypeUtils.isArrayType(type) && Array.getLength(_defaultValue) > 0) {
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Method>> METHOD_BY_NAME_AND_CLASS = new ConcurrentHashMap<Class<?>, ConcurrentMap<String, Method>>();
private static final Method NULL_METHOD;
static {
try {
} catch (NoSuchMethodException e) {
throw new RuntimeException("Impossible normally");
}
}
method = findMethod(constraintType, attributeName);
if (method == null || method == NULL_METHOD) {
private Method findMethod(final Class<C> constraintType, final String attributeName) {
ConcurrentMap<String, Method> cache = METHOD_BY_NAME_AND_CLASS.get(constraintType);
if (cache == null) {
cache = new ConcurrentHashMap<String, Method>();
final ConcurrentMap<String, Method> old = METHOD_BY_NAME_AND_CLASS.putIfAbsent(constraintType, cache);
if (old != null) {
cache = old;
}
}
final Method found = cache.get(attributeName);
if (found != null) {
return found;
}
final Method m = Reflection.INSTANCE.getPublicMethod(constraintType, attributeName);
if (m == null) {
cache.putIfAbsent(attributeName, NULL_METHOD);
return null;
}
final Method oldMtd = cache.putIfAbsent(attributeName, m);
if (oldMtd != null) {
return oldMtd;
}
return m;
}
final Map<String, Object> result = new HashMap<String, Object>();
for (final Method m : descriptor.getMethods()) {
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private static final ConcurrentMap<Class<?>, Method[]> METHODS_CACHE = new ConcurrentHashMap<Class<?>, Method[]>();
private final Method[] methods;
public AnnotationProxyBuilder(final Class<A> annotationType) {
Method[] mtd = METHODS_CACHE.get(annotationType);
if (mtd == null) {
final Method[] value = Reflection.INSTANCE.getDeclaredMethods(type);
mtd = METHODS_CACHE.putIfAbsent(annotationType, value);
if (mtd == null) {
mtd = value;
}
}
this.methods = mtd;
} else {
this.methods = Reflection.INSTANCE.getDeclaredMethods(type);
}
public Method[] getMethods() {
return methods;
}
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
private static final String VALIDATION_CONFIGURATION_XSD = "META-INF/validation-configuration-1.1.xsd";
private static final ConcurrentMap<String, Schema> SCHEMA_CACHE = new ConcurrentHashMap<String, Schema>(1);
protected static InputStream getInputStream(final String path) throws IOException {
final ClassLoader loader = Reflection.INSTANCE.getClassLoader(ValidationParser.class);
final InputStream inputStream = loader.getResourceAsStream(path);
final Enumeration<URL> urls = loader.getResources(path);
final String url = urls.nextElement().toString();
final Schema schema = SCHEMA_CACHE.get(xsd);
if (schema != null) {
return schema;
}
Schema s = sf.newSchema(schemaUrl);
final Schema old = SCHEMA_CACHE.putIfAbsent(xsd, s);
if (old != null) {
s = old;
}
return s;
for (final Method method : AnnotationProxyBuilder.findMethods(annotationType)) {
this.methods = findMethods(annotationType);
}
public static <A> Method[] findMethods(final Class<A> annotationType) {
final Method[] value = Reflection.INSTANCE.getDeclaredMethods(annotationType);
return mtd;
return Reflection.INSTANCE.getDeclaredMethods(annotationType);
private ConstraintMappingsType parseXmlMappings(final InputStream in) {
final JAXBContext jc = JAXBContext.newInstance(ConstraintMappingsType.class);
final Unmarshaller unmarshaller = jc.createUnmarshaller();
final StreamSource stream = new StreamSource(in);
final JAXBElement<ConstraintMappingsType> root = unmarshaller.unmarshal(stream, ConstraintMappingsType.class);
} catch (final JAXBException e) {
import java.lang.reflect.AccessibleObject;
processConvertGroup(edesc, field);
if (m != null) {
processConvertGroup(edesc, m);
methodFound = true;
} else {
if (m != null) {
processConvertGroup(edesc, m);
private static void processConvertGroup(final ElementDescriptorImpl edesc, final AccessibleObject accessible) {
final ConvertGroup.List convertGroupList = accessible.getAnnotation(ConvertGroup.List.class);
if (convertGroupList != null) {
for (final ConvertGroup convertGroup : convertGroupList.value()) {
edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
}
}
final ConvertGroup convertGroup = accessible.getAnnotation(ConvertGroup.class);
if (convertGroup != null) {
edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
}
}
private PropertyDescriptor getPropertyDescriptor(final MetaProperty prop) {
final ConstructorDescriptorImpl consDesc = new ConstructorDescriptorImpl(metaBean, EMPTY_VALIDATION);
for (final Annotation anno : method.getAnnotations()) {
final ParameterDescriptorImpl parameterDescriptor = new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx));
processConstraint(anno, methodDesc, access, validations);
processConstraint(annotation, desc, access, validations);
}
}
private <A extends Annotation> void processConstraint(final A annotation, final InvocableElementDescriptor desc,
final AccessStrategy access, final AppendValidation validations) throws IllegalAccessException, InvocationTargetException {
Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
if (vcAnno != null) {
annotationProcessor.processAnnotation(annotation, null, ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations, true);
} else {
final ConstraintAnnotationAttributes.Worker<? extends Annotation> worker = ConstraintAnnotationAttributes.VALUE.analyze(annotation.annotationType());
if (worker.isValid()) {
Annotation[] children = Annotation[].class.cast(worker.read(annotation));
if (children != null) {
for (Annotation child : children) {
public BeanDescriptor getConstraintsForClass(final Class<?> clazz) {
edesc = metaBean.initFeature(Jsr303Features.Bean.BEAN_DESCRIPTOR, createBeanDescriptor(metaBean));
private final Map<Class<?>, Boolean> ignoreAnnotationDefaults = new HashMap<Class<?>, Boolean>();
import javax.validation.ConstraintValidatorFactory;
public AnnotationConstraintBuilder(ConstraintValidatorFactory factory, Class<? extends ConstraintValidator<A, ?>>[] validatorClasses,
A annotation, Class<?> owner, AccessStrategy access, ConstraintTarget target) {
constraintValidation = new ConstraintValidation<A>(factory, validatorClasses, annotation, owner, access, reportFromComposite, target);
new AnnotationConstraintBuilder<A>(factoryContext.getConstraintValidatorFactory(), constraintClasses, annotation, owner, access, null);
public final <T extends Annotation> void append(final ConstraintValidation<T> validation) {
public abstract <T extends Annotation> void performAppend(final ConstraintValidation<T> validation);
public <T extends Annotation> void preProcessValidation(final ConstraintValidation<T> validation) {
public <T extends Annotation> void postProcessValidation(final ConstraintValidation<T> validation) {
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.reflect.TypeUtils;
import javax.validation.ConstraintValidatorFactory;
import javax.validation.UnexpectedTypeException;
import javax.validation.constraintvalidation.SupportedValidationTarget;
import javax.validation.constraintvalidation.ValidationTarget;
import java.lang.reflect.Array;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collection;
private final ConstraintValidatorFactory factory;
private ConstraintValidator<T, ?> validator;
public ConstraintValidation(ConstraintValidatorFactory factory,
Class<? extends ConstraintValidator<T, ?>>[] validatorClasses,
T annotation, Class<?> owner, AccessStrategy access,
boolean reportFromComposite, ConstraintTarget target) {
this.factory = factory;
public void validate(final GroupValidationContext<?> context) {
if (validator == null) {
synchronized (this) {
if (validator == null) {
try {
validator = getConstraintValidator(annotation, validatorClasses, owner, access);
if (validator != null) {
validator.initialize(annotation);
}
} catch (final RuntimeException re) {
if (ValidationException.class.isInstance(re)) {
throw re;
}
throw new ConstraintDefinitionException(re);
}
}
}
for (Iterator<ConstraintValidation<?>> composed = getComposingValidations().iterator(); !failed && composed.hasNext(); ) {
private <A extends Annotation, T> ConstraintValidator<A, ? super T> getConstraintValidator(A annotation,
Class<? extends ConstraintValidator<A, ?>>[] constraintClasses, Class<?> owner, AccessStrategy access) {
if (constraintClasses != null && constraintClasses.length > 0) {
Type type = determineTargetedType(owner, access);
final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validatorTypes = getValidatorsTypes(constraintClasses);
reduceTarget(validatorTypes, access);
final List<Type> assignableTypes = new ArrayList<Type>(constraintClasses.length);
fillAssignableTypes(type, validatorTypes.keySet(), assignableTypes);
reduceAssignableTypes(assignableTypes);
checkOneType(assignableTypes, type, owner, annotation, access);
if ((type == Object.class || type == Object[].class) && validatorTypes.containsKey(Object.class) && validatorTypes.containsKey(Object[].class)) {
throw new ConstraintDefinitionException("Only a validator for Object or Object[] should be provided for cross parameter validators");
}
final Collection<Class<? extends ConstraintValidator<A, ?>>> key = validatorTypes.get(assignableTypes.get(0));
if (key.size() > 1) {
throw new ConstraintDefinitionException(message);
}
throw new UnexpectedTypeException(message);
}
@SuppressWarnings("unchecked")
final ConstraintValidator<A, ? super T> validator = (ConstraintValidator<A, ? super T>) factory.getInstance(key.iterator().next());
if (validator == null) {
}
return validator;
}
return null;
}
private <A extends Annotation> void reduceTarget(final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validator, final AccessStrategy access) {
for (final Map.Entry<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> entry : validator.entrySet()) {
final Collection<Class<? extends ConstraintValidator<A, ?>>> validators = entry.getValue();
final Iterator<Class<? extends ConstraintValidator<A, ?>>> it = validators.iterator();
while (it.hasNext()) {
final Type v = it.next();
if (!Class.class.isInstance(v)) {
}
final Class<?> clazz = Class.class.cast(v);
final SupportedValidationTarget target = clazz.getAnnotation(SupportedValidationTarget.class);
if (target != null) {
final Collection<ValidationTarget> targets = Arrays.asList(target.value());
final boolean isParameter = ParameterAccess.class.isInstance(access) || ParametersAccess.class.isInstance(access);
if ((isParameter && !targets.contains(ValidationTarget.PARAMETERS))
|| (!isParameter && !targets.contains(ValidationTarget.ANNOTATED_ELEMENT))) {
it.remove();
}
}
}
if (validators.isEmpty()) {
validator.remove(entry.getKey());
}
}
}
private static void checkOneType(List<Type> types, Type targetType, Class<?> owner, Annotation anno,
AccessStrategy access) {
if (types.isEmpty()) {
throw new ConstraintDefinitionException(message);
}
throw new UnexpectedTypeException(message);
} else if (types.size() > 1) {
StringBuilder buf = new StringBuilder();
buf.append("Ambiguous validators for type ");
buf.append(stringForType(targetType));
buf.append(". See: @").append(anno.annotationType().getSimpleName()).append(" at ").append(
stringForLocation(owner, access));
buf.append(". Validators are: ");
boolean comma = false;
for (Type each : types) {
if (comma)
buf.append(", ");
comma = true;
buf.append(each);
}
throw new UnexpectedTypeException(buf.toString());
}
}
private static String stringForType(Type clazz) {
if (clazz instanceof Class<?>) {
if (((Class<?>) clazz).isArray()) {
} else {
return ((Class<?>) clazz).getName();
}
} else {
return clazz.toString();
}
}
private static String stringForLocation(Class<?> owner, AccessStrategy access) {
if (access != null) {
return access.toString();
} else {
return owner.getName();
}
}
private static void fillAssignableTypes(Type type, Set<Type> validatorsTypes, List<Type> suitableTypes) {
for (final Type validatorType : validatorsTypes) {
if (org.apache.commons.lang3.reflect.TypeUtils.isAssignable(type, validatorType)
&& !suitableTypes.contains(validatorType)) {
suitableTypes.add(validatorType);
}
}
}
private static void reduceAssignableTypes(List<Type> assignableTypes) {
if (assignableTypes.size() <= 1) {
}
boolean removed;
do {
removed = false;
final Type type = assignableTypes.get(0);
Type nextType = assignableTypes.get(i);
if (TypeUtils.isAssignable(nextType, type)) {
assignableTypes.remove(0);
i--;
removed = true;
} else if (TypeUtils.isAssignable(type, nextType)) {
assignableTypes.remove(i--);
removed = true;
}
}
} while (removed && assignableTypes.size() > 1);
}
private static <A extends Annotation> Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> getValidatorsTypes(
Class<? extends ConstraintValidator<A, ?>>[] constraintValidatorClasses) {
final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validatorsTypes = new HashMap<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>>();
for (Class<? extends ConstraintValidator<A, ?>> validatorType : constraintValidatorClasses) {
Type validatedType = TypeUtils.getTypeArguments(validatorType, ConstraintValidator.class).get(ConstraintValidator.class.getTypeParameters()[1]);
if (validatedType == null) {
throw new ValidationException(String.format("Could not detect validated type for %s", validatorType));
}
if (validatedType instanceof GenericArrayType) {
Type componentType = TypeUtils.getArrayComponentType(validatedType);
if (componentType instanceof Class<?>) {
validatedType = Array.newInstance((Class<?>) componentType, 0).getClass();
}
}
if (!validatorsTypes.containsKey(validatedType)) {
validatorsTypes.put(validatedType, new ArrayList<Class<? extends ConstraintValidator<A, ?>>>());
}
validatorsTypes.get(validatedType).add(validatorType);
}
return validatorsTypes;
}
private static Type determineTargetedType(Class<?> owner, AccessStrategy access) {
if (access == null)
return owner;
Type type = access.getJavaType();
if (type == null)
return Object.class;
if (type instanceof Class<?>)
type = ClassUtils.primitiveToWrapper((Class<?>) type);
return type;
}
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Collection;
import static org.apache.bval.model.Features.Property.HIDDEN;
import static org.apache.bval.model.Features.Property.PREFERRED;
import static org.apache.bval.model.Features.Property.READONLY;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.bval.model.MetaBean;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import org.apache.commons.lang3.reflect.TypeUtils;
import org.apache.commons.lang3.reflect.TypeUtils;
import java.util.List;
import java.util.Map;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.Character.getNumericValue;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Annotation;
import static java.lang.Character.getNumericValue;
import static java.lang.Character.isDigit;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.Character.getNumericValue;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.io.File;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.io.File;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.io.File;
import java.io.IOException;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import static java.util.Arrays.asList;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.util.regex.Pattern;
import org.apache.bval.jsr303.ConfigurationImpl;
import com.google.inject.Injector;
import com.google.inject.BindingAnnotation;
import javax.validation.ConstraintViolationException;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import com.google.inject.AbstractModule;
import com.google.inject.Scopes;
import com.google.inject.TypeLiteral;
import com.google.inject.matcher.Matchers;
import org.aopalliance.intercept.MethodInterceptor;
import org.apache.bval.jsr303.ApacheValidationProvider;
import org.apache.bval.jsr303.DefaultMessageInterpolator;
import org.apache.bval.jsr303.resolver.DefaultTraversableResolver;
import org.apache.bval.jsr303.ApacheValidationProvider;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import org.apache.bval.model.MetaBean;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import org.apache.commons.lang3.reflect.TypeUtils;
boolean foundPayload = false;
boolean foundGroups = false;
Method validationAppliesTo = null;
boolean foundMessage = false;
foundPayload = true;
foundGroups = true;
validationAppliesTo = method;
if (ConstraintAnnotationAttributes.MESSAGE.getAttributeName().equals(name)) {
foundMessage = true;
if (!TypeUtils.isAssignable(method.getReturnType(), ConstraintAnnotationAttributes.MESSAGE.getType())) {
}
}
if (!foundMessage) {
}
if (!foundPayload) {
}
if (!foundGroups) {
}
if (validationAppliesTo != null && !ConstraintTarget.IMPLICIT.equals(validationAppliesTo.getDefaultValue())) {
throw new ConstraintDefinitionException("validationAppliesTo default value should be IMPLICIT");
}
if (!TypeUtils.isAssignable(method.getReturnType(), ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getType())) {
}
if (!TypeUtils.isAssignable(method.getReturnType(), ConstraintAnnotationAttributes.GROUPS.getType())) {
}
if (Object[].class.cast(method.getDefaultValue()).length > 0) {
throw new ConstraintDefinitionException("Default value for groups() must be an empty array");
}
private void buildPayload(final Method method) throws IllegalAccessException, InvocationTargetException {
if (!TypeUtils.isAssignable(method.getReturnType(), ConstraintAnnotationAttributes.PAYLOAD.getType())) {
}
if (Object[].class.cast(method.getDefaultValue()).length > 0) {
throw new ConstraintDefinitionException("Default value for payload() must be an empty array");
}
import org.apache.commons.lang3.ClassUtils;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Set;
Worker<C> w = Worker.class.cast(WORKER_CACHE.get(clazz));
if (w == null) {
w = new Worker<C>(clazz);
WORKER_CACHE.putIfAbsent(clazz, w);
return w;
}
}
private static final ConcurrentMap<Class<?>, Worker<?>> WORKER_CACHE = new ConcurrentHashMap<Class<?>, Worker<?>>();
method = findMethod(constraintType, attributeName);
if (!m.isAccessible()) {
m.setAccessible(true);
}
return method != null && method != NULL_METHOD;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import javax.validation.groups.Default;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.lang3.StringEscapeUtils;
import java.io.StringWriter;
import java.text.ParsePosition;
import java.lang.reflect.Type;
import org.apache.bval.jsr303.example.Address;
import org.apache.bval.jsr303.example.Author;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.xml.XMLMetaValue;
import java.util.Collection;
import java.util.Date;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.routines.StandardValidation;
import static org.apache.bval.model.Features.Property.JAVASCRIPT_VALIDATION_FUNCTIONS;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import com.thoughtworks.xstream.annotations.XStreamOmitField;
import org.apache.bval.model.Validation;
import org.apache.commons.lang3.ClassUtils;
import static org.apache.bval.model.Features.Property.DENIED;
import static org.apache.bval.model.Features.Property.HIDDEN;
import static org.apache.bval.model.Features.Property.MANDATORY;
import static org.apache.bval.model.Features.Property.MAX_LENGTH;
import static org.apache.bval.model.Features.Property.MIN_LENGTH;
import static org.apache.bval.model.Features.Property.READONLY;
import static org.apache.bval.model.Features.Property.MAX_VALUE;
import static org.apache.bval.model.Features.Property.MIN_VALUE;
import static org.apache.bval.model.Features.Property.REG_EXP;
import static org.apache.bval.model.Features.Property.TIME_LAG;
public MethodDescriptor getInternalConstraintsForMethod(final String methodName, final Class<?>... parameterTypes) {
if (methodName == null) {
throw new IllegalArgumentException("Method name can't be null");
}
}
final Object value = worker.read(annotation);
if (Annotation[].class.isInstance(value)) {
final Annotation[] children = Annotation[].class.cast(value);
if (children != null) {
for (Annotation child : children) {
}
return MethodDescriptorImpl.class.cast(
BeanDescriptorImpl.class.cast(getConstraintsForClass(Proxies.classFor(method.getDeclaringClass())))
.getInternalConstraintsForMethod(method.getName(), method.getParameterTypes()));
if (resolver == null) {
return this;
}
if (resolver == null) {
return this;
}
if (constraintFactory == null) {
return this;
}
if (parameterNameProvider == null) {
return this;
}
if (stream == null) {
return this;
}
validation.validateGroupContext(parametersContext);
validation.validateGroupContext(crossParameterContext);
validation.validateGroupContext(parametersContext);
validation.validateGroupContext(crossParameterContext);
validation.validateGroupContext(context);
validation.validateGroupContext(context);
validation.validateGroupContext(context);
validation.validateGroupContext(context);
validateGroupContext((GroupValidationContext<?>) context);
public void validateGroupContext(final GroupValidationContext<?> context) {
if (clazz == null || clazz == Object.class || clazz == Serializable.class || clazz == Cloneable.class) {
if (method.isSynthetic() || method.isBridge()) {
continue;
}
} finally {
try {
stream.close();
} catch (final IOException e) {
}
if (bmpSingleton.bmInfos != null) {
bmpSingleton.bmInfos.remove(loader());
}
private boolean validatorFound = Boolean.getBoolean("bval.in-container");
private boolean validatorFactoryFound = Boolean.getBoolean("bval.in-container");
import org.apache.bval.jsr.parameter.DefaultParameterNameProvider;
import javax.enterprise.inject.spi.AnnotatedCallable;
import javax.validation.ValidationException;
import javax.validation.executable.ValidateOnExecution;
import javax.validation.metadata.BeanDescriptor;
import javax.validation.metadata.MethodType;
import java.util.Collection;
private boolean validBean;
private boolean validConstructors;
private boolean validBusinessMethods;
private boolean validGetterMethods;
private ValidatorFactory factory;
private Validator validator;
validBean = globalExecutableTypes.contains(ExecutableType.IMPLICIT) || globalExecutableTypes.contains(ExecutableType.ALL);
validConstructors =validBean || globalExecutableTypes.contains(ExecutableType.CONSTRUCTORS);
validBusinessMethods = validBean || globalExecutableTypes.contains(ExecutableType.NON_GETTER_METHODS);
validGetterMethods = globalExecutableTypes.contains(ExecutableType.ALL) || globalExecutableTypes.contains(ExecutableType.GETTER_METHODS);
private void ensureFactoryValidator() {
if (validator != null) {
return;
}
factory = factory != null ? factory : config.buildValidatorFactory();
validator = factory.getValidator();
}
final AnnotatedType<A> annotatedType = pat.getAnnotatedType();
final Class<A> javaClass = annotatedType.getJavaClass();
ensureFactoryValidator();
try {
final BeanDescriptor classConstraints = validator.getConstraintsForClass(javaClass);
if (annotatedType.isAnnotationPresent(ValidateOnExecution.class)
|| hasValidationAnnotation(annotatedType.getMethods())
|| hasValidationAnnotation(annotatedType.getConstructors())
|| (validBean && classConstraints.isBeanConstrained())
|| (validConstructors && !classConstraints.getConstrainedConstructors().isEmpty())
|| (validBusinessMethods && !classConstraints.getConstrainedMethods(MethodType.NON_GETTER).isEmpty())
|| (validGetterMethods && !classConstraints.getConstrainedMethods(MethodType.GETTER).isEmpty())) {
final BValAnnotatedType<A> bValAnnotatedType = new BValAnnotatedType<A>(annotatedType);
pat.setAnnotatedType(bValAnnotatedType);
}
} catch (final ValidationException ve) {
LOGGER.log(Level.SEVERE, ve.getMessage(), ve);
}
private static <A> boolean hasValidationAnnotation(final Collection<? extends AnnotatedCallable<? super A>> methods) {
for (final AnnotatedCallable<? super A> m : methods) {
if (m.isAnnotationPresent(ValidateOnExecution.class)) {
return true;
}
}
return false;
}
factory.close();
}
if (bmpSingleton == null) {
bmpSingleton = this;
}
}
try {
} catch (final Exception e) {
}
afterBeanDiscovery.addBean(new ValidatorFactoryBean(factory = config.buildValidatorFactory()));
if (validatorFactoryFound) {
public void cleanupFinalBeanManagers(final @Observes AfterDeploymentValidation ignored) {
public void cleanupStoredBeanManagerOnShutdown(final @Observes BeforeShutdown ignored) {
if (bmpSingleton != null && bmpSingleton.bmInfos != null) {
private static final ConstraintDefaults DEFAULT_CONSTRAINTS = new ConstraintDefaults();
private volatile boolean init;
parameterNameProvider = configuration.getParameterNameProvider();
messageResolver = configuration.getMessageInterpolator();
traversableResolver = configuration.getTraversableResolver();
constraintValidatorFactory = configuration.getConstraintValidatorFactory();
return DEFAULT_CONSTRAINTS;
import org.apache.bval.cdi.BValExtension;
import java.io.IOException;
import java.util.concurrent.CopyOnWriteArrayList;
protected Class<? extends MessageInterpolator> messageInterpolatorClass = null;
protected Class<? extends ConstraintValidatorFactory> constraintValidatorFactoryClass = null;
protected TraversableResolver defaultTraversableResolver = new DefaultTraversableResolver();
protected TraversableResolver traversableResolver = defaultTraversableResolver;
protected Class<? extends TraversableResolver> traversableResolverClass = null;
protected Class<? extends ParameterNameProvider> parameterNameProviderClass = null;
private Collection<BValExtension.Releasable> releasables = new CopyOnWriteArrayList<BValExtension.Releasable>();
private boolean beforeCdi = false;
this.traversableResolverClass = null;
this.traversableResolver = resolver;
this.messageInterpolatorClass = null;
this.constraintValidatorFactoryClass = null;
this.parameterNameProviderClass = null;
if ("bval.before.cdi".equals(name)) {
beforeCdi = Boolean.parseBoolean(value);
} else {
properties.put(name, value);
}
if (beforeCdi) {
return defaultMessageInterpolator;
}
if (messageInterpolator == defaultMessageInterpolator && messageInterpolatorClass != null) {
synchronized (this) {
if (messageInterpolator == defaultMessageInterpolator && messageInterpolatorClass != null) {
messageInterpolator = newInstance(messageInterpolatorClass);
}
}
}
if (beforeCdi) {
return constraintValidatorFactory;
}
if (constraintValidatorFactory == defaultConstraintValidatorFactory && constraintValidatorFactoryClass != null) {
synchronized (this) {
if (constraintValidatorFactory == defaultConstraintValidatorFactory && constraintValidatorFactoryClass != null) {
constraintValidatorFactory = newInstance(constraintValidatorFactoryClass);
}
}
}
if (beforeCdi) {
return defaultTraversableResolver;
}
if (traversableResolver == defaultTraversableResolver && traversableResolverClass != null) {
synchronized (this) {
if (traversableResolver == defaultTraversableResolver && traversableResolverClass != null) {
traversableResolver = newInstance(traversableResolverClass);
}
}
}
if (beforeCdi) {
return defaultParameterNameProvider;
}
if (parameterNameProvider == defaultParameterNameProvider && parameterNameProviderClass != null) {
synchronized (this) {
if (parameterNameProvider == defaultParameterNameProvider && parameterNameProviderClass != null) {
parameterNameProvider = newInstance(parameterNameProviderClass);
}
}
}
return new Closeable() {
public void close() throws IOException {
for (final BValExtension.Releasable<?> releasable : releasables) {
releasable.release();
}
releasables.clear();
}
};
private <T> T newInstance(final Class<T> cls) {
if (System.getSecurityManager() == null) {
return createInstance(cls);
}
return AccessController.doPrivileged(new PrivilegedAction<T>() {
public T run() {
return createInstance(cls);
}
});
private <T> T createInstance(final Class<T> cls) {
try {
final BValExtension.Releasable<T> releasable = BValExtension.inject(cls);
releasables.add(releasable);
return releasable.getInstance();
} catch (final Exception e) {
try {
return cls.newInstance();
} catch (final InstantiationException e1) {
throw new ValidationException(e1.getMessage(), e1);
} catch (final IllegalAccessException e1) {
throw new ValidationException(e1.getMessage(), e1);
}
} catch (final NoClassDefFoundError error) {
try {
return cls.newInstance();
} catch (final InstantiationException e1) {
throw new ValidationException(e1.getMessage(), e1);
} catch (final IllegalAccessException e1) {
throw new ValidationException(e1.getMessage(), e1);
}
}
}
public void traversableResolverClass(final Class<TraversableResolver> clazz) {
traversableResolverClass = clazz;
}
public void constraintValidatorFactoryClass(final Class<ConstraintValidatorFactory> clazz) {
constraintValidatorFactoryClass = clazz;
}
public void messageInterpolatorClass(final Class<MessageInterpolator> clazz) {
messageInterpolatorClass = clazz;
}
public void parameterNameProviderClass(final Class<? extends ParameterNameProvider> clazz) {
parameterNameProviderClass = clazz;
public class ValidationParser {
targetConfig.parameterNameProviderClass(clazz);
target.messageInterpolatorClass(clazz);
target.traversableResolverClass(clazz);
target.constraintValidatorFactoryClass(clazz);
ensureFactoryValidator();
LOGGER.log(Level.FINEST, ve.getMessage(), ve);
|| (validBean && classConstraints != null && classConstraints.isBeanConstrained())
|| (validConstructors && classConstraints != null && !classConstraints.getConstrainedConstructors().isEmpty())
|| (validBusinessMethods && classConstraints != null && !classConstraints.getConstrainedMethods(MethodType.NON_GETTER).isEmpty())
|| (validGetterMethods && classConstraints != null && !classConstraints.getConstrainedMethods(MethodType.GETTER).isEmpty())) {
if (instance != null) {
releasables.add(instance);
}
final Set<ConstraintViolation<?>> violations = executableValidator.validateConstructorReturnValue(constructor, context.getTarget());
afterBeanDiscovery.addBean(new ValidatorBean(factory, factory.getValidator()));
afterBeanDiscovery.addBean(new ValidatorBean(factory, null));
validatorFound = true;
import javax.validation.ValidatorFactory;
private final ValidatorFactory factory;
private volatile Validator instance;
public ValidatorBean(final ValidatorFactory factory, final Validator validator) {
this.factory = factory;
if (instance == null) {
synchronized (this) {
if (instance == null) {
instance = factory.getValidator();
}
}
}
builder.service(TestEnricher.class, EJBEnricher.class);
import java.util.HashSet;
public static Collection<String> SKIPPED_PREFIXES = new HashSet<String>();
static {
SKIPPED_PREFIXES.add("java.");
SKIPPED_PREFIXES.add("javax.");
SKIPPED_PREFIXES.add("org.apache.bval.");
SKIPPED_PREFIXES.add("org.apache.openejb.");
}
protected boolean skip(final String name) {
for (final String p : SKIPPED_PREFIXES) {
if (name.startsWith(p)) {
return true;
}
}
return false;
}
final String name = javaClass.getName();
if (skip(name)) {
return;
}
if (!javaClass.isInterface() && !Modifier.isFinal(modifiers) && !Modifier.isAbstract(modifiers)) {
import org.apache.bval.util.AccessStrategy;
setAccessible(constructor);
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
for (final Field f : Reflection.getDeclaredFields(clazz)) {
for (final Method m : Reflection.getDeclaredMethods(clazz)) {
for (final Constructor<?> c : Reflection.getDeclaredConstructors(beanClass)) {
import java.lang.reflect.AccessibleObject;
import org.apache.commons.weaver.privilizer.Privileged;
protected boolean setAccessible(AccessibleObject accessibleObject) {
if (accessibleObject.isAccessible()) {
return false;
}
doSetAccessible(accessibleObject);
return true;
}
@Privileged
private void doSetAccessible(AccessibleObject accessibleObject) {
accessibleObject.setAccessible(true);
}
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final StringBuilder buf = new StringBuilder(80 * 40);
final StringTokenizer tok = new StringTokenizer(Reflection.getProperty("java.class.path"));
return buf.append(prop).append(": ").append(Reflection.getProperty(prop));
setAccessible(field);
import org.apache.commons.lang3.ObjectUtils;
return ObjectUtils.defaultIfNull(TypeUtils.unrollVariables(typeArguments, ITERABLE_TYPE), Object.class);
private final Type containerType;
private final Integer index;
import org.apache.commons.lang3.ObjectUtils;
return ObjectUtils.defaultIfNull(TypeUtils.unrollVariables(typeArguments, MAP_TYPEVARS[1]), Object.class);
private final Type containerType;
private final Object key;
Type keyType = TypeUtils.unrollVariables(typeArguments, MAP_TYPEVARS[0]);
final Type result = getJavaElementType(containerType);
setAccessible(method);
final String methodName = member.getName();
return Introspector.decapitalize(methodName.substring(2));
if (methodName.startsWith("get")) {
return Introspector.decapitalize(methodName.substring(3));
}
return null;
import java.lang.reflect.Modifier;
import org.apache.commons.lang3.ClassUtils;
public class Reflection {
private static void setAccessibility(final Field field) {
if (!Modifier.isPublic(field.getModifiers())
|| (Modifier.isPublic(field.getModifiers()) && Modifier.isAbstract(field.getModifiers()))) {
field.setAccessible(true);
public static Class<?> getClass(final ClassLoader classLoader, final String className) throws Exception {
return ClassUtils.getClass(classLoader, className, true);
}
public static Object getAnnotationValue(final Annotation annotation, final String name)
throws IllegalAccessException, InvocationTargetException {
Method valueMethod;
try {
valueMethod = annotation.annotationType().getDeclaredMethod(name);
} catch (final NoSuchMethodException ex) {
valueMethod = null;
}
if (null != valueMethod) {
if (!valueMethod.isAccessible()) {
valueMethod.setAccessible(true);
}
return valueMethod.invoke(annotation);
}
return null;
}
public static ClassLoader getClassLoader(final Class<?> clazz) {
final ClassLoader cl = Thread.currentThread().getContextClassLoader();
if (cl != null) {
return cl;
}
return clazz.getClassLoader();
}
public static String getProperty(final String name) {
return System.getProperty(name);
}
public static Field getDeclaredField(final Class<?> clazz, final String fieldName) {
final Field f;
try {
f = clazz.getDeclaredField(fieldName);
} catch (final NoSuchFieldException e) {
return null;
}
setAccessibility(f);
return f;
}
public static Field[] getDeclaredFields(final Class<?> clazz) {
final Field[] fields = clazz.getDeclaredFields();
if (fields.length > 0) {
for (final Field f : fields) {
if (!f.isAccessible()) {
f.setAccessible(true);
}
}
}
return fields;
}
public static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>... parameters) {
try {
return clazz.getDeclaredConstructor(parameters);
} catch (final NoSuchMethodException e) {
return null;
}
}
public static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>... parameters) {
try {
return clazz.getDeclaredMethod(name, parameters);
} catch (final NoSuchMethodException e) {
return null;
}
}
public static Method[] getDeclaredMethods(final Class<?> clazz) {
return clazz.getDeclaredMethods();
}
public static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz) {
return clazz.getDeclaredConstructors();
}
public static Method getPublicMethod(final Class<?> clazz, final String methodName) {
try {
return clazz.getMethod(methodName);
} catch (final NoSuchMethodException e) {
return null;
}
}
public static <T> T newInstance(final Class<T> cls) {
try {
return cls.newInstance();
} catch (final Exception ex) {
}
}
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.bval.jsr.groups.GroupsComputer;
import org.apache.bval.jsr.xml.AnnotationProxyBuilder;
import org.apache.bval.util.AccessStrategy;
import org.apache.commons.lang3.reflect.TypeUtils;
import org.apache.commons.weaver.privilizer.Privileged;
@Privileged
if (constraintValidation.getAnnotation() == null) {
return;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final Object result =
Reflection.getAnnotationValue(annotation, ConstraintAnnotationAttributes.VALUE.getAttributeName());
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;
import javax.validation.ConstraintValidatorFactory;
import javax.validation.MessageInterpolator;
import javax.validation.ParameterNameProvider;
import javax.validation.TraversableResolver;
import javax.validation.ValidationException;
import javax.validation.Validator;
import javax.validation.ValidatorContext;
import org.apache.commons.weaver.privilizer.Privileged;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
@Privileged
return Class.forName(className, true, Reflection.getClassLoader(ApacheFactoryContext.class));
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.weaver.privilizer.Privileged;
return instantiateValidatorFactory(validatorFactoryClass, configuration);
@Privileged
String VALIDATOR_FACTORY_CLASSNAME = "apache.bval.validator-factory-classname";
String METABEAN_FACTORY_CLASSNAMES = "apache.bval.metabean-factory-classnames";
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
return Reflection.newInstance(cls);
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final Field field = Reflection.getDeclaredField(current, prop.getName());
for (final Constructor<?> cons : Reflection.getDeclaredConstructors(metaBean.getBeanClass())) {
for (final Method method : Reflection.getDeclaredMethods(current)) {
final Method overridden = Reflection.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
if (overridden != null) {
parents.add(overridden);
processMethod(overridden, methodDesc);
final Method m = Reflection.getDeclaredMethod(i, method.getName(), method.getParameterTypes());
final Method overridden = Reflection.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
if (overridden != null) {
if (overridden.getAnnotation(Valid.class) != null) {
import java.lang.reflect.Constructor;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintDefinitionException;
import javax.validation.ConstraintTarget;
import javax.validation.ConstraintViolation;
import javax.validation.ElementKind;
import javax.validation.ValidationException;
import javax.validation.executable.ExecutableValidator;
import javax.validation.groups.Default;
import javax.validation.metadata.BeanDescriptor;
import javax.validation.metadata.ConstraintDescriptor;
import javax.validation.metadata.ElementDescriptor;
import javax.validation.metadata.ParameterDescriptor;
import javax.validation.metadata.PropertyDescriptor;
import org.apache.commons.weaver.privilizer.Privileged;
@Privileged
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import org.apache.bval.cdi.BValExtension;
import org.apache.bval.jsr.parameter.DefaultParameterNameProvider;
import org.apache.bval.jsr.resolver.DefaultTraversableResolver;
import org.apache.bval.jsr.util.IOs;
import org.apache.bval.jsr.xml.ValidationParser;
import org.apache.commons.weaver.privilizer.Privileged;
private Collection<BValExtension.Releasable<?>> releasables = new CopyOnWriteArrayList<BValExtension.Releasable<?>>();
return doBuildValidatorFactory();
@Privileged
private ValidatorFactory doBuildValidatorFactory() {
final ValidationProvider<?> useProvider = provider == null ? findProvider() : provider;
return useProvider.buildValidatorFactory(this);
private ConfigurationImpl prepare() {
@Privileged
}
try {
return cls.newInstance();
} catch (final Exception e) {
throw new ValidationException(e.getMessage(), e);
import org.apache.commons.weaver.privilizer.Privileged;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
MESSAGE("message"),
GROUPS("groups"),
PAYLOAD("payload"),
VALIDATION_APPLIES_TO("validationAppliesTo"),
VALUE("value");
private ConstraintAnnotationAttributes(final String name) {
@SuppressWarnings("unchecked")
@Privilizing(@CallTo(Reflection.class))
final Method m = Reflection.getPublicMethod(constraintType, attributeName);
public <T> T read(final Annotation constraint) {
@SuppressWarnings("unchecked")
final T result = (T) doInvoke(constraint);
return result;
@Privileged
import javax.validation.ConstraintValidator;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
try {
classes.add(Reflection.getClass(classloader, eachClassName));
} catch (Exception e) {
log.log(Level.SEVERE, String.format("Cannot find class %s", eachClassName), e);
Class<? extends ConstraintValidator<A, ?>>[] constraintClasses, Class<?> owner, AccessStrategy access) {
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final ClassLoader classLoader = Reflection.getClassLoader(DefaultMessageInterpolator.class);
import javax.validation.ValidationException;
import javax.validation.ValidationProviderResolver;
import javax.validation.spi.ValidationProvider;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final URL url = cfgs.nextElement();
@SuppressWarnings("rawtypes")
final Class<? extends ValidationProvider> providerType =
cl.loadClass(line).asSubclass(ValidationProvider.class);
providers.add(Reflection.newInstance(providerType.asSubclass(ValidationProvider.class)));
if (br != null) {
}
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final List<Class<?>> classSequence =
ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), beanClass);
final Field[] fields = Reflection.getDeclaredFields(beanClass);
final Method[] methods = Reflection.getDeclaredMethods(beanClass);
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final ClassLoader classLoader = Reflection.getClassLoader(DefaultTraversableResolver.class);
Reflection.getClass(classLoader, PERSISTENCE_UTIL_CLASSNAME);
@Deprecated
import org.apache.commons.weaver.privilizer.Privileged;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final Method[] value = Reflection.getDeclaredMethods(annotationType);
return Reflection.getDeclaredMethods(annotationType);
final ClassLoader classLoader = Reflection.getClassLoader(getType());
return doCreateAnnotation(proxyClass, handler);
@Privileged
public static final class ConvertGroupAnnotation implements ConvertGroup {
public ConvertGroupAnnotation(final Class<?> from, final Class<?> to) {
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.apache.bval.jsr.ApacheValidatorFactory;
import org.apache.bval.jsr.ConstraintAnnotationAttributes;
import org.apache.bval.jsr.util.EnumerationConverter;
import org.apache.bval.jsr.util.IOs;
import org.apache.bval.util.FieldAccess;
import org.apache.bval.util.MethodAccess;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.beanutils.ConvertUtils;
import org.apache.commons.beanutils.Converter;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.weaver.privilizer.Privileged;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final Method m = Reflection.getPublicMethod(annotationClass, name);
final Method method = Reflection.getDeclaredMethod(beanClass, methodName, toTypes(methodType.getParameter(), defaultPackage));
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
final Constructor<?> constructor = Reflection.getDeclaredConstructor(beanClass, toTypes(constructorType.getParameter(), defaultPackage));
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
final Field field = Reflection.getDeclaredField(beanClass, fieldName);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, field, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
@Privileged
private static Method getGetter(Class<?> clazz,String propertyName) {
ClassLoader loader = Reflection.getClassLoader(ValidationMappingParser.class);
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.bval.jsr.BootstrapConfigurationImpl;
import org.apache.bval.jsr.ConfigurationImpl;
import org.apache.bval.jsr.util.IOs;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privileged;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
import org.xml.sax.SAXException;
@Privilizing(@CallTo(Reflection.class))
@Privileged
final ClassLoader loader = Reflection.getClassLoader(ValidationParser.class);
final ClassLoader loader = Reflection.getClassLoader(ValidationParser.class);
final Class<? extends ParameterNameProvider> clazz =
loadClass(parameterNameProvider).asSubclass(ParameterNameProvider.class);
final ClassLoader loader = Reflection.getClassLoader(ValidationParser.class);
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
addLoader(new XMLMetaBeanURLLoader(Reflection.getClassLoader(getClass()).getResource(resource)));
private static final long serialVersionUID = 1L;
annotations.add(BValBindingLiteral.INSTANCE);
@SuppressWarnings("unchecked")
final T result = (T) ann;
return result;
public static class BValBindingLiteral extends AnnotationLiteral<BValBinding> implements BValBinding {
private static final long serialVersionUID = 1L;
public static final Annotation INSTANCE = new BValBindingLiteral();
private Collection<ExecutableType> classConfiguration;
private Boolean constructorValidated;
private ExecutableValidator executableValidator;
@SuppressWarnings("rawtypes")
final ConstructorDescriptor constraints =
validator.getConstraintsForClass(targetClass).getConstraintsForConstructor(constructor.getParameterTypes());
@SuppressWarnings("unchecked")
@SuppressWarnings("unchecked")
final MethodDescriptor constraintsForMethod =
validator.getConstraintsForClass(targetClass).getConstraintsForMethod(method.getName(),
method.getParameterTypes());
final Set<ConstraintViolation<Object>> violations =
executableValidator.validateParameters(context.getTarget(), method, context.getParameters());
final Set<ConstraintViolation<Object>> violations =
executableValidator.validateReturnValue(context.getTarget(), method, result);
final ValidateOnExecution annotation =
targetClass.getConstructor(constructor.getParameterTypes()).getAnnotation(
ValidateOnExecution.class);
constructorValidated =
types.contains(ExecutableType.CONSTRUCTORS) || types.contains(ExecutableType.IMPLICIT)
|| types.contains(ExecutableType.ALL);
return constructorValidated.booleanValue();
final List<Class<?>> classHierarchy =
ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), targetClass);
validateOnExecution =
c.getDeclaredMethod(method.getName(), method.getParameterTypes()).getAnnotation(
ValidateOnExecution.class);
} else if (ExecutableType.ALL == type) {
} else if (ExecutableType.NONE != type) {
if (ExecutableType.IMPLICIT ==type) {
} else if (ExecutableType.ALL == type) {
} else if (ExecutableType.NONE != type) {
return (!getter && config.contains(ExecutableType.NON_GETTER_METHODS))
|| (getter && config.contains(ExecutableType.GETTER_METHODS));
return (name.startsWith("get") || name.startsWith("is")) && Void.TYPE.equals(method.getReturnType())
&& method.getParameterTypes().length == 0;
injectionPoints =
Collections.singleton(InjectionPoint.class.cast(new BValInterceptorInjectionPoint(this, injectionTarget
.getInjectionPoints().iterator().next())));
private static final long serialVersionUID = 1L;
import org.apache.commons.lang3.ArrayUtils;
public AnnotationConstraintBuilder(ConstraintValidatorFactory factory,
Class<? extends ConstraintValidator<A, ?>>[] validatorClasses, A annotation, Class<?> owner,
AccessStrategy access, ConstraintTarget target) {
final boolean reportFromComposite =
constraintValidation =
new ConstraintValidation<A>(factory, validatorClasses, annotation, owner, access, reportFromComposite,
target);
}
throw new ConstraintDefinitionException("cross parameter AND generic constraints should get validationAppliesTo attribute");
}
throw new ConstraintDefinitionException("pure generic constraints shouldn't get validationAppliesTo attribute");
throw new ConstraintDefinitionException("Return type for validationAppliesTo() must be of type "
ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getType());
if (!ConstraintTarget.class.isInstance(validationAppliesTo)) {
constraintValidation.setValidationAppliesTo(ConstraintTarget.class.cast(validationAppliesTo));
throw new ConstraintDefinitionException("Return type for groups() must be of type "
ConstraintAnnotationAttributes.GROUPS.getType());
if (ArrayUtils.isEmpty(garr)) {
throw new ConstraintDefinitionException("Return type for payload() must be of type "
ConstraintAnnotationAttributes.PAYLOAD.getType());
final Class<? extends Payload>[] payload_raw =
final Set<Class<? extends Payload>> payloadSet;
final int index = computeIndex(composite);
final ConstraintOverrides generalOverride = findOverride(composite.getAnnotation().annotationType(), -1);
final ConstraintOverrides override = findOverride(composite.getAnnotation().annotationType(), index);
final OverridesAttribute.List overridesAttributeList = method.getAnnotation(OverridesAttribute.List.class);
if (overridesAttributeList != null) {
for (OverridesAttribute overridesAttribute : overridesAttributeList.value()) {
parseConstraintOverride(method.getName(), overridesAttribute);
final OverridesAttribute overridesAttribute = method.getAnnotation(OverridesAttribute.class);
if (overridesAttribute != null) {
parseConstraintOverride(method.getName(), overridesAttribute);
final Annotation originalAnnot = composite.getAnnotation();
final AnnotationProxyBuilder<Annotation> apb = new AnnotationProxyBuilder<Annotation>(originalAnnot);
final Annotation newAnnot = apb.createAnnotation();
public boolean processAnnotations(Meta prop, Class<?> owner, AnnotatedElement element, AccessStrategy access,
AppendValidation appender) throws IllegalAccessException, InvocationTargetException {
AccessStrategy access, AppendValidation appender, boolean reflection) throws IllegalAccessException,
InvocationTargetException {
final Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
} else if (ArrayUtils.contains(strategies, access)) {
return false;
} else {
strategies = ArrayUtils.add(strategies, access);
prop.putFeature(Features.Property.REF_CASCADE, strategies);
final Class<A> annotationType = (Class<A>) annotation.annotationType();
Class<? extends ConstraintValidator<A, ?>>[] validatorClasses =
factoryContext.getFactory().getConstraintsCache().getConstraintValidators(annotationType);
final Class<? extends ConstraintValidator<A, ?>>[] constraintClasses = select(rawConstraintClasses, access);
new AnnotationConstraintBuilder<A>(factoryContext.getConstraintValidatorFactory(), constraintClasses,
annotation, owner, access, null);
final MetaBean parentMetaBean = prop.getParentMetaBean();
final Class<? extends ConstraintValidator<A, ?>>[] rawConstraintClasses, final AccessStrategy access) {
final Collection<Class<? extends ConstraintValidator<A, ?>>> selected =
new ArrayList<Class<? extends ConstraintValidator<A, ?>>>();
if (isReturn && ValidationTarget.ANNOTATED_ELEMENT == validationTarget) {
} else if (isParam && ValidationTarget.PARAMETERS == validationTarget) {
}
@SuppressWarnings("unchecked")
final Class<? extends ConstraintValidator<A, ?>>[] result = selected.toArray(new Class[selected.size()]);
return result;
final List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>();
final String[] factoryClassNames =
StringUtils.split(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.METABEAN_FACTORY_CLASSNAMES));
final Class<? extends MetaBeanFactory> factoryClass = (Class<? extends MetaBeanFactory>) loadClass(clsName);
final boolean enableMetaBeansXml =
Boolean.parseBoolean(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML));
final String validatorFactoryClassname =
return (name.startsWith("get") || name.startsWith("is")) && method.getParameterTypes().length == 0;
import javax.enterprise.inject.spi.CDI;
final BeanManager beanManager = CDI.current().getBeanManager();
public static BeanManager getBeanManager() {
return CDI.current().getBeanManager();
useCdi = BValExtension.getBeanManager() != null;
return instance.getInstance();
try {
final BeanDescriptor classConstraints = validator.getConstraintsForClass(javaClass);
if (annotatedType.isAnnotationPresent(ValidateOnExecution.class)
|| hasValidationAnnotation(annotatedType.getMethods())
|| hasValidationAnnotation(annotatedType.getConstructors())
|| (validBean && classConstraints != null && classConstraints.isBeanConstrained())
|| (validConstructors && classConstraints != null && !classConstraints.getConstrainedConstructors().isEmpty())
|| (validBusinessMethods && classConstraints != null && !classConstraints.getConstrainedMethods(MethodType.NON_GETTER).isEmpty())
|| (validGetterMethods && classConstraints != null && !classConstraints.getConstrainedMethods(MethodType.GETTER).isEmpty())) {
final BValAnnotatedType<A> bValAnnotatedType = new BValAnnotatedType<A>(annotatedType);
pat.setAnnotatedType(bValAnnotatedType);
}
} catch (final NoClassDefFoundError ncdfe) {
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final boolean mustUnset = Reflection.setAccessible(field, true);
} finally {
if (mustUnset) {
Reflection.setAccessible(field, false);
}
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final boolean mustUnset = Reflection.setAccessible(method, true);
} finally {
if (mustUnset) {
Reflection.setAccessible(method, false);
}
import org.apache.bval.util.reflection.Reflection;
private static Object readField(Field field, Object bean) throws IllegalAccessException {
final boolean mustUnset = Reflection.setAccessible(field, true);
try {
return field.get(bean);
} finally {
if (mustUnset) {
Reflection.setAccessible(field, false);
}
}
}
return readField(rememberField, bean);
return readField(rememberField, bean);
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Member;
import org.apache.commons.weaver.privilizer.Privilizing;
final Method valueMethod;
return null;
final boolean mustUnset = setAccessible(valueMethod, true);
try {
} finally {
if (mustUnset) {
setAccessible(valueMethod, false);
}
return cl == null ? clazz.getClassLoader() : cl;
return clazz.getDeclaredField(fieldName);
return clazz.getDeclaredFields();
public static <T> Constructor<T> getDeclaredConstructor(final Class<T> clazz, final Class<?>... parameters) {
public static Method getPublicMethod(final Class<?> clazz, final String methodName, Class<?>... parameterTypes) {
return clazz.getMethod(methodName, parameterTypes);
public static boolean setAccessible(final AccessibleObject o, boolean accessible) {
if (o == null || o.isAccessible() == accessible) {
return false;
}
final Member m = (Member) o;
if (Modifier.isPublic(m.getModifiers())) {
if (!isPackageAccess(m.getDeclaringClass().getModifiers())) {
return false;
}
}
o.setAccessible(accessible);
return true;
}
private static boolean isPackageAccess(final int modifiers) {
return (modifiers & (Modifier.PRIVATE | Modifier.PROTECTED | Modifier.PUBLIC)) == 0;
}
final boolean mustUnset = Reflection.setAccessible(m, true);
} catch (Exception e) {
} finally {
if (mustUnset) {
Reflection.setAccessible(m, false);
}
import org.apache.commons.lang3.ArrayUtils;
Class<?>[] groupSequence = createGroupSequence(classType.getGroupSequence(), defaultPackage);
private <A extends Annotation> Class<?> getAnnotationParameterType(final Class<A> annotationClass, final String name) {
List<Object> values = new ArrayList<Object>();
for (Serializable s : elementType.getContent()) {
values.add(getSingleValue(s, returnType.getComponentType(), defaultPackage));
}
return values.toArray((Object[]) Array.newInstance(returnType.getComponentType(), values.size()));
private Object getSingleValue(Serializable serializable, Class<?> returnType, String defaultPackage) {
return convertToResultType(returnType, value, defaultPackage);
if (serializable instanceof JAXBElement<?>) {
JAXBElement<?> elem = (JAXBElement<?>) serializable;
if (String.class.equals(elem.getDeclaredType())) {
String value = (String) elem.getValue();
return convertToResultType(returnType, value, defaultPackage);
}
if (AnnotationType.class.equals(elem.getDeclaredType())) {
AnnotationType annotationType = (AnnotationType) elem.getValue();
try {
Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) returnType;
return createAnnotation(annotationType, annotationClass, defaultPackage);
} catch (ClassCastException e) {
throw new ValidationException("Unexpected parameter value");
}
}
}
throw new ValidationException("Unexpected parameter value");
private Object convertToResultType(Class<?> returnType, String value, String defaultPackage) {
}
}
if (Short.class.equals(returnType) || short.class.equals(returnType)) {
}
if (Integer.class.equals(returnType) || int.class.equals(returnType)) {
}
if (Long.class.equals(returnType) || long.class.equals(returnType)) {
}
if (Float.class.equals(returnType) || float.class.equals(returnType)) {
}
if (Double.class.equals(returnType) || double.class.equals(returnType)) {
}
if (Boolean.class.equals(returnType) || boolean.class.equals(returnType)) {
}
if (Character.class.equals(returnType) || char.class.equals(returnType)) {
if (converter == null) {
return converter.convert(returnType, value);
return ArrayUtils.EMPTY_CLASS_ARRAY;
private Class<? extends Payload>[] getPayload(PayloadType payloadType, String defaultPackage) {
payloadList.add((Class<? extends Payload>) payload);
private Class<?>[] createGroupSequence(GroupSequenceType groupSequenceType, String defaultPackage) {
return null;
private <A> void processMethodLevel(final List<MethodType> methods, final Class<A> beanClass,
final String defaultPackage, final boolean parentIgnoreAnn, final Collection<String> getters) {
}
methodNames.add(methodName);
if (methodType.getIgnoreAnnotations() == null) {
} else {
ignoreAnn = methodType.getIgnoreAnnotations();
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, method,
AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, method,
new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, method,
AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, method,
new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(method,
returnValue.getIgnoreAnnotations() == null ? ignoreAnn : returnValue.getIgnoreAnnotations());
factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(method,
crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
private <A> void processConstructorLevel(final List<ConstructorType> constructors, final Class<A> beanClass,
final String defaultPackage, final boolean parentIgnore) {
final Constructor<?> constructor =
Reflection.getDeclaredConstructor(beanClass, toTypes(constructorType.getParameter(), defaultPackage));
final boolean ignoreMethodAnnotation =
constructorType.getIgnoreAnnotations() == null ? parentIgnore : constructorType.getIgnoreAnnotations();
if (constructorType.getIgnoreAnnotations() == null) {
} else {
ignoreAnn = constructorType.getIgnoreAnnotations();
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, constructor,
AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, constructor,
new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
boolean ignoreParametersAnnotation =
p.getIgnoreAnnotations() == null ? ignoreMethodAnnotation : p.getIgnoreAnnotations();
factory.getAnnotationIgnores().setIgnoreAnnotationsOnParameter(constructor, i,
p.getIgnoreAnnotations() != null ? p.getIgnoreAnnotations() : ignoreAnn);
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, constructor,
AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, constructor,
new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(constructor,
returnValue.getIgnoreAnnotations() != null ? returnValue.getIgnoreAnnotations() : ignoreAnn);
factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(constructor,
crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
beanClass.getName());
}
fieldNames.add(fieldName);
getterNames.add(methodName);
if (validator == null) {
Class<? extends ConstraintValidator<?, ?>>[] validatedBy = annotationType.getAnnotation(Constraint.class).validatedBy();
} else {
Collections.addAll(classes, validator);
private static Method getGetter(Class<?> clazz, String propertyName) {
setAccessible(constructor);
import java.lang.reflect.AccessibleObject;
import org.apache.commons.weaver.privilizer.Privileged;
protected boolean setAccessible(AccessibleObject accessibleObject) {
if (accessibleObject.isAccessible()) {
return false;
}
doSetAccessible(accessibleObject);
return true;
}
@Privileged
private void doSetAccessible(AccessibleObject accessibleObject) {
accessibleObject.setAccessible(true);
}
setAccessible(field);
setAccessible(method);
return rememberField.get(bean);
return rememberField.get(bean);
if (!field.isAccessible()) {
field.setAccessible(true);
}
private static void setAccessibility(final Field field) {
if (!Modifier.isPublic(field.getModifiers())
|| (Modifier.isPublic(field.getModifiers()) && Modifier.isAbstract(field.getModifiers()))) {
field.setAccessible(true);
}
}
Method valueMethod;
valueMethod = null;
if (null != valueMethod) {
if (!valueMethod.isAccessible()) {
valueMethod.setAccessible(true);
return valueMethod.invoke(annotation);
return null;
if (cl != null) {
return cl;
}
return clazz.getClassLoader();
final Field f;
f = clazz.getDeclaredField(fieldName);
setAccessibility(f);
return f;
final Field[] fields = clazz.getDeclaredFields();
if (fields.length > 0) {
for (final Field f : fields) {
if (!f.isAccessible()) {
f.setAccessible(true);
}
}
}
return fields;
public static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>... parameters) {
public static Method getPublicMethod(final Class<?> clazz, final String methodName) {
return clazz.getMethod(methodName);
import java.lang.reflect.InvocationTargetException;
if (!m.isAccessible()) {
m.setAccessible(true);
}
} catch (IllegalArgumentException e) {
} catch (IllegalAccessException e) {
} catch (InvocationTargetException e) {
throw new ValidationException(
Class<?>[] groupSequence =
createGroupSequence(classType.getGroupSequence(), defaultPackage);
private <A extends Annotation> Class<?> getAnnotationParameterType(
final Class<A> annotationClass, final String name) {
} else {
List<Object> values = new ArrayList<Object>();
for (Serializable s : elementType.getContent()) {
values.add(getSingleValue(s, returnType.getComponentType(), defaultPackage));
}
return values.toArray(
(Object[]) Array.newInstance(returnType.getComponentType(), values.size()));
private Object getSingleValue(Serializable serializable, Class<?> returnType,
String defaultPackage) {
Object returnValue;
returnValue = convertToResultType(returnType, value, defaultPackage);
} else if (serializable instanceof JAXBElement<?> &&
((JAXBElement<?>) serializable).getDeclaredType()
.equals(String.class)) {
String value = (String) elem.getValue();
returnValue = convertToResultType(returnType, value, defaultPackage);
} else if (serializable instanceof JAXBElement<?> &&
((JAXBElement<?>) serializable).getDeclaredType()
.equals(AnnotationType.class)) {
JAXBElement<?> elem = (JAXBElement<?>) serializable;
AnnotationType annotationType = (AnnotationType) elem.getValue();
try {
Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) returnType;
returnValue =
createAnnotation(annotationType, annotationClass, defaultPackage);
} catch (ClassCastException e) {
throw new ValidationException("Unexpected parameter value");
} else {
throw new ValidationException("Unexpected parameter value");
return returnValue;
private Object convertToResultType(Class<?> returnType, String value,
String defaultPackage) {
} else if (Short.class.equals(returnType) || short.class.equals(returnType)) {
} else if (Integer.class.equals(returnType) || int.class.equals(returnType)) {
} else if (Long.class.equals(returnType) || long.class.equals(returnType)) {
} else if (Float.class.equals(returnType) || float.class.equals(returnType)) {
} else if (Double.class.equals(returnType) || double.class.equals(returnType)) {
} else if (Boolean.class.equals(returnType) || boolean.class.equals(returnType)) {
} else if (Character.class.equals(returnType) || char.class.equals(returnType)) {
if (converter != null) {
return converter.convert(returnType, value);
} else {
return new Class[]{};
private Class<? extends Payload>[] getPayload(PayloadType payloadType,
String defaultPackage) {
} else {
payloadList.add((Class<? extends Payload>) payload);
private Class<?>[] createGroupSequence(GroupSequenceType groupSequenceType,
String defaultPackage) {
} else {
return null;
private <A> void processMethodLevel(final List<MethodType> methods, final Class<A> beanClass, final String defaultPackage, final boolean parentIgnoreAnn, final Collection<String> getters) {
} else {
methodNames.add(methodName);
}
if (methodType.getIgnoreAnnotations() != null) {
} else {
ignoreAnn = parentIgnoreAnn;
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(method, returnValue.getIgnoreAnnotations() == null ? ignoreAnn : returnValue.getIgnoreAnnotations());
factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(method, crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
private <A> void processConstructorLevel(final List<ConstructorType> constructors, final Class<A> beanClass, final String defaultPackage, final boolean parentIgnore) {
final Constructor<?> constructor = Reflection.getDeclaredConstructor(beanClass, toTypes(constructorType.getParameter(), defaultPackage));
final boolean ignoreMethodAnnotation = constructorType.getIgnoreAnnotations() == null ? parentIgnore : constructorType.getIgnoreAnnotations();
if (constructorType.getIgnoreAnnotations() != null) {
} else {
ignoreAnn = parentIgnore;
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
boolean ignoreParametersAnnotation = p.getIgnoreAnnotations() == null ? ignoreMethodAnnotation : p.getIgnoreAnnotations();
factory.getAnnotationIgnores().setIgnoreAnnotationsOnParameter(constructor, i, p.getIgnoreAnnotations() != null ? p.getIgnoreAnnotations() : ignoreAnn);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(constructor, returnValue.getIgnoreAnnotations() != null ? returnValue.getIgnoreAnnotations() : ignoreAnn);
factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(constructor, crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
throw new ValidationException(fieldName
" is defined more than once in mapping xml for bean "
beanClass.getName());
} else {
fieldNames.add(fieldName);
}
throw new ValidationException(
} else {
getterNames.add(methodName);
if (validator != null) {
classes
.addAll(Arrays.asList(validator));
Class<? extends ConstraintValidator<?, ?>>[] validatedBy = annotationType
.getAnnotation(Constraint.class)
.validatedBy();
classes.addAll(Arrays.asList(validatedBy));
private static Method getGetter(Class<?> clazz,String propertyName) {
import org.apache.commons.lang3.ArrayUtils;
Class<?>[] groupSequence = createGroupSequence(classType.getGroupSequence(), defaultPackage);
private <A extends Annotation> Class<?> getAnnotationParameterType(final Class<A> annotationClass, final String name) {
List<Object> values = new ArrayList<Object>();
for (Serializable s : elementType.getContent()) {
values.add(getSingleValue(s, returnType.getComponentType(), defaultPackage));
}
return values.toArray((Object[]) Array.newInstance(returnType.getComponentType(), values.size()));
private Object getSingleValue(Serializable serializable, Class<?> returnType, String defaultPackage) {
return convertToResultType(returnType, value, defaultPackage);
if (serializable instanceof JAXBElement<?>) {
JAXBElement<?> elem = (JAXBElement<?>) serializable;
if (String.class.equals(elem.getDeclaredType())) {
String value = (String) elem.getValue();
return convertToResultType(returnType, value, defaultPackage);
}
if (AnnotationType.class.equals(elem.getDeclaredType())) {
AnnotationType annotationType = (AnnotationType) elem.getValue();
try {
Class<? extends Annotation> annotationClass = (Class<? extends Annotation>) returnType;
return createAnnotation(annotationType, annotationClass, defaultPackage);
} catch (ClassCastException e) {
throw new ValidationException("Unexpected parameter value");
}
}
}
throw new ValidationException("Unexpected parameter value");
private Object convertToResultType(Class<?> returnType, String value, String defaultPackage) {
}
}
if (Short.class.equals(returnType) || short.class.equals(returnType)) {
}
if (Integer.class.equals(returnType) || int.class.equals(returnType)) {
}
if (Long.class.equals(returnType) || long.class.equals(returnType)) {
}
if (Float.class.equals(returnType) || float.class.equals(returnType)) {
}
if (Double.class.equals(returnType) || double.class.equals(returnType)) {
}
if (Boolean.class.equals(returnType) || boolean.class.equals(returnType)) {
}
if (Character.class.equals(returnType) || char.class.equals(returnType)) {
if (converter == null) {
return converter.convert(returnType, value);
return ArrayUtils.EMPTY_CLASS_ARRAY;
private Class<? extends Payload>[] getPayload(PayloadType payloadType, String defaultPackage) {
payloadList.add((Class<? extends Payload>) payload);
private Class<?>[] createGroupSequence(GroupSequenceType groupSequenceType, String defaultPackage) {
return null;
private <A> void processMethodLevel(final List<MethodType> methods, final Class<A> beanClass,
final String defaultPackage, final boolean parentIgnoreAnn, final Collection<String> getters) {
}
methodNames.add(methodName);
if (methodType.getIgnoreAnnotations() == null) {
} else {
ignoreAnn = methodType.getIgnoreAnnotations();
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, method,
AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, method,
new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, method,
AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, method,
new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(method,
returnValue.getIgnoreAnnotations() == null ? ignoreAnn : returnValue.getIgnoreAnnotations());
factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(method,
crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
private <A> void processConstructorLevel(final List<ConstructorType> constructors, final Class<A> beanClass,
final String defaultPackage, final boolean parentIgnore) {
final Constructor<?> constructor =
Reflection.getDeclaredConstructor(beanClass, toTypes(constructorType.getParameter(), defaultPackage));
final boolean ignoreMethodAnnotation =
constructorType.getIgnoreAnnotations() == null ? parentIgnore : constructorType.getIgnoreAnnotations();
if (constructorType.getIgnoreAnnotations() == null) {
} else {
ignoreAnn = constructorType.getIgnoreAnnotations();
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, constructor,
AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, constructor,
new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
boolean ignoreParametersAnnotation =
p.getIgnoreAnnotations() == null ? ignoreMethodAnnotation : p.getIgnoreAnnotations();
factory.getAnnotationIgnores().setIgnoreAnnotationsOnParameter(constructor, i,
p.getIgnoreAnnotations() != null ? p.getIgnoreAnnotations() : ignoreAnn);
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, constructor,
AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint =
new MetaConstraint<A, Annotation>(beanClass, constructor,
new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
factory.getAnnotationIgnores().setIgnoreAnnotationOnReturn(constructor,
returnValue.getIgnoreAnnotations() != null ? returnValue.getIgnoreAnnotations() : ignoreAnn);
factory.getAnnotationIgnores().setIgnoreAnnotationOnCrossParameter(constructor,
crossParameter.getIgnoreAnnotations() != null ? crossParameter.getIgnoreAnnotations() : ignoreAnn);
beanClass.getName());
}
fieldNames.add(fieldName);
getterNames.add(methodName);
if (validator == null) {
Class<? extends ConstraintValidator<?, ?>>[] validatedBy = annotationType.getAnnotation(Constraint.class).validatedBy();
} else {
Collections.addAll(classes, validator);
private static Method getGetter(Class<?> clazz, String propertyName) {
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final boolean mustUnset = Reflection.setAccessible(field, true);
} finally {
if (mustUnset) {
Reflection.setAccessible(field, false);
}
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final boolean mustUnset = Reflection.setAccessible(method, true);
} finally {
if (mustUnset) {
Reflection.setAccessible(method, false);
}
import org.apache.bval.util.reflection.Reflection;
private static Object readField(Field field, Object bean) throws IllegalAccessException {
final boolean mustUnset = Reflection.setAccessible(field, true);
try {
return field.get(bean);
} finally {
if (mustUnset) {
Reflection.setAccessible(field, false);
}
}
}
return readField(rememberField, bean);
return readField(rememberField, bean);
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Member;
import org.apache.commons.weaver.privilizer.Privilizing;
final Method valueMethod;
return null;
final boolean mustUnset = setAccessible(valueMethod, true);
try {
} finally {
if (mustUnset) {
setAccessible(valueMethod, false);
}
return cl == null ? clazz.getClassLoader() : cl;
return clazz.getDeclaredField(fieldName);
return clazz.getDeclaredFields();
public static <T> Constructor<T> getDeclaredConstructor(final Class<T> clazz, final Class<?>... parameters) {
public static Method getPublicMethod(final Class<?> clazz, final String methodName, Class<?>... parameterTypes) {
return clazz.getMethod(methodName, parameterTypes);
public static boolean setAccessible(final AccessibleObject o, boolean accessible) {
if (o == null || o.isAccessible() == accessible) {
return false;
}
final Member m = (Member) o;
if (Modifier.isPublic(m.getModifiers())) {
if (!isPackageAccess(m.getDeclaringClass().getModifiers())) {
return false;
}
}
o.setAccessible(accessible);
return true;
}
private static boolean isPackageAccess(final int modifiers) {
return (modifiers & (Modifier.PRIVATE | Modifier.PROTECTED | Modifier.PUBLIC)) == 0;
}
final boolean mustUnset = Reflection.setAccessible(m, true);
} catch (Exception e) {
} finally {
if (mustUnset) {
Reflection.setAccessible(m, false);
}
return getPropertyValue(new PropertyAccess(bean.getClass(), metaProperty.getName()));
return getPropertyValue(access);
public Object getPropertyValue(AccessStrategy access) throws IllegalArgumentException, IllegalStateException {
if (context == null) {
}
return context == null ? null : context.getListener();
if (validate.value().isEmpty()) {
if (parameter == null) {
}
if (coll.isEmpty()) {
}
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
return bean instanceof Class<?> ? finder.findForClass((Class<?>) bean) : finder.findForClass(bean.getClass());
if (beanInfo.getBeanClass() != null && beanInfo.getId().equals(beanInfo.getBeanClass().getName())) {
if (beanInfo.getBeanClass() != null && beanInfo.getId().equals(beanInfo.getBeanClass().getName())) {
if (beanType == null) {
prop.setMetaBean(new DynamicMetaBean(this));
}
} else {
if (error.getReason() == null) {
return;
}
if (error.getOwner() == null) {
return;
}
if (errorsByReason == null) {
return Collections.emptyMap();
}
if (errorsByOwner == null) {
return Collections.emptyMap();
}
if (errorsByReason == null || (errorsByReason.isEmpty() && errorsByOwner.isEmpty())) {
return true;
}
if (!list.isEmpty()) {
return false;
}
if (!list.isEmpty()) {
return false;
}
if (errorsByReason == null)
return false;
if (errorsByOwner == null) {
return false;
}
if (errors == null) {
return false;
}
if (propertyName == null) {
if (!list.isEmpty()) {
return true;
}
List<Error> list = errors.get(propertyName);
return list != null && !list.isEmpty();
@SuppressWarnings("unchecked")
final T faster = (T) features.putIfAbsent(key, value);
return faster == null ? value : faster;
if (validations == null) {
}
if (validation.equals(aValidation)) {
}
public abstract class Meta extends FeaturesCapable {
private static final long serialVersionUID = 1L;
return methods == null ? null : methods.get(method);
return constructors == null ? null : constructors.get(constructor);
if (idx == null) {
return idx;
return i == 0 ? methods.get(o1) - methods.get(o2) : i;
return i == 0 ? constructors.get(o1) - constructors.get(o2) : i;
private static final long serialVersionUID = 1L;
public abstract class MetaInvocable extends MetaAnnotated {
private static final long serialVersionUID = 1L;
private static final long serialVersionUID = 1L;
public class MetaParameter extends MetaAnnotated {
private static final long serialVersionUID = 1L;
@Override
public MetaBean getParentMetaBean() {
return invocable.getParentMetaBean();
public class MetaProperty extends Meta implements Cloneable, Features.Property {
Type targetType = type instanceof DynaType ? ((DynaType) type).getRawType() : type;
Type assigningType = getParentMetaBean() == null ? null : getParentMetaBean().getBeanClass();
if (value == null) {
}
if (!(value instanceof CharSequence)) {
}
if (seq.length() == 0) {
}
return aPattern.matcher(seq).matches();
import org.apache.commons.lang3.StringUtils;
InputStream in = BValVersion.class.getResourceAsStream("/META-INF/org.apache.bval.revision.properties");
if (StringUtils.isBlank(revision)) {
if (strTok != null) {
}
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
if (this == o) {
}
if (o == null || getClass() != o.getClass()) {
}
if (dyn == null) {
} else {
context.setBean(each, dyn.resolveMetaBean(each));
if (dyn == null) {
} else {
context.setBean(each, dyn.resolveMetaBean(each));
if (errorsByReason == null) {
}
if (Modifier.isPublic(m.getModifiers()) && Modifier.isPublic(m.getDeclaringClass().getModifiers())) {
return false;
public static List<Class<?>> fillFullClassHierarchyAsList(List<Class<?>> allClasses, Class<?> clazz) {
final Class<?> loaded = loadClass(parameterNameProvider);
if (loaded != null) {
final Class<? extends ParameterNameProvider> clazz = loaded.asSubclass(ParameterNameProvider.class);
targetConfig.parameterNameProviderClass(clazz);
log.log(Level.INFO, String.format("Using %s as validation provider.", parameterNameProvider));
} else {
}
return value == null || Boolean.FALSE.equals(value);
return value == null || Boolean.TRUE.equals(value);
public class DecimalMaxValidatorForNumber implements ConstraintValidator<DecimalMax, Number> {
if (value instanceof BigDecimal) {
return ((BigDecimal) value).compareTo(maxValue) != 1;
}
if (value instanceof BigInteger) {
return (new BigDecimal((BigInteger) value)).compareTo(maxValue) != 1;
}
return (new BigDecimal(value.doubleValue()).compareTo(maxValue)) != 1;
public class DecimalMaxValidatorForString implements ConstraintValidator<DecimalMax, String> {
public class DecimalMinValidatorForNumber implements ConstraintValidator<DecimalMin, Number> {
if (value instanceof BigDecimal) {
return ((BigDecimal) value).compareTo(minValue) != -1;
}
if (value instanceof BigInteger) {
return (new BigDecimal((BigInteger) value)).compareTo(minValue) != -1;
}
return (new BigDecimal(value.doubleValue()).compareTo(minValue)) != -1;
public class DecimalMinValidatorForString implements ConstraintValidator<DecimalMin, String> {
throw new IllegalArgumentException("The length of the integer part cannot be negative.");
throw new IllegalArgumentException("The length of the fraction part cannot be negative.");
final int intLength = bigDecimal.precision() - bigDecimal.scale();
return false;
throw new IllegalArgumentException("The length of the integer part cannot be negative.");
throw new IllegalArgumentException("The length of the fraction part cannot be negative.");
final BigDecimal bigDecimal = getBigDecimalValue(str);
return false;
return new BigDecimal(str);
if (value instanceof BigDecimal) {
return ((BigDecimal) value).compareTo(BigDecimal.valueOf(max)) != 1;
}
if (value instanceof BigInteger) {
return ((BigInteger) value).compareTo(BigInteger.valueOf(max)) != 1;
}
return value.longValue() <= max;
if (value instanceof BigDecimal) {
return ((BigDecimal) value).compareTo(BigDecimal.valueOf(minValue)) != -1;
}
if (value instanceof BigInteger) {
return ((BigInteger) value).compareTo(BigInteger.valueOf(minValue)) != -1;
}
return value.longValue() >= minValue;
if (value == null) {
return true;
}
try {
final Method isEmptyMethod = value.getClass().getMethod("isEmpty");
if (isEmptyMethod != null) {
return !((Boolean) isEmptyMethod.invoke(value)).booleanValue();
}
} catch (IllegalAccessException iae) {
} catch (NoSuchMethodException nsme) {
} catch (InvocationTargetException ite) {
}
return !value.toString().isEmpty();
return value == null || !value.isEmpty();
final Pattern.Flag flags[] = annotation.flags();
if (min < 0) {
throw new ValidationException("Min cannot be negative");
}
if (max < 0) {
throw new ValidationException("Max cannot be negative");
}
if (max < min) {
throw new ValidationException("Max cannot be less than Min");
}
public class SizeValidatorForArrayOfBoolean extends SizeValidator implements ConstraintValidator<Size, boolean[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfByte extends SizeValidator implements ConstraintValidator<Size, byte[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfChar extends SizeValidator implements ConstraintValidator<Size, char[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfDouble extends SizeValidator implements ConstraintValidator<Size, double[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfFloat extends SizeValidator implements ConstraintValidator<Size, float[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfInt extends SizeValidator implements ConstraintValidator<Size, int[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfLong extends SizeValidator implements ConstraintValidator<Size, long[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfObject extends SizeValidator implements ConstraintValidator<Size, Object[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfShort extends SizeValidator implements ConstraintValidator<Size, short[]> {
final int length = Array.getLength(array);
public class SizeValidatorForCharSequence extends SizeValidator implements ConstraintValidator<Size, CharSequence> {
final int length = s.length();
public class SizeValidatorForCollection extends SizeValidator implements ConstraintValidator<Size, Collection<?>> {
final int length = collection.size();
public class SizeValidatorForMap extends SizeValidator implements ConstraintValidator<Size, Map<?, ?>> {
final int size = map.size();
private static final boolean hasSecurityManager = System.getSecurityManager() != null;
if (!accessible && !hasSecurityManager) {
return false;
}
if (!accessible && System.getSecurityManager() == null) {
import java.util.EnumSet;
public static final Set<String> SKIPPED_PREFIXES;
final Set<String> s = new HashSet<String>();
s.add("java.");
s.add("javax.");
s.add("org.apache.bval.");
s.add("org.apache.openejb.");
SKIPPED_PREFIXES = Collections.unmodifiableSet(s);
globalExecutableTypes = Collections.unmodifiableSet(convertToRuntimeTypes(bootstrap.getDefaultValidatedExecutableTypes()));
validConstructors = validBean || globalExecutableTypes.contains(ExecutableType.CONSTRUCTORS);
if (factory == null) {
factory = config.buildValidatorFactory();
}
final Set<ExecutableType> types = EnumSet.noneOf(ExecutableType.class);
if (ExecutableType.NONE == type) {
continue;
}
if (ExecutableType.ALL == type) {
}
if (ExecutableType.IMPLICIT == type) {
types.add(ExecutableType.CONSTRUCTORS);
types.add(ExecutableType.NON_GETTER_METHODS);
} else {
|| classConstraints != null
&& (validBean && classConstraints.isBeanConstrained()
|| validConstructors && !classConstraints.getConstrainedConstructors().isEmpty()
|| validBusinessMethods && !classConstraints.getConstrainedMethods(MethodType.NON_GETTER).isEmpty()
|| validGetterMethods && !classConstraints.getConstrainedMethods(MethodType.GETTER).isEmpty())
) {
import javax.interceptor.InterceptorBinding;
import java.util.EnumSet;
@Priority(4800)
private Set<ExecutableType> classConfiguration;
@AroundConstruct
final Set<ConstraintViolation<?>> violations =
executableValidator.validateConstructorParameters(constructor, context.getParameters());
final Set<ConstraintViolation<?>> violations =
executableValidator.validateConstructorReturnValue(constructor, context.getTarget());
private boolean isConstructorValidated(final Class<?> targetClass, final Constructor<?> constructor)
throws NoSuchMethodException {
final Set<ExecutableType> config = EnumSet.noneOf(ExecutableType.class);
if (ExecutableType.NONE == type) {
continue;
}
if (ExecutableType.ALL == type) {
config.add(ExecutableType.NON_GETTER_METHODS);
config.add(ExecutableType.GETTER_METHODS);
break;
}
} else {
classConfiguration = EnumSet.noneOf(ExecutableType.class);
if (ExecutableType.NONE == type) {
continue;
}
if (ExecutableType.ALL == type) {
}
if (ExecutableType.IMPLICIT == type) {
classConfiguration.add(ExecutableType.CONSTRUCTORS);
classConfiguration.add(ExecutableType.NON_GETTER_METHODS);
} else {
private static boolean doValidMethod(final Method method, final Set<ExecutableType> config) {
return isGetter(method) ? config.contains(ExecutableType.GETTER_METHODS) : config
.contains(ExecutableType.NON_GETTER_METHODS);
return method.getParameterTypes().length == 0 && !Void.TYPE.equals(method.getReturnType())
&& (name.startsWith("get") || name.startsWith("is") && boolean.class.equals(method.getReturnType()));
}
final Set<Type> t = new HashSet<Type>();
t.add(BValInterceptor.class);
t.add(Object.class);
types = Collections.unmodifiableSet(t);
final Set<Annotation> q = new HashSet<Annotation>();
q.add(DefaultLiteral.INSTANCE);
q.add(AnyLiteral.INSTANCE);
qualifiers = Collections.unmodifiableSet(q);
public class ValidatorBean implements Bean<Validator> , PassivationCapable {
final Set<Type> t = new HashSet<Type>();
t.add(Validator.class);
t.add(Object.class);
types = Collections.unmodifiableSet(t);
final Set<Annotation> q = new HashSet<Annotation>();
q.add(DefaultLiteral.INSTANCE);
q.add(AnyLiteral.INSTANCE);
qualifiers = Collections.unmodifiableSet(q);
final Set<Type> t = new HashSet<Type>();
t.add(ValidatorFactory.class);
t.add(Object.class);
types = Collections.unmodifiableSet(t);
final Set<Annotation> q = new HashSet<Annotation>();
q.add(DefaultLiteral.INSTANCE);
q.add(AnyLiteral.INSTANCE);
qualifiers = Collections.unmodifiableSet(q);
private final Collection<BValExtension.Releasable<?>> releasables = new CopyOnWriteArrayList<BValExtension.Releasable<?>>();
useCdi = Boolean.valueOf(BValExtension.getBeanManager() != null);
useCdi = Boolean.FALSE;
useCdi = Boolean.FALSE;
if (useCdi.booleanValue()) {
import org.apache.commons.lang3.Validate;
private static final AnnotatedTypeFilter DEFAULT_ANNOTATED_TYPE_FILTER = new AnnotatedTypeFilter() {
@Override
public boolean accept(AnnotatedType<?> annotatedType) {
if (annotatedType.getJavaClass().getName().startsWith("org.apache.bval.")) {
return false;
}
return true;
}
};
private static AnnotatedTypeFilter annotatedTypeFilter = DEFAULT_ANNOTATED_TYPE_FILTER;
public static void setAnnotatedTypeFilter(AnnotatedTypeFilter annotatedTypeFilter) {
BValExtension.annotatedTypeFilter = Validate.notNull(annotatedTypeFilter);
if (!annotatedTypeFilter.accept(annotatedType)) {
final Class<A> javaClass = annotatedType.getJavaClass();
final int modifiers = javaClass.getModifiers();
public interface AnnotatedTypeFilter {
boolean accept(AnnotatedType<?> annotatedType);
}
changed = processAnnotation(annotation, prop, owner, access, appender, true) || changed;
if (ArrayUtils.contains(strategies, access)) {
return false;
}
return new ClassValidator(this);
boolean isTreatMapsLikeBeans() {
return Boolean.parseBoolean(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.TREAT_MAPS_LIKE_BEANS));
}
public interface ApacheValidatorConfiguration extends Configuration<ApacheValidatorConfiguration> {
@SuppressWarnings("unchecked")
final T result = (T) this;
return result;
final Set<Class<?>> inheritedGroups = builder.getConstraintValidation().getGroups();
final Set<Class<? extends Payload>> inheritedPayload = builder.getConstraintValidation().getPayload();
final T originalAnnot = validation.getAnnotation();
final AnnotationProxyBuilder<T> apb = new AnnotationProxyBuilder<T>(originalAnnot);
final T newAnnot = apb.createAnnotation();
if (m == null) {
if (isAccessor != null && boolean.class.equals(isAccessor.getReturnType())) {
m = isAccessor;
}
}
final MetaProperty prop = metaBean.getProperty(propertyName);
if (prop == null) {
}
final boolean getter =
d.getParameterDescriptors().isEmpty()
&& (d.getName().startsWith("get") || (d.getName().startsWith("is") && boolean.class.equals(d
.getReturnValueDescriptor().getElementClass())));
if (constraintDescriptors.isEmpty()) {
if (!getConstraintDescriptors(mprop.getValidations()).isEmpty()) {
} else {
hasAnyContraints = true;
if (Valid.class.isInstance(anno)) {
} else {
processAnnotations(null, consDesc, cons.getDeclaringClass(), anno);
if (Valid.class.isInstance(anno)) {
} else {
processAnnotations(null, consDesc, cons.getDeclaringClass(), anno);
if (consDesc.getGroupConversions().isEmpty() || consDesc.isCascaded()) {
ensureNotNullDescriptors(cons.getDeclaringClass(), consDesc);
} else {
if (consDesc.getReturnValueDescriptor() == null) {
} else {
returnValueDescriptor.getMutableConstraintDescriptors().addAll(list);
if (consDesc.getCrossParameterDescriptor() == null) {
} else {
CrossParameterDescriptorImpl.class.cast(consDesc.getCrossParameterDescriptor()).getMutableConstraintDescriptors().addAll(list);
final boolean propertyAccessor =
method.getParameterTypes().length == 0
&& (method.getName().startsWith("get") && !Void.TYPE.equals(method.getReturnType()) || method
.getName().startsWith("is") && Boolean.TYPE.equals(method.getReturnType()));
} else if (parents.size() == 1) {
if (parentDesc == null) {
ensureMethodDoesntDefineParameterConstraint(methodDesc);
} else {
if (propertyAccessor) {
if (annotationIgnores.isIgnoreAnnotationOnParameter(method, idx)) {
} else {
final ParameterAccess access = new ParameterAccess(method.getParameterTypes()[idx], idx);
processAnnotations(methodDesc, paramAnnos, access, idx, names.get(idx));
if (from != null) {
if (paramDesc.isCascaded()) {
paramDesc.addGroupConversion(new GroupConversionDescriptorImpl(from[i], to[i]));
}
} else {
throw new ConstraintDeclarationException("Group conversion is only relevant for @Valid cases");
private <A extends Annotation> void processConstraint(final A annotation,
final InvocableElementDescriptor desc, final AccessStrategy access, final AppendValidation validations)
throws IllegalAccessException, InvocationTargetException {
final Constraint vcAnno = annotation.annotationType().getAnnotation(Constraint.class);
if (vcAnno == null) {
} else {
annotationProcessor.processAnnotation(annotation, null, ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations, true);
<T extends Object> Set<javax.validation.ConstraintViolation<T>> validateProperty(T object, String propertyName,
boolean cascade, Class<?>... groups);
<T extends Object> Set<javax.validation.ConstraintViolation<T>> validateValue(Class<T> beanType,
String propertyName, Object value, boolean cascade, Class<?>... groups);
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
if (object == null) {
}
final Set<ConstraintViolation<T>> result =
@SuppressWarnings("unchecked")
final T result = (T) this;
return result;
if (!(type.isInterface() || Modifier.isAbstract(type.getModifiers()))) {
return newInstance(type);
}
try {
if (type.isAssignableFrom(cls)) {
@SuppressWarnings("unchecked")
final Class<? extends T> implClass = (Class<? extends T>) cls;
return newInstance(implClass);
}
} catch (ClassNotFoundException e) {
}
final Constructor<T> cons = Reflection.getDeclaredConstructor(cls, ApacheFactoryContext.class);
if (cons == null) {
}
final boolean mustUnset = Reflection.setAccessible(cons, true);
} finally {
if (mustUnset) {
Reflection.setAccessible(cons, false);
}
if (feature == null) {
} else {
mappedGroup = PropertyDescriptorImpl.class.cast(feature).mapGroup(group);
if (group == mappedGroup) {
validateCascadedBean(context, prop, null);
} else {
final ConstraintValidation<?> constraintValidation = ConstraintValidation.class.cast(validation);
final AccessStrategy[] access = prop.getFeature(Features.Property.REF_CASCADE);
ValidationHelper.validateContext(context, new JsrValidationCallback(context), factoryContext.isTreatMapsLikeBeans());
}, factoryContext.isTreatMapsLikeBeans());
context.getRootMetaBean().getBeanClass(), beanPath, access.getElementType())) {
}
final List<Group> groupSeq = context.getMetaBean().getFeature(JsrFeatures.Bean.GROUP_SEQUENCE);
return null;
}
if (ex instanceof ValidationException) {
}
String objectId;
if (object == null) {
objectId = "<null>";
objectId = object.toString();
final List<Group> defaultGroups = expandDefaultGroup(context);
if (defaultGroups == null) {
helper.run();
} else {
final Group currentGroup = context.getCurrentGroup();
if (Collections.singletonList(Group.DEFAULT).equals(computedGroup.getGroups()) && metaBean.getFeature(JsrFeatures.Bean.GROUP_SEQUENCE) != null) {
@SuppressWarnings("unchecked")
final List<? extends Group> sequenceGroups = List.class.cast(metaBean.getFeature(JsrFeatures.Bean.GROUP_SEQUENCE));
sequence.getGroups().addAll(sequenceGroups);
if (propertyName == null || propertyName.trim().isEmpty()) {
if (parameterValues.length == 0) {
} else {
checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()), ConstraintTarget.IMPLICIT);
checkValidationAppliesTo(constructorDescriptor.getParameterDescriptors(), ConstraintTarget.IMPLICIT);
@SuppressWarnings("unchecked")
final GroupValidationContext<ConstraintValidationListener<?>> parametersContext =
createInvocableContext(constructorDescriptor.getMetaBean(), rootBean,
Class.class.cast(invocable.getDeclaringClass()), gps);
@SuppressWarnings("unchecked")
final GroupValidationContext<Object> crossParameterContext =
createContext(constructorDescriptor.getMetaBean(), rootBean,
Class.class.cast(invocable.getDeclaringClass()), gps);
if (rootBean == null) {
final Method m = Method.class.cast(invocable);
parametersContext.setMethod(m);
crossParameterContext.setMethod(m);
ValidationHelper.validateContext(parametersContext, new JsrValidationCallback(parametersContext), factoryContext.isTreatMapsLikeBeans());
ValidationHelper.validateContext(parametersContext, new JsrValidationCallback(parametersContext), factoryContext.isTreatMapsLikeBeans());
ValidationHelper.validateContext(parametersContext, new JsrValidationCallback(parametersContext), factoryContext.isTreatMapsLikeBeans());
ValidationHelper.validateContext(parametersContext, new JsrValidationCallback(parametersContext), factoryContext.isTreatMapsLikeBeans());
ValidationHelper.validateContext(crossParameterContext, new JsrValidationCallback(crossParameterContext), factoryContext.isTreatMapsLikeBeans());
ValidationHelper.validateContext(crossParameterContext, new JsrValidationCallback(crossParameterContext), factoryContext.isTreatMapsLikeBeans());
@SuppressWarnings("unchecked")
final Set<ConstraintViolation<T>> parameterViolations = Set.class.cast(parametersContext.getListener().getConstraintViolations());
violations.addAll(parameterViolations);
@SuppressWarnings("unchecked")
final Set<ConstraintViolation<T>> crossParameterViolations = Set.class.cast(crossParameterContext.getListener().getConstraintViolations());
violations.addAll(crossParameterViolations);
@SuppressWarnings("unchecked")
final GroupValidationContext<T> context =
createInvocableContext(methodDescriptor.getMetaBean(), createdObject,
Class.class.cast(Proxies.classFor(clazz)), gps);
ValidationHelper.validateContext(context, new JsrValidationCallback(context), factoryContext.isTreatMapsLikeBeans());
ValidationHelper.validateContext(context, new JsrValidationCallback(context), factoryContext.isTreatMapsLikeBeans());
return validateInvocationParameters(method, parameterValues, methodDescriptor, groups,
new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())), object);
final MethodDescriptorImpl methodDescriptor = findMethodDescriptor(object, method);
@SuppressWarnings("unchecked")
final Set<ConstraintViolation<T>> result =
Set.class.cast(validaReturnedValue(
new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())), returnValue,
object.getClass(), methodDescriptor, groups, object));
return result;
final List<Group> groups = new LinkedList<Group>();
final List<List<Group>> sequences = new LinkedList<List<Group>>();
if (providerClass == null) {
return providerResolver.getValidationProviders().get(0);
}
for (ValidationProvider<?> provider : providerResolver.getValidationProviders()) {
if (providerClass.isAssignableFrom(provider.getClass())) {
return provider;
@Privilizing(@CallTo(Reflection.class))
if (TypeUtils.isInstance(result, getType())) {
return result;
throw new IllegalStateException(String.format("Invalid '%s' value: %s", getAttributeName(), result));
final boolean unset = Reflection.setAccessible(method, true);
} finally {
if (unset) {
Reflection.setAccessible(method, false);
}
new HashMap<Class<? extends Annotation>, Class<? extends ConstraintValidator<?, ?>>[]>();
Class<? extends ConstraintValidator<A, ?>>[] definitionClasses) {
Class<A> annotationClass) {
import java.util.List;
import org.apache.commons.lang3.StringUtils;
private static final String DEFAULT_CONSTRAINTS = "org/apache/bval/jsr/DefaultConstraints.properties";
private Map<String, Class<? extends ConstraintValidator<?, ?>>[]> defaultConstraints;
final Properties constraintProperties = new Properties();
final InputStream stream = classloader.getResourceAsStream(resource);
if (stream == null) {
log.log(Level.WARNING, String.format("Cannot find %s", resource));
} else {
final Map<String, Class<? extends ConstraintValidator<?, ?>>[]> loadedConstraints =
new HashMap<String, Class<? extends ConstraintValidator<?, ?>>[]>();
final List<Class<?>> classes = new LinkedList<Class<?>>();
for (String className : StringUtils.split((String) entry.getValue(), ',')) {
classes.add(Reflection.getClass(classloader, className.trim()));
log.log(Level.SEVERE, String.format("Cannot find class %s", className), e);
final ClassLoader classloader = Thread.currentThread().getContextClassLoader();
return classloader == null ? getClass().getClassLoader() : classloader;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
if (this == o) {
return true;
}
if (o == null || !getClass().equals(o.getClass())) {
return false;
}
@SuppressWarnings("rawtypes")
return new EqualsBuilder()
.append(reportAsSingleViolation, that.reportAsSingleViolation)
.append(annotation.annotationType(), that.annotation.annotationType())
.append(attributes, that.attributes)
.append(composingConstraints, that.composingConstraints)
.append(constraintValidatorClasses, that.constraintValidatorClasses)
.append(groups, that.groups)
.append(payload, that.payload)
.append(template, that.template)
.append(validationAppliesTo, that.validationAppliesTo)
.build();
private int computeHashCode() {
return new HashCodeBuilder(1, 31)
.append(annotation.annotationType())
.append(groups)
.append(payload)
.append(constraintValidatorClasses)
.append(attributes)
.append(composingConstraints)
.append(reportAsSingleViolation)
.append(validationAppliesTo)
.append(template)
.build();
final Set<ConstraintValidation<?>> matchingDescriptors =
final Groups groupChain = new GroupsComputer().computeGroups(groups);
for (Group defaultGroupMember : metaBean.<List<Group>>getFeature(JsrFeatures.Bean.GROUP_SEQUENCE)) {
if (scope == Scope.LOCAL_ELEMENT) {
if (!it.next().getOwner().equals(metaBean.getBeanClass())) {
final Set<ConstraintValidation<?>> matchingDescriptors =
{
}
final boolean isOwner = descriptor.getOwner().equals(metaBean.getBeanClass());
case LOCAL_ELEMENT:
if (isOwner) {
return true;
}
break;
case HIERARCHY:
if (!isOwner) {
return true;
}
break;
return Collections.<ConstraintDescriptor<?>> unmodifiableSet(constraintDescriptors);
import org.apache.commons.lang3.StringUtils;
if (context.getCurrentOwner() != null && !this.owner.equals(context.getCurrentOwner())) {
final ConstraintValidationListener<?> listener = context.getListener();
for (Iterator<ConstraintValidation<?>> composed = getComposingValidations().iterator(); !failed
&& composed.hasNext();) {
final ConstraintValidatorContextImpl jsrContext = new ConstraintValidatorContextImpl(context, this);
private <A extends Annotation> ConstraintValidator<A, ? super T> getConstraintValidator(A annotation,
if (ArrayUtils.isNotEmpty(constraintClasses)) {
final Type type = determineTargetedType(owner, access);
if ((type.equals(Object.class) || type.equals(Object[].class)) && validatorTypes.containsKey(Object.class)
&& validatorTypes.containsKey(Object[].class)) {
throw new ConstraintDefinitionException(
"Only a validator for Object or Object[] should be provided for cross-parameter validators");
AccessStrategy access) {
}
if (types.size() > 1) {
throw new UnexpectedTypeException(String.format(
"Ambiguous validators for type %s. See: @%s at %s. Validators are: %s", stringForType(targetType), anno
.annotationType().getSimpleName(), stringForLocation(owner, access), StringUtils.join(types, ", ")));
return clazz.toString();
return access == null ? owner.getName() : access.toString();
if (TypeUtils.isAssignable(type, validatorType) && !suitableTypes.contains(validatorType)) {
boolean removed = false;
final Type nextType = assignableTypes.get(i);
final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validatorsTypes =
new HashMap<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>>();
Type validatedType =
TypeUtils.getTypeArguments(validatorType, ConstraintValidator.class).get(
ConstraintValidator.class.getTypeParameters()[1]);
final Type componentType = TypeUtils.getArrayComponentType(validatedType);
if (access == null) {
}
final Type type = access.getJavaType();
if (type == null) {
}
return type instanceof Class<?> ? ClassUtils.primitiveToWrapper((Class<?>) type) : type;
context.getRootMetaBean().getBeanClass(), beanPath, access.getElementType())) {
}
return composedConstraints == null ? Collections.<ConstraintValidation<?>> emptySet() : composedConstraints;
return validatorClasses == null ? Collections.<Class<? extends ConstraintValidator<T, ?>>> emptyList() : Arrays.asList(validatorClasses);
import javax.validation.Payload;
import javax.validation.Valid;
import javax.validation.ValidationException;
import javax.validation.groups.ConvertGroup;
return !annotatedType.getJavaClass().getName().startsWith("org.apache.bval.");
LOGGER.log(Level.INFO, e.getMessage());
import javax.enterprise.inject.spi.WithAnnotations;
import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import javax.enterprise.inject.spi.AnnotatedConstructor;
import javax.enterprise.inject.spi.AnnotatedMethod;
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.CDI;
import static java.util.Arrays.asList;
public class BValInterceptor implements Serializable {
private transient volatile Map<Method, Boolean> methodConfiguration = new ConcurrentHashMap<Method, Boolean>();
private transient volatile Set<ExecutableType> classConfiguration;
private transient volatile Boolean constructorValidated;
private transient volatile ExecutableValidator executableValidator;
final AnnotatedType<?> annotatedType = CDI.current().getBeanManager().createAnnotatedType(constructor.getDeclaringClass());
AnnotatedConstructor<?> annotatedConstructor = null;
for (final AnnotatedConstructor<?> ac : annotatedType.getConstructors()) {
if (!constructor.equals(ac.getJavaMember())) {
continue;
}
annotatedConstructor = ac;
break;
}
final ValidateOnExecution annotation = annotatedConstructor != null ?
annotatedConstructor.getAnnotation(ValidateOnExecution.class) :
targetClass.getConstructor(constructor.getParameterTypes()).getAnnotation(ValidateOnExecution.class);
return constructorValidated;
if (methodConfiguration == null) {
synchronized (this) {
if (methodConfiguration == null) {
methodConfiguration = new ConcurrentHashMap<Method, Boolean>();
}
}
}
ClassHelper.fillFullClassHierarchyAsList(new LinkedList<Class<?>>(), targetClass);
Collections.reverse(classHierarchy);
ValidateOnExecution validateOnExecutionType = null;
final AnnotatedType<?> annotatedType = CDI.current().getBeanManager().createAnnotatedType(c);
AnnotatedMethod<?> annotatedMethod = null;
for (final AnnotatedMethod<?> m : annotatedType.getMethods()) {
if (!m.getJavaMember().getName().equals(method.getName())
|| !asList(method.getGenericParameterTypes()).equals(asList(m.getJavaMember().getGenericParameterTypes()))) {
continue;
annotatedMethod = m;
break;
}
try {
if (annotatedMethod == null) {
continue;
}
if (validateOnExecutionType == null) {
final ValidateOnExecution vat = annotatedType.getAnnotation(ValidateOnExecution.class);
if (vat != null) {
validateOnExecutionType = vat;
}
}
final ValidateOnExecution mvat = annotatedMethod.getAnnotation(ValidateOnExecution.class);
if (mvat != null) {
validateOnExecution = mvat;
boolean classMeta = false;
if (validateOnExecution == null) {
validateOnExecution = validateOnExecutionType;
classMeta = validateOnExecution != null;
if (!classMeta) {
final AnnotatedType<?> annotatedType = CDI.current().getBeanManager().createAnnotatedType(targetClass);
final ValidateOnExecution annotation = annotatedType.getAnnotation(ValidateOnExecution.class);
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
return getPropertyValue(new PropertyAccess(bean.getClass(), metaProperty.getName()));
return getPropertyValue(access);
public Object getPropertyValue(AccessStrategy access) throws IllegalArgumentException, IllegalStateException {
public void moveDown(String prop) {
}
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Collection;
if (context == null) {
}
return context == null ? null : context.getListener();
if (validate.value().isEmpty()) {
if (parameter == null) {
}
if (coll.isEmpty()) {
}
return bean instanceof Class<?> ? finder.findForClass((Class<?>) bean) : finder.findForClass(bean.getClass());
import static org.apache.bval.model.Features.Property.HIDDEN;
import static org.apache.bval.model.Features.Property.PREFERRED;
import static org.apache.bval.model.Features.Property.READONLY;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.bval.model.MetaBean;
if (beanInfo.getBeanClass() != null && beanInfo.getId().equals(beanInfo.getBeanClass().getName())) {
if (beanInfo.getBeanClass() != null && beanInfo.getId().equals(beanInfo.getBeanClass().getName())) {
import static org.apache.bval.model.Features.Property.REF_BEAN_ID;
import static org.apache.bval.model.Features.Property.REF_BEAN_TYPE;
import static org.apache.bval.model.Features.Property.REF_CASCADE;
public MetaBean findForId(final String beanInfoId) {
if (beanInfo != null) {
}
} catch (final RuntimeException e) {
} catch (final Exception e) {
public MetaBean findForClass(final Class<?> clazz) {
if (clazz == null) {
}
if (beanInfo != null) {
}
} catch (final RuntimeException e) {
} catch (final Exception e) {
for (final MetaProperty prop : beanInfo.getProperties()) {
final String beanRef = prop.getFeature(REF_BEAN_ID);
if (beanType == null) {
prop.setMetaBean(new DynamicMetaBean(this));
}
} else {
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
if (error.getReason() == null) {
return;
}
if (error.getOwner() == null) {
return;
}
if (errorsByReason == null) {
return Collections.emptyMap();
}
if (errorsByOwner == null) {
return Collections.emptyMap();
}
if (errorsByReason == null || (errorsByReason.isEmpty() && errorsByOwner.isEmpty())) {
return true;
}
if (!list.isEmpty()) {
return false;
}
if (!list.isEmpty()) {
return false;
}
if (errorsByReason == null) {
return false;
}
if (errorsByOwner == null) {
return false;
}
if (errors == null) {
return false;
}
if (propertyName == null) {
if (!list.isEmpty()) {
return true;
}
List<Error> list = errors.get(propertyName);
return list != null && !list.isEmpty();
String EXECUTABLES = "executables";
String PROPERTIES = "properties";
import org.apache.commons.lang3.ArrayUtils;
final T value = (T) features.get(key);
if (value == null) {
return defaultValue;
return value;
public <T> void putFeature(final String key, final T value) {
features.put(key, value);
}
public <T> T initFeature(final String key, final T value) {
@SuppressWarnings("unchecked")
final T faster = (T) features.putIfAbsent(key, value);
return faster == null ? value : faster;
if (validations == null) {
}
if (validation.equals(aValidation)) {
}
package org.apache.bval.model;
public abstract class Meta extends FeaturesCapable {
private static final long serialVersionUID = 1L;
protected MetaBean parentMetaBean;
public MetaBean getParentMetaBean() {
return parentMetaBean;
}
package org.apache.bval.model;
import org.apache.commons.lang3.ArrayUtils;
public abstract class MetaAnnotated extends Meta {
private static final long serialVersionUID = 1L;
private Annotation[] annotations = new Annotation[0];
public Annotation[] getAnnotations() {
return annotations;
}
public void addAnnotation(final Annotation annotation) {
this.annotations = ArrayUtils.add(annotations, annotation);
}
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
import java.beans.Introspector;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
@Privilizing(@CallTo(Reflection.class))
private Map<String, MetaProperty> properties = null;
private Map<Method, MetaMethod> methods = null;
private Map<Constructor<?>, MetaConstructor> constructors = null;
if (beanClass != null) {
final Map<String, MetaProperty> oldProperties = properties;
final Map<Method, MetaMethod> oldMethods = methods;
final Map<Constructor<?>, MetaConstructor> oldConstructors = constructors;
properties = new TreeMap<String, MetaProperty>(new FieldComparator(beanClass));
if (oldProperties != null) {
properties.putAll(oldProperties);
}
methods = new TreeMap<Method, MetaMethod>(new MethodComparator(beanClass));
if (oldMethods != null) {
methods.putAll(oldMethods);
}
constructors = new TreeMap<Constructor<?>, MetaConstructor>(new ConstructorComparator(beanClass));
if (oldConstructors != null) {
constructors.putAll(oldConstructors);
}
}
if (properties == null) {
return new MetaProperty[0];
}
public MetaMethod[] getMethods() {
if (methods == null) {
return new MetaMethod[0];
}
return methods.values().toArray(new MetaMethod[this.methods.size()]);
}
public void addMethod(final Method method, final MetaMethod meta) {
if (methods == null) {
methods = new HashMap<Method, MetaMethod>();
}
methods.put(method, meta);
}
public void addConstructor(final Constructor<?> constructor, final MetaConstructor meta) {
if (constructors == null) {
constructors = new HashMap<Constructor<?>, MetaConstructor>();
}
constructors.put(constructor, meta);
}
this.properties = new HashMap<String, MetaProperty>();
for (final MetaProperty property : properties) {
if (properties == null) {
return null;
}
if (properties == null) {
return false;
}
if (properties == null) {
properties = new HashMap<String, MetaProperty>();
}
public MetaMethod getMethod(final Method method) {
return methods == null ? null : methods.get(method);
}
public MetaConstructor getConstructor(final Constructor<?> constructor) {
return constructors == null ? null : constructors.get(constructor);
}
protected static class FieldComparator implements Comparator<String> {
private final Map<String, Integer> fields = new HashMap<String, Integer>();
protected FieldComparator(final Class<?> beanClass) {
int i = 0;
Class<?> clazz = beanClass;
while (clazz != null && clazz != Object.class) {
for (final Field f : Reflection.getDeclaredFields(clazz)) {
i;
final String name = f.getName();
if (!fields.containsKey(name)) {
fields.put(name, i);
}
}
for (final Method m : clazz.getDeclaredMethods()) {
if (m.getName().startsWith("get") && Void.TYPE != m.getReturnType() && m.getParameterTypes().length == 0) {
final String name = Introspector.decapitalize(m.getName().substring("get".length()));
if (!name.isEmpty()) {
i;
if (!fields.containsKey(name)) {
fields.put(name, i);
}
}
}
}
clazz = clazz.getSuperclass();
}
}
public int compare(final String o1, final String o2) {
return fieldIndex(o1) - fieldIndex(o2);
}
private int fieldIndex(final String o2) {
final Integer idx = fields.get(o2);
if (idx == null) {
}
return idx;
}
}
protected static class MethodComparator implements Comparator<Method> {
private final Map<Method, Integer> methods = new HashMap<Method, Integer>();
protected MethodComparator(final Class<?> beanClass) {
Class<?> clazz = beanClass;
while (clazz != null && clazz != Object.class) {
for (final Method m : Reflection.getDeclaredMethods(clazz)) {
methods.put(m, Arrays.hashCode(m.getParameterTypes()));
}
clazz = clazz.getSuperclass();
}
}
public int compare(final Method o1, final Method o2) {
if (o1 == o2) {
return 0;
}
final int i = o1.getName().compareTo(o2.getName());
return i == 0 ? methods.get(o1) - methods.get(o2) : i;
}
}
protected static class ConstructorComparator implements Comparator<Constructor<?>> {
private final Map<Constructor<?>, Integer> constructors = new HashMap<Constructor<?>, Integer>();
protected ConstructorComparator(final Class<?> beanClass) {
for (final Constructor<?> c : Reflection.getDeclaredConstructors(beanClass)) {
constructors.put(c, Arrays.hashCode(c.getParameterTypes()));
}
}
public int compare(final Constructor<?> o1, final Constructor<?> o2) {
if (o1 == o2) {
return 0;
}
final int i = o1.getName().compareTo(o2.getName());
return i == 0 ? constructors.get(o1) - constructors.get(o2) : i;
}
}
package org.apache.bval.model;
import java.lang.reflect.Constructor;
public class MetaConstructor extends MetaInvocable {
private static final long serialVersionUID = 1L;
private final Constructor<?> constructor;
public MetaConstructor(final MetaBean metabean, final Constructor<?> constructor) {
this.parentMetaBean = metabean;
this.constructor = constructor;
}
public Constructor<?> getConstructor() {
return constructor;
}
package org.apache.bval.model;
import java.lang.reflect.Method;
public class MetaMethod extends MetaInvocable {
private static final long serialVersionUID = 1L;
private final Method method;
public MetaMethod(final MetaBean parent, final Method method) {
this.parentMetaBean = parent;
this.method = method;
}
public Method getMethod() {
return method;
}
import java.lang.reflect.Type;
public class MetaProperty extends Meta implements Cloneable, Features.Property {
Type targetType = type instanceof DynaType ? ((DynaType) type).getRawType() : type;
Type assigningType = getParentMetaBean() == null ? null : getParentMetaBean().getBeanClass();
void moveDown(String prop);
if (value == null) {
}
if (!(value instanceof CharSequence)) {
}
if (seq.length() == 0) {
}
return aPattern.matcher(seq).matches();
import java.io.InputStream;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
InputStream in = BValVersion.class.getResourceAsStream("/META-INF/org.apache.bval.revision.properties");
if (StringUtils.isBlank(revision)) {
if (strTok != null) {
}
final StringBuilder buf = new StringBuilder(80 * 40);
final StringTokenizer tok = new StringTokenizer(Reflection.getProperty("java.class.path"));
return buf.append(prop).append(": ").append(Reflection.getProperty(prop));
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final boolean mustUnset = Reflection.setAccessible(field, true);
} finally {
if (mustUnset) {
Reflection.setAccessible(field, false);
}
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.reflect.TypeUtils;
return ObjectUtils.defaultIfNull(TypeUtils.unrollVariables(typeArguments, ITERABLE_TYPE), Object.class);
private final Type containerType;
private final Integer index;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.reflect.TypeUtils;
return ObjectUtils.defaultIfNull(TypeUtils.unrollVariables(typeArguments, MAP_TYPEVARS[1]), Object.class);
private final Type containerType;
private final Object key;
Type keyType = TypeUtils.unrollVariables(typeArguments, MAP_TYPEVARS[0]);
final Type result = getJavaElementType(containerType);
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
final String methodName = member.getName();
return Introspector.decapitalize(methodName.substring(2));
if (methodName.startsWith("get")) {
return Introspector.decapitalize(methodName.substring(3));
}
return null;
final boolean mustUnset = Reflection.setAccessible(method, true);
} finally {
if (mustUnset) {
Reflection.setAccessible(method, false);
}
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
import org.apache.bval.util.reflection.Reflection;
private static Object readField(Field field, Object bean) throws IllegalAccessException {
final boolean mustUnset = Reflection.setAccessible(field, true);
try {
return field.get(bean);
} finally {
if (mustUnset) {
Reflection.setAccessible(field, false);
}
}
}
return readField(rememberField, bean);
return readField(rememberField, bean);
if (this == o) {
}
if (o == null || getClass() != o.getClass()) {
}
import java.util.List;
import java.util.Map;
if (dyn == null) {
} else {
context.setBean(each, dyn.resolveMetaBean(each));
if (dyn == null) {
} else {
context.setBean(each, dyn.resolveMetaBean(each));
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.Character.getNumericValue;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import java.lang.annotation.Annotation;
import static java.lang.Character.getNumericValue;
import static java.lang.Character.isDigit;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import javax.validation.Constraint;
import javax.validation.Payload;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.Character.getNumericValue;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import org.apache.bval.extras.constraints.checkdigit.Luhn;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.io.File;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.io.File;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.io.File;
import java.io.IOException;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import static java.util.Arrays.asList;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import java.util.regex.Pattern;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import org.apache.bval.model.MetaBean;
package org.apache.bval.cdi;
import javax.enterprise.inject.Any;
import javax.enterprise.util.AnnotationLiteral;
public class AnyLiteral extends AnnotationLiteral<Any> implements Any {
private static final long serialVersionUID = 1L;
public static final AnyLiteral INSTANCE = new AnyLiteral();
@Override
public String toString() {
return "@javax.enterprise.inject.Any()";
}
package org.apache.bval.cdi;
import javax.interceptor.InterceptorBinding;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
@InterceptorBinding
public @interface BValBinding {
package org.apache.bval.cdi;
import javax.enterprise.inject.Default;
import javax.enterprise.util.AnnotationLiteral;
public class DefaultLiteral extends AnnotationLiteral<Default> implements Default {
private static final long serialVersionUID = 1L;
public static final DefaultLiteral INSTANCE = new DefaultLiteral();
@Override
public String toString() {
return "@javax.enterprise.inject.Default()";
}
return value == null || Boolean.FALSE.equals(value);
return value == null || Boolean.TRUE.equals(value);
public class DecimalMaxValidatorForNumber implements ConstraintValidator<DecimalMax, Number> {
if (value instanceof BigDecimal) {
return ((BigDecimal) value).compareTo(maxValue) != 1;
}
if (value instanceof BigInteger) {
return (new BigDecimal((BigInteger) value)).compareTo(maxValue) != 1;
}
return (new BigDecimal(value.doubleValue()).compareTo(maxValue)) != 1;
public class DecimalMaxValidatorForString implements ConstraintValidator<DecimalMax, String> {
public class DecimalMinValidatorForNumber implements ConstraintValidator<DecimalMin, Number> {
if (value instanceof BigDecimal) {
return ((BigDecimal) value).compareTo(minValue) != -1;
}
if (value instanceof BigInteger) {
return (new BigDecimal((BigInteger) value)).compareTo(minValue) != -1;
}
return (new BigDecimal(value.doubleValue()).compareTo(minValue)) != -1;
public class DecimalMinValidatorForString implements ConstraintValidator<DecimalMin, String> {
throw new IllegalArgumentException("The length of the integer part cannot be negative.");
throw new IllegalArgumentException("The length of the fraction part cannot be negative.");
final int intLength = bigDecimal.precision() - bigDecimal.scale();
return false;
throw new IllegalArgumentException("The length of the integer part cannot be negative.");
throw new IllegalArgumentException("The length of the fraction part cannot be negative.");
final BigDecimal bigDecimal = getBigDecimalValue(str);
return false;
return new BigDecimal(str);
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
if (value instanceof BigDecimal) {
return ((BigDecimal) value).compareTo(BigDecimal.valueOf(max)) != 1;
}
if (value instanceof BigInteger) {
return ((BigInteger) value).compareTo(BigInteger.valueOf(max)) != 1;
}
return value.longValue() <= max;
if (value instanceof BigDecimal) {
return ((BigDecimal) value).compareTo(BigDecimal.valueOf(minValue)) != -1;
}
if (value instanceof BigInteger) {
return ((BigInteger) value).compareTo(BigInteger.valueOf(minValue)) != -1;
}
return value.longValue() >= minValue;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
if (value == null) {
return true;
}
try {
final Method isEmptyMethod = value.getClass().getMethod("isEmpty");
if (isEmptyMethod != null) {
return !((Boolean) isEmptyMethod.invoke(value)).booleanValue();
}
} catch (IllegalAccessException iae) {
} catch (NoSuchMethodException nsme) {
} catch (InvocationTargetException ite) {
}
return !value.toString().isEmpty();
return value == null || !value.isEmpty();
final Pattern.Flag flags[] = annotation.flags();
if (min < 0) {
throw new ValidationException("Min cannot be negative");
}
if (max < 0) {
throw new ValidationException("Max cannot be negative");
}
if (max < min) {
throw new ValidationException("Max cannot be less than Min");
}
public class SizeValidatorForArrayOfBoolean extends SizeValidator implements ConstraintValidator<Size, boolean[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfByte extends SizeValidator implements ConstraintValidator<Size, byte[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfChar extends SizeValidator implements ConstraintValidator<Size, char[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfDouble extends SizeValidator implements ConstraintValidator<Size, double[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfFloat extends SizeValidator implements ConstraintValidator<Size, float[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfInt extends SizeValidator implements ConstraintValidator<Size, int[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfLong extends SizeValidator implements ConstraintValidator<Size, long[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfObject extends SizeValidator implements ConstraintValidator<Size, Object[]> {
final int length = Array.getLength(array);
public class SizeValidatorForArrayOfShort extends SizeValidator implements ConstraintValidator<Size, short[]> {
final int length = Array.getLength(array);
public class SizeValidatorForCharSequence extends SizeValidator implements ConstraintValidator<Size, CharSequence> {
public boolean isValid(CharSequence s, ConstraintValidatorContext context) {
final int length = s.length();
public class SizeValidatorForCollection extends SizeValidator implements ConstraintValidator<Size, Collection<?>> {
final int length = collection.size();
public class SizeValidatorForMap extends SizeValidator implements ConstraintValidator<Size, Map<?, ?>> {
final int size = map.size();
package org.apache.bval.jsr;
import javax.validation.ParameterNameProvider;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privileged;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
private ParameterNameProvider parameterNameProvider;
public ValidatorContext parameterNameProvider(ParameterNameProvider parameterNameProvider) {
this.parameterNameProvider = parameterNameProvider;
return this;
}
return new ClassValidator(this);
public ParameterNameProvider getParameterNameProvider() {
return parameterNameProvider == null ? factory.getParameterNameProvider() : parameterNameProvider;
}
boolean isTreatMapsLikeBeans() {
return Boolean.parseBoolean(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.TREAT_MAPS_LIKE_BEANS));
}
final List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>();
final String[] factoryClassNames =
StringUtils.split(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.METABEAN_FACTORY_CLASSNAMES));
final Class<? extends MetaBeanFactory> factoryClass = (Class<? extends MetaBeanFactory>) loadClass(clsName);
boolean jsrFound = false;
jsrFound |= builder instanceof JsrMetaBeanFactory;
if (!jsrFound) {
builders.add(new JsrMetaBeanFactory(this));
final boolean enableMetaBeansXml =
Boolean.parseBoolean(factory.getProperties().get(
ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML));
@Privileged
try {
Constructor<F> c = ConstructorUtils.getMatchingAccessibleConstructor(cls, ApacheFactoryContext.this.getClass());
if (c != null) {
return c.newInstance(ApacheFactoryContext.this);
c = ConstructorUtils.getMatchingAccessibleConstructor(cls, getFactory().getClass());
if (c != null) {
return c.newInstance(getFactory());
}
return cls.newInstance();
} catch (Exception e) {
throw new ValidationException(e);
}
return Class.forName(className, true, Reflection.getClassLoader(ApacheFactoryContext.class));
package org.apache.bval.jsr;
final String validatorFactoryClassname =
package org.apache.bval.jsr;
public interface ApacheValidatorConfiguration extends Configuration<ApacheValidatorConfiguration> {
String VALIDATOR_FACTORY_CLASSNAME = "apache.bval.validator-factory-classname";
String METABEAN_FACTORY_CLASSNAMES = "apache.bval.metabean-factory-classnames";
package org.apache.bval.jsr;
import org.apache.bval.jsr.xml.AnnotationIgnores;
import org.apache.bval.jsr.xml.MetaConstraint;
import org.apache.bval.jsr.xml.ValidationMappingParser;
import org.apache.bval.util.AccessStrategy;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
import javax.validation.ParameterNameProvider;
import java.io.Closeable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
@Privilizing(@CallTo(Reflection.class))
private static final ConstraintDefaults DEFAULT_CONSTRAINTS = new ConstraintDefaults();
private ParameterNameProvider parameterNameProvider;
private final ConcurrentMap<Class<?>, List<AccessStrategy>> validAccesses;
private final ConcurrentMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>> constraintMap;
private final Collection<Closeable> toClose = new ArrayList<Closeable>();
public static ApacheValidatorFactory getDefault() {
synchronized (ApacheValidatorFactory.class) {
if (DEFAULT_FACTORY == null) {
DEFAULT_FACTORY = Validation.byProvider(ApacheValidationProvider.class).configure()
.buildValidatorFactory().unwrap(ApacheValidatorFactory.class);
}
}
validAccesses = new ConcurrentHashMap<Class<?>, List<AccessStrategy>>();
constraintMap = new ConcurrentHashMap<Class<?>, List<MetaConstraint<?, ? extends Annotation>>>();
protected void configure(final ConfigurationState configuration) {
parameterNameProvider = configuration.getParameterNameProvider();
messageResolver = configuration.getMessageInterpolator();
traversableResolver = configuration.getTraversableResolver();
constraintValidatorFactory = configuration.getConstraintValidatorFactory();
if (ConfigurationImpl.class.isInstance(configuration)) {
final ConfigurationImpl impl = ConfigurationImpl.class.cast(configuration);
toClose.add(impl.getClosable());
}
new ValidationMappingParser(this).processMappingConfig(configuration.getMappingStreams());
if (messageResolver != null) {
this.messageResolver = messageResolver;
}
if (traversableResolver != null) {
this.traversableResolver = traversableResolver;
}
}
public void setParameterNameProvider(final ParameterNameProvider parameterNameProvider) {
if (parameterNameProvider != null) {
this.parameterNameProvider = parameterNameProvider;
}
if (constraintValidatorFactory != null) {
this.constraintValidatorFactory = constraintValidatorFactory;
if (DefaultConstraintValidatorFactory.class.isInstance(constraintValidatorFactory)) {
toClose.add(Closeable.class.cast(constraintValidatorFactory));
}
}
public ParameterNameProvider getParameterNameProvider() {
return parameterNameProvider;
}
public void close() {
try {
for (final Closeable c : toClose) {
c.close();
}
toClose.clear();
} catch (final Exception e) {
}
}
final T result = (T) this;
try {
return Reflection.newInstance(cls);
} catch (final RuntimeException e) {
throw new ValidationException(e.getCause());
}
return DEFAULT_CONSTRAINTS;
public void addMetaConstraint(final Class<?> beanClass,
final MetaConstraint<?, ?> metaConstraint) {
List<MetaConstraint<?, ? extends Annotation>> slot = constraintMap.get(beanClass);
if (slot == null) {
slot = new ArrayList<MetaConstraint<?, ? extends Annotation>>();
final List<MetaConstraint<?, ? extends Annotation>> old = constraintMap.putIfAbsent(beanClass, slot);
if (old != null) {
slot = old;
List<AccessStrategy> slot = validAccesses.get(beanClass);
if (slot == null) {
slot = new ArrayList<AccessStrategy>();
final List<AccessStrategy> old = validAccesses.putIfAbsent(beanClass, slot);
if (old != null) {
slot = old;
package org.apache.bval.jsr;
package org.apache.bval.jsr;
import org.apache.bval.jsr.xml.AnnotationProxyBuilder;
final Set<Class<?>> inheritedGroups = builder.getConstraintValidation().getGroups();
final Set<Class<? extends Payload>> inheritedPayload = builder.getConstraintValidation().getPayload();
final T originalAnnot = validation.getAnnotation();
final AnnotationProxyBuilder<T> apb = new AnnotationProxyBuilder<T>(originalAnnot);
final T newAnnot = apb.createAnnotation();
package org.apache.bval.jsr;
package org.apache.bval.jsr;
package org.apache.bval.jsr;
public final <T extends Annotation> void append(final ConstraintValidation<T> validation) {
public abstract <T extends Annotation> void performAppend(final ConstraintValidation<T> validation);
public <T extends Annotation> void preProcessValidation(final ConstraintValidation<T> validation) {
public <T extends Annotation> void postProcessValidation(final ConstraintValidation<T> validation) {
package org.apache.bval.jsr;
import java.util.Set;
<T extends Object> Set<javax.validation.ConstraintViolation<T>> validateProperty(T object, String propertyName,
boolean cascade, Class<?>... groups);
<T extends Object> Set<javax.validation.ConstraintViolation<T>> validateValue(Class<T> beanType,
String propertyName, Object value, boolean cascade, Class<?>... groups);
package org.apache.bval.jsr;
new HashMap<Class<? extends Annotation>, Class<? extends ConstraintValidator<?, ?>>[]>();
Class<? extends ConstraintValidator<A, ?>>[] definitionClasses) {
Class<A> annotationClass) {
package org.apache.bval.jsr;
import javax.validation.ConstraintTarget;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
private final ConstraintTarget validationAppliesTo;
private final String template;
private final int hashCode;
public ConstraintDescriptorImpl(final ConstraintDescriptor<T> descriptor) {
descriptor.isReportAsSingleViolation(), descriptor.getValidationAppliesTo(), descriptor.getMessageTemplate());
boolean reportAsSingleViolation, ConstraintTarget validationAppliesTo, String messageTemplate) {
this.validationAppliesTo = validationAppliesTo;
this.template = messageTemplate;
this.hashCode = computeHashCode();
public String getMessageTemplate() {
return template;
}
public ConstraintTarget getValidationAppliesTo() {
return validationAppliesTo;
}
@Override
public boolean equals(Object o) {
if (this == o) {
return true;
}
if (o == null || !getClass().equals(o.getClass())) {
return false;
}
@SuppressWarnings("rawtypes")
final ConstraintDescriptorImpl that = (ConstraintDescriptorImpl) o;
return new EqualsBuilder()
.append(reportAsSingleViolation, that.reportAsSingleViolation)
.append(annotation.annotationType(), that.annotation.annotationType())
.append(attributes, that.attributes)
.append(composingConstraints, that.composingConstraints)
.append(constraintValidatorClasses, that.constraintValidatorClasses)
.append(groups, that.groups)
.append(payload, that.payload)
.append(template, that.template)
.append(validationAppliesTo, that.validationAppliesTo)
.build();
}
@Override
public int hashCode() {
return hashCode;
}
private int computeHashCode() {
return new HashCodeBuilder(1, 31)
.append(annotation.annotationType())
.append(groups)
.append(payload)
.append(constraintValidatorClasses)
.append(attributes)
.append(composingConstraints)
.append(reportAsSingleViolation)
.append(validationAppliesTo)
.append(template)
.build();
}
package org.apache.bval.jsr;
import org.apache.bval.jsr.groups.Group;
import org.apache.bval.jsr.groups.Groups;
import org.apache.bval.jsr.groups.GroupsComputer;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
final Set<ConstraintValidation<?>> matchingDescriptors =
final Groups groupChain = new GroupsComputer().computeGroups(groups);
for (Group defaultGroupMember : metaBean.<List<Group>>getFeature(JsrFeatures.Bean.GROUP_SEQUENCE)) {
if (scope == Scope.LOCAL_ELEMENT) {
if (!it.next().getOwner().equals(metaBean.getBeanClass())) {
final Set<ConstraintValidation<?>> matchingDescriptors =
{
}
final boolean isOwner = descriptor.getOwner().equals(metaBean.getBeanClass());
case LOCAL_ELEMENT:
if (isOwner) {
return true;
}
break;
case HIERARCHY:
if (!isOwner) {
return true;
}
break;
if (constraintDescriptors.isEmpty()) {
return Collections.emptySet();
}
return Collections.<ConstraintDescriptor<?>> unmodifiableSet(constraintDescriptors);
package org.apache.bval.jsr;
import org.apache.bval.jsr.util.PathImpl;
import javax.validation.ElementKind;
import java.util.Iterator;
final Object[] parameters;
Object leaf;
Object returnValue;
T rootBean;
final GroupValidationContext<T> ctx = GroupValidationContext.class.cast(context);
final ElementKind elementKind = ctx.getElementKind();
final Iterator<Path.Node> it = propPath.iterator();
final ElementKind kind = propPath.iterator().next().getKind();
returnValue = ctx.getReturnValue();
if (ElementKind.CONSTRUCTOR.equals(kind)) {
rootBean = null;
leaf = context.getBean();
} else if (ElementKind.METHOD.equals(kind)) {
rootBean = (T) returnValue;
if (kindOf(propPath, ElementKind.RETURN_VALUE)) {
leaf = returnValue;
returnValue = this.rootBean;
} else {
leaf = this.rootBean;
returnValue = this.rootBean;
}
} else {
rootBean = this.rootBean;
if (kindOf(propPath, ElementKind.PARAMETER, ElementKind.CROSS_PARAMETER)) {
leaf = rootBean;
} else {
leaf = context.getBean();
}
}
} else {
rootBean = this.rootBean;
leaf = context.getBean();
}
if (ElementKind.CONSTRUCTOR.equals(kind)
&& (ElementKind.CROSS_PARAMETER.equals(elementKind)
|| ElementKind.PARAMETER.equals(elementKind))
leaf = null;
}
parameters = ctx.getParameters();
} else {
leaf = context.getBean();
returnValue = null;
parameters = null;
rootBean = this.rootBean;
}
constraintViolations.add(new ConstraintViolationImpl<T>(
messageTemplate, message,
rootBean, leaf,
propPath, value, descriptor,
rootBeanType,
elementType, returnValue, parameters));
}
private static boolean kindOf(final Path propPath, final ElementKind... kinds) {
final Iterator<Path.Node> node = propPath.iterator();
boolean isParam = false;
while (node.hasNext()) {
final ElementKind current = node.next().getKind();
isParam = false;
for (final ElementKind k : kinds) {
if (k.equals(current)) {
isParam = true;
break;
}
}
}
return isParam;
package org.apache.bval.jsr;
import org.apache.bval.jsr.util.LeafNodeBuilderCustomizableContextImpl;
import org.apache.bval.jsr.util.NodeBuilderDefinedContextImpl;
import org.apache.bval.jsr.util.NodeImpl;
import org.apache.bval.jsr.util.PathImpl;
import javax.validation.ElementKind;
import java.lang.reflect.Method;
return new ConstraintViolationBuilderImpl(this, messageTemplate, validationContext.getPropertyPath());
}
public <T> T unwrap(Class<T> type) {
if (type.isInstance(this)) {
return type.cast(this);
}
path = PathImpl.create();
path.getLeafNode().setName(name);
public NodeBuilderCustomizableContext addPropertyNode(String name) {
final NodeImpl node;
if (!propertyPath.isRootPath()) {
if (propertyPath.getLeafNode().getKind() != null) {
node = new NodeImpl.PropertyNodeImpl(name);
propertyPath.addNode(node);
} else {
node = propertyPath.getLeafNode();
}
} else {
node = new NodeImpl.PropertyNodeImpl(name);
propertyPath.addNode(node);
}
node.setName(name);
return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
}
public LeafNodeBuilderCustomizableContext addBeanNode() {
final NodeImpl node = new NodeImpl.BeanNodeImpl();
node.setKind(ElementKind.BEAN);
propertyPath.addNode(node);
return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
}
public NodeBuilderDefinedContext addParameterNode(int index) {
final Method method = parent.validationContext.getMethod();
final List<String> parameters = parent.validationContext.getParameterNameProvider().getParameterNames(method);
final NodeImpl node = new NodeImpl.ParameterNodeImpl(parameters.get(index), index);
node.setParameterIndex(index);
node.setKind(ElementKind.PARAMETER);
if (!propertyPath.isRootPath()) {
propertyPath.removeLeafNode();
}
propertyPath.addNode(node);
return new NodeBuilderDefinedContextImpl(parent, messageTemplate, propertyPath);
}
package org.apache.bval.jsr;
package org.apache.bval.jsr;
import org.apache.bval.el.MessageEvaluator;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
import javax.validation.MessageInterpolator;
@Privilizing(@CallTo(Reflection.class))
private static final boolean LOG_FINEST = log.isLoggable(Level.FINEST);
private static final String DEFAULT_VALIDATION_MESSAGES = "org.apache.bval.jsr.ValidationMessages";
private final Map<Locale, ResourceBundle> defaultBundlesMap = new ConcurrentHashMap<Locale, ResourceBundle>();
private final MessageEvaluator evaluator;
findDefaultResourceBundle(defaultLocale);
findUserResourceBundle(defaultLocale);
MessageEvaluator ev = null;
try {
ev = MessageEvaluator.class.cast(getClass().getClassLoader().loadClass("org.apache.bval.el.ELFacade").newInstance());
}
evaluator = ev;
context.getConstraintDescriptor().getAttributes(), locale, context.getValidatedValue());
Locale locale, Object validatedValue) {
resolvedMessage = replaceAnnotationAttributes(resolvedMessage, annotationParameters);
if (evaluator != null) {
resolvedMessage = evaluator.interpolate(resolvedMessage, annotationParameters, validatedValue);
}
resolvedMessage = resolvedMessage.replace( "\\{", "{" ).replace( "\\}", "}" ).replace( "\\\\", "\\" ).replace( "\\$", "$" );
final ClassLoader classLoader = Reflection.getClassLoader(DefaultMessageInterpolator.class);
if (LOG_FINEST) {
if (rb != null) {
log.log(Level.FINEST, String.format("%s found", USER_VALIDATION_MESSAGES));
} else {
log.log(Level.FINEST, String.format("%s not found. Delegating to %s", USER_VALIDATION_MESSAGES, DEFAULT_VALIDATION_MESSAGES));
}
} catch (final MissingResourceException e) {
final Matcher matcher = messageParameterPattern.matcher(message);
final StringBuffer sb = new StringBuffer(64);
final String parameter = matcher.group(1);
private String replaceAnnotationAttributes(final String message,
final Map<String, Object> annotationParameters) {
parameterValue = replaceVariables(parameterValue, bundle, locale, recurse);
} catch (final MissingResourceException e) {
package org.apache.bval.jsr;
import javax.validation.ValidationException;
import javax.validation.ValidationProviderResolver;
import javax.validation.spi.ValidationProvider;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
"META-INF/services/javax.validation.spi.ValidationProvider";
final URL url = cfgs.nextElement();
@SuppressWarnings("rawtypes")
final Class<? extends ValidationProvider> providerType =
cl.loadClass(line).asSubclass(ValidationProvider.class);
providers.add(Reflection.newInstance(providerType.asSubclass(ValidationProvider.class)));
if (br != null) {
}
package org.apache.bval.jsr;
import org.apache.bval.jsr.groups.Group;
import javax.validation.ConstraintDeclarationException;
import javax.validation.metadata.GroupConversionDescriptor;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArraySet;
private final Set<GroupConversionDescriptor> groupConversions = new CopyOnWriteArraySet<GroupConversionDescriptor>();
private boolean cascaded;
private final Collection<Object> validated = new CopyOnWriteArraySet<Object>();
protected static Set<ConstraintDescriptor<?>> getConstraintDescriptors(final Validation[] validations) {
private final Map<Group, Group> groupMapping = new HashMap<Group, Group>();
public Set<ConstraintDescriptor<?>> getMutableConstraintDescriptors() {
public void addGroupMapping(final Group from, final Group to) {
groupMapping.put(from, to);
}
public Group mapGroup(final Group current) {
final Group mapping = groupMapping.get(current);
if (mapping != null) {
return mapping;
}
return current;
}
public Set<GroupConversionDescriptor> getGroupConversions() {
return groupConversions;
}
public void addGroupConversion(final GroupConversionDescriptor descriptor) {
groupConversions.add(descriptor);
final Group from = new Group(descriptor.getFrom());
throw new ConstraintDeclarationException("You can't map twice from the same group");
}
addGroupMapping(from, new Group(descriptor.getTo()));
}
public boolean isCascaded() {
return cascaded;
}
public void setCascaded(final boolean cascaded) {
this.cascaded = cascaded;
}
public boolean isValidated(final Object object) {
return validated.contains(object);
}
public void setValidated(final Object object) {
this.validated.add(object);
}
package org.apache.bval.jsr;
package org.apache.bval.jsr;
import org.apache.bval.jsr.groups.Group;
import org.apache.bval.jsr.groups.Groups;
import org.apache.bval.jsr.util.PathImpl;
import javax.validation.ElementKind;
import javax.validation.ParameterNameProvider;
import javax.validation.Path;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
void setCurrentGroups(Groups groups);
void setKind(ElementKind type);
ElementKind getElementKind();
Object getReturnValue();
Object[] getParameters();
void setParameters(Object[] parameters);
void setReturnValue(Object returnValue);
ParameterNameProvider getParameterNameProvider();
void setMethod(Method method);
Method getMethod();
void setConstructor(Constructor<?> method);
Constructor<?> getConstructor();
void moveDown(Path.Node node);
package org.apache.bval.jsr;
import org.apache.bval.jsr.groups.Group;
import org.apache.bval.jsr.groups.Groups;
import org.apache.bval.jsr.resolver.CachingTraversableResolver;
import org.apache.bval.jsr.util.NodeImpl;
import org.apache.bval.jsr.util.PathImpl;
import javax.validation.ElementKind;
import javax.validation.ParameterNameProvider;
import javax.validation.Path;
import javax.validation.ValidationException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
private final ParameterNameProvider parameterNameProvider;
private Object[] parameters;
private Object returnValue;
private Method method;
private Constructor<?> constructor;
TraversableResolver traversableResolver, ParameterNameProvider parameterNameProvider, MetaBean rootMetaBean) {
this.parameterNameProvider = parameterNameProvider;
this.path = PathImpl.create();
public void setKind(final ElementKind type) {
path.getLeafNode().setKind(type);
}
moveDown(prop.getName());
@Override
public void moveDown(final String prop) {
path.addProperty(prop);
}
public void moveDown(final Path.Node node) {
path.addNode(node);
}
public void setCurrentGroups(final Groups g) {
groups = g;
}
public <T> T unwrap(Class<T> type) {
if (type.isInstance(this)) {
return type.cast(this);
}
}
public ElementKind getElementKind() {
return path.getLeafNode().getKind();
}
public Object getReturnValue() {
return returnValue;
}
public Object[] getParameters() {
return parameters;
}
public void setParameters(final Object[] parameters) {
this.parameters = parameters;
}
public void setReturnValue(final Object returnValue) {
this.returnValue = returnValue;
}
public ParameterNameProvider getParameterNameProvider() {
return parameterNameProvider;
}
public void setMethod(final Method method) {
this.method = method;
}
public Method getMethod() {
return method;
}
public Constructor<?> getConstructor() {
return constructor;
}
public void setConstructor(final Constructor<?> constructor) {
this.constructor = constructor;
}
package org.apache.bval.jsr;
package org.apache.bval.jsr;
public interface JsrFeatures {
interface Method extends Features.Property {
String MethodDescriptor = "MethodDescriptor";
}
interface Constructor extends Features.Property {
String ConstructorDescriptor = "ConstructorDescriptor";
}
String ANNOTATIONS_TO_PROCESS = "annotationToProcess";
package org.apache.bval.jsr;
import org.apache.bval.jsr.groups.Group;
import org.apache.bval.jsr.util.ClassHelper;
import org.apache.bval.jsr.xml.MetaConstraint;
import org.apache.bval.model.Meta;
import org.apache.bval.model.MetaConstructor;
import org.apache.bval.model.MetaMethod;
import org.apache.bval.model.MetaParameter;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
import javax.validation.ConstraintDeclarationException;
import javax.validation.GroupDefinitionException;
import javax.validation.GroupSequence;
import javax.validation.groups.ConvertGroup;
import javax.validation.groups.Default;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.annotation.ElementType;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
@Privilizing(@CallTo(Reflection.class))
public class JsrMetaBeanFactory implements MetaBeanFactory {
protected static final Logger log = Logger.getLogger(JsrMetaBeanFactory.class.getName());
public JsrMetaBeanFactory(ApacheFactoryContext factoryContext) {
final List<Class<?>> classSequence =
ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), beanClass);
annotationProcessor.processAnnotations(null, beanClass, beanClass, null, new AppendValidationToMeta(metabean));
final Collection<String> missingValid = new ArrayList<String>();
final Field[] fields = Reflection.getDeclaredFields(beanClass);
for (final Field field : fields) {
if (field.getAnnotation(ConvertGroup.class) != null) {
missingValid.add(field.getName());
}
final Method[] methods = Reflection.getDeclaredMethods(beanClass);
for (final Method method : methods) {
if (method.isSynthetic() || method.isBridge()) {
continue;
}
for (final String name : missingValid) {
final MetaProperty metaProperty = metabean.getProperty(name);
if (metaProperty != null && metaProperty.getFeature(JsrFeatures.Property.REF_CASCADE) == null) {
throw new ConstraintDeclarationException("@ConvertGroup needs @Valid");
missingValid.clear();
for (final MetaConstraint<?, ? extends Annotation> metaConstraint : factoryContext.getFactory().getMetaConstraints(beanClass)) {
Meta meta;
AccessStrategy access = metaConstraint.getAccessStrategy();
meta = null;
final Method method = Method.class.cast(metaConstraint.getMember());
meta = metabean.getMethod(method);
final MetaMethod metaMethod;
if (meta == null) {
meta = new MetaMethod(metabean, method);
metaMethod = MetaMethod.class.cast(meta);
metabean.addMethod(method, metaMethod);
} else {
metaMethod = MetaMethod.class.cast(meta);
}
final Integer index = metaConstraint.getIndex();
if (index != null && index >= 0) {
MetaParameter param = metaMethod.getParameter(index);
if (param == null) {
param = new MetaParameter(metaMethod, index);
metaMethod.addParameter(index, param);
}
param.addAnnotation(metaConstraint.getAnnotation());
} else {
metaMethod.addAnnotation(metaConstraint.getAnnotation());
}
continue;
} else if (access.getElementType() == ElementType.CONSTRUCTOR){
final Constructor<?> constructor = Constructor.class.cast(metaConstraint.getMember());
meta = metabean.getConstructor(constructor);
final MetaConstructor metaConstructor;
if (meta == null) {
meta = new MetaConstructor(metabean, constructor);
metaConstructor = MetaConstructor.class.cast(meta);
metabean.addConstructor(constructor, metaConstructor);
} else {
metaConstructor = MetaConstructor.class.cast(meta);
}
final Integer index = metaConstraint.getIndex();
if (index != null && index >= 0) {
MetaParameter param = metaConstructor.getParameter(index);
if (param == null) {
param = new MetaParameter(metaConstructor, index);
metaConstructor.addParameter(index, param);
}
param.addAnnotation(metaConstraint.getAnnotation());
} else {
metaConstructor.addAnnotation(metaConstraint.getAnnotation());
}
continue;
meta = metabean.getProperty(access.getPropertyName());
create = meta == null;
meta = addMetaProperty(metabean, access);
if (!annotationProcessor.processAnnotation(metaConstraint.getAnnotation(), meta, beanClass,
metaConstraint.getAccessStrategy(), new AppendValidationToMeta(meta == null ? metabean : meta), false)
for (final AccessStrategy access : factoryContext.getFactory().getValidAccesses(beanClass)) {
if (access.getElementType() == ElementType.PARAMETER) {
continue;
}
processGroupSequence(beanClass, metabean, JsrFeatures.Bean.GROUP_SEQUENCE);
groupSeq = metabean.initFeature(key, new ArrayList<Group>(annotation == null ? 1 : annotation.value().length));
for (final Class<?> groupClass : groupClasses) {
package org.apache.bval.jsr;
import javax.validation.metadata.ParameterDescriptor;
package org.apache.bval.jsr;
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
final ParameterAccess that = (ParameterAccess) o;
return paramIdx == that.paramIdx && paramType.equals(that.paramType);
}
@Override
public int hashCode() {
int result = paramType.hashCode();
return result;
}
package org.apache.bval.jsr;
import org.apache.bval.jsr.groups.Group;
import javax.validation.metadata.ParameterDescriptor;
void addGroupMapping(Group from, Group to);
Group mapGroup(Group current);
package org.apache.bval.jsr;
package org.apache.bval.jsr;
package org.apache.bval.jsr;
package org.apache.bval.jsr.groups;
import javax.validation.groups.Default;
public boolean equals(final Object o) {
return this == o || o instanceof Group && ObjectUtils.equals(group, ((Group) o).group);
package org.apache.bval.jsr.groups;
final List<Group> groups = new LinkedList<Group>();
final List<List<Group>> sequences = new LinkedList<List<Group>>();
package org.apache.bval.jsr.groups;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
public static final Class<?>[] DEFAULT_GROUP = new Class<?>[]{Default.class};
DEFAULT_GROUPS = new GroupsComputer().computeGroups(Arrays.asList(DEFAULT_GROUP));
private final Map<Class<?>, List<Group>> resolvedSequences = new ConcurrentHashMap<Class<?>, List<Group>>();
for (final Class<?> clazz : groups) {
if (clazz == null) {
throw new IllegalArgumentException("At least one group has to be specified.");
}
package org.apache.bval.jsr.resolver;
package org.apache.bval.jsr.resolver;
package org.apache.bval.jsr.resolver;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
import java.lang.annotation.ElementType;
import java.util.logging.Level;
import java.util.logging.Logger;
@Privilizing(@CallTo(Reflection.class))
private static final boolean LOG_FINEST = log.isLoggable(Level.FINEST);
"org.apache.bval.jsr.resolver.JPATraversableResolver";
final ClassLoader classLoader = Reflection.getClassLoader(DefaultTraversableResolver.class);
Reflection.getClass(classLoader, PERSISTENCE_UTIL_CLASSNAME);
if (LOG_FINEST) {
log.log(Level.FINEST, String.format("Found %s on classpath.", PERSISTENCE_UTIL_CLASSNAME));
}
} catch (final Exception e) {
if (LOG_FINEST) {
log.log(Level.FINEST, String.format("Instantiated an instance of %s.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME));
}
} catch (final Exception e) {
log.log(Level.WARNING, String.format("Unable to load or instantiate JPA aware resolver %s. All properties will per default be traversable.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME), e);
package org.apache.bval.jsr.resolver;
package org.apache.bval.jsr.resolver;
package org.apache.bval.jsr.util;
package org.apache.bval.jsr.util;
import org.apache.bval.jsr.ConstraintValidatorContextImpl;
import javax.validation.ElementKind;
node.setKind(ElementKind.PROPERTY);
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addNode(String name) {
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(String name) {
propertyPath.addNode(node);
node = new NodeImpl.PropertyNodeImpl(name);
node.setKind(ElementKind.PROPERTY);
return null;
}
public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext addBeanNode() {
propertyPath.addNode(node);
node = new NodeImpl((String) null);
node.setKind(ElementKind.BEAN);
return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
}
package org.apache.bval.jsr.util;
import org.apache.bval.jsr.ConstraintValidatorContextImpl;
import javax.validation.ElementKind;
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addNode(String name) {
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(String name) {
return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, name);
}
public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext addBeanNode() {
final NodeImpl node = new NodeImpl((String) null);
node.setKind(ElementKind.BEAN);
propertyPath.addNode(node);
return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
}
package org.apache.bval.jsr.util;
import org.apache.bval.jsr.ConstraintValidatorContextImpl;
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(String name) {
propertyPath.addProperty(name);
return new NodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath, node.getName());
}
public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext addBeanNode() {
return new LeafNodeBuilderCustomizableContextImpl(parent, messageTemplate, propertyPath);
}
package org.apache.bval.jsr.util;
return create();
public static PathImpl create() {
final PathImpl path = new PathImpl();
final NodeImpl node = new NodeImpl.BeanNodeImpl();
for (final Object aPath : path) {
nodeList.add(newNode(Node.class.cast(aPath)));
private static Node newNode(final Node cast) {
if (PropertyNode.class.isInstance(cast)) {
return new NodeImpl.PropertyNodeImpl(cast);
}
if (BeanNode.class.isInstance(cast)) {
return new NodeImpl.BeanNodeImpl(cast);
}
if (MethodNode.class.isInstance(cast)) {
return new NodeImpl.MethodNodeImpl(cast);
}
if (ConstructorNode.class.isInstance(cast)) {
return new NodeImpl.ConstructorNodeImpl(cast);
}
if (ConstructorNode.class.isInstance(cast)) {
return new NodeImpl.ConstructorNodeImpl(cast);
}
if (ReturnValueNode.class.isInstance(cast)) {
return new NodeImpl.ReturnValueNodeImpl(cast);
}
if (ParameterNode.class.isInstance(cast)) {
return new NodeImpl.ParameterNodeImpl(cast);
}
if (CrossParameterNode.class.isInstance(cast)) {
return new NodeImpl.CrossParameterNodeImpl(cast);
}
return new NodeImpl(cast);
}
if (!PropertyNode.class.isInstance(leaf)) {
final NodeImpl tmp = new NodeImpl.PropertyNodeImpl(leaf);
removeLeafNode();
addNode(tmp);
leaf = tmp;
}
final NodeImpl node;
if ("<cross-parameter>".equals(name)) {
node = new NodeImpl.CrossParameterNodeImpl();
} else {
node = new NodeImpl.PropertyNodeImpl(name);
}
addNode(node);
package org.apache.bval.jsr.util;
import javax.validation.ValidationException;
import java.io.StringWriter;
import java.text.ParsePosition;
package org.apache.bval.jsr.util;
public final class Proxies {
return clazz;
}
return classFor(clazz.getSuperclass());
private Proxies() {
package org.apache.bval.jsr.util;
import org.apache.bval.jsr.JsrMetaBeanFactory;
import org.apache.bval.jsr.UnknownPropertyException;
import org.apache.bval.jsr.util.PathNavigation.CallbackProcedure;
import java.lang.reflect.Type;
mp = JsrMetaBeanFactory.addMetaProperty(metaBean, access);
package org.apache.bval.jsr.xml;
import javax.validation.Valid;
final Map<String, Object> result = new HashMap<String, Object>();
for (final Method m : descriptor.getMethods()) {
if (processedValuesFromDescriptor != descriptor.size()
&& !Valid.class.equals(annotationType)) {
package org.apache.bval.jsr.xml;
import org.apache.bval.ConstructorAccess;
import java.lang.reflect.Constructor;
} else if (member instanceof Constructor<?>) {
return new ConstructorAccess((Constructor<?>) member);
public Integer getIndex() {
return index;
}
public void setIndex(final int index) {
this.index = index;
}
import org.apache.bval.jsr.example.Address;
import org.apache.bval.jsr.example.Author;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import org.apache.bval.jsr.example.ZipCodeCityCarrier;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.example;
package org.apache.bval.jsr.extensions;
package org.apache.bval.jsr.groups;
package org.apache.bval.jsr.groups;
package org.apache.bval.jsr.groups;
package org.apache.bval.jsr.groups;
package org.apache.bval.jsr.groups;
package org.apache.bval.jsr.groups;
package org.apache.bval.jsr.groups;
package org.apache.bval.jsr.groups;
package org.apache.bval.jsr.groups;
package org.apache.bval.jsr.groups;
package org.apache.bval.jsr.groups;
package org.apache.bval.jsr.groups.implicit;
package org.apache.bval.jsr.groups.implicit;
package org.apache.bval.jsr.groups.inheritance;
import org.apache.bval.jsr.groups.Billable;
import org.apache.bval.jsr.groups.BillableCreditCard;
package org.apache.bval.jsr.groups.inheritance;
import org.apache.bval.jsr.groups.Billable;
package org.apache.bval.jsr.groups.redefining;
import org.apache.bval.jsr.example.ZipCodeCityCarrier;
package org.apache.bval.jsr.groups.redefining;
package org.apache.bval.arquillian;
import org.jboss.arquillian.core.spi.LoadableExtension;
import org.jboss.arquillian.test.spi.TestEnricher;
public class BValArquillianExtension implements LoadableExtension {
public void register(final ExtensionBuilder builder) {
builder.service(TestEnricher.class, EJBEnricher.class);
}
import org.apache.bval.model.Features;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.model.Validation;
import org.apache.bval.model.ValidationContext;
import org.apache.bval.model.ValidationListener;
import org.apache.bval.xml.XMLMetaValue;
import java.util.Collection;
import java.util.Date;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.model.FeaturesCapable;
import org.apache.bval.model.MetaBean;
import org.apache.bval.model.MetaProperty;
import org.apache.bval.routines.StandardValidation;
import static org.apache.bval.model.Features.Property.JAVASCRIPT_VALIDATION_FUNCTIONS;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import com.thoughtworks.xstream.annotations.XStreamOmitField;
import org.apache.bval.model.Validation;
import org.apache.commons.lang3.ClassUtils;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
@Privilizing(@CallTo(Reflection.class))
addLoader(new XMLMetaBeanURLLoader(Reflection.getClassLoader(getClass()).getResource(resource)));
import static org.apache.bval.model.Features.Property.DENIED;
import static org.apache.bval.model.Features.Property.HIDDEN;
import static org.apache.bval.model.Features.Property.MANDATORY;
import static org.apache.bval.model.Features.Property.MAX_LENGTH;
import static org.apache.bval.model.Features.Property.MIN_LENGTH;
import static org.apache.bval.model.Features.Property.READONLY;
import static org.apache.bval.model.Features.Property.MAX_VALUE;
import static org.apache.bval.model.Features.Property.MIN_VALUE;
import static org.apache.bval.model.Features.Property.REG_EXP;
import static org.apache.bval.model.Features.Property.TIME_LAG;
}
<T> Set<javax.validation.ConstraintViolation<T>> validateProperty(T object, String propertyName,
<T> Set<javax.validation.ConstraintViolation<T>> validateValue(Class<T> beanType,
public Object construct(InvocationContext context) throws Exception {
public Object invoke(final InvocationContext context) throws Exception {
import org.apache.bval.jsr.groups.GroupsComputer;
import org.apache.bval.jsr.xml.AnnotationProxyBuilder;
import org.apache.bval.util.AccessStrategy;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.reflect.TypeUtils;
import org.apache.commons.weaver.privilizer.Privileged;
import javax.validation.Constraint;
import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintDefinitionException;
import javax.validation.ConstraintTarget;
import javax.validation.ConstraintValidator;
import javax.validation.OverridesAttribute;
import javax.validation.Payload;
import javax.validation.ReportAsSingleViolation;
import javax.validation.constraintvalidation.SupportedValidationTarget;
import javax.validation.constraintvalidation.ValidationTarget;
public AnnotationConstraintBuilder(
Class<? extends ConstraintValidator<A, ?>>[] validatorClasses, A annotation, Class<?> owner,
AccessStrategy access, ConstraintTarget target) {
new ConstraintValidation<A>(validatorClasses, annotation, owner, access, reportFromComposite,
private final ApacheValidatorFactory factory;
public AnnotationProcessor(ApacheValidatorFactory factory) {
this.factory = factory;
AccessStrategy access, AppendValidation appender, boolean reflection) throws IllegalAccessException,
factory.getConstraintsCache().getConstraintValidators(annotationType);
validatorClasses = factory.getDefaultConstraints().getValidatorClasses(annotationType);
private <A extends Annotation> boolean applyConstraint(
A annotation,
new AnnotationConstraintBuilder<A>(
constraintClasses,
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
private volatile MetaBeanFinder metaBeanFinder;
public ApacheFactoryContext(ApacheValidatorFactory factory, MetaBeanFinder metaBeanFinder) {
metaBeanFinder = factory.buildMetaBeanFinder();
}
resetMeta();
resetMeta();
resetMeta();
resetMeta();
import org.apache.bval.IntrospectorMetaBeanFactory;
import org.apache.bval.MetaBeanBuilder;
import org.apache.bval.MetaBeanFactory;
import org.apache.bval.MetaBeanFinder;
import org.apache.bval.MetaBeanManager;
import org.apache.bval.xml.XMLMetaBeanBuilder;
import org.apache.bval.xml.XMLMetaBeanFactory;
import org.apache.bval.xml.XMLMetaBeanManager;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.reflect.ConstructorUtils;
import org.apache.commons.weaver.privilizer.Privileged;
import java.lang.reflect.Constructor;
private final MetaBeanFinder defaultMetaBeanFinder;
protected MetaBeanFinder buildMetaBeanFinder() {
final List<MetaBeanFactory> builders = new ArrayList<MetaBeanFactory>();
if (Boolean.parseBoolean(getProperties().get(
ApacheValidatorConfiguration.Properties.ENABLE_INTROSPECTOR))) {
builders.add(new IntrospectorMetaBeanFactory());
}
final String[] factoryClassNames =
StringUtils.split(getProperties().get(
ApacheValidatorConfiguration.Properties.METABEAN_FACTORY_CLASSNAMES));
if (factoryClassNames != null) {
for (String clsName : factoryClassNames) {
@SuppressWarnings("unchecked")
final Class<? extends MetaBeanFactory> factoryClass = (Class<? extends MetaBeanFactory>) loadClass(clsName);
builders.add(createMetaBeanFactory(factoryClass));
}
}
boolean jsrFound = false;
for (MetaBeanFactory builder : builders) {
jsrFound |= builder instanceof JsrMetaBeanFactory;
}
if (!jsrFound) {
builders.add(new JsrMetaBeanFactory(this));
}
@SuppressWarnings("deprecation")
final boolean enableMetaBeansXml =
Boolean.parseBoolean(getProperties().get(
ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML));
if (enableMetaBeansXml) {
XMLMetaBeanManagerCreator.addFactory(builders);
}
return createMetaBeanManager(builders);
}
public ApacheValidatorFactory(ConfigurationState configuration) {
properties = new HashMap<String, String>(configuration.getProperties());
defaultMetaBeanFinder = buildMetaBeanFinder();
return new ApacheFactoryContext(this, defaultMetaBeanFinder);
@SuppressWarnings("deprecation")
protected MetaBeanFinder createMetaBeanManager(List<MetaBeanFactory> builders) {
if (Boolean.parseBoolean(getProperties().get(
ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML))) {
return XMLMetaBeanManagerCreator.createXMLMetaBeanManager(builders);
}
return new MetaBeanManager(new MetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
}
@Privileged
private <F extends MetaBeanFactory> F createMetaBeanFactory(final Class<F> cls) {
try {
Constructor<F> c = ConstructorUtils.getMatchingAccessibleConstructor(cls, ApacheValidatorFactory.this.getClass());
if (c != null) {
return c.newInstance(this);
}
c = ConstructorUtils.getMatchingAccessibleConstructor(cls, getClass());
if (c != null) {
return c.newInstance(this);
}
return cls.newInstance();
} catch (Exception e) {
throw new ValidationException(e);
}
}
private static class XMLMetaBeanManagerCreator {
static void addFactory(List<MetaBeanFactory> builders) {
builders.add(new XMLMetaBeanFactory());
}
protected static MetaBeanManager createXMLMetaBeanManager(List<MetaBeanFactory> builders) {
return new XMLMetaBeanManager(
new XMLMetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
}
}
private Class<?> loadClass(final String className) {
try {
return Class.forName(className, true, Reflection.getClassLoader(ApacheValidatorFactory.class));
} catch (ClassNotFoundException ex) {
}
}
this.annotationProcessor = new AnnotationProcessor(factoryContext.getFactory());
annotationProcessor.processAnnotation(
annotation, null, ClassUtils.primitiveToWrapper((Class<?>) access.getJavaType()),
access, validations, true);
new GroupValidationContextImpl<T>(listener, factoryContext.getMessageInterpolator(),
factoryContext.getTraversableResolver(), factoryContext.getParameterNameProvider(),
factoryContext.getConstraintValidatorFactory(), metaBean);
new GroupValidationContextImpl<T>(listener, factoryContext.getMessageInterpolator(),
factoryContext.getTraversableResolver(), factoryContext.getParameterNameProvider(),
factoryContext.getConstraintValidatorFactory(), metaBean);
public ConstraintValidation(Class<? extends ConstraintValidator<T, ?>>[] validatorClasses,
validator = getConstraintValidator(
context.getConstraintValidatorFactory(), annotation, validatorClasses, owner, access);
private <A extends Annotation> ConstraintValidator<A, ? super T> getConstraintValidator(
ConstraintValidatorFactory factory, A annotation,
import javax.validation.ConstraintValidatorFactory;
ConstraintValidatorFactory getConstraintValidatorFactory();
import javax.validation.ConstraintValidatorFactory;
private final ConstraintValidatorFactory constraintValidatorFactory;
TraversableResolver traversableResolver, ParameterNameProvider parameterNameProvider,
ConstraintValidatorFactory constraintValidatorFactory,
MetaBean rootMetaBean) {
this.constraintValidatorFactory = constraintValidatorFactory;
@Override
public ConstraintValidatorFactory getConstraintValidatorFactory() {
return constraintValidatorFactory;
}
protected final ApacheValidatorFactory factory;
public JsrMetaBeanFactory(ApacheValidatorFactory factory) {
this.factory = factory;
this.annotationProcessor = new AnnotationProcessor(factory);
if (!factory.getAnnotationIgnores().isIgnoreAnnotations(beanClass)) {
if (!factory.getAnnotationIgnores().isIgnoreAnnotations(field)) {
if (!factory.getAnnotationIgnores().isIgnoreAnnotations(method)) {
for (final MetaConstraint<?, ? extends Annotation> metaConstraint : factory.getMetaConstraints(beanClass)) {
for (final AccessStrategy access : factory.getValidAccesses(beanClass)) {
Class<?>[] groupClasses = factory.getDefaultSequence(beanClass);
if (loaded == null) {
} else {
if (target.getTraversableResolver() == target.getDefaultTraversableResolver() && traversableResolverClass != null) {
Class<TraversableResolver> clazz = (Class<TraversableResolver>)
loadClass(traversableResolverClass);
target.traversableResolverClass(clazz);
log.log(Level.INFO, String.format("Using %s as traversable resolver.", traversableResolverClass));
}
if (target.getConstraintValidatorFactory() == target.getDefaultConstraintValidatorFactory() && constraintFactoryClass != null) {
Class<ConstraintValidatorFactory> clazz = (Class<ConstraintValidatorFactory>)
loadClass(constraintFactoryClass);
target.constraintValidatorFactoryClass(clazz);
log.log(Level.INFO, String.format("Using %s as constraint factory.", constraintFactoryClass));
}
throw exceptions.iterator().next();
public final class AnnotationProxyBuilder<A extends Annotation> {
private synchronized void resetMeta() {
return getPropertyValue(PropertyAccess.getInstance(bean.getClass(), metaProperty.getName()));
context.moveDown(prop, PropertyAccess.getInstance(bean.getClass(), prop.getName()));
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.lang.reflect.Constructor;
import java.util.Collections;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.logging.Level;
import java.util.logging.Logger;
@Privilizing(@CallTo(Reflection.class))
private static final Logger log =  Logger.getLogger(PropertyAccess.class.getName());
private static final String BEANUTILS =
"org.apache.commons.beanutils.BeanUtils";
private static final String BEANUTILS_PROPERTY_ACCESS =
"org.apache.bval.util.BeanUtilsPropertyAccess";
private static final Constructor<? extends PropertyAccess> BEANUTILS_PROPERTY_ACCESS_CTOR;
private static final ConcurrentMap<Class<?>, Map<String, PropertyDescriptor>> PROPERTY_DESCRIPTORS =
new ConcurrentHashMap<Class<?>, Map<String, PropertyDescriptor>>();
static {
final ClassLoader cl = Reflection.getClassLoader(PropertyAccess.class);
boolean useBeanUtils;
try {
Reflection.getClass(cl, BEANUTILS);
useBeanUtils = true;
} catch (Exception e) {
useBeanUtils = false;
}
Constructor<? extends PropertyAccess> ctor;
if (useBeanUtils) {
try {
final Class<?> beanUtilsPropertyAccess =
Reflection.getClass(cl, BEANUTILS_PROPERTY_ACCESS);
ctor = Reflection.getDeclaredConstructor(
beanUtilsPropertyAccess.asSubclass(PropertyAccess.class),
Class.class, String.class);
} catch (Exception e) {
ctor = null;
}
} else {
ctor = null;
}
BEANUTILS_PROPERTY_ACCESS_CTOR = ctor;
}
public static PropertyAccess getInstance(Class<?> clazz,
String propertyName) {
if (BEANUTILS_PROPERTY_ACCESS_CTOR != null) {
try {
return BEANUTILS_PROPERTY_ACCESS_CTOR.newInstance(clazz,
propertyName);
} catch (Exception e) {
log.log(Level.WARNING,
String.format(
"Exception encountered attempting to instantiate %s(%s, %s)",
BEANUTILS_PROPERTY_ACCESS_CTOR, clazz, propertyName),
e);
}
}
return new PropertyAccess(clazz, propertyName);
}
@Deprecated
protected Object getPublicProperty(Object bean) throws InvocationTargetException,
return ((Map<?, ?>) bean).get(propertyName);
}
final Method readMethod =
getPropertyReadMethod(propertyName, bean.getClass());
if (readMethod == null) {
throw new NoSuchMethodException(toString());
}
final boolean unset = Reflection.setAccessible(readMethod, true);
try {
return readMethod.invoke(bean);
} finally {
if (unset) {
Reflection.setAccessible(readMethod, false);
}
public static Object getProperty(Object bean, String propertyName)
throws InvocationTargetException, NoSuchMethodException,
IllegalAccessException {
return getInstance(bean.getClass(), propertyName).get(bean);
private static Method getPropertyReadMethod(String propertyName,
Class<?> beanClass) {
final Map<String, PropertyDescriptor> propertyDescriptors =
getPropertyDescriptors(beanClass);
if (propertyDescriptors.containsKey(propertyName)) {
return propertyDescriptors.get(propertyName).getReadMethod();
return getPublicProperty(bean);
private static Map<String, PropertyDescriptor> getPropertyDescriptors(Class<?> type) {
if (PROPERTY_DESCRIPTORS.containsKey(type)) {
return PROPERTY_DESCRIPTORS.get(type);
}
Map<String, PropertyDescriptor> m;
try {
final PropertyDescriptor[] propertyDescriptors = Introspector.getBeanInfo(type).getPropertyDescriptors();
if (propertyDescriptors == null) {
m = Collections.emptyMap();
} else {
m = new HashMap<String, PropertyDescriptor>();
for (PropertyDescriptor pd : propertyDescriptors) {
m.put(pd.getName(), pd);
}
}
} catch (IntrospectionException e) {
log.log(Level.SEVERE, String.format("Cannot locate %s for ", BeanInfo.class.getSimpleName(), type), e);
m = Collections.emptyMap();
}
final Map<String, PropertyDescriptor> faster = PROPERTY_DESCRIPTORS.putIfAbsent(type, m);
return faster == null ? m : faster;
}
@Deprecated
import java.lang.annotation.ElementType;
private static class NullSafePropertyAccess extends AccessStrategy {
private final PropertyAccess wrapped;
wrapped = PropertyAccess.getInstance(clazz, propertyName);
return bean == null ? null : wrapped.get(bean);
}
@Override
public ElementType getElementType() {
return wrapped.getElementType();
}
@Override
public Type getJavaType() {
return wrapped.getJavaType();
}
@Override
public String getPropertyName() {
return wrapped.getPropertyName();
PropertyAccess access = PropertyAccess.getInstance(rawType, token);
if (returnType.equals(String.class)) {
return value;
}
ClassLoader cl = Reflection.getClassLoader(ValidationMappingParser.class);
try {
return Reflection.getClass(cl, toQualifiedClassName(value, defaultPackage));
} catch (Exception e) {
throw new ValidationException(e);
}
}
if (returnType.isEnum()) {
try {
@SuppressWarnings({ "rawtypes", "unchecked" })
final Enum e = Enum.valueOf(returnType.asSubclass(Enum.class), value);
return e;
} catch (IllegalArgumentException e) {
throw new ValidationException(e);
}
throw new ValidationException(String.format("Unknown annotation value type %s", returnType.getName()));
protected volatile MessageInterpolator messageInterpolator = defaultMessageInterpolator;
protected volatile ConstraintValidatorFactory constraintValidatorFactory = defaultConstraintValidatorFactory;
protected volatile TraversableResolver traversableResolver = defaultTraversableResolver;
protected volatile ParameterNameProvider parameterNameProvider = defaultParameterNameProvider;
private volatile ConstraintValidator<T, ?> validator;
useCdi = BValExtension.getBeanManager() != null;
if (useCdi) {
notNull("validated object", object);
notNull("validated object", object);
return validateValueImpl(notNull("bean type", beanType), null, propertyName, value, cascade, groups);
notNull("class", clazz);
for (final Class<?> c : notNull("groups", groups)) {
notNull("group", c);
notNull("Constructor", constructor);
notNull("Returned value", createdObject);
return validateReturnedValue(new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(), Arrays.asList(constructor.getParameterTypes())), createdObject, declaringClass, methodDescriptor, gps, null);
private <T> Set<ConstraintViolation<T>> validateReturnedValue(final NodeImpl rootNode, final T createdObject, final Class<?> clazz,
notNull("Object", object);
notNull("Parameters", parameterValues);
notNull("Method", method);
notNull("Groups", groups);
for (final Class<?> g : groups) {
notNull("Each group", g);
if (method.getParameterTypes().length == 0) {
checkValidationAppliesTo(Collections.singleton(methodDescriptor.getCrossParameterDescriptor()),
ConstraintTarget.PARAMETERS);
} else if (!Void.TYPE.equals(method.getReturnType())) {
checkValidationAppliesTo(Collections.singleton(methodDescriptor.getCrossParameterDescriptor()),
ConstraintTarget.IMPLICIT);
checkValidationAppliesTo(methodDescriptor.getParameterDescriptors(), ConstraintTarget.IMPLICIT);
private static <T> T notNull(final String entity, final T shouldntBeNull) {
return shouldntBeNull;
Set.class.cast(validateReturnedValue(
if (directValueClass.isArray()) {
return;
if (Collection.class.isAssignableFrom(directValueClass)) {
final Collection<?> coll = Collection.class.cast(context.getValidatedValue());
if (!coll.isEmpty()) {
context.setMetaBean(metaBeanFinder.findForClass(coll.iterator().next().getClass()));
return;
}
}
if (Map.class.isAssignableFrom(directValueClass)) {
final Map<?, ?> m = Map.class.cast(context.getValidatedValue());
if (!m.isEmpty()) {
context.setMetaBean(metaBeanFinder.findForClass(m.values().iterator().next().getClass()));
return;
}
}
context.setMetaBean(metaBeanFinder.findForClass(directValueClass));
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Deprecated
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
import org.apache.bval.model.Features.Bean;
Set<PropertyDescriptor> procedureDescriptors = metaBean.getFeature(Bean.PROPERTIES);
procedureDescriptors = metaBean.initFeature(Bean.PROPERTIES, procedureDescriptors);
ExecutableMeta executables = metaBean.getFeature(Bean.EXECUTABLES);
executables = metaBean.initFeature(Bean.EXECUTABLES, executables);
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
return new ConstraintFinderImpl(metaBean, new HashSet(constraintDescriptors));
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
import org.apache.bval.model.Features.Property;
@Override
if (metaProperty != null && metaProperty.getFeature(Property.REF_CASCADE) == null) {
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
final Class<Enum> enumClass = type;
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
@Override
context.buildConstraintViolationWithTemplate("city not OK").addPropertyNode("city").addConstraintViolation();
if (isProxyClass(clazz)) {
final Class<?> parent = clazz.getSuperclass();
if (parent != null) {
return classFor(clazz.getSuperclass());
}
return clazz;
}
private static boolean isProxyClass(Class<?> clazz) {
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
private static final Set<String> KNOWN_PROXY_CLASSNAMES;
static {
final Set<String> s = new HashSet<String>();
s.add("org.jboss.weld.bean.proxy.ProxyObject");
KNOWN_PROXY_CLASSNAMES = Collections.unmodifiableSet(s);
}
final String simpleName = clazz.getSimpleName();
if (KNOWN_PROXY_CLASSNAMES.contains(simpleName)) {
return true;
}
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
final String name = getPropertyName(m);
if (StringUtils.isNotEmpty(name)) {
if (!fields.containsKey(name)) {
private String getPropertyName(Method potentialAccessor) {
if (potentialAccessor.getParameterTypes().length == 0) {
final String name = potentialAccessor.getName();
if (Boolean.TYPE.equals(potentialAccessor.getReturnType())
&& potentialAccessor.getName().startsWith("is")) {
return Introspector.decapitalize(name.substring(2));
}
if (!Void.TYPE.equals(potentialAccessor.getReturnType())
&& potentialAccessor.getName().startsWith("get")) {
return Introspector.decapitalize(name.substring(3));
}
}
return null;
@Override
public int compare(final String o1, final String o2) {
final Integer i1 = fields.get(o1);
final Integer i2 = fields.get(o2);
if (i1 == null) {
if (i2 == null) {
return StringUtils.compare(o1, o2);
}
return -1;
if (i2 == null) {
return 1;
}
return i1.intValue() - i2.intValue();
if (KNOWN_PROXY_CLASSNAMES.contains(clazz.getName())) {
import javax.enterprise.util.AnnotationLiteral;
public static final class ValidAnnotation extends AnnotationLiteral<Valid> implements Valid {
private static final long serialVersionUID = 1L;
public static final ValidAnnotation INSTANCE = new ValidAnnotation();
public static final class ConvertGroupAnnotation extends AnnotationLiteral<ConvertGroup> implements ConvertGroup {
private static final long serialVersionUID = 1L;
@FrenchZipCode
String zipCode2 = "123456";
public String getZipCode2() {
return zipCode2;
}
public void setZipCode2(String zipCode2) {
this.zipCode2 = zipCode2;
}
private static String ATOM = "[^\\x00-\\x1F\\(\\)\\<\\>\\@\\,\\;\\:\\\\\\\"\\.\\[\\]\\s]";
public class AnyLiteral extends EmptyAnnotationLiteral<Any> implements Any {
public static class BValBindingLiteral extends EmptyAnnotationLiteral<BValBinding> implements BValBinding {
public String toString() {
return "@org.apache.bval.cdi.BValBinding()";
public class DefaultLiteral extends EmptyAnnotationLiteral<Default> implements Default {
import org.apache.bval.cdi.EmptyAnnotationLiteral;
public static final class ValidAnnotation extends EmptyAnnotationLiteral<Valid> implements Valid {
import org.apache.bval.util.reflection.Reflection;
return factories != null ? factories.clone() : null;
this.factories = factories != null ? factories.clone() : null;
return Reflection.toClass(className);
log.log(Level.FINE, String.format("Class not found: %s", className), e);
return enumConstants != null ? enumConstants.clone() : null;
target.validations = validations != null ? validations.clone() : null;
return validations != null ? validations.clone() : null;
this.validations = validations != null ? validations.clone() : null;
import java.util.HashSet;
import java.util.Set;
import org.apache.bval.util.ObjectUtils;
private Set<Annotation> annotations = new HashSet<Annotation>();
private Annotation[] annArray = null;
if (annArray == null) {
annArray = annotations.isEmpty() ? ObjectUtils.EMPTY_ANNOTATION_ARRAY : annotations.toArray(new Annotation[annotations.size()]);
}
return annArray;
this.annotations.add(annotation);
annArray = null;
if (name != null && !name.isEmpty()) {
return o1.compareTo(o2);
import org.apache.bval.util.reflection.TypeUtils;
import org.apache.bval.util.reflection.TypeUtils;
Type type = TypeUtils.unrollVariables(typeArguments, ITERABLE_TYPE);
return type != null ? type : Object.class;
import org.apache.bval.util.reflection.TypeUtils;
Reflection.toClass(BEANUTILS, cl);
Reflection.toClass(BEANUTILS_PROPERTY_ACCESS, cl);
import java.util.HashMap;
import java.util.Map;
private static final Object[][] NATIVE_CODES = new Object[][]{
{byte.class, "byte", "B"},
{char.class, "char", "C"},
{double.class, "double", "D"},
{float.class, "float", "F"},
{int.class, "int", "I"},
{long.class, "long", "J"},
{short.class, "short", "S"},
{boolean.class, "boolean", "Z"},
{void.class, "void", "V"}
};
private static final Map<Class<?>, Class<?>> PRIMITIVE_WRAPPER_MAP = new HashMap<Class<?>, Class<?>>();
static {
PRIMITIVE_WRAPPER_MAP.put(Boolean.TYPE, Boolean.class);
PRIMITIVE_WRAPPER_MAP.put(Byte.TYPE, Byte.class);
PRIMITIVE_WRAPPER_MAP.put(Character.TYPE, Character.class);
PRIMITIVE_WRAPPER_MAP.put(Short.TYPE, Short.class);
PRIMITIVE_WRAPPER_MAP.put(Integer.TYPE, Integer.class);
PRIMITIVE_WRAPPER_MAP.put(Long.TYPE, Long.class);
PRIMITIVE_WRAPPER_MAP.put(Double.TYPE, Double.class);
PRIMITIVE_WRAPPER_MAP.put(Float.TYPE, Float.class);
PRIMITIVE_WRAPPER_MAP.put(Void.TYPE, Void.TYPE);
}
public static Class<?> primitiveToWrapper(final Class<?> cls) {
Class<?> convertedClass = cls;
if (cls != null && cls.isPrimitive()) {
convertedClass = PRIMITIVE_WRAPPER_MAP.get(cls);
}
return convertedClass;
}
public static Class<?> wrapperToPrimitive(final Class<?> cls) {
for (Map.Entry<Class<?>, Class<?>> primitiveEntry : PRIMITIVE_WRAPPER_MAP.entrySet()) {
if (primitiveEntry.getValue().equals(cls)) {
return primitiveEntry.getKey();
}
}
return null;
public static Class<?> toClass(String className) throws ClassNotFoundException
{
ClassLoader cl = getClassLoader(Reflection.class);
return toClass(className, cl);
}
public static Class toClass(String className, ClassLoader loader) throws ClassNotFoundException {
return toClass(className, false, loader);
}
public static Class toClass(String className, boolean resolve, ClassLoader loader) throws ClassNotFoundException {
if (className == null) {
throw new NullPointerException("className == null");
}
int dims = 0;
while (className.endsWith("[]")) {
dims;
className = className.substring(0, className.length() - 2);
}
boolean primitive = false;
if (className.indexOf('.') == -1) {
if (NATIVE_CODES[i][1].equals(className)) {
if (dims == 0) {
return (Class) NATIVE_CODES[i][0];
}
className = (String) NATIVE_CODES[i][2];
primitive = true;
}
}
}
if (dims > 0) {
buf.append('[');
}
if (!primitive) {
buf.append('L');
}
buf.append(className);
if (!primitive) {
buf.append(';');
}
className = buf.toString();
}
if (loader == null) {
loader = Thread.currentThread().getContextClassLoader();
}
return Class.forName(className, resolve, loader);
}
import org.apache.bval.util.Validate;
import org.apache.bval.util.reflection.TypeUtils;
if (garr == null || garr.length == 0) {
import org.apache.bval.util.ObjectUtils;
if (ObjectUtils.arrayContains(strategies, access)) {
strategies = ObjectUtils.arrayAdd(strategies, access);
import org.apache.bval.util.reflection.Reflection;
validatorFactoryClass = Reflection.toClass(validatorFactoryClassname).asSubclass(ValidatorFactory.class);
import org.apache.bval.util.ObjectUtils;
import org.apache.bval.util.StringUtils;
return array == null || array.length == 0 ? ObjectUtils. EMPTY_CLASS_ARRAY : array.clone();
Constructor<F> c = Reflection.getDeclaredConstructor(cls, ApacheValidatorFactory.this.getClass());
c = Reflection.getDeclaredConstructor(cls, getClass());
annotation, null, Reflection.primitiveToWrapper((Class<?>) access.getJavaType()),
import org.apache.bval.util.ObjectUtils;
import org.apache.bval.util.reflection.TypeUtils;
Validation[] validations = meta.getValidations();
if (validations == null || validations.length == 0) {
import org.apache.bval.util.reflection.TypeUtils;
import org.apache.bval.util.StringUtils;
classes.add(Reflection.toClass(className.trim(), classloader));
if (this == o) { return true; }
if (o == null || getClass() != o.getClass()) { return false; }
ConstraintDescriptorImpl<?> that = (ConstraintDescriptorImpl<?>) o;
if (reportAsSingleViolation != that.reportAsSingleViolation) { return false; }
if (annotation != null ? !annotation.equals(that.annotation) : that.annotation != null) { return false; }
if (groups != null ? !groups.equals(that.groups) : that.groups != null) { return false; }
if (payload != null ? !payload.equals(that.payload) : that.payload != null) { return false; }
if (constraintValidatorClasses != null ? !constraintValidatorClasses.equals(that.constraintValidatorClasses) : that.constraintValidatorClasses != null) { return false; }
if (attributes != null ? !attributes.equals(that.attributes) : that.attributes != null) { return false; }
if (composingConstraints != null ? !composingConstraints.equals(that.composingConstraints) : that.composingConstraints != null) { return false; }
if (validationAppliesTo != that.validationAppliesTo) { return false; }
return template != null ? template.equals(that.template) : that.template == null;
int result = annotation != null ? annotation.hashCode() : 0;
return result;
import org.apache.bval.util.ObjectUtils;
import org.apache.bval.util.StringUtils;
import org.apache.bval.util.reflection.Reflection;
import org.apache.bval.util.reflection.TypeUtils;
this.validatorClasses = validatorClasses != null ? validatorClasses.clone() : null;
if (ObjectUtils.isNotEmpty(constraintClasses)) {
return type instanceof Class<?> ? Reflection.primitiveToWrapper((Class<?>) type) : type;
import java.util.Arrays;
resolvedParameterValue = Arrays.toString((Object[]) variable);
public boolean isDefault() {
return Default.class.equals(group);
}
public boolean equals(Object o) {
if (this == o) { return true; }
if (o == null || getClass() != o.getClass()) { return false; }
Group group1 = (Group) o;
return group != null ? group.equals(group1.group) : group1.group == null;
Reflection.toClass(PERSISTENCE_UTIL_CLASSNAME, classLoader);
(Class<? extends TraversableResolver>) Reflection.toClass(JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME, classLoader);
log.log(Level.WARNING, String.format("Unable to load or instantiate JPA aware resolver %s. All properties will per default be traversable.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME), e);
try {
int codePoints = org.apache.commons.lang3.StringEscapeUtils.UNESCAPE_JAVA.translate(path, here, w);
if (codePoints == 0) {
w.write(Character.toChars(Character.codePointAt(path, here)));
pos.next();
} else {
pos.plus(Character.charCount(Character.codePointAt(path, pos.getIndex())));
}
catch (Exception e) {
throw new RuntimeException("Java escaping in quotes is only supported with Apache commons-lang3 on the classpath!");
}
import org.apache.bval.util.ObjectUtils;
import org.apache.bval.util.reflection.TypeUtils;
import org.apache.bval.util.ObjectUtils;
import org.apache.bval.util.StringUtils;
return Reflection.toClass(toQualifiedClassName(value, defaultPackage), cl);
return ObjectUtils.EMPTY_CLASS_ARRAY;
import org.apache.bval.util.ObjectUtils;
return s == null || ObjectUtils.arrayContains(values, s);
import org.apache.bval.util.reflection.Reflection;
(Validation) Reflection.toClass(xv.getJava()).newInstance();
import org.apache.bval.util.reflection.Reflection;
public class BeanValidationContext<T extends ValidationListener> implements ValidationContext<T> {
protected <VL extends ValidationListener> void validateRelatedBean(ValidationContext<VL> context,
MetaProperty prop) {
private static final Logger log = Logger.getLogger(MetaBeanBuilder.class.getName());
@Target({ METHOD, FIELD, CONSTRUCTOR, PARAMETER })
annArray = annotations.isEmpty() ? ObjectUtils.EMPTY_ANNOTATION_ARRAY
: annotations.toArray(new Annotation[annotations.size()]);
} else {
copy.properties = new TreeMap<String, MetaProperty>();
public static void main(String[] args) {
throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {
private static final Logger log = Logger.getLogger(PropertyAccess.class.getName());
private static final String BEANUTILS = "org.apache.commons.beanutils.BeanUtils";
private static final String BEANUTILS_PROPERTY_ACCESS = "org.apache.bval.util.BeanUtilsPropertyAccess";
final Class<?> beanUtilsPropertyAccess = Reflection.toClass(BEANUTILS_PROPERTY_ACCESS, cl);
ctor = Reflection.getDeclaredConstructor(beanUtilsPropertyAccess.asSubclass(PropertyAccess.class),
public static PropertyAccess getInstance(Class<?> clazz, String propertyName) {
return BEANUTILS_PROPERTY_ACCESS_CTOR.newInstance(clazz, propertyName);
log.log(Level.WARNING, String.format("Exception encountered attempting to instantiate %s(%s, %s)",
BEANUTILS_PROPERTY_ACCESS_CTOR, clazz, propertyName), e);
protected Object getPublicProperty(Object bean)
throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {
final Method readMethod = getPropertyReadMethod(propertyName, bean.getClass());
throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {
private static Method getPropertyReadMethod(String propertyName, Class<?> beanClass) {
final Map<String, PropertyDescriptor> propertyDescriptors = getPropertyDescriptors(beanClass);
} else {
public static void validateContext(ValidationContext<?> context, ValidateCallback s, boolean treatMapsLikeBeans) {
protected static <VL extends ValidationListener> void validateBeanInContext(ValidationContext<VL> context,
ValidateCallback s) {
protected static <VL extends ValidationListener> void validateArrayInContext(ValidationContext<VL> context,
ValidateCallback s) {
protected static <VL extends ValidationListener> void validateIterableInContext(ValidationContext<VL> context,
ValidateCallback s) {
protected static <VL extends ValidationListener> void validateMapInContext(ValidationContext<VL> context,
ValidateCallback s) {
private static <VL extends ValidationListener> DynamicMetaBean getDynamicMetaBean(ValidationContext<VL> context) {
public static <VL extends ValidationListener> void validateBean(ValidationContext<VL> context) {
public static <VL extends ValidationListener> void validateProperty(ValidationContext<VL> context) {
@Constraint(validatedBy = ABANumberValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class ABANumberValidator extends ModulusValidator<ABANumber> {
private static final int[] POSITION_WEIGHT = new int[] { 3, 1, 7 };
protected int weightedValue(int charValue, int leftPos, int rightPos) throws Exception {
@Constraint(validatedBy = CUSIPValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class CUSIPValidator extends ModulusValidator<CUSIP> {
private static final int[] POSITION_WEIGHT = new int[] { 2, 1 };
protected int weightedValue(int charValue, int leftPos, int rightPos) throws Exception {
@Constraint(validatedBy = EAN13Validator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class EAN13Validator extends ModulusValidator<EAN13> {
private static final int[] POSITION_WEIGHT = new int[] { 3, 1 };
protected int weightedValue(int charValue, int leftPos, int rightPos) throws Exception {
@Constraint(validatedBy = IBANValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class IBANValidator implements ConstraintValidator<IBAN, String> {
public void initialize(IBAN iban) {
@Constraint(validatedBy = ISBN10Validator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class ISBN10Validator extends ModulusValidator<ISBN10> {
protected int weightedValue(int charValue, int leftPos, int rightPos) throws Exception {
@Constraint(validatedBy = LuhnValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class LuhnValidator extends ModulusValidator<Luhn> {
private static final int[] POSITION_WEIGHT = new int[] { 2, 1 };
protected int weightedValue(int charValue, int leftPos, int rightPos) throws Exception {
abstract class ModulusValidator<A extends Annotation> implements ConstraintValidator<A, String> {
protected abstract int weightedValue(int charValue, int leftPos, int rightPos) throws Exception;
todo = todo / 10;
@Constraint(validatedBy = SedolValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class SedolValidator extends ModulusValidator<Sedol> {
private static final int[] POSITION_WEIGHT = new int[] { 1, 3, 1, 7, 3, 9, 1 };
protected int weightedValue(int charValue, int leftPos, int rightPos) throws Exception {
protected int toInt(char character, int leftPos, int rightPos) {
@Constraint(validatedBy = VerhoeffValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
public final class VerhoeffValidator implements ConstraintValidator<Verhoeff, String> {
@Pattern(regexp = "^(3[47]\\d{13})$")
@Constraint(validatedBy = {})
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Pattern(regexp = "^(30[0-5]\\d{11}|3095\\d{10}|36\\d{12}|3[8-9]\\d{12})$")
@Constraint(validatedBy = {})
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Pattern(regexp = "^((6011\\d{12})|(64[4-9]\\d{13})|(65\\d{14}))$")
@Constraint(validatedBy = {})
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Pattern(regexp = "^(5[1-5]\\d{14})$")
@Constraint(validatedBy = {})
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Pattern(regexp = "^(4)(\\d{12}|\\d{15})$")
@Constraint(validatedBy = {})
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Constraint(validatedBy = DirectoryValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Constraint(validatedBy = DirectoryValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Constraint(validatedBy = SymlinkValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
@Constraint(validatedBy = DomainValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
private static final Pattern DOMAIN_NAME_REGEX =
return true;
return true;
return isValidInfrastructureTld(tld) || isValidGenericTld(tld) || isValidCountryCodeTld(tld);
);
@Constraint(validatedBy = InetAddressValidator.class)
@Target({ FIELD, ANNOTATION_TYPE, PARAMETER })
@Retention(RUNTIME)
private static final Pattern IPV4_PATTERN =
public String toJSON(Collection<MetaBean> metaBeans) throws IOException, TemplateException {
public void toJSON(Collection<MetaBean> metaBeans, Writer out) throws IOException, TemplateException {
@Target({ ElementType.TYPE })
globalExecutableTypes =
Collections.unmodifiableSet(convertToRuntimeTypes(bootstrap.getDefaultValidatedExecutableTypes()));
validBean = globalExecutableTypes.contains(ExecutableType.IMPLICIT)
|| globalExecutableTypes.contains(ExecutableType.ALL);
validGetterMethods = globalExecutableTypes.contains(ExecutableType.ALL)
|| globalExecutableTypes.contains(ExecutableType.GETTER_METHODS);
private static Set<ExecutableType> convertToRuntimeTypes(
final Set<ExecutableType> defaultValidatedExecutableTypes) {
|| hasValidationAnnotation(annotatedType.getMethods())
|| hasValidationAnnotation(annotatedType.getConstructors())
|| classConstraints != null && (validBean && classConstraints.isBeanConstrained()
|| validConstructors && !classConstraints.getConstrainedConstructors().isEmpty()
|| validBusinessMethods
&& !classConstraints.getConstrainedMethods(MethodType.NON_GETTER).isEmpty()
|| validGetterMethods
&& !classConstraints.getConstrainedMethods(MethodType.GETTER).isEmpty())) {
private static <A> boolean hasValidationAnnotation(
final Collection<? extends AnnotatedCallable<? super A>> methods) {
private Releasable(final CreationalContext<T> context, final InjectionTarget<T> injectionTarget,
final T instance) {
final MethodDescriptor constraintsForMethod = validator.getConstraintsForClass(targetClass)
.getConstraintsForMethod(method.getName(), method.getParameterTypes());
final AnnotatedType<?> annotatedType =
CDI.current().getBeanManager().createAnnotatedType(constructor.getDeclaringClass());
final ValidateOnExecution annotation = annotatedConstructor != null
? annotatedConstructor.getAnnotation(ValidateOnExecution.class) : targetClass
.getConstructor(constructor.getParameterTypes()).getAnnotation(ValidateOnExecution.class);
constructorValidated = types.contains(ExecutableType.CONSTRUCTORS)
|| types.contains(ExecutableType.IMPLICIT) || types.contains(ExecutableType.ALL);
ClassHelper.fillFullClassHierarchyAsList(new LinkedList<Class<?>>(), targetClass);
|| !asList(method.getGenericParameterTypes())
.equals(asList(m.getJavaMember().getGenericParameterTypes()))) {
final AnnotatedType<?> annotatedType =
CDI.current().getBeanManager().createAnnotatedType(targetClass);
return isGetter(method) ? config.contains(ExecutableType.GETTER_METHODS)
: config.contains(ExecutableType.NON_GETTER_METHODS);
}
injectionPoints = Collections.singleton(InjectionPoint.class
.cast(new BValInterceptorInjectionPoint(this, injectionTarget.getInjectionPoints().iterator().next())));
public abstract class EmptyAnnotationLiteral<T extends Annotation> extends AnnotationLiteral<T> {
protected EmptyAnnotationLiteral() {
public Class<? extends Annotation> annotationType() {
if (annotationType == null) {
public int hashCode() {
public boolean equals(final Object other) {
return Annotation.class.isInstance(other)
&& Annotation.class.cast(other).annotationType().equals(annotationType());
private Class<T> getAnnotationType(Class<?> definedClazz) {
if (superClazz.equals(Object.class)) {
} else if (superClazz instanceof ParameterizedType) {
if (actualArgs.length == 1) {
if (type instanceof Class) {
} else {
} else {
} else {
public class ValidatorBean implements Bean<Validator>, PassivationCapable {
public class ValidatorFactoryBean implements Bean<ValidatorFactory>, PassivationCapable {
}
@Target({ METHOD, FIELD, ANNOTATION_TYPE, PARAMETER })
@Constraint(validatedBy = { NotEmptyValidatorForCollection.class, NotEmptyValidatorForMap.class,
NotEmptyValidatorForString.class, NotEmptyValidator.class })
@Target({ METHOD, FIELD, ANNOTATION_TYPE, PARAMETER })
}
}
}
}
}
}
}
}
}
public String interpolate(final String message, final Map<String, Object> annotationParameters,
final Object validatedValue) {
variables.setVariable(var.getKey(),
EXPRESSION_FACTORY.createValueExpression(var.getValue(), Object.class));
variables.setVariable("validatedValue",
EXPRESSION_FACTORY.createValueExpression(validatedValue, Object.class));
return EXPRESSION_FACTORY.createValueExpression(context, message.replace("#{", "\\#{"), String.class)
.getValue(context).toString();
public Formatter format(final String format, final Object... args) {
public AnnotationConstraintBuilder(Class<? extends ConstraintValidator<A, ?>>[] validatorClasses, A annotation,
Class<?> owner, AccessStrategy access, ConstraintTarget target) {
new ConstraintValidation<A>(validatorClasses, annotation, owner, access, reportFromComposite, target);
throw new ConstraintDefinitionException(
if (!TypeUtils.isAssignable(method.getReturnType(),
ConstraintAnnotationAttributes.MESSAGE.getType())) {
throw new ConstraintDefinitionException("Return type for message() must be of type "
ConstraintAnnotationAttributes.MESSAGE.getType());
constraintValidation.getAttributes().put(name,
method.invoke(constraintValidation.getAnnotation()));
log.log(Level.WARNING,
String.format("Error processing annotation: %s ", constraintValidation.getAnnotation()), e);
throw new ConstraintDefinitionException(
throw new ConstraintDefinitionException(
|| (validationTarget.b > 0 && validationTargetInherited.a > 0 && validationTarget.a == 0)) {
final SupportedValidationTarget supportedAnnotationTypes =
validator.getAnnotation(SupportedValidationTarget.class);
throw new ConstraintDefinitionException(
"pure cross parameter constraints shouldn't get validationAppliesTo attribute");
throw new ConstraintDefinitionException(
"cross parameter AND generic constraints should get validationAppliesTo attribute");
throw new ConstraintDefinitionException(
"pure generic constraints shouldn't get validationAppliesTo attribute");
private void buildValidationAppliesTo(final Method method)
throws InvocationTargetException, IllegalAccessException {
if (!TypeUtils.isAssignable(method.getReturnType(),
ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getType())) {
throw new ConstraintDefinitionException(
throw new ConstraintDefinitionException(
throw new ConstraintDeclarationException(
", it needs a defined index when there is a list of constraints");
AccessStrategy access, AppendValidation appender, boolean reflection)
throws IllegalAccessException, InvocationTargetException {
private <A extends Annotation> boolean applyConstraint(A annotation,
new AnnotationConstraintBuilder<A>(constraintClasses, annotation, owner, access, null);
return Boolean
.parseBoolean(factory.getProperties().get(ApacheValidatorConfiguration.Properties.TREAT_MAPS_LIKE_BEANS));
validatorFactoryClass =
Reflection.toClass(validatorFactoryClassname).asSubclass(ValidatorFactory.class);
if (Boolean.parseBoolean(getProperties().get(ApacheValidatorConfiguration.Properties.ENABLE_INTROSPECTOR))) {
StringUtils.split(getProperties().get(ApacheValidatorConfiguration.Properties.METABEAN_FACTORY_CLASSNAMES));
final Class<? extends MetaBeanFactory> factoryClass =
(Class<? extends MetaBeanFactory>) loadClass(clsName);
Boolean.parseBoolean(getProperties().get(ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML));
public final void setTraversableResolver(TraversableResolver traversableResolver) {
public final void setConstraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory) {
if (!(type.isInterface() || Modifier.isAbstract(type.getModifiers()))) {
public void addMetaConstraint(final Class<?> beanClass, final MetaConstraint<?, ?> metaConstraint) {
public <T> List<MetaConstraint<T, ? extends Annotation>> getMetaConstraints(Class<T> beanClass) {
return array == null || array.length == 0 ? ObjectUtils.EMPTY_CLASS_ARRAY : array.clone();
if (Boolean.parseBoolean(getProperties().get(ApacheValidatorConfiguration.Properties.ENABLE_METABEANS_XML))) {
new XMLMetaBeanBuilder(builders.toArray(new MetaBeanFactory[builders.size()])));
private static final CopyOnWriteArraySet<ConstraintValidation<?>> NO_CONSTRAINTS =
new CopyOnWriteArraySet<ConstraintValidation<?>>();
edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()),
new Group(convertGroup.to())));
edesc.addGroupConversion(new GroupConversionDescriptorImpl(new Group(convertGroup.from()),
new Group(convertGroup.to())));
edesc.addGroupConversion(
new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
edesc.addGroupConversion(
new GroupConversionDescriptorImpl(new Group(convertGroup.from()), new Group(convertGroup.to())));
final MethodDescriptor methodDescriptor =
if (methodDescriptor != null
&& (methodDescriptor.hasConstrainedParameters() || methodDescriptor.hasConstrainedReturnValue())) {
private static Collection<MethodDescriptor> filter(final Set<MethodDescriptor> containedMethods,
final MethodType type) {
d.getParameterDescriptors().isEmpty() && (d.getName().startsWith("get") || (d.getName().startsWith("is")
&& boolean.class.equals(d.getReturnValueDescriptor().getElementClass())));
case GETTER:
if (getter) {
list.add(d);
}
break;
case NON_GETTER:
if (!getter) {
list.add(d);
}
private final Map<String, ConstructorDescriptor> contructorConstraints =
new HashMap<String, ConstructorDescriptor>();
private ExecutableMeta(final ApacheFactoryContext factoryContext, final MetaBean metaBean1,
final Collection<ConstraintDescriptor<?>> constraintDescriptors) {
final boolean isInnerClass = cons.getDeclaringClass().getEnclosingClass() != null
&& !Modifier.isStatic(cons.getDeclaringClass().getModifiers());
final ParameterDescriptorImpl paramDesc =
new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx));
consDesc.getParameterDescriptors()
.add(new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx)));
consDesc.addValidations(
processAnnotations(consDesc, paramAnnos, access, idx, names.get(idx)).getValidations());
if (annotationIgnores.isIgnoreAnnotationOnCrossParameter(cons)
&& consDesc.getCrossParameterDescriptor() != null) {
consDesc.setReturnValueDescriptor(
new ReturnValueDescriptorImpl(metaBean, returnType, NO_CONSTRAINTS, consDesc.isCascaded()));
final ReturnValueDescriptorImpl returnValueDescriptor =
ReturnValueDescriptorImpl.class.cast(consDesc.getReturnValueDescriptor());
private void processAnnotations(final Method mtd, final InvocableElementDescriptor consDesc,
final Class<?> clazz, final Annotation anno) throws InvocationTargetException, IllegalAccessException {
final List<ConstraintValidation<?>> list =
removeFromListValidationAppliesTo(validations.getValidations(), ConstraintTarget.PARAMETERS);
ReturnValueDescriptorImpl returnValueDescriptor =
ReturnValueDescriptorImpl.class.cast(consDesc.getReturnValueDescriptor());
if (mtd == null
|| !factoryContext.getFactory().getAnnotationIgnores().isIgnoreAnnotationOnCrossParameter(mtd)) {
final List<ConstraintValidation<?>> list =
removeFromListValidationAppliesTo(validations.getValidations(), ConstraintTarget.RETURN_VALUE);
CrossParameterDescriptorImpl.class.cast(consDesc.getCrossParameterDescriptor())
.getMutableConstraintDescriptors().addAll(list);
private static List<ConstraintValidation<?>> removeFromListValidationAppliesTo(
final List<ConstraintValidation<?>> validations, final ConstraintTarget constraint) {
final List<Class<?>> classHierarchy =
ClassHelper.fillFullClassHierarchyAsList(new ArrayList<Class<?>>(), current);
final boolean propertyAccessor = method.getParameterTypes().length == 0
&& (method.getName().startsWith("get") && !Void.TYPE.equals(method.getReturnType())
|| method.getName().startsWith("is") && Boolean.TYPE.equals(method.getReturnType()));
final Method overridden =
Reflection.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
final MethodDescriptor parentDec =
factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass())
.getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
ensureNoParameterConstraint(InvocableElementDescriptor.class.cast(parentDec),
"Parameter constraints can't be defined for parallel interfaces/parents");
ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDec,
"Return value constraints should be the same for parent and children");
final MethodDescriptor parentDesc =
factoryContext.getValidator().getConstraintsForClass(parent.getDeclaringClass())
.getConstraintsForMethod(parent.getName(), parent.getParameterTypes());
ensureNoReturnValueAddedInChild(methodDesc.getReturnValueDescriptor(), parentDesc,
"Return value constraints should be at least the same for parent and children");
final Iterator<ParameterDescriptor> parentPd =
parentDesc.getParameterDescriptors().iterator();
throw new ConstraintDeclarationException(
"child shouldn't get more constraint than parent");
throw new ConstraintDeclarationException(
"child shouldn't get more constraint than parent");
ensureNoConvertGroup(itfWithThisMethod.iterator().next(),
"ConvertGroup can't be used in interface AND parent class");
final Method overridden =
Reflection.getDeclaredMethod(clazz, method.getName(), method.getParameterTypes());
if (returnValid > 1
&& !(interfaces.length == returnValid && method.getAnnotation(Valid.class) == null)) {
throw new ConstraintDeclarationException(
"@Valid on returned value can't be set more than once");
final MetaProperty prop =
metaBean.getProperty(Introspector.decapitalize(method.getName().substring(3)));
final BeanDescriptorImpl desc =
BeanDescriptorImpl.class.cast(factoryContext.getValidator().getConstraintsForClass(parent));
private void ensureNoReturnValueAddedInChild(final ReturnValueDescriptor returnValueDescriptor,
final MethodDescriptor parentMtdDesc, final String msg) {
if (parentReturnDesc.isCascaded() && !returnValueDescriptor.isCascaded() || parentReturnDesc
.getConstraintDescriptors().size() > returnValueDescriptor.getConstraintDescriptors().size()) {
private static void ensureNoParameterConstraint(final InvocableElementDescriptor constraintsForMethod,
final String msg) {
private void processMethod(final Method method, final MethodDescriptorImpl methodDesc)
throws InvocationTargetException, IllegalAccessException {
final ParameterDescriptorImpl parameterDescriptor =
new ParameterDescriptorImpl(metaBean, EMPTY_VALIDATION, names.get(idx));
if (annotationIgnores.isIgnoreAnnotationOnCrossParameter(method)
&& methodDesc.getCrossParameterDescriptor() != null) {
private AppendValidationToList processAnnotations(InvocableElementDescriptor methodDesc,
Annotation[] paramAnnos, AccessStrategy access, int idx, String name)
from = new Group[] { new Group(cg.from()) };
to = new Group[] { new Group(cg.to()) };
if (existing.getAnnotation().annotationType()
final AccessStrategy access, final AppendValidation validations)
throws InvocationTargetException, IllegalAccessException {
desc.addGroupConversion(
new GroupConversionDescriptorImpl(new Group(cg.from()), new Group(cg.to())));
private <A extends Annotation> void processConstraint(final A annotation, final InvocableElementDescriptor desc,
final AccessStrategy access, final AppendValidation validations)
final ConstraintAnnotationAttributes.Worker<? extends Annotation> worker =
ConstraintAnnotationAttributes.VALUE.analyze(annotation.annotationType());
annotationProcessor.processAnnotation(annotation, null,
Reflection.primitiveToWrapper((Class<?>) access.getJavaType()), access, validations, true);
final String constraintValidatorFactoryClassName, final String messageInterpolatorClassName,
final String traversableResolverClassName, final String parameterNameProviderClassName,
final Set<String> constraintMappingResourcePaths, final boolean executableValidationEnabled,
final Set<ExecutableType> defaultValidatedExecutableTypes, final Map<String, String> properties) {
<T> Set<javax.validation.ConstraintViolation<T>> validateProperty(T object, String propertyName, boolean cascade,
Class<?>... groups);
<T> Set<javax.validation.ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value,
boolean cascade, Class<?>... groups);
private <T> Set<ConstraintViolation<T>> validateBeanWithGroups(final GroupValidationContext<T> context,
final Groups sequence) {
final List<Group> ownerDefaultGroups =
final Groups propertyGroup = groupsComputer.computeGroups(new Class<?>[] { mappedGroup.getGroup() });
for (final PropertyDescriptor prop : getConstraintsForClass(context.getMetaBean().getBeanClass())
.getConstrainedProperties()) {
checkValidationAppliesTo(constraintValidation.getValidationAppliesTo(),
ConstraintTarget.PARAMETERS);
checkValidationAppliesTo(constraintValidation.getValidationAppliesTo(),
ConstraintTarget.RETURN_VALUE);
private void validateCascadedBean(final GroupValidationContext<?> context, final MetaProperty prop,
final Groups groups) {
ValidationHelper.validateContext(context, new JsrValidationCallback(context),
factoryContext.isTreatMapsLikeBeans());
protected <T> GroupValidationContext<T> createContext(MetaBean metaBean, T object, Class<T> objectClass,
Class<?>... groups) {
final GroupValidationContextImpl<T> context = new GroupValidationContextImpl<T>(listener,
factoryContext.getMessageInterpolator(), factoryContext.getTraversableResolver(),
factoryContext.getParameterNameProvider(), factoryContext.getConstraintValidatorFactory(), metaBean);
protected <T> GroupValidationContext<T> createInvocableContext(MetaBean metaBean, T object, Class<T> objectClass,
Class<?>... groups) {
final GroupValidationContextImpl<T> context = new GroupValidationContextImpl<T>(listener,
factoryContext.getMessageInterpolator(), factoryContext.getTraversableResolver(),
factoryContext.getParameterNameProvider(), factoryContext.getConstraintValidatorFactory(), metaBean);
if (Collections.singletonList(Group.DEFAULT).equals(computedGroup.getGroups())
&& metaBean.getFeature(JsrFeatures.Bean.GROUP_SEQUENCE) != null) {
final List<? extends Group> sequenceGroups =
List.class.cast(metaBean.getFeature(JsrFeatures.Bean.GROUP_SEQUENCE));
public <T> Set<ConstraintViolation<T>> validateConstructorParameters(Constructor<? extends T> constructor,
Object[] parameterValues, Class<?>... gps) {
final ConstructorDescriptorImpl constructorDescriptor = ConstructorDescriptorImpl.class
.cast(getConstraintsForClass(declaringClass).getConstraintsForConstructor(constructor.getParameterTypes()));
checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()),
ConstraintTarget.PARAMETERS);
checkValidationAppliesTo(Collections.singleton(constructorDescriptor.getCrossParameterDescriptor()),
ConstraintTarget.IMPLICIT);
return validateInvocationParameters(constructor, parameterValues, constructorDescriptor, gps,
new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(),
Arrays.asList(constructor.getParameterTypes())),
null);
private <T> Set<ConstraintViolation<T>> validateInvocationParameters(final Member invocable,
final Object[] parameterValues, final InvocableElementDescriptor constructorDescriptor, final Class<?>[] gps,
final NodeImpl rootNode, final Object rootBean) {
final GroupValidationContext<ConstraintValidationListener<?>> parametersContext = createInvocableContext(
constructorDescriptor.getMetaBean(), rootBean, Class.class.cast(invocable.getDeclaringClass()), gps);
final GroupValidationContext<Object> crossParameterContext = createContext(constructorDescriptor.getMetaBean(),
rootBean, Class.class.cast(invocable.getDeclaringClass()), gps);
final ElementDescriptorImpl crossParamDescriptor =
ElementDescriptorImpl.class.cast(constructorDescriptor.getCrossParameterDescriptor());
final ParameterDescriptorImpl paramDesc =
ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
if (gps.length == 0 && parametersContext.getListener().getConstraintViolations().size()
crossParameterContext.getListener().getConstraintViolations().size() > 0) {
final ParameterDescriptorImpl paramDesc =
ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
ValidationHelper.validateContext(parametersContext, new JsrValidationCallback(parametersContext),
factoryContext.isTreatMapsLikeBeans());
final ParameterDescriptorImpl paramDesc =
ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
final ConstraintValidation<?> validation =
ConstraintValidation.class.cast(constraintDescriptor);
if (parametersContext.getListener().getConstraintViolations().size()
crossParameterContext.getListener().getConstraintViolations().size() > 0) {
final ParameterDescriptorImpl paramDesc =
ParameterDescriptorImpl.class.cast(parameterDescriptors.get(i));
initMetaBean(parametersContext, factoryContext.getMetaBeanFinder(),
parameterValues[i].getClass());
ValidationHelper.validateContext(parametersContext,
new JsrValidationCallback(parametersContext), factoryContext.isTreatMapsLikeBeans());
initMetaBean(parametersContext, factoryContext.getMetaBeanFinder(),
parametersContext.getValidatedValue().getClass());
ValidationHelper.validateContext(parametersContext, new JsrValidationCallback(parametersContext),
factoryContext.isTreatMapsLikeBeans());
ValidationHelper.validateContext(parametersContext,
new JsrValidationCallback(parametersContext), factoryContext.isTreatMapsLikeBeans());
initMetaBean(crossParameterContext, factoryContext.getMetaBeanFinder(),
crossParameterContext.getValidatedValue().getClass());
ValidationHelper.validateContext(crossParameterContext,
new JsrValidationCallback(crossParameterContext), factoryContext.isTreatMapsLikeBeans());
ValidationHelper.validateContext(crossParameterContext,
new JsrValidationCallback(crossParameterContext), factoryContext.isTreatMapsLikeBeans());
final Set<ConstraintViolation<T>> parameterViolations =
Set.class.cast(parametersContext.getListener().getConstraintViolations());
final Set<ConstraintViolation<T>> crossParameterViolations =
Set.class.cast(crossParameterContext.getListener().getConstraintViolations());
private static void checkValidationAppliesTo(final Collection<? extends ElementDescriptor> descriptors,
final ConstraintTarget forbidden) {
private static void checkValidationAppliesTo(final Set<ConstraintDescriptor<?>> constraintDescriptors,
final ConstraintTarget forbidden) {
public <T> Set<ConstraintViolation<T>> validateConstructorReturnValue(final Constructor<? extends T> constructor,
final T createdObject, final Class<?>... gps) {
final ConstructorDescriptorImpl methodDescriptor = ConstructorDescriptorImpl.class
.cast(getConstraintsForClass(declaringClass).getConstraintsForConstructor(constructor.getParameterTypes()));
return validateReturnedValue(
new NodeImpl.ConstructorNodeImpl(declaringClass.getSimpleName(),
Arrays.asList(constructor.getParameterTypes())),
createdObject, declaringClass, methodDescriptor, gps, null);
private <T> Set<ConstraintViolation<T>> validateReturnedValue(final NodeImpl rootNode, final T createdObject,
final Class<?> clazz, final InvocableElementDescriptor methodDescriptor, final Class<?>[] gps,
final Object rootBean) {
final ElementDescriptorImpl returnedValueDescriptor =
ElementDescriptorImpl.class.cast(methodDescriptor.getReturnValueDescriptor());
final Set<ConstraintDescriptor<?>> returnedValueConstraints =
returnedValueDescriptor.getConstraintDescriptors();
final GroupValidationContext<T> context = createInvocableContext(methodDescriptor.getMetaBean(), createdObject,
Class.class.cast(Proxies.classFor(clazz)), gps);
ValidationHelper.validateContext(context, new JsrValidationCallback(context),
factoryContext.isTreatMapsLikeBeans());
ValidationHelper.validateContext(context, new JsrValidationCallback(context),
factoryContext.isTreatMapsLikeBeans());
public <T> Set<ConstraintViolation<T>> validateParameters(T object, Method method, Object[] parameterValues,
Class<?>... groups) {
if (methodDescriptor == null
public <T> Set<ConstraintViolation<T>> validateReturnValue(T object, Method method, Object returnValue,
Class<?>... groups) {
checkValidationAppliesTo(methodDescriptor.getReturnValueDescriptor().getConstraintDescriptors(),
ConstraintTarget.RETURN_VALUE);
final Set<ConstraintViolation<T>> result = Set.class.cast(validateReturnedValue(
new NodeImpl.MethodNodeImpl(method.getName(), Arrays.asList(method.getParameterTypes())), returnValue,
object.getClass(), methodDescriptor, groups, object));
return MethodDescriptorImpl.class
.cast(BeanDescriptorImpl.class.cast(getConstraintsForClass(Proxies.classFor(method.getDeclaringClass())))
private <T> void initMetaBean(final GroupValidationContext<T> context, final MetaBeanFinder metaBeanFinder,
final Class<?> directValueClass) {
protected BootstrapConfiguration bootstrapConfiguration;
private Collection<BValExtension.Releasable<?>> releasables =
new CopyOnWriteArrayList<BValExtension.Releasable<?>>();
public ConfigurationImpl constraintValidatorFactory(ConstraintValidatorFactory constraintFactory) {
return doBuildValidatorFactory();
return ValidationParser.processValidationConfig(getProperties().get(Properties.VALIDATION_XML_PATH), this,
ignoreXmlConfiguration);
if (constraintValidatorFactory == defaultConstraintValidatorFactory
&& constraintValidatorFactoryClass != null) {
if (constraintValidatorFactory == defaultConstraintValidatorFactory
&& constraintValidatorFactoryClass != null) {
}
private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Method>> METHOD_BY_NAME_AND_CLASS =
new ConcurrentHashMap<Class<?>, ConcurrentMap<String, Method>>();
Class<A> annotationType) {
this(descriptor.getAnnotation(), descriptor.getGroups(), descriptor.getPayload(),
descriptor.getConstraintValidatorClasses(), descriptor.getAttributes(),
descriptor.getComposingConstraints(), descriptor.isReportAsSingleViolation(),
descriptor.getValidationAppliesTo(), descriptor.getMessageTemplate());
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
if (reportAsSingleViolation != that.reportAsSingleViolation) {
return false;
}
if (annotation != null ? !annotation.equals(that.annotation) : that.annotation != null) {
return false;
}
if (groups != null ? !groups.equals(that.groups) : that.groups != null) {
return false;
}
if (payload != null ? !payload.equals(that.payload) : that.payload != null) {
return false;
}
if (constraintValidatorClasses != null ? !constraintValidatorClasses.equals(that.constraintValidatorClasses)
: that.constraintValidatorClasses != null) {
return false;
}
if (attributes != null ? !attributes.equals(that.attributes) : that.attributes != null) {
return false;
}
if (composingConstraints != null ? !composingConstraints.equals(that.composingConstraints)
: that.composingConstraints != null) {
return false;
}
if (validationAppliesTo != that.validationAppliesTo) {
return false;
}
for (Group defaultGroupMember : metaBean.<List<Group>> getFeature(JsrFeatures.Bean.GROUP_SEQUENCE)) {
if (findInScopes.size() == Scope.values().length) {
case LOCAL_ELEMENT:
if (isOwner) {
return true;
}
break;
case HIERARCHY:
if (!isOwner) {
return true;
}
break;
public ConstraintValidation(Class<? extends ConstraintValidator<T, ?>>[] validatorClasses, T annotation,
Class<?> owner, AccessStrategy access, boolean reportFromComposite, ConstraintTarget target) {
validator = getConstraintValidator(context.getConstraintValidatorFactory(), annotation,
validatorClasses, owner, access);
ConstraintValidatorFactory factory, A annotation,
final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validatorTypes =
getValidatorsTypes(constraintClasses);
final Collection<Class<? extends ConstraintValidator<A, ?>>> key =
validatorTypes.get(assignableTypes.get(0));
final ConstraintValidator<A, ? super T> validator =
(ConstraintValidator<A, ? super T>) factory.getInstance(key.iterator().next());
private <A extends Annotation> void reduceTarget(
final Map<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> validator,
final AccessStrategy access) {
for (final Map.Entry<Type, Collection<Class<? extends ConstraintValidator<A, ?>>>> entry : validator
.entrySet()) {
final boolean isParameter =
ParameterAccess.class.isInstance(access) || ParametersAccess.class.isInstance(access);
throw new UnexpectedTypeException(
String.format("Ambiguous validators for type %s. See: @%s at %s. Validators are: %s",
stringForType(targetType), anno.annotationType().getSimpleName(), stringForLocation(owner, access),
StringUtils.join(types, ", ")));
: ((Class<?>) clazz).getName();
Type validatedType = TypeUtils.getTypeArguments(validatorType, ConstraintValidator.class)
.get(ConstraintValidator.class.getTypeParameters()[1]);
throw new ConstraintDefinitionException(
annotation.annotationType().getCanonicalName(),
e);
return validatorClasses == null ? Collections.<Class<? extends ConstraintValidator<T, ?>>> emptyList()
: Arrays.asList(validatorClasses);
private void addError(String messageTemplate, Path propPath, ValidationContext<?> context) {
gcontext.getMessageResolver().interpolate(messageTemplate, (MessageInterpolator.Context) gcontext);
} else {
message = gcontext.getMessageResolver().interpolate(messageTemplate, null);
if (propPath == null)
propPath = gcontext.getPropertyPath();
if (context.getMetaProperty() == null)
value = context.getBean();
else
value = context.getPropertyValue();
&& (ElementKind.CROSS_PARAMETER.equals(elementKind) || ElementKind.PARAMETER.equals(elementKind))
constraintViolations.add(new ConstraintViolationImpl<T>(messageTemplate, message, rootBean, leaf, propPath,
value, descriptor, rootBeanType, elementType, returnValue, parameters));
if (endOutMostReportAsSingle) {
private final List<ValidationListener.Error> errorMessages = new LinkedList<ValidationListener.Error>();
ConstraintValidation<?> aConstraintValidation) {
public ConstraintViolationBuilder buildConstraintViolationWithTemplate(String messageTemplate) {
implements ConstraintValidatorContext.ConstraintViolationBuilder {
ConstraintViolationBuilderImpl(ConstraintValidatorContextImpl contextImpl, String template, PathImpl path) {
final List<String> parameters =
parent.validationContext.getParameterNameProvider().getParameterNames(method);
"At least one custom message must be created if the default error message gets disabled.");
List<ValidationListener.Error> returnedErrorMessages = new ArrayList<ValidationListener.Error>(errorMessages);
returnedErrorMessages.add(new ValidationListener.Error(getDefaultConstraintMessageTemplate(),
validationContext.getPropertyPath(), null));
Path propertyPath, Object value, ConstraintDescriptor<?> constraintDescriptor, Class<T> rootBeanClass,
ElementType elementType, Object returnValue, Object[] parameters) {
if (this == o)
return true;
if (o == null || getClass() != o.getClass())
return false;
if (constraintDescriptor != null ? !constraintDescriptor.equals(that.constraintDescriptor)
: that.constraintDescriptor != null)
if (elementType != that.elementType)
return false;
if (leafBean != null ? !leafBean.equals(that.leafBean) : that.leafBean != null)
return false;
if (message != null ? !message.equals(that.message) : that.message != null)
return false;
if (!Arrays.equals(parameters, that.parameters))
return false;
if (propertyPath != null ? !propertyPath.equals(that.propertyPath) : that.propertyPath != null)
return false;
if (returnValue != null ? !returnValue.equals(that.returnValue) : that.returnValue != null)
return false;
if (rootBean != null ? !rootBean.equals(that.rootBean) : that.rootBean != null)
return false;
if (value != null ? !value.equals(that.value) : that.value != null)
return false;
implements ConstructorDescriptor, ProcedureDescriptor {
private final Collection<BValExtension.Releasable<?>> releasables =
new CopyOnWriteArrayList<BValExtension.Releasable<?>>();
private final Map<Locale, ResourceBundle> userBundlesMap = new ConcurrentHashMap<Locale, ResourceBundle>();
ev = MessageEvaluator.class
.cast(getClass().getClassLoader().loadClass("org.apache.bval.el.ELFacade").newInstance());
return interpolateMessage(message, context.getConstraintDescriptor().getAttributes(), locale,
context.getValidatedValue());
private String interpolateMessage(String message, Map<String, Object> annotationParameters, Locale locale,
Object validatedValue) {
userBundleResolvedMessage = replaceVariables(resolvedMessage, userResourceBundle, locale, true);
if (evaluatedDefaultBundleOnce && !hasReplacementTakenPlace(userBundleResolvedMessage, resolvedMessage)) {
resolvedMessage = replaceVariables(userBundleResolvedMessage, defaultResourceBundle, locale, false);
resolvedMessage =
resolvedMessage.replace("\\{", "{").replace("\\}", "}").replace("\\\\", "\\").replace("\\$", "$");
rb = loadBundle(getClass().getClassLoader(), locale,
log.log(Level.FINEST, String.format("%s not found. Delegating to %s", USER_VALIDATION_MESSAGES,
DEFAULT_VALIDATION_MESSAGES));
private ResourceBundle loadBundle(ClassLoader classLoader, Locale locale, String message) {
private String replaceVariables(String message, ResourceBundle bundle, Locale locale, boolean recurse) {
private String replaceAnnotationAttributes(final String message, final Map<String, Object> annotationParameters) {
private String resolveParameter(String parameterName, ResourceBundle bundle, Locale locale, boolean recurse) {
if (bundle == null) {
if (bundle == null) {
private static final String SPI_CFG = "META-INF/services/javax.validation.spi.ValidationProvider";
providers
.add(Reflection.newInstance(providerType.asSubclass(ValidationProvider.class)));
throw new ValidationException(
private final Set<GroupConversionDescriptor> groupConversions =
new CopyOnWriteArraySet<GroupConversionDescriptor>();
@SuppressWarnings({ "unchecked", "rawtypes" })
return constraintDescriptors.isEmpty() ? Collections.<ConstraintDescriptor<?>> emptySet()
: Collections.unmodifiableSet(constraintDescriptors);
public interface GroupValidationContext<T> extends ValidationContext<ConstraintValidationListener<T>> {
final class GroupValidationContextImpl<T> extends BeanValidationContext<ConstraintValidationListener<T>>
implements GroupValidationContext<T>, MessageInterpolator.Context {
TraversableResolver traversableResolver, ParameterNameProvider parameterNameProvider,
ConstraintValidatorFactory constraintValidatorFactory, MetaBean rootMetaBean) {
private static final CopyOnWriteArraySet<ConstraintValidation<?>> NO_CONSTRAINTS =
new CopyOnWriteArraySet<ConstraintValidation<?>>();
protected InvocableElementDescriptor(final MetaBean metaBean, final Class<?> elementClass,
final Validation[] validations) {
return getReturnValueDescriptor().isCascaded()
|| !getReturnValueDescriptor().getConstraintDescriptors().isEmpty();
private void processClass(Class<?> beanClass, MetaBean metabean)
throws IllegalAccessException, InvocationTargetException {
annotationProcessor.processAnnotations(null, beanClass, beanClass, null,
new AppendValidationToMeta(metabean));
private void addXmlConstraints(Class<?> beanClass, MetaBean metabean)
throws IllegalAccessException, InvocationTargetException {
} else if (access.getElementType() == ElementType.METHOD
} else if (access.getElementType() == ElementType.CONSTRUCTOR) {
groupSeq =
metabean.initFeature(key, new ArrayList<Group>(annotation == null ? 1 : annotation.value().length));
log.log(Level.FINEST,
String.format("Default group sequence for bean %s is: %s", beanClass.getName(), groupSeq));
public class MethodDescriptorImpl extends InvocableElementDescriptor
implements javax.validation.metadata.MethodDescriptor, ProcedureDescriptor {
public class NodeBuilderCustomizableContextImpl
implements ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext {
public NodeBuilderCustomizableContextImpl(final ConstraintValidatorContextImpl parent, final String messageTemplate,
final PathImpl propertyPath) {
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(
String name) {
public class NodeContextBuilderImpl
implements ConstraintValidatorContext.ConstraintViolationBuilder.NodeContextBuilder {
public NodeContextBuilderImpl(final ConstraintValidatorContextImpl context, final String template,
final PathImpl path) {
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(
String name) {
public ParameterAccess(Type paramType, int paramIdx) {
if (this == o)
return true;
if (o == null || getClass() != o.getClass())
return false;
private final Set<GroupConversionDescriptor> groupConversions =
new CopyOnWriteArraySet<GroupConversionDescriptor>();
public ReturnValueDescriptorImpl(final MetaBean metaBean, Class<?> returnType,
final Collection<ConstraintValidation<?>> list, boolean cascaded) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
private void ensureExpandable(List<Group> groupList, List<Group> defaultGroupList, int defaultGroupIndex) {
if ((i == 0 && index == defaultGroupIndex - 1)
throw new GroupDefinitionException(
public static final Class<?>[] DEFAULT_GROUP = new Class<?>[] { Default.class };
Set<Class<?>> processedSequences) {
return !(resolver instanceof CachingRelevant) || ((CachingRelevant) resolver).needsCaching();
public boolean isReachable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
Path pathToTraversableObject, ElementType elementType) {
CacheEntry currentLH =
new CacheEntry(traversableObject, traversableProperty, rootBeanType, pathToTraversableObject, elementType);
currentLH.reachable = delegate.isReachable(traversableObject, traversableProperty, rootBeanType,
pathToTraversableObject, elementType);
cachedLH.reachable = delegate.isReachable(traversableObject, traversableProperty, rootBeanType,
pathToTraversableObject, elementType);
public boolean isCascadable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
Path pathToTraversableObject, ElementType elementType) {
CacheEntry currentLH =
new CacheEntry(traversableObject, traversableProperty, rootBeanType, pathToTraversableObject, elementType);
currentLH.cascadable = delegate.isCascadable(traversableObject, traversableProperty, rootBeanType,
pathToTraversableObject, elementType);
cachedLH.cascadable = delegate.isCascadable(traversableObject, traversableProperty, rootBeanType,
pathToTraversableObject, elementType);
private CacheEntry(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
Path pathToTraversableObject, ElementType elementType) {
return elementType == that.elementType && path.equals(that.path) && type.equals(that.type)
&& !(object != null ? !object.equals(that.object) : that.object != null) && node.equals(that.node);
private static final String PERSISTENCE_UTIL_CLASSNAME = "javax.persistence.PersistenceUtil";
"org.apache.bval.jsr.resolver.JPATraversableResolver";
public boolean isReachable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
Path pathToTraversableObject, ElementType elementType) {
return jpaTR == null || jpaTR.isReachable(traversableObject, traversableProperty, rootBeanType,
pathToTraversableObject, elementType);
public boolean isCascadable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
Path pathToTraversableObject, ElementType elementType) {
return jpaTR == null || jpaTR.isCascadable(traversableObject, traversableProperty, rootBeanType,
pathToTraversableObject, elementType);
log.log(Level.FINEST,
String.format("Cannot find %s on classpath. All properties will per default be traversable.",
PERSISTENCE_UTIL_CLASSNAME));
(Class<? extends TraversableResolver>) Reflection.toClass(JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME,
classLoader);
log.log(Level.FINEST,
String.format("Instantiated an instance of %s.", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME));
log.log(Level.WARNING,
String.format(
"Unable to load or instantiate JPA aware resolver %s. All properties will per default be traversable.",
JPA_AWARE_TRAVERSABLE_RESOLVER_CLASSNAME),
e);
public boolean isReachable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
Path pathToTraversableObject, ElementType elementType) {
return traversableObject == null
|| Persistence.getPersistenceUtil().isLoaded(traversableObject, traversableProperty.getName());
public boolean isCascadable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
Path pathToTraversableObject, ElementType elementType) {
public boolean isReachable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
Path pathToTraversableObject, java.lang.annotation.ElementType elementType) {
public boolean isCascadable(Object traversableObject, Path.Node traversableProperty, Class<?> rootBeanType,
Path pathToTraversableObject, ElementType elementType) {
try {
final ByteArrayOutputStream baos = new ByteArrayOutputStream();
final byte[] buffer = new byte[1024];
int length;
while ((length = stream.read(buffer)) != -1) {
baos.write(buffer, 0, length);
return new ByteArrayInputStream(baos.toByteArray());
} catch (final IOException e) {
throw new RuntimeException(e);
}
public class LeafNodeBuilderCustomizableContextImpl
implements ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderCustomizableContext {
public LeafNodeBuilderCustomizableContextImpl(final ConstraintValidatorContextImpl parent, String messageTemplate,
PathImpl propertyPath) {
private class LeafNodeContextBuilderImpl
implements ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeContextBuilder {
public ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderDefinedContext atIndex(
Integer index) {
public class LeafNodeBuilderDefinedContextImpl
implements ConstraintValidatorContext.ConstraintViolationBuilder.LeafNodeBuilderDefinedContext {
public LeafNodeBuilderDefinedContextImpl(final ConstraintValidatorContextImpl context, final String tpl,
final PathImpl path) {
implements ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext {
NodeBuilderCustomizableContextImpl(ConstraintValidatorContextImpl contextImpl, String template, PathImpl path,
String name) {
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(
String name) {
implements ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderDefinedContext {
public NodeBuilderDefinedContextImpl(ConstraintValidatorContextImpl contextImpl, String template, PathImpl path) {
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(
String name) {
final class NodeContextBuilderImpl implements ConstraintValidatorContext.ConstraintViolationBuilder.NodeContextBuilder {
NodeContextBuilderImpl(ConstraintValidatorContextImpl contextImpl, String template, PathImpl path, NodeImpl node) {
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderDefinedContext atKey(Object key) {
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderDefinedContext atIndex(Integer index) {
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addNode(String name) {
public ConstraintValidatorContext.ConstraintViolationBuilder.NodeBuilderCustomizableContext addPropertyNode(
String name) {
public NodeImpl(String name) {
throw new IllegalStateException(
String.format("Position %s: expected property, index/key, or end of expression", here));
throw new IllegalStateException(String.format(
"Position %s: expected property path separator, index/key, or end of expression", here));
} catch (Exception e) {
throw new RuntimeException(
"Java escaping in quotes is only supported with Apache commons-lang3 on the classpath!");
KNOWN_PROXY_CLASSNAMES = Collections.unmodifiableSet(s);
throw new UnknownPropertyException(
String.format("Property %s.%s is not cascaded", mp.getParentMetaBean().getId(), mp.getName()));
validationContext.moveDown(mp,
new NullSafePropertyAccess(validationContext.getMetaBean().getBeanClass(), mp.getName()));
validationContext.setMetaBean(validationContext.getMetaBean()
.resolveMetaBean(ObjectUtils.defaultIfNull(validationContext.getBean(), rawType)));
private final Map<Class<?>, Map<Member, Boolean>> ignoreAnnotationOnMember =
new HashMap<Class<?>, Map<Member, Boolean>>();
private final Map<Class<?>, Map<Member, Map<Integer, Boolean>>> ignoreAnnotationOnParameter =
new HashMap<Class<?>, Map<Member, Map<Integer, Boolean>>>();
return ignoreAnnotationDefaults.containsKey(clazz) && ignoreAnnotationDefaults.get(clazz);
log.log(Level.FINEST, String.format("%s level annotations are getting ignored for %s.%s", type, clazz.getName(),
member.getName()));
log.log(Level.FINEST, String.format("Class level annotation are getting ignored for %s", clazz.getName()));
if (processedValuesFromDescriptor != descriptor.size() && !Valid.class.equals(annotationType)) {
private static final Set<ConstraintAnnotationAttributes> RESERVED_PARAMS = Collections
.unmodifiableSet(EnumSet.of(ConstraintAnnotationAttributes.GROUPS, ConstraintAnnotationAttributes.MESSAGE,
ConstraintAnnotationAttributes.PAYLOAD, ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO));
final Collection<String> potentialMethodName =
processPropertyLevel(bean.getGetter(), beanClass, defaultPackage, ignoreAnnotations);
final JAXBElement<ConstraintMappingsType> root =
unmarshaller.unmarshal(stream, ConstraintMappingsType.class);
private void processClassLevel(ClassType classType, Class<?> beanClass, String defaultPackage) {
MetaConstraint<?, ?> metaConstraint = createConstraint(constraint, beanClass, null, defaultPackage);
private <A extends Annotation, T> MetaConstraint<?, ?> createConstraint(final ConstraintType constraint,
final Class<T> beanClass, final Member member, final String defaultPackage) {
private <A extends Annotation> Class<?> getAnnotationParameterType(final Class<A> annotationClass,
final String name) {
throw new ValidationException(
private Object getElementValue(ElementType elementType, Class<?> returnType, String defaultPackage) {
throw new ValidationException("Attempt to specify an array where single value is expected.");
private <A extends Annotation> Annotation createAnnotation(AnnotationType annotationType, Class<A> returnType,
String defaultPackage) {
return new Class[] {};
throw new ValidationException(
int i = 0;
throw new ValidationException(
}
final Method method =
Reflection.getDeclaredMethod(beanClass, methodName, toTypes(methodType.getParameter(), defaultPackage));
final boolean ignoreMethodAnnotation =
methodType.getIgnoreAnnotations() == null ? parentIgnoreAnn : methodType.getIgnoreAnnotations();
final MetaConstraint<?, ?> constraint =
createConstraint(constraintType, beanClass, method, defaultPackage);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method,
AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method,
new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
boolean ignoreParametersAnnotation =
p.getIgnoreAnnotations() == null ? ignoreMethodAnnotation : p.getIgnoreAnnotations();
final MetaConstraint<?, ?> constraint =
createConstraint(constraintType, beanClass, method, defaultPackage);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method,
AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method,
new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
final MetaConstraint<?, ?> constraint =
createConstraint(constraintType, beanClass, method, defaultPackage);
throw new ValidationException(
final MetaConstraint<?, ?> constraint =
createConstraint(constraintType, beanClass, constructor, defaultPackage);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor,
AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass,
constructor, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
final MetaConstraint<?, ?> constraint =
createConstraint(constraintType, beanClass, constructor, defaultPackage);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, constructor,
AnnotationProxyBuilder.ValidAnnotation.INSTANCE);
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass,
constructor, new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
final MetaConstraint<?, ?> constraint =
createConstraint(constraintType, beanClass, constructor, defaultPackage);
private <A> void processFieldLevel(List<FieldType> fields, Class<A> beanClass, String defaultPackage,
boolean ignoreAnnotations) {
throw new ValidationException(
}
final boolean ignoreFieldAnnotation =
fieldType.getIgnoreAnnotations() == null ? ignoreAnnotations : fieldType.getIgnoreAnnotations();
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, field,
new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
MetaConstraint<?, ?> constraint = createConstraint(constraintType, beanClass, field, defaultPackage);
String defaultPackage, boolean ignoreAnnotatino) {
throw new ValidationException(
final boolean ignoreGetterAnnotation =
getterType.getIgnoreAnnotations() == null ? ignoreAnnotatino : getterType.getIgnoreAnnotations();
final MetaConstraint<?, ?> constraint = new MetaConstraint<A, Annotation>(beanClass, method,
new AnnotationProxyBuilder.ConvertGroupAnnotation(from, to));
createConstraint(constraintType, beanClass, method, defaultPackage);
private void processConstraintDefinitions(List<ConstraintDefinitionType> constraintDefinitionList,
String defaultPackage) {
if (validatedByType.getIncludeExistingValidators() != null
&& validatedByType.getIncludeExistingValidators()) {
validatorClass = (Class<? extends ConstraintValidator<?, ?>>) loadClass(validatorClassName);
if (!classes.contains(validatorClass))
classes.add(validatorClass);
throw new ValidationException(
classes.toArray(new Class[classes.size()]));
Class<? extends Annotation> annotationType) {
new ArrayList<Class<? extends ConstraintValidator<? extends Annotation, ?>>>();
factory.getDefaultConstraints().getValidatorClasses(annotationType);
Class<? extends ConstraintValidator<?, ?>>[] validatedBy =
annotationType.getAnnotation(Constraint.class).validatedBy();
@Target({ ANNOTATION_TYPE, METHOD, FIELD })
Class<? extends Payload>[] payload() default {};
@Pattern(regexp = ".*?COMPANY.*?") })
@Target({ ANNOTATION_TYPE, METHOD, FIELD, CONSTRUCTOR, PARAMETER })
@OverridesAttribute(constraint = Pattern.class, name = "message", constraintIndex = 0)
String emailMessage() default "Not an email";
@OverridesAttribute(constraint = Pattern.class, name = "message", constraintIndex = 1)
String agimatecMessage() default "Not COMPANY";
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@interface List {
@Target({ ANNOTATION_TYPE, METHOD, FIELD })
@OverridesAttribute.List({ @OverridesAttribute(constraint = Size.class, name = "min"),
@OverridesAttribute(constraint = Size.class, name = "max") })
@OverridesAttribute(constraint = Size.class, name = "message")
Class<? extends Payload>[] payload() default {};
@Target({ ANNOTATION_TYPE, METHOD, FIELD })
@Constraint(validatedBy = { HasStringValidator.class })
Class<? extends Payload>[] payload() default {};
Class<? extends Payload>[] payload() default {};
@Target({ TYPE })
String message() default "{validator.zipCodeCityCoherence}";
Class<? extends Payload>[] payload() default {};
public class ZipCodeCityCoherenceValidator implements ConstraintValidator<ZipCodeCityCoherence, ZipCodeCityCarrier> {
context.buildConstraintViolationWithTemplate("city not OK").addPropertyNode("city")
.addConstraintViolation();
@GroupSequence(value = { Default.class, HighLevelCoherence.class })
@GroupSequence({ First.class, Author.class, Last.class })
@GroupSequence({ First.class, Second.class, Book.class, Last.class })
@GroupSequence(value = { First.class, Second.class, Last.class })
@Pattern(regexp = "^....-....-....$", message = "must match ....-....-....") })
public void save(@Pattern(regexp = "[a-f0-9]{4}") String data) {
return;
@Size(min = 3, max = 10)
public String echo(@NotNull @Size(min = 3, max = 10) String str) {
return str;
@NotNull(groups = { Billable.class, BuyInOneClick.class })
@GroupSequence(value = CyclicGroupSequence1.class)
@GroupSequence({ GClass1.class, GClass2.class })
@GroupSequence({ GClass3.class, GClass1.class })
@NotNull
String getCreationDate();
@NotNull
String getLastModifier();
@NotNull
String getLastReader();
@Size(min = 10, max = 10)
@NotNull(groups = { Billable.class })
@GroupSequence({ Address.class, Address.HighLevelCoherence.class, Address.ExtraCareful.class })
public interface HighLevelCoherence {
}
public interface ExtraCareful {
}
@NotNull
@GroupSequence({ Address.class, Address.HighLevelCoherence.class })
public interface HighLevelCoherence {
}
f.set(instance,
Validation.byDefaultProvider().configure().buildValidatorFactory().getValidator());
new Class<?>[] { Context.class }, new InvocationHandler() {
public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {
if (method.getName().equals("lookup") && args != null && args.length == 1
&& String.class.isInstance(args[0])) {
if ("java:comp/ValidatorFactory".equals(args[0])) {
return Validation.byDefaultProvider().configure().buildValidatorFactory();
}
if ("java:comp/Validator".equals(args[0])) {
return Validation.byDefaultProvider().configure().buildValidatorFactory().getValidator();
}
return null;
}));
if (context.getPropertyValue() == null)
return;
if (lag == null)
return;
if (context.getPropertyValue() == null)
return;
if (regExp == null)
return;
if (context.getPropertyValue() == null)
return;
if (minValue == null || context.getPropertyValue() == null)
return;
if (maxValue == null || context.getPropertyValue() == null)
return;
Object currentValue) {
Integer maxLength = (Integer) context.getMetaProperty().getFeature(Features.Property.MAX_LENGTH);
if (maxLength == null)
return;
if (context.getPropertyValue() == null)
return;
Integer maxLength = (Integer) context.getMetaProperty().getFeature(Features.Property.MIN_LENGTH);
if (maxLength == null)
return;
if (context.getPropertyValue() == null)
return;
if (features == null)
features = new ArrayList<XMLMetaFeature>();
if (features == null)
return null;
if (key.equals(anno.getKey()))
return anno;
if (validators == null)
validators = new ArrayList<XMLMetaValidatorReference>();
xStream.processAnnotations(new Class[] { XMLFeaturesCapable.class, XMLMetaFeature.class, XMLMetaBean.class,
XMLMetaBeanInfos.class, XMLMetaBeanReference.class, XMLMetaElement.class, XMLMetaProperty.class,
XMLMetaValidator.class, XMLMetaValidatorReference.class });
if (properties == null)
properties = new ArrayList<XMLMetaProperty>();
if (properties == null)
return null;
if (name.equals(prop.getName()))
return prop;
if (beanRelations == null)
beanRelations = new ArrayList<XMLMetaBeanReference>();
if (beanRelations == null)
return null;
if (name.equals(relation.getName()))
return relation;
new LinkedHashMap<XMLMetaBeanLoader, XMLMetaBeanInfos>();
if (metaBean.getId() == null)
return;
visitXMLBeanMeta(metaBean.getId(), new Visitor() {
public void visit(XMLMetaBean xmlMeta, XMLMetaBeanInfos xmlInfos) throws Exception {
protected void enrichValidations(FeaturesCapable prop, XMLFeaturesCapable xmlProp, XMLResult result,
boolean addStandard) throws Exception {
List<String> jsValidators =
if (standardValidation != null && valRef.getRefId().equals(standardValidation.getValidationId())) {
XMLMetaValidator validator = result.xmlInfos.getValidator(valRef.getRefId());
if (validator.getJsFunction() != null && !jsValidators.contains(validator.getJsFunction())) {
prop.putFeature(JAVASCRIPT_VALIDATION_FUNCTIONS, jsValidators.toArray(new String[jsValidators.size()]));
} else if (addStandard && standardValidation != null && !prop.hasValidation(standardValidation)) {
protected MetaProperty enrichElement(MetaBean meta, XMLMetaElement xmlProp, XMLResult result) throws Exception {
for (Map.Entry<XMLMetaBeanLoader, XMLMetaBeanInfos> entry : resources.entrySet()) {
for (Map.Entry<XMLMetaBeanLoader, XMLMetaBeanInfos> entry : resources.entrySet()) {
if (beans == null)
return null;
if (beanLookup == null)
initBeanLookup();
Validation validation = (Validation) Reflection.toClass(xv.getJava()).newInstance();
if (beans == null)
beans = new ArrayList<XMLMetaBean>();
if (validators == null)
return null;
if (validationLookup == null)
initValidationLookup();
if (validators == null)
validators = new ArrayList<XMLMetaValidator>();
if (url == null)
throw new NullPointerException("URL required");
XMLMetaBeanInfos beanInfos = (XMLMetaBeanInfos) XMLMapper.getInstance().getXStream().fromXML(stream);
VALUE1, VALUE2, VALUE3
return new BeanInfo[] { bi };
PropertyDescriptor numericValue =
new PropertyDescriptor("numericValue", targetClass, "getNumericValue", "setNumericValue");
return new PropertyDescriptor[] { numericValue };
import org.apache.commons.lang3.StringEscapeUtils;
import java.util.logging.Logger;
private static final Logger LOG = Logger.getLogger(PathNavigation.class.getName());
private static final boolean COMMONS_LANG3_AVAILABLE;
static {
boolean b = true;
try {
new StringEscapeUtils();
} catch (Exception e) {
b = false;
LOG.warning("Apache commons-lang3 is not on the classpath; Java escaping in quotes will not be available.");
}
COMMONS_LANG3_AVAILABLE = b;
}
final int codePoints;
if (COMMONS_LANG3_AVAILABLE) {
codePoints = StringEscapeUtils.UNESCAPE_JAVA.translate(path, here, w);
} else {
codePoints = 0;
}
if (codePoints == 0) {
w.write(Character.toChars(Character.codePointAt(path, here)));
pos.next();
} else {
pos.plus(Character.charCount(Character.codePointAt(path, pos.getIndex())));
import java.io.IOException;
import java.io.Writer;
private static class QuotedStringParser {
String parseQuotedString(CharSequence path, PathPosition pos) throws Exception {
final int len = path.length();
final int start = pos.getIndex();
if (start < len) {
final char quote = path.charAt(start);
pos.next();
final StringWriter w = new StringWriter();
while (pos.getIndex() < len) {
final int here = pos.getIndex();
if (path.charAt(here) == quote) {
pos.next();
return w.toString();
}
handleNextChar(path, pos, w);
}
pos.setIndex(start);
}
return null;
}
protected void handleNextChar(CharSequence path, PathPosition pos, Writer target) throws IOException {
target.write(Character.toChars(Character.codePointAt(path, pos.getIndex())));
pos.next();
}
}
private static class FullQuotedStringParser extends QuotedStringParser {
@Override
protected void handleNextChar(CharSequence path, PathPosition pos, Writer target) throws IOException {
final int
codePoints = StringEscapeUtils.UNESCAPE_JAVA.translate(path, pos.getIndex(), target);
if (codePoints == 0) {
super.handleNextChar(path, pos, target);
} else {
pos.plus(Character.charCount(Character.codePointAt(path, pos.getIndex())));
}
}
}
}
private static final QuotedStringParser QUOTED_STRING_PARSER;
QuotedStringParser quotedStringParser;
quotedStringParser = new FullQuotedStringParser();
quotedStringParser = new QuotedStringParser();
QUOTED_STRING_PARSER = quotedStringParser;
String s = QUOTED_STRING_PARSER.parseQuotedString(path, pos);
