import static java.lang.Math.atan;
import static java.lang.Math.atan2;
import static java.lang.Math.cos;
import static java.lang.Math.pow;
import static java.lang.Math.sin;
import static java.lang.Math.sinh;
import static java.lang.Math.sqrt;
import static java.lang.Math.toDegrees;
import static java.lang.Math.toRadians;
    public static int lon2tilex(final double lon, @Nonnegative final int zoom) {
    public static int lat2tiley(final double lat, @Nonnegative final int zoom) {
        double lat_rad = toRadians(lat);
    public static double tilex2lon(final int x, @Nonnegative final int zoom) {
        return x / pow(2.d, zoom) * 360.d - 180.d;
    }

    public static double tiley2lat(final int y, @Nonnegative final int zoom) {
        double n = PI - (2.d * PI * y) / pow(2.d, zoom);
        return toDegrees(atan(sinh(n)));
    }

    public static long tile(final double lat, final double lon, @Nonnegative final int zoom) {
        int xtile = lon2tilex(lon, zoom);
        int ytile = lat2tiley(lat, zoom);
        long n = 1L << zoom; // 2^z
    /**
     * Return a Haversine distance in Kilometers between two points.
     * 
     * @link http://www.movable-type.co.uk/scripts/latlong.html
     * @link http://rosettacode.org/wiki/Haversine_formula#Java
     * @return distance between two points in Kilometers
     */
    public static double haversineDistance(final double lat1, final double lon1, final double lat2,
            final double lon2) {
        double R = 6371.0d; // Radius of the earth in Km
        double dLat = toRadians(lat2 - lat1); // deg2rad below
        double dLon = toRadians(lon2 - lon1);
        double sinDLat = sin(dLat / 2.d);
        double sinDLon = sin(dLon / 2.d);
        double a = sinDLat * sinDLat  cos(toRadians(lat1)) * cos(toRadians(lat2)) * sinDLon
                * sinDLon;
        double c = 2.d * atan2(sqrt(a), sqrt(1.d - a));
        return R * c; // Distance in Km
    }

