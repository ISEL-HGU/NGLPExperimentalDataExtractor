import java.util.concurrent.ConcurrentLinkedQueue;
import org.apache.hadoop.hbase.client.BufferedMutator;
import org.apache.hadoop.hbase.client.Connection;
import org.apache.hadoop.hbase.client.ConnectionFactory;
import org.apache.hadoop.hbase.client.Mutation;
import org.apache.hadoop.hbase.client.RegionLocator;
import org.apache.hadoop.hbase.client.Table;
public class HBaseTableConnection {
   * HTablePool for maintaining a tPool of tables, but there are still some

  private final Connection connection;
  private final RegionLocator regionLocator;
  // BufferedMutator used for doing async flush i.e. autoflush = false
  private final ThreadLocal<ConcurrentLinkedQueue<Mutation>> buffers;
  private final ThreadLocal<Table> tables;

  private final BlockingQueue<Table> tPool = new LinkedBlockingQueue<>();
  private final BlockingQueue<ConcurrentLinkedQueue<Mutation>> bPool = new LinkedBlockingQueue<>();
  @SuppressWarnings("unused")

   *

    this.buffers = new ThreadLocal<>();
    this.connection = ConnectionFactory.createConnection(conf);
    this.regionLocator = this.connection.getRegionLocator(this.tableName);


  private Table getTable() throws IOException {
    Table table = tables.get();
      table = connection.getTable(tableName);
      tPool.add(table); //keep track

  private ConcurrentLinkedQueue<Mutation> getBuffer() throws IOException {
    ConcurrentLinkedQueue<Mutation> buffer = buffers.get();
    if (buffer == null) {
      buffer = new ConcurrentLinkedQueue<>();
      bPool.add(buffer);
      buffers.set(buffer);
    }
    return buffer;
  }

  public void flushCommits() throws IOException {
    BufferedMutator bufMutator = connection.getBufferedMutator(this.tableName);
    for (ConcurrentLinkedQueue<Mutation> buffer : bPool) {
      for (Mutation m: buffer) {
        bufMutator.mutate(m);
      }
    }
    bufMutator.flush();
    bufMutator.close();
  }

    flushCommits();

    for (Table table : tPool) {
   * getStartEndKeys provided by {@link HRegionLocation}.
   * @see RegionLocator#getStartEndKeys()
    return regionLocator.getStartEndKeys();
   * getRegionLocation provided by {@link HRegionLocation}
   * @see RegionLocator#getRegionLocation(byte[])
    return regionLocator.getRegionLocation(bs);
  public boolean[] existsAll(List<Get> list) throws IOException {
    return getTable().existsAll(list);
  }

    getBuffer().add(put);
    getBuffer().addAll(puts);
    getBuffer().add(delete);
    getBuffer().addAll(deletes);
