import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Map;
import com.aerospike.client.Key;
import com.aerospike.client.Value;
import com.aerospike.client.Bin;
import com.aerospike.client.Record;
import com.aerospike.client.AerospikeClient;
import org.apache.avro.util.Utf8;
import org.apache.gora.persistency.Persistent;
import org.apache.gora.persistency.impl.DirtyListWrapper;
import org.apache.gora.persistency.impl.DirtyMapWrapper;
import org.apache.gora.util.AvroUtils;
  /**
   * Aerospike, being a schemaless database does not support explicit schema creation through the
   * provided java client. When the records are added to the database, the schema is created on
   * the fly. Thus, schema related functionality is unavailable in gora-aerospike module.
   *
   * @return null
   */
  /**
   * Aerospike, being a schemaless database does not support explicit schema creation through the
   * provided java client. When the records are added to the database, the schema is created on
   * the fly. Thus, schema creation functionality is unavailable in gora-aerospike module.
   */
  /**
   * Aerospike, being a schemaless database does not support explicit schema creation through the
   * provided java client. When the records are added to the database, the schema is created on
   * the fly. Thus, schema deletion functionality is unavailable in gora-aerospike module.
   */
  /**
   * Aerospike, being a schemaless database does not support explicit schema creation through the
   * provided java client. When the records are added to the database, the schema is created on
   * the fly. Thus, schema exists functionality is unavailable in gora-aerospike module.
   */

    Value keyValue;
    if (keyClass.getSimpleName().equalsIgnoreCase("string")) {
      keyValue = Value.get(key.toString());
    } else {
      keyValue = Value.get(key);
    }

            aerospikeParameters.getAerospikeMapping().getSet(), keyValue);
    Value keyValue;
    if (keyClass.getSimpleName().equalsIgnoreCase("string")) {
      keyValue = Value.get(key.toString());
    } else {
      keyValue = Value.get(key);
    }

            aerospikeParameters.getAerospikeMapping().getSet(), keyValue);
      Object persistentValue = persistent.get(i);
      if (persistentValue != null) {
        String mappingBinName = aerospikeParameters.getAerospikeMapping().getBinMapping()
                .get(fields.get(i).name());
        if (mappingBinName == null) {
          LOG.error(
                  "Aerospike mapping for field {}#{} not found. Wrong gora-aerospike-mapping.xml?",
                  persistent.getClass().getName(), fields.get(i).name());
          throw new RuntimeException(
                  "Aerospike mapping for field ["  persistent.getClass().getName()  "#"  fields
                          .get(i).name()  "] not found. Wrong gora-aerospike-mapping.xml?");
        }
        Bin bin = new Bin(mappingBinName,
                getSerializableValue(persistentValue, fields.get(i).schema()));
        aerospikeClient
                .put(aerospikeParameters.getAerospikeMapping().getWritePolicy(), recordKey, bin);
   * Method to get the value serializable in database from the Avro persistent object
   * @param object persistent object
   * @param schema schema of the persistent object
   * @return serializable value
  private Value getSerializableValue(Object object, Schema schema) {
    Value value = null;
    switch (schema.getType()) {
      case UNION:
        if (object != null) {
          int schemaPos = getUnionSchema(object, schema);
          Schema unionSchema = schema.getTypes().get(schemaPos);
          value = getSerializableValue(object, unionSchema);
        }
        break;
      case STRING:
        value = Value.get(object.toString());
        break;
      case BYTES:
        value = Value.get(((ByteBuffer) object).array());
        break;
      case MAP:
        Map<Object, Object> newMap = new HashMap<>();
        Map<?, ?> fieldMap = (Map<?, ?>) object;
        for (Object key : fieldMap.keySet()) {
          newMap.put(key.toString(),
                  getSerializableValue(fieldMap.get(key), schema.getValueType()));
        }
        value = Value.get(newMap);
        break;
      case ARRAY:
        List<Object> objectList = new ArrayList<>();
        for (Object obj : (List<Object>) object) {
          objectList.add(getSerializableValue(obj, schema.getElementType()));
        }
        value = Value.get(objectList);
        break;
      default:
        value = Value.get(object);
        break;
    return value;
   * @param fieldName  field name
  private void setPersistentField(String fieldName, Record record, T persistent) {
    String binName = aerospikeParameters.getAerospikeMapping().getBinName(fieldName);
              fieldName);
      throw new RuntimeException("Aerospike mapping for field ["  fieldName  "] not found. "
    if (record.bins.get(fieldName) == null) {
      return;
    }
    String binDataType = record.bins.get(fieldName).getClass().getSimpleName();
    persistent.put(fieldName,
            getDeserializedObject(binValue, binDataType, fieldMap.get(fieldName).schema()));
  }
  /**
   * Method to get Avro mapped persistent object from the record retrieved from the database
   *
   * @param binValue    value retrieved from database
   * @param binDataType data type of the database value
   * @param schema      corresponding schema in the persistent class
   * @return persistent object
   */
  private Object getDeserializedObject(Object binValue, String binDataType, Schema schema) {

    Object result;
    switch (schema.getType()) {

      case MAP:
        Map<String, Object> rawMap = (Map<String, Object>) binValue;
        Map<Utf8, Object> deserializableMap = new HashMap<>();
        if (rawMap == null) {
          result = new DirtyMapWrapper(deserializableMap);
          break;
        }
        for (Map.Entry<?, ?> e : rawMap.entrySet()) {
          Schema innerSchema = schema.getValueType();
          Object obj = getDeserializedObject(e.getValue(), e.getValue().getClass().getSimpleName(),
                  innerSchema);
          if (e.getKey().getClass().getSimpleName().equalsIgnoreCase("Utf8")) {
            deserializableMap.put((Utf8) e.getKey(), obj);
          } else {
            deserializableMap.put(new Utf8((String) e.getKey()), obj);
        }
        result = new DirtyMapWrapper<>(deserializableMap);
        break;

      case ARRAY:
        List<Object> rawList = (List<Object>) binValue;
        List<Object> deserializableList = new ArrayList<>();
        if (rawList == null) {
          return new DirtyListWrapper(deserializableList);
        }
        for (Object item : rawList) {
          Object obj = getDeserializedObject(item, item.getClass().getSimpleName(),
                  schema.getElementType());
          deserializableList.add(obj);
        }
        result = new DirtyListWrapper<>(deserializableList);
        break;

      case RECORD:
        result = (PersistentBase) binValue;
        break;

      case UNION:
        int index = getUnionSchema(binValue, schema);
        Schema resolvedSchema = schema.getTypes().get(index);
        result = getDeserializedObject(binValue, binDataType, resolvedSchema);
        break;

      case ENUM:
        result = AvroUtils.getEnumValue(schema, (String) binValue);
        break;

      case BYTES:
        result = ByteBuffer.wrap((byte[]) binValue);
        break;

      case STRING:
        if (binValue instanceof org.apache.avro.util.Utf8)
          result = binValue;
        else
          result = new Utf8((String) binValue);
        break;

      case INT:
        if (binDataType.equalsIgnoreCase("long")) {
          result = Math.toIntExact((Long) binValue);
        } else {
          result = binValue;
        }
        break;

      default:
        result = binValue;
    return result;
  }

  /**
   * Method to retrieve the corresponding schema type index of a particular object having UNION
   * schema. As UNION type can have one or more types and at a given instance, it holds an object
   * of only one type of the defined types, this method is used to figure out the corresponding
   * instance's
   * schema type index.
   *
   * @param instanceValue value that the object holds
   * @param unionSchema   union schema containing all of the data types
   * @return the unionSchemaPosition corresponding schema position
   */
  private int getUnionSchema(Object instanceValue, Schema unionSchema) {
    int unionSchemaPos = 0;
    for (Schema currentSchema : unionSchema.getTypes()) {
      Schema.Type schemaType = currentSchema.getType();
      if (instanceValue instanceof CharSequence && schemaType.equals(Schema.Type.STRING))
        return unionSchemaPos;
      else if (instanceValue instanceof ByteBuffer && schemaType.equals(Schema.Type.BYTES))
        return unionSchemaPos;
      else if (instanceValue instanceof byte[] && schemaType.equals(Schema.Type.BYTES))
        return unionSchemaPos;
      else if (instanceValue instanceof Integer && schemaType.equals(Schema.Type.INT))
        return unionSchemaPos;
      else if (instanceValue instanceof Long && schemaType.equals(Schema.Type.LONG))
        return unionSchemaPos;
      else if (instanceValue instanceof Double && schemaType.equals(Schema.Type.DOUBLE))
        return unionSchemaPos;
      else if (instanceValue instanceof Float && schemaType.equals(Schema.Type.FLOAT))
        return unionSchemaPos;
      else if (instanceValue instanceof Boolean && schemaType.equals(Schema.Type.BOOLEAN))
        return unionSchemaPos;
      else if (instanceValue instanceof Map && schemaType.equals(Schema.Type.MAP))
        return unionSchemaPos;
      else if (instanceValue instanceof List && schemaType.equals(Schema.Type.ARRAY))
        return unionSchemaPos;
      else if (instanceValue instanceof Persistent && schemaType.equals(Schema.Type.RECORD))
        return unionSchemaPos;
      unionSchemaPos;
    }
    return 0;
