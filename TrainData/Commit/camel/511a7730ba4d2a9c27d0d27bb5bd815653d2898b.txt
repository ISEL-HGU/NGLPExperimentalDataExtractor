        // then do a more complex sorting where we check inter-dependency among the methods
        methods.sort((m1, m2) -> {
            Class[] types1 = m1.getParameterTypes();
            Class[] types2 = m2.getParameterTypes();

            // favour methods that has no parameters
            if (types1.length == 0 && types2.length == 0) {
                return 0;
            } else if (types1.length == 0) {
                return -1;
            } else if (types2.length == 0) {
                return 1;
            }

            // okay then compare so we favour methods that does not use parameter types that are returned from other methods
            boolean usedByOthers1 = false;
            for (Class clazz : types1) {
                usedByOthers1 |= methods.stream().anyMatch(m -> m.getParameterCount() > 0 && clazz.isAssignableFrom(m.getReturnType()));
            }
            boolean usedByOthers2 = false;
            for (Class clazz : types2) {
                usedByOthers2 |= methods.stream().anyMatch(m -> m.getParameterCount() > 0 && clazz.isAssignableFrom(m.getReturnType()));
            }
            return Boolean.compare(usedByOthers1, usedByOthers2);
        });

                    } else if (instances.size() > 1) {
