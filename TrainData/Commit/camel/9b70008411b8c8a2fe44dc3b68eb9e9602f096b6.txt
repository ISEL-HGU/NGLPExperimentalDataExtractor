import java.util.concurrent.atomic.AtomicReference;
import org.apache.camel.support.ExpressionAdapter;
        // chicken-and-egg situation as we need to return an ExpressionClause
        // which needs a right-hand side that is being built via the fluent
        // builder that is returned, and therefore we need to use a ref
        // to the expression (right hand side) that will be used below
        // in the onNewPredicate where the actual matching is executed
        final AtomicReference<Expression> ref = new AtomicReference<>();

        final ExpressionClause<Predicate> answer = new ExpressionClause<>(
            onNewPredicate(new Predicate() {
                @Override
                public boolean matches(Exchange exchange) {
                    Expression left = expression;
                    Expression right = ref.get();
                    return PredicateBuilder.isEqualTo(left, right).matches(exchange);
                }

                @Override
                public String toString() {
                    return expression  " == "  ref.get();
                }
            }));

        final Expression right = new ExpressionAdapter() {
            @Override
            public Object evaluate(Exchange exchange) {
                if (answer.getExpressionValue() != null) {
                    return answer.getExpressionValue().evaluate(exchange, Object.class);
                } else {
                    return answer.getExpressionType().evaluate(exchange);
                }
            }
        };
        // okay now we can set the reference to the right-hand-side
        ref.set(right);

        return answer;
