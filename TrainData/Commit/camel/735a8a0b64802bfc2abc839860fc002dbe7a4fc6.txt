/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *      http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
import java.util.Arrays;
    private static final GenericType ALL = new GenericType(Object.class);
    private static final Map<String, Class> PRIMITIVE_CLASSES = new HashMap<>();
        Exact, Extends, Super
    
    
    
    static {
        PRIMITIVE_CLASSES.put("int", int.class);
        PRIMITIVE_CLASSES.put("short", short.class);
        PRIMITIVE_CLASSES.put("long", long.class);
        PRIMITIVE_CLASSES.put("byte", byte.class);
        PRIMITIVE_CLASSES.put("char", char.class);
        PRIMITIVE_CLASSES.put("float", float.class);
        PRIMITIVE_CLASSES.put("double", double.class);
        PRIMITIVE_CLASSES.put("boolean", boolean.class);
        PRIMITIVE_CLASSES.put("void", void.class);
    }
    public GenericType(Type type) {
        this(getConcreteClass(type), parametersOf(type));
    }
        this(clazz, BoundType.Exact, parameters);

            return new GenericType(PRIMITIVE_CLASSES.get(type));
        return PRIMITIVE_CLASSES.containsKey(type);
        if (parameters.length == 0 && boundType == BoundType.Extends && clazz == Object.class) {
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result  ((boundType == null) ? 0 : boundType.hashCode());
        result = prime * result  ((clazz == null) ? 0 : clazz.hashCode());
        result = prime * result  Arrays.hashCode(parameters);
        return result;
    }

        GenericType other = (GenericType)object;
            return other.parameters == null;
            WildcardType wct = (WildcardType)type;
            return wct.getLowerBounds().length == 0 ? BoundType.Extends : BoundType.Super;
    static GenericType[] parametersOf(Type type) {
        if (type instanceof Class) {
            Class clazz = (Class)type;
            if (clazz.isArray()) {
                    return new GenericType[] {t};
            } else {
                return EMPTY;
            }
        }
        if (type instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType)type;
            Type[] parameters = pt.getActualTypeArguments();
            for (int i = 0; i < gts.length; i) {
        if (type instanceof GenericArrayType) {
            return new GenericType[] {new GenericType(((GenericArrayType)type).getGenericComponentType())};
    }
    static Class<?> getConcreteClass(Type type) {
        Type ntype = collapse(type);
        if (ntype instanceof Class) {
            return (Class<?>)ntype;
        }
        if (ntype instanceof ParameterizedType) {
            return getConcreteClass(collapse(((ParameterizedType)ntype).getRawType()));
        }
        throw new RuntimeException("Unknown type "  type);
    }
    static Type collapse(Type target) {
        if (target instanceof Class || target instanceof ParameterizedType) {
            return target;
        } else if (target instanceof TypeVariable) {
            return collapse(((TypeVariable<?>)target).getBounds()[0]);
        } else if (target instanceof GenericArrayType) {
            Type t = collapse(((GenericArrayType)target).getGenericComponentType());
            while (t instanceof ParameterizedType) {
                t = collapse(((ParameterizedType)t).getRawType());
            }
            return Array.newInstance((Class<?>)t, 0).getClass();
        } else if (target instanceof WildcardType) {
            WildcardType wct = (WildcardType)target;
            if (wct.getLowerBounds().length == 0) {
                return collapse(wct.getUpperBounds()[0]);
            } else {
                return collapse(wct.getLowerBounds()[0]);
            }
        }
        throw new RuntimeException("Huh? "  target);
    }
