        List<MethodInfo> localOperationsWithBody = null;
        if (!operationsWithBody.isEmpty()) {
            localOperationsWithBody = new ArrayList<>(operationsWithBody);
        }
        List<MethodInfo> localOperationsWithNoBody = null;
        if (!operationsWithNoBody.isEmpty()) {
            localOperationsWithNoBody = new ArrayList<>(operationsWithNoBody);
        }
        List<MethodInfo> localOperationsWithCustomAnnotation = null;
        if (!operationsWithCustomAnnotation.isEmpty()) {
            localOperationsWithCustomAnnotation = new ArrayList<>(operationsWithCustomAnnotation);
        }
        List<MethodInfo> localOperationsWithHandlerAnnotation = null;
        if (!operationsWithHandlerAnnotation.isEmpty()) {
            localOperationsWithHandlerAnnotation = new ArrayList<>(operationsWithHandlerAnnotation);
        }
        if (localOperationsWithBody != null) {
            removeAllAbstractMethods(localOperationsWithBody);
        }
        if (localOperationsWithNoBody != null) {
            removeAllAbstractMethods(localOperationsWithNoBody);
        }
        if (localOperationsWithCustomAnnotation != null) {
            removeAllAbstractMethods(localOperationsWithCustomAnnotation);
        }
        if (localOperationsWithHandlerAnnotation != null) {
            removeAllAbstractMethods(localOperationsWithHandlerAnnotation);
        }
            if (localOperationsWithHandlerAnnotation != null) {
                removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);
            }
            if (localOperationsWithCustomAnnotation != null) {
                removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);
            }
            if (localOperationsWithBody != null) {
                removeNonMatchingMethods(localOperationsWithBody, name);
            }
            if (localOperationsWithNoBody != null) {
                removeNonMatchingMethods(localOperationsWithNoBody, name);
            }
            if (localOperationsWithHandlerAnnotation != null) {
                removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);
            }
            if (localOperationsWithCustomAnnotation != null) {
                removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);
            }
            if (localOperationsWithBody != null) {
                removeAllSetterOrGetterMethods(localOperationsWithBody);
            }
            if (localOperationsWithNoBody != null) {
                removeAllSetterOrGetterMethods(localOperationsWithNoBody);
            }
        if (localOperationsWithHandlerAnnotation != null && localOperationsWithHandlerAnnotation.size() > 1) {
        if (localOperationsWithHandlerAnnotation != null && localOperationsWithHandlerAnnotation.size() == 1) {
        } else if (localOperationsWithCustomAnnotation != null && localOperationsWithCustomAnnotation.size() == 1) {
        if (noParameters && localOperationsWithNoBody != null && localOperationsWithNoBody.size() == 1) {
        } else if (!noParameters && (localOperationsWithBody != null && localOperationsWithBody.size() == 1 && localOperationsWithCustomAnnotation == null)) {
        if (localOperationsWithBody != null || localOperationsWithCustomAnnotation != null) {
            Collection<MethodInfo> possibleOperations = new ArrayList<>();
            if (localOperationsWithBody != null) {
                possibleOperations.addAll(localOperationsWithBody);
            }
            if (localOperationsWithCustomAnnotation != null) {
                possibleOperations.addAll(localOperationsWithCustomAnnotation);
            }
            if (!possibleOperations.isEmpty()) {
                MethodInfo answer = null;
                if (name != null) {
                    // do we have hardcoded parameters values provided from the method name then use that for matching
                    String parameters = StringHelper.between(name, "(", ")");
                    if (parameters != null) {
                        // special as we have hardcoded parameters, so we need to choose method that matches those parameters the best
                        LOG.trace("Choosing best matching method matching parameters: {}", parameters);
                        answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations);
                    }
                if (answer == null) {
                    // multiple possible operations so find the best suited if possible
                    answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);
                }
                if (answer == null && possibleOperations.size() > 1) {
                    answer = getSingleCovariantMethod(possibleOperations);
                }

                if (answer == null) {
                    throw new AmbiguousMethodCallException(exchange, possibleOperations);
                } else {
                    return answer;
                }
            List<MethodInfo> possibles = new ArrayList<>();
            List<MethodInfo> possiblesWithException = null;
                        if (possiblesWithException == null) {
                            possiblesWithException = new ArrayList<>();
                        }
        if (exception != null && possiblesWithException != null && possiblesWithException.size() == 1) {
            if (possibleWithCustomAnnotation != null && possibleWithCustomAnnotation.size() == 1) {
