import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.AnnotationValue;
            if (roundEnv.processingOver()) {
            if (this.processingEnv.getElementUtils().getTypeElement("org.apache.camel.impl.converter.CoreStaticTypeConverterLoader") != null) {
                return false;
            }

            // We're in tests, do not generate anything
            if (this.processingEnv.getElementUtils().getTypeElement("org.apache.camel.converter.ObjectConverter") == null) {
            Map<String, Map<TypeMirror, ExecutableElement>> converters = new TreeMap<>();
            TypeElement converterAnnotationType = this.processingEnv.getElementUtils().getTypeElement("org.apache.camel.Converter");
            for (Element element : roundEnv.getElementsAnnotatedWith(converterAnnotationType)) {
            TypeElement fallbackAnnotationType = this.processingEnv.getElementUtils().getTypeElement("org.apache.camel.FallbackConverter");
            List<ExecutableElement> fallbackConverters = new ArrayList<>();
            for (Element element : roundEnv.getElementsAnnotatedWith(fallbackAnnotationType)) {
                if (element.getKind() == ElementKind.METHOD) {
                    ExecutableElement ee = (ExecutableElement) element;
                    fallbackConverters.add(ee);
                }
            String c = "CoreStaticTypeConverterLoader";
                writer.append("import org.apache.camel.TypeConverterLoaderException;\n");
                writer.append("import org.apache.camel.spi.TypeConverterLoader;\n");
                writer.append("import org.apache.camel.spi.TypeConverterRegistry;\n");
                writer.append("import org.apache.camel.support.TypeConverterSupport;\n");
                writer.append("public class ").append(c).append(" implements TypeConverterLoader {\n");
                writer.append("    static abstract class SimpleTypeConverter extends TypeConverterSupport {\n");
                writer.append("        private final boolean allowNull;\n");
                writer.append("\n");
                writer.append("        public SimpleTypeConverter(boolean allowNull) {\n");
                writer.append("            this.allowNull = allowNull;\n");
                writer.append("        @Override\n");
                writer.append("        public boolean allowNull() {\n");
                writer.append("            return allowNull;\n");
                writer.append("        }\n");
                writer.append("\n");
                writer.append("        @Override\n");
                writer.append("        public <T> T convertTo(Class<T> type, Exchange exchange, Object value) throws TypeConversionException {\n");
                writer.append("            try {\n");
                writer.append("                return (T) doConvert(exchange, value);\n");
                writer.append("            } catch (TypeConversionException e) {\n");
                writer.append("                throw e;\n");
                writer.append("            } catch (Exception e) {\n");
                writer.append("                throw new TypeConversionException(value, type, e);\n");
                writer.append("            }\n");
                writer.append("        }\n");
                writer.append("        protected abstract Object doConvert(Exchange exchange, Object value) throws Exception;\n");
                writer.append("    };\n");
                writer.append("\n");
                writer.append("    @Override\n");
                writer.append("    public void load(TypeConverterRegistry registry) throws TypeConverterLoaderException {\n");

                        boolean allowNull = false;
                        for (AnnotationMirror ann : from.getValue().getAnnotationMirrors()) {
                            if (ann.getAnnotationType().asElement() == converterAnnotationType) {
                                for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : ann.getElementValues().entrySet()) {
                                    switch (entry.getKey().getSimpleName().toString()) {
                                        case "allowNull":
                                            allowNull = (Boolean) entry.getValue().getValue();
                                            break;
                                        default:
                                            throw new IllegalStateException();
                                    }
                                }
                            }
                        writer.append("        registry.addTypeConverter(").append(to.getKey()).append(".class").append(", ")
                                .append(toString(from.getKey())).append(".class, new SimpleTypeConverter(")
                                .append(Boolean.toString(allowNull)).append(") {\n");
                        writer.append("            @Override\n");
                        writer.append("            public Object doConvert(Exchange exchange, Object value) throws Exception {\n");
                        writer.append("                return ").append(toJava(from.getValue(), converterClasses)).append(";\n");
                        writer.append("            }\n");
                        writer.append("        });\n");

                for (ExecutableElement ee : fallbackConverters) {
                    boolean allowNull = false;
                    boolean canPromote = false;
                    for (AnnotationMirror ann : ee.getAnnotationMirrors()) {
                        if (ann.getAnnotationType().asElement() == fallbackAnnotationType) {
                            for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : ann.getElementValues().entrySet()) {
                                switch (entry.getKey().getSimpleName().toString()) {
                                    case "allowNull":
                                        allowNull = (Boolean) entry.getValue().getValue();
                                        break;
                                    case "canPromote":
                                        canPromote = (Boolean) entry.getValue().getValue();
                                        break;
                                    default:
                                        throw new IllegalStateException();
                                }
                            }
                        }
                    }
                    writer.append("        registry.addFallbackTypeConverter(new TypeConverterSupport() {\n");
                    writer.append("            @Override\n");
                    writer.append("            public boolean allowNull() {\n");
                    writer.append("                return ").append(Boolean.toString(allowNull)).append(";\n");
                    writer.append("            }\n");
                    writer.append("            @Override\n");
                    writer.append("            public <T> T convertTo(Class<T> type, Exchange exchange, Object value) throws TypeConversionException {\n");
                    writer.append("                try {\n");
                    writer.append("                    return (T) ").append(toJavaFallback(ee, converterClasses)).append(";\n");
                    writer.append("                } catch (TypeConversionException e) {\n");
                    writer.append("                    throw e;\n");
                    writer.append("                } catch (Exception e) {\n");
                    writer.append("                    throw new TypeConversionException(value, type, e);\n");
                    writer.append("                }\n");
                    writer.append("            }\n");
                    writer.append("        }, ").append(Boolean.toString(canPromote)).append(");\n");
                }
                writer.append("\n");
                writer.append("\n");
    private String toJavaFallback(ExecutableElement converter, Set<String> converterClasses) {
        String pfx;
        if (converter.getModifiers().contains(Modifier.STATIC)) {
            pfx = converter.getEnclosingElement().toString()  "."  converter.getSimpleName();
        } else {
            converterClasses.add(converter.getEnclosingElement().toString());
            pfx = "get"  converter.getEnclosingElement().getSimpleName()  "()."  converter.getSimpleName();
        }
        String type = toString(converter.getParameters().get(converter.getParameters().size() - 2).asType());
        String cast = type.equals("java.lang.Object") ? "" : "("  type  ") ";
        return pfx  "(type, "  (converter.getParameters().size() == 4 ? "exchange, " : "")  cast  "value"  ", registry)";
    }

