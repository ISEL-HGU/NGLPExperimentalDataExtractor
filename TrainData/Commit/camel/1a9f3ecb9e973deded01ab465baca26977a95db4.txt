import java.util.ArrayList;
import java.util.List;
 * This implementation provides a 1st-level in-memory {@link LRUCache} for fast check of the most
 * frequently used keys. When {@link #add(String)} or {@link #contains(String)} methods are being used
 * then in case of 1st-level cache miss, the underlying file is scanned which may cost additional performance.
 * So try to find the right balance of the size of the 1st-level cache, the default size is 1000.
 * The file store has a maximum capacity of 32mb by default. If the file store grows bigger, then
 * the {@link #getDropOldestFileStore()} number of entries from the file store is dropped to reduce
 * the file store and make room for newer entries.

    private final AtomicBoolean init = new AtomicBoolean();

    private long maxFileStoreSize = 32 * 1024 * 1000L; // 32mb store file
    private long dropOldestFileStore = 1000;
                // always register the most used keys in the LRUCache

                // now check the file store
                boolean containsInFile = containsStore(key);
                if (containsInFile) {
                    return false;
                }

                // its a new key so append to file store
                appendToStore(key);

                // check if we hit maximum capacity and report a warning about this
                if (fileStore.length() > maxFileStoreSize) {
                    LOG.warn("Maximum capacity of file store: {} hit at {} bytes. Dropping {} oldest entries from the file store", fileStore, maxFileStoreSize, dropOldestFileStore);
            // check 1st-level first and then fallback to check the actual file
            return cache.containsKey(key) || containsStore(key);
            // remove from file cache also
            removeFromStore(key);
    @ManagedOperation(description = "Clear the store (danger this removes all entries)")
            // clear file store
            clearStore();
     * The default is 32mb.
    public long getDropOldestFileStore() {
        return dropOldestFileStore;
    }

     * Sets the number of oldest entries to drop from the file store when the maximum capacity is hit to reduce
     * disk space to allow room for new entries.
     * <p/>
     * The default is 1000.
     */
    @ManagedAttribute(description = "Number of oldest elements to drop from file store if maximum file size reached")
    public void setDropOldestFileStore(long dropOldestFileStore) {
        this.dropOldestFileStore = dropOldestFileStore;
    }

    /**
     * Sets the 1st-level cache size.
    @ManagedAttribute(description = "The current 1st-level cache size")
     * Reset and clears the 1st-level cache to force it to reload from file
            // run the cleanup task first
            cache.clear();
     * Checks the file store if the key exists
     * @param key  the key
     * @return <tt>true</tt> if exists in the file, <tt>false</tt> otherwise
    protected boolean containsStore(final String key) {
        if (fileStore == null || !fileStore.exists()) {
            return false;
        }

        Scanner scanner = null;
        try {
            scanner = new Scanner(fileStore);
            scanner.useDelimiter(STORE_DELIMITER);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                if (line.equals(key)) {
                    return true;
                }
            }
        } catch (IOException e) {
            throw ObjectHelper.wrapRuntimeCamelException(e);
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
        return false;
    }

    /**
     * Appends the given key to the file store
     *
     * @param key  the key
     */
    protected void appendToStore(final String key) {
        LOG.debug("Appending: {} to idempotent filestore: {}", key, fileStore);
                    LOG.info("Parent directory of filestore: {} successfully created.", fileStore);
                    LOG.warn("Parent directory of filestore: {} cannot be created.", fileStore);
            fos.write(key.getBytes());
    protected synchronized void removeFromStore(String key) {
        LOG.debug("Removing: {} from idempotent filestore: {}", key, fileStore);

        // we need to re-load the entire file and remove the key and then re-write the file
        List<String> lines = new ArrayList<>();

        boolean found = false;
        Scanner scanner = null;
            scanner = new Scanner(fileStore);
            scanner.useDelimiter(STORE_DELIMITER);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                if (key.equals(line)) {
                    found = true;
                } else {
                    lines.add(line);
                }
            if (scanner != null) {
                scanner.close();
            }
        }

        if (found) {
            // rewrite file
            LOG.debug("Rewriting idempotent filestore: {} due to key: {} removed", fileStore, key);
            FileOutputStream fos = null;
            try {
                fos = new FileOutputStream(fileStore);
                for (String line : lines) {
                    fos.write(line.getBytes());
                    fos.write(STORE_DELIMITER.getBytes());
                }
            } catch (IOException e) {
                throw ObjectHelper.wrapRuntimeCamelException(e);
            } finally {
                IOHelper.close(fos, "Rewriting file idempotent repository", LOG);
            }
        }
    }

    /**
     * Clears the file-store (danger this deletes all entries)
     */
    protected void clearStore() {
        try {
            FileUtil.deleteFile(fileStore);
            FileUtil.createNewFile(fileStore);
        } catch (IOException e) {
            throw ObjectHelper.wrapRuntimeCamelException(e);
        }
    }

    /**
     * Trunks the file store when the max store size is hit by dropping the most oldest entries.
     */
    protected synchronized void trunkStore() {
        if (fileStore == null || !fileStore.exists()) {
            return;
        }

        LOG.debug("Trunking: {} oldest entries from idempotent filestore: {}", dropOldestFileStore, fileStore);

        // we need to re-load the entire file and remove the key and then re-write the file
        List<String> lines = new ArrayList<>();

        Scanner scanner = null;
        int count = 0;
        try {
            scanner = new Scanner(fileStore);
            scanner.useDelimiter(STORE_DELIMITER);
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                count;
                if (count > dropOldestFileStore) {
                    lines.add(line);
                }
            }
        } catch (IOException e) {
            throw ObjectHelper.wrapRuntimeCamelException(e);
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }

        if (!lines.isEmpty()) {
            // rewrite file
            LOG.debug("Rewriting idempotent filestore: {} with {} entries:", fileStore, lines.size());
            FileOutputStream fos = null;
            try {
                fos = new FileOutputStream(fileStore);
                for (String line : lines) {
                    fos.write(line.getBytes());
                    fos.write(STORE_DELIMITER.getBytes());
                }
            } catch (IOException e) {
                throw ObjectHelper.wrapRuntimeCamelException(e);
            } finally {
                IOHelper.close(fos, "Rewriting file idempotent repository", LOG);
            }
        } else {
            // its a small file so recreate the file
            LOG.debug("Clearing idempotent filestore: {}", fileStore);
            clearStore();
        }
    }

    /**
     * Cleanup the 1st-level cache.
     */
    protected void cleanup() {
        // run the cleanup task first
        if (cache instanceof LRUCache) {
            ((LRUCache) cache).cleanUp();
        // run the cleanup task first

        cache.clear();
