import static org.apache.camel.tools.apt.AnnotationProcessorHelper.dumpExceptionToErrorFile;

@SupportedAnnotationTypes({"org.apache.camel.Converter", "org.apache.camel.FallbackConverter"})
    // TODO: fallback does not work
    // TODO: generate so you dont need to pass in CamelContext but register into a java set/thingy
    // so you can init this via static initializer block { ... } and then register on CamelContext later

                // is the method annotated with @Converter
                if (isConverterMethod(ee)) {
                    TypeMirror to = ee.getReturnType();
                    TypeMirror from = ee.getParameters().get(0).asType();
                    String fromStr = toString(from);
                    if (!fromStr.endsWith("[]")) {
                        TypeElement e = this.processingEnv.getElementUtils().getTypeElement(fromStr);
                        if (e != null) {
                            from = e.asType();
                        } else {
                            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "Could not retrieve type element for "  fromStr);
                        }
                    converters.computeIfAbsent(currentClass, c -> new ClassConverters(comparator)).addTypeConverter(to, from, ee);
                    if (converters.containsKey(currentClass)) {
                        converters.get(currentClass).setIgnoreOnLoadError(ignoreOnLoadError);
                    }
        for (Element element : roundEnv.getElementsAnnotatedWith(converterAnnotationType)) {
                if (isFallbackConverterMethod(ee)) {
                    converters.computeIfAbsent(currentClass, c -> new ClassConverters(comparator)).addFallbackTypeConverter(ee);
                    if (converters.containsKey(currentClass)) {
                        converters.get(currentClass).setIgnoreOnLoadError(ignoreOnLoadError);
                    }
            writeConverterLoader(key, value, converterAnnotationType, fallbackAnnotationType);
    private static boolean isConverterMethod(ExecutableElement element) {
        for (AnnotationMirror ann : element.getAnnotationMirrors()) {
            String name = ann.getAnnotationType().asElement().getSimpleName().toString();
            if ("Converter".equals(name)) {
                return true;
            }
        }
        return false;
    }

    private static boolean isFallbackConverterMethod(ExecutableElement element) {
        for (AnnotationMirror ann : element.getAnnotationMirrors()) {
            String name = ann.getAnnotationType().asElement().getSimpleName().toString();
            if ("FallbackConverter".equals(name)) {
                return true;
            }
        }
        return false;
    }

            writer.append("    private final DoubleMap<Class<?>, Class<?>, BaseTypeConverter> converters = new DoubleMap<>("  converters.size()  ");\n");
