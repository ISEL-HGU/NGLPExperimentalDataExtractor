import java.util.function.Consumer;
import java.util.function.Predicate;

        final ManagementStrategy managementStrategy = camelContext.getManagementStrategy();

        registerPropertyForBeanType(applicationContext, BacklogTracer.class, camelContext::addInterceptStrategy);
        registerPropertyForBeanType(applicationContext, HandleFault.class, camelContext::addInterceptStrategy);
        registerPropertyForBeanType(applicationContext, InflightRepository.class, camelContext::setInflightRepository);
        registerPropertyForBeanType(applicationContext, AsyncProcessorAwaitManager.class, camelContext::setAsyncProcessorAwaitManager);
        registerPropertyForBeanType(applicationContext, ManagementStrategy.class, camelContext::setManagementStrategy);
        registerPropertyForBeanType(applicationContext, ManagementNamingStrategy.class, managementStrategy::setManagementNamingStrategy);
        registerPropertyForBeanType(applicationContext, EventFactory.class, managementStrategy::setEventFactory);
        registerPropertyForBeanType(applicationContext, UnitOfWorkFactory.class, camelContext::setUnitOfWorkFactory);
        registerPropertyForBeanType(applicationContext, RuntimeEndpointRegistry.class, camelContext::setRuntimeEndpointRegistry);

        registerPropertiesForBeanTypes(applicationContext, TypeConverters.class, camelContext.getTypeConverterRegistry()::addTypeConverters);

        final Predicate<EventNotifier> containsEventNotifier = managementStrategy.getEventNotifiers()::contains;
        registerPropertiesForBeanTypesWithCondition(applicationContext, EventNotifier.class, containsEventNotifier.negate(), managementStrategy::addEventNotifier);

        registerPropertiesForBeanTypes(applicationContext, EndpointStrategy.class, camelContext::addRegisterEndpointCallback);

        registerPropertyForBeanType(applicationContext, ShutdownStrategy.class, camelContext::setShutdownStrategy);
        
        final Predicate<InterceptStrategy> containsInterceptStrategy = camelContext.getInterceptStrategies()::contains;
        registerPropertiesForBeanTypesWithCondition(applicationContext, InterceptStrategy.class, containsInterceptStrategy.negate(), camelContext::addInterceptStrategy);

        final Predicate<LifecycleStrategy> containsLifecycleStrategy = camelContext.getLifecycleStrategies()::contains;
        registerPropertiesForBeanTypesWithCondition(applicationContext, LifecycleStrategy.class, containsLifecycleStrategy.negate(), camelContext::addLifecycleStrategy);

        registerPropertiesForBeanTypes(applicationContext, CamelClusterService.class, addServiceToContext(camelContext));


        registerPropertiesForBeanTypes(applicationContext, RoutePolicyFactory.class, camelContext::addRoutePolicyFactory);

        registerPropertiesForBeanTypes(applicationContext, HealthCheckRepository.class, healthCheckRegistry::addRepository);

        registerPropertyForBeanType(applicationContext, HealthCheckService.class, addServiceToContext(camelContext));
        registerPropertyForBeanType(applicationContext, RouteController.class, camelContext::setRouteController);
        registerPropertyForBeanType(applicationContext, UuidGenerator.class, camelContext::setUuidGenerator);

        final Predicate<LogListener> containsLogListener = camelContext.getLogListeners()::contains;
        registerPropertiesForBeanTypesWithCondition(applicationContext, LogListener.class, containsLogListener.negate(), camelContext::addLogListener);

        registerPropertyForBeanType(applicationContext, ExecutorServiceManager.class, camelContext::setExecutorServiceManager);
    private static <T> Consumer<T> addServiceToContext(final CamelContext camelContext) {
        return service -> {
            try {
                camelContext.addService(service);
            } catch (Exception e) {
                throw new RuntimeException("Unable to add service to Camel context", e);
            }
        };
    }

    private static <T> void registerPropertyForBeanType(final ApplicationContext applicationContext, final Class<T> beanType, final Consumer<T> propertySetter) {
        T propertyBean = getSingleBeanOfType(applicationContext, beanType);
        if (propertyBean == null) {
            return;
        }

        LOG.info("Using custom {}: {}", beanType.getSimpleName(), propertyBean);
        propertySetter.accept(propertyBean);
    }

    private static <T> void registerPropertiesForBeanTypes(final ApplicationContext applicationContext, final Class<T> beanType, final Consumer<T> propertySetter) {
        registerPropertiesForBeanTypesWithCondition(applicationContext, beanType, b -> true, propertySetter);
    }

    private static <T> void registerPropertiesForBeanTypesWithCondition(final ApplicationContext applicationContext, final Class<T> beanType, final Predicate<T> condition,
        final Consumer<T> propertySetter) {
        final Map<String, T> beans = applicationContext.getBeansOfType(beanType);
        if (!ObjectHelper.isNotEmpty(beans)) {
            return;
        }

        final String simpleName = beanType.getSimpleName();
        beans.forEach((name, bean) -> {
            if (condition.test(bean)) {
                LOG.info("Adding custom {} with id: {} and implementation: {}", simpleName, name, bean);
                propertySetter.accept(bean);
            }
        });
    }
    
