    public static final char[] RAW_TOKEN_START = {'(', '{'};
    public static final char[] RAW_TOKEN_END = {')', '}'};
    private static final Pattern SECRETS = Pattern.compile("([?&][^=]*(?:passphrase|password|secretKey)[^=]*)=(RAW[({].*[)}]|[^&]*)", Pattern.CASE_INSENSITIVE);
    // (applies to URI with authority component and userinfo token in the form
    // "user:password").
    // (applies to URI path with authority component and userinfo token in the
    // form "user:password").
     * Removes detected sensitive information (such as passwords) from the URI
     * and returns the result.
     * @return Returns null if the uri is null, otherwise the URI with the
     *         passphrase, password or secretKey sanitized.
     * Extracts the scheme specific path from the URI that is used as the
     * remainder option when creating endpoints.
     * @param u the URI
     * The URI parameters will by default be URI encoded. However you can define
     * a parameter values with the syntax: <tt>key=RAW(value)</tt> which tells
     * Camel to not encode the value, and use the value as is (eg key=value) and
     * the value has <b>not</b> been encoded.
     * The URI parameters will by default be URI encoded. However you can define
     * a parameter values with the syntax: <tt>key=RAW(value)</tt> which tells
     * Camel to not encode the value, and use the value as is (eg key=value) and
     * the value has <b>not</b> been encoded.
     * The URI parameters will by default be URI encoded. However you can define
     * a parameter values with the syntax: <tt>key=RAW(value)</tt> which tells
     * Camel to not encode the value, and use the value as is (eg key=value) and
     * the value has <b>not</b> been encoded.
     * @param lenient whether to parse lenient and ignore trailing & markers
     *            which has no key or value which can happen when using HTTP
     *            components
            throw new URISyntaxException(uri, "Invalid uri syntax: Trailing & marker found. "  "Check the uri and remove the trailing & marker.");
     * Scans RAW tokens in the string and returns the list of pair indexes which
     * tell where a RAW token starts and ends in the string.
     * This is a companion method with {@link #isRaw(int, List)} and the
     * returned value is supposed to be used as the parameter of that method.
     * @return the list of pair indexes which represent the start and end
     *         positions of a RAW token
     * Tests if the index is within any pair of the start and end indexes which
     * represent the start and end positions of a RAW token.
     * This is a companion method with {@link #scanRaw(String)} and is supposed
     * to consume the returned value of that method as the second parameter
     * <tt>pairs</tt>.
     * @param pairs the list of pair indexes which represent the start and end
     *            positions of a RAW token
     * @return <tt>true</tt> if the index is within any pair of the indexes,
     *         <tt>false</tt> otherwise
     * Traverses the given parameters, and resolve any parameter values which
     * uses the RAW token syntax: <tt>key=RAW(value)</tt>. This method will then
     * remove the RAW tokens, and replace the content of the value, with just
     * the value.
                List list = (List)value;
        // assemble string as new uri and replace parameters with the query
        // instead
     * @param value the value
     * @param options the map with the options (eg key/value pairs)
     * @return a query string with <tt>key1=value&key2=value2&...</tt>, or an
     *         empty string if there is no options.
                    String key = (String)o;
                    // the value may be a list since the same key has multiple
                    // values
                        List<String> list = (List<String>)value;
                            // append & separator if there is more in the list
                            // to append
     * It keeps the original parameters and if a new parameter is already
     * defined in {@code originalURI}, it will be replaced by its value in
     * {@code newParameters}.
     * @param originalURI the original URI
     * @throws URISyntaxException is thrown if the uri syntax is invalid
     * Normalizes the uri by reordering the parameters so they are sorted and
     * thus we can use the uris for endpoint matching.
     * The URI parameters will by default be URI encoded. However you can define
     * a parameter values with the syntax: <tt>key=RAW(value)</tt> which tells
     * Camel to not encode the value, and use the value as is (eg key=value) and
     * the value has <b>not</b> been encoded.
        // okay if we have user info in the path and they use @ in username or
        // password,
        // then we need to encode them (but leave the last @ sign before the
        // hostname)
        // this is needed as Camel end users may not encode their user info
        // properly, but expect
        // this to work out of the box with Camel, and hence we need to fix it
        // for them
