        Map<String, String> options = buildEndpointOptions(remaining, parameters);
        // now create the endpoint instance which either happens with a new
        // base component which has been pre-configured for this connector
        // or we fallback and use the default component in the camel context
        createNewBaseComponent(scheme);
        // create the uri of the base component
        log.debug("Connector resolved: {} -> {}", uri, delegateUri);
        return new DefaultConnectorEndpoint(uri, this, delegate, model.getInputDataType(), model.getOutputDataType());
                    options = (Map) buildEndpointOptions(null, map);
        if (model.getBaseScheme() == null) {
            throw new IllegalArgumentException("Camel connector must have baseSchema defined in camel-connector.json file");
        }
        if (model.getBaseJavaType() == null) {
            throw new IllegalArgumentException("Camel connector must have baseJavaType defined in camel-connector.json file");
        }
    private Component createNewBaseComponent(String scheme) throws Exception {
        String baseClassName = model.getBaseJavaType();

        if (baseClassName != null) {
            // create a new instance of this base component
            Class<?> type = Class.forName(baseClassName);
            Constructor ctr = getPublicDefaultConstructor(type);
            if (ctr != null) {
                // call default no-arg constructor
                Object base = ctr.newInstance();

                // the connector may have default values for the component level also
                // and if so we need to prepare these values and set on this component before we can start
                Map<String, String> defaultOptions = model.getDefaultComponentOptions();

                if (!defaultOptions.isEmpty()) {
                    Map<String, Object> copy = new LinkedHashMap<>();
                    for (Map.Entry<String, String> entry : defaultOptions.entrySet()) {
                        String key = entry.getKey();
                        String value = entry.getValue();
                        if (value != null) {
                            // also support {{ }} placeholders so resolve those first
                            value = getCamelContext().resolvePropertyPlaceholders(value);
                            log.debug("Using component option: {}={}", key, value);
                            copy.put(key, value);
                        }
                    }
                    IntrospectionSupport.setProperties(getCamelContext(), getCamelContext().getTypeConverter(), base, copy);
                }

                // configure component with extra options
                if (componentOptions != null && !componentOptions.isEmpty()) {
                    Map<String, Object> copy = new LinkedHashMap<>(componentOptions);
                    IntrospectionSupport.setProperties(getCamelContext(), getCamelContext().getTypeConverter(), base, copy);
                }

                if (base instanceof Component) {
                    getCamelContext().removeComponent(scheme);
                    // ensure component is started and stopped when Camel shutdown
                    getCamelContext().addService(base, true, true);
                    getCamelContext().addComponent(scheme, (Component) base);

                    return (Component) base;
                }
            }
        }

        return null;
    }

    private Map<String, String> buildEndpointOptions(String remaining, Map<String, Object> parameters) throws URISyntaxException {

    private static Constructor getPublicDefaultConstructor(Class<?> clazz) {
        for (Constructor ctr : clazz.getConstructors()) {
            if (Modifier.isPublic(ctr.getModifiers()) && ctr.getParameterCount() == 0) {
                return ctr;
            }
        }
        return null;
    }
