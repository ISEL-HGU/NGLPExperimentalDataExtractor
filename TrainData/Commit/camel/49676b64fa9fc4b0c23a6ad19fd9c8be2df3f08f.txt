import java.util.Collections;
import javax.net.ssl.SSLContext;

import io.undertow.protocols.ssl.UndertowXnioSsl;

import org.apache.camel.CamelContext;
import org.apache.camel.http.common.cookie.CookieHandler;
import org.xnio.ssl.XnioSsl;
 * The implementation of Producer is considered as experimental. The Undertow
 * client classes are not thread safe, their purpose is for the reverse proxy
 * usage inside Undertow itself. This may change in the future versions and
 * general purpose HTTP client wrapper will be added. Therefore this Producer
 * may be changed too.
    private UndertowClient client;
    private final UndertowEndpoint endpoint;
    private final OptionMap options;
    private DefaultByteBufferPool pool;
    private XnioSsl ssl;
    private XnioWorker worker;

    public UndertowProducer(final UndertowEndpoint endpoint, final OptionMap options) {
    public boolean process(final Exchange camelExchange, final AsyncCallback callback) {
        final URI uri;
        final HttpString method;
            final String exchangeUri = UndertowHelper.createURL(camelExchange, getEndpoint());
            uri = UndertowHelper.createURI(camelExchange, exchangeUri, getEndpoint());
            method = UndertowHelper.createMethod(camelExchange, endpoint, camelExchange.getIn().getBody() != null);
        } catch (final URISyntaxException e) {
            camelExchange.setException(e);
        final String pathAndQuery = URISupport.pathAndQueryOf(uri);
        final UndertowHttpBinding undertowHttpBinding = endpoint.getUndertowHttpBinding();

        final CookieHandler cookieHandler = endpoint.getCookieHandler();
        final Map<String, List<String>> cookieHeaders;
        if (cookieHandler != null) {
            try {
                cookieHeaders = cookieHandler.loadCookies(camelExchange, uri);
            } catch (final IOException e) {
                camelExchange.setException(e);
                callback.done(true);
                return true;
            }
        } else {
            cookieHeaders = Collections.emptyMap();
        }

        final ClientRequest request = new ClientRequest();
        request.setMethod(method);
        request.setPath(pathAndQuery);

        final HeaderMap requestHeaders = request.getRequestHeaders();

        // Set the Host header
        final Message message = camelExchange.getIn();
        final String host = message.getHeader(Headers.HOST_STRING, String.class);
        requestHeaders.put(Headers.HOST, Optional.ofNullable(host).orElseGet(() -> uri.getAuthority()));

        final Object body = undertowHttpBinding.toHttpRequest(request, camelExchange.getIn());

        final TypeConverter tc = endpoint.getCamelContext().getTypeConverter();
        final ByteBuffer bodyAsByte = tc.tryConvertTo(ByteBuffer.class, body);

        if (body != null) {
            requestHeaders.put(Headers.CONTENT_LENGTH, bodyAsByte.remaining());
        }

        for (final Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
            requestHeaders.putAll(HttpString.tryFromString(entry.getKey()), entry.getValue());
        }

        if (LOG.isDebugEnabled()) {
            LOG.debug("Executing http {} method: {}", method, pathAndQuery);
        }

        final UndertowClientCallback clientCallback = new UndertowClientCallback(camelExchange, callback, getEndpoint(),
            request, bodyAsByte);

        // when connect succeeds or fails UndertowClientCallback will
        // get notified on a I/O thread run by Xnio worker. The writing
        // of request and reading of response is performed also in the
        // callback
        client.connect(clientCallback, uri, worker, ssl, pool, options);

        // the call above will proceed on Xnio I/O thread we will
        // notify the exchange asynchronously when the HTTP exchange
        // ends with success or failure from UndertowClientCallback
        return false;
        // as in Undertow tests
        pool = new DefaultByteBufferPool(true, 17 * 1024);
        final Xnio xnio = Xnio.getInstance();
        worker = xnio.createWorker(options);

        final SSLContext sslContext = getEndpoint().getSslContext();
        if (sslContext != null) {
            ssl = new UndertowXnioSsl(xnio, options, sslContext);
        }

        final CamelContext camelContext = getEndpoint().getCamelContext();
        client = UndertowClient.getInstance(camelContext.getApplicationContextClassLoader());
