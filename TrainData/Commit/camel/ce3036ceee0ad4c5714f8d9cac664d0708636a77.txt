            
            try {
                while (it.hasNext()) {
                    final ProcessorExchangePair pair = it.next();
                    // in case the iterator returns null then continue to next
                    if (pair == null) {
                        continue;
                    }
    
                    final Exchange subExchange = pair.getExchange();
                    updateNewExchange(subExchange, total.intValue(), pairs, it);
    
                    completion.submit(new Callable<Exchange>() {
                        public Exchange call() throws Exception {
                            // start the aggregation task at this stage only in order not to pile up too many threads
                            if (aggregationTaskSubmitted.compareAndSet(false, true)) {
                                // but only submit the aggregation task once
                                aggregateExecutorService.submit(aggregateOnTheFlyTask);
                            }
    
                            if (!running.get()) {
                                // do not start processing the task if we are not running
                                return subExchange;
                            }
    
                            try {
                                doProcessParallel(pair);
                            } catch (Throwable e) {
                                subExchange.setException(e);
                            }
    
                            // Decide whether to continue with the multicast or not; similar logic to the Pipeline
                            Integer number = getExchangeIndex(subExchange);
                            boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, "Parallel processing failed for number "  number, LOG);
                            if (stopOnException && !continueProcessing) {
                                // signal to stop running
                                running.set(false);
                                // throw caused exception
                                if (subExchange.getException() != null) {
                                    // wrap in exception to explain where it failed
                                    CamelExchangeException cause = new CamelExchangeException("Parallel processing failed for number "  number, subExchange, subExchange.getException());
                                    subExchange.setException(cause);
                                }
                            }
    
                            LOG.trace("Parallel processing complete for exchange: {}", subExchange);
                    });
    
                    total.incrementAndGet();
                }
            } catch (RuntimeException e) {
                // The methods it.hasNext and it.next can throw RuntimeExceptions when custom iterators are implemented.
                // We have to catch the exception here otherwise the aggregator threads would pile up.
                executionException.set(e);
