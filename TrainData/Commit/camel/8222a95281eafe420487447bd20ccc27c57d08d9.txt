    /**
     * Root element of the internal tree
     */

    /**
     * Reference to current "level-s" element
     */
    /**
     * Creates a new XmlJsonStreamWriter instance
     * @param jsonGenerator the {@link JsonGenerator} to use to write the json document
     */
    public void writeStartElement(String localName) {
    public void writeStartElement(String namespaceURI, String localName) {
    public void writeStartElement(String prefix, String localName, String namespaceURI) {
    public void writeEmptyElement(String namespaceURI, String localName) {
    public void writeEmptyElement(String prefix, String localName, String namespaceURI) {
    public void writeEmptyElement(String localName) {
    public void writeEndElement() {
        currentTreeElement.writeEnd();
    public void writeAttribute(String localName, String value) {
    public void writeAttribute(String prefix, String namespaceURI, String localName, String value) {
            case XJConstants.TYPE_HINT_NAME:
                currentTreeElement.setName(value);
                return;
            case XJConstants.TYPE_HINT_TYPE:
                currentTreeElement.setJsonToken(XJConstants.TYPE_JSONTYPE_MAP.get(value));
                return;
            default:
                return;
    public void writeAttribute(String namespaceURI, String localName, String value) {
    public void writeNamespace(String prefix, String namespaceURI) {
        // ignore event - we don't care
    public void writeDefaultNamespace(String namespaceURI) {
        // ignore event - we don't care
    public void writeComment(String data) {
        // ignore event - we don't care
    public void writeProcessingInstruction(String target) {
        // ignore event - we don't care
    public void writeProcessingInstruction(String target, String data) {
        // ignore event - we don't care
    public void writeCData(String data) {
    public void writeDTD(String dtd) {
        // ignore event - we don't care
    public void writeEntityRef(String name) {
        // ignore event - we don't care
    public void writeStartDocument() {
    public void writeStartDocument(String version) {
    public void writeStartDocument(String encoding, String version) {
    public void writeCharacters(String text) {
    public void writeCharacters(char[] text, int start, int len) {
    public String getPrefix(String uri) {
    public void setPrefix(String prefix, String uri) {
        // ignore - ATM we don't care
    public void setDefaultNamespace(String uri) {
        // ignore - ATM we don't care
    public void setNamespaceContext(NamespaceContext context) {
        // ignore - ATM we don't care
    }

    @Override
    /**
     * Class that represents an element of the internal tree
     */
        void writeEnd() {
                // no type hints
            } else {
                // type hints given
            if (xmlEvent == XMLEvent.START_ELEMENT) {
                if (childs.isEmpty()) {
                    // empty root element
                    if (this.parent.jsonToken == JsonToken.NOT_AVAILABLE) {
                        jsonToken = JsonToken.START_OBJECT;
                        jsonToken = JsonToken.FIELD_NAME;
                        final TreeElement treeElement = new TreeElement(this, -1, JsonToken.VALUE_STRING);
                        treeElement.setValue("");
                        this.addChild(treeElement);
                    }
                } else if (childs.size() == 1 && childs.get(0).xmlEvent == XMLEvent.CHARACTERS) {
                    // just character childs.

                    // empty root element
                    if (this.parent.jsonToken == JsonToken.NOT_AVAILABLE) {
                        final TreeElement child = childs.get(0);
                        if (isWhitespace(child.value)) {
                            childs.remove(0);
                        } else {
                            // create new intermediary element
                            final TreeElement treeElement = new TreeElement(this, -1, JsonToken.FIELD_NAME, XJConstants.JSON_WRITER_MIXED_CONTENT_TEXT_KEY);
                            treeElement.addChild(child);
                            childs.set(childs.indexOf(child), treeElement);
                            child.parent = treeElement;
                        }
                    } else {
                        jsonToken = JsonToken.FIELD_NAME;
                    }
                } else {
                    // mixed content fixup.
                    final Iterator<TreeElement> iterator = childs.iterator();
                    while (iterator.hasNext()) {
                        TreeElement element = iterator.next();
                        if (element.jsonToken == JsonToken.VALUE_STRING) {
                            if (isWhitespace(element.value)) {
                                // remove element if is (ignorable-) whitespace
                                iterator.remove();
                            } else {
                                // create new intermediary element
                                final TreeElement treeElement = new TreeElement(this, -1, JsonToken.FIELD_NAME,
                                        element.name != null ? element.name : XJConstants.JSON_WRITER_MIXED_CONTENT_TEXT_KEY);
                                treeElement.addChild(element);
                                childs.set(childs.indexOf(element), treeElement);
                                element.parent = treeElement;
                                element.jsonToken = JsonToken.VALUE_STRING;

                    jsonToken = JsonToken.START_OBJECT;

                    wrapChildsInArrayIfNecessary();
                }
            } else {
                throw new IllegalStateException("XMLEvent: "  xmlEvent  "; Json Token: "  jsonToken);
            case VALUE_NULL:
            case VALUE_STRING:
            case VALUE_NUMBER_INT:
            case VALUE_NUMBER_FLOAT:
            case VALUE_TRUE:
            case VALUE_FALSE:
                if (childs.isEmpty()) {
                    final TreeElement treeElement = new TreeElement(this, -1, jsonToken);
                    treeElement.setValue("");
                    this.addChild(treeElement);
                    jsonToken = JsonToken.FIELD_NAME;
                } else if (childs.size() == 1) {
                    childs.get(0).jsonToken = jsonToken;
                    jsonToken = JsonToken.FIELD_NAME;
                } else {
                    // create FIELD childs if element contains text and attributes.
                                final TreeElement treeElement = new TreeElement(this, -1, JsonToken.FIELD_NAME,
                                        element.name != null ? element.name : XJConstants.JSON_WRITER_MIXED_CONTENT_TEXT_KEY);
                                if (element.xmlEvent == XMLEvent.CHARACTERS) {
                                    element.jsonToken = jsonToken;
                                }
                    jsonToken = JsonToken.START_OBJECT;
                    wrapChildsInArrayIfNecessary();
                }
                break;
            case START_OBJECT:
            case START_ARRAY:
                // mixed content fixup.
                final Iterator<TreeElement> iterator = childs.iterator();
                while (iterator.hasNext()) {
                    TreeElement element = iterator.next();
                    if (isValueToken(element.jsonToken)) {
                        if (isWhitespace(element.value)) {
                            // remove element if is (ignorable-) whitespace
                            iterator.remove();
                        } else {
                            // create new intermediary element
                            final TreeElement treeElement = new TreeElement(this, -1, JsonToken.FIELD_NAME, XJConstants.JSON_WRITER_MIXED_CONTENT_TEXT_KEY);
                            treeElement.addChild(element);
                            childs.set(childs.indexOf(element), treeElement);
                            element.parent = treeElement;
                }
                if (jsonToken != JsonToken.START_ARRAY) {
                    wrapChildsInArrayIfNecessary();
                }

                break;
            default:
                throw new IllegalStateException("XMLEvent: "  xmlEvent  "; Json Token: "  jsonToken);
            }
        }

        private void wrapChildsInArrayIfNecessary() {
            final Map<String, Set<TreeElement>> childElementsMap = childs.stream()
                    .collect(Collectors.groupingBy(o -> o.name, HashMap::new, Collectors.toCollection(LinkedHashSet::new)));

            // create arrays if element with the same name occurs more than once.
            for (Map.Entry<String, Set<TreeElement>> mapEntry : childElementsMap.entrySet()) {
                if (mapEntry.getValue().size() > 1) {
                    if (childElementsMap.size() == 1) {
                        jsonToken = JsonToken.START_ARRAY;
                    } else {
                        final TreeElement treeElement = new TreeElement(this, -1, JsonToken.START_ARRAY, mapEntry.getKey());
                        treeElement.childs = new ArrayList<>(mapEntry.getValue());
                        for (TreeElement child : treeElement.childs) {
                            child.parent = treeElement;
                        }

                        final List<TreeElement> newChildList = new ArrayList<>(this.childs.size() - mapEntry.getValue().size()  1);
                        for (TreeElement e : this.childs) {
                            if (!mapEntry.getValue().contains(e)) {
                                newChildList.add(e);
                            }
                        }
                        childs = newChildList;
                        childs.add(treeElement);
                    }
                }
            return jsonToken == JsonToken.VALUE_STRING
                    || jsonToken == JsonToken.VALUE_NUMBER_FLOAT
                    || jsonToken == JsonToken.VALUE_NUMBER_INT
                    || jsonToken == JsonToken.VALUE_TRUE
                    || jsonToken == JsonToken.VALUE_FALSE
                    || jsonToken == JsonToken.VALUE_NULL;
            case NOT_AVAILABLE:
                break;
            case START_OBJECT:
                if (parent.jsonToken == JsonToken.START_OBJECT) {
                    jsonGenerator.writeObjectFieldStart(name);
                } else {
                    jsonGenerator.writeStartObject();
                }
                break;
            case START_ARRAY:
                if (parent.jsonToken == JsonToken.START_OBJECT) {
                    jsonGenerator.writeArrayFieldStart(name);
                } else {
                    jsonGenerator.writeStartArray();
                }
                break;
            case FIELD_NAME:
                if (parent.jsonToken != JsonToken.START_ARRAY) {
                    jsonGenerator.writeFieldName(name);
                }
                break;
            case VALUE_STRING:
                jsonGenerator.writeString(value);
                break;
            case VALUE_NUMBER_INT:
            case VALUE_NUMBER_FLOAT:
            case VALUE_TRUE:
            case VALUE_FALSE:
                if (value == null || value.isEmpty()) {
                } else {
                    jsonGenerator.writeRawValue(value);
                }
                break;
            case VALUE_NULL:
                jsonGenerator.writeNull();

                break;
            default:
                throw new IllegalStateException("XMLEvent: "  xmlEvent  "; Json Token: "  jsonToken);
            case START_OBJECT:
                jsonGenerator.writeEndObject();
                break;
            case START_ARRAY:
                jsonGenerator.writeEndArray();
                break;
            case VALUE_NULL:
            case NOT_AVAILABLE:
            case FIELD_NAME:
            case VALUE_STRING:
            case VALUE_NUMBER_INT:
            case VALUE_NUMBER_FLOAT:
            case VALUE_TRUE:
            case VALUE_FALSE:
                // nop;
                break;
            default:
                throw new IllegalStateException("XMLEvent: "  xmlEvent  "; Json Token: "  jsonToken);
            return "TreeElement{"
                     "name='"  name  '\''
                     ", value='"  value  '\''
                     ", xmlEvent="  xmlEvent
                     ", jsonToken="  jsonToken
                     '}';
