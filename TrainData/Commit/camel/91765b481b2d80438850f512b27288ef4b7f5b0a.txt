/*
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
import org.apache.camel.PropertyBindingException;
    // TODO: Add support for Map/List
     * @return              true if all the properties was bound, false otherwise
    public static boolean bindProperties(CamelContext camelContext, Object target, Map<String, Object> properties) {
        boolean answer = true;
            answer &= bindProperty(camelContext, target, entry.getKey(), entry.getValue());
    public static boolean bindProperty(CamelContext camelContext, Object target, String name, Object value) {
        try {
            if (target != null && name != null) {
                return setProperty(camelContext, target, name, value);
            }
        } catch (Exception e) {
            throw new PropertyBindingException(target, name, e);
        }

        return false;
    }

    /**
     * Binds the mandatory property to the target object (will fail if not set/bound).
     *
     * @param camelContext  the camel context
     * @param target        the target object
     * @param name          name of property
     * @param value         value of property
     */
    public static void bindMandatoryProperty(CamelContext camelContext, Object target, String name, Object value) {
        try {
            if (target != null && name != null) {
                boolean bound = setProperty(camelContext, target, name, value);
                if (!bound) {
                    throw new PropertyBindingException(target, name);
                }
            }
        } catch (Exception e) {
            throw new PropertyBindingException(target, name, e);
    private static boolean setProperty(CamelContext context, Object target, String name, Object value) throws Exception {
            target = newTarget;
            name = parts[parts.length - 1];
        }

        if (value instanceof String) {
            if (value.toString().startsWith("class:")) {
                // its a new class to be created
                String className = value.toString().substring(6);
                Class<?> type = context.getClassResolver().resolveMandatoryClass(className);
                if (type != null) {
                    value = context.getInjector().newInstance(type);
                }
            } else if (value.toString().startsWith("#type:")) {
                // its reference by type, so lookup the actual value and use it if there is only one instance in the registry
                String typeName = value.toString().substring(6);
                Class<?> type = context.getClassResolver().resolveMandatoryClass(typeName);
                if (type != null) {
                    Set<?> types = context.getRegistry().findByType(type);
                    if (types.size() == 1) {
                        value = types.iterator().next();
            } else if (EndpointHelper.isReferenceParameter(value.toString())) {
                // okay its a reference so swap to lookup this which is already supported in IntrospectionSupport
                refName = value.toString();
                value = null;
        return IntrospectionSupport.setProperty(context, context.getTypeConverter(), target, name, value, refName, true);
