import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Address;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Envelope;

 * The rabbitmq component allows you produce and consume messages from
 * <a href="http://www.rabbitmq.com/">RabbitMQ</a> instances.
@UriEndpoint(firstVersion = "2.12.0", scheme = "rabbitmq", title = "RabbitMQ", syntax = "rabbitmq:hostname:portNumber/exchangeName", consumerClass = RabbitMQConsumer.class, label = "messaging")
    @UriPath
    @Metadata(required = "true")
    @UriPath(defaultValue = "5672")
    @Metadata(required = "true")
    @UriPath
    @Metadata(required = "true")
    private boolean passive;
    // camel-jms supports this setting but it is not currently configurable in
    // camel-rabbitmq
    // camel-jms supports this setting but it is not currently configurable in
    // camel-rabbitmq
    // camel-jms supports this setting but it is not currently configurable in
    // camel-rabbitmq
        // If it is BridgeEndpoint we should ignore the message header of
        // EXCHANGE_NAME
     * The consumer uses a Thread Pool Executor with a fixed number of threads.
     * This setting allows you to set that number of threads.
     * Port number for the host with the running rabbitmq instance or cluster.
     * Default value is 5672.
     * If we are declaring a durable exchange (the exchange will survive a
     * server restart)
     * The exchange name determines which exchange produced messages will sent
     * to. In the case of consumers, the exchange name determines which exchange
     * the queue will bind to.
     * The routing key to use when binding a consumer queue to the exchange. For
     * producer routing keys, you set the header rabbitmq.ROUTING_KEY.
     * If true the producer will not declare and bind a queue. This can be used
     * for directing messages via an existing routing key.
     * 
     * If the bridgeEndpoint is true, the producer will ignore the message
     * header of "rabbitmq.EXCHANGE_NAME" and "rabbitmq.ROUTING_KEY"
     * If this option is set, camel-rabbitmq will try to create connection based
     * on the setting of option addresses. The addresses value is a string which
     * looks like "server1:12345, server2:12345"
     * To use a custom RabbitMQ connection factory. When this option is set, all
     * connection options (connectionTimeout, requestedChannelMax...) set on URI
     * are not used
     * Configure SSL trust manager, SSL should be enabled for this option to be
     * effective
     * Connection client properties (client info used in negotiating with the
     * server)
     * Enables connection automatic recovery (uses connection implementation
     * that performs automatic recovery when connection shutdown is not
     * initiated by the application)
     * Network recovery interval in milliseconds (interval used when recovering
     * from network failure)
     * Enables connection topology recovery (should topology recovery be
     * performed?)
     * Enables the quality of service on the RabbitMQConsumer side. You need to
     * specify the option of prefetchSize, prefetchCount, prefetchGlobal at the
     * same time
     * The maximum amount of content (measured in octets) that the server will
     * deliver, 0 if unlimited. You need to specify the option of prefetchSize,
     * prefetchCount, prefetchGlobal at the same time
     * The maximum number of messages that the server will deliver, 0 if
     * unlimited. You need to specify the option of prefetchSize, prefetchCount,
     * prefetchGlobal at the same time
     * If the settings should be applied to the entire channel rather than each
     * consumer You need to specify the option of prefetchSize, prefetchCount,
     * prefetchGlobal at the same time
     * Number of concurrent consumers when consuming from broker. (eg similar as
     * to the same option for the JMS component).
     * If the option is true, camel declare the exchange and queue name and bind
     * them together. If the option is false, camel won't declare the exchange
     * and queue name on the server.
     * Set the maximum number of milliseconds to wait for a channel from the
     * pool
     * This flag tells the server how to react if the message cannot be routed
     * to a queue. If this flag is set, the server will return an unroutable
     * message with a Return method. If this flag is zero, the server silently
     * drops the message.
     * This flag tells the server how to react if the message cannot be routed
     * to a queue consumer immediately. If this flag is set, the server will
     * return an undeliverable message with a Return method. If this flag is
     * zero, the server will queue the message, but with no guarantee that it
     * will ever be consumed.
     * Specify arguments for configuring the different RabbitMQ concepts, a
     * different prefix is required for each:
     * <li>Exchange: arg.exchange.</li>
     * <li>Queue: arg.queue.</li>
     * <li>Binding: arg.binding.</li>
     * Key/value args for configuring the queue binding parameters when
     * declare=true
     * Set the configurer for setting the exchange args in
     * Channel.exchangeDeclare
     * Set timeout for waiting for a reply when using the InOut Exchange Pattern
     * (in milliseconds)
     * When true and an inOut Exchange failed on the consumer side send the
     * caused Exception back in the response
     * When true, the message will be published with
     * <a href="https://www.rabbitmq.com/confirms.html">publisher
     * acknowledgements</a> turned on
     * The amount of time in milliseconds to wait for a basic.ack response from
     * RabbitMQ server
     * When true, an exception will be thrown when the message cannot be
     * delivered (basic.return) and the message is marked as mandatory.
     * PublisherAcknowledgement will also be activated in this case See also <a
     * href=https://www.rabbitmq.com/confirms.html">publisher
     * acknowledgements</a> - When will messages be confirmed?
     * Exclusive queues may only be accessed by the current connection, and are
     * deleted when that connection closes.


