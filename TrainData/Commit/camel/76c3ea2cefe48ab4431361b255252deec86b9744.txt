
import org.apache.camel.support.EndpointHelper;
import org.apache.camel.support.service.ServiceHelper;

 * To use Zipkin with Camel then setup this {@link ZipkinTracer} in your Camel
 * application.
 * Events (span) are captured for incoming and outgoing messages being sent
 * to/from Camel. This means you need to configure which which Camel endpoints
 * that maps to zipkin service names. The mapping can be configured using
 * For both kinds you can use wildcards and regular expressions to match, which
 * is using the rules from {@link PatternHelper#matchPattern(String, String)}
 * and {@link EndpointHelper#matchEndpoint(CamelContext, String, String)}
 * To match all Camel messages you can use <tt>*</tt> in the pattern and
 * configure that to the same service name. <br/>
 * If no mapping has been configured then Camel will fallback and use endpoint
 * uri's as service names. However its recommended to configure service mappings
 * so you can use human logic names instead of Camel endpoint uris in the names.
 * Camel will auto-configure a {@link Reporter span reporter} one hasn't been
 * explicitly configured, and if the hostname and port to a zipkin collector has
 * been configured as environment variables
 * <li>ZIPKIN_COLLECTOR_HTTP_SERVICE_HOST - The http hostname</li>
 * <li>ZIPKIN_COLLECTOR_HTTP_SERVICE_PORT - The port number</li>
 * <li>ZIPKIN_COLLECTOR_THRIFT_SERVICE_HOST - The Scribe (Thrift RPC)
 * hostname</li>
 * <li>ZIPKIN_COLLECTOR_THRIFT_SERVICE_PORT - The port number</li>
 * This class is implemented as both an
 * {@link org.apache.camel.spi.EventNotifier} and {@link RoutePolicy} that
 * allows to trap when Camel starts/ends an {@link Exchange} being routed using
 * the {@link RoutePolicy} and during the routing if the {@link Exchange} sends
 * messages, then we track them using the
 * {@link org.apache.camel.spi.EventNotifier}.
// NOTE: this implementation currently only does explicit propagation, meaning
// that non-camel
// components will not see the current trace context, and therefore will be
// unassociated. This can
// be fixed by using CurrentTraceContext to scope a span where user code is
// invoked.
// If this is desirable, an instance variable of
// CurrentTraceContext.Default.create() could do the
        @Override
        public String get(Message message, String key) {
        @Override
        public void put(Message message, String key, String value) {
     * Registers this {@link ZipkinTracer} on the {@link CamelContext} if not
     * already registered.
                // start this service eager so we init before Camel is starting
                // up
     * Sets the POST URL for zipkin's
     * <a href="http://zipkin.io/zipkin-api/#/">v2 api</a>, usually
     * Configures a rate that decides how many events should be traced by
     * zipkin. The rate is expressed as a percentage (1.0f = 100%, 0.5f is 50%,
     * 0.1f is 10%).
    /**
     * Sets the reporter used to send timing data (spans) to the zipkin server.
     */
    /**
     * Returns the reporter used to send timing data (spans) to the zipkin
     * server.
     */
     * Adds a client service mapping that matches Camel events to the given
     * zipkin service name. See more details at the class javadoc.
     * @param pattern the pattern such as route id, endpoint url
     * Adds a server service mapping that matches Camel events to the given
     * zipkin service name. See more details at the class javadoc.
     * @param pattern the pattern such as route id, endpoint url
     * Adds an exclude pattern that will disable tracing with zipkin for Camel
     * messages that matches the pattern.
     * @param pattern the pattern such as route id, endpoint url
     * This is not recommended for production usage, or when having big
     * payloads. You can limit the size by configuring the <a href=
     * "http://camel.apache.org/how-do-i-set-the-max-chars-when-debug-logging-messages-in-camel.html">max
     * debug log size</a>.
     * By default message bodies that are stream based are <b>not</b> included.
     * You can use the option {@link #setIncludeMessageBodyStreams(boolean)} to
     * Whether to include message bodies that are stream based in the zipkin
     * traces.
     * This requires enabling
     * <a href="http://camel.apache.org/stream-caching.html">stream caching</a>
     * on the routes or globally on the CamelContext.
     * This is not recommended for production usage, or when having big
     * payloads. You can limit the size by configuring the <a href=
     * "http://camel.apache.org/how-do-i-set-the-max-chars-when-debug-logging-messages-in-camel.html">max
     * debug log size</a>.
                // is there a zipkin service setup as ENV variable to auto
                // register a span reporter
            // Try to lookup the span reporter from the registry if only one
            // instance is present
            IOHelper.close((Closeable)spanReporter);
            brave = Tracing.newBuilder().currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder().addScopeDecorator(MDCScopeDecorator.create()).build())
                .localServiceName(serviceName).sampler(Sampler.create(rate)).spanReporter(spanReporter).build();
            brave = Tracing.newBuilder().localServiceName(serviceName).sampler(Sampler.create(rate)).spanReporter(spanReporter).build();
        // if we started from a server span then lets reuse that when we call a
        // downstream service
            INJECTOR.inject(span.context(), exchange.getIn());
            // use event notifier to track events when Camel messages to
            // endpoints
                ExchangeSendingEvent ese = (ExchangeSendingEvent)event;
                ExchangeSentEvent ese = (ExchangeSentEvent)event;
            case ExchangeSending:
            case ExchangeSent:
            case ExchangeCreated:
            case ExchangeCompleted:
            case ExchangeFailed:
                return true;
            default:
                return false;
            // use route policy to track events when Camel a Camel route
            // begins/end the lifecycle of an Exchange

        // Report Server send after route has completed processing of the
        // exchange.
