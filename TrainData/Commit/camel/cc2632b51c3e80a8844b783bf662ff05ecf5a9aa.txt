import java.lang.reflect.Type;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Comparator;
import java.util.regex.Matcher;
import java.util.stream.Stream;

import org.apache.camel.maven.packaging.srcgen.Annotation;
import org.apache.camel.maven.packaging.srcgen.GenericType;
import org.apache.camel.maven.packaging.srcgen.JavaClass;
import org.apache.camel.maven.packaging.srcgen.Method;
import org.apache.camel.maven.packaging.srcgen.Property;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
    private static final Map<Type, Type> PRIMITIVE_CLASSES;
        PRIMITIVE_CLASSES = new HashMap<>();
        PRIMITIVE_CLASSES.put(boolean.class, Boolean.class);
        PRIMITIVE_CLASSES.put(char.class, Character.class);
        PRIMITIVE_CLASSES.put(long.class, Long.class);
        PRIMITIVE_CLASSES.put(int.class, Integer.class);
        PRIMITIVE_CLASSES.put(byte.class, Byte.class);
        PRIMITIVE_CLASSES.put(short.class, Short.class);
        PRIMITIVE_CLASSES.put(double.class, Double.class);
        PRIMITIVE_CLASSES.put(float.class, Float.class);
    DynamicClassLoader projectClassLoader;

        JavaClass commonClass = new JavaClass(getProjectClassLoader());
            Property prop = commonClass.addProperty(type, option.getName());
        writeSourceIfChanged(commonClass, packageName.replaceAll("\\.", "\\/")  "/"  commonName  ".java", true);

        Class commonClazz = generateDummyClass(commonClass.getCanonicalName());
            JavaClass configClass = new JavaClass(getProjectClassLoader());
            configClass.addAnnotation(loadClass("org.springframework.boot.context.properties.ConfigurationProperties")).setStringValue("prefix", propertiesPrefix);
            configClass.addField()
                .setName("configurations")
                .setType(loadType("java.util.Map<java.lang.String, "  packageName  "."  commonName  ">"))
                .setLiteralInitializer("new HashMap<>()")
            Method method;
            method.setReturnType(loadType("java.util.Map<java.lang.String, "  packageName  "."  commonName  ">"));
            String fileName = packageName.replaceAll("\\.", "\\/")  "/"  configName  ".java";
            writeSourceIfChanged(configClass, fileName, true);
        generateDummyClass(packageName  "."  className);

        JavaClass javaClass = new JavaClass(getProjectClassLoader());
            Property prop = javaClass.addProperty(type, name);
        String fileName = packageName.replaceAll("\\.", "\\/")  "/"  className  ".java";
        writeSourceIfChanged(javaClass, fileName, true);
        final JavaClass javaClass = new JavaClass(getProjectClassLoader());
            .setType(loadClass("org.apache.camel.CamelContext"))
            .setType(loadClass(packageName  "."  configType))
        Method method;
        method.setReturnType(loadClass("org.apache.camel.spi.RestConfiguration"));
        writeSourceIfChanged(javaClass, fileName, true);

        final JavaClass javaClass = new JavaClass(getProjectClassLoader());
        javaClass.setPackage(packageName);
        javaClass.setName(name);
        javaClass.extendSuperType("ComponentConfigurationPropertiesCommon");
        Property bogus = javaClass.addProperty("java.lang.Boolean", "enabled");
        javaClass.getJavaDoc().setText(doc);
        javaClass.addAnnotation(Generated.class.getName()).setStringValue("value", SpringBootAutoConfigurationMojo.class.getName());
        Set<JavaClass> nestedTypes = new HashSet<>();
            JavaClass javaClassSource = readJavaType(type);
                type = packageName  "."  name  "$"  option.getShortJavaType()  INNER_TYPE_SUFFIX;
            if (type.equals(packageName  "."  name  "$"  option.getShortJavaType()  INNER_TYPE_SUFFIX)) {
                Class configClass = generateDummyClass(type);
            }

            Property prop = javaClass.addProperty(type, option.getName());
        writeSourceIfChanged(javaClass, fileName, true);
    private void createComponentConfigurationSourceInnerClass(JavaClass javaClass, Set<JavaClass> nestedTypes, ComponentModel model) throws MojoFailureException {
        for (JavaClass nestedType : nestedTypes) {
            final JavaClass innerClass = javaClass.addNestedType()
                    .setPublic()
                    .setStatic(true)
                    .setName(nestedType.getName()  INNER_TYPE_SUFFIX);
            for (Property sourceProp : getProperties(nestedType)) {
                GenericType propType = sourceProp.getType();
                boolean ignore = sourceProp.hasAnnotation(XmlTransient.class);
                if (ignore || propType.getRawClass().getName().equals("org.apache.camel.CamelContext")) {
                String wt = PRIMITIVEMAP.get(propType.toString());
                GenericType ptype = wt != null ? loadType(wt) : propType;
                final Property prop = innerClass.addProperty(ptype, sourceProp.getName());
                if (sourceProp.getField() != null) {
                    prop.getField().getJavaDoc().setText(sourceProp.getField().getJavaDoc().getText());
                    prop.getField().setLiteralInitializer(sourceProp.getField().getLiteralInitializer());
                }

                ComponentOptionModel com = model.getComponentOptions().stream()
                        .filter(o -> o.getName().equals(sourceProp.getName()))
                        .findFirst().orElse(null);
                EndpointOptionModel eom = Stream.concat(model.getEndpointOptions().stream(), model.getEndpointPathOptions().stream())
                        .filter(o -> o.getName().equals(sourceProp.getName()))
                        .findFirst().orElse(null);
                String deprecationNote = null;
                if (eom != null) {
                    prop.getField().getJavaDoc().setText(eom.getDescription());
                    prop.getField().setLiteralInitializer(asLiteralDefault(sourceProp.getType(), eom.getDefaultValue()));
                    deprecationNote = eom.getDeprecationNote();
                } else if (com != null) {
                    prop.getField().getJavaDoc().setText(com.getDescription());
                    prop.getField().setLiteralInitializer(asLiteralDefault(sourceProp.getType(), com.getDefaultValue()));
                    deprecationNote = com.getDeprecationNote();
                }
                if (!propType.getRawClass().isArray()) {
                    optionClass = propType.getRawClass();
                    if (INCLUDE_INNER_PATTERN.matcher(propType.toString()).matches()
                        && !propType.getRawClass().isArray()
                    if (deprecationNote != null && !deprecationNote.isEmpty()) {
                        String jd = prop.getField().getJavaDoc().getText();
                        if (jd != null) {
                            jd = "\n\n";
                        } else {
                            jd = "";
                        }
                        jd = "@deprecated "  deprecationNote;
                        prop.getField().getJavaDoc().setText(jd);
                    }
                final Method mutator = sourceProp.getMutator();
                            prop.setType(loadType(wrapperType));
    private List<Property> getProperties(JavaClass nestedType) {
        final List<Property> properties = new ArrayList<>();
            for (Property propertySource : nestedType.getProperties()) {
                    properties.add(propertySource);
    private String asLiteralDefault(GenericType type, String defaultValue) {
        if (defaultValue != null && !defaultValue.isEmpty()) {
            if (type.getRawClass() == String.class) {
                return Annotation.quote(defaultValue);
            } else if (type.getRawClass().isEnum()) {
                return type.getRawClass().getSimpleName()  "."  defaultValue;
            } else if (type.getRawClass() == boolean.class || type.getRawClass() == Boolean.class) {
                return defaultValue;
            } else if (type.getRawClass() == int.class || type.getRawClass() == Integer.class) {
                return defaultValue;
            } else if (type.getRawClass() == long.class || type.getRawClass() == Long.class) {
                return defaultValue  "L";
            } else if (type.getRawClass() == float.class || type.getRawClass() == Float.class) {
                return defaultValue  "f";
            } else if (type.getRawClass() == double.class || type.getRawClass() == Double.class) {
                return defaultValue;
            } else if (type.getRawClass() == Class.class) {
                return defaultValue  ".class";
            } else {
//                throw new UnsupportedOperationException("Unsupported default value for type: "
//                         type.toString()  ": "  defaultValue);
                return null;
            }
        }
        return null;
    }

    private GenericType loadType(String type) throws MojoFailureException {
        try {
            return GenericType.parse(type, getProjectClassLoader());
        } catch (ClassNotFoundException e) {
            throw new MojoFailureException("Unable to load type", e);
        }
    }

    private Class<?> loadClass(String loadClassName) throws MojoFailureException {
                optionClass = getProjectClassLoader().loadClass(loadClassName);
    protected DynamicClassLoader getProjectClassLoader() {
        if (projectClassLoader == null) {
            final List<?> classpathElements;
                classpathElements = project.getTestClasspathElements();
            } catch (org.apache.maven.artifact.DependencyResolutionRequiredException e) {
                throw new RuntimeException(e.getMessage(), e);
            final URL[] urls = new URL[classpathElements.size()];
            int i = 0;
            for (Iterator<?> it = classpathElements.iterator(); it.hasNext(); i) {
                try {
                    urls[i] = new File((String) it.next()).toURI().toURL();
                } catch (MalformedURLException e) {
                    throw new RuntimeException(e.getMessage(), e);
                }
            }
            final ClassLoader tccl = Thread.currentThread().getContextClassLoader();
            projectClassLoader = new DynamicClassLoader(urls, tccl != null ? tccl : getClass().getClassLoader());
        return projectClassLoader;
//        type = type.replaceAll("\\<\\?\\>", "");
    private boolean isNestedProperty(Set<JavaClass> nestedTypes, JavaClass type) {
    private JavaClass readJavaType(String type) {
            Path sourcePath = project.getCompileSourceRoots().stream()
                    .map(Paths::get)
                    .map(p -> p.resolve(fileName))
                    .filter(Files::isRegularFile)
                    .findFirst().orElse(null);
            if (sourcePath == null) {
                return null;
            }
            String sourceCode;
            try (InputStream is = Files.newInputStream(sourcePath)) {
                sourceCode = loadText(is);
            } catch (IOException e) {
                throw new RuntimeException("Unable to load source code", e);
            }
            try {
                Class<?> clazz = getProjectClassLoader().loadClass(type);
                JavaClass nestedType = new JavaClass(getProjectClassLoader())
                        .setPackage(clazz.getPackage().getName())
                        .setName(clazz.getSimpleName())
                        .setEnum(clazz.isEnum())
                        .setClass(!clazz.isInterface())
                        .setAbstract((clazz.getModifiers() & Modifier.ABSTRACT) != 0)
                        .setStatic((clazz.getModifiers() & Modifier.STATIC) != 0)
                        .extendSuperType(clazz.getGenericSuperclass() != null ? new GenericType(clazz.getGenericSuperclass()).toString() : null);
                List<java.lang.reflect.Method> publicMethods = Stream.of(clazz.getDeclaredMethods())
                        .filter(m -> Modifier.isPublic(m.getModifiers()))
                        .collect(Collectors.toList());
                List<java.lang.reflect.Method> allSetters = publicMethods.stream()
                        .filter(m -> m.getReturnType() == void.class || m.getReturnType() == clazz)
                        .filter(m -> m.getParameterCount() == 1)
                        .filter(m -> m.getName().matches("set[A-Z][a-zA-Z0-9]*"))
                        .collect(Collectors.toList());
                List<java.lang.reflect.Method> allGetters = publicMethods.stream()
                        .filter(m -> m.getReturnType() != void.class)
                        .filter(m -> m.getParameterCount() == 0)
                        .filter(m -> m.getName().matches("(get|is)[A-Z][a-zA-Z0-9]*"))
                        .collect(Collectors.toList());
                allSetters.stream()
                        .sorted(Comparator.comparing(m -> sourceCode.indexOf("void "  m.getName()  "(")))
                        .map(m -> Strings.uncapitalize(m.getName().substring(3)))
                        .forEach(fn -> {
                            Class<?> ft;
                            Type wft;
                            boolean isBoolean;
                            java.lang.reflect.Field field = Stream.of(clazz.getDeclaredFields())
                                    .filter(f -> f.getName().equals(fn))
                                    .findAny().orElse(null);
                            List<java.lang.reflect.Method> setters = allSetters.stream()
                                    .filter(m -> m.getName().equals("set"  Strings.capitalize(fn)))
                                    .collect(Collectors.toList());
                            List<java.lang.reflect.Method> getters = allGetters.stream()
                                    .filter(m -> m.getName().equals("get"  Strings.capitalize(fn))
                                            || m.getName().equals("is"  Strings.capitalize(fn)))
                                    .collect(Collectors.toList());
                            java.lang.reflect.Method mutator;
                            java.lang.reflect.Method accessor;
                            if (setters.size() == 1) {
                                mutator = setters.get(0);
                                ft = mutator.getParameterTypes()[0];
                                wft = PRIMITIVE_CLASSES.getOrDefault(ft, ft);
                                isBoolean = ft == boolean.class || ft == Boolean.class;
                                accessor = allGetters.stream()
                                        .filter(m -> m.getName().equals("get"  Strings.capitalize(fn))
                                                || isBoolean && m.getName().equals("is"  Strings.capitalize(fn)))
                                        .filter(m -> PRIMITIVE_CLASSES.getOrDefault(m.getReturnType(), m.getReturnType()) == wft)
                                        .findAny().orElse(null);
                            } else if (field != null) {
                                ft = field.getType();
                                wft = PRIMITIVE_CLASSES.getOrDefault(ft, ft);
                                isBoolean = ft == boolean.class || ft == Boolean.class;
                                mutator = allSetters.stream()
                                        .filter(m -> m.getName().equals("set"  Strings.capitalize(fn)))
                                        .filter(m -> PRIMITIVE_CLASSES.getOrDefault(m.getParameterTypes()[0], m.getParameterTypes()[0]) == wft)
                                        .findAny().orElse(null);
                                accessor = allGetters.stream()
                                        .filter(m -> m.getName().equals("get"  Strings.capitalize(fn))
                                                || isBoolean && m.getName().equals("is"  Strings.capitalize(fn)))
                                        .filter(m -> PRIMITIVE_CLASSES.getOrDefault(m.getReturnType(), m.getReturnType()) == wft)
                                        .findAny().orElse(null);
                            } else {
                                if (getters.size() == 1) {
                                    ft = getters.get(0).getReturnType();
                                } else {
                                    throw new IllegalStateException("Unable to determine type for property "  fn);
                                }
                                wft = PRIMITIVE_CLASSES.getOrDefault(ft, ft);
                                mutator = setters.stream()
                                        .filter(m -> PRIMITIVE_CLASSES.getOrDefault(m.getParameterTypes()[0], m.getParameterTypes()[0]) == wft)
                                        .findAny().orElse(null);
                                accessor = getters.stream()
                                        .filter(m -> PRIMITIVE_CLASSES.getOrDefault(m.getReturnType(), m.getReturnType()) == wft)
                                        .findAny().orElse(null);
                            }
                            if (mutator == null) {
                                throw new IllegalStateException("Could not find mutator for property "  fn);
                            }
                            Property property = nestedType.addProperty(new GenericType(wft), fn);
                            property.getMutator().getJavaDoc().setText(getSetterJavaDoc(sourceCode, fn));
                            for (java.lang.annotation.Annotation ann : mutator.getAnnotations()) {
                                addAnnotation(ac -> property.getMutator().addAnnotation(ac), ann);
                            }
                            if (accessor != null) {
                                for (java.lang.annotation.Annotation ann : accessor.getAnnotations()) {
                                    addAnnotation(ac -> property.getAccessor().addAnnotation(ac), ann);
                                }
                            } else {
                                property.removeAccessor();
                            }
                            if (field != null) {
                                for (java.lang.annotation.Annotation ann : field.getAnnotations()) {
                                    addAnnotation(ac -> property.getField().addAnnotation(ac), ann);
                                }
                            } else {
                                property.removeField();
                            }
                        });
                return nestedType;
            } catch (ClassNotFoundException e) {
                return null;
        return null;
    }

    private String getSetterJavaDoc(String sourceCode, String name) {
        int idx = sourceCode.indexOf("public void set"  Strings.capitalize(name)  "(");
        if (idx > 0) {
            sourceCode = sourceCode.substring(0, idx);
            idx = sourceCode.lastIndexOf("/**");
            if (idx > 0) {
                sourceCode = sourceCode.substring(idx  3);
                idx = sourceCode.indexOf("*/");
                if (idx > 0) {
                    sourceCode = sourceCode.substring(0, idx);
                    List<String> lines = Stream.of(sourceCode.split("\n"))
                            .map(String::trim)
                            .map(s -> s.startsWith("*") ? s.substring(1) : s)
                            .map(String::trim)
                            .filter(s -> !s.isEmpty())
                            .collect(Collectors.toList());
                    int lastLine = 0;
                    while (lastLine < lines.size()) {
                        if (lines.get(lastLine).startsWith("@")) {
                            break;
                        }
                        lastLine;
                    }
                    sourceCode = lines.subList(0, lastLine).stream()
                            .map(s -> s.replaceAll("  ", " "))
                            .map(String::trim)
                            .filter(s -> !s.isEmpty())
                            .collect(Collectors.joining(" "));
                    return sourceCode;
                }

            }
        }
        return null;
    }

    private void addAnnotation(Function<Class<? extends java.lang.annotation.Annotation>, Annotation> creator, java.lang.annotation.Annotation ann) {
        Class<? extends java.lang.annotation.Annotation> ac = ann.annotationType();
        Annotation a = creator.apply(ac);
        for (java.lang.reflect.Method m : ac.getMethods()) {
            if ("equals".equals(m.getName()) || "toString".equals(m.getName()) || "hashCode".equals(m.getName())) {
                continue;
            }
            String n = m.getName();
            try {
                Object v = m.invoke(ann);
                if (v != null) {
                    a.setLiteralValue(n, v.toString());
                }
            } catch (Exception e) {
                throw new RuntimeException("Unable to retrieve annotation value "  n  " on "  ac.getName());
            }
        }
        final JavaClass javaClass = new JavaClass(getProjectClassLoader());
        javaClass.extendSuperType("DataFormatConfigurationPropertiesCommon");
        Property bogus = javaClass.addProperty("java.lang.Boolean", "enabled");
            Property prop = javaClass.addProperty(type, option.getName());
        writeSourceIfChanged(javaClass, fileName, true);
        final JavaClass javaClass = new JavaClass(getProjectClassLoader());
        javaClass.extendSuperType("LanguageConfigurationPropertiesCommon");
        Property bogus = javaClass.addProperty("java.lang.Boolean", "enabled");
            Property prop = javaClass.addProperty(type, option.getName());
        writeSourceIfChanged(javaClass, fileName, true);
    }
    static class DynamicClassLoader extends URLClassLoader {
        public DynamicClassLoader(URL[] urls, ClassLoader parent) {
            super(urls, parent);
        }

        public Class defineClass(String name, byte[] data) {
            return super.defineClass(name, data, 0, data.length);
        }
        Class configClass = generateDummyClass(packageName  "."  configurationName);

        final JavaClass javaClass = new JavaClass(getProjectClassLoader());
            "{ConditionalOnCamelContextAndAutoConfigurationBeans.class,\n        "  name  ".GroupConditions.class}");
            "{ComponentConfigurationProperties.class,\n        "  configurationName  ".class}"
            .setType(loadClass("org.slf4j.Logger"))
            .setLiteralInitializer("LoggerFactory\n            .getLogger("  name  ".class)");
            .setType(ApplicationContext.class)
            .setType(loadClass("org.apache.camel.CamelContext"))
            .setType(configClass)
            .setType(loadType("java.util.List<org.apache.camel.spi.ComponentCustomizer<"  model.getJavaType()  ">>"))
        javaClass.addNestedType()
                .extendSuperType("GroupCondition")
                .setBody("super(\"camel.component\", \"camel.component."  componentName  "\");");
        Method method = javaClass.addMethod()
            .setReturnType(loadType(model.getJavaType()))
        writeSourceIfChanged(javaClass, fileName, false);
    }

    private Class generateDummyClass(String clazzName) {
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC,
                clazzName.replace('.', '/'),
                null,
                "java/lang/Object",
                null);
        cw.visitEnd();
        return getProjectClassLoader().defineClass(clazzName, cw.toByteArray());
        Class configClass = generateDummyClass(packageName  "."  configurationName);

        final JavaClass javaClass = new JavaClass(getProjectClassLoader());
            "{ConditionalOnCamelContextAndAutoConfigurationBeans.class,\n        "  name  ".GroupConditions.class}");
            "{DataFormatConfigurationProperties.class,\n        "  configurationName  ".class}"
            .setType(loadType("org.slf4j.Logger"))
            .setLiteralInitializer("LoggerFactory\n            .getLogger("  name  ".class)");
            .setType(ApplicationContext.class)
            .setType(loadType("org.apache.camel.CamelContext"))
            .setType(configClass)
            .setType(loadType("java.util.List<org.apache.camel.spi.DataFormatCustomizer<"  model.getJavaType()  ">>"))
        JavaClass groupConditions = javaClass.addNestedType()
                .extendSuperType("GroupCondition");
        groupConditions.addMethod()
                .setBody("super(\"camel.dataformat\", \"camel.dataformat."  dataformatName  "\");");
        Method method = javaClass.addMethod()
            .setReturnType(loadType("org.apache.camel.spi.DataFormatFactory"))
        String[] springBeanAliases = dataFormatAliases.stream().map(alias -> alias  "-dataformat-factory").toArray(String[]::new);
        writeSourceIfChanged(javaClass, fileName, false);
        Class configClass = generateDummyClass(packageName  "."  configurationName);

        final JavaClass javaClass = new JavaClass(getProjectClassLoader());
            "{ConditionalOnCamelContextAndAutoConfigurationBeans.class,\n        "  name  ".GroupConditions.class}");
            "{LanguageConfigurationProperties.class,\n        "  configurationName  ".class}"
            .setType(loadType("org.slf4j.Logger"))
            .setLiteralInitializer("LoggerFactory\n            .getLogger("  name  ".class)");
            .setType(ApplicationContext.class)
            .setType(loadType("org.apache.camel.CamelContext"))
            .setType(configClass)
            .setType(loadType("java.util.List<org.apache.camel.spi.LanguageCustomizer<"  model.getJavaType()  ">>"))
        javaClass.addNestedType()
                .extendSuperType("GroupCondition")
                .setBody("super(\"camel.component\", \"camel.component."  languageName  "\");");
        Method method = javaClass.addMethod()
            .setReturnType(loadType(model.getJavaType()))
        String[] springBeanAliases = languageAliases.stream().map(alias -> alias  "-language").toArray(String[]::new);
        writeSourceIfChanged(javaClass, fileName, false);
        sb.append("IntrospectionSupport.getProperties(configuration, parameters, null,\n" 
                  "        false);\n");
        sb.append("            nestedClass = (Class) paramClass.getDeclaredField(\n" 
                  "                    \"CAMEL_NESTED_CLASS\").get(null);\n");
        sb.append("            IntrospectionSupport.getProperties(value, nestedParameters,\n" 
                  "                    null, false);\n");
        sb.append("            CamelPropertiesHelper.setCamelProperties(camelContext,\n" 
                  "                    nestedProperty, nestedParameters, false);\n");
//        sb.append("            // ignore, class must not be a nested configuration class after all\n");
        sb.append("CamelPropertiesHelper.setCamelProperties(camelContext, component,\n");
        sb.append("        parameters, false);\n");
        sb.append("        boolean useCustomizer = (customizer instanceof HasId)\n");
        sb.append("                ? HierarchicalPropertiesEvaluator.evaluate(\n");
        sb.append("                        applicationContext.getEnvironment(),\n");
        sb.append("                        \"camel.component.customizer\",\n");
        sb.append("                        \"camel.component.").append(name).append(".customizer\",\n");
        sb.append("                        ((HasId) customizer).getId())\n");
        sb.append("                : HierarchicalPropertiesEvaluator.evaluate(\n");
        sb.append("                        applicationContext.getEnvironment(),\n");
        sb.append("                        \"camel.component.customizer\",\n");
        sb.append("                        \"camel.component.").append(name).append(".customizer\");\n");
        sb.append("            LOGGER.debug(\"Configure component {}, with customizer {}\",\n");
        sb.append("                    component, customizer);\n");
        sb.append("        if (CamelContextAware.class\n" 
                  "                .isAssignableFrom(").append(shortJavaType).append(".class)) {\n");
        sb.append("            CamelContextAware contextAware = CamelContextAware.class\n" 
                  "                    .cast(dataformat);\n");
        sb.append("            IntrospectionSupport.getProperties(configuration,\n" 
                  "                    parameters, null, false);\n");
        sb.append("            CamelPropertiesHelper.setCamelProperties(camelContext,\n" 
                  "                    dataformat, parameters, false);\n");
        sb.append("        if (ObjectHelper.isNotEmpty(customizers)) {\n");
        sb.append("            for (DataFormatCustomizer<").append(shortJavaType).append("> customizer : customizers) {\n");
        sb.append("                boolean useCustomizer = (customizer instanceof HasId)\n");
        sb.append("                        ? HierarchicalPropertiesEvaluator.evaluate(\n");
        sb.append("                                applicationContext.getEnvironment(),\n");
        sb.append("                                \"camel.dataformat.customizer\",\n");
        sb.append("                                \"camel.dataformat.").append(name).append(".customizer\",\n");
        sb.append("                                ((HasId) customizer).getId())\n");
        sb.append("                        : HierarchicalPropertiesEvaluator.evaluate(\n" 
                  "                                applicationContext.getEnvironment(),\n");
        sb.append("                                \"camel.dataformat.customizer\",\n");
        sb.append("                                \"camel.dataformat.").append(name).append(".customizer\");\n");
        sb.append("                if (useCustomizer) {\n");
        sb.append("                    LOGGER.debug(\n" 
                  "                            \"Configure dataformat {}, with customizer {}\",\n" 
                  "                            dataformat, customizer);\n");
        sb.append("                    customizer.customize(dataformat);\n");
        sb.append("                }\n");
        sb.append("            }\n");
        sb.append("    CamelContextAware contextAware = CamelContextAware.class\n" 
                  "            .cast(language);\n");
        sb.append("IntrospectionSupport.getProperties(configuration, parameters, null,\n" 
                  "        false);\n");
        sb.append("CamelPropertiesHelper.setCamelProperties(camelContext, language,\n" 
                  "        parameters, false);\n");
        sb.append("        boolean useCustomizer = (customizer instanceof HasId)\n");
        sb.append("                ? HierarchicalPropertiesEvaluator.evaluate(\n");
        sb.append("                        applicationContext.getEnvironment(),\n");
        sb.append("                        \"camel.language.customizer\",\n");
        sb.append("                        \"camel.language.").append(name).append(".customizer\",\n");
        sb.append("                        ((HasId) customizer).getId())\n");
        sb.append("                : HierarchicalPropertiesEvaluator.evaluate(\n");
        sb.append("                        applicationContext.getEnvironment(),\n");
        sb.append("                        \"camel.language.customizer\",\n");
        sb.append("                        \"camel.language.").append(name).append(".customizer\");\n");
        sb.append("            LOGGER.debug(\"Configure language {}, with customizer {}\",\n" 
                  "                    language, customizer);\n");
    private static void sortImports(JavaClass importer) {
        // do nothing, as imports are sorted automatically when displayed
    private void writeSourceIfChanged(JavaClass source, String fileName, boolean innerClassesLast) throws MojoFailureException {
        writeSourceIfChanged(source.printClass(innerClassesLast), fileName);
