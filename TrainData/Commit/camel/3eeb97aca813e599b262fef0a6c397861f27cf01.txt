import org.jboss.forge.roaster.model.source.Importer;
import org.springframework.boot.autoconfigure.condition.AllNestedConditions;
                //boolean hasOptions = model.getComponentOptions().stream().anyMatch(o -> !o.getName().equals("resolvePropertyPlaceholders"));
                createComponentConfigurationSource(pkg, model, overrideComponentName);
                createComponentAutoConfigurationSource(pkg, model, aliases, overrideComponentName);
                createDataFormatConfigurationSource(pkg, model, overrideDataFormatName);
                createDataFormatAutoConfigurationSource(pkg, model, aliases, overrideDataFormatName);
                createLanguageConfigurationSource(pkg, model, overrideLanguageName);
                createLanguageAutoConfigurationSource(pkg, model, aliases, overrideLanguageName);
        javaClass.extendSuperType(Roaster.create(JavaClassSource.class).setName("ComponentConfigurationPropertiesCommon"));
        javaClass.addImport("org.apache.camel.spring.boot.ComponentConfigurationPropertiesCommon");
                || name.equals("encoding") || name.equals("allowDefaultCodec") || name.equals("udpConnectionlessSending") || name.equals("networkInterface")
                || name.equals("clientMode") || name.equals("reconnect") || name.equals("reconnectInterval") || name.equals("useByteBuf")
                || name.equals("udpByteArrayCodec") || name.equals("broadcast")) {
        javaClass.extendSuperType(Roaster.create(JavaClassSource.class).setName("DataFormatConfigurationPropertiesCommon"));
        javaClass.addImport("org.apache.camel.spring.boot.DataFormatConfigurationPropertiesCommon");
        javaClass.extendSuperType(Roaster.create(JavaClassSource.class).setName("LanguageConfigurationPropertiesCommon"));
        javaClass.addImport("org.apache.camel.spring.boot.LanguageConfigurationPropertiesCommon");
                    || "headerName".equals(option.getName()) || "regex".equals(option.getName()) || "xml".equals(option.getName())
                    || "includeTokens".equals(option.getName()) || "group".equals(option.getName()) || "skipFirst".equals(option.getName())) {
        String packageName, ComponentModel model, List<String> componentAliases, String overrideComponentName) throws MojoFailureException {
        javaClass.extendSuperType(AllNestedConditions.class);
        javaClass.addAnnotation(AutoConfigureAfter.class).setLiteralValue("CamelAutoConfiguration.class");
        javaClass.addAnnotation(EnableConfigurationProperties.class).setLiteralValue(
            "{ ComponentConfigurationProperties.class, "  configurationName  ".class }"
        );
        javaClass.addImport(HashMap.class);
        javaClass.addImport(Map.class);
        javaClass.addImport("org.apache.camel.util.IntrospectionSupport");
        javaClass.addImport(List.class);
        javaClass.addImport(ConditionalOnBean.class);
        javaClass.addImport("org.slf4j.Logger");
        javaClass.addImport("org.slf4j.LoggerFactory");
        javaClass.addImport("org.apache.camel.spi.ComponentCustomizer");
        javaClass.addImport("org.apache.camel.spring.boot.CamelAutoConfiguration");
        javaClass.addImport("org.apache.camel.spring.boot.ComponentConfigurationProperties");
        javaClass.addImport("org.apache.camel.spring.boot.util.GroupCondition");
        javaClass.addImport("org.apache.camel.util.ObjectHelper");

        javaClass.addField()
            .setPrivate()
            .setStatic(true)
            .setFinal(true)
            .setName("LOGGER")
            .setType("Logger")
            .setLiteralInitializer("LoggerFactory.getLogger("  name  ".class)");

        javaClass.addField()
            .setPrivate()
            .setName("camelContext")
            .setType("CamelContext")
            .addAnnotation(Autowired.class);

        javaClass.addField()
            .setPrivate()
            .setName("customizers")
            .setType("List<ComponentCustomizer<"  model.getShortJavaType()  ">>")
            .addAnnotation(Autowired.class).setLiteralValue("required", "false");

        javaClass.addField()
            .setPrivate()
            .setName("globalConfiguration")
            .setType("ComponentConfigurationProperties")
            .addAnnotation(Autowired.class);

        javaClass.addField()
            .setPrivate()
            .setName("componentConfiguration")
            .setType(configurationName)
            .addAnnotation(Autowired.class);

        javaClass.addMethod()
            .setConstructor(true)
            .setPublic()
            .setBody("super(ConfigurationPhase.REGISTER_BEAN);");

        javaClass.addNestedType(
            Roaster.create(JavaClassSource.class)
                .setName("OnCamelContext")
                .setStatic(true)
                .addAnnotation(ConditionalOnBean.class)
                    .setLiteralValue("CamelContext.class")
                    .getOrigin()
        );
        javaClass.addNestedType(
            Roaster.create(JavaClassSource.class)
                .setName("OnCamelAutoConfiguration")
                .setStatic(true)
                .addAnnotation(ConditionalOnBean.class)
                    .setLiteralValue("CamelAutoConfiguration.class")
                    .getOrigin()
        );
        javaClass.addNestedType(
            Roaster.create(JavaClassSource.class)
                .setName("Condition")
                .setStatic(true)
                .extendSuperType(Roaster.create(JavaClassSource.class).setName("GroupCondition"))
                .addMethod()
                    .setName("Condition")
                    .setConstructor(true)
                    .setPublic()
                    .setBody("super(\"camel.component\", \"camel.component."  (overrideComponentName != null ? overrideComponentName : model.getScheme()).toLowerCase(Locale.US)  "\");")
                    .getOrigin()
        );
        String body = createComponentBody(model.getShortJavaType());
            .setName(methodName)
            .setPublic()
            .setBody(body)
            .setReturnType(model.getShortJavaType())
            .addThrows(Exception.class);
        method.addAnnotation(ConditionalOnClass.class).setLiteralValue("CamelContext.class");
        method.addAnnotation(ConditionalOnMissingBean.class).setLiteralValue(model.getShortJavaType()  ".class");
        String packageName, DataFormatModel model, List<String> dataFormatAliases, String overrideDataFormatName) throws MojoFailureException {
        name = name.replace("DataFormat", "DataFormatAutoConfiguration");
        javaClass.extendSuperType(AllNestedConditions.class);
        javaClass.addAnnotation(EnableConfigurationProperties.class).setLiteralValue(
            "{ DataFormatConfigurationProperties.class, "  configurationName  ".class }"
        );
        javaClass.addImport(HashMap.class);
        javaClass.addImport(Map.class);
        javaClass.addImport("org.apache.camel.util.IntrospectionSupport");
        javaClass.addImport(List.class);
        javaClass.addImport(ConditionalOnBean.class);
        javaClass.addImport("org.slf4j.Logger");
        javaClass.addImport("org.slf4j.LoggerFactory");
        javaClass.addImport("org.apache.camel.CamelContextAware");
        javaClass.addImport("org.apache.camel.spring.boot.CamelAutoConfiguration");
        javaClass.addImport("org.apache.camel.spring.boot.DataFormatConfigurationProperties");
        javaClass.addImport("org.apache.camel.spring.boot.util.GroupCondition");
        javaClass.addImport("org.apache.camel.util.ObjectHelper");
        javaClass.addImport("org.apache.camel.spi.DataFormatCustomizer");
        javaClass.addField()
            .setPrivate()
            .setStatic(true)
            .setFinal(true)
            .setName("LOGGER")
            .setType("Logger")
            .setLiteralInitializer("LoggerFactory.getLogger("  name  ".class)");

        javaClass.addField()
            .setPrivate()
            .setName("camelContext")
            .setType("CamelContext")
            .addAnnotation(Autowired.class);

        javaClass.addField()
            .setPrivate()
            .setName("customizers")
            .setType("List<DataFormatCustomizer<"  model.getShortJavaType()  ">>")
            .addAnnotation(Autowired.class)
                .setLiteralValue("required", "false");

        javaClass.addField()
            .setPrivate()
            .setName("globalConfiguration")
            .setType("DataFormatConfigurationProperties")
            .addAnnotation(Autowired.class);

        javaClass.addField()
            .setPrivate()
            .setName("dataformatConfiguration")
            .setType(configurationName)
            .addAnnotation(Autowired.class);

        javaClass.addMethod()
            .setConstructor(true)
            .setPublic()
            .setBody("super(ConfigurationPhase.REGISTER_BEAN);");

        javaClass.addNestedType(
            Roaster.create(JavaClassSource.class)
                .setName("OnCamelContext")
                .setStatic(true)
                .addAnnotation(ConditionalOnBean.class)
                    .setLiteralValue("CamelContext.class")
                    .getOrigin()
        );
        javaClass.addNestedType(
            Roaster.create(JavaClassSource.class)
                .setName("OnCamelAutoConfiguration")
                .setStatic(true)
                .addAnnotation(ConditionalOnBean.class)
                    .setLiteralValue("CamelAutoConfiguration.class")
                    .getOrigin()
        );
        javaClass.addNestedType(
            Roaster.create(JavaClassSource.class)
                .setName("Condition")
                .setStatic(true)
                .extendSuperType(Roaster.create(JavaClassSource.class).setName("GroupCondition"))
                .addAnnotation(ConditionalOnBean.class)
                    .setLiteralValue("CamelAutoConfiguration.class")
                    .getOrigin()
                .addMethod()
                    .setName("Condition")
                    .setConstructor(true)
                    .setPublic()
                    .setBody("super(\"camel.dataformat\", \"camel.dataformat."  (overrideDataFormatName != null ? overrideDataFormatName : model.getName()).toLowerCase(Locale.US)  "\");")
                    .getOrigin()
        );


        String body = createDataFormatBody(model.getShortJavaType());
            .setName(methodName)
            .setPublic()
            .setBody(body)
            .setReturnType("org.apache.camel.spi.DataFormatFactory")
            .addThrows(Exception.class);
        String packageName, LanguageModel model, List<String> languageAliases, String overrideLanguageName) throws MojoFailureException {
        javaClass.extendSuperType(AllNestedConditions.class);
        javaClass.addAnnotation(AutoConfigureAfter.class).setLiteralValue("CamelAutoConfiguration.class");
        javaClass.addAnnotation(EnableConfigurationProperties.class).setLiteralValue(
            "{ LanguageConfigurationProperties.class, "  configurationName  ".class }"
        );
        javaClass.addImport(HashMap.class);
        javaClass.addImport(Map.class);
        javaClass.addImport("org.apache.camel.util.IntrospectionSupport");
        javaClass.addImport(List.class);
        javaClass.addImport(ConditionalOnBean.class);
        javaClass.addImport("org.slf4j.Logger");
        javaClass.addImport("org.slf4j.LoggerFactory");
        javaClass.addImport("org.apache.camel.CamelContextAware");
        javaClass.addImport("org.apache.camel.spring.boot.CamelAutoConfiguration");
        javaClass.addImport("org.apache.camel.spring.boot.LanguageConfigurationProperties");
        javaClass.addImport("org.apache.camel.spring.boot.util.GroupCondition");
        javaClass.addImport("org.apache.camel.util.ObjectHelper");
        javaClass.addImport("org.apache.camel.spi.LanguageCustomizer");
        javaClass.addField()
            .setPrivate()
            .setStatic(true)
            .setFinal(true)
            .setName("LOGGER")
            .setType("Logger")
            .setLiteralInitializer("LoggerFactory.getLogger("  name  ".class)");

        javaClass.addField()
            .setPrivate()
            .setName("camelContext")
            .setType("CamelContext")
            .addAnnotation(Autowired.class);

        javaClass.addField()
            .setPrivate()
            .setName("customizers")
            .setType("List<LanguageCustomizer<"  model.getShortJavaType()  ">>")
            .addAnnotation(Autowired.class).setLiteralValue("required", "false");

        javaClass.addField()
            .setPrivate()
            .setName("globalConfiguration")
            .setType("LanguageConfigurationProperties")
            .addAnnotation(Autowired.class);

        javaClass.addField()
            .setPrivate()
            .setName("languageConfiguration")
            .setType(configurationName)
            .addAnnotation(Autowired.class);

        javaClass.addMethod()
            .setConstructor(true)
            .setPublic()
            .setBody("super(ConfigurationPhase.REGISTER_BEAN);");

        javaClass.addNestedType(
            Roaster.create(JavaClassSource.class)
                .setName("OnCamelContext")
                .setStatic(true)
                .addAnnotation(ConditionalOnBean.class)
                    .setLiteralValue("CamelContext.class")
                    .getOrigin()
        );
        javaClass.addNestedType(
            Roaster.create(JavaClassSource.class)
                .setName("OnCamelAutoConfiguration")
                .setStatic(true)
                .addAnnotation(ConditionalOnBean.class)
                    .setLiteralValue("CamelAutoConfiguration.class")
                    .getOrigin()
        );
        javaClass.addNestedType(
            Roaster.create(JavaClassSource.class)
                .setName("Condition")
                .setStatic(true)
                .extendSuperType(Roaster.create(JavaClassSource.class).setName("GroupCondition"))
                .addAnnotation(ConditionalOnBean.class)
                    .setLiteralValue("CamelAutoConfiguration.class")
                    .getOrigin()
                .addMethod()
                    .setName("Condition")
                    .setConstructor(true)
                    .setPublic()
                    .setBody("super(\"camel.component\", \"camel.component."  (overrideLanguageName != null ? overrideLanguageName : model.getName()).toLowerCase(Locale.US)  "\");")
                    .getOrigin()
        );

        String body = createLanguageBody(model.getShortJavaType());
            .setName(methodName)
            .setPublic()
            .setBody(body)
            .setReturnType(model.getShortJavaType())
            .addThrows(Exception.class);
    private static String createComponentBody(String shortJavaType) {
        sb.append("Map<String, Object> parameters = new HashMap<>();\n");
        sb.append("IntrospectionSupport.getProperties(componentConfiguration, parameters, null, false);\n");
        sb.append("\n");
        sb.append("for (Map.Entry<String, Object> entry : parameters.entrySet()) {\n");
        sb.append("    Object value = entry.getValue();\n");
        sb.append("    Class<?> paramClass = value.getClass();\n");
        sb.append("    if (paramClass.getName().endsWith(\"NestedConfiguration\")) {\n");
        sb.append("        Class nestedClass = null;\n");
        sb.append("        try {\n");
        sb.append("            nestedClass = (Class) paramClass.getDeclaredField(\"CAMEL_NESTED_CLASS\").get(null);\n");
        sb.append("            HashMap<String, Object> nestedParameters = new HashMap<>();\n");
        sb.append("            IntrospectionSupport.getProperties(value, nestedParameters, null, false);\n");
        sb.append("            Object nestedProperty = nestedClass.newInstance();\n");
        sb.append("            IntrospectionSupport.setProperties(camelContext, camelContext.getTypeConverter(), nestedProperty, nestedParameters);\n");
        sb.append("            entry.setValue(nestedProperty);\n");
        sb.append("        } catch (NoSuchFieldException e) {\n");
        sb.append("            // ignore, class must not be a nested configuration class after all\n");
        sb.append("        }\n");
        sb.append("    }\n");
        sb.append("}\n");
        sb.append("IntrospectionSupport.setProperties(camelContext, camelContext.getTypeConverter(), component, parameters);\n");
        sb.append("\n");
        sb.append("boolean useConfigurers = globalConfiguration.getConfigurer().isEnabled() && componentConfiguration.getConfigurer().isEnabled();\n");
        sb.append("\n");
        sb.append("if (useConfigurers && ObjectHelper.isNotEmpty(customizers)) {\n");
        sb.append("    for (ComponentCustomizer<").append(shortJavaType).append("> configurer : customizers) {\n");
        sb.append("        LOGGER.debug(\"Configure component {}, with configurer {}\", component, configurer);\n");
        sb.append("        configurer.customize(component);\n");
        sb.append("    }\n");
        sb.append("}\n");

    private static String createDataFormatBody(String shortJavaType) {
        sb.append("\n");
        sb.append("        try {\n");
        sb.append("            Map<String, Object> parameters = new HashMap<>();\n");
        sb.append("            IntrospectionSupport.getProperties(dataformatConfiguration, parameters, null, false);\n");
        sb.append("            IntrospectionSupport.setProperties(camelContext, camelContext.getTypeConverter(), dataformat, parameters);\n");
        sb.append("        } catch (Exception e) {\n");
        sb.append("            throw new RuntimeCamelException(e);\n");
        sb.append("        }\n");
        sb.append("\n");
        sb.append("boolean useConfigurers = globalConfiguration.getConfigurer().isEnabled() && dataformatConfiguration.getConfigurer().isEnabled();\n");
        sb.append("\n");
        sb.append("if (useConfigurers && ObjectHelper.isNotEmpty(customizers)) {\n");
        sb.append("    for (DataFormatCustomizer<").append(shortJavaType).append("> configurer : customizers) {\n");
        sb.append("        LOGGER.debug(\"Configure dataformat {}, with configurer {}\", dataformat, configurer);\n");
        sb.append("        configurer.customize(dataformat);\n");
        sb.append("    }\n");
        sb.append("}\n");
    private static String createLanguageBody(String shortJavaType) {
        sb.append("\n");
        sb.append("Map<String, Object> parameters = new HashMap<>();\n");
        sb.append("IntrospectionSupport.getProperties(languageConfiguration, parameters, null, false);\n");
        sb.append("IntrospectionSupport.setProperties(camelContext, camelContext.getTypeConverter(), language, parameters);\n");
        sb.append("\n");
        sb.append("boolean useConfigurers = globalConfiguration.getConfigurer().isEnabled() && languageConfiguration.getConfigurer().isEnabled();\n");
        sb.append("\n");
        sb.append("if (useConfigurers && ObjectHelper.isNotEmpty(customizers)) {\n");
        sb.append("    for (LanguageCustomizer<").append(shortJavaType).append("> configurer : customizers) {\n");
        sb.append("        LOGGER.debug(\"Configure language {}, with configurer {}\", language, configurer);\n");
        sb.append("        configurer.customize(language);\n");
        sb.append("    }\n");
        sb.append("}\n");
    private static void sortImports(Importer importer) {
        List<Import> imports = importer.getImports();
            importer.removeImport(name);
            importer.addImport(name);
        writeSourceIfChanged(source.toString(), fileName);
    }

    private void writeSourceIfChanged(String source, String fileName) throws MojoFailureException {

        source = Formatter.format(source);
        source = source.replaceAll("\\t", "    ");
            String code = source;
    /*
    */

