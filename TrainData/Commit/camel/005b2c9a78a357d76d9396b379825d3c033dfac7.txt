import org.apache.camel.ExchangePattern;
import org.apache.camel.component.mllp.MllpComponent;
    private Boolean logPhi = true;
    private Integer logPhiMaxBytes = 5120;
         * Allows for bridging the consumer to the Camel routing Error Handler,
         * which mean any exceptions occurred while the consumer is trying to
         * receive incoming messages, or the likes, will now be processed as a
         * message and handled by the routing Error Handler. If disabled, the
         * consumer will use the org.apache.camel.spi.ExceptionHandler to deal
         * with exceptions by logging them at WARN or ERROR level and ignored.
         * 
         * @param bridgeErrorHandler
         */
        private Boolean bridgeErrorHandler = true;
        /**
         * Sets the exchange pattern when the consumer creates an exchange.
         * 
         * @param exchangePattern
         */
        private ExchangePattern exchangePattern = ExchangePattern.InOut;
        /**
         * Sets whether synchronous processing should be strictly used (this
         * component only supports synchronous operations).
         * 
         * @param synchronous
         */
        private Boolean synchronous = true;
        /**
         * Enable/disable the SO_REUSEADDR socket option.
         * 
         * @param reuseAddress
         *            enable SO_REUSEADDR when true; disable SO_REUSEADDR when
         *            false; use system default when null
         */
        private Boolean reuseAddress = false;
        /**
         * Enable/Disable strict compliance to the MLLP standard. The MLLP
         * Enable/Disable the buffering of HL7 payloads before writing to the
         * socket.
        public Boolean getBridgeErrorHandler() {
            return bridgeErrorHandler;
        }

        public void setBridgeErrorHandler(Boolean bridgeErrorHandler) {
            this.bridgeErrorHandler = bridgeErrorHandler;
        }

        public ExchangePattern getExchangePattern() {
            return exchangePattern;
        }

        public void setExchangePattern(ExchangePattern exchangePattern) {
            this.exchangePattern = exchangePattern;
        }

        public Boolean getSynchronous() {
            return synchronous;
        }

        public void setSynchronous(Boolean synchronous) {
            this.synchronous = synchronous;
        }

        public Boolean getReuseAddress() {
            return reuseAddress;
        }

        public void setReuseAddress(Boolean reuseAddress) {
            this.reuseAddress = reuseAddress;
        }

