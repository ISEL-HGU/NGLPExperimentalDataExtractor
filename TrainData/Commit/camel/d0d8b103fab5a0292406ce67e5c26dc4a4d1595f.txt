import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.LRUCache;
import org.apache.camel.util.LRUCacheFactory;
import org.apache.camel.util.ServiceHelper;
    private volatile Integer throttleRate = new Integer(0);
    private final DelayQueue<ThrottlePermit> delayQueue = new DelayQueue<>();
    // below 4 fields added for (throttling grouping)
    private Expression correlationExpression;
    private Map<Integer, DelayQueue<ThrottlePermit>> delayQueueCache;
    private Map<Integer, Integer> throttleRatesMap = new HashMap<>();
    private ExecutorService delayQueueCacheExecutorService;    
                     final ExecutorService asyncExecutor, final boolean shutdownAsyncExecutor, final boolean rejectExecution, Expression correlation) {
        this.correlationExpression = correlation;
            DelayQueue<ThrottlePermit> delayQ = null;
            Integer key = null;
            if (correlationExpression != null) {
                key = correlationExpression.evaluate(exchange, Integer.class);
                delayQ = locateDelayQueue(key, doneSync);
            } else {
                delayQ = delayQueue;
            }
            
            calculateAndSetMaxRequestsPerPeriod(delayQ, exchange, key);
            ThrottlePermit permit = delayQ.poll();
                             ((correlationExpression != null) ? throttleRatesMap.get(key) : throttleRate)  " within "  timePeriodMillis  "ms");
                    permit = delayQ.take();
                    enqueuePermit(permit, exchange, delayQ);
                enqueuePermit(permit, exchange, delayQ);
    private DelayQueue<ThrottlePermit> locateDelayQueue(final Integer key, final boolean doneSync) throws InterruptedException, ExecutionException {        
        CompletableFuture<DelayQueue<ThrottlePermit>> futureDelayQueue = new CompletableFuture<>();

        if (!doneSync) {
            delayQueueCacheExecutorService.submit(() -> {
                futureDelayQueue.complete(findDelayQueue(key));
            });
        }
        DelayQueue<ThrottlePermit> currentQueue = (!doneSync) ? futureDelayQueue.get() : findDelayQueue(key);   
        return currentQueue;
    }

    private DelayQueue<ThrottlePermit> findDelayQueue(Integer key) {
        DelayQueue<ThrottlePermit> currentDelayQueue = delayQueueCache.get(key);
        if (currentDelayQueue == null) {
            currentDelayQueue = new DelayQueue<>();
            throttleRatesMap.put(key, 0);
            delayQueueCache.put(key, currentDelayQueue);
        }
        return currentDelayQueue;
    }

     * @throws ExecutionException 
     * @throws InterruptedException 
    protected void enqueuePermit(final ThrottlePermit permit, final Exchange exchange, DelayQueue<ThrottlePermit> delayQueue) throws InterruptedException, ExecutionException {
    protected void calculateAndSetMaxRequestsPerPeriod(DelayQueue<ThrottlePermit> delayQueue, final Exchange exchange, final Integer key) throws Exception {
        Object lockOnSync = null;
        Integer currentThrottleRate = throttleRate;
        if (correlationExpression != null) {
            currentThrottleRate = throttleRatesMap.get(key);
            lockOnSync = new Integer(currentThrottleRate.intValue());
        } else {
            lockOnSync = this;
        }
        synchronized (lockOnSync) {
            if (newThrottle == null && currentThrottleRate == 0) {
                if (newThrottle != currentThrottleRate) {
                    // get the queue from the cache
                    if (currentThrottleRate > newThrottle) {
                        int delta = currentThrottleRate - newThrottle;
                        log.debug("Throttle rate decreased from {} to {}, triggered by ExchangeId: {}", currentThrottleRate, newThrottle, exchange.getExchangeId());
                    } else if (newThrottle > currentThrottleRate) {
                        int delta = newThrottle - currentThrottleRate;
                        if (currentThrottleRate == 0) {
                            log.debug("Throttle rate increase from {} to {}, triggered by ExchangeId: {}", currentThrottleRate, newThrottle, exchange.getExchangeId());
                    if (correlationExpression != null) {
                        throttleRatesMap.put(key, newThrottle);
                    } else {
                    	throttleRate = newThrottle;
                    }
    @SuppressWarnings("unchecked")
        if (camelContext != null) {
            int maxSize = CamelContextHelper.getMaximumSimpleCacheSize(camelContext);
            if (maxSize > 0) {
                delayQueueCache = LRUCacheFactory.newLRUCache(16, maxSize, false);
                log.debug("DelayQueues cache size: {}", maxSize);
            } else {
                delayQueueCache = LRUCacheFactory.newLRUCache(100);
                log.debug("Defaulting DelayQueues cache size: {}", 100);
            }
        }
        if (delayQueueCache != null) {
            ServiceHelper.startService(delayQueueCache);
        }
        if (delayQueueCacheExecutorService == null) {
            String name = getClass().getSimpleName()  "-DelayQueueLocatorTask";
            delayQueueCacheExecutorService = createDelayQueueCacheExecutorService(name);
        }
    
    /**
     * Strategy to create the thread pool for locating right DelayQueue from the case as a background task
     *
     * @param name  the suggested name for the background thread
     * @return the thread pool
     */
    protected synchronized ExecutorService createDelayQueueCacheExecutorService(String name) {
        // use a cached thread pool so we each on-the-fly task has a dedicated thread to process completions as they come in
        return camelContext.getExecutorServiceManager().newCachedThreadPool(this, name);
    }
    @SuppressWarnings("rawtypes")
        if (delayQueueCacheExecutorService != null) {
            camelContext.getExecutorServiceManager().shutdownNow(delayQueueCacheExecutorService);
        }
        if (delayQueueCache != null) {
            ServiceHelper.stopService(delayQueueCache);
            if (log.isDebugEnabled()) {
                if (delayQueueCache instanceof LRUCache) {
                    log.debug("Clearing deleay queues cache[size={}, hits={}, misses={}, evicted={}]",
                            delayQueueCache.size(), ((LRUCache) delayQueueCache).getHits(), ((LRUCache) delayQueueCache).getMisses(), ((LRUCache) delayQueueCache).getEvicted());
                }
            }
            delayQueueCache.clear();
        }
        if (throttleRatesMap != null && throttleRatesMap.size() > 0) {
            throttleRatesMap.clear();
        }
     * If it is grouped throttling applied with correlationExpression 
     * than the max per period within the group will return
        if (correlationExpression == null) {
            return throttleRate;
        }
        return Collections.max(throttleRatesMap.entrySet(), (entry1, entry2) -> entry1.getValue() - entry2.getValue()).getValue();
