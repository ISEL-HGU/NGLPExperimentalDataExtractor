
 * The JSCH session and channel are not thread-safe so we need to synchronize
 * access to using this operation.
     * Extended user info which supports interactive keyboard mode, by entering
     * the password.
        this.endpoint = (SftpEndpoint)endpoint;
                    channel = (ChannelSftp)session.openChannel("sftp");
        SftpConfiguration sftpConfig = (SftpConfiguration)configuration;
                // Return 'false' indicating modification of the hosts file is
                // disabled.
            public String[] promptKeyboardInteractive(String destination, String name, String instruction, String[] prompt, boolean[] echo) {
                    return new String[] {configuration.getPassword()};
                session.setTimeout(configuration.getSoTimeout());
            LOG.debug("The Server Alive Internal is already set, the socket timeout won't be considered to avoid overidding the provided Server alive interval value");
            // make use of the '/' separator because JSch expects this
                // ignore, we could not change directory so try to create it
                // instead
                    // we are here if the server side doesn't create
                    // intermediate folders
        // must compact path so SFTP server can traverse correctly, make use of
        // the '/'
        // separator because JSch expects this as the file separator even on
        // Windows
            // extract the path segment relative to the target path and make
            // sure it keeps the preceding '/' for the regex op
            String p = getCurrentDirectory().substring(path.length() - (path.endsWith("/") ? 1 : 0));
        // if it starts with the root path then a little special handling for
        // that
                    list.add(new SftpRemoteFileJCraft((ChannelSftp.LsEntry)file));
            // local work directory is configured so we should store file
            // content as files in this local directory
            GenericFile<ChannelSftp.LsEntry> target = (GenericFile<ChannelSftp.LsEntry>)exchange.getProperty(FileComponent.FILE_EXCHANGE_FILE);
                // (must do this as some FTP servers cannot retrieve using
                // absolute path)
                // remote name is now only the file name as we just changed
                // directory
        GenericFile<ChannelSftp.LsEntry> file = (GenericFile<ChannelSftp.LsEntry>)exchange.getProperty(FileComponent.FILE_EXCHANGE_FILE);
            // store content as a file in the local work directory in the temp
            // handle
                // (must do this as some FTP servers cannot retrieve using
                // absolute path)
                // remote name is now only the file name as we just changed
                // directory
            // failed to retrieve the file so we need to close streams and
            // delete in progress file
        // operation went okay so rename temp to local after we have retrieved
        // the data
                // must remember current dir so we stay in that directory after
                // the write
                // the target name should be without path, as we have changed
                // directory
        if (endpoint.getFileExist() == GenericFileExist.Ignore || endpoint.getFileExist() == GenericFileExist.Fail || endpoint.getFileExist() == GenericFileExist.Move) {
                is = new ByteArrayInputStream(new byte[] {});
                LOG.debug("Took {} ({} millis) to store file: {} and FTP client returned: true", new Object[] {TimeUtils.printDuration(time), time, targetName});

                ChannelSftp.LsEntry entry = (ChannelSftp.LsEntry)file;
            // or an exception can be thrown with id 2 which means file does not
            // exists
            // or an exception can be thrown with id 2 which means file does not
            // exists
     * adapted from com.jcraft.jsch.Util.createSocket(String, int, int) added
     * possibility to specify the address of the local network interface,
     * against the connection should bind
                        } catch (Exception eee) {
                        }
