import java.util.Collections;

    /** An array of the valid targetBytecode values */
    public static final CompilerConfiguration DEFAULT = new CompilerConfiguration() {
        @Override
        public List<String> getClasspath() {
            return Collections.unmodifiableList(super.getClasspath());
        }

        @Override
        public List<CompilationCustomizer> getCompilationCustomizers() {
            return Collections.unmodifiableList(super.getCompilationCustomizers());
        }

        @Override
        public Set<String> getDisabledGlobalASTTransformations() {
            return Collections.emptySet();
        }

        @Override
        public Map<String, Object> getJointCompilationOptions() {
            return Collections.unmodifiableMap(super.getJointCompilationOptions());
        }

        @Override
        public Map<String, Boolean> getOptimizationOptions() {
            return Collections.unmodifiableMap(super.getOptimizationOptions());
        }

        @Override
        public Set<String> getScriptExtensions() {
            return Collections.unmodifiableSet(super.getScriptExtensions());
        }

        @Override
        public void setBytecodePostprocessor(BytecodeProcessor bytecodePostprocessor) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setClasspath(String classpath) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setClasspathList(List<String> parts) {
            throw new UnsupportedOperationException();
        }

        @Override
        public CompilerConfiguration addCompilationCustomizers(CompilationCustomizer... customizers) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setDebug(boolean debug) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setDefaultScriptExtension(String defaultScriptExtension) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setDisabledGlobalASTTransformations(Set<String> disabledGlobalASTTransformations) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setJointCompilationOptions(Map<String, Object> options) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setMinimumRecompilationInterval(int time) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setOptimizationOptions(Map<String, Boolean> options) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setOutput(PrintWriter output) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setParameters(boolean parameters) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setPluginFactory(ParserPluginFactory pluginFactory) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setRecompileGroovySource(boolean recompile) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setScriptBaseClass(String scriptBaseClass) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setScriptExtensions(Set<String> scriptExtensions) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setSourceEncoding(String encoding) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setTargetBytecode(String version) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setTargetDirectory(File directory) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setTargetDirectory(String directory) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setTolerance(int tolerance) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setVerbose(boolean verbose) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void setWarningLevel(int level) {
            throw new UnsupportedOperationException();
        }
    };

        warningLevel = WarningMessage.LIKELY_ERRORS;
        classpath = new LinkedList<String>();
        parameters = getSystemPropertySafe("groovy.parameters") != null;
        tolerance = 10;
        minimumRecompilationInterval = 100;
        setTargetBytecodeIfValid(getSystemPropertySafe("groovy.target.bytecode", getMinBytecodeVersion()));

        previewFeatures = getSystemPropertySafe("groovy.preview.features") != null;
        defaultScriptExtension = getSystemPropertySafe("groovy.default.scriptExtension", ".groovy");
        setSourceEncodingOrDefault(encoding);
        setTargetDirectorySafe(getSystemPropertySafe("groovy.target.directory"));
        optimizationOptions = new HashMap<>(4);
        handleOptimizationOption(optimizationOptions, INVOKEDYNAMIC, "groovy.target.indy");
        handleOptimizationOption(optimizationOptions, GROOVYDOC, "groovy.attach.groovydoc");
        handleOptimizationOption(optimizationOptions, RUNTIME_GROOVYDOC, "groovy.attach.runtime.groovydoc");
        jointCompilationOptions = new HashMap<>(4);
        handleJointCompilationOption(jointCompilationOptions, MEM_STUB, "groovy.generate.stub.in.memory");
        String propValue = getSystemPropertySafe(sysOptionName);
        boolean optionEnabled = propValue == null
                ? (DEFAULT == null ? false : Boolean.TRUE.equals(DEFAULT.getOptimizationOptions().get(optionName)))
                : Boolean.valueOf(propValue);

        String propValue = getSystemPropertySafe(sysOptionName);
        boolean optionEnabled = propValue == null
                ? (DEFAULT == null ? false : Boolean.TRUE.equals(DEFAULT.getJointCompilationOptions().get(optionName)))
                : Boolean.valueOf(propValue);

     * for your compilation but you want to make a some changes programmatically.
     * settings in {@link System#getProperties()} in general, only {@code file.encoding},
     * {@code groovy.target.directory} and {@code groovy.source.encoding} are checked.
     * a {@code Properties} object that is backed by <code>System.getProperties()</code> (which
     * And you also have to contend with a possible {@code SecurityException} when
     * {@code CompilerConfiguration} and make your changes there using the setter:
     *   <tr><th>Property Key</th><th>Related Property Getter</th></tr>
     *   <tr><td><code>"groovy.warnings"</code></td><td>{@link #getWarningLevel}</td></tr>
     *   <tr><td><code>"groovy.source.encoding"</code></td><td>{@link #getSourceEncoding}</td></tr>
     *   <tr><td><code>"groovy.target.directory"</code></td><td>{@link #getTargetDirectory}</td></tr>
     *   <tr><td><code>"groovy.target.bytecode"</code></td><td>{@link #getTargetBytecode}</td></tr>
     *   <tr><td><code>"groovy.parameters"</code></td><td>{@link #getParameters()}</td></tr>
     *   <tr><td><code>"groovy.preview.features"</code></td><td>{@link #isPreviewFeatures}</td></tr>
     *   <tr><td><code>"groovy.classpath"</code></td><td>{@link #getClasspath}</td></tr>
     *   <tr><td><code>"groovy.output.verbose"</code></td><td>{@link #getVerbose}</td></tr>
     *   <tr><td><code>"groovy.output.debug"</code></td><td>{@link #getDebug}</td></tr>
     *   <tr><td><code>"groovy.errors.tolerance"</code></td><td>{@link #getTolerance}</td></tr>
     *   <tr><td><code>"groovy.script.extension"</code></td><td>{@link #getDefaultScriptExtension}</td></tr>
     *   <tr><td><code>"groovy.script.base"</code></td><td>{@link #getScriptBaseClass}</td></tr>
     *   <tr><td><code>"groovy.recompile"</code></td><td>{@link #getRecompileGroovySource}</td></tr>
     *   <tr><td><code>"groovy.recompile.minimumInterval"</code></td><td>{@link #getMinimumRecompilationInterval}</td></tr>
     *   <tr><td><code>"groovy.default.scriptExtension"</code></td><td>{@link #getDefaultScriptExtension}</td></tr>
     *   <tr><td><code>"groovy.disabled.global.ast.transformations"</code></td><td>{@link #getDisabledGlobalASTTransformations}</td></tr>
     * </table>
     *
     * <table summary="Groovy Compiler Optimization Options Configuration Properties">
     *   <tr><th>Property Key</th><th>Get/Set Property Name</th></tr>
     *   <tr><td><code>"groovy.target.indy"</code></td><td>{@link #getOptimizationOptions}</td></tr>
        setSourceEncodingOrDefault(encoding);
    }

    private void setSourceEncodingOrDefault(String encoding) {
        } else {
        setTargetDirectorySafe(directory);
    }

    private void setTargetDirectorySafe(String directory) {
        setTargetBytecodeIfValid(version);
    }

    private void setTargetBytecodeIfValid(String version) {
        if (options == null) throw new IllegalArgumentException("provided option map must not be null");
        if (customizers == null) throw new IllegalArgumentException("provided customizers list must not be null");
     * Disables the specified global AST transformations. In order to avoid class loading side effects,
     * it is not recommended to use MyASTTransformation.class.getName() but instead directly use the class
     * name as a string. Disabled AST transformations only apply to automatically loaded global AST
     * transformations, that is to say transformations defined in a
     * If you explicitly add a global AST transformation in your compilation process,
     * for example using the {@link org.codehaus.groovy.control.customizers.ASTTransformationCustomizer} or
     * using a {@link org.codehaus.groovy.control.CompilationUnit.PrimaryClassNodeOperation},
     * then nothing will prevent the transformation from being loaded.
