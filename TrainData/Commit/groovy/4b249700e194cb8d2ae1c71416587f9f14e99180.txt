                for (int i = 0, len = methods.size(); i != len; i) {

                int size = matchingMethods.size();
                if (0 == size) {
                } else if (1 == size) {

                method = createTransformMetaMethod(pickClosureMethod(newArgClasses));
        final Object owner = closure.getOwner();
        final Object delegate = closure.getDelegate();
        final Object thisObject = closure.getThisObject();
        final int resolveStrategy = closure.getResolveStrategy();
        boolean invokeOnDelegate = false;
        boolean invokeOnOwner = false;
        boolean ownerFirst = true;
        switch (resolveStrategy) {
            case Closure.TO_SELF:
                break;
            case Closure.DELEGATE_ONLY:
                method = getDelegateMethod(closure, delegate, methodName, argClasses);
                callObject = delegate;
                if (method == null) {
                    invokeOnDelegate = delegate != closure && (delegate instanceof GroovyObject);
                }
                break;
            case Closure.OWNER_ONLY:
                method = getDelegateMethod(closure, owner, methodName, argClasses);
                callObject = owner;
                if (method == null) {
                    invokeOnOwner = owner != closure && (owner instanceof GroovyObject);
                }

                break;
            case Closure.DELEGATE_FIRST:
                method = getDelegateMethod(closure, delegate, methodName, argClasses);
                callObject = delegate;
                if (method == null) {
                if (method == null) {
                    invokeOnDelegate = delegate != closure && (delegate instanceof GroovyObject);
                    invokeOnOwner = owner != closure && (owner instanceof GroovyObject);
                    ownerFirst = false;
                }
                break;
            default: // owner first
                // owner first means we start with the outer most owner that is not a generated closure
                // this owner is equal to the this object, so we check that one first.
                method = getDelegateMethod(closure, thisObject, methodName, argClasses);
                callObject = thisObject;
                if (method == null) {
                    // try finding a delegate that has that method... we start from
                    // outside building a stack and try each delegate
                    LinkedList list = new LinkedList();
                    for (Object current = closure; current != thisObject;) {
                        if (!(current instanceof Closure)) break;
                        Closure currentClosure = (Closure) current;
                        if (currentClosure.getDelegate() != null) list.add(current);
                        current = currentClosure.getOwner();
                    }

                    while (!list.isEmpty() && method == null) {
                        Closure closureWithDelegate = (Closure) list.removeLast();
                        Object currentDelegate = closureWithDelegate.getDelegate();
                        method = getDelegateMethod(closureWithDelegate, currentDelegate, methodName, argClasses);
                        callObject = currentDelegate;
                    }
                }
                if (method == null) {
                    invokeOnDelegate = delegate != closure && (delegate instanceof GroovyObject);
                    invokeOnOwner = owner != closure && (owner instanceof GroovyObject);
                }
        }
        if (method == null && (invokeOnOwner || invokeOnDelegate)) {
            try {
                if (ownerFirst) {
                    return invokeOnDelegationObjects(invokeOnOwner, owner, invokeOnDelegate, delegate, methodName, arguments);
                } else {
                    return invokeOnDelegationObjects(invokeOnDelegate, delegate, invokeOnOwner, owner, methodName, arguments);
                }
            } catch (MissingMethodException mme) {
                last = mme;
