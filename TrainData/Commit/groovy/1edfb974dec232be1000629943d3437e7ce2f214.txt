        if (null != this.numberFormatError) {
            throw createParsingFailedException(this.numberFormatError.value.getMessage(), this.numberFormatError.key);
        }

                    this.numberFormatError = null; // reset the numberFormatError, try to parse the negative number

                    try {
                        String integerLiteralText = constantExpression.getNodeMetaData(INTEGER_LITERAL_TEXT);
                        if (null != integerLiteralText) {
                            return this.configureAST(new ConstantExpression(Numbers.parseInteger(null, SUB_STR  integerLiteralText)), ctx);
                        }
                        String floatingPointLiteralText = constantExpression.getNodeMetaData(FLOATING_POINT_LITERAL_TEXT);
                        if (null != floatingPointLiteralText) {
                            return this.configureAST(new ConstantExpression(Numbers.parseDecimal(SUB_STR  floatingPointLiteralText)), ctx);
                        }
                    } catch (Exception e) {
                        throw createParsingFailedException(e.getMessage(), ctx);
        Number num = null;
        try {
            num = Numbers.parseInteger(null, text);
        } catch (Exception e) {
            this.numberFormatError = new Pair<>(ctx, e);
        }

        ConstantExpression constantExpression = new ConstantExpression(num, !text.startsWith(SUB_STR));
        Number num = null;
        try {
            num = Numbers.parseDecimal(text);
        } catch (Exception e) {
            this.numberFormatError = new Pair<>(ctx, e);
        }

        ConstantExpression constantExpression = new ConstantExpression(num, !text.startsWith(SUB_STR));

    private Pair<GroovyParserRuleContext, Exception> numberFormatError;

