            if (typeCheckingContext.getEnclosingClosure() != null) {
                         returnStatement.getLineNumber()  ":"  returnStatement.getColumnNumber()
                         " "  returnStatement.getText());
     *
        if (set == null) {
        if (fn != null && Modifier.isPrivate(fn.getModifiers()) &&
                (fn.getDeclaringClass() != typeCheckingContext.getEnclosingClassNode() || typeCheckingContext.getEnclosingClosure() != null) &&
                fn.getDeclaringClass().getModule() == typeCheckingContext.getEnclosingClassNode().getModule()) {
        if (mn == null) {
            if (packageName == null) {
            Expression objectExpression = ((MethodCallExpression) call).getObjectExpression();
            clazzType.setGenericsTypes(new GenericsType[]{new GenericsType(cn)});
                if (md != null) type = md.getType();
            if (val != null) vexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY, val);
            if (val != null) vexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, val);
        if (visitPropertyExpressionSilent(pexp, pexp)) return;
            rangeType.setGenericsTypes(new GenericsType[]{new GenericsType(WideningCategories.lowestUpperBound(fromType, toType))});
            storeType(expression, rangeType);
            ClassNode resultType = (op == KEYWORD_IN || op == COMPARE_NOT_IN)
                    ? getResultType(rType, op, lType, reversedBinaryExpression)
                    : getResultType(lType, op, rType, expression);
            if (op == KEYWORD_IN || op == COMPARE_NOT_IN) {
                    && leftExpression.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE) == null) {
                            ((VariableExpression) rightExpression).getAccessedVariable() instanceof Expression &&
                            ((Expression) ((VariableExpression) rightExpression).getAccessedVariable()).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS) != null) {
                        Variable targetVariable = findTargetVariable((VariableExpression) leftExpression);
                            ((ASTNode) targetVariable).putNodeMetaData(
                                    StaticTypesMarker.CLOSURE_ARGUMENTS,
                                    ((Expression) ((VariableExpression) rightExpression).getAccessedVariable()).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS));
     *
     * @param expression      the assignment expression
     * @param leftExpression  left expression of the assignment
     * @param setterInfo      possible setters
        if (directSetterCandidate == null) {
                    if (directSetterCandidate != null) {
            Expression assignmentExpression) {
            if (methodNode != null) {
            if (!extension.handleIncompatibleAssignment(leftExpressionType, inferredRightExpressionType, assignmentExpression)) {
                addAssignmentError(leftExpressionType, inferredRightExpressionType, assignmentExpression);
            }
        if (UNKNOWN_PARAMETER_TYPE.equals(wrappedRHS) ||
            final ClassNode inferredRightExpressionTypeOrig) {
            if (isBeingCompiled(node) && arguments.length == 1 && LINKEDHASHMAP_CLASSNODE.equals(arguments[0])) {
        } else if (constructorList.size() > 1) {
     * otherwise falls back to the provided type class.
     * @param pexp     a property expression
     * @param readMode if true, look for property read, else for property set
     * @param visitor  if not null, when the property node is found, visit it with the provided visitor
                if (storeField(field, isAttributeExpression, pexp, current, visitor, receiver.getData(), !readMode))
                    return true;
            for (ClassNode dgmReceiver : dgmReceivers) {
            if (propertyType == null)
                propertyType = getTypeForListPropertyExpression(testClass, objectExpressionType, pexp);
            if (propertyType == null) propertyType = getTypeForSpreadExpression(testClass, objectExpressionType, pexp);
            if (propertyType == null) continue;
            if (visitor != null) {
            if (delegationData != null) pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);
        if (types != null && types.length == 1) contentType = types[0].getType();
            intf.setGenericsTypes(new GenericsType[]{new GenericsType(getWrapper(result.get()))});
        if (types == null || types.length != 1) return OBJECT_TYPE;
            intf.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(itemType))});
        if (objectExpressionType.getGenericsTypes() != null) {
     * <p>
        } else if (member instanceof List) {
            if (list.size() == 1) {
        if (getGenericsWithoutArray(type) != null) {
        if (field == null || !returnTrueIfFieldExists) return false;
        if (delegationData != null) {
        if (delegationData != null) {
            list.setGenericsTypes(new GenericsType[]{
        for (Receiver<String> receiver : receivers) {
            if (mn != null) {
                                isPostfix ? exprType : getMathWideningClassNode(exprType));
            storeType(origin, isPostfix ? exprType : inferReturnTypeGenerics(exprType, node, ArgumentListExpression.EMPTY_ARGUMENTS));
        if (typeCheckingContext.getEnclosingClosure() != null) {
        if (enclosingMethod != null && typeCheckingContext.getEnclosingClosure() == null) {
        if (args.length > 0 &&
                typeCheckingContext.getEnclosingClosure() != null &&
                !call.getType().isStaticClass()) {
            if (isNullConstant(exp)) {
                ret[i] = UNKNOWN_PARAMETER_TYPE;
            } else {
                ret[i] = getInferredTypeFromTempInfo(exp, getType(exp));
            }
                } else if (arr.size() == 1) {
        if (dmd == null) {
        if (parameters != null) {
            if (parameter.getInitialExpression() != null) {
        if (!typeCheckingContext.methodsToBeVisited.isEmpty() && !typeCheckingContext.methodsToBeVisited.contains(node))
            return;
                if (parameter.getInitialExpression() != null) {
                    if (mn.size() == 1)
                        typeCheckMethodsWithGenericsOrFail(currentReceiver.getType(), args, mn.get(0), call);
                    visitMethodCallArguments(receiver, argumentList, true, (MethodNode) call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET));
     * @deprecated this method is unused, replaced with {@link DelegatesTo} inference.
        Parameter[] params = selectedMethod != null ? selectedMethod.getParameters() : Parameter.EMPTY_ARRAY;
                if (i < params.length && visitClosures) {
                    checkClosureWithDelegatesTo(receiver, selectedMethod, newArgs, params, expression, param);
                        if (i > 0) {
                            inferClosureParameterTypes(receiver, arguments, (ClosureExpression) expression, param, selectedMethod);
                if (expression.getNodeMetaData(StaticTypesMarker.DELEGATION_METADATA) != null) {
     * @param expression     a closure expression for which the argument types should be inferred
     * @param param          the parameter where to look for a {@link groovy.transform.stc.ClosureParams} annotation.
        if (annotations != null && !annotations.isEmpty()) {
        Map<String, GenericsType> targetMethodDeclarationClassConnections = new HashMap<String, GenericsType>();
        Map<String, GenericsType> SAMTypeConnections = new HashMap<String, GenericsType>();
        if (blockParameterTypes == null) {
            } else if (p.length == 0 && parameterTypesForSAM.length != 0) {
        for (int i = 0; i < blockParameterTypes.length; i) {
        for (int i = 0; i < blockParameterTypes.length; i) {
                    selectedMethod instanceof ExtensionMethodNode ? ((ExtensionMethodNode) selectedMethod).getExtensionMethodNode() : selectedMethod,
        return compilationUnit != null ? compilationUnit.getTransformLoader() : getSourceUnit().getClassLoader();
        if (candidates.size() > 1) {
                    if (i < inferred.length - 1 || inferred.length == closureParams.length) {
                        ClassNode lastArgInferred = inferred[inferred.length - 1];
                    if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i == length - 1)) {
            if (candidates.size() > 1) {
        if (candidates.size() == 1) {
            if (closureParams.length == 0 && inferred.length == 1) {
                    if (i < inferred.length - 1 || inferred.length == closureParams.length) {
                        ClassNode lastArgInferred = inferred[inferred.length - 1];
                        if (lastArgInferred.isArray()) {
                            inferredType = lastArgInferred.getComponentType();
                        } else {
                            addError("Incorrect number of parameters. Expected "  inferred.length  " but found "  closureParams.length, expression);
                        }
                        addError("Expected parameter of type "  inferredType.toString(false)  " but got "  originType.toString(false), closureParam.getType());
        );
            );
     *
        if (lowerBound != null) {
            if (upperBounds != null) {
        if (options == null) {
            return new String[]{options.getText()};
        throw new IllegalArgumentException("Unexpected options for @ClosureParams:"  options);
        if (annotations != null && !annotations.isEmpty()) {
                if (strategy != null) {
                    stInt = (Integer) evaluateExpression(castX(ClassHelper.Integer_TYPE, strategy), typeCheckingContext.source.getConfiguration());
                    if (genericTypeIndex != null) {
                        addStaticTypeError("Cannot use @DelegatesTo(genericTypeIndex="  genericTypeIndex.getText()
                                 ") without @DelegatesTo.Target because generic argument types are not available at runtime", value);
                } else if (type != null && !"".equals(type.getText()) && type instanceof ConstantExpression) {
                    if (resolved != null) {
                        if (resolved.length == 1) {
                            resolved = resolveGenericsFromTypeHint(receiver, arguments, mn, resolved);
                    String parameterName = parameter instanceof ConstantExpression ? parameter.getText() : "";
                                        if (genericsTypes == null) {
                                            addStaticTypeError("Cannot use @DelegatesTo(genericTypeIndex="  genericTypeIndex.getText()
                                                     ") with a type that doesn't use generics", methodParam);
                                        } else if (gti < 0 || gti >= genericsTypes.length) {
                                            addStaticTypeError("Index of generic type @DelegatesTo(genericTypeIndex="  genericTypeIndex.getText()
                                                     ") "  (gti < 0 ? "lower" : "greater")  " than those of the selected type", methodParam);
                                            if (pTypeGenerics != null && pTypeGenerics.length > gti) {
                                                addStaticTypeError("Unable to map actual type ["  actualType.toString(false)  "] onto "  paramType.toString(false), methodParam);
                    if (expression.getNodeMetaData(StaticTypesMarker.DELEGATION_METADATA) == null) {
                                final Collection<Receiver<String>> owners,
                                final boolean implicitThis) {
        if (typeCheckingContext.delegationMetadata == null || !implicitThis) {
                        if (type != null && type.equals(CLOSURE_TYPE)) {
                    mn = disambiguateMethods(mn, chosenReceiver != null ? chosenReceiver.getType() : null, args, call);
                        if (chosenReceiver == null) {
                        if (directMethodCallCandidate == GET_DELEGATE && typeCheckingContext.getEnclosingClosure() != null) {
                            if (md != null) {
                            returnType = adjustWithTraits(directMethodCallCandidate, chosenReceiver.getType(), args, returnType);
                if (mn != null) {
                    for (int i = 0; i < argExpressions.size() && i < parameters.length; i) {
                        Expression arg = argExpressions.get(i);
                        ClassNode pType = parameters[i].getType();
                        ClassNode aType = getType(arg);
                        if (CLOSURE_TYPE.equals(pType) && CLOSURE_TYPE.equals(aType)) {
                            if (!isAssignableTo(aType, pType)) {
                                addNoMatchingMethodError(receiver, name, getArgumentTypes(argumentList), call);
                                call.removeNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);
                            }
                        }
     * @param receiver                  the receiver of the method call
     * @param args                      the arguments of the method call
     * @param returnType                the original return type, as inferred by the type checker
                return new LowestUpperBoundClassNode(returnType.getName()  "Composed", OBJECT_TYPE, nodes.toArray(ClassNode.EMPTY_ARRAY));
     *
     * @param name     the name of the method
     * @param args     the argument classes
        if (args.length != 1) return;
            MethodNode node = new MethodNode(name, Opcodes.ACC_PUBLIC, receiver.getComponentType(), new Parameter[]{new Parameter(args[0], "arg")}, null, null);
            MethodNode node = new MethodNode(name, Opcodes.ACC_PUBLIC, VOID_TYPE, new Parameter[]{new Parameter(args[0], "arg")}, null, null);
        if (getInferredReturnType(closure) != null) {
     *
        if (objectExpression instanceof ClosureExpression && (CALL.equals(name) || "doCall".equals(name))) return true;
            if (typeCheckingContext.enclosingBlocks.size() > 0) {
     * return
     * <p>
     * return
     * <p>
                    if (value != null) nonNullValues.add(value);
        return typeCheckingContext.getEnclosingClosure() != null &&
        } else if ((expressionType.getModifiers() & Opcodes.ACC_FINAL) == 0 && targetType.isInterface()) {
        } else if ((targetType.getModifiers() & Opcodes.ACC_FINAL) == 0 && expressionType.isInterface()) {
            if (enclosingBinaryExpression != null && enclosingBinaryExpression.getRightExpression() == expression) {
                (expr instanceof MapExpression && ((MapExpression) expr).getMapEntryExpressions().size() == 0);
                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, cn == null ? oldDIT : lowestUpperBound(oldDIT, cn));
                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, cn == null ? null : lowestUpperBound(oldValue, cn));
            if (var.isClosureSharedVariable() && cn != null) {
            if (leftRedirect.isArray() && implementsInterfaceOrIsSubclassOf(rightRedirect, Collection_TYPE))
                return leftRedirect;
                return inferSAMTypeGenericsInAssignment(left, findSAM(left), right, (ClosureExpression) rightExpression);
                if (isPrimitiveType(initialType) && rightRedirect.isDerivedFrom(Number_TYPE)) {
            if (method != null && implementsInterfaceOrIsSubclassOf(right, RANGE_TYPE)) {
            return method != null ? inferComponentType(left, right) : null;
                if (isIntCategory(getUnwrapper(leftRedirect)) && isIntCategory(getUnwrapper(rightRedirect)))
                    return int_TYPE;
                if (isLongCategory(getUnwrapper(leftRedirect)) && isLongCategory(getUnwrapper(rightRedirect)))
                    return long_TYPE;
                if (isBigIntCategory(getUnwrapper(leftRedirect)) && isBigIntCategory(getUnwrapper(rightRedirect)))
                    return BigInteger_TYPE;
        if (samGt == null || closureGt == null) return samUsage;
        Map<String, GenericsType> connections = new HashMap<String, GenericsType>();
        extractGenericsConnections(connections, getInferredReturnType(closureExpression), sam.getReturnType());
        for (int i = 0; i < closureParams.length; i) {
            extractGenericsConnections(connections, fromClosure, fromMethod);
        if (methods.size() > 1 && receiver != null && argTypes != null) {
            if (filteredWithGenerics.size() == 1) {
            if (i < nodesSize - 1) sb.append(", ");
     *
     * @param name     the name of the methods to return
                    stubbed = new ConstructorNode(
                    stubbed = new MethodNode(
            methods = addGeneratedMethods(receiver, new ArrayList<MethodNode>(receiver.getDeclaredConstructors()));
            methods = findMethodsWithGenerated(receiver, name);
                    methods.addAll(findMethodsWithGenerated(parent, name));
                if (pname == null) {
                        while (property == null && svCur instanceof InnerClassNode && !svCur.isStaticClass()) {
                            if (property != null) {
                if (pname != null) {
     *
     * @param prefix     the method name prefix ("get", "is", "set", ...)
        if (prefix == null || methodName == null) return null;
        if (methodName.startsWith(prefix) && prefix.length() < methodName.length()) {
     *
     * @param an   a FieldNode or PropertyNode
        type = applyGenericsContext(connections, type);
            throw new IllegalArgumentException("Storing inferred return type is only allowed on closures but found "  node.getClass());
     *
    private static class ExtensionMethodDeclaringClass {
    }
     * @param method            the method node
     * @param arguments         the method call arguments
        if (getGenericsWithoutArray(returnType) == null) return returnType;
        applyGenericsConnections(placeholdersFromContext, resolvedPlaceholders);
                        Map<String, GenericsType> pholders = applyGenericsContextToParameterClass(resolvedPlaceholders, type);
                    Map<String, GenericsType> connections = new HashMap<String, GenericsType>();
                    extractGenericsConnections(connections, actualType, type);
        if (explicitTypeHints != null) {
            if (methodGenericTypes != null && methodGenericTypes.length == explicitTypeHints.length) {
                if (unresolvedSuperClass != null && unresolvedSuperClass.isUsingGenerics()) {
     * @param samType     the type into which the closure is coerced into
    private static ClassNode convertClosureTypeToSAMType(final Expression expression, final ClassNode closureType, final ClassNode samType, final Map<String, GenericsType> placeholders) {
        if (closureType.isUsingGenerics() && sam != null) {
            //correct SAM type for generics
            //sam = applyGenericsContext(placeholders, sam);
            // the return type of the SAM method exactly corresponds to the inferred return type
            ClassNode samReturnType = sam.getReturnType();
            ClassNode closureReturnType = expression.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
            if (closureReturnType != null && closureReturnType.isUsingGenerics()) {
                ClassNode unwrapped = closureReturnType.getGenericsTypes()[0].getType();
                extractGenericsConnections(placeholders, unwrapped, samReturnType);
            } else if (samReturnType.isGenericsPlaceHolder()) {
                placeholders.put(samReturnType.getGenericsTypes()[0].getName(), closureType.getGenericsTypes()[0]);
            }
            // now repeat the same for each parameter given in the ClosureExpression
            if (expression instanceof ClosureExpression && sam.getParameters().length > 0) {
                List<ClassNode[]> genericsToConnect = new LinkedList<ClassNode[]>();
                Parameter[] closureParams = ((ClosureExpression) expression).getParameters();
                ClassNode[] closureParamTypes = extractTypesFromParameters(closureParams);
                if (expression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS) != null) {
                    closureParamTypes = expression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);
                }
                final Parameter[] parameters = sam.getParameters();
                for (int i = 0; i < parameters.length; i) {
                    final Parameter parameter = parameters[i];
                    if (parameter.getOriginType().isUsingGenerics() && closureParamTypes.length > i) {
                        genericsToConnect.add(new ClassNode[]{closureParamTypes[i], parameter.getOriginType()});
                    }
                }
                for (ClassNode[] classNodes : genericsToConnect) {
                    ClassNode found = classNodes[0];
                    ClassNode expected = classNodes[1];
                    if (!isAssignableTo(found, expected)) {
                        // probably facing a type mismatch
                        continue;
                    }
                    ClassNode generifiedType = GenericsUtils.parameterizeType(found, expected);
                    while (expected.isArray()) {
                        expected = expected.getComponentType();
                        generifiedType = generifiedType.getComponentType();
                    }
                    if (expected.isGenericsPlaceHolder()) {
                        placeholders.put(expected.getGenericsTypes()[0].getName(), new GenericsType(generifiedType));
                    } else {
                        GenericsType[] expectedGenericsTypes = expected.getGenericsTypes();
                        GenericsType[] foundGenericsTypes = generifiedType.getGenericsTypes();
                        for (int i = 0; i < expectedGenericsTypes.length; i) {
                            final GenericsType type = expectedGenericsTypes[i];
                            if (type.isPlaceholder()) {
                                String name = type.getName();
                                placeholders.put(name, foundGenericsTypes[i]);
                            }
                        }
                    }
                }
            }
        ClassNode result = applyGenericsContext(placeholders, samType.redirect());
            if (cn != null) return cn;
        if (isStaticTarget && CLASS_Type.equals(receiver) &&
                receiver.getGenericsTypes().length > 0 &&
                !OBJECT_TYPE.equals(receiver.getGenericsTypes()[0].getType())) {
            if (method != null) addMethodLevelDeclaredGenerics(method, resolvedPlaceholders);
            while (current != null) {
                    if (method != null) addMethodLevelDeclaredGenerics(method, currentPlaceHolders);
                if (resolvedPlaceholders != null) {
                    Set<Map.Entry<String, GenericsType>> entries = currentPlaceHolders.entrySet();
                    for (Map.Entry<String, GenericsType> entry : entries) {
                        if (referenced == null) continue;
                if (current == null && CLASS_Type.equals(declaringClass)) {
        if (resolvedPlaceholders == null) {
            if (method != null) descriptor = method.getTypeDescriptor();
                            " was not matched with found receiver "  receiver.getName()  "." 
        if (genericsTypes == null) return "";
            if (i < genericsTypes.length - 1) {
        if (nodes == null || nodes.length == 0) return "[]";
        if (nodeMetaData != null) {
        if ((DEBUG_GENERATED_CODE && expr.getLineNumber() < 0) || !typeCheckingContext.reportedErrors.contains(err)) {
                addError(StaticTypesTransformation.STATIC_ERROR_PREFIX  "Error in generated code ["  expr.getText()  "] - "  msg, expr);
            addStaticTypeError("Unsupported postfix operation type ["  ((PostfixExpression) expression).getOperation()  "]", expression);
            addStaticTypeError("Unsupported prefix operation type ["  ((PrefixExpression) expression).getOperation()  "]", expression);
                            if (message != null) {
                case 1:
                    return new SignatureCodecVersion1(classLoader);
                default:
                    return null;
     * <p>
