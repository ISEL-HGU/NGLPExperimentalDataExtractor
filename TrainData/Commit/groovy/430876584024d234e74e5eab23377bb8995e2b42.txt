    private Set<Variable> declaredFinalVariables = null;
        assignmentTracker.add(new StateMap());
        state.putAll(getState());
        Set<Variable> old = declaredFinalVariables;
        declaredFinalVariables = new HashSet<Variable>();
        if (isDeclaration) {
            recordFinalVars(leftExpression);
        }
        // visit RHS first for expressions like a = b = 0
        inAssignment = assignment;
        rightExpression.visit(this);
        inAssignment = false;
        leftExpression.visit(this);
        if (assignment) {
            recordAssignments(expression, isDeclaration, leftExpression, rightExpression);
        }
    }

    private void recordAssignments(BinaryExpression expression, boolean isDeclaration, Expression leftExpression, Expression rightExpression) {
        if (leftExpression instanceof Variable) {
            boolean uninitialized =
                    isDeclaration && rightExpression == EmptyExpression.INSTANCE;
            recordAssignment((Variable) leftExpression, isDeclaration, uninitialized, false, expression);
        } else if (leftExpression instanceof TupleExpression) {
            TupleExpression te = (TupleExpression) leftExpression;
            for (Expression next : te.getExpressions()) {
                if (next instanceof Variable) {
                    recordAssignment((Variable) next, isDeclaration, false, false, next);
                }
            }
        }
    }

    private void recordFinalVars(Expression leftExpression) {
        if (leftExpression instanceof VariableExpression) {
        } else if (leftExpression instanceof TupleExpression) {
            TupleExpression te = (TupleExpression) leftExpression;
            for (Expression next : te.getExpressions()) {
                if (next instanceof Variable) {
                    declaredFinalVariables.add((Variable) next);
        Map<Variable, VariableState> state = getState();
        Variable key = expression.getAccessedVariable();
        if (key == null) {
            fixVar(expression);
            key = expression.getAccessedVariable();
        }
        if (key != null && !key.isClosureSharedVariable() && callback != null) {
            if (inAssignment && variableState == VariableState.is_uninitialized) {
                callback.variableNotAlwaysInitialized(expression);
            if (beforeValue != null) {

        // getTarget(var) can be null in buggy xform code, e.g. Spock
        if (getTarget(var) == null) {
            fixVar(var);
            // we maybe can't fix a synthetic field
            if (getTarget(var) == null) return;
        }

    // getTarget(var) can be null in buggy xform code, e.g. Spock <= 1.1
    // TODO consider removing fixVar once Spock 1.2 is released - replace with informational exception?
    // This fixes xform declaration expressions but not other synthetic fields which aren't set up correctly
    private void fixVar(Variable var) {
        if (getTarget(var) == null && var instanceof VariableExpression && getState() != null && var.getName() != null) {
            for (Variable v: getState().keySet()) {
                if (var.getName().equals(v.getName())) {
                    ((VariableExpression)var).setAccessedVariable(v);
                    break;
                }
            }
        }
    }

