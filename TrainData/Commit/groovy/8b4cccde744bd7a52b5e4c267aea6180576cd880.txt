import groovy.lang.Tuple;
    private static boolean isClassExpr(Expression mrExpr) {
        List<MethodNode> mrMethodNodeList = new LinkedList<>();
                    mrMethodNodeList.add(mn);
                    mrMethodNodeList.add(mn);
        MethodNode result = chooseMrMethodNodeCandidate(mrExpr, mrMethodNodeList);

        return result;

    /**
     * Choose the best method node for method reference.
     */
    private MethodNode chooseMrMethodNodeCandidate(Expression mrExpr, List<MethodNode> mrMethodNodeList) {
        if (1 == mrMethodNodeList.size()) return mrMethodNodeList.get(0);

        return mrMethodNodeList.stream()
                .map(e -> Tuple.tuple(e, matchingScore(e, mrExpr)))
                .sorted((t1, t2) -> Integer.compare(t2.getV2(), t1.getV2()))
                .findFirst()
                .get()
                .getV1();
    }

    private static Integer matchingScore(MethodNode mn, Expression mrExpr) {
        ClassNode mrExprType = mrExpr.getType();

        int score = 9;
        for (ClassNode cn = mn.getDeclaringClass(); null != cn && !cn.equals(mrExprType); cn = cn.getSuperClass()) {
            score--;
        }
        if (score < 0) {
            score = 0;
        }
        score *= 10;

        boolean isClassExpr = isClassExpr(mrExpr);
        boolean isStaticMethod = mn.isStatic();

        if (isClassExpr && isStaticMethod || !isClassExpr && !isStaticMethod) {
            score = 9;
        }

        return score;
    }
}
