import java.util.HashSet;
import java.util.Set;
import static org.codehaus.groovy.ast.tools.GeneralUtils.getAllProperties;
    private void createSortable(AnnotationNode anno, ClassNode classNode) {
        List<String> includes = getMemberStringList(anno, "includes");
        List<String> excludes = getMemberStringList(anno, "excludes");
        boolean reversed = memberHasValue(anno, "reversed", true);
        boolean includeSuperProperties = memberHasValue(anno, "includeSuperProperties", true);
        boolean allNames = memberHasValue(anno, "allNames", true);
        boolean allProperties = !memberHasValue(anno, "allProperties", false);
        if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;
        if (!checkPropertyList(classNode, includes, "includes", anno, MY_TYPE_NAME, false, includeSuperProperties, allProperties)) return;
        if (!checkPropertyList(classNode, excludes, "excludes", anno, MY_TYPE_NAME, false, includeSuperProperties, allProperties)) return;
            addError(MY_TYPE_NAME  " cannot be applied to interface "  classNode.getName(), anno);
        List<PropertyNode> properties = findProperties(anno, classNode, includes, excludes, allProperties, includeSuperProperties, allNames);
    private List<PropertyNode> findProperties(AnnotationNode annotation, final ClassNode classNode, final List<String> includes,
                                              final List<String> excludes, final boolean allProperties,
                                              final boolean includeSuperProperties, final boolean allNames) {
        Set<String> names = new HashSet<String>();
        List<PropertyNode> props = getAllProperties(names, classNode, classNode, true, false, allProperties,
                false, includeSuperProperties, false, false, allNames, false);
        for (PropertyNode property : props) {
            if ((excludes != null && excludes.contains(propertyName)) ||
