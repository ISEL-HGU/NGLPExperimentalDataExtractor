import org.codehaus.groovy.ast.ClassHelper;
import static java.lang.Math.min;
        return isAssignableTo(arg, ptype) ? min(getDistance(arg, lastParamType), getDistance(arg, ptype)) : -1;
            Map<GenericsType, GenericsType> declaringAndActualGenericsTypeMap = makeDeclaringAndActualGenericsTypeMap(declaringClassForDistance, actualReceiverForDistance);
            Parameter[] params = makeRawTypes(safeNode.getParameters(), declaringAndActualGenericsTypeMap);
    private static ClassNode findActualTypeByGenericsPlaceholderName(String placeholderName, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
        for (Map.Entry<GenericsType, GenericsType> entry : genericsPlaceholderAndTypeMap.entrySet()) {
            GenericsType declaringGenericsType = entry.getKey();

            if (placeholderName.equals(declaringGenericsType.getName())) {
                return entry.getValue().getType();
            }
        }

        return null;
    }

    /**
     * map declaring generics type to actual generics type, e.g. GROOVY-7204:
     * declaring generics types:      T,      S extends Serializable
     * actual generics types   : String,      Long
     *
     * the result map is [
     *  T: String,
     *  S: Long
     * ]
     *
     * The resolved types can not help us to choose methods correctly if the argument is a string:  T: Object, S: Serializable
     * so we need actual types:  T: String, S: Long
     */
    private static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMap(ClassNode declaringClassForDistance, ClassNode actualReceiverForDistance) {
        GenericsType[] declaringGenericsTypes = declaringClassForDistance.getGenericsTypes();
        GenericsType[] actualGenericsTypes = actualReceiverForDistance.getGenericsTypes();

        if (null == declaringGenericsTypes) {
            return Collections.emptyMap();
        }

        if (null == actualGenericsTypes) {
            List<ClassNode> superClassAndInterfaceList = getAllSuperClassesAndInterfaces(actualReceiverForDistance);

            for (ClassNode cn : superClassAndInterfaceList) {
                if (cn.isDerivedFrom(declaringClassForDistance)) {
                    actualGenericsTypes = cn.getGenericsTypes();

                    if (null != actualGenericsTypes && declaringGenericsTypes.length == actualGenericsTypes.length) {
                        break;
                    }
                }
            }
        }

        if (null == actualGenericsTypes || declaringGenericsTypes.length != actualGenericsTypes.length) {
            return Collections.emptyMap();
        }

        Map<GenericsType, GenericsType> result = new HashMap<>();
        for (int i = 0, n = declaringGenericsTypes.length; i < n; i) {
            result.put(declaringGenericsTypes[i], actualGenericsTypes[i]);
        }

        return result;
    }

    private static List<ClassNode> getAllSuperClassesAndInterfaces(ClassNode actualReceiverForDistance) {
        List<ClassNode> superClassAndInterfaceList = new LinkedList<>();
        List<ClassNode> allSuperClassNodeList = getAllUnresolvedSuperClasses(actualReceiverForDistance);
        superClassAndInterfaceList.addAll(allSuperClassNodeList);
        superClassAndInterfaceList.addAll(actualReceiverForDistance.getAllInterfaces());

        for (ClassNode superClassNode : allSuperClassNodeList) {
            superClassAndInterfaceList.addAll(superClassNode.getAllInterfaces());
        }

        return superClassAndInterfaceList;
    }

    private static List<ClassNode> getAllUnresolvedSuperClasses(ClassNode actualReceiverForDistance) {
        List<ClassNode> superClassNodeList = new LinkedList<>();

        for (ClassNode cn = actualReceiverForDistance.getUnresolvedSuperClass(); null != cn && ClassHelper.OBJECT_TYPE != cn; cn = cn.getUnresolvedSuperClass()) {
            superClassNodeList.add(cn);
        }

        return superClassNodeList;
    }

    private static Parameter[] makeRawTypes(Parameter[] params, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {

            ClassNode actualType = findActualTypeByGenericsPlaceholderName(oldP.getType().getUnresolvedName(), genericsPlaceholderAndTypeMap);
            Parameter newP = new Parameter(makeRawType(null == actualType ? oldP.getType() : actualType), oldP.getName());
            int pindex = min(i, parameters.length - 1);
