            FieldVariableExpression fieldVariableExpression = new FieldVariableExpression(fieldNode);
                    fieldVariableExpression.storeInferredType(actualType);
                    VariableExpression variableExpression = (VariableExpression) leftExpression;

                    final Variable accessedVariable = variableExpression.getAccessedVariable();
                    if (accessedVariable instanceof FieldNode) {
                        new FieldVariableExpression((FieldNode) accessedVariable).storeInferredType(resultType);
                    }


//                new FieldVariableExpression(node).storeInferredType(getType(init));

        if (exp instanceof FieldNode) {
            ClassNode inferredType = new FieldVariableExpression((FieldNode) exp).getInferredType();

            if (null != inferredType) {
                return inferredType;
            }
        }

    private class FieldVariableExpression extends VariableExpression {
        private final FieldNode fieldNode;

        FieldVariableExpression(FieldNode fieldNode) {
            super(fieldNode);
            this.fieldNode = fieldNode;

            ClassNode inferred = getInferredType();
            if (inferred == null) {
                storeInferredType(fieldNode.getOriginType());
            }
        }

        @Override
        public ListHashMap getMetaDataMap() {
            AnnotatedNode node = getKey();

            return getMetaDataMap(node);
        }

        private ListHashMap getMetaDataMap(AnnotatedNode key) {
            if (null == key) {
                return new ListHashMap(); // all valid cases should have a methodNode as key. return a empty map is just to avoid NPE, the map will be abandoned finally
            }

            ListHashMap metaDataMap = fieldNode.getNodeMetaData(key);

            if (null == metaDataMap) {
                metaDataMap = new ListHashMap();
                fieldNode.putNodeMetaData(key, metaDataMap);
            }

            return metaDataMap;
        }

        @Override
        public int hashCode() {
            return fieldNode.hashCode();
        }

        @Override
        public boolean equals(Object other) {
            return fieldNode.equals(other);
        }

        @SuppressWarnings("unchecked")
        private ClassNode getInferredType() {
            Map<Object, Object> enclosingMetaData = getMetaDataMap();

            ClassNode inferredType = (ClassNode) enclosingMetaData.get(StaticTypesMarker.INFERRED_TYPE);

            return inferredType;
//            return null == inferredType ? (ClassNode) getMetaDataMap(getDefaultKey()).get(StaticTypesMarker.INFERRED_TYPE) : inferredType;
        }

        @SuppressWarnings("unchecked")
        private void storeInferredType(ClassNode inferredType) {
            Map<Object, Object> enclosingMetaData = getMetaDataMap();

            enclosingMetaData.put(StaticTypesMarker.INFERRED_TYPE, inferredType);
        }

        private AnnotatedNode getKey() {
            AnnotatedNode node = typeCheckingContext.getEnclosingMethod();

            return node;
//            return null == node ? getDefaultKey() : node;
        }

//        private ClassNode getDefaultKey() {
//            return typeCheckingContext.getEnclosingClassNode();
//        }
    }
