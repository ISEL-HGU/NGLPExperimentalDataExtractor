import groovy.transform.MapConstructor;
import static org.codehaus.groovy.transform.ImmutableASTTransformation.createConstructorStatement;
import static org.codehaus.groovy.transform.ImmutableASTTransformation.makeImmutable;
    private static final Class<? extends Annotation> MAP_CONSTRUCTOR_CLASS = MapConstructor.class;
        boolean makeImmutable = makeImmutable(cNode);
        boolean specialHashMapCase = (ImmutableASTTransformation.isSpecialHashMapCase(list) && superList.isEmpty()) ||
                (ImmutableASTTransformation.isSpecialHashMapCase(superList) && list.isEmpty());
        // no processing if existing constructors found unless forced or ImmutableBase in play
        if (!cNode.getDeclaredConstructors().isEmpty() && !force && !makeImmutable) return;
            FieldNode fNode = pNode.getField();
            params.add(createParam(fNode, name, defaults, xform, makeImmutable));
            } else if (!superInPre && !specialHashMapCase) {
                if (makeImmutable) {
                    body.addStatement(createConstructorStatement(xform, cNode, pNode, false));
                    if (useSetters && hasSetter) {
                        body.addStatement(stmt(callThisX(getSetterName(name), varX(name))));
                    } else {
                        body.addStatement(assignS(propX(varX("this"), name), varX(name)));
                    }

            Parameter nextParam = createParam(fNode, name, defaults, xform, makeImmutable);
            if (makeImmutable) {
                body.addStatement(createConstructorStatement(xform, cNode, pNode, false));
                if (useSetters && hasSetter) {
                    body.addStatement(stmt(callThisX(getSetterName(name), varX(nextParam))));
                } else {
                    body.addStatement(assignS(propX(varX("this"), name), varX(nextParam)));
                }

        boolean hasMapCons = hasAnnotation(cNode, MapConstructorASTTransformation.MY_TYPE);
        if (!specialHashMapCase || !hasMapCons) {
            cNode.addConstructor(new ConstructorNode(ACC_PUBLIC, params.toArray(new Parameter[params.size()]), ClassNode.EMPTY_ARRAY, body));
        }


        // If the first param is def or a Map, named args might not work as expected so we add a hard-coded map constructor in this case
        // we don't do it for LinkedHashMap for now (would lead to duplicate signature)
        // or if there is already a @MapConstructor annotation
        if (!params.isEmpty() && defaults && !hasMapCons) {
    private static Parameter createParam(FieldNode fNode, String name, boolean defaults, AbstractASTTransformation xform, boolean makeImmutable) {
        } else if (!makeImmutable) {
            // TODO we could support some default vals provided they were listed last
