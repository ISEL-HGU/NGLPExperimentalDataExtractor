import java.util.ListIterator;
import static org.codehaus.groovy.ast.tools.GeneralUtils.callThisX;
import static org.codehaus.groovy.ast.tools.GeneralUtils.castX;
import static org.codehaus.groovy.ast.tools.GeneralUtils.declS;
import static org.codehaus.groovy.ast.tools.GeneralUtils.localVarX;
import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
import static org.codehaus.groovy.ast.tools.GenericsUtils.addMethodGenerics;
 * <p>
    private static final Class<?> GENERATED_ANNOTATION = Generated.class;
    private static final Class<?> INTERNAL_ANNOTATION = Internal.class;
                            @Override
    @Override
                if (isFinal(var.getAccessedVariable().getModifiers()))
                    @Override
                        @Override
                             *      this.metaClass = this.$getStaticMetaClass()
                    @Override
                        @Override
                        @Override
                        @Override
        GroovyCodeVisitor visitor = new CodeVisitorSupport() {
            @Override
        for (Statement stmt : init) {
            stmt.visit(visitor);
    @Override
        GroovyCodeVisitor checkSuper = new CodeVisitorSupport() {
            @Override
            @Override
            @Override
    @Override
    @Override
    @Override
            getterModifiers = ~ACC_FINAL & getterModifiers;
    private void visitGetter(PropertyNode node, Statement getterBlock, int getterModifiers, String getterName) {
        MethodNode getter =
                new MethodNode(getterName, getterModifiers, node.getType(), Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, getterBlock);
        getter.setSynthetic(true);
        addPropertyMethod(getter);
        visitMethod(getter);
    @FunctionalInterface
        void call(ArgumentListExpression arguments, Parameter[] parameters, MethodNode method);
     * Creates a new method for each combination of default parameter expressions.
    protected void addDefaultParameterMethods(ClassNode type) {
        List<MethodNode> methods = new ArrayList<>(type.getMethods());
        addDefaultParameters(methods, (arguments, params, method) -> {
            BlockStatement code = new BlockStatement();
            MethodNode newMethod = new MethodNode(method.getName(), method.getModifiers(), method.getReturnType(), params, method.getExceptions(), code);
            MethodNode oldMethod = type.getDeclaredMethod(method.getName(), params);
            if (oldMethod != null) {
                throw new RuntimeParserException(
                        "The method with default parameters \""  method.getTypeDescriptor() 
                                "\" defines a method \""  newMethod.getTypeDescriptor() 
                                "\" that is already defined.",
                        method);
            }

            List<AnnotationNode> annotations = method.getAnnotations();
            if (annotations != null && !annotations.isEmpty()) {
                newMethod.addAnnotations(annotations);
            }
            newMethod.setGenericsTypes(method.getGenericsTypes());

            // GROOVY-5632, GROOVY-9151: check for references to parameters that have been removed
            GroovyCodeVisitor visitor = new CodeVisitorSupport() {
                private boolean inClosure;

                @Override
                public void visitClosureExpression(ClosureExpression e) {
                    boolean prev = inClosure; inClosure = true;
                    super.visitClosureExpression(e);
                    inClosure = prev;
                }

                @Override
                public void visitVariableExpression(VariableExpression e) {
                    if (e.getAccessedVariable() instanceof Parameter) {
                        Parameter p = (Parameter) e.getAccessedVariable();
                        if (p.hasInitialExpression() && !Arrays.asList(params).contains(p)) {
                            VariableScope blockScope = code.getVariableScope();
                            VariableExpression localVariable = (VariableExpression) blockScope.getDeclaredVariable(p.getName());
                            if (localVariable == null) {
                                // create a variable declaration so that the name can be found in the new method
                                localVariable = localVarX(p.getName(), p.getType());
                                localVariable.setModifiers(p.getModifiers());
                                blockScope.putDeclaredVariable(localVariable);
                                code.addStatement(declS(localVariable, p.getInitialExpression()));
                            }
                            if (!localVariable.isClosureSharedVariable()) {
                                localVariable.setClosureSharedVariable(inClosure);
                            }
                }
            };
            visitor.visitArgumentlistExpression(arguments);
            // if variable was created to capture an initial value expression, reference it in arguments as well
            for (ListIterator<Expression> it = arguments.getExpressions().listIterator(); it.hasNext();) {
                Expression argument = it.next();
                if (argument instanceof CastExpression) {
                    argument = ((CastExpression) argument).getExpression();
                }
                for (Parameter p : method.getParameters()) {
                    if (p.hasInitialExpression() && p.getInitialExpression() == argument) {
                        if (code.getVariableScope().getDeclaredVariable(p.getName()) != null) {
                            it.set(varX(p.getName()));
                        }
                        break;
            // delegate to original method using arguments derived from defaults
            MethodCallExpression call = callThisX(method.getName(), arguments);
            call.setMethodTarget(method);
            call.setImplicitThis(true);

            if (method.isVoidMethod()) {
                code.addStatement(new ExpressionStatement(call));
            } else {
                code.addStatement(new ReturnStatement(call));
            // GROOVY-5681: set anon. inner enclosing method reference
            visitor = new CodeVisitorSupport() {
                @Override
                public void visitConstructorCallExpression(ConstructorCallExpression call) {
                    if (call.isUsingAnonymousInnerClass()) {
                        call.getType().setEnclosingMethod(newMethod);
                    }
                    super.visitConstructorCallExpression(call);
                }
            };
            visitor.visitBlockStatement(code);

            addPropertyMethod(newMethod);
            newMethod.putNodeMetaData(DEFAULT_PARAMETER_GENERATED, Boolean.TRUE);
        });
     * Creates a new constructor for each combination of default parameter expressions.
    protected void addDefaultParameterConstructors(ClassNode type) {
        List<ConstructorNode> constructors = new ArrayList<>(type.getDeclaredConstructors());
        addDefaultParameters(constructors, (arguments, params, method) -> {
            // delegate to original constructor using arguments derived from defaults
            Statement code = new ExpressionStatement(new ConstructorCallExpression(ClassNode.THIS, arguments));
            addConstructor(params, (ConstructorNode) method, code, type);
        });
    }

    protected void addConstructor(Parameter[] newParams, ConstructorNode ctor, Statement code, ClassNode type) {
        ConstructorNode newConstructor = type.addConstructor(ctor.getModifiers(), newParams, ctor.getExceptions(), code);
        newConstructor.putNodeMetaData(DEFAULT_PARAMETER_GENERATED, Boolean.TRUE);
        markAsGenerated(type, newConstructor);
        // TODO: Copy annotations, etc.?
    }

    /**
     * Creates a new helper method for each combination of default parameter expressions.
     */
    protected void addDefaultParameters(List<? extends MethodNode> methods, DefaultArgsAction action) {
        for (MethodNode method : methods) {
        long n = Arrays.stream(parameters).filter(Parameter::hasInitialExpression).count();
        for (int i = 1; i <= n; i = 1) {
            Parameter[] newParams = new Parameter[parameters.length - i];
            int j = 1;
                    Expression e;
                    if (j > n - i && parameter.hasInitialExpression()) {
                        e = parameter.getInitialExpression();
                        newParams[index] = parameter;
                        e = varX(parameter);

                    arguments.addExpression(castX(parameter.getType(), e));

                    if (parameter.hasInitialExpression()) j = 1;
            if (parameter.hasInitialExpression()) {
                // remove default expression and store it as node metadata
                parameter.putNodeMetaData(Verifier.INITIAL_EXPRESSION,
                        parameter.getInitialExpression());
                parameter.setInitialExpression(null);
            }
     * When InnerClassVisitor adds <code>this.this$0 = $p$n</code>, it adds it
     * as a BlockStatement having that ExpressionStatement.
     */
            if (fieldNode.getType().equals(ClassHelper.REFERENCE_TYPE) && ((fieldNode.getModifiers() & ACC_SYNTHETIC) != 0)) {
     * Capitalizes the start of the given bean property name.
            @Override
        genericsSpec = addMethodGenerics(overridingMethod, genericsSpec);
                    @Override
        final int mods = ACC_STATIC | ACC_SYNTHETIC | ACC_PUBLIC;
