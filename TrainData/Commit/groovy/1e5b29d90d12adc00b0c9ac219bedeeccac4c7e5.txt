            final boolean allNames = memberHasValue(anno, "allNames", true);
            createHashCode(cNode, cacheHashCode, includeFields, callSuper, excludes, includes, allNames);
            createEquals(cNode, includeFields, callSuper, useCanEqual, excludes, includes, allNames);
        createHashCode(cNode, cacheResult, includeFields, callSuper, excludes, includes, false);
    }

    public static void createHashCode(ClassNode cNode, boolean cacheResult, boolean includeFields, boolean callSuper, List<String> excludes, List<String> includes, boolean allNames) {
                    calculateHashStatements(cNode, hash, includeFields, callSuper, excludes, includes, allNames)
            body.addStatement(calculateHashStatements(cNode, null, includeFields, callSuper, excludes, includes, allNames));
    private static Statement calculateHashStatements(ClassNode cNode, Expression hash, boolean includeFields, boolean callSuper, List<String> excludes, List<String> includes, boolean allNames) {
            if (shouldSkip(pNode.getName(), excludes, includes, allNames)) continue;
                    notIdenticalX(getter, varX("this")),
            if (shouldSkip(fNode.getName(), excludes, includes, allNames)) continue;
                    notIdenticalX(fieldExpr, varX("this")),
        createEquals(cNode, includeFields, callSuper, useCanEqual, excludes, includes, false);
    }

    public static void createEquals(ClassNode cNode, boolean includeFields, boolean callSuper, boolean useCanEqual, List<String> excludes, List<String> includes, boolean allNames) {
            if (shouldSkip(pNode.getName(), excludes, includes, allNames)) continue;
            if (shouldSkip(fNode.getName(), excludes, includes, allNames)) continue;
