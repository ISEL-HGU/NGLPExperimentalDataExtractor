        if (source instanceof PropertyExpression && typeCheckingContext.getEnclosingClosureStack().size() == 1) {
            switch (vexp.getName()) {
                case "delegate":
                    DelegationMetadata md = getDelegationMetadata(enclosingClosure.getClosureExpression());
                    if (md != null) {
                        storeType(vexp, md.getType());
                        return;
                    }
                    // falls through
                case "owner":
                    if (typeCheckingContext.getEnclosingClosureStack().size() > 1) {
                        storeType(vexp, CLOSURE_TYPE);
                        return;
                    }
                    // falls through
                case "thisObject":
                    storeType(vexp, typeCheckingContext.getEnclosingClassNode());
                    return;
                        //receivers.add(new Receiver<String>(CLOSURE_TYPE, path  "owner"));
                    //receivers.add(new Receiver<String>(CLOSURE_TYPE, path  "owner"));
        if (typeCheckingContext.delegationMetadata != null
                && objectExpression instanceof VariableExpression
                && ((VariableExpression) objectExpression).getName().equals("owner")
                && /*isNested:*/typeCheckingContext.delegationMetadata.getParent() != null) {
            owners.clear();
            List<Receiver<String>> enclosingClass = Collections.singletonList(
                    Receiver.<String>make(typeCheckingContext.getEnclosingClassNode()));
            addReceivers(owners, enclosingClass, typeCheckingContext.delegationMetadata.getParent(), "owner.");
        }
