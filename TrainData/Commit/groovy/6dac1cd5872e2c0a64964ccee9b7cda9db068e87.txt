import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;
        Class<?> theClass = metaClass.getTheClass();
        int methodModifiers = cachedMethod.getModifiers();
        if (checkAccessible(caller, declaringClass, methodModifiers, false)) {
            return metaMethod;
        }

        if (declaringClass == theClass) {
            // GROOVY-9081 "3) Access public members of private class", e.g. Collections.unmodifiableMap([:]).toString()
            // try to find the visible method from its superclasses
            List<Class<?>> superclassList = findSuperclasses(theClass);
            List<Class<?>> classList = new LinkedList<>();
            classList.add(theClass);
            classList.addAll(superclassList);

            for (Class<?> sc : classList) {
                Optional<MetaMethod> optionalMetaMethod = getAccessibleMetaMethod(metaMethod, params, caller, sc);
                if (optionalMetaMethod.isPresent()) {
                    return optionalMetaMethod.get();
                }
            }

        // GROOVY-9081 Sub-class derives the protected members from public class, "Invoke the members on the sub class instances"
        // e.g. StringBuilder sb = new StringBuilder(); sb.setLength(0);
        // `setLength` is the method of `AbstractStringBuilder`, which is `package-private`
            Optional<MetaMethod> optionalMetaMethod = getAccessibleMetaMethod(metaMethod, params, caller, theClass);
            if (optionalMetaMethod.isPresent()) {
                return optionalMetaMethod.get();
    private static Optional<MetaMethod> getAccessibleMetaMethod(MetaMethod metaMethod, Class<?>[] params, Class<?> caller, Class<?> sc) {
        List<MetaMethod> metaMethodList = getMetaMethods(metaMethod, params, sc);
        for (MetaMethod mm : metaMethodList) {
            if (checkAccessible(caller, mm.getDeclaringClass().getTheClass(), mm.getModifiers(), false)) {
                return Optional.of(mm);
            }
        }
        return Optional.empty();
    }

    private static List<MetaMethod> getMetaMethods(MetaMethod metaMethod, Class<?>[] params, Class<?> sc) {
        List<Method> optionalMethod = ReflectionUtils.getMethods(sc, metaMethod.getName(), params);
        return optionalMethod.stream().map(CachedMethod::new).collect(Collectors.toList());
    }

                    if (isExportedForIllegalAccess(declaringModule, pn)) return false;
                    if (isExportedForIllegalAccess(declaringModule, pn)) return false;
                if (isOpenedForIllegalAccess(declaringModule, pn)) return false;
    private static boolean isExportedForIllegalAccess(Module declaringModule, String pn) {
        return concealedPackageList(declaringModule).contains(pn);
    }

    private static boolean isOpenedForIllegalAccess(Module declaringModule, String pn) {
        if (isExportedForIllegalAccess(declaringModule, pn)) return true;
        return exportedPackageList(declaringModule).contains(pn);
    }

    private static List<Class<?>> findSuperclasses(Class<?> clazz) {
        List<Class<?>> result = new LinkedList<>();

        for (Class<?> c = clazz.getSuperclass(); null != c; c = c.getSuperclass()) {
            result.add(c);
        }

        return result;
    private static Set<String> exportedPackageList(Module module) {
        return EXPORTED_PACKAGES_TO_OPEN.computeIfAbsent(module.getName(), m -> new HashSet<>());
    }
