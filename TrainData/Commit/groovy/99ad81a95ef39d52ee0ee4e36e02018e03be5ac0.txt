     * @param callerClass           the callerClass to invoke {@code setAccessible}
    public boolean checkCanSetAccessible(AccessibleObject accessibleObject, Class<?> callerClass) {
        if (!super.checkCanSetAccessible(accessibleObject, callerClass)) return false;
        if (callerClass == MethodHandle.class) {
        Module callerModule = callerClass.getModule();
        int modifiers = accessibleObject instanceof Executable
                            ? ((Executable) accessibleObject).getModifiers()
                            : ((Field) accessibleObject).getModifiers();
        return checkAccessible(callerClass, declaringClass, modifiers, true);
    private static boolean checkAccessible(Class<?> callerClass, Class<?> declaringClass, int modifiers, boolean allowIllegalAccess) {
        Module callerModule = callerClass.getModule();
        // class is public and package is exported to callerClass
                    return !isExportedForIllegalAccess(declaringModule, pn);
                    && isSubclassOf(callerClass, declaringClass)) {
                    return !isExportedForIllegalAccess(declaringModule, pn);
        // package is open to callerClass
                return !isOpenedForIllegalAccess(declaringModule, pn);
