import org.codehaus.groovy.ast.expr.ArgumentListExpression;
import org.codehaus.groovy.ast.expr.ArrayExpression;
import org.codehaus.groovy.runtime.ArrayTypeUtils;
import static org.codehaus.groovy.ast.tools.GeneralUtils.args;
import static org.codehaus.groovy.ast.tools.GeneralUtils.block;
import static org.codehaus.groovy.ast.tools.GeneralUtils.ctorX;
import static org.codehaus.groovy.ast.tools.GeneralUtils.returnS;

        boolean isConstructorReference = isConstructorReference(mrMethodName);
        if (isConstructorReference) {
            mrMethodName = createSyntheticMethodForConstructorReference();
            addSyntheticMethodForConstructorReference(mrMethodName, mrExprType, parametersWithExactType);
        }

        MethodNode mrMethodNode = findMrMethodNode(mrMethodName, parametersWithExactType, mrExpr, isConstructorReference);

            if (isConstructorReference) {
                // TODO move the checking code to the Parrot parser
                throw new GroovyRuntimeException("Constructor reference must be className::new");
            }

                createBootstrapMethodArguments(
                        abstractMethodDesc,
                        mrMethodNode.isStatic() || isConstructorReference ? Opcodes.H_INVOKESTATIC : Opcodes.H_INVOKEVIRTUAL,
                        isConstructorReference ? controller.getClassNode() : mrExprType,
                        mrMethodNode)
        );
    private void addSyntheticMethodForConstructorReference(String syntheticMethodName, ClassNode returnType, Parameter[] parametersWithExactType) {
        ArgumentListExpression ctorArgs = args(parametersWithExactType);

        controller.getClassNode().addSyntheticMethod(
                syntheticMethodName,
                Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC,
                returnType,
                parametersWithExactType,
                ClassNode.EMPTY_ARRAY,
                block(
                        returnS(
                                returnType.isArray()
                                        ?   new ArrayExpression(
                                                ClassHelper.make(ArrayTypeUtils.elementType(returnType.getTypeClass())),
                                                null,
                                                ctorArgs.getExpressions()
                                            )
                                        :   ctorX(returnType, ctorArgs)
                        )
                )
        );

    }

    private String createSyntheticMethodForConstructorReference() {
        return controller.getContext().getNextConstructorReferenceSyntheticMethodName(controller.getMethodNode());
    }

    private boolean isConstructorReference(String mrMethodName) {
        return "new".equals(mrMethodName);
    }

    private MethodNode findMrMethodNode(String mrMethodName, Parameter[] abstractMethodParameters, Expression mrExpr, boolean isConstructorReference) {
        if (isConstructorReference) {
            return controller.getClassNode().getMethod(mrMethodName, abstractMethodParameters);
        }

}
