import picocli.CommandLine;
import picocli.CommandLine.*;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.Callable;
        processArgs(args, System.out, System.err);
    @Deprecated
        processArgs(args, out, out);
    }
    // package-level visibility for testing purposes (just usage/errors at this stage)
    static void processArgs(String[] args, final PrintStream out, final PrintStream err) {
        GroovyCommand groovyCommand = new GroovyCommand();
        CommandLine parser = new CommandLine(groovyCommand).setUnmatchedArgumentsAllowed(true).setStopAtUnmatched(true);
        parser.getCommandSpec().mixinStandardHelpOptions(true);
            List<CommandLine> result = parser.parse(args);
            if (CommandLine.printHelpIfRequested(result, out, err, Help.Ansi.AUTO)) {
                return;
            // TODO: pass printstream(s) down through process
            if (!groovyCommand.process(parser)) {
                // If we fail, then exit with an error so scripting frameworks can catch it.
                System.exit(1);
            }

        } catch (ParameterException ex) { // command line arguments could not be parsed
            err.println(ex.getMessage());
            ex.getCommandLine().usage(err);
            err.println("error: "  ioe.getMessage());
    static class VersionProvider implements IVersionProvider {
        @Override
        public String[] getVersion() {
            return new String[] {
                    "Groovy Version: "  GroovySystem.getVersion()  " JVM: "  System.getProperty("java.version") 
                    " Vendor: "  System.getProperty("java.vm.vendor")   " OS: "  System.getProperty("os.name")
            };
        }
    @Command(name = "groovy",
            customSynopsis = "groovy [options] [filename] [args]",
            description = "The Groovy command line processor.",
            sortOptions = false,
            versionProvider = VersionProvider.class)
    private static class GroovyCommand {
        // IMPLEMENTATION NOTE:
        // classpath must be the first argument, so that the `startGroovy(.bat)` script
        // can extract it and the JVM can be started with the classpath already correctly set.
        // This saves us from having to fork a new JVM process with the classpath set from the processed arguments.
        @Option(names = {"-cp", "-classpath", "--classpath"}, paramLabel = "<path>", description = "Specify where to find the class files - must be first argument")
        private String classpath;
        @Option(names = {"-D", "--define"}, paramLabel = "<property=value>", description = "Define a system property")
        private Map<String, String> systemProperties = new LinkedHashMap<String, String>();
        @Option(names = "--disableopt", paramLabel = "optlist", split = ",",
                description = {
                        "Disables one or all optimization elements; optlist can be a comma separated list with the elements: ",
                                "all (disables all optimizations), ",
                                "int (disable any int based optimizations)"})
        private List<String> disableopt = new ArrayList<String>();

        @Option(names = {"-d", "--debug"}, description = "Debug mode will print out full stack traces")
        private boolean debug;

        @Option(names = {"-c", "--encoding"}, paramLabel = "<charset>", description = "Specify the encoding of the files")
        private String encoding;

        @Option(names = {"-e"}, paramLabel = "<script>", description = "Specify a command line script")
        private String script;

        @Option(names = {"-i"}, arity = "0..1", paramLabel = "<extension>", description = "Modify files in place; create backup if extension is given (e.g. \'.bak\')")
        private String extension;

        @Option(names = {"-n"}, description = "Process files line by line using implicit 'line' variable")
        private boolean lineByLine;

        @Option(names = {"-p"}, description = "Process files line by line and print result (see also -n)")
        private boolean lineByLinePrint;

        @Option(names = {"-pa", "--parameters"}, description = "Generate metadata for reflection on method parameter names (jdk8 only)")
        private boolean parameterMetadata;

        @Option(names = "-l", arity = "0..1", paramLabel = "<port>", description = "Listen on a port and process inbound lines (default: 1960)")
        private String port;

        @Option(names = {"-a", "--autosplit"}, arity = "0..1", paramLabel = "<splitPattern>", description = "Split lines using splitPattern (default '\\s') using implicit 'split' variable")
        private String splitPattern;

        @Option(names = {"--indy"}, description = "Enables compilation using invokedynamic")
        private boolean indy;

        @Option(names = {"--configscript"}, paramLabel = "<script>", description = "A script for tweaking the configuration options")
        private String configscript;

        @Option(names = {"-b", "--basescript"}, paramLabel = "<class>", description = "Base class name for scripts (must derive from Script)")
        private String scriptBaseClass;

        @Unmatched
        List<String> arguments = new ArrayList<String>();

        /**
         * Process the users request.
         *
         * @param parser the parsed command line. Used when the user input was invalid.
         * @throws ParameterException if the user input was invalid
         */
        boolean process(CommandLine parser) throws ParameterException, IOException {
            for (String key : systemProperties.keySet()) {
                System.setProperty(key, systemProperties.get(key));
            GroovyMain main = new GroovyMain();

            // add the ability to parse scripts with a specified encoding
            main.conf.setSourceEncoding(encoding);

            main.debug = debug;
            main.conf.setDebug(main.debug);
            main.conf.setParameters(parameterMetadata);
            main.processFiles = lineByLine || lineByLinePrint;
            main.autoOutput = lineByLinePrint;
            main.editFiles = extension != null;
            if (main.editFiles) {
                main.backupExtension = extension;
            }

            main.autoSplit = splitPattern != null;
            if (main.autoSplit) {
                main.splitPattern = splitPattern;
            }

            main.isScriptFile = script == null;
            if (main.isScriptFile) {
                if (arguments.isEmpty()) {
                    throw new ParameterException(parser, "error: neither -e or filename provided");
                }
                main.script = arguments.remove(0);
                if (main.script.endsWith(".java")) {
                    throw new ParameterException(parser, "error: cannot compile file with .java extension: "  main.script);
                }
            } else {
                main.script = script;
            }

            main.processSockets = port != null;
            if (main.processSockets) {
                String p = port.trim().length() > 0 ? port : "1960"; // default port to listen to
                main.port = Integer.parseInt(p);
            }

            for (String optimization : disableopt) {
                main.conf.getOptimizationOptions().put(optimization, false);
            }

            if (indy) {
                CompilerConfiguration.DEFAULT.getOptimizationOptions().put("indy", true);
                main.conf.getOptimizationOptions().put("indy", true);
            }

            if (scriptBaseClass != null) {
                main.conf.setScriptBaseClass(scriptBaseClass);
            }

            processConfigScripts(getConfigScripts(), main.conf);

            main.args = arguments;
            return main.run();
        private List<String> getConfigScripts() {
            if (this.configscript != null) {
                scripts.add(this.configscript);
            String configScripts = System.getProperty("groovy.starter.configscripts", null);
            if (configScripts != null && !configScripts.isEmpty()) {
            return scripts;
