            delegationData = adjustData(delegationData, receiver, typeCheckingContext.delegationMetadata);
                                data = adjustData(data, chosenReceiver.getType(), typeCheckingContext.delegationMetadata);
    // adjust data to handle cases like nested .with since we didn't have enough information earlier
    // TODO see if we can make the earlier detection smarter and then remove this adjustment
    private static String adjustData(String data, ClassNode type, DelegationMetadata dmd) {
        StringBuilder path = new StringBuilder();
        int i = 0;
        String[] propertyPath = data.split("\\.");
        while (dmd != null) {
            int strategy = dmd.getStrategy();
            ClassNode delegate = dmd.getType();
            dmd = dmd.getParent();
            switch (strategy) {
                case Closure.DELEGATE_FIRST:
                    if (!delegate.isDerivedFrom(CLOSURE_TYPE) && !delegate.isDerivedFrom(type)) {
                        path.append("owner"); // must be non-delegate case
                    } else {
                        path.append("delegate");
                    }
                    break;
                default:
                    if (i >= propertyPath.length) return data;
                    path.append(propertyPath[i]);
            }
            if (type.equals(delegate)) break;
            i;
            if (dmd != null) path.append('.');
        }
        String result = path.toString();
        if (!result.isEmpty()) {
            return result;
        }
        return data;
    }

