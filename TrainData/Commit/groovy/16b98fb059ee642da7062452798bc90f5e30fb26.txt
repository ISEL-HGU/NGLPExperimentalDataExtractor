import java.util.LinkedHashMap;
            Map<GenericsType, GenericsType> declaringAndActualGenericsTypeMap = makeDeclaringAndActualGenericsTypeMap(declaringClassForDistance, actualReceiverForDistance);
            Parameter[] params = makeRawTypes(safeNode.getParameters(), declaringAndActualGenericsTypeMap);
    private static ClassNode findActualTypeByGenericsPlaceholderName(String placeholderName, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
        for (Map.Entry<GenericsType, GenericsType> entry : genericsPlaceholderAndTypeMap.entrySet()) {
            GenericsType declaringGenericsType = entry.getKey();

            if (placeholderName.equals(declaringGenericsType.getName())) {
                return entry.getValue().getType();
            }
        }

        return null;
    }

    /**
     * map declaring generics type to actual generics type, e.g. GROOVY-7204:
     * declaring generics types:      T,      S extends Serializable
     * actual generics types   : String,      Long
     *
     * the result map is [
     *  T: String,
     *  S: Long
     * ]
     *
     * The resolved types can not help us to choose methods correctly if the argument is a string:  T: Object, S: Serializable
     * so we need actual types:  T: String, S: Long
     */
    private static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMap(ClassNode declaringClass, ClassNode actualReceiver) {
        ClassNode parameterizedType = GenericsUtils.findParameterizedType(declaringClass, actualReceiver);

        if (null == parameterizedType) {
            return Collections.emptyMap();
        }

        GenericsType[] declaringGenericsTypes = declaringClass.getGenericsTypes();
        GenericsType[] actualGenericsTypes = parameterizedType.getGenericsTypes();

        Map<GenericsType, GenericsType> result = new LinkedHashMap<>();
        for (int i = 0, n = declaringGenericsTypes.length; i < n; i) {
            result.put(declaringGenericsTypes[i], actualGenericsTypes[i]);
        }

        return result;
    }

    private static Parameter[] makeRawTypes(Parameter[] params, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
            ClassNode actualType = findActualTypeByGenericsPlaceholderName(oldP.getType().getUnresolvedName(), genericsPlaceholderAndTypeMap);
