import java.io.InputStream;
import java.net.URL;
public class DefaultCipherService
    private static final Charset UTF_8 = Charset.forName("UTF-8");
    private static final String HASH_ALGORITHM = "SHA-256";
    private static final String CIPHER_ALGORITHM = "AES";
    public String setMasterHash(String masterPassword, String masterSalt, boolean overwrite)
        throws IOException
            if (!masterFile.getParentFile().mkdirs())
            keys = loadProperties(masterFile.toURI().toURL());
            throw new IllegalStateException("MasterKey for hash "  saltHash 

        return saltHash;
    protected String getMasterKey(String masterSalt)
            throw new IllegalStateException("Could not find master.hash file. Create a master password first!");
            Properties keys = loadProperties(masterFile.toURI().toURL());
                throw new IllegalStateException("Could not find master key for hash "  saltKey 
            throw new RuntimeException(e);
    public String encrypt(String cleartext, String masterSalt)
    public String decrypt(String encryptedValue, String masterSalt)
            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);
            throw new RuntimeException(e);
            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
            throw new RuntimeException(e);
            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
            throw new RuntimeException(e);
        // Note: using 128 bit AES avoids requirement for "Unlimited Crypto" patch

    /**
     * Copied over from PropertyFileUtils to avoid the need for having the api
     * on the classpath when using the password encode CLI
     */
    private Properties loadProperties(URL url)
    {
        Properties props = new Properties();

        InputStream inputStream = null;
        try
        {
            inputStream = url.openStream();

            if (inputStream != null)
            {
                props.load(inputStream);
            }
        }
        catch (IOException e)
        {
            throw new IllegalStateException(e);
        }
        finally
        {
            try
            {
                if (inputStream != null)
                {
                    inputStream.close();
                }
            }
            catch (IOException e)
            {
                // no worries, means that the file is already closed
            }
        }

        return props;
    }


