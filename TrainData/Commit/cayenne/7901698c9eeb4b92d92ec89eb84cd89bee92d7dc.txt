        DbEntity sourceEntity = incomingDB.getSourceEntity();
        String tableName = quoter.quotedFullyQualifiedName(sourceEntity);
                    String subquerySourceTableName = quoter.quotedFullyQualifiedName(dbRelationship.getSourceEntity());
                    String subqueryTargetTableName = quoter.quotedFullyQualifiedName(dbRelationship.getTargetEntity());

                    String subqueryTargetAlias;
                        context.append(subquerySourceTableName).append(' ').append(subquerySourceAlias);
                    context.append(subqueryTargetTableName).append(' ').append(subqueryTargetAlias);
            } else {
                String targetAlias = appendTable(rhsId);
        } finally {

            // support "AS", and the rest of the databases do not care

            generateJoinsForFlattenedAttributes(id);

        } else {
     *
    private void generateJoinsForFlattenedAttributes(EJBQLTableId id) {
        String entityName = context.getEntityDescriptor(id.getEntityId())
        boolean isProcessingOmitted = id.getDbPath() != null;

            Collection<ObjAttribute> attributes = context.getEntityDescriptor(id.getEntityId())
                    .getEntity().getAttributes();
                        && sourceExpression.contains(id.getEntityId()  "."  objAttribute.getName())) {
                    Iterator<CayenneMapEntry> dbPathIterator = objAttribute.getDbPathIterator();
                            String targetEntityName = quoter.quotedFullyQualifiedName(rel.getTargetEntity());
                                            quoter.quotedFullyQualifiedName(rel.getSourceEntity())),
    private EJBQLExpression ejbqlQualifierForEntityAndSubclasses(Expression qualifier, String entityId) {
        // parser only works on full queries, so prepend a dummy query and then strip it out...
