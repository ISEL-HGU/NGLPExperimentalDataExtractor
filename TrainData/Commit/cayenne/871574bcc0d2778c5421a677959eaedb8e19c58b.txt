
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.cayenne.Persistent;
import org.apache.cayenne.di.Inject;
import org.apache.cayenne.di.Provider;
 * <p>
 * A {@link DataChannelFilter} that invalidates cache groups.
 * Use custom rules for invalidation provided via DI.
 * </p>
 * <p>
 * Default rule is based on entities' {@link CacheGroups} annotation.
 * </p>
 * <p>
 *     To add default filter: <pre>
 *         ServerRuntime.builder("cayenne-project.xml")
 *              .addModule(CacheInvalidationModuleBuilder.builder().build());
 *     </pre>
 * </p>
 *
 * @see InvalidationHandler
 * @see CacheInvalidationModuleBuilder
    @Inject
    private Provider<QueryCache> cacheProvider;

    @Inject(CacheInvalidationModuleBuilder.INVALIDATION_HANDLERS_LIST)
    private List<InvalidationHandler> handlers;

    private final Map<Class<? extends Persistent>, InvalidationFunction> mappedHandlers;

    private final InvalidationFunction skipHandler;

    private final ThreadLocal<Set<String>> groups;

    public CacheInvalidationFilter() {
        mappedHandlers = new ConcurrentHashMap<>();
        skipHandler = new InvalidationFunction() {
            @Override
            public Collection<String> apply(Persistent p) {
                return Collections.emptyList();
            }
        };
        groups = new ThreadLocal<>();
    }
    public QueryResponse onQuery(ObjectContext originatingContext, Query query, DataChannelFilterChain filterChain) {
    public GraphDiff onSync(ObjectContext originatingContext, GraphDiff changes,
                            int syncType, DataChannelFilterChain filterChain) {
                QueryCache cache = cacheProvider.get();
        } finally {
    @PrePersist
    @PreRemove
    @PreUpdate
        // TODO: for some reason we can't use Persistent as the argument type... (is it fixed in Cayenne 4.0.M4?)
        Persistent p = (Persistent) object;
        InvalidationFunction invalidationFunction = mappedHandlers.get(p.getClass());
        if(invalidationFunction == null) {
            invalidationFunction = skipHandler;
            for (InvalidationHandler handler : handlers) {
                InvalidationFunction function = handler.canHandle(p.getClass());
                if (function != null) {
                    invalidationFunction = function;
                    break;
                }
            }
            mappedHandlers.put(p.getClass(), invalidationFunction);
        Collection<String> objectGroups = invalidationFunction.apply(p);
        if (!objectGroups.isEmpty()) {
            getOrCreateTxGroups().addAll(objectGroups);
        }

    protected Set<String> getOrCreateTxGroups() {
        Set<String> txGroups = groups.get();
        if (txGroups == null) {
            txGroups = new HashSet<>();
            groups.set(txGroups);

        return txGroups;
