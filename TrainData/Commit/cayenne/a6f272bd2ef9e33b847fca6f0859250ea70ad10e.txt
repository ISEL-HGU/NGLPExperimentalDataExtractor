import org.slf4j.helpers.FormattingTuple;
import org.slf4j.helpers.MessageFormatter;
import java.io.PrintStream;
import java.text.SimpleDateFormat;
import java.util.Date;
 * ModelerLogger is a Logger implementation, which performs output
 * to the LogConsole.

    private static final int BUFFER_SIZE = 32;
    private static final byte LOG_LEVEL_INFO = 2;
    private static final byte LOG_LEVEL_DEBUG = 1;
    private static final byte LOG_LEVEL_TRACE = 0;
    private static final byte LOG_LEVEL_WARNING = 3;
    private static final byte LOG_LEVEL_ERROR = 4;

    private static final String INFO_LOG_NAME = "INFO";
    private static final String DEBUG_LOG_NAME = "DEBUG";
    private static final String TRACE_LOG_NAME = "TRACE";
    private static final String WARNING_LOG_NAME = "WARNING";
    private static final String ERROR_LOG_NAME = "ERROR";
    private static final String DATE_FORMAT = "yyyy/MM/dd HH.mm.ss";
    private String name;
    private int currentLogLevel = LOG_LEVEL_INFO;

    public ModelerLogger(String name) {
    }

    private String getLogLevel(byte level) {
        switch (level) {
            case LOG_LEVEL_INFO:
                return INFO_LOG_NAME;

            case LOG_LEVEL_DEBUG:
                return DEBUG_LOG_NAME;

            case LOG_LEVEL_TRACE:
                return TRACE_LOG_NAME;

            case LOG_LEVEL_WARNING:
                return WARNING_LOG_NAME;

            case LOG_LEVEL_ERROR:
                return ERROR_LOG_NAME;

            default:
                throw new IllegalStateException("Unregistered log level - "  level);

        }
    }

    private void consoleLog(byte level, String message, Throwable throwable) {
        if(this.isLevelEnabled(level)) {
            StringBuilder buffer = new StringBuilder(BUFFER_SIZE);
            buffer.append(this.getFormattedDate());
            buffer.append(' ');

            buffer.append('[');
            buffer.append(Thread.currentThread().getName());
            buffer.append("] ");

            buffer.append('[');
            String levelStr = this.getLogLevel(level);
            buffer.append(levelStr);
            buffer.append(']');

            buffer.append(' ');
            buffer.append(message);
            this.write(buffer, throwable);
        }
    }
    
    private void consoleLog(byte level, String message) {
        consoleLog(level, message, (Throwable) null);
    }

    private void consoleLog(byte level, String format, Object... arguments) {
        if(this.isLevelEnabled(level)) {
            FormattingTuple tuple = MessageFormatter.arrayFormat(format, arguments);
            this.consoleLog(level, tuple.getMessage(), tuple.getThrowable());
        }
    }

    private String getFormattedDate() {
        Date currentDate = new Date();
        SimpleDateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
        String dateText = formatter.format(currentDate);
        return dateText;
    }

    private void write(StringBuilder buffer, Throwable throwable) {
        PrintStream targetStream = System.err;
        targetStream.println(buffer.toString());
        this.writeThrowable(throwable, targetStream);
        targetStream.flush();
    }

    private void writeThrowable(Throwable throwable, PrintStream targetStream) {
        if(throwable != null) {
            throwable.printStackTrace(targetStream);
        }

    }

    private boolean isLevelEnabled(int logLevel) {
        return (logLevel >= this.currentLogLevel);
        consoleLog(LOG_LEVEL_DEBUG, message);
        consoleLog(LOG_LEVEL_DEBUG, message, object);
        consoleLog(LOG_LEVEL_DEBUG, message, object, secondObject);
        consoleLog(LOG_LEVEL_DEBUG, message, objects);
        consoleLog(LOG_LEVEL_DEBUG, message, throwable);
        return isLevelEnabled(LOG_LEVEL_DEBUG);
        consoleLog(LOG_LEVEL_DEBUG, message);
        consoleLog(LOG_LEVEL_DEBUG, message, object);
        consoleLog(LOG_LEVEL_DEBUG, message, object, secondObject);
        consoleLog(LOG_LEVEL_DEBUG, message, objects);
        consoleLog(LOG_LEVEL_DEBUG, message, throwable);
        return isLevelEnabled(LOG_LEVEL_INFO);
        consoleLog(LOG_LEVEL_ERROR, message);
        consoleLog(LOG_LEVEL_ERROR, message, object);
        consoleLog(LOG_LEVEL_ERROR, message, object, secondObject);
        consoleLog(LOG_LEVEL_ERROR, message, objects);
        consoleLog(LOG_LEVEL_ERROR, message, throwable);
        return isLevelEnabled(LOG_LEVEL_ERROR);
        consoleLog(LOG_LEVEL_ERROR, message);
        consoleLog(LOG_LEVEL_ERROR, message, object);
        consoleLog(LOG_LEVEL_ERROR, message, object, secondObject);
        consoleLog(LOG_LEVEL_ERROR, message, objects);
        consoleLog(LOG_LEVEL_ERROR, message, throwable);
        consoleLog(LOG_LEVEL_INFO, message);
        consoleLog(LOG_LEVEL_INFO, message, object);
        consoleLog(LOG_LEVEL_INFO, message, object, secondObject);
        consoleLog(LOG_LEVEL_INFO, message, objects);
        consoleLog(LOG_LEVEL_INFO, message, throwable);
        return isLevelEnabled(LOG_LEVEL_INFO);
        consoleLog(LOG_LEVEL_INFO, message);
        consoleLog(LOG_LEVEL_INFO, message, object);
        consoleLog(LOG_LEVEL_INFO, message, object, secondObject);
        consoleLog(LOG_LEVEL_INFO, message, objects);
        consoleLog(LOG_LEVEL_INFO, message, throwable);
        return isLevelEnabled(LOG_LEVEL_WARNING);
        return name;
        return isLevelEnabled(LOG_LEVEL_TRACE);
        consoleLog(LOG_LEVEL_TRACE, message);
        consoleLog(LOG_LEVEL_TRACE, message, object);
        consoleLog(LOG_LEVEL_TRACE, message, secondObject);
        consoleLog(LOG_LEVEL_TRACE, message, objects);
        consoleLog(LOG_LEVEL_TRACE, message, throwable);
        return isLevelEnabled(LOG_LEVEL_TRACE);
        consoleLog(LOG_LEVEL_TRACE, message);
        consoleLog(LOG_LEVEL_TRACE, message, object);
        consoleLog(LOG_LEVEL_TRACE, message, object, secondObject);
        consoleLog(LOG_LEVEL_TRACE, message, objects);
        consoleLog(LOG_LEVEL_TRACE, message, throwable);
        consoleLog(LOG_LEVEL_WARNING, message);
        consoleLog(LOG_LEVEL_WARNING, message, object);
        consoleLog(LOG_LEVEL_WARNING, message, objects);
        consoleLog(LOG_LEVEL_WARNING, message, secondObject);
        consoleLog(LOG_LEVEL_WARNING, message, throwable);
        return isLevelEnabled(LOG_LEVEL_WARNING);
        consoleLog(LOG_LEVEL_WARNING, message);
        consoleLog(LOG_LEVEL_WARNING, message, object);
        consoleLog(LOG_LEVEL_WARNING, message, object, secondObject);
        consoleLog(LOG_LEVEL_WARNING, message, objects);
        consoleLog(LOG_LEVEL_WARNING, message, throwable);
        return isLevelEnabled(LOG_LEVEL_ERROR);
     * Prints common message to the modeler console
        FormattingTuple tuple = MessageFormatter.arrayFormat(message, parameters);
        getLogConsole().appendMessage(level, tuple.getMessage(), throwable, style);
