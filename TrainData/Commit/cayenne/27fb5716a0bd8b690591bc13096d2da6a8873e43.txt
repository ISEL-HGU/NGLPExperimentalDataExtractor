        if (connections == null || connections.isEmpty()) {
            return;
        }
        Throwable deferredException = null;
        for (Connection connection : connections.values()) {
            try {
                if (deferredException == null) {
                    connection.commit();
                } else {
                    // we must do a partial rollback if only to cleanup uncommitted connections.
                    connection.rollback();
            } catch (Throwable th) {
                // there is no such thing as "partial" rollback in real
                // transactions, so we can't set any meaningful status.
                // status = ?;
                setRollbackOnly();
                // stores last exception
                // TODO: chain exceptions...
                deferredException = th;

        if (deferredException != null) {
            logger.logRollbackTransaction("transaction rolledback.");
            throw new CayenneRuntimeException(deferredException);
        } else {
            logger.logCommitTransaction("transaction committed.");
        }
        if (connections == null || connections.isEmpty()) {
            return;
        }
        Throwable deferredException = null;
        for (Connection connection : connections.values()) {
            try {
                // continue with rollback even if an exception was thrown
                // before
                connection.rollback();
            } catch (Throwable th) {
                // stores last exception
                // TODO: chain exceptions...
                deferredException = th;
        }
        if (deferredException != null) {
            throw new CayenneRuntimeException(deferredException);
