import java.util.function.Predicate;
        return resolve(name -> {
            DataChannelDescriptor dataChannelDescriptor = (DataChannelDescriptor) parent;
            for (DataNodeDescriptor dataNodeDescriptor : dataChannelDescriptor.getNodeDescriptors()) {
                if (dataNodeDescriptor.getName().equals(name)) {
                    return true;

            return false;
        return resolve(name -> {
            // null context is a situation when DataMap is a
            // top level object of the project
            if (parent == null) {

            if (parent instanceof DataChannelDescriptor) {
                DataChannelDescriptor domain = (DataChannelDescriptor) parent;
                return domain.getDataMap(name) != null;
            }
            return false;
        return resolve(name -> ((DataMap) parent).getObjEntity(name) != null);
        return resolve(name -> ((DataMap) parent).getDbEntity(name) != null);
        return resolve(name -> {
            DataMap map = (DataMap) parent;
            return map.getEmbeddable(map.getNameWithDefaultPackage(name)) != null;
        return resolve(name -> ((Embeddable) parent).getAttribute(name) != null);
        return resolve(name -> ((DataMap) parent).getProcedure(name) != null);
        return resolve(name -> {
            // it doesn't matter if we create a parameter with a duplicate name.. parameters are positional anyway..
            // still try to use unique names for visual consistency
            Procedure procedure = (Procedure) parent;
            for (ProcedureParameter parameter1 : procedure.getCallParameters()) {
                if (name.equals(parameter1.getName())) {
                    return true;

            return false;
        return resolve(name -> ((DataMap) parent).getQueryDescriptor(name) != null);
    String resolve(Predicate<String> nameChecker) {
        while (nameChecker.test(name)) {
        return resolve(name -> {
            DbEntity entity = (DbEntity) parent;
            // check if either attribute or relationship name matches...
            return entity.getAttribute(name) != null || entity.getRelationship(name) != null;
        return resolve(name -> {
            ObjEntity entity = (ObjEntity) parent;
            // check if either attribute or relationship name matches...
            if (entity.getAttribute(name) != null || entity.getRelationship(name) != null) {
                return true;
            //  check if there's a callback method that shadows attribute getter (unlikely, but still)
            String conflictingCallback = "get"  NameUtil.capitalize(name);
            return entity.getCallbackMethods().contains(conflictingCallback);
        });
