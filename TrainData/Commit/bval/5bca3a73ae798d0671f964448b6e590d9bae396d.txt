import java.lang.annotation.Annotation;
import java.util.HashSet;
import java.util.stream.Stream;
import javax.enterprise.inject.spi.AfterDeploymentValidation;
import javax.enterprise.inject.spi.Annotated;
import javax.validation.Constraint;
import javax.validation.Valid;
    private final Collection<Class<?>> potentiallyBValAnnotation = new HashSet<>();
    private final Collection<Class<?>> notBValAnnotation = new HashSet<>();

        if (!javaClass.isInterface() && !javaClass.isAnonymousClass() && !Modifier.isFinal(modifiers) && !Modifier.isAbstract(modifiers)) {
                if (hasValidation(annotatedType)
                    || hasValidationAnnotation(annotatedType.getMethods())
                    || hasValidationAnnotation(annotatedType.getConstructors())
                    || Stream.concat(annotatedType.getMethods().stream(), annotatedType.getConstructors().stream())
                        .flatMap(it -> it.getParameters().stream())
                        .anyMatch(this::hasValidation)) {
                    pat.setAnnotatedType(new BValAnnotatedType<>(annotatedType));
            } catch (final NoClassDefFoundError ncdfe) {
                // skip
    public void afterStart(@Observes final AfterDeploymentValidation clearEvent) {
        potentiallyBValAnnotation.clear();
        notBValAnnotation.clear();
    }

    private boolean hasValidationAnnotation(final Collection<? extends Annotated> annotateds) {
        return annotateds.stream().anyMatch(this::hasValidation);
    }

    private boolean hasValidation(final Annotated m) {
        return m.getAnnotations().stream()
                .anyMatch(it -> {
                    final Class<? extends Annotation> type = it.annotationType();
                    if (type == ValidateOnExecution.class || type == Valid.class) {
                        return true;
                    }
                    if (isSkippedAnnotation(type)) {
                        return false;
                    }
                    if (type.getName().startsWith("javax.validation.constraints")) {
                        return true;
                    }
                    if (notBValAnnotation.contains(type)) { // more likely so faster first
                        return false;
                    }
                    if (potentiallyBValAnnotation.contains(type)) {
                        return true;
                    }
                    cacheIsBvalAnnotation(type);
                    return potentiallyBValAnnotation.contains(type);
                });
    }

    private boolean isSkippedAnnotation(final Class<? extends Annotation> type) {
        if (type.getName().startsWith("java.")) {
            return true;
        }
        if (type.getName().startsWith("javax.enterprise.")) {
            return true;
        }
        if (type.getName().startsWith("javax.inject.")) {
            return true;
        }
        return false;
    }

    private void cacheIsBvalAnnotation(final Class<? extends Annotation> type) {
        if (flattenAnnotations(type, new HashSet<>()).anyMatch(it -> it == Constraint.class)) {
            potentiallyBValAnnotation.add(type);
        } else {
            notBValAnnotation.add(type);
        }
    }

    private Stream<Class<?>> flattenAnnotations(final Class<? extends Annotation> type, final Set<Class<?>> seen) {
        seen.add(type);
        return Stream.of(type)
                     .flatMap(it -> Stream.concat(
                             Stream.of(it),
                             Stream.of(it.getAnnotations())
                                   .map(Annotation::annotationType)
                                   .distinct()
                                   .filter(a -> !isSkippedAnnotation(a))
                                   .filter(seen::add)
                                   .flatMap(a -> flattenAnnotations(a, seen))));
    }

