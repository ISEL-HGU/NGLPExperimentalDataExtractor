import java.util.function.Consumer;
        hierarchy(result.consumer(Set::add));
        return Stream.concat(Stream.of(this), getAssignableKeys().stream())
            .anyMatch(cek -> cek.typeArgumentIndex != null
                && cek.containerClass.getTypeParameters()[cek.typeArgumentIndex.intValue()].equals(var));
    }

    private void hierarchy(Consumer<ContainerElementKey> sink) {
        if (typeArgumentIndex == null) {
            return;
        }
        final TypeVariable<?> var = containerClass.getTypeParameters()[typeArgumentIndex.intValue()];

        final Lazy<Set<ContainerElementKey>> round = new Lazy<>(LinkedHashSet::new);
        Stream
            .concat(Stream.of(containerClass.getAnnotatedSuperclass()),
                Stream.of(containerClass.getAnnotatedInterfaces()))
            .filter(AnnotatedParameterizedType.class::isInstance).map(AnnotatedParameterizedType.class::cast)
            .forEach(t -> {
                final AnnotatedType[] args = ((AnnotatedParameterizedType) t).getAnnotatedActualTypeArguments();
                for (int i = 0; i < args.length; i) {
                    if (args[i].getType().equals(var)) {
                        round.get().add(new ContainerElementKey(t, Integer.valueOf(i)));
                    }
                }
            });

        round.optional().ifPresent(s -> {
            s.forEach(sink);
            s.forEach(k -> k.hierarchy(sink));
        });
