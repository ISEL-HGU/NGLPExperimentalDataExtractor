import java.util.IdentityHashMap;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.function.Predicate;
import org.apache.bval.jsr.descriptor.DescriptorManager;
import org.apache.bval.jsr.groups.GroupStrategy;
        void process(GroupStrategy groups, Consumer<ConstraintViolation<T>> sink) {

            GroupStrategy.redefining(groups, Collections.singletonMap(Group.DEFAULT, descriptor.getGroupStrategy()))
                .applyTo(noViolations(gs -> validateDescriptorConstraints(gs, sink)));

            recurse(groups, sink);
        void recurse(GroupStrategy groups, Consumer<ConstraintViolation<T>> sink) {
        void validateDescriptorConstraints(GroupStrategy groups, Consumer<ConstraintViolation<T>> sink) {
            constraintsFor(descriptor, groups)
                    validatorContext.getValueExtractors().findUnwrappingInfo(context.getValue().getClass(),
                        valueUnwrapping);
            final ConcurrentMap<Path, Set<Object>> pathMap = completedValidations.computeIfAbsent(constraint,
                k -> new ConcurrentSkipListMap<>(PathImpl.PATH_COMPARATOR));
            final Set<Object> objectSet =
                pathMap.computeIfAbsent(context.getPath(), p -> Collections.newSetFromMap(new IdentityHashMap<>()));
            if (!objectSet.add(context.getValue())) {
            final Set<Boolean> validationResults = constraint.getComposingConstraints().stream().map(ConstraintD.class::cast)
            return Collections.singleton(Boolean.TRUE).equals(validationResults);
        void process(GroupStrategy groups, Consumer<ConstraintViolation<T>> sink) {

            final GroupStrategy localGroupStrategy = GroupStrategy.redefining(groups,
                Collections.singletonMap(Group.DEFAULT, descriptor.getGroupStrategy()));

            localGroupStrategy.applyTo(noViolations(gs -> {
                validateDescriptorConstraints(gs, sink);
                propertyFrames.get().forEach(p -> {
                    p.validateDescriptorConstraints(gs, sink);
                    if (localGroupStrategy == groups) {
                        p.recurse(gs, sink);
                    }
                });
            }));
            if (localGroupStrategy != groups) {
                propertyFrames.get().forEach(p -> p.recurse(groups, sink));
            }

        void validateDescriptorConstraints(GroupStrategy groups, Consumer<ConstraintViolation<T>> sink) {
            super.validateDescriptorConstraints(groups, sink);
                        if (constraintsFor(d, groups).findFirst().isPresent()
                                .forEach(f -> f.validateDescriptorConstraints(groups, sink));
        void recurse(GroupStrategy groups, Consumer<ConstraintViolation<T>> sink) {
            if (context.getValue() == null || !DescriptorManager.isCascaded(descriptor)) {
                return;
            final Map<Group, GroupStrategy> conversions =
                descriptor.getGroupConversions().stream().collect(Collectors.toMap(gc -> Group.of(gc.getFrom()),
                    gc -> validatorContext.getGroupsComputer().computeGroups(gc.getTo()).asStrategy()));

            GroupStrategy.redefining(groups, conversions).applyTo(noViolations(gs -> cascade(gs, sink)));
        private void cascade(GroupStrategy groups, Consumer<ConstraintViolation<T>> sink) {
            descriptor.getConstrainedContainerElementTypes().stream()
                .filter(d -> d.isCascaded() || !d.getConstrainedContainerElementTypes().isEmpty())
                .flatMap(d -> ComposedD.unwrap(d, ContainerElementTypeD.class)).forEach(d -> {
                    final ValueExtractor<?> runtimeTypeValueExtractor =
                        context.getValidatorContext().getValueExtractors().find(context.runtimeKey(d.getKey()));
                    ExtractValues.extract(context, d.getKey(), runtimeTypeValueExtractor).stream()
                        .filter(e -> !e.isRecursive()).map(e -> new ContainerElementCascadeFrame(this, d, e))
                        .forEach(f -> f.recurse(groups, sink));
                });
                .map(context -> new BeanFrame<>(this, context)).forEach(b -> b.process(groups, sink));

        void recurse(GroupStrategy groups, Consumer<ConstraintViolation<T>> sink) {
        void validateDescriptorConstraints(GroupStrategy groups, Consumer<ConstraintViolation<T>> sink) {
            Validate.validState(ancestor != null, "Expected parent context");


                    Validate.validState(ancestor != null, "Expected parent context");
        void validateDescriptorConstraints(GroupStrategy groups, Consumer<ConstraintViolation<T>> sink) {
        void recurse(GroupStrategy groups, Consumer<ConstraintViolation<T>> sink) {
    private static Stream<ConstraintD<?>> constraintsFor(ElementD<?, ?> descriptor, GroupStrategy groups) {
                return groups.getGroups().stream().map(Group::getGroup).anyMatch(g -> constraintGroups.contains(g)
                    || constraintGroups.contains(Default.class) && c.getDeclaringClass().equals(g));
    protected final Groups groups;
    private ConcurrentMap<ConstraintD<?>, ConcurrentMap<Path, Set<Object>>> completedValidations;
            completedValidations = new ConcurrentHashMap<>();
                baseFrame.process(groups.asStrategy(), sink);
                completedValidations = null;
    protected <U> Predicate<U> noViolations(Consumer<? super U> consumer) {
        return u -> {
            final int originalCount = violationCount();
            consumer.accept(u);
            return violationCount() == originalCount;
        };
    }

    private int violationCount() {
        final Optional<Set<ConstraintViolation<T>>> maybeResults = results.optional();
        return maybeResults.isPresent() ? maybeResults.get().size() : 0;
    }

