        return getDeclaredConstraints(meta.getHost());
        if (declaredAnnotations.length == 0) {
            return declaredAnnotations;
        }
        Stream<Annotation> constraints = Stream.of(declaredAnnotations)
                .filter(a -> a.annotationType().isAnnotationPresent(Constraint.class));
        if (!repeated.isEmpty()) {
            constraints = constraints.peek(c -> Exceptions.raiseIf(
                Optional.of(c.annotationType()).map(t -> t.getAnnotation(Repeatable.class)).map(Repeatable::value)
                    .filter(repeated::containsKey).isPresent(),
                ConstraintDeclarationException::new,
                "Simultaneous declaration of repeatable constraint and associated container on %s", e));
            constraints = Stream.concat(constraints, repeated.values().stream().flatMap(Stream::of));
        }
        return constraints.toArray(Annotation[]::new);
        if (VALIDATED_CONSTRAINT_TYPES.contains(type)) {
            return;
        Exceptions.raiseUnless(type.isAnnotationPresent(Constraint.class), ConstraintDefinitionException::new,
            "%s is not a validation constraint", type);

        final Set<ValidationTarget> supportedTargets = supportedTargets(type);

        final Map<String, Method> attributes =
            Stream.of(Reflection.getDeclaredMethods(type)).filter(m -> m.getParameterCount() == 0)
                .collect(Collectors.toMap(Method::getName, Function.identity()));

        if (supportedTargets.size() > 1
            && !attributes.containsKey(ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getAttributeName())) {
            Exceptions.raise(ConstraintDefinitionException::new,
                "Constraint %s is both generic and cross-parameter but lacks %s attribute", type.getName(),
                ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO);
        }
        for (ConstraintAnnotationAttributes attr : CONSTRAINT_ATTRIBUTES) {
            if (attributes.containsKey(attr.getAttributeName())) {
                Exceptions.raiseUnless(attr.analyze(type).isValid(), ConstraintDefinitionException::new,
                    "%s declared invalid type for attribute %s", type, attr);

                if (!attr.isValidDefaultValue(attributes.get(attr.getAttributeName()).getDefaultValue())) {
                    Exceptions.raise(ConstraintDefinitionException::new,
                        "%s declares invalid default value for attribute %s", type, attr);
                }
                if (attr == ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO) {
                    if (supportedTargets.size() == 1) {
                        Exceptions.raise(ConstraintDefinitionException::new,
                            "Pure %s constraint %s should not declare attribute %s",
                            supportedTargets.iterator().next(), type, attr);
                    }
                }
            } else if (attr.isMandatory()) {
                Exceptions.raise(ConstraintDefinitionException::new, "%s does not declare mandatory attribute %s",
                    type, attr);
            }
            attributes.remove(attr.getAttributeName());
        }
        attributes.keySet().forEach(k -> Exceptions.raiseIf(k.startsWith("valid"),
            ConstraintDefinitionException::new, "Invalid constraint attribute %s", k));

        VALIDATED_CONSTRAINT_TYPES.add(type);
