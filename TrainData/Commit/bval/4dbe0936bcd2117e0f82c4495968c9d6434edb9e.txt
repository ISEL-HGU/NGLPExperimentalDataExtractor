import java.lang.reflect.TypeVariable;
import java.util.Collection;
import java.util.HashSet;
import javax.validation.metadata.ValidateUnwrappedValue;
import org.apache.bval.util.ObjectUtils;
    public static class UnwrappingInfo {
        public final ContainerElementKey containerElementKey;
        public final ValueExtractor<?> valueExtractor;

        private UnwrappingInfo(ContainerElementKey containerElementKey, ValueExtractor<?> valueExtractor) {
            super();
            this.containerElementKey = containerElementKey;
            this.valueExtractor = valueExtractor;
        }
    }

    private static <T> Optional<T> maximallySpecific(Collection<T> candidates, Function<? super T, Class<?>> toType) {
        final Collection<T> result;
        if (candidates.size() > 1) {
            result = new HashSet<>();
            for (T candidate : candidates) {
                final Class<?> candidateType = toType.apply(candidate);
                if (candidates.stream().filter(Predicate.isEqual(candidate).negate()).map(toType)
                    .allMatch(t -> t.isAssignableFrom(candidateType))) {
                    result.add(candidate);
                }
            }
        } else {
            result = candidates;
        }
        return result.size() == 1 ? Optional.of(result.iterator().next()) : Optional.empty();
    private final Lazy<Set<ValueExtractors>> children = new Lazy<>(HashSet::new);
    private final Lazy<Map<ContainerElementKey, ValueExtractor<?>>> searchCache = new Lazy<>(HashMap::new);
        final ValueExtractors child = new ValueExtractors(this, onDuplicateContainerElementKey);
        children.get().add(child);
        return child;
        children.optional().ifPresent(s -> s.stream().forEach(ValueExtractors::clearCache));
        final Optional<ValueExtractor<?>> cacheHit = searchCache.optional().map(m -> m.get(key));
        if (cacheHit.isPresent()) {
            return cacheHit.get();
        }
        final Map<ValueExtractor<?>, ContainerElementKey> candidates = Stream
            .concat(Stream.of(key), key.getAssignableKeys().stream()).filter(allValueExtractors::containsKey).collect(
                Collectors.toMap(allValueExtractors::get, Function.identity(), (quid, quo) -> quo, LinkedHashMap::new));
        final Optional<ValueExtractor<?>> result =
            maximallySpecific(candidates.keySet(), ve -> candidates.get(ve).getContainerClass());
        if (result.isPresent()) {
            searchCache.get().put(key, result.get());
            return result.get();
        throw Exceptions.create(ConstraintDeclarationException::new, "Could not determine %s for %s",
            ValueExtractor.class.getSimpleName(), key);
    }
    public Optional<UnwrappingInfo> findUnwrappingInfo(Class<?> containerClass,
        ValidateUnwrappedValue valueUnwrapping) {
        if (valueUnwrapping == ValidateUnwrappedValue.SKIP) {
            return Optional.empty();
        final Map<ContainerElementKey, ValueExtractor<?>> allValueExtractors = getValueExtractors();

        final Set<UnwrappingInfo> unwrapping = allValueExtractors.entrySet().stream()
            .filter(e -> e.getKey().getContainerClass().isAssignableFrom(containerClass))
            .map(e -> new UnwrappingInfo(e.getKey(), e.getValue())).collect(Collectors.toSet());

        final Optional<UnwrappingInfo> result =
            maximallySpecific(unwrapping, u -> u.containerElementKey.getContainerClass());

        if (result.isPresent()) {
            if (valueUnwrapping == ValidateUnwrappedValue.UNWRAP || isUnwrapByDefault(result.get().valueExtractor)) {
                return result
                    .map(u -> new UnwrappingInfo(translateTo(containerClass, u.containerElementKey), u.valueExtractor));
            }
        } else if (valueUnwrapping == ValidateUnwrappedValue.UNWRAP) {
            Exceptions.raise(ConstraintDeclarationException::new, "Could not determine %s for %s",
                ValueExtractor.class.getSimpleName(), containerClass);
        }
        return Optional.empty();
    }

    private static ContainerElementKey translateTo(Class<?> containerClass, ContainerElementKey key) {
        final Class<?> keyContainer = key.getContainerClass();
        if (keyContainer.equals(containerClass)) {
            return key;
        }
        Validate.validState(keyContainer.isAssignableFrom(containerClass), "Cannot render %s in terms of %s", key,
            containerClass);
        if (key.getTypeArgumentIndex() == null) {
            return new ContainerElementKey(containerClass, null);
        }
        Integer typeArgumentIndex = null;
        final Map<TypeVariable<?>, Type> typeArguments = TypeUtils.getTypeArguments(containerClass, keyContainer);
        Type t = typeArguments.get(keyContainer.getTypeParameters()[key.getTypeArgumentIndex().intValue()]);
        while (t instanceof TypeVariable<?>) {
            final TypeVariable<?> var = (TypeVariable<?>) t;
            if (containerClass.equals(var.getGenericDeclaration())) {
                typeArgumentIndex = Integer.valueOf(ObjectUtils.indexOf(containerClass.getTypeParameters(), var));
                break;
            }
            t = typeArguments.get(t);
        }
        return new ContainerElementKey(containerClass, typeArgumentIndex);

    private void clearCache() {
        searchCache.optional().ifPresent(Map::clear);
    }
