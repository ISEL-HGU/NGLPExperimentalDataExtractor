import javax.validation.ConstraintDeclarationException;
import javax.validation.ConstraintTarget;
import org.apache.bval.util.Exceptions;
                    return getConstraints(ConstraintTarget.RETURN_VALUE);
                    return getConstraints(ConstraintTarget.PARAMETERS);
        private Annotation[] getConstraints(ConstraintTarget constraintTarget) {
            return Optional.of(getConstraintsByTarget()).map(m -> m.get(constraintTarget))
        private Map<ConstraintTarget, List<Annotation>> getConstraintsByTarget() {
            final Map<ConstraintTarget, List<Annotation>> result = new EnumMap<>(ConstraintTarget.class);
                final Optional<ConstraintTarget> explicitTarget =
                        .filter(ConstraintAnnotationAttributes.Worker::isValid)
                        .<ConstraintTarget> map(w -> w.read(constraint)).filter(et -> et != ConstraintTarget.IMPLICIT);
                final ConstraintTarget target;

                if (explicitTarget.isPresent()) {
                    target = explicitTarget.get();
                } else {
                            validatorFactory.getAnnotationsManager().supportedTargets(constraintType);
                    if (supportedTargets.size() == 1) {
                        final ValidationTarget validationTarget = supportedTargets.iterator().next();
                        switch (validationTarget) {
                        case PARAMETERS:
                            target = ConstraintTarget.PARAMETERS;
                            break;
                        case ANNOTATED_ELEMENT:
                            target = ConstraintTarget.RETURN_VALUE;
                            break;
                        default:
                            throw Exceptions.create(IllegalStateException::new, "Unknown %s %s for %s",
                                ValidationTarget.class.getSimpleName(), validationTarget, constraintType);
                        }
                    } else {
                        target = impliedConstraintTarget();
                        Exceptions.raiseIf(target == null, ConstraintDeclarationException::new,
                            "Found %d possible %s types for constraint type %s and no explicit assignment via #%s()",
                            supportedTargets.size(), ValidationTarget.class.getSimpleName(), constraintType.getName(),
                            ConstraintAnnotationAttributes.VALIDATION_APPLIES_TO.getAttributeName());
                    }
                }

        private ConstraintTarget impliedConstraintTarget() {
            if (meta.getHost().getParameterCount() == 0) {
                return ConstraintTarget.RETURN_VALUE;
            }
            if (Void.TYPE.equals(meta.getType())) {
                return ConstraintTarget.PARAMETERS;
            }
            return null;
        }
