import java.lang.reflect.WildcardType;
import java.util.function.Function;
import java.util.function.Predicate;
import javax.validation.ConstraintDeclarationException;
import javax.validation.valueextraction.UnwrapByDefault;
import org.apache.bval.util.reflection.Reflection.Interfaces;
        
        if (result instanceof WildcardType && key.getTypeArgumentIndex() != null) {
            result = TypeUtils.getTypeArguments(target, key.getContainerClass())
                .get(key.getContainerClass().getTypeParameters()[key.getTypeArgumentIndex().intValue()]);
    public static boolean isUnwrapByDefault(ValueExtractor<?> valueExtractor) {
        if (valueExtractor != null) {
            for (Class<?> t : Reflection.hierarchy(valueExtractor.getClass(), Interfaces.INCLUDE)) {
                if (t.isAnnotationPresent(UnwrapByDefault.class)) {
                    return true;
                }
            }
        }
        return false;
    }

    private static boolean related(Class<?> c1, Class<?> c2) {
        return c1.isAssignableFrom(c2) || c2.isAssignableFrom(c1);
    }

        final Set<ContainerElementKey> assignableKeys = key.getAssignableKeys();
        if (assignableKeys.isEmpty()) {
            return null;
        final Map<ContainerElementKey, ValueExtractor<?>> candidateMap =
            assignableKeys.stream().filter(allValueExtractors::containsKey)
                .collect(Collectors.toMap(Function.identity(), allValueExtractors::get));

        if (candidateMap.isEmpty()) {
            return null;
        }
        if (candidateMap.size() > 1) {
            final Set<Class<?>> containerTypes =
                candidateMap.keySet().stream().map(ContainerElementKey::getContainerClass).collect(Collectors.toSet());

            final boolean allRelated = containerTypes.stream().allMatch(quid -> containerTypes.stream()
                .filter(Predicate.isEqual(quid).negate()).allMatch(quo -> related(quid, quo)));

            Exceptions.raiseUnless(allRelated, ConstraintDeclarationException::new,
                "> 1 maximally specific %s found for %s", ValueExtractor.class.getSimpleName(), key);
        }
        return candidateMap.values().iterator().next();
    private void populate(Supplier<Map<ContainerElementKey, ValueExtractor<?>>> target) {
