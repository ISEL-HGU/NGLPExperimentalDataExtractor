        if (hasWork()) {
            final Frame<?> baseFrame = computeBaseFrame();
            Validate.validState(baseFrame != null, "%s computed null baseFrame", getClass().getName());
            final Consumer<ConstraintViolation<T>> sink = results.consumer(Set::add);
            validatedPathsByConstraint = new ConcurrentHashMap<>();
            try {
                groups.getGroups().stream().map(Group::getGroup).forEach(g -> baseFrame.process(g, sink));
                sequences: for (List<Group> seq : groups.getSequences()) {
                    final boolean proceed = each(seq.stream().map(Group::getGroup), baseFrame::process, sink);
                    if (!proceed) {
                        break sequences;
                    }
            } finally {
                validatedPathsByConstraint = null;
            if (results.optional().isPresent()) {
                return Collections.unmodifiableSet(results.get());
            }
        return results.reset(Collections::emptySet).get();
    protected boolean hasWork() {
        return true;
    }

