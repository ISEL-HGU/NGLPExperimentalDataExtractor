import java.lang.reflect.Executable;
import java.util.List;
import java.util.Optional;
import java.util.function.BiPredicate;
import org.apache.bval.jsr.descriptor.DescriptorManager;
import org.apache.bval.jsr.metadata.Signature;
import org.apache.bval.jsr.util.ExecutableTypes;
import org.apache.bval.util.reflection.TypeUtils;
    private transient volatile Map<Signature, Boolean> executableValidation;
    @SuppressWarnings({ "unchecked", "rawtypes" })
        final Constructor ctor = context.getConstructor();
        if (!isConstructorValidated(ctor)) {
        final ConstructorDescriptor constraints = validator.getConstraintsForClass(ctor.getDeclaringClass())
            .getConstraintsForConstructor(ctor.getParameterTypes());
        if (!DescriptorManager.isConstrained(constraints)) {
        if (constraints.hasConstrainedParameters()) {
                executableValidator.validateConstructorParameters(ctor, context.getParameters());
        if (constraints.hasConstrainedReturnValue()) {
                executableValidator.validateConstructorReturnValue(ctor, context.getTarget());

        if (!isExecutableValidated(targetClass, method, this::computeIsMethodValidated)) {

        if (!DescriptorManager.isConstrained(constraintsForMethod)) {
        if (constraintsForMethod.hasConstrainedParameters()) {
        if (constraintsForMethod.hasConstrainedReturnValue()) {
    private <T> boolean isConstructorValidated(final Constructor<T> constructor)
        {
        return isExecutableValidated(constructor.getDeclaringClass(), constructor, this::computeIsConstructorValidated);
    private <T, E extends Executable> boolean isExecutableValidated(final Class<T> targetClass, final E executable,
        BiPredicate<? super Class<T>, ? super E> compute) {
        if (executableValidation == null) {
                if (executableValidation == null) {
                    executableValidation = new ConcurrentHashMap<>();
        return executableValidation.computeIfAbsent(Signature.of(executable),
            s -> compute.test(targetClass, executable));
                    final ValidateOnExecution annotation = CDI.current().getBeanManager()
                        .createAnnotatedType(targetClass).getAnnotation(ValidateOnExecution.class);
                        classConfiguration = globalConfiguration.getGlobalExecutableTypes();
                        classConfiguration = ExecutableTypes.interpret(annotation.type());
    private <T> boolean computeIsConstructorValidated(Class<T> targetClass, Constructor<T> ctor) {
        final AnnotatedType<T> annotatedType =
            CDI.current().getBeanManager().createAnnotatedType(ctor.getDeclaringClass());

        final ValidateOnExecution annotation =
            annotatedType.getConstructors().stream().filter(ac -> ctor.equals(ac.getJavaMember())).findFirst()
                .map(ac -> ac.getAnnotation(ValidateOnExecution.class))
                .orElseGet(() -> ctor.getAnnotation(ValidateOnExecution.class));

        final Set<ExecutableType> validatedExecutableTypes =
            annotation == null ? classConfiguration : ExecutableTypes.interpret(annotation.type());

        return validatedExecutableTypes.contains(ExecutableType.CONSTRUCTORS);
    }

    private <T> boolean computeIsMethodValidated(Class<T> targetClass, Method method) {
        Collection<ExecutableType> declaredExecutableTypes = null;

        for (final Class<?> c : Reflection.hierarchy(targetClass, Interfaces.INCLUDE)) {
            final AnnotatedType<?> annotatedType = CDI.current().getBeanManager().createAnnotatedType(c);

            final AnnotatedMethod<?> annotatedMethod = annotatedType.getMethods().stream()
                .filter(am -> Signature.of(am.getJavaMember()).equals(Signature.of(method))).findFirst().orElse(null);

            if (annotatedMethod == null) {
                continue;
            }
            if (annotatedMethod.isAnnotationPresent(ValidateOnExecution.class)) {
                final List<ExecutableType> validatedTypesOnMethod =
                    Arrays.asList(annotatedMethod.getAnnotation(ValidateOnExecution.class).type());

                // implicit directly on method -> early return:
                if (validatedTypesOnMethod.contains(ExecutableType.IMPLICIT)) {
                    return true;
                }
                declaredExecutableTypes = validatedTypesOnMethod;
                // ignore the hierarchy once the lowest method is found:
                break;
            }
            if (declaredExecutableTypes == null) {
                if (annotatedType.isAnnotationPresent(ValidateOnExecution.class)) {
                    declaredExecutableTypes =
                        Arrays.asList(annotatedType.getAnnotation(ValidateOnExecution.class).type());
                } else {
                    final Optional<Package> pkg = Optional.of(annotatedType).map(AnnotatedType::getBaseType)
                        .map(t -> TypeUtils.getRawType(t, null)).map(Class::getPackage)
                        .filter(p -> p.isAnnotationPresent(ValidateOnExecution.class));
                    if (pkg.isPresent()) {
                        declaredExecutableTypes =
                            Arrays.asList(pkg.get().getAnnotation(ValidateOnExecution.class).type());
                    }
                }
            }
        }
        final ExecutableType methodType =
            Methods.isGetter(method) ? ExecutableType.GETTER_METHODS : ExecutableType.NON_GETTER_METHODS;

        return Optional.ofNullable(declaredExecutableTypes).map(ExecutableTypes::interpret)
            .orElse(globalConfiguration.getGlobalExecutableTypes()).contains(methodType);
    }

