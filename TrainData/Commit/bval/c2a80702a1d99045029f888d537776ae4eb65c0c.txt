import java.lang.reflect.InvocationTargetException;
import java.util.Optional;

import javax.validation.MessageInterpolator;

import org.apache.bval.el.MessageEvaluator;
import org.apache.bval.jsr.util.LookBehindRegexHolder;
import org.apache.bval.util.reflection.Reflection;
import org.apache.commons.weaver.privilizer.Privilizing;
import org.apache.commons.weaver.privilizer.Privilizing.CallTo;
    /**
     * {@link LookBehindRegexHolder} to match Bean Validation attribute patterns, considering character escaping.
     */
    private static final LookBehindRegexHolder MESSAGE_PARAMETER = new LookBehindRegexHolder(
        "(?<!(?:^|[^\\\\])(?:\\\\\\\\){0,%1$d}\\\\)\\{((?:[\\w\\.]|\\\\[\\{\\$\\}\\\\]))\\}", n -> (n - 4) / 2);
        return resolveEscapeSequences(resolvedMessage);
    }
    private String resolveEscapeSequences(String s) {
        int pos = s.indexOf('\\');
        if (pos < 0) {
            return s;
        }
        StringBuilder result = new StringBuilder(s.length());
 
        int prev = 0;
        do {
            if (pos  1 >= s.length()) {
                break;
            }
            if ("\\{}$".indexOf(s.charAt(pos  1)) >= 0) {
                result.append(s, prev, pos);
                prev = pos  1;
            }
            pos = s.indexOf('\\', pos  2);
        } while (pos > 0);

        if (prev < s.length()) {
            result.append(s, prev, s.length());
        }
        return result.toString();
        if (classLoader == null) {
            // 2011-03-27 jw: No privileged action required.
            // A class can always access the classloader of itself and of subclasses.
            USER_VALIDATION_MESSAGES  " not found by validator classloader");
        } else {
            rb = loadBundle(classLoader, locale, USER_VALIDATION_MESSAGES  " not found by thread local classloader");
            return null;
        final Matcher matcher = MESSAGE_PARAMETER.matcher(message);
        final StringBuilder sb = new StringBuilder(64);
        int prev = 0;
            int start = matcher.start();
            if (start > prev) {
                sb.append(message, prev, start);
            }
            sb.append(resolveParameter(matcher.group(1), bundle, locale, recurse).orElseGet(matcher::group));
            prev = matcher.end();
        if (prev < message.length()) {
            sb.append(message, prev, message.length());
        }
        final Matcher matcher = MESSAGE_PARAMETER.matcher(message);
        final StringBuilder sb = new StringBuilder(64);
        int prev = 0;
            int start = matcher.start();
            Object variable = annotationParameters.get(parameter);
            if (variable == null) {
                resolvedParameterValue = matcher.group();
            } else if (Object[].class.isInstance(variable)) {
                resolvedParameterValue = Arrays.toString((Object[]) variable);
            } else if (variable.getClass().isArray()) {
                try {
                    resolvedParameterValue = (String) Reflection
                        .getDeclaredMethod(Arrays.class, "toString", variable.getClass()).invoke(null, variable);
                } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
                    throw new IllegalStateException("Could not expand array "  variable);
                resolvedParameterValue = variable.toString();
            if (start > prev) {
                sb.append(message, prev, start);
            }
            sb.append(resolvedParameterValue);
            prev = matcher.end();
        if (prev < message.length()) {
            sb.append(message, prev, message.length());
        }
    private Optional<String> resolveParameter(String parameterName, ResourceBundle bundle, Locale locale,
        boolean recurse) {
        return Optional.ofNullable(bundle).map(b -> {
            try {
                return b.getString(parameterName);
            } catch (final MissingResourceException e) {
                return null;
        }).map(v -> recurse ? replaceVariables(v, bundle, locale, recurse) : v);
        return defaultBundlesMap.computeIfAbsent(locale,
            k -> ResourceBundle.getBundle(DEFAULT_VALIDATION_MESSAGES, locale));
        return userBundlesMap.computeIfAbsent(locale, this::getFileBasedResourceBundle);
