import java.util.ArrayDeque;
import java.util.Collections;
import java.util.Deque;
import org.apache.ivy.core.module.descriptor.DefaultArtifact;
    private Set<Caller> getCallersByMrid(String rootModuleConf, ModuleRevisionId mrid) {
        Map<ModuleRevisionId, Caller> callers = callersByRootConf.get(rootModuleConf);
        if (callers == null) {
            return Collections.emptySet();
        }

        Set<Caller> mridCallers = new HashSet<>();
        for (Caller caller : callers.values()) {
            if (caller.getAskedDependencyId().equals(mrid)) {
                mridCallers.add(caller);
            }
        }
        return mridCallers;
    }

        return doesCallersExclude(rootModuleConf, artifact, new ArrayDeque<IvyNode>());
            Deque<IvyNode> callersStack) {
        /* The caller stack is, from bottom to top, the path from the
           artifact we're considering excluding up towards the
           root. */
        callersStack.push(node);
            Set<Caller> callers = getCallersByMrid(rootModuleConf, node.getId());
            if (callers.isEmpty()) {
            String[] moduleConfs = new String[] {rootModuleConf};
            callers: for (Caller caller : callers) {
                /* Each ancestor of this artifact (called "descendant", here, since it's
                   a descendant relative to this.node) might itself have been excluded by
                   an older ancestor (this.node); if it is, then it is as if artifact
                   itself were excluded in this path. */
                for (IvyNode descendant : callersStack) {
                    if (node.directlyExcludes(node.getDescriptor(), moduleConfs,
                            caller.getDependencyDescriptor(),
                            DefaultArtifact.newIvyArtifact(descendant.getId(), null))) {
                        allInconclusive = false;
                        continue callers;
                    }
                }
