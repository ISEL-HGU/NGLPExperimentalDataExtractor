import java.util.HashSet;
import java.util.Set;
    private final Map<ModuleRevisionId, List<IvyNode>> dependencies = new HashMap<>();
        if (report == null) {
            throw new BuildException("No resolution report was available to run the post-resolve task. Make sure resolve was done before this task");
        }
        for (IvyNode dependency : report.getDependencies()) {
            populateDependencyTree(dependency);
        final List<IvyNode> dependencyList = dependencies.get(mrid);
            printDependencies(mrid, dependencyList, 0, new HashSet<ModuleRevisionId>());
    private void printDependencies(final ModuleRevisionId mrid, final List<IvyNode> dependencyList, final int indent,
                                   final Set<ModuleRevisionId> ancestors) {
        for (final Iterator iterator = dependencyList.iterator(); iterator.hasNext();) {
            final Set<ModuleRevisionId> ancestorsForCurrentDep = new HashSet<>(ancestors);
            // previous ancestors plus the module to whom these dependencies belong to
            ancestorsForCurrentDep.add(mrid);
            final IvyNode dependency = (IvyNode) iterator.next();
            final boolean evicted = dependency.isEvicted(getConf());
            final StringBuilder sb = new StringBuilder();
            final ModuleRevisionId dependencyMrid = dependency.getId();
            final boolean circular = ancestorsForCurrentDep.contains(dependencyMrid);
            if (!evicted && circular) {
                // log and skip processing the (transitive) dependencies of this dependency
                sb.append("(circularly depends on) ").append(dependencyMrid);
                log(sb.toString());
                continue;
            } else {
                sb.append(dependencyMrid.toString());
            }
            printDependencies(dependencyMrid, dependencies.get(dependencyMrid), indent  1, ancestorsForCurrentDep);
    private boolean hasDependencies(final IvyNode module) {
        if (module == null) {
            return false;
        }
        final List<IvyNode> dependenciesForModule = dependencies.get(module.getId());
        return dependenciesForModule != null && !dependenciesForModule.isEmpty();
    private void populateDependencyTree(IvyNode dependency) {
    private void registerNodeIfNecessary(final ModuleRevisionId moduleRevisionId) {
            dependencies.put(moduleRevisionId, new ArrayList<IvyNode>());
    private void addDependency(final ModuleRevisionId moduleRevisionId, final IvyNode dependency) {
        final List<IvyNode> dependencyList = dependencies.get(moduleRevisionId);
        dependencyList.add(dependency);
