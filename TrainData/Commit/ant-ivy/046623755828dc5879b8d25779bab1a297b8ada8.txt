import java.io.BufferedInputStream;
import java.io.File;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;

     * @param val  String
        final String val = getFirstChildText(projectElement, PACKAGING);
            return "jar";
        return replaceProps(val);
                getFirstChildElement(parent, DEPENDENCY_MGT), DEPENDENCIES);
    private static Map<String, String> getProperties(final Element parent) {
        final Element propsEl = getFirstChildElement(parent, PROPERTIES);
        if (propsEl == null) {
            return Collections.emptyMap();
        }
        propsEl.normalize();
        final Map<String, String> props = new HashMap<>();
        for (final Element prop : getAllChilds(propsEl)) {
            props.put(prop.getNodeName(), getTextContent(prop));
        }
        return props;
    }

        private static final String OS = "os";
        private static final String FAMILY = "family";
        private static final String VERSION = "version";
        private static final String ARCH = "arch";

        private static final String FILE = "file";
        private static final String MISSING = "missing";
        private static final String EXISTS = "exists";

        private static final String JDK = "jdk";

            return isActiveByDefault() || isActivatedByProperty()
                    || isActiveByOS() || isActiveByJDK() || isActiveByFile();
        public boolean isActiveByOS() {
            final Element activation = getFirstChildElement(profileElement, ACTIVATION_ELEMENT);
            if (activation == null) {
                return false;
            }
            final Element osActivation = getFirstChildElement(activation, OS);
            if (osActivation == null) {
                return false;
            }
            final String actualOS = System.getProperty("os.name");
            final String expectedOSName = getFirstChildText(osActivation, NAME);
            if (expectedOSName != null && !actualOS.equals(expectedOSName.trim())) {
                // os name is specified but doesn't match
                return false;
            }
            final String expectedOSFamily = getFirstChildText(osActivation, FAMILY);
            if (expectedOSFamily != null && !actualOS.contains(expectedOSFamily.trim())) {
                // os family is specified but doesn't match
                return false;
            }
            final String expectedOSArch = getFirstChildText(osActivation, ARCH);
            if (expectedOSArch != null && !System.getProperty("os.arch").equals(expectedOSArch.trim())) {
                // os arch is specified but doesn't match
                return false;
            }
            final String expectedOSVersion = getFirstChildText(osActivation, VERSION);
            if (expectedOSVersion != null && !System.getProperty("os.version").equals(expectedOSVersion.trim())) {
                // os version is specified but doesn't match
                return false;
            }
            // reaching here implies that either no OS match rules were specified or
            // all of the OS rules that were specified were matched. So we just check to see
            // if any rules were specified at all, in which case, we consider the profile to be activated
            // by the OS element
            return (expectedOSName != null || expectedOSFamily != null || expectedOSArch != null || expectedOSVersion != null);
        }

        public boolean isActiveByJDK() {
            final Element activation = getFirstChildElement(profileElement, ACTIVATION_ELEMENT);
            if (activation == null) {
                return false;
            }
            final String expectedJDKRange = getFirstChildText(activation, JDK);
            if (expectedJDKRange == null) {
                return false;
            }
            final boolean negate = expectedJDKRange.trim().startsWith("!");
            final String nonNegatedRange = negate ? expectedJDKRange.substring(1).trim() : expectedJDKRange.trim();
            final boolean javaVersionInRange = MavenVersionRangeParser.currentJavaVersionInRange(nonNegatedRange);
            return javaVersionInRange ^ negate;
        }

        public boolean isActiveByFile() {
            final Element activation = getFirstChildElement(profileElement, ACTIVATION_ELEMENT);
            if (activation == null) {
                return false;
            }
            final Element fileActivation = getFirstChildElement(activation, FILE);
            if (fileActivation == null) {
                return false;
            }
            final String expectedMissing = getFirstChildText(fileActivation, MISSING);
            if (expectedMissing != null && new File(expectedMissing.trim()).exists()) {
                // the file was specified and expected to be missing, but it exists
                return false;
            }
            final String expectedExists = getFirstChildText(fileActivation, EXISTS);
            if (expectedExists != null && !(new File(expectedExists.trim()).exists())) {
                // the file was specified and expected to be existing, but it doesn't
                return false;
            }
            // reaching here implies that either no file match rules were specified or
            // all of the file rules that were specified were matched. So we just check to see
            // if any rules were specified at all, in which case, we consider the profile to be activated
            // by the file element
            return (expectedMissing != null || expectedExists != null);
        }

            final boolean matched;
                matched = PomReader.this.properties.containsKey(propertyName);
                matched = propertyValue.equals(PomReader.this.properties.get(propertyName));
        public Map<String, String> getProfileProperties() {
            return PomReader.getProperties(profileElement);
        }
        return new HashMap<>(getProperties(projectElement));
