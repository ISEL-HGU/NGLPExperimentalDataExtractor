 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
        Pattern.compile(".*Generated By:JJTree:.*"),
        Pattern.compile(".*Generated By:JavaCC:.*"),
package org.apache.rat;
package org.apache.rat;
package org.apache.rat;
package org.apache.rat;
package org.apache.rat;
package org.apache.rat;
package org.apache.rat.analysis;
package org.apache.rat.analysis;
package org.apache.rat.analysis;
package org.apache.rat.analysis.generation;
package org.apache.rat.analysis.generation;
package org.apache.rat.analysis.license;
package org.apache.rat.analysis.license;
package org.apache.rat.analysis.license;
package org.apache.rat.analysis.license;
package org.apache.rat.analysis.license;
package org.apache.rat.analysis.license;
package org.apache.rat.analysis.license;
package org.apache.rat.analysis.util;
package org.apache.rat.anttasks;
package org.apache.rat.anttasks;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document.impl;
package org.apache.rat.document.impl;
package org.apache.rat.document.impl;
package org.apache.rat.document.impl;
package org.apache.rat.document.impl.guesser;
package org.apache.rat.document.impl.guesser;
package org.apache.rat.document.impl.guesser;
package org.apache.rat.document.impl.guesser;
package org.apache.rat.document.impl.util;
package org.apache.rat.document.impl.util;
package org.apache.rat.document.impl.util;
package org.apache.rat.document.impl.util;
package org.apache.rat.document.impl.zip;
package org.apache.rat.document.impl.zip;
package org.apache.rat.document.impl.zip;
package org.apache.rat.document.impl.zip;
package org.apache.rat.document.impl.zip;
package org.apache.rat.document.impl.zip;
package org.apache.rat.document.impl.zip;
package org.apache.rat.document.impl.zip;
package org.apache.rat.header;
package org.apache.rat.header;
package org.apache.rat.header;
package org.apache.rat.header;
package org.apache.rat.header;
package org.apache.rat.license;
package org.apache.rat.license;
package org.apache.rat.license;
package org.apache.rat.license;
package org.apache.rat.license;
package org.apache.rat.license;
package org.apache.rat.license;
package org.apache.rat.policy;
package org.apache.rat.report;
package org.apache.rat.report;
package org.apache.rat.report;
package org.apache.rat.report.analyser;
package org.apache.rat.report.analyser;
package org.apache.rat.report.analyser;
package org.apache.rat.report.analyser;
package org.apache.rat.report.analyser;
package org.apache.rat.report.analyser;
package org.apache.rat.report.analyser;
package org.apache.rat.report.claim;
package org.apache.rat.report.claim.impl.xml;
package org.apache.rat.report.claim.util;
package org.apache.rat.report.xml;
package org.apache.rat.report.xml;
package org.apache.rat.report.xml.writer;
package org.apache.rat.report.xml.writer;
package org.apache.rat.report.xml.writer;
package org.apache.rat.report.xml.writer;
package org.apache.rat.report.xml.writer.impl.base;
package org.apache.rat.analysis;
package org.apache.rat.analysis.license;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.document;
package org.apache.rat.header;
package org.apache.rat.report.claim.impl.xml;
package org.apache.rat.report.xml;
package org.apache.rat.report.xml;
package org.apache.rat.test.utils;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.generation.GeneratedLicenseNotRequired;
import org.apache.rat.analysis.generation.JavaDocLicenseNotRequired;
import org.apache.rat.analysis.license.ApacheSoftwareLicense20;
import org.apache.rat.analysis.license.DojoLicenseHeader;
import org.apache.rat.analysis.license.OASISLicense;
import org.apache.rat.analysis.license.TMF854LicenseHeader;
import org.apache.rat.analysis.license.W3CDocLicense;
import org.apache.rat.analysis.license.W3CLicense;
import org.apache.rat.analysis.util.HeaderMatcherMultiplexer;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.impl.FileDocument;
import org.apache.rat.document.impl.zip.ZipFileUnarchiver;
import org.apache.rat.report.IReportable;
import org.apache.rat.report.RatReport;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.license.ILicenseFamily;
import org.apache.rat.report.IReportable;
import org.apache.rat.report.RatReport;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.xml.XmlReportFactory;
import org.apache.rat.report.xml.writer.IXmlWriter;
import org.apache.rat.report.xml.writer.impl.base.XmlWriter;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.Claims;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.Claims;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.Claims;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.license.Apache20LicenseFamily;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.Claims;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.Claims;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.license.ModifiedBSDLicenseFamily;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.Claims;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.license.OASISLicenseFamily;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.Claims;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.license.ModifiedBSDLicenseFamily;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.Claims;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.license.W3CDocumentLicenseFamily;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.Claims;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.license.W3CSoftwareLicenseFamily;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.Defaults;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.util.HeaderMatcherMultiplexer;
import org.apache.rat.license.ILicenseFamily;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentCollection;
import org.apache.rat.document.UnreadableArchiveException;
import org.apache.rat.document.impl.DocumentImplUtils;
import org.apache.rat.document.impl.zip.ZipDocumentFactory;
import org.apache.rat.report.IReportable;
import org.apache.rat.report.RatReport;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.document.CompositeDocumentException;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentCollection;
import org.apache.rat.document.IFileUnarchiver;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentCollection;
import org.apache.rat.document.UnreadableArchiveException;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentMatcher;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentMatcher;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentMatcher;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentAnalyser;
import org.apache.rat.document.IDocumentMatcher;
import org.apache.rat.document.RatDocumentAnalysisException;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentAnalyser;
import org.apache.rat.document.RatDocumentAnalysisException;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentMatcher;
import org.apache.rat.document.RatDocumentAnalysisException;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentMatcher;
import org.apache.rat.document.RatDocumentAnalysisException;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentCollection;
import org.apache.rat.document.UnreadableArchiveException;
import org.apache.rat.document.IDocumentCollection;
import org.apache.rat.document.IDocumentCollection;
import org.apache.rat.document.IDocumentCollection;
import org.apache.rat.document.impl.CompositeDocument;
import org.apache.rat.document.IDocumentCollection;
import org.apache.rat.document.IFileUnarchiver;
import org.apache.rat.analysis.Claims;
import org.apache.rat.license.Apache20LicenseFamily;
import org.apache.rat.license.ILicenseFamily;
import org.apache.rat.license.ModifiedBSDLicenseFamily;
import org.apache.rat.license.OASISLicenseFamily;
import org.apache.rat.license.W3CDocumentLicenseFamily;
import org.apache.rat.license.W3CSoftwareLicenseFamily;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentAnalyser;
import org.apache.rat.document.RatDocumentAnalysisException;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.RatDocumentAnalysisException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.document.IDocumentAnalyser;
import org.apache.rat.document.IDocumentMatcher;
import org.apache.rat.document.impl.guesser.ArchiveGuesser;
import org.apache.rat.document.impl.guesser.BinaryGuesser;
import org.apache.rat.document.impl.guesser.NoteGuesser;
import org.apache.rat.document.impl.util.ConditionalAnalyser;
import org.apache.rat.document.impl.util.DocumentAnalyserMultiplexer;
import org.apache.rat.document.impl.util.DocumentMatcherMultiplexer;
import org.apache.rat.document.impl.util.MatchNegator;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentAnalyser;
import org.apache.rat.document.RatDocumentAnalysisException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.analysis.Claims;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.document.RatDocumentAnalysisException;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentCollection;
import org.apache.rat.document.RatDocumentAnalysisException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.report.xml.writer.IXmlWriter;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentAnalyser;
import org.apache.rat.document.RatDocumentAnalysisException;
import org.apache.rat.report.RatReport;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.xml.writer.IXmlWriter;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.document.IDocumentAnalyser;
import org.apache.rat.license.ILicenseFamily;
import org.apache.rat.policy.DefaultPolicy;
import org.apache.rat.report.RatReport;
import org.apache.rat.report.analyser.DefaultAnalyserFactory;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.report.claim.impl.xml.SimpleXmlClaimReporter;
import org.apache.rat.report.claim.util.ClaimReporterMultiplexer;
import org.apache.rat.report.xml.writer.IXmlWriter;
import org.apache.rat.report.xml.writer.IXmlWriter;
import org.apache.rat.report.xml.writer.InvalidXmlException;
import org.apache.rat.report.xml.writer.OperationNotAllowedException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.report.xml.writer.IXmlWriter;
import org.apache.rat.document.DocumentUtils;
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentCollection;
 /*
        org.apache.rat.Report.report(out, rcElement, Defaults.getDefaultStyleSheet(), m, getApprovedLicenseNames());
    public static final String PLAIN_STYLESHEET = "org/apache/rat/plain-rat.xsl";
 b/rat/rat-core/src/main/java/org/apache/rat/document/impl/AbstractMonolithicDocument.java
/**
 * Abstract base class for monolithic documents.
 */
public abstract class AbstractMonolithicDocument implements IDocument {
	private final String name;
	public AbstractMonolithicDocument(String pName) {
		name = pName;
	}

	public IDocumentCollection readArchive() throws IOException {
	public String getName() {
		return name;
	}
 b/rat/rat-core/src/main/java/org/apache/rat/document/impl/MonolithicFileDocument.java
import java.io.InputStreamReader;
import java.net.URL;
public class MonolithicFileDocument extends AbstractMonolithicDocument {
	private final File file;

    /**
     * Creates a new instance. The document is read from the
     * given URL.
     */
    public static IDocument newInstance(final URL url) {
    	if ("file".equals(url.getProtocol())) {
    		final File f = new File(url.getFile());
    		return new MonolithicFileDocument(f);
    	}
    	return new AbstractMonolithicDocument(url.toExternalForm()){
			public Reader reader() throws IOException {
				return new InputStreamReader(url.openStream(), "UTF-8");
			}
    	};
    }

    	super(DocumentImplUtils.toName(file));
 b/rat/rat-core/src/test/java/org/apache/rat/report/xml/XmlUtils.java
import java.io.StringReader;
import java.lang.reflect.UndeclaredThrowableException;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
        return isWellFormedXml(new InputSource(new StringReader(string)));
    public static final XMLReader newXMLReader() throws SAXException, ParserConfigurationException {
    	final SAXParserFactory spf = SAXParserFactory.newInstance();
    	spf.setValidating(false);
    	spf.setNamespaceAware(true);
    	return spf.newSAXParser().getXMLReader();
    }

    public static final boolean isWellFormedXml(final InputSource isource) {
    	try {
    		newXMLReader().parse(isource);
    		return true;
    	} catch (SAXException e) {
    		System.out.println(e);
    		e.printStackTrace();
    		return false;
    	} catch (IOException e) {
    		throw new UndeclaredThrowableException(e);
    	} catch (ParserConfigurationException e) {
    		throw new UndeclaredThrowableException(e);
    	}
    }
    	return isWellFormedXml(new InputSource(in));
 b/rat-core/src/main/java/org/apache/rat/document/impl/AbstractMonolithicDocument.java
/**
 * Abstract base class for monolithic documents.
 */
public abstract class AbstractMonolithicDocument implements IDocument {
	private final String name;
	public AbstractMonolithicDocument(String pName) {
		name = pName;
	}

	public IDocumentCollection readArchive() throws IOException {
	public String getName() {
		return name;
	}
 b/rat-core/src/main/java/org/apache/rat/document/impl/MonolithicFileDocument.java
import java.io.InputStreamReader;
import java.net.URL;
public class MonolithicFileDocument extends AbstractMonolithicDocument {
	private final File file;

    /**
     * Creates a new instance. The document is read from the
     * given URL.
     */
    public static IDocument newInstance(final URL url) {
    	if ("file".equals(url.getProtocol())) {
    		final File f = new File(url.getFile());
    		return new MonolithicFileDocument(f);
    	}
    	return new AbstractMonolithicDocument(url.toExternalForm()){
			public Reader reader() throws IOException {
				return new InputStreamReader(url.openStream(), "UTF-8");
			}
    	};
    }

    	super(DocumentImplUtils.toName(file));
 b/rat-core/src/test/java/org/apache/rat/report/xml/XmlUtils.java
import java.io.StringReader;
import java.lang.reflect.UndeclaredThrowableException;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
        return isWellFormedXml(new InputSource(new StringReader(string)));
    public static final XMLReader newXMLReader() throws SAXException, ParserConfigurationException {
    	final SAXParserFactory spf = SAXParserFactory.newInstance();
    	spf.setValidating(false);
    	spf.setNamespaceAware(true);
    	return spf.newSAXParser().getXMLReader();
    }

    public static final boolean isWellFormedXml(final InputSource isource) {
    	try {
    		newXMLReader().parse(isource);
    		return true;
    	} catch (SAXException e) {
    		System.out.println(e);
    		e.printStackTrace();
    		return false;
    	} catch (IOException e) {
    		throw new UndeclaredThrowableException(e);
    	} catch (ParserConfigurationException e) {
    		throw new UndeclaredThrowableException(e);
    	}
    }
    	return isWellFormedXml(new InputSource(in));
	  /**
	   * Process a directory, restricted directories will be ignored.
	   * 
	   * @param report The report to process the directory with
	   * @param file the directory to process
	   * @throws RatReportFailedException
	   */
    /**
     * Run a report over all files and directories in this DirectoryWalker,
     * ignoring any files/directories set to be ignored.
     * 
     * @param report the defined RatReport to run on this Directory walker.
     * 
     */
    /**
     * Process a directory, ignoring any files/directories set to be ignored.
     * 
     * @param report the report to use in processing
     * @param file the run the report against
     * @throws RatReportFailedException
     */
    /**
     * Process all directories in a set of file objects, ignoring any directories set to be ignored.
     * 
     * @param report the report to use in processing
     * @param files the files to process (only directories will be processed)
     * @throws RatReportFailedException
     */
    
    /**
     * Process all files in a set of file objects, ignoring any files set to be ignored.
     * 
     * @param report the report to use in processing
     * @param files the files to process (only files will be processed)
     * @throws RatReportFailedException
     */
    /**
     * Report on the given file.
     * 
     * @param report the report to process the file with
     * @param file the file to be reported on
     * @throws RatReportFailedException
     */
			report.report(System.out);
            //report.styleReport(System.out);
    /**
     * Output a report in the default style and default licence
     * header matcher. 
     * 
     * @param out - the output stream to recieve the styled report
     * @throws Exception
     */
    /**
     * Output a report that is styled using a defined stylesheet.
     * 
     * @param out the stream to write the report to
     * @param base the files or directories to report on
     * @param style an input stream representing the stylesheet to use for styling the report
     * @param matcher the header matcher for matching licence headers
     * @param approvedLicenseNames a list of licence families that are approved for use in the project
     * @throws IOException
     * @throws TransformerConfigurationException
     * @throws InterruptedException
     * @throws RatReportFailedException
     */
    /**
     * 
     * Output a report that is styled using a defined stylesheet.
     * 
     * @param out the writer to write the report to
     * @param base the files or directories to report on
     * @param style an input stream representing the stylesheet to use for styling the report
     * @param matcher the header matcher for matching licence headers
     * @param approvedLicenseNames a list of licence families that are approved for use in the project
     * @throws IOException
     * @throws TransformerConfigurationException
     * @throws FileNotFoundException
     * @throws InterruptedException
     * @throws RatReportFailedException
     */
    /**
     * 
     * @param container the files or directories to report on
     * @param out the writer to write the report to
     * @param matcher the header matcher for matching licence headers
     * @param approvedLicenseNames a list of licence families that are approved for use in the project
     * @throws IOException
     * @throws RatReportFailedException
     */
    /**
     * Report on a document. This will result in the document being passed through
     * the document analyser with descriptive elements added to the analysis report.
     * 
     * @param document the document to report on.
     */
	  /**
	   * Process a directory, restricted directories will be ignored.
	   * 
	   * @param report The report to process the directory with
	   * @param file the directory to process
	   * @throws RatReportFailedException
	   */
    /**
     * Run a report over all files and directories in this DirectoryWalker,
     * ignoring any files/directories set to be ignored.
     * 
     * @param report the defined RatReport to run on this Directory walker.
     * 
     */
    /**
     * Process a directory, ignoring any files/directories set to be ignored.
     * 
     * @param report the report to use in processing
     * @param file the run the report against
     * @throws RatReportFailedException
     */
    /**
     * Process all directories in a set of file objects, ignoring any directories set to be ignored.
     * 
     * @param report the report to use in processing
     * @param files the files to process (only directories will be processed)
     * @throws RatReportFailedException
     */
    
    /**
     * Process all files in a set of file objects, ignoring any files set to be ignored.
     * 
     * @param report the report to use in processing
     * @param files the files to process (only files will be processed)
     * @throws RatReportFailedException
     */
    /**
     * Report on the given file.
     * 
     * @param report the report to process the file with
     * @param file the file to be reported on
     * @throws RatReportFailedException
     */
			report.report(System.out);
            //report.styleReport(System.out);
    /**
     * Output a report in the default style and default licence
     * header matcher. 
     * 
     * @param out - the output stream to recieve the styled report
     * @throws Exception
     */
    /**
     * Output a report that is styled using a defined stylesheet.
     * 
     * @param out the stream to write the report to
     * @param base the files or directories to report on
     * @param style an input stream representing the stylesheet to use for styling the report
     * @param matcher the header matcher for matching licence headers
     * @param approvedLicenseNames a list of licence families that are approved for use in the project
     * @throws IOException
     * @throws TransformerConfigurationException
     * @throws InterruptedException
     * @throws RatReportFailedException
     */
    /**
     * 
     * Output a report that is styled using a defined stylesheet.
     * 
     * @param out the writer to write the report to
     * @param base the files or directories to report on
     * @param style an input stream representing the stylesheet to use for styling the report
     * @param matcher the header matcher for matching licence headers
     * @param approvedLicenseNames a list of licence families that are approved for use in the project
     * @throws IOException
     * @throws TransformerConfigurationException
     * @throws FileNotFoundException
     * @throws InterruptedException
     * @throws RatReportFailedException
     */
    /**
     * 
     * @param container the files or directories to report on
     * @param out the writer to write the report to
     * @param matcher the header matcher for matching licence headers
     * @param approvedLicenseNames a list of licence families that are approved for use in the project
     * @throws IOException
     * @throws RatReportFailedException
     */
    /**
     * Report on a document. This will result in the document being passed through
     * the document analyser with descriptive elements added to the analysis report.
     * 
     * @param document the document to report on.
     */
			//report.report(System.out);
            report.styleReport(System.out);
			//report.report(System.out);
            report.styleReport(System.out);
        Pattern.compile(".*This class was generated by.*"),
        Pattern.compile(".*Generated By:JJTree&JavaCC*")};
        Pattern.compile(".*This class was generated by.*"),
        Pattern.compile(".*Generated By:JJTree&JavaCC*")};
        Pattern.compile(".*Generated By:JJTree.*"),
        Pattern.compile(".*Generated By:JavaCC.*"),
        Pattern.compile(".*This class was generated by.*")};
        Pattern.compile(".*Generated By:JJTree.*"),
        Pattern.compile(".*Generated By:JavaCC.*"),
        Pattern.compile(".*This class was generated by.*")};
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import javax.xml.parsers.DocumentBuilderFactory;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.PosixParser;
import org.apache.rat.annotation.AbstractLicenceAppender;
import org.apache.rat.annotation.ApacheV2LicenceAppender;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

	//@SuppressWarnings("unchecked")
  public static final void main(String args[]) throws Exception {
	  Options opts = new Options();

    Option help = new Option("h", "help", false,
        "Print help for the RAT command line interface and exit");
    opts.addOption(help);

    Option addLicence = new Option(
        "a",
        "addLicence",
        false,
        "Add the default licence header to any file with an unknown licence that is not in the exclusion list. By default new files will be created with the licence header, to force the modification of existing files use the --force option.");
    opts.addOption(addLicence);
    
    Option write = new Option(
        "f",
        "force",
        false,
        "Forces any changes in files to be written without confirmation");
    opts.addOption(write);

    Option copyright = new Option(
        "c",
        "copyright",
        true,
        "The copyright message to use in the licence headers, usually in the form of \"Copyright 2008 Foo\"");
    opts.addOption(copyright);
    
    Option xml = new Option(
        "x",
        "xml",
        false,
        "Output the report in XML format");
    opts.addOption(xml);
    
    PosixParser parser = new PosixParser();
    CommandLine cl = null;
    try {
      cl = parser.parse(opts, args);
    } catch (ParseException e) {
      System.err.println("Please use the \"--help\" option to see a list of valid commands and options");
      System.exit(1);
    }

    if (cl.hasOption('h')) {
      printUsage(opts);
    }
    
    
    args = cl.getArgs();
    if (args == null || args.length != 1) {
			printUsage(opts);
      Report report = new Report(args[0]);
      
      if (cl.hasOption('a')) {
        OutputStream reportOutput = new ByteArrayOutputStream();
        PrintStream stream = new PrintStream(reportOutput, true);
        report.report(stream);
        
        AbstractLicenceAppender  appender;
        String copyrightMsg = cl.getOptionValue("c");
        if ( copyrightMsg != null) {
          appender = new ApacheV2LicenceAppender(copyrightMsg);
        } else {
          appender = new ApacheV2LicenceAppender();
        }
        if (cl.hasOption("f")) {
          appender.setForce(true);
        }
        
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setValidating(false);
        ByteArrayInputStream xmlStream = new ByteArrayInputStream(reportOutput.toString().getBytes("UTF-8"));
        Document doc = factory.newDocumentBuilder().parse(xmlStream);
        
        NodeList resourceHeaders = doc.getElementsByTagName("header-type");
        String value = null;
        for (int i = 0; i < resourceHeaders.getLength(); i) {
          Node headerType = resourceHeaders.item(i).getAttributes().getNamedItem("name");
          if(headerType != null) {
            value = headerType.getNodeValue();
          } else {
            value = null;
          }
          if (value != null &&value.equals("?????")) {
            Node resource = resourceHeaders.item(i).getParentNode();
            String filename = resource.getAttributes().getNamedItem("name").getNodeValue();
            File document = new File(filename);
            appender.append(document);
          }
        }
      }
      
      if (cl.hasOption('x')) {
			  report.report(System.out);
		  } else {
        report.styleReport(System.out);
		  }		  
		} 
	private static final void printUsage(Options opts) {
    HelpFormatter f = new HelpFormatter();

    String header = "Options";
    
    StringBuffer footer = new StringBuffer("\n");
    footer.append("NOTE:\n");
    footer.append("RAT is really little more than a grep ATM\n");
    footer.append("RAT is also rather memory hungry ATM\n");
    footer.append("RAT is very basic ATM\n");
    footer.append("RAT ATM runs on unpacked releases\n");
    footer.append("RAT highlights possible issues\n");
    footer.append("RAT reports require intepretation\n");
    footer.append("RAT often requires some tuning before it runs well against a project\n");
    footer.append("RAT relies on heuristics: it may miss issues\n");
        
    f.printHelp("java rat.report [options] [DIR]",
        header, opts, footer.toString(), false);
    System.exit(0);
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import javax.xml.parsers.DocumentBuilderFactory;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.PosixParser;
import org.apache.rat.annotation.AbstractLicenceAppender;
import org.apache.rat.annotation.ApacheV2LicenceAppender;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

	//@SuppressWarnings("unchecked")
  public static final void main(String args[]) throws Exception {
	  Options opts = new Options();

    Option help = new Option("h", "help", false,
        "Print help for the RAT command line interface and exit");
    opts.addOption(help);

    Option addLicence = new Option(
        "a",
        "addLicence",
        false,
        "Add the default licence header to any file with an unknown licence that is not in the exclusion list. By default new files will be created with the licence header, to force the modification of existing files use the --force option.");
    opts.addOption(addLicence);
    
    Option write = new Option(
        "f",
        "force",
        false,
        "Forces any changes in files to be written without confirmation");
    opts.addOption(write);

    Option copyright = new Option(
        "c",
        "copyright",
        true,
        "The copyright message to use in the licence headers, usually in the form of \"Copyright 2008 Foo\"");
    opts.addOption(copyright);
    
    Option xml = new Option(
        "x",
        "xml",
        false,
        "Output the report in XML format");
    opts.addOption(xml);
    
    PosixParser parser = new PosixParser();
    CommandLine cl = null;
    try {
      cl = parser.parse(opts, args);
    } catch (ParseException e) {
      System.err.println("Please use the \"--help\" option to see a list of valid commands and options");
      System.exit(1);
    }

    if (cl.hasOption('h')) {
      printUsage(opts);
    }
    
    
    args = cl.getArgs();
    if (args == null || args.length != 1) {
			printUsage(opts);
      Report report = new Report(args[0]);
      
      if (cl.hasOption('a')) {
        OutputStream reportOutput = new ByteArrayOutputStream();
        PrintStream stream = new PrintStream(reportOutput, true);
        report.report(stream);
        
        AbstractLicenceAppender  appender;
        String copyrightMsg = cl.getOptionValue("c");
        if ( copyrightMsg != null) {
          appender = new ApacheV2LicenceAppender(copyrightMsg);
        } else {
          appender = new ApacheV2LicenceAppender();
        }
        if (cl.hasOption("f")) {
          appender.setForce(true);
        }
        
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setValidating(false);
        ByteArrayInputStream xmlStream = new ByteArrayInputStream(reportOutput.toString().getBytes("UTF-8"));
        Document doc = factory.newDocumentBuilder().parse(xmlStream);
        
        NodeList resourceHeaders = doc.getElementsByTagName("header-type");
        String value = null;
        for (int i = 0; i < resourceHeaders.getLength(); i) {
          Node headerType = resourceHeaders.item(i).getAttributes().getNamedItem("name");
          if(headerType != null) {
            value = headerType.getNodeValue();
          } else {
            value = null;
          }
          if (value != null &&value.equals("?????")) {
            Node resource = resourceHeaders.item(i).getParentNode();
            String filename = resource.getAttributes().getNamedItem("name").getNodeValue();
            File document = new File(filename);
            appender.append(document);
          }
        }
      }
      
      if (cl.hasOption('x')) {
			  report.report(System.out);
		  } else {
        report.styleReport(System.out);
		  }		  
		} 
	private static final void printUsage(Options opts) {
    HelpFormatter f = new HelpFormatter();

    String header = "Options";
    
    StringBuffer footer = new StringBuffer("\n");
    footer.append("NOTE:\n");
    footer.append("RAT is really little more than a grep ATM\n");
    footer.append("RAT is also rather memory hungry ATM\n");
    footer.append("RAT is very basic ATM\n");
    footer.append("RAT ATM runs on unpacked releases\n");
    footer.append("RAT highlights possible issues\n");
    footer.append("RAT reports require intepretation\n");
    footer.append("RAT often requires some tuning before it runs well against a project\n");
    footer.append("RAT relies on heuristics: it may miss issues\n");
        
    f.printHelp("java rat.report [options] [DIR]",
        header, opts, footer.toString(), false);
    System.exit(0);
            throw new RatCheckException( "Too many unapproved licenses: "  statistics.getNumUnapprovedLicenses() );
 b/rat-maven-plugin/src/main/java/org/apache/rat/mp/AbstractRatMojo.java
package org.apache.rat.mp;
 b/rat-maven-plugin/src/main/java/org/apache/rat/mp/FilesReportable.java
package org.apache.rat.mp;
 b/rat-maven-plugin/src/main/java/org/apache/rat/mp/HeaderMatcherSpecification.java
package org.apache.rat.mp;
 b/rat-maven-plugin/src/main/java/org/apache/rat/mp/LicenseFamilySpecification.java
package org.apache.rat.mp;
 b/rat-maven-plugin/src/main/java/org/apache/rat/mp/RatCheckException.java
package org.apache.rat.mp;
 b/rat-maven-plugin/src/main/java/org/apache/rat/mp/RatCheckMojo.java
package org.apache.rat.mp;
        URL url = Thread.currentThread().getContextClassLoader().getResource( "org/apache/rat/mp/identity.xsl" );
 b/rat-maven-plugin/src/main/java/org/apache/rat/mp/RatReportMojo.java
package org.apache.rat.mp;
        return ResourceBundle.getBundle( "org/apache/rat/mp/rat-report", locale, getClass().getClassLoader() );
 b/rat-maven-plugin/src/main/java/org/apache/rat/mp/RatStatistics.java
package org.apache.rat.mp;
import org.apache.rat.Defaults;
import org.apache.rat.Report;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.util.HeaderMatcherMultiplexer;
import org.apache.rat.license.ILicenseFamily;
import org.apache.rat.report.IReportable;
import org.apache.rat.report.RatReportFailedException;
            Report.report( out, getResources(), style, m, getApprovedLicenseNames() );
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentCollection;
import org.apache.rat.document.impl.DocumentImplUtils;
import org.apache.rat.document.impl.zip.ZipDocumentFactory;
import org.apache.rat.report.IReportable;
import org.apache.rat.report.RatReport;
import org.apache.rat.report.RatReportFailedException;

import org.apache.rat.Defaults;
import org.apache.rat.Defaults;
import org.apache.rat.Defaults;
import org.apache.rat.Report;
import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.util.HeaderMatcherMultiplexer;
import org.apache.rat.license.ILicenseFamily;
import org.apache.rat.report.IReportable;
import org.apache.rat.report.RatReportFailedException;
            Report.report( out, getResources(), style, m, getApprovedLicenseNames() );
import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentCollection;
import org.apache.rat.document.impl.DocumentImplUtils;
import org.apache.rat.document.impl.zip.ZipDocumentFactory;
import org.apache.rat.report.IReportable;
import org.apache.rat.report.RatReport;
import org.apache.rat.report.RatReportFailedException;

import org.apache.rat.Defaults;
import org.apache.rat.Defaults;
import org.apache.tools.ant.taskdefs.LogOutputStream;
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 */ 
package org.apache.rat.annotation;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Add a licence header to a document. This appender does not check for the
 * existence of an existing licence header, it is assumed that either a second
 * licence header is intentional or that there is no licence header present
 * already.
 * 
 */
public abstract class AbstractLicenceAppender {
  private static final int TYPE_UNKNOWN = 0;
  private static final int TYPE_JAVA = 1;
  private static final int TYPE_XML = 2;
  private static final int TYPE_HTML = 3;
  private static final int TYPE_CSS = 4;
  private static final int TYPE_JAVASCRIPT = 5;
  private static final int TYPE_APT = 6;
  private static final int TYPE_PROPERTIES = 7;
  private boolean isForced;

  public AbstractLicenceAppender() {
    super();
  }

  /**
   * Append the default licence header to the supplied document.
   * 
   * @param document
   * @throws IOException
   *           if there is a problem either reading or writing the file
   */
  public void append(File document) throws IOException {
    int type = getType(document);
    if (type == TYPE_UNKNOWN) {
      return;
    }
    File newDocument = new File(document.getAbsolutePath()  ".new");
    FileWriter writer = new FileWriter(newDocument);
  
    FileReader fr = new FileReader(document);
    BufferedReader br = new BufferedReader(fr);
    
    if (type == TYPE_CSS 
        || type == TYPE_JAVASCRIPT 
        || type == TYPE_APT 
        || type == TYPE_PROPERTIES
        || type == TYPE_HTML) {
      writer.append(getLicenceHeader(document));
      writer.append("\n");
    }
  
    String line;
    while ((line = br.readLine()) != null) {
      writer.append(line);
      writer.append("\n");
      if (type == TYPE_JAVA && line.startsWith("package ")) {
        writer.append(getLicenceHeader(document));
        writer.append("\n");
      }
      if (type == TYPE_XML && line.startsWith("<?xml ")) {
        writer.append(getLicenceHeader(document));
        writer.append("\n");
      }
    }
    br.close();
    writer.close();
    
    if (isForced) {
      document.delete();
      boolean renamed = newDocument.renameTo(document.getAbsoluteFile());
      if (!renamed) {
        System.err.println("Failed to rename new file, original file remains unchanged.");
      }
    }
  }

  /**
   * Detect the type of document.
   * 
   * @param document
   * @return
   * @TODO use existing mechanism to detect the type of a file and record it in the report output, thus we will not need this duplication here.
   */
  protected int getType(File document) {
    if (document.getPath().endsWith(".java")) {
      return TYPE_JAVA;
    } else if (document.getPath().endsWith(".xml") || document.getPath().endsWith(".xsl")) {
      return TYPE_XML;
    } else if (document.getPath().endsWith(".html") || document.getPath().endsWith(".htm")) {
      return TYPE_HTML;
    } else if (document.getPath().endsWith(".css")) {
      return TYPE_CSS;
    } else if (document.getPath().endsWith(".js")) {
      return TYPE_JAVASCRIPT;
    } else if (document.getPath().endsWith(".apt")) {
      return TYPE_APT;
    } else if (document.getPath().endsWith(".properties")) {
      return TYPE_PROPERTIES;
    }
    return TYPE_UNKNOWN;
  }

  /**
   * Set the force flag on this appender. If this flag is set
   * to true then files will be modified directly, otherwise
   * new files will be created alongside the existing files.
   * 
   * @param b
   */
  public void setForce(boolean b) {
    isForced = b;    
  }
  
  /**
   * Get the licence header for a document.
   */
  public abstract String getLicenceHeader(File document);
  
  /**
   * Get the first line of the licence header formatted
   * for the given type of file.
   * 
   * @param type the type of file, see the TYPE_* constants
   * @return
   */
  protected String getFirstLine(int type) {
    switch (type) {
      case TYPE_JAVA: return "/*\n";
      case TYPE_XML: return "<!--\n";
      case TYPE_HTML: return "<!--\n";
      case TYPE_CSS: return "/*\n";
      case TYPE_JAVASCRIPT: return "/*\n";
      case TYPE_APT: return "~~\n";
      case TYPE_PROPERTIES: return "#\n";
      default: return "";
    }
  }
  

  /**
   * Get the last line of the licence header formatted
   * for the given type of file.
   * 
   * @param type the type of file, see the TYPE_* constants
   * @return
   */
  protected String getLastLine(int type) {
    switch (type) {
      case TYPE_JAVA: return " */\n";
      case TYPE_XML: return "-->\n";
      case TYPE_HTML: return "-->\n";
      case TYPE_CSS: return " */\n";
      case TYPE_JAVASCRIPT: return " */\n";
      case TYPE_APT: return "~~\n";
      case TYPE_PROPERTIES: return "#\n";
      default: return "";
    }
  }
  

  /**
   * Get a line of the licence header formatted
   * for the given type of file.
   * 
   * @param type the type of file, see the TYPE_* constants
   * @param content the content for this line
   * @return
   */
  protected String getLine(int type, String content) {
    switch (type) {
      case TYPE_JAVA: return " * "  content  "\n";
      case TYPE_XML: return " "  content  "\n";
      case TYPE_HTML: return " "  content  "\n";
      case TYPE_CSS: return " * "  content  "\n";
      case TYPE_JAVASCRIPT: return " * "  content  "\n";
      case TYPE_APT: return "~~ "  content  "\n";
      case TYPE_PROPERTIES: return "# "  content  "\n";
      default: return "";
    }
  }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 */
package org.apache.rat.annotation;

import java.io.File;


/**
 * Add an Apache Software Licence V2 licence header to a 
 * document. This appender does not check for the
 * existence of an existing licence header, it is assumed that either a second
 * licence header is intentional or that there is no licence header present
 * already. 
 * 
 */
public class ApacheV2LicenceAppender extends AbstractLicenceAppender {

  private String copyright;

  /**
   * Create a licence appender with the standard ASF licence header.
   */
  public ApacheV2LicenceAppender() {
    super();
  }

  /**
   * Create a licence appender with the given copyright line. This should be of
   * the form "Copyright 2008 Foo"
   * 
   * @param copyright
   */
  public ApacheV2LicenceAppender(String copyright) {
    super();
    this.copyright = copyright;
  }

  //@Override
  public String getLicenceHeader(File document) {
    int type = getType(document);
    StringBuffer sb = new StringBuffer();
    if (copyright == null) {
      sb.append(getFirstLine(type));
      sb.append(getLine(type, ""));
      sb.append(getLine(type, "Licensed to the Apache Software Foundation (ASF) under one"));
      sb.append(getLine(type, "or more contributor license agreements.  See the NOTICE file"));
      sb.append(getLine(type, "distributed with this work for additional information"));
      sb.append(getLine(type, "regarding copyright ownership.  The ASF licenses this file"));
      sb.append(getLine(type, "to you under the Apache License, Version 2.0 (the"));
      sb.append(getLine(type, "\"License\"); you may not use this file except in compliance"));
      sb.append(getLine(type, "with the License.  You may obtain a copy of the License at"));
      sb.append(getLine(type, ""));
      sb.append(getLine(type, "  http://www.apache.org/licenses/LICENSE-2.0"));
      sb.append(getLine(type, ""));
      sb.append(getLine(type, "Unless required by applicable law or agreed to in writing,"));
      sb.append(getLine(type, "software distributed under the License is distributed on an"));
      sb.append(getLine(type, "\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY"));
      sb.append(getLine(type, "KIND, either express or implied.  See the License for the"));
      sb.append(getLine(type, "specific language governing permissions and limitations"));
      sb.append(getLine(type, "under the License."));
      sb.append(getLine(type, ""));
      sb.append(getLastLine(type));
    } else {
      sb.append(getFirstLine(type));
      sb.append(getLine(type, ""));
      sb.append(copyright);
      sb.append(getLine(type, ""));
      sb.append(getLine(type, "Licensed under the Apache License, Version 2.0 (the \"License\");"));
      sb.append(getLine(type, "you may not use this file except in compliance with the License."));
      sb.append(getLine(type, "You may obtain a copy of the License at"));
      sb.append(getLine(type, ""));
      sb.append(getLine(type, "  http://www.apache.org/licenses/LICENSE-2.0"));
      sb.append(getLine(type, ""));
      sb.append(getLine(type, "Unless required by applicable law or agreed to in writing,"));
      sb.append(getLine(type, "software distributed under the License is distributed on an"));
      sb.append(getLine(type, "\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY"));
      sb.append(getLine(type, "KIND, either express or implied.  See the License for the"));
      sb.append(getLine(type, "specific language governing permissions and limitations"));
      sb.append(getLine(type, "under the License."));
      sb.append(getLine(type, ""));
      sb.append(getLastLine(type));
    }
    return sb.toString();
  }
  
  

}
}
}
}
}
 b/rat-anttasks/src/main/java/org/apache/rat/anttasks/Report.java
import org.apache.tools.ant.taskdefs.LogOutputStream;
 b/rat-anttasks/src/main/java/org/apache/rat/anttasks/ResourceCollectionContainer.java
}
 b/rat-core/src/main/java/org/apache/rat/annotation/AbstractLicenceAppender.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 */ 
package org.apache.rat.annotation;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Add a licence header to a document. This appender does not check for the
 * existence of an existing licence header, it is assumed that either a second
 * licence header is intentional or that there is no licence header present
 * already.
 * 
 */
public abstract class AbstractLicenceAppender {
  private static final int TYPE_UNKNOWN = 0;
  private static final int TYPE_JAVA = 1;
  private static final int TYPE_XML = 2;
  private static final int TYPE_HTML = 3;
  private static final int TYPE_CSS = 4;
  private static final int TYPE_JAVASCRIPT = 5;
  private static final int TYPE_APT = 6;
  private static final int TYPE_PROPERTIES = 7;
  private boolean isForced;

  public AbstractLicenceAppender() {
    super();
  }

  /**
   * Append the default licence header to the supplied document.
   * 
   * @param document
   * @throws IOException
   *           if there is a problem either reading or writing the file
   */
  public void append(File document) throws IOException {
    int type = getType(document);
    if (type == TYPE_UNKNOWN) {
      return;
    }
    File newDocument = new File(document.getAbsolutePath()  ".new");
    FileWriter writer = new FileWriter(newDocument);
  
    FileReader fr = new FileReader(document);
    BufferedReader br = new BufferedReader(fr);
    
    if (type == TYPE_CSS 
        || type == TYPE_JAVASCRIPT 
        || type == TYPE_APT 
        || type == TYPE_PROPERTIES
        || type == TYPE_HTML) {
      writer.append(getLicenceHeader(document));
      writer.append("\n");
    }
  
    String line;
    while ((line = br.readLine()) != null) {
      writer.append(line);
      writer.append("\n");
      if (type == TYPE_JAVA && line.startsWith("package ")) {
        writer.append(getLicenceHeader(document));
        writer.append("\n");
      }
      if (type == TYPE_XML && line.startsWith("<?xml ")) {
        writer.append(getLicenceHeader(document));
        writer.append("\n");
      }
    }
    br.close();
    writer.close();
    
    if (isForced) {
      document.delete();
      boolean renamed = newDocument.renameTo(document.getAbsoluteFile());
      if (!renamed) {
        System.err.println("Failed to rename new file, original file remains unchanged.");
      }
    }
  }

  /**
   * Detect the type of document.
   * 
   * @param document
   * @return
   * @TODO use existing mechanism to detect the type of a file and record it in the report output, thus we will not need this duplication here.
   */
  protected int getType(File document) {
    if (document.getPath().endsWith(".java")) {
      return TYPE_JAVA;
    } else if (document.getPath().endsWith(".xml") || document.getPath().endsWith(".xsl")) {
      return TYPE_XML;
    } else if (document.getPath().endsWith(".html") || document.getPath().endsWith(".htm")) {
      return TYPE_HTML;
    } else if (document.getPath().endsWith(".css")) {
      return TYPE_CSS;
    } else if (document.getPath().endsWith(".js")) {
      return TYPE_JAVASCRIPT;
    } else if (document.getPath().endsWith(".apt")) {
      return TYPE_APT;
    } else if (document.getPath().endsWith(".properties")) {
      return TYPE_PROPERTIES;
    }
    return TYPE_UNKNOWN;
  }

  /**
   * Set the force flag on this appender. If this flag is set
   * to true then files will be modified directly, otherwise
   * new files will be created alongside the existing files.
   * 
   * @param b
   */
  public void setForce(boolean b) {
    isForced = b;    
  }
  
  /**
   * Get the licence header for a document.
   */
  public abstract String getLicenceHeader(File document);
  
  /**
   * Get the first line of the licence header formatted
   * for the given type of file.
   * 
   * @param type the type of file, see the TYPE_* constants
   * @return
   */
  protected String getFirstLine(int type) {
    switch (type) {
      case TYPE_JAVA: return "/*\n";
      case TYPE_XML: return "<!--\n";
      case TYPE_HTML: return "<!--\n";
      case TYPE_CSS: return "/*\n";
      case TYPE_JAVASCRIPT: return "/*\n";
      case TYPE_APT: return "~~\n";
      case TYPE_PROPERTIES: return "#\n";
      default: return "";
    }
  }
  

  /**
   * Get the last line of the licence header formatted
   * for the given type of file.
   * 
   * @param type the type of file, see the TYPE_* constants
   * @return
   */
  protected String getLastLine(int type) {
    switch (type) {
      case TYPE_JAVA: return " */\n";
      case TYPE_XML: return "-->\n";
      case TYPE_HTML: return "-->\n";
      case TYPE_CSS: return " */\n";
      case TYPE_JAVASCRIPT: return " */\n";
      case TYPE_APT: return "~~\n";
      case TYPE_PROPERTIES: return "#\n";
      default: return "";
    }
  }
  

  /**
   * Get a line of the licence header formatted
   * for the given type of file.
   * 
   * @param type the type of file, see the TYPE_* constants
   * @param content the content for this line
   * @return
   */
  protected String getLine(int type, String content) {
    switch (type) {
      case TYPE_JAVA: return " * "  content  "\n";
      case TYPE_XML: return " "  content  "\n";
      case TYPE_HTML: return " "  content  "\n";
      case TYPE_CSS: return " * "  content  "\n";
      case TYPE_JAVASCRIPT: return " * "  content  "\n";
      case TYPE_APT: return "~~ "  content  "\n";
      case TYPE_PROPERTIES: return "# "  content  "\n";
      default: return "";
    }
  }
}
 b/rat-core/src/main/java/org/apache/rat/annotation/ApacheV2LicenceAppender.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 */
package org.apache.rat.annotation;

import java.io.File;


/**
 * Add an Apache Software Licence V2 licence header to a 
 * document. This appender does not check for the
 * existence of an existing licence header, it is assumed that either a second
 * licence header is intentional or that there is no licence header present
 * already. 
 * 
 */
public class ApacheV2LicenceAppender extends AbstractLicenceAppender {

  private String copyright;

  /**
   * Create a licence appender with the standard ASF licence header.
   */
  public ApacheV2LicenceAppender() {
    super();
  }

  /**
   * Create a licence appender with the given copyright line. This should be of
   * the form "Copyright 2008 Foo"
   * 
   * @param copyright
   */
  public ApacheV2LicenceAppender(String copyright) {
    super();
    this.copyright = copyright;
  }

  //@Override
  public String getLicenceHeader(File document) {
    int type = getType(document);
    StringBuffer sb = new StringBuffer();
    if (copyright == null) {
      sb.append(getFirstLine(type));
      sb.append(getLine(type, ""));
      sb.append(getLine(type, "Licensed to the Apache Software Foundation (ASF) under one"));
      sb.append(getLine(type, "or more contributor license agreements.  See the NOTICE file"));
      sb.append(getLine(type, "distributed with this work for additional information"));
      sb.append(getLine(type, "regarding copyright ownership.  The ASF licenses this file"));
      sb.append(getLine(type, "to you under the Apache License, Version 2.0 (the"));
      sb.append(getLine(type, "\"License\"); you may not use this file except in compliance"));
      sb.append(getLine(type, "with the License.  You may obtain a copy of the License at"));
      sb.append(getLine(type, ""));
      sb.append(getLine(type, "  http://www.apache.org/licenses/LICENSE-2.0"));
      sb.append(getLine(type, ""));
      sb.append(getLine(type, "Unless required by applicable law or agreed to in writing,"));
      sb.append(getLine(type, "software distributed under the License is distributed on an"));
      sb.append(getLine(type, "\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY"));
      sb.append(getLine(type, "KIND, either express or implied.  See the License for the"));
      sb.append(getLine(type, "specific language governing permissions and limitations"));
      sb.append(getLine(type, "under the License."));
      sb.append(getLine(type, ""));
      sb.append(getLastLine(type));
    } else {
      sb.append(getFirstLine(type));
      sb.append(getLine(type, ""));
      sb.append(copyright);
      sb.append(getLine(type, ""));
      sb.append(getLine(type, "Licensed under the Apache License, Version 2.0 (the \"License\");"));
      sb.append(getLine(type, "you may not use this file except in compliance with the License."));
      sb.append(getLine(type, "You may obtain a copy of the License at"));
      sb.append(getLine(type, ""));
      sb.append(getLine(type, "  http://www.apache.org/licenses/LICENSE-2.0"));
      sb.append(getLine(type, ""));
      sb.append(getLine(type, "Unless required by applicable law or agreed to in writing,"));
      sb.append(getLine(type, "software distributed under the License is distributed on an"));
      sb.append(getLine(type, "\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY"));
      sb.append(getLine(type, "KIND, either express or implied.  See the License for the"));
      sb.append(getLine(type, "specific language governing permissions and limitations"));
      sb.append(getLine(type, "under the License."));
      sb.append(getLine(type, ""));
      sb.append(getLastLine(type));
    }
    return sb.toString();
  }
  
  

}
 b/rat-core/src/main/java/org/apache/rat/document/IResource.java
}
 b/rat-core/src/main/java/org/apache/rat/document/impl/zip/ZipDocumentCollection.java
}
 b/rat-core/src/main/java/org/apache/rat/report/xml/writer/IXmlWriter.java
}
 b/rat-maven-plugin/src/main/java/org/apache/rat/mp/FilesReportable.java
}
      writer.write(getLicenceHeader(document));
      writer.write('\n');
      writer.write(line);
      writer.write('\n');
        writer.write(getLicenceHeader(document));
        writer.write('\n');
        writer.write(getLicenceHeader(document));
        writer.write('\n');
   * @return not null
   * @return not null
   * @return not null
   * @return not null
     * @param name not null
     * @return not null
     * @param headerPattern <code>Patter</code>
     * false otherwise or if {@link #read(Reader)} has not been
     * @throws OperationNotAllowedException if called after {@link #content(CharSequence)} 
     * or {@link #closeElement()} or before any call to {@link #openElement(CharSequence)}
     * @throws OperationNotAllowedException if called after {@link #content(CharSequence)} 
     * or {@link #closeElement()} or before any call to {@link #openElement(CharSequence)}
        "NOTICE", "LICENSE",
        "LICENSE.TXT", "NOTICE.TXT",
        "BUILD", "BUILT.TXT",
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * This file does intentionally *NOT* contain an ASL license header,
 * because it is used in the test suite.
 */
     * Whether to exclude subprojects. This is recommended, if you want a
     * separate apache-rat-plugin report for each subproject.
        if ( excludes == null  ||  excludes.length == 0 )
        {
            getLog().info( "No excludes" );
        }
        else
        {
            for ( int i = 0;  i < excludes.length;  i )
            {
                getLog().info( "Exclude: "  excludes[i] );
            }
        }
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
public class RatHeaderAnalysisException extends Exception {
public class RatDocumentAnalysisException extends Exception {
public class UnreadableArchiveException extends IOException {
        initCause(cause);
public class RatReportFailedException extends Exception {
import org.apache.rat.report.claim.ClaimStatistic;
	    HelpFormatter f = new HelpFormatter();
	    String header = "Options";
	    StringBuffer footer = new StringBuffer("\n");
	    footer.append("NOTE:\n");
	    footer.append("RAT is really little more than a grep ATM\n");
	    footer.append("RAT is also rather memory hungry ATM\n");
	    footer.append("RAT is very basic ATM\n");
	    footer.append("RAT ATM runs on unpacked releases\n");
	    footer.append("RAT highlights possible issues\n");
	    footer.append("RAT reports require intepretation\n");
	    footer.append("RAT often requires some tuning before it runs well against a project\n");
	    footer.append("RAT relies on heuristics: it may miss issues\n");

	    f.printHelp("java rat.report [options] [DIR]",
	            header, opts, footer.toString(), false);
	    System.exit(0);
	public ClaimStatistic report(PrintStream out) throws Exception {
            return report(base, new OutputStreamWriter(out), Defaults.createDefaultMatcher(), null);
        return null;
    public static ClaimStatistic report(Writer out, IReportable base, final InputStream style, 
        final ClaimStatistic statistic = report(base, writer, matcher, approvedLicenseNames);
        return statistic;
    public static ClaimStatistic report(final IReportable container, final Writer out, final IHeaderMatcher matcher,
        final ClaimStatistic statistic = new ClaimStatistic();
        RatReport report = XmlReportFactory.createStandardReport(writer, matcher, approvedLicenseNames, statistic);  
        return statistic;
import org.apache.rat.document.IResource;
import org.apache.rat.report.claim.LicenseFamilyCode;
import org.apache.rat.report.claim.impl.LicenseApprovalClaim;

    public static void reportLicenseApprovalClaim(final IResource subject, final boolean isAcceptable, final IClaimReporter reporter) throws RatReportFailedException {
        reporter.claim(new LicenseApprovalClaim(subject, isAcceptable));
    public static final LicenseFamilyCode ASL_CODE = new LicenseFamilyCode("AL   ");
    public static final LicenseFamilyCode OASIS_CODE = new LicenseFamilyCode("OASIS");
    public static final LicenseFamilyCode W3CD_CODE = new LicenseFamilyCode("W3CD ");
    public static final LicenseFamilyCode W3C_CODE = new LicenseFamilyCode("W3C  ");
    public static final LicenseFamilyCode DOJO = new LicenseFamilyCode("DOJO ");
    public static final LicenseFamilyCode TMF854 = new LicenseFamilyCode("TMF  ");
import org.apache.rat.document.IResource;
	public boolean match(IResource subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException;
import org.apache.rat.document.IResource;
import org.apache.rat.report.claim.LicenseFamilyCode;
import org.apache.rat.report.claim.impl.LicenseHeaderClaim;
    public boolean match(IResource subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
    private void reportOnLicense(IResource subject, IClaimReporter reporter) throws RatHeaderAnalysisException {
            reporter.claim(new LicenseHeaderClaim(subject, LicenseFamilyCode.GENERATED,
                    "Generated files do not required license headers"));
import org.apache.rat.document.IResource;
import org.apache.rat.report.claim.LicenseFamilyCode;
import org.apache.rat.report.claim.impl.LicenseHeaderClaim;
    public boolean match(IResource subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
    private void reportOnLicense(IResource subject, IClaimReporter reporter) throws RatHeaderAnalysisException {
            reporter.claim(new LicenseHeaderClaim(subject, LicenseFamilyCode.GENERATED,
                    "JavaDocs are generated and so license header is optional"));
import org.apache.rat.document.IResource;
	public boolean match(IResource subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IResource;
import org.apache.rat.report.claim.LicenseFamilyCode;
import org.apache.rat.report.claim.LicenseFamilyName;
import org.apache.rat.report.claim.impl.LicenseFamilyClaim;
	private final LicenseFamilyCode code;
	private final LicenseFamilyName name;
	public BaseLicense(final LicenseFamilyCode code, final LicenseFamilyName name, final String notes)
    public final void reportOnLicense(IResource subject, IClaimReporter reporter) throws RatHeaderAnalysisException {
        final LicenseFamilyName name = getName();
        final LicenseFamilyCode code = getCode();
            reporter.claim(new LicenseFamilyClaim(subject, name, code, notes));
    public LicenseFamilyCode getCode() {
	public LicenseFamilyName getName() {
import org.apache.rat.document.IResource;
    public boolean match(IResource subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IResource;
    public boolean match(IResource subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IResource;
    public boolean match(IResource subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IResource;
    public boolean match(IResource subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IResource;
    public boolean match(IResource subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IResource;
	public boolean match(IResource subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.report.claim.LicenseFamilyName;

    public static final LicenseFamilyName ACADEMIC_FREE_LICENSE_FAMILY = new LicenseFamilyName("Academic Free License, Version 2.1");
    public LicenseFamilyName getFamilyName() {
import org.apache.rat.report.claim.LicenseFamilyName;

    public static final LicenseFamilyName APACHE_SOFTWARE_LICENSE_NAME = new LicenseFamilyName("Apache License Version 2.0");
    public LicenseFamilyName getFamilyName() {
import org.apache.rat.report.claim.LicenseFamilyName;

    public LicenseFamilyName getFamilyName();
import org.apache.rat.report.claim.LicenseFamilyName;

    public static final LicenseFamilyName MODIFIED_BSD_LICENSE_NAME = new LicenseFamilyName("Modified BSD License");
    public LicenseFamilyName getFamilyName() {
import org.apache.rat.report.claim.LicenseFamilyName;

    public static final LicenseFamilyName OASIS_OPEN_LICENSE_NAME = new LicenseFamilyName("OASIS Open License");
    public LicenseFamilyName getFamilyName() {
import org.apache.rat.report.claim.LicenseFamilyName;

    public static final LicenseFamilyName W3C_DOCUMENT_COPYRIGHT_NAME = new LicenseFamilyName("W3C Document Copyright");
    public LicenseFamilyName getFamilyName() {
import org.apache.rat.report.claim.LicenseFamilyName;

    public static final LicenseFamilyName W3C_SOFTWARE_COPYRIGHT_NAME = new LicenseFamilyName("W3C Software Copyright");
    public LicenseFamilyName getFamilyName() {
import java.util.Comparator;
import org.apache.rat.report.claim.IClaim;
import org.apache.rat.report.claim.LicenseFamilyName;
import org.apache.rat.report.claim.impl.LicenseFamilyClaim;
    private static final LicenseFamilyName[] APPROVED_LICENSES = {
    private static final LicenseFamilyName[] toNames(final ILicenseFamily[] approvedLicenses) {
        LicenseFamilyName[] results = null;
            results = new LicenseFamilyName[length];
    private final LicenseFamilyName[] approvedLicenseNames;

    private static final Comparator licenseFamilyComparator = new Comparator(){
        public int compare(Object arg0, Object arg1) {
            return ((LicenseFamilyName) arg0).getName().compareTo(((LicenseFamilyName) arg1).getName());
        }
    };
    public DefaultPolicy(final IClaimReporter reporter, final LicenseFamilyName[] approvedLicenseNames) {
            this.approvedLicenseNames = new LicenseFamilyName[length];
        Arrays.sort(this.approvedLicenseNames, licenseFamilyComparator);
    public void claim(IClaim pClaim)
        if (pClaim instanceof LicenseFamilyClaim) {
            final LicenseFamilyClaim lfc = (LicenseFamilyClaim) pClaim;
            final boolean isApproved = Arrays.binarySearch(approvedLicenseNames, lfc.getLicenseFamilyName(), licenseFamilyComparator) >= 0;
            Claims.reportLicenseApprovalClaim(pClaim.getSubject(), isApproved, reporter);
import org.apache.rat.report.claim.IClaim;
    public AbstractSingleClaimAnalyser(final IClaimReporter reporter) {
            reporter.claim(toClaim(document));
    protected abstract IClaim toClaim(final IDocument document) throws RatDocumentAnalysisException;
import java.io.IOException;

import org.apache.rat.document.IDocument;
import org.apache.rat.document.IDocumentCollection;
import org.apache.rat.document.RatDocumentAnalysisException;
import org.apache.rat.report.claim.FileType;
import org.apache.rat.report.claim.IClaim;
import org.apache.rat.report.claim.impl.ArchiveFileTypeClaim;
import org.apache.rat.report.claim.impl.FileTypeClaim;
        return new AbstractSingleClaimAnalyser(reporter){
            protected IClaim toClaim(IDocument pDocument)
                    throws RatDocumentAnalysisException {
                boolean readable = false;
                try {
                    final IDocumentCollection contents = pDocument.readArchive();
                    if (contents != null) {
                        readable = true;
                    }
                } catch (IOException e) {
                    readable = false;
                }
                return new ArchiveFileTypeClaim(pDocument, readable);
            }
        };
        return new AbstractSingleClaimAnalyser(reporter){
            protected IClaim toClaim(IDocument pDocument)
                    throws RatDocumentAnalysisException {
                return new FileTypeClaim(pDocument, FileType.NOTICE);
            }
        };
        return new AbstractSingleClaimAnalyser(reporter){
            protected IClaim toClaim(IDocument pDocument)
                    throws RatDocumentAnalysisException {
                return new FileTypeClaim(pDocument, FileType.BINARY);
            }
        };
        return new AbstractSingleClaimAnalyser(reporter){
            protected IClaim toClaim(IDocument pDocument)
                    throws RatDocumentAnalysisException {
                return new FileTypeClaim(pDocument, FileType.STANDARD);
            }
        };
        return createArchiveTypeAnalyser(reporter);
            HeaderCheckWorker worker = new HeaderCheckWorker(reader, matcher, reporter, document);
import org.apache.rat.document.IResource;
import org.apache.rat.report.claim.LicenseFamilyCode;
import org.apache.rat.report.claim.LicenseFamilyName;
import org.apache.rat.report.claim.impl.LicenseFamilyClaim;
    private final IResource name;
            final IHeaderMatcher matcher, final IClaimReporter reporter, final IResource name) {
	public HeaderCheckWorker(Reader reader, final IHeaderMatcher matcher, final IClaimReporter reporter, final IResource name) {
            final IClaimReporter reporter, final IResource name) {
            final IClaimReporter reporter, final IResource name) {
	}

					reporter.claim(new LicenseFamilyClaim(name, LicenseFamilyName.UNKNOWN_LICENSE_FAMILY, LicenseFamilyCode.UNKNOWN, notes));
     * @param pClaim The claim to state.
    void claim(IClaim pClaim) throws RatReportFailedException;
import org.apache.rat.document.IResource;
import org.apache.rat.report.claim.IClaim;
import org.apache.rat.report.claim.impl.ArchiveFileTypeClaim;
import org.apache.rat.report.claim.impl.FileTypeClaim;
import org.apache.rat.report.claim.impl.LicenseApprovalClaim;
import org.apache.rat.report.claim.impl.LicenseFamilyClaim;
import org.apache.rat.report.claim.impl.LicenseHeaderClaim;
    public static final String LICENSE_APPROVAL_PREDICATE = "license-approval";
    public static final String LICENSE_FAMILY_PREDICATE = "license-family";
    public static final String HEADER_SAMPLE_PREDICATE = "header-sample";
    public static final String HEADER_TYPE_PREDICATE = "header-type";
    public static final String FILE_TYPE_PREDICATE = "type";
    public static final String ARCHIVE_TYPE_PREDICATE = "archive-type";
    public static final String ARCHIVE_TYPE_UNREADABLE = "unreadable";
    public static final String ARCHIVE_TYPE_READABLE = "readable";
    private IResource lastSubject;

    protected void handleClaim(ArchiveFileTypeClaim pClaim)
            throws IOException, RatReportFailedException {
        handleClaim((FileTypeClaim) pClaim);
        writeClaim(ARCHIVE_TYPE_PREDICATE, pClaim.isReadable() ? ARCHIVE_TYPE_READABLE : ARCHIVE_TYPE_UNREADABLE, false);
    }

    protected void handleClaim(FileTypeClaim pClaim)
            throws IOException, RatReportFailedException {
        writeClaim(FILE_TYPE_PREDICATE, pClaim.getType().getName(), false);
    }

    protected void handleClaim(LicenseApprovalClaim pClaim)
            throws IOException, RatReportFailedException {
        writeClaim(LICENSE_APPROVAL_PREDICATE, Boolean.toString(pClaim.isApproved()), false);
    }

    protected void handleClaim(LicenseFamilyClaim pClaim)
            throws IOException, RatReportFailedException {
        handleClaim((LicenseHeaderClaim) pClaim);
        writeClaim(LICENSE_FAMILY_PREDICATE, pClaim.getLicenseFamilyName().getName(), false);
    }

    protected void handleClaim(LicenseHeaderClaim pClaim)
            throws IOException, RatReportFailedException {
        writeClaim(HEADER_SAMPLE_PREDICATE, pClaim.getHeaderSample(), true);
        writeClaim(HEADER_TYPE_PREDICATE, pClaim.getLicenseFamilyCode().getName(), false);
    }

    protected void handleClaim(CustomClaim pClaim)
            throws IOException, RatReportFailedException {
        writeClaim(pClaim.getPredicate(), pClaim.getObject(), pClaim.isLiteral());
    }

    /**
     * Writes a single claim to the XML file.
     * @param pPredicate The claims predicate.
     * @param pObject The claims object.
     * @param pLiteral Whether to write the object as an element (true),
     *   or an attribute (false).
     * @throws IOException An I/O error occurred while writing the claim.
     * @throws RatReportFailedException Another error occurred while writing the claim.
     */
    protected void writeClaim(String pPredicate, String pObject, boolean pLiteral)
            throws IOException, RatReportFailedException {
        if (pLiteral) {
            writer.openElement(pPredicate).content(pObject).closeElement();
        } else {
            writer.openElement(pPredicate).attribute(NAME, pObject).closeElement();
        }
    }
    protected void handleClaim(IClaim pClaim) throws IOException, RatReportFailedException {
        if (pClaim instanceof ArchiveFileTypeClaim) {
            handleClaim((ArchiveFileTypeClaim) pClaim);
        } else if (pClaim instanceof FileTypeClaim) {
            handleClaim((FileTypeClaim) pClaim);
        } else if (pClaim instanceof LicenseApprovalClaim) {
            handleClaim((LicenseApprovalClaim) pClaim);
        } else if (pClaim instanceof LicenseFamilyClaim) {
            handleClaim((LicenseFamilyClaim) pClaim);
        } else if (pClaim instanceof LicenseHeaderClaim) {
            handleClaim((LicenseHeaderClaim) pClaim);
        } else if (pClaim instanceof CustomClaim) {
            handleClaim((CustomClaim) pClaim);
        } else {
            throw new IllegalStateException("Invalid claim type: "  pClaim.getClass().getName());
        }
    }

    public void claim(IClaim pClaim) throws RatReportFailedException {
        final IResource subject = pClaim.getSubject();
                writer.openElement("resource").attribute(NAME, subject.getName());
            handleClaim(pClaim);
            throw new RatReportFailedException("XML writing failure: "  e.getMessage()
                     " subject: "  subject  " claim type: "
                     pClaim.getClass().getName(), e);
import org.apache.rat.report.claim.IClaim;
    public void claim(IClaim pClaim)
            reporters[i].claim(pClaim);
import org.apache.rat.document.IDocument;
import org.apache.rat.report.RatReportFailedException;
import org.apache.rat.report.claim.ClaimStatistic;
import org.apache.rat.report.claim.impl.ClaimAggregator;
            final IHeaderMatcher matcher, ClaimStatistic pStatistic) {
        return createStandardReport(writer, matcher, null, pStatistic);
            final IHeaderMatcher matcher, final ILicenseFamily[] approvedLicenses,
            final ClaimStatistic pStatistic) {
        final IClaimReporter reporter;
        if (pStatistic == null) {
            reporter = new SimpleXmlClaimReporter(writer);
        } else {
            reporter = new ClaimAggregator(new SimpleXmlClaimReporter(writer));
        }

        if (pStatistic == null) {
            return result;
        }
        return new RatReport(){
            public void endReport() throws RatReportFailedException {
                result.endReport();
                ((ClaimAggregator) reporter).fillClaimStatistic(pStatistic);
            }
            public void report(IDocument pDocument)
                    throws RatReportFailedException {
                result.report(pDocument);
            }
            public void startReport() throws RatReportFailedException {
                result.startReport();
            }
        };
import org.apache.rat.document.IResource;
	public boolean match(IResource subject, String line, IClaimReporter reporter) {
import org.apache.rat.report.claim.LicenseFamilyCode;
import org.apache.rat.report.claim.LicenseFamilyName;

        super(new LicenseFamilyCode(""), new LicenseFamilyName(""), "");
    public MockLocation(String name) {
        this(name, "url");
    }

import org.apache.rat.report.claim.IClaim;
    public void claim(IClaim pClaim)
        claims.add(pClaim);
    public CustomClaim getClaim(int index) {
        return (CustomClaim) claims.get(index);
import java.io.Writer;
import org.apache.rat.report.claim.ClaimStatistic;
    protected ClaimStatistic createReport( Writer out, InputStream style ) throws MojoExecutionException, MojoFailureException
            return Report.report( out, getResources(), style, m, getApprovedLicenseNames() );
import java.io.FileWriter;
import org.apache.rat.report.claim.ClaimStatistic;
    private ClaimStatistic getRawReport()
        FileWriter fw = null;
            fw = new FileWriter( reportFile );
            final ClaimStatistic statistic = createReport( fw, Defaults.getDefaultStyleSheet() );
            fw.close();
            fw = null;
            return statistic;
            if ( fw != null )
                    fw.close();
        final ClaimStatistic report = getRawReport();
    protected void check( ClaimStatistic statistics )
        if ( numUnapprovedLicenses < statistics.getNumUnApproved() )
            throw new RatCheckException( "Too many unapproved licenses: "  statistics.getNumUnApproved() );
import org.apache.rat.report.claim.LicenseFamilyName;
    private static final LicenseFamilyName LICENSE_FAMILY_NAME = new LicenseFamilyName("Example License");

    public LicenseFamilyName getFamilyName() {
    	return LICENSE_FAMILY_NAME;
import org.apache.rat.analysis.license.BaseLicense;
import org.apache.rat.document.IResource;
import org.apache.rat.report.claim.IClaimReporter;
import org.apache.rat.report.claim.LicenseFamilyCode;
import org.apache.rat.report.claim.LicenseFamilyName;
    	super(new LicenseFamilyCode("EXMPL"), new LicenseFamilyName("Example License"), "");
    public boolean match(IResource subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import java.io.Reader;
import org.apache.rat.document.CompositeDocumentException;
import org.apache.rat.document.IDocument;
public class ZipFileDocument implements IDocument {
    private final String name;
        this.name = file.getPath();
    }

    public Reader reader() throws IOException {
        throw new CompositeDocumentException();

    public String getName() {
        return name;
    }
     * Is this a composite document?
     * @return true if composite, false otherwise
    public boolean isComposite();
	public boolean isComposite() {
        return false;
    public String getName() {
    public boolean isComposite() {
        try {
            unarchiver.unarchive(file);
            return true;
        } catch (IOException e) {
            return false;
        }
    public boolean isComposite() {
        return false;
    
    
    public boolean isComposite() {
        try {
            ZipDocumentFactory.load(file);
            return true;
        } catch (IOException e) {
            return false;
    
    
                return new ArchiveFileTypeClaim(pDocument, pDocument.isComposite());
    
    public boolean isComposite() {
        return contents != null;
    }

    public boolean isComposite() {
        return documentCollection != null;
    }
        public boolean isComposite() {
            try {
                ZipDocumentFactory.load( file );
                return true;
            } catch (IOException e) {
                return false;
            }
        

        public boolean isComposite() {
            if (resource instanceof FileResource) {
                final FileResource fileResource = (FileResource) resource;
                final File file = fileResource.getFile();
                try {
                    return ZipDocumentFactory.load(file) != null;
                } catch (IOException e) {
                    return false;
                }
            }
            return false;
        }
public class ToNameTransformer implements Transformer {
    private static final Transformer TO_NAME_TRANSFORMER = new ToNameTransformer();
    
    public static final Transformer toNameTransformer() {
        return TO_NAME_TRANSFORMER;
    }
    
import org.apache.rat.document.ToNameTransformer;
        CollectionUtils.transform(documents, ToNameTransformer.toNameTransformer());
        IDocument document = new FileDocument(file);
import org.apache.rat.document.impl.zip.ZipDocumentFactory;
    public FileDocument(final File file) {
            ZipDocumentFactory.load(file);
        return ZipDocumentFactory.isZip(file);
import java.util.zip.ZipException;
    public static final boolean isZip(File file) {
            zip.entries();
            return true;
        } catch (ZipException e) {
            return false;
        } catch (IOException e) {
            return false;
                try {
                    zip.close();
                } catch (Throwable t) {
                    // Swallow
                }
        return ZipDocumentFactory.isZip(file);
            return ZipDocumentFactory.isZip(file);
                return ZipDocumentFactory.isZip(file);
import java.io.IOException;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;
    public static final boolean isZip(File file) {
        ZipFile zip = null;
        try {
            zip = new ZipFile(file);
            zip.entries();
            return true;
        } catch (ZipException e) {
            return false;
        } catch (IOException e) {
            return false;
        } finally {
            if (zip != null) {
                try {
                    zip.close();
                } catch (Throwable t) {
                    // Swallow
                }
            }
        }
    }

        return DocumentImplUtils.isZip(file);
            return DocumentImplUtils.isZip(file);
                return DocumentImplUtils.isZip(file);
        return false;
        return false;
import org.apache.tools.ant.types.Resource;
import org.apache.tools.ant.types.ResourceCollection;
import org.apache.tools.ant.types.resources.FileResource;
import org.apache.rat.document.IDocument;
    public static void reportLicenseApprovalClaim(final IDocument subject, final boolean isAcceptable, final IClaimReporter reporter) throws RatReportFailedException {
import org.apache.rat.document.IDocument;
	public boolean match(IDocument subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException;
import org.apache.rat.document.IDocument;
    public boolean match(IDocument subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
    private void reportOnLicense(IDocument subject, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IDocument;
    public boolean match(IDocument subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
    private void reportOnLicense(IDocument subject, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IDocument;
	public boolean match(IDocument subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IDocument;
    public final void reportOnLicense(IDocument subject, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IDocument;
    public boolean match(IDocument subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IDocument;
    public boolean match(IDocument subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IDocument;
    public boolean match(IDocument subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IDocument;
    public boolean match(IDocument subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IDocument;
    public boolean match(IDocument subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.document.IDocument;
	public boolean match(IDocument subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {
public interface IDocument {
    public String getName();
    
        if (subject != null && subject instanceof IDocument) {
            IDocument location = (IDocument) subject;
import org.apache.rat.document.IDocument;
    private final IDocument name;
            final IHeaderMatcher matcher, final IClaimReporter reporter, final IDocument name) {
	public HeaderCheckWorker(Reader reader, final IHeaderMatcher matcher, final IClaimReporter reporter, final IDocument name) {
            final IClaimReporter reporter, final IDocument name) {
            final IClaimReporter reporter, final IDocument name) {
import org.apache.rat.document.IDocument;
    IDocument getSubject();
import org.apache.rat.document.IDocument;
    private final IDocument subject;
    protected AbstractClaim(IDocument pSubject) {
    public IDocument getSubject() {
import org.apache.rat.document.IDocument;
    public ArchiveFileTypeClaim(IDocument pSubject, boolean pReadable) {
import org.apache.rat.document.IDocument;
    public FileTypeClaim(IDocument pSubject, FileType pType) {
import org.apache.rat.document.IDocument;
    public LicenseApprovalClaim(IDocument pSubject, boolean pApproved) {
import org.apache.rat.document.IDocument;
    public LicenseFamilyClaim(IDocument pSubject, LicenseFamilyName pName,
import org.apache.rat.document.IDocument;
    public LicenseHeaderClaim(IDocument pSubject, LicenseFamilyCode pCode, String pHeaderSample) {
import org.apache.rat.document.IDocument;
    private final IDocument subject;
    public CustomClaim(final IDocument subject, final String predicate, final String object, final boolean isLiteral) {
    public IDocument getSubject() {
import org.apache.rat.document.IDocument;
    private IDocument lastSubject;
        final IDocument subject = pClaim.getSubject();
import org.apache.rat.document.IDocument;
	public boolean match(IDocument subject, String line, IClaimReporter reporter) {
import java.io.IOException;
import java.io.Reader;

public class MockLocation implements IDocument {
    public boolean isComposite() {
        // TODO Auto-generated method stub
        return false;
    }

    public Reader reader() throws IOException {
        throw new UnsupportedOperationException();
    }

import org.apache.rat.document.IDocument;
    public boolean match(IDocument subject, String line, IClaimReporter reporter) throws RatHeaderAnalysisException {

    /**
     * Gets data describing this resource.
     * @return not null
     */
    public MetaData getMetaData();
import org.apache.rat.document.MetaData;
	private final MetaData metaData;
        this.metaData = new MetaData();

    public MetaData getMetaData() {
        return metaData;
    }
import org.apache.rat.document.MetaData;
    private final MetaData metaData = new MetaData();
    public MetaData getMetaData() {
        return metaData;
    }    
    private final MetaData metaData = new MetaData();
    
    public MetaData getMetaData() {
        return metaData;
    }
    private final MetaData metaData = new MetaData();
    public MetaData getMetaData() {
        return metaData;
    }
import org.apache.rat.document.MetaData;
        private final MetaData metaData = new MetaData();
        

        public MetaData getMetaData() {
            return metaData;
        }
import org.apache.rat.document.MetaData;
        private final MetaData metaData = new MetaData();
        
        public MetaData getMetaData() {
            return metaData;
        }
import java.io.InputStream;
    
    /**
     * Streams the document's contents.
     * @return not null
     * @throws IOException when stream could not be opened
     */
    public InputStream inputStream() throws IOException;
import java.io.FileInputStream;
import java.io.InputStream;
    
    public InputStream inputStream() throws IOException {
        return new FileInputStream(file);
    }
import java.io.FileInputStream;
import java.io.InputStream;
				return new InputStreamReader(inputStream(), "UTF-8");

            public InputStream inputStream() throws IOException {
                return url.openStream();
            }

    public InputStream inputStream() throws IOException {
        return new FileInputStream(file);
    }
import java.io.InputStream;
    

    public InputStream inputStream() throws IOException {
        throw new UnsupportedOperationException();
    }
import java.io.InputStream;
    

    public InputStream inputStream() throws IOException {
        throw new UnsupportedOperationException();
    }
        
        public InputStream inputStream() throws IOException {
            return new FileInputStream(file);
        }
        
        public InputStream inputStream() throws IOException {
            return resource.getInputStream();
        }
 b/apache-rat-core/src/main/java/org/apache/rat/api/ContentType.java
package org.apache.rat.api;
 b/apache-rat-core/src/main/java/org/apache/rat/api/MetaData.java
package org.apache.rat.api;

import org.apache.rat.api.MetaData;

import org.apache.rat.api.MetaData;
import org.apache.rat.api.MetaData;
import org.apache.rat.api.MetaData;

import org.apache.rat.api.MetaData;

import org.apache.rat.api.MetaData;
import org.apache.rat.api.MetaData;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;


    /** 
     * Only likely to be a small quantity of data 
     * so trade some performance for simplicity.
     */
    private final List/*<Datum>*/ data;
        this.data = new ArrayList/*<Datum>*/(16);
    
    /**
     * Gets all data.
     * @return unmodifiable view of the meta data.
     */
    public Collection getData() {
        return Collections.unmodifiableCollection(data);
    }
    
    /**
     * Adds a new datum.
     * Existing data with the same name are not replaced.
     * @param datum
     * @see #put(org.apache.rat.api.MetaData.Datum)
     */
    public void add(final Datum datum) {
       data.add(datum); 
    }
    
    /**
     * Puts in a new datum replacing any existing data.
     * Any current data matching the name are removed.
     * @param datum not null
     * @see #add(org.apache.rat.api.MetaData.Datum)
     */
    public void put(final Datum datum) {
       clear(datum.getName()); 
    }
    
    /**
     * Removes all data matching the given name.
     * @param name not null
     * @return true if any data match, false otherwise
     */
    public boolean clear(final String name) {
        boolean dataRemoved = false;
        for (final Iterator it=data.iterator();it.hasNext();) {
            final Datum datum = (Datum) it.next();
            if (datum.getName().equals(name)) {
                it.remove();
                dataRemoved = true;
            }
        }
        return dataRemoved;
    }
    
    /**
     * A datum.
     */
    public static final class Datum {
        private final String name;
        private final String value;
        
        /**
         * Constructs a datum.
         * @param name not null
         * @param value not null
         */
        public Datum(final String name, final String value) {
            super();
            this.name = name;
            this.value = value;
        }
        
        /**
         * Gets the name of the data type.
         * To avoid collisions, it is recommended that URLs are used.
         * @return not null
         */
        public String getName() {
            return name;
        }
     
        /**
         * Data type value.
         * @return not null
         */
        public String getValue() {
            return value;
        }

        /**
         * Constructs a <code>String</code> with all attributes
         * in name = value format.
         *
         * @return a <code>String</code> representation 
         * of this object.
         */
        public String toString()
        {
            return "Datum [ "
                 "name ='"  this.name  "',"
                 "value ='"  this.value  " "
                 "']";
        }
    }

    /**
     * Representations suitable for logging.
     * @return a <code>String</code> representation 
     * of this object.
     */
    public String toString()
    {
        return "FileDocument ( "
             "file = "  this.file  " "
             "name = "  this.name  " "
             "metaData = "  this.metaData  " "
             " )";
    }
    
    
public class ArchiveGuesser {
    public static final boolean isArchive(final IDocument document) {
public class BinaryGuesser {
    private static boolean isBinaryDocument(IDocument document) {
    public static final boolean isBinary(final IDocument document) {
            result = isBinaryDocument(document);
public class NoteGuesser {
    public static final boolean isNote(final IDocument document) {
import org.apache.rat.report.RatReportFailedException;
  
        return new DefaultAnalyser(reporter, matcher);
    
    private final static class DefaultAnalyser implements IDocumentAnalyser {
        private final IClaimReporter reporter;
        private final IHeaderMatcher matcher;
        public DefaultAnalyser(final IClaimReporter reporter, final IHeaderMatcher matcher) {
            super();
            this.reporter = reporter;
            this.matcher = matcher;
        }
        public void analyse(IDocument document) throws RatDocumentAnalysisException {
            final FileType type;
            if (NoteGuesser.isNote(document)) {
                type = FileType.NOTICE;
            } else if (ArchiveGuesser.isArchive(document)) {
                type = FileType.ARCHIVE;
            } else if (BinaryGuesser.isBinary(document)) {
                type = FileType.BINARY;
            } else {
                type = FileType.STANDARD;
                final DocumentHeaderAnalyser headerAnalyser = new DocumentHeaderAnalyser(matcher, reporter);
                headerAnalyser.analyse(document);
            }
            
            try {
                reporter.claim(new FileTypeClaim(document, type));
            } catch (RatReportFailedException e) {
                throw new RatReportAnalysisResultException(e);
            }
        }        
    
    public static final String TYPE_STANDARD = "standard";
    public static final String TYPE_BINARY = "binary";
    public static final String TYPE_NOTICE = "notice";
    public static final String TYPE_ARCHIVE = "archive";
    public static final String TYPE_UNKNOWN = "?????";
    public static final String TYPE_GENERATED = "GEN  ";
    
    public static final String RAT_FILE_CATEGORY ="http://org/apache/rat/meta-data#FileCategory";
    
    public static final FileType GENERATED = new FileType(TYPE_GENERATED);
    public static final FileType UNKNOWN = new FileType(TYPE_UNKNOWN);
    public static final FileType ARCHIVE = new FileType(TYPE_ARCHIVE);
    public static final FileType NOTICE = new FileType(TYPE_NOTICE);
    public static final FileType BINARY = new FileType(TYPE_BINARY);
    public static final FileType STANDARD = new FileType(TYPE_STANDARD);
    public static final String RAT_DOCUMENT_CATEGORY_VALUE_GENERATED = "GEN  ";
    public static final String RAT_DOCUMENT_CATEGORY_VALUE_UNKNOWN = "?????";
    public static final String RAT_DOCUMENT_CATEGORY_VALUE_ARCHIVE = "archive";
    public static final String RAT_DOCUMENT_CATEGORY_VALUE_NOTICE = "notice";
    public static final String RAT_DOCUMENT_CATEGORY_VALUE_BINARY = "binary";
    public static final String RAT_DOCUMENT_CATEGORY_VALUE_STANDARD = "standard";
    public static final String RAT_DOCUMENT_CATEGORY_URL ="http://org/apache/rat/meta-data#FileCategory";
    
import org.apache.rat.api.MetaData;

    public static final FileType GENERATED = new FileType(MetaData.RAT_DOCUMENT_CATEGORY_VALUE_GENERATED);
    public static final FileType UNKNOWN = new FileType(MetaData.RAT_DOCUMENT_CATEGORY_VALUE_UNKNOWN);
    public static final FileType ARCHIVE = new FileType(MetaData.RAT_DOCUMENT_CATEGORY_VALUE_ARCHIVE);
    public static final FileType NOTICE = new FileType(MetaData.RAT_DOCUMENT_CATEGORY_VALUE_NOTICE);
    public static final FileType BINARY = new FileType(MetaData.RAT_DOCUMENT_CATEGORY_VALUE_BINARY);
    public static final FileType STANDARD = new FileType(MetaData.RAT_DOCUMENT_CATEGORY_VALUE_STANDARD);
        if (pClaim instanceof FileTypeClaim) {
        if (pClaim instanceof FileTypeClaim) {
import org.apache.rat.document.IDocument;
    private IDocument subject;
            Claims.reportLicenseApprovalClaim(subject, isApproved, reporter);

    public void report(final IDocument subject) throws RatReportFailedException {
        this.subject = subject;
    }
                reporter.report(document);
                final FileType type;
                if (NoteGuesser.isNote(document)) {
                    type = FileType.NOTICE;
                } else if (ArchiveGuesser.isArchive(document)) {
                    type = FileType.ARCHIVE;
                } else if (BinaryGuesser.isBinary(document)) {
                    type = FileType.BINARY;
                } else {
                    type = FileType.STANDARD;
                    final DocumentHeaderAnalyser headerAnalyser = new DocumentHeaderAnalyser(matcher, reporter);
                    headerAnalyser.analyse(document);
                }
import org.apache.rat.document.IDocument;
    
    /**
     * Starts a report on the given document.
     * All claims concern this document until this is called next.
     * @param subject not null
     * @throws RatReportFailedException
     */
    void report(IDocument subject) throws RatReportFailedException;
    
import org.apache.rat.document.IDocument;

    public void report(IDocument document) throws RatReportFailedException {}
import org.apache.rat.document.IDocument;

    public void report(IDocument document) throws RatReportFailedException {
        super.report(document);
        if (reporter != null) {
            reporter.report(document);
        }
    }
    private IDocument subject;
        try {
            handleClaim(pClaim);
        } catch (IOException e) {
            throw new RatReportFailedException("XML writing failure: "  e.getMessage()
                     " subject: "  subject  " claim type: "
                     pClaim.getClass().getName(), e);
        }
    }

    public void report(final IDocument subject) throws RatReportFailedException {
        this.subject = subject;
                     " subject: "  subject, e);
import org.apache.rat.document.IDocument;
    public void report(IDocument document) throws RatReportFailedException {
        final int length = reporters.length;
        for (int i=0;i<length;i) {
            reporters[i].report(document);
        } 
    }
import org.apache.rat.document.IDocument;

    public void report(IDocument document) throws RatReportFailedException {
    }
import org.apache.rat.report.claim.LicenseFamilyCode;
		super(LicenseFamilyCode.ASL_CODE, Apache20LicenseFamily.APACHE_SOFTWARE_LICENSE_NAME, "");
import org.apache.rat.report.claim.LicenseFamilyCode;
        super(LicenseFamilyCode.DOJO, ModifiedBSDLicenseFamily.MODIFIED_BSD_LICENSE_NAME, "Dual license AFL/BSD");
import org.apache.rat.report.claim.LicenseFamilyCode;
        super(LicenseFamilyCode.OASIS_CODE, OASISLicenseFamily.OASIS_OPEN_LICENSE_NAME, "No modifications allowed");
import org.apache.rat.report.claim.LicenseFamilyCode;
        super(LicenseFamilyCode.TMF854, ModifiedBSDLicenseFamily.MODIFIED_BSD_LICENSE_NAME, "BSD");
import org.apache.rat.report.claim.LicenseFamilyCode;
        super(LicenseFamilyCode.W3CD_CODE, W3CDocumentLicenseFamily.W3C_DOCUMENT_COPYRIGHT_NAME,  NOTES);
import org.apache.rat.report.claim.LicenseFamilyCode;
        super(LicenseFamilyCode.W3C_CODE, W3CSoftwareLicenseFamily.W3C_SOFTWARE_COPYRIGHT_NAME,  NOTES);
    public static final String RAT_LICENSE_FAMILY_VALUE_ASL = "AL   ";
    public static final String RAT_LICENSE_FAMILY_VALUE_OASIS = "OASIS";
    public static final String RAT_LICENSE_FAMILY_VALUE_W3CD = "W3CD ";
    public static final String RAT_LICENSE_FAMILY_VALUE_W3C = "W3C  ";
    public static final String RAT_LICENSE_FAMILY_VALUE_DOJO = "DOJO ";
    public static final String RAT_LICENSE_FAMILY_VALUE_TMF = "TMF  ";
import org.apache.rat.report.claim.impl.LicenseApprovalClaim;
            reportLicenseApprovalClaim(subject, isApproved, reporter);
    public void reportLicenseApprovalClaim(final IDocument subject, final boolean isAcceptable, final IClaimReporter reporter) throws RatReportFailedException {
        reporter.claim(new LicenseApprovalClaim(subject, isAcceptable));
    }
    
import org.apache.rat.api.MetaData;

    public static final LicenseFamilyCode TMF854 = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_VALUE_TMF);
    public static final LicenseFamilyCode DOJO = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_VALUE_DOJO);
    public static final LicenseFamilyCode W3C_CODE = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_VALUE_W3C);
    public static final LicenseFamilyCode W3CD_CODE = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_VALUE_W3CD);
    public static final LicenseFamilyCode OASIS_CODE = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_VALUE_OASIS);
    public static final LicenseFamilyCode ASL_CODE = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_VALUE_ASL);
import org.apache.rat.report.claim.LicenseFamilyName;
		super(LicenseFamilyCode.ASL_CODE, LicenseFamilyName.APACHE_SOFTWARE_LICENSE_NAME, "");
import org.apache.rat.report.claim.LicenseFamilyName;
        super(LicenseFamilyCode.DOJO, LicenseFamilyName.MODIFIED_BSD_LICENSE_NAME, "Dual license AFL/BSD");
import org.apache.rat.report.claim.LicenseFamilyName;
        super(LicenseFamilyCode.OASIS_CODE, LicenseFamilyName.OASIS_OPEN_LICENSE_NAME, "No modifications allowed");
import org.apache.rat.report.claim.LicenseFamilyName;
        super(LicenseFamilyCode.TMF854, LicenseFamilyName.MODIFIED_BSD_LICENSE_NAME, "BSD");
import org.apache.rat.report.claim.LicenseFamilyName;
        super(LicenseFamilyCode.W3CD_CODE, LicenseFamilyName.W3C_DOCUMENT_COPYRIGHT_NAME,  NOTES);
import org.apache.rat.report.claim.LicenseFamilyName;
        super(LicenseFamilyCode.W3C_CODE, LicenseFamilyName.W3C_SOFTWARE_COPYRIGHT_NAME,  NOTES);
    public static final String RAT_BASE_URL = "http://org/apache/rat/meta-data";
    
    // Document Categories
    public static final String RAT_DOCUMENT_CATEGORY_URL = RAT_BASE_URL  "#FileCategory";
    
    // License Family Categories
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_GEN = "GEN  ";
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_UNKNOWN = "?????";
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_ASL = "AL   ";
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_OASIS = "OASIS";
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_W3CD = "W3CD ";
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_W3C = "W3C  ";
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_DOJO = "DOJO ";
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_TMF = "TMF  ";
    public static final String RAT_LICENSE_FAMILY_CATEGORY_URL= RAT_BASE_URL  "LicenseFamilyCategory";

    // License Family Standard Names
    public static final String RAT_LICENSE_FAMILY_NAME_VALUE_W3C_SOFTWARE_COPYRIGHT = "W3C Software Copyright";
    public static final String RAT_LICENSE_FAMILY_NAME_VALUE_W3C_DOCUMENT_COPYRIGHT = "W3C Document Copyright";
    public static final String RAT_LICENSE_FAMILY_NAME_VALUE_OASIS_OPEN_LICENSE = "OASIS Open License";
    public static final String RAT_LICENSE_FAMILY_NAME_VALUE_MODIFIED_BSD_LICENSE = "Modified BSD License";
    public static final String RAT_LICENSE_FAMILY_NAME_VALUE_APACHE_LICENSE_VERSION_2_0 = "Apache License Version 2.0";
    public static final String RAT_LICENSE_FAMILY_NAME_VALUE_ACADEMIC_FREE_LICENSE_VERSION_2_1 = "Academic Free License, Version 2.1";
    public static final String RAT_LICENSE_FAMILY_NAME_VALUE_UNKNOWN = "?????";
    public static final String RAT_LICENSE_FAMILY_NAME_URL= RAT_BASE_URL  "LicenseFamilyName";

        return LicenseFamilyName.ACADEMIC_FREE_LICENSE_FAMILY;
        return LicenseFamilyName.APACHE_SOFTWARE_LICENSE_NAME;
        return LicenseFamilyName.MODIFIED_BSD_LICENSE_NAME;
        return LicenseFamilyName.OASIS_OPEN_LICENSE_NAME;
        return LicenseFamilyName.W3C_DOCUMENT_COPYRIGHT_NAME;
        return LicenseFamilyName.W3C_SOFTWARE_COPYRIGHT_NAME;
        LicenseFamilyName.APACHE_SOFTWARE_LICENSE_NAME, LicenseFamilyName.OASIS_OPEN_LICENSE_NAME, 
        LicenseFamilyName.W3C_SOFTWARE_COPYRIGHT_NAME, LicenseFamilyName.W3C_DOCUMENT_COPYRIGHT_NAME,
        LicenseFamilyName.MODIFIED_BSD_LICENSE_NAME
    
    public static final LicenseFamilyCode TMF854 = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_TMF);
    public static final LicenseFamilyCode DOJO = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_DOJO);
    public static final LicenseFamilyCode W3C_CODE = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_W3C);
    public static final LicenseFamilyCode W3CD_CODE = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_W3CD);
    public static final LicenseFamilyCode OASIS_CODE = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_OASIS);
    public static final LicenseFamilyCode ASL_CODE = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_ASL);
    public static final LicenseFamilyCode GENERATED = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_GEN);
    public static final LicenseFamilyCode UNKNOWN = new LicenseFamilyCode(MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_UNKNOWN);
    
    private final String name;
    
import org.apache.rat.api.MetaData;

    public static final LicenseFamilyName W3C_SOFTWARE_COPYRIGHT_NAME = new LicenseFamilyName(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_W3C_SOFTWARE_COPYRIGHT);
    public static final LicenseFamilyName W3C_DOCUMENT_COPYRIGHT_NAME = new LicenseFamilyName(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_W3C_DOCUMENT_COPYRIGHT);
    public static final LicenseFamilyName OASIS_OPEN_LICENSE_NAME = new LicenseFamilyName(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_OASIS_OPEN_LICENSE);
    public static final LicenseFamilyName MODIFIED_BSD_LICENSE_NAME = new LicenseFamilyName(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_MODIFIED_BSD_LICENSE);
    public static final LicenseFamilyName APACHE_SOFTWARE_LICENSE_NAME = new LicenseFamilyName(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_APACHE_LICENSE_VERSION_2_0);
    public static final LicenseFamilyName ACADEMIC_FREE_LICENSE_FAMILY = new LicenseFamilyName(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_ACADEMIC_FREE_LICENSE_VERSION_2_1);
    public static final LicenseFamilyName UNKNOWN_LICENSE_FAMILY = new LicenseFamilyName(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_UNKNOWN);
    private final String name;
    
            reporter.claim(new LicenseHeaderClaim(subject, LicenseFamilyCode.GENERATED));
            reporter.claim(new LicenseHeaderClaim(subject, LicenseFamilyCode.GENERATED));
import org.apache.rat.api.MetaData;
        subject.getMetaData().set(new MetaData.Datum(MetaData.RAT_URL_HEADER_SAMPLE, notes));
            reporter.claim(new LicenseFamilyClaim(subject, name, code));
    public static final String RAT_URL_DOCUMENT_CATEGORY = RAT_BASE_URL  "#FileCategory";
    public static final String RAT_URL_LICENSE_FAMILY_CATEGORY= RAT_BASE_URL  "LicenseFamilyCategory";
    public static final String RAT_URL_LICENSE_FAMILY_NAME= RAT_BASE_URL  "LicenseFamilyName";
    
    // Header sample
    public static final String RAT_URL_HEADER_SAMPLE = RAT_BASE_URL  "HeaderSample";
     * @see #set(org.apache.rat.api.MetaData.Datum)
    public void set(final Datum datum) {
       add(datum);
    }
    
    /**
     * Gets the first datum matching the given name.
     * @param name not null
     * @return the matching datum first added when there is any matching data,
     * null otherwise
     */
    public Datum get(final String name) {
        Datum result = null;
        for (final Iterator/*<Datum>*/ it=data.iterator();it.hasNext();) {
            final Datum next = (Datum) it.next();
            if (name.equals(next.getName())) {
                result = next;
                break;
            }
        }
        return result;
import org.apache.rat.api.MetaData;
    private final IDocument subject;
        this.subject = name;
                    subject.getMetaData().set(new MetaData.Datum(MetaData.RAT_URL_HEADER_SAMPLE, notes));
					reporter.claim(new LicenseFamilyClaim(subject, LicenseFamilyName.UNKNOWN_LICENSE_FAMILY, LicenseFamilyCode.UNKNOWN));
                throw new RatHeaderAnalysisException("Cannot read header for "  subject, e);
                throw new RatHeaderAnalysisException("Cannot write claim for "  subject, e);
            match = matcher.match(subject, line, reporter);
            LicenseFamilyCode pCode) {
        super(pSubject, pCode);
    public LicenseHeaderClaim(IDocument pSubject, LicenseFamilyCode pCode) {
import org.apache.rat.api.MetaData;
    private boolean writtenDocumentClaims = false;
            if(!writtenDocumentClaims) {
                writeDocumentClaims(subject);
                writtenDocumentClaims = true;
            }
                    if(!writtenDocumentClaims) {
                        writeDocumentClaims(lastSubject);
                    }
                writtenDocumentClaims = false;
    private void writeDocumentClaims(final IDocument subject) throws IOException, RatReportFailedException {
        final MetaData metaData = subject.getMetaData();
        final MetaData.Datum sampleDatum = metaData.get(MetaData.RAT_URL_HEADER_SAMPLE);
        if (sampleDatum != null) {
            final String sample = sampleDatum.getValue();
            if (sample != null) {
                writeClaim(HEADER_SAMPLE_PREDICATE, sample, true);
            }
        }
    }

import org.apache.rat.api.MetaData;
        subject.getMetaData().set(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_GEN);
import org.apache.rat.api.MetaData;
        subject.getMetaData().set(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_GEN);
    public static final String RAT_URL_LICENSE_FAMILY_CATEGORY= RAT_BASE_URL  "LicenseFamilyCategory";
    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_GEN = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY, RAT_LICENSE_FAMILY_CATEGORY_VALUE_GEN);
    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_UNKNOWN = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY, RAT_LICENSE_FAMILY_CATEGORY_VALUE_UNKNOWN);
    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_ASL = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY, RAT_LICENSE_FAMILY_CATEGORY_VALUE_ASL);
    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_OASIS = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY, RAT_LICENSE_FAMILY_CATEGORY_VALUE_OASIS);
    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_W3CD = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY, RAT_LICENSE_FAMILY_CATEGORY_VALUE_W3CD);
    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_W3C = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY, RAT_LICENSE_FAMILY_CATEGORY_VALUE_W3C);
    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_DOJO = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY, RAT_LICENSE_FAMILY_CATEGORY_VALUE_DOJO);
    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_TMF = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY, RAT_LICENSE_FAMILY_CATEGORY_VALUE_TMF);
            final MetaData.Datum licenseFamilyCategoryDatum = metaData.get(MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY);
            if (licenseFamilyCategoryDatum != null) {
                final String licenseFamilyCategory = licenseFamilyCategoryDatum.getValue();
                writeClaim(LICENSE_FAMILY_PREDICATE, licenseFamilyCategory, false);
            }
        subject.getMetaData().set(new MetaData.Datum(MetaData.RAT_URL_HEADER_CATEGORY, code.getName()));
    // Header Categories
    public static final String RAT_URL_HEADER_CATEGORY= RAT_BASE_URL  "HeaderCategory";
    
                    subject.getMetaData().set(new MetaData.Datum(MetaData.RAT_URL_HEADER_CATEGORY, MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_UNKNOWN));
    
    public String toString() {
        return "LicenseFamilyCode:"  name;
    }
import org.apache.rat.api.MetaData;
    private IDocument subject;
    private boolean writtenDocumentClaims = false;
    
        // Does Nothing
    protected void handleHeaderCategoryClaim(String headerCategory) {
        writeDocumentClaimsWhenNecessary(subject);
    
    private void writeDocumentClaim(IDocument subject)  {
        final MetaData.Datum headerCategoryDatum = subject.getMetaData().get(MetaData.RAT_URL_HEADER_CATEGORY);
        if (headerCategoryDatum != null) {
            final String headerCategory = headerCategoryDatum.getValue();
            if (headerCategory != null) {
                handleHeaderCategoryClaim(headerCategory);
            }
        }
    }
    
    public void report(IDocument subject) throws RatReportFailedException {
        writeDocumentClaimsWhenNecessary(subject);
        this.subject = subject;
        writtenDocumentClaims = false;
    }

    private void writeDocumentClaimsWhenNecessary(IDocument subject) {
        if (!writtenDocumentClaims && subject != null) {
            writeDocumentClaim(subject);
            writtenDocumentClaims = true;
        }
    }
import org.apache.rat.api.MetaData;
    protected void handleHeaderCategoryClaim(String headerCategory) {
        
        if (MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_GEN.equals(headerCategory)) {
            incMapValue(numsByLicenseFamilyCode, LicenseFamilyCode.GENERATED);
        } else if (MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_UNKNOWN.equals(headerCategory)) {
            incMapValue(numsByLicenseFamilyCode, LicenseFamilyCode.UNKNOWN);
public class LicenseFamilyClaim extends AbstractClaim {
    private final LicenseFamilyCode code;
        super(pSubject);
        this.code = pCode;
    public LicenseFamilyCode getCode() {
        return code;
    }
    
            writtenDocumentClaims = false;
            final MetaData.Datum headerCategoryDatum = metaData.get(MetaData.RAT_URL_HEADER_CATEGORY);
            if (headerCategoryDatum != null) {
                final String headerCategory = headerCategoryDatum.getValue();
                writeClaim(HEADER_TYPE_PREDICATE, headerCategory, false);
            }
        
        public String toString() {
            return "File:"  file.getAbsolutePath();
        }
import org.apache.rat.api.MetaData;
		super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_ASL, LicenseFamilyName.APACHE_SOFTWARE_LICENSE_NAME, "");
	private final MetaData.Datum licenseFamilyCategory;
	public BaseLicense(final MetaData.Datum licenseFamilyCategory, final LicenseFamilyName name, final String notes)
		this.licenseFamilyCategory = licenseFamilyCategory;
        subject.getMetaData().set(new MetaData.Datum(MetaData.RAT_URL_HEADER_CATEGORY,licenseFamilyCategory.getValue()));
        subject.getMetaData().set(licenseFamilyCategory);
            reporter.claim(new LicenseFamilyClaim(subject, name));
import org.apache.rat.api.MetaData;
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_DOJO, LicenseFamilyName.MODIFIED_BSD_LICENSE_NAME, "Dual license AFL/BSD");
import org.apache.rat.api.MetaData;
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_OASIS, LicenseFamilyName.OASIS_OPEN_LICENSE_NAME, "No modifications allowed");
import org.apache.rat.api.MetaData;
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_TMF, LicenseFamilyName.MODIFIED_BSD_LICENSE_NAME, "BSD");
import org.apache.rat.api.MetaData;
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_W3CD, LicenseFamilyName.W3C_DOCUMENT_COPYRIGHT_NAME,  NOTES);
import org.apache.rat.api.MetaData;
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_W3C, LicenseFamilyName.W3C_SOFTWARE_COPYRIGHT_NAME,  NOTES);
					reporter.claim(new LicenseFamilyClaim(subject, LicenseFamilyName.UNKNOWN_LICENSE_FAMILY));
     * keys are license family category names,
     * keys are instances of license family category names and
            incMapValue(numsByLicenseFamilyCode, MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_GEN);
            incMapValue(numsByLicenseFamilyCode, MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_UNKNOWN);
    public LicenseFamilyClaim(IDocument pSubject, LicenseFamilyName pName) {
import org.apache.rat.api.MetaData;
        super(new MetaData.Datum(MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY, ""), new LicenseFamilyName(""), "");
import org.apache.rat.api.MetaData;
    	super(new MetaData.Datum(MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY, "EXMPL"), new LicenseFamilyName("Example License"), "");
		super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_ASL, MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_APACHE_LICENSE_VERSION_2_0, "");
	private final MetaData.Datum licenseFamilyName;
	public BaseLicense(final MetaData.Datum licenseFamilyCategory, final MetaData.Datum licenseFamilyName, final String notes)
		this.licenseFamilyName = licenseFamilyName;
        final MetaData metaData = subject.getMetaData();
        metaData.set(new MetaData.Datum(MetaData.RAT_URL_HEADER_SAMPLE, notes));
        metaData.set(new MetaData.Datum(MetaData.RAT_URL_HEADER_CATEGORY,licenseFamilyCategory.getValue()));
        metaData.set(licenseFamilyCategory);
        metaData.set(licenseFamilyName);
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_DOJO, MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_MODIFIED_BSD_LICENSE, "Dual license AFL/BSD");
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_OASIS, MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_OASIS_OPEN_LICENSE, "No modifications allowed");
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_TMF, 
                MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_MODIFIED_BSD_LICENSE, "BSD");
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_W3CD, 
                MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_W3C_DOCUMENT_COPYRIGHT,  NOTES);
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_W3C, 
                MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_W3C_SOFTWARE_COPYRIGHT,  NOTES);
    public static final String RAT_URL_HEADER_CATEGORY= RAT_BASE_URL  "#HeaderCategory";
    public static final String RAT_URL_LICENSE_FAMILY_CATEGORY= RAT_BASE_URL  "#LicenseFamilyCategory";
    public static final String RAT_URL_LICENSE_FAMILY_NAME= RAT_BASE_URL  "#LicenseFamilyName";
    public static final Datum RAT_LICENSE_FAMILY_NAME_DATUM_W3C_SOFTWARE_COPYRIGHT 
        = new Datum(RAT_URL_LICENSE_FAMILY_NAME, RAT_LICENSE_FAMILY_NAME_VALUE_W3C_SOFTWARE_COPYRIGHT);
    public static final Datum RAT_LICENSE_FAMILY_NAME_DATUM_W3C_DOCUMENT_COPYRIGHT 
        = new Datum(RAT_URL_LICENSE_FAMILY_NAME, RAT_LICENSE_FAMILY_NAME_VALUE_W3C_DOCUMENT_COPYRIGHT);
    public static final Datum RAT_LICENSE_FAMILY_NAME_DATUM_OASIS_OPEN_LICENSE 
        = new Datum(RAT_URL_LICENSE_FAMILY_NAME, RAT_LICENSE_FAMILY_NAME_VALUE_OASIS_OPEN_LICENSE);
    public static final Datum RAT_LICENSE_FAMILY_NAME_DATUM_MODIFIED_BSD_LICENSE 
        = new Datum(RAT_URL_LICENSE_FAMILY_NAME, RAT_LICENSE_FAMILY_NAME_VALUE_MODIFIED_BSD_LICENSE);
    public static final Datum RAT_LICENSE_FAMILY_NAME_DATUM_APACHE_LICENSE_VERSION_2_0
        = new Datum(RAT_URL_LICENSE_FAMILY_NAME, RAT_LICENSE_FAMILY_NAME_VALUE_APACHE_LICENSE_VERSION_2_0);
    public static final Datum RAT_LICENSE_FAMILY_NAME_DATUM_ACADEMIC_FREE_LICENSE_VERSION_2_1
        = new Datum(RAT_URL_LICENSE_FAMILY_NAME, RAT_LICENSE_FAMILY_NAME_VALUE_ACADEMIC_FREE_LICENSE_VERSION_2_1);
    public static final Datum RAT_LICENSE_FAMILY_NAME_DATUM_UNKNOWN
        = new Datum(RAT_URL_LICENSE_FAMILY_NAME, RAT_LICENSE_FAMILY_NAME_VALUE_UNKNOWN); 
import org.apache.rat.api.MetaData;
    public String getFamilyName() {
        return MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_ACADEMIC_FREE_LICENSE_VERSION_2_1;
import org.apache.rat.api.MetaData;
    public String getFamilyName() {
        return MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_APACHE_LICENSE_VERSION_2_0;
    public String getFamilyName();
import org.apache.rat.api.MetaData;
    public String getFamilyName() {
        return MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_MODIFIED_BSD_LICENSE;
import org.apache.rat.api.MetaData;
    public String getFamilyName() {
        return MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_OASIS_OPEN_LICENSE;
import org.apache.rat.api.MetaData;
    public String getFamilyName() {
        return MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_W3C_DOCUMENT_COPYRIGHT;
import org.apache.rat.api.MetaData;
    public String getFamilyName() {
        return MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_W3C_SOFTWARE_COPYRIGHT;
import org.apache.rat.api.MetaData;
    private static final String[] APPROVED_LICENSES = {
        MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_APACHE_LICENSE_VERSION_2_0,
        MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_OASIS_OPEN_LICENSE,
        MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_W3C_SOFTWARE_COPYRIGHT,
        MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_W3C_DOCUMENT_COPYRIGHT,
        MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_MODIFIED_BSD_LICENSE
    private static final String[] toNames(final ILicenseFamily[] approvedLicenses) {
        String[] results = null;
            results = new String[length];
    private final String[] approvedLicenseNames;
    private boolean testedDocument = false;
    public DefaultPolicy(final IClaimReporter reporter, final String[] approvedLicenseNames) {
            this.approvedLicenseNames = new String[length];
        Arrays.sort(this.approvedLicenseNames);
        testDocumentWhenNecessary(subject);
    }

    private void testDocumentWhenNecessary(final IDocument subject) throws RatReportFailedException {
        if (!testedDocument && subject != null) {
            final MetaData.Datum nameDatum = subject.getMetaData().get(MetaData.RAT_URL_LICENSE_FAMILY_NAME);
            if (nameDatum != null) {
                final String name = nameDatum.getValue();
                final boolean isApproved = Arrays.binarySearch(approvedLicenseNames, name) >= 0;
                reportLicenseApprovalClaim(subject, isApproved, reporter);
            }
            testedDocument = true;
    
        testDocumentWhenNecessary(this.subject);
        testedDocument = false;
                    final MetaData metaData = subject.getMetaData();
                    metaData.set(new MetaData.Datum(MetaData.RAT_URL_HEADER_SAMPLE, notes));
                    metaData.set(new MetaData.Datum(MetaData.RAT_URL_HEADER_CATEGORY, MetaData.RAT_LICENSE_FAMILY_CATEGORY_VALUE_UNKNOWN));
                    metaData.set(MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_UNKNOWN);
     * keys are the names of the license families and
     * keys are the name of the license families and
    protected void handleLicenseFamilyNameClaim(String licenseFamilyName) {
        final MetaData.Datum licenseFamilyNameDatum = subject.getMetaData().get(MetaData.RAT_URL_LICENSE_FAMILY_NAME);
        if (licenseFamilyNameDatum != null) {
            final String licenseFamilyName = licenseFamilyNameDatum.getName();
            if (licenseFamilyName != null) {
                handleLicenseFamilyNameClaim(licenseFamilyName);
            }
        }
    protected void handleLicenseFamilyNameClaim(String licenseFamilyName) {
        incMapValue(numsByLicenseFamilyName, licenseFamilyName);
        writeHeaderSample(metaData);
        writeLicenseFamilyCategory(metaData);
        writeHeaderCategory(metaData);
        writeLicenseFamilyName(metaData);
    }

    private void writeLicenseFamilyName(final MetaData metaData) throws IOException, RatReportFailedException {
        final MetaData.Datum licenseFamilyNameDatum = metaData.get(MetaData.RAT_URL_LICENSE_FAMILY_NAME);
        if (licenseFamilyNameDatum != null) {
            final String licenseFamilyName = licenseFamilyNameDatum.getValue();
            if (licenseFamilyName != null) {
                writeClaim(LICENSE_FAMILY_PREDICATE, licenseFamilyName, false);
            }
        }
    }

    private void writeHeaderCategory(final MetaData metaData) throws IOException, RatReportFailedException {
        final MetaData.Datum headerCategoryDatum = metaData.get(MetaData.RAT_URL_HEADER_CATEGORY);
        if (headerCategoryDatum != null) {
            final String headerCategory = headerCategoryDatum.getValue();
            writeClaim(HEADER_TYPE_PREDICATE, headerCategory, false);
        }
    }

    private void writeLicenseFamilyCategory(final MetaData metaData) throws IOException, RatReportFailedException {
        final MetaData.Datum licenseFamilyCategoryDatum = metaData.get(MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY);
        if (licenseFamilyCategoryDatum != null) {
            final String licenseFamilyCategory = licenseFamilyCategoryDatum.getValue();
            writeClaim(LICENSE_FAMILY_PREDICATE, licenseFamilyCategory, false);
        }
    }

    private void writeHeaderSample(final MetaData metaData) throws IOException, RatReportFailedException {
        super(new MetaData.Datum(MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY, ""), 
                new MetaData.Datum(MetaData.RAT_URL_LICENSE_FAMILY_NAME, ""), "");
    public String getFamilyName() {
    	return "Example License";
    	super(new MetaData.Datum(MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY, "EXMPL"), 
                new MetaData.Datum(MetaData.RAT_URL_LICENSE_FAMILY_NAME, "Example License"), "");
    public static final String RAT_URL_HEADER_CATEGORY = RAT_BASE_URL  "#HeaderCategory";
    public static final String RAT_URL_HEADER_SAMPLE = RAT_BASE_URL  "#HeaderSample";
    
    // License Approval
    public static final String RAT_URL_APPROVED_LICENSE = RAT_BASE_URL  "#ApprovedLicense";
    public static final String RAT_APPROVED_LICENSE_VALUE_TRUE = Boolean.TRUE.toString();
    public static final String RAT_APPROVED_LICENSE_VALUE_FALSE = Boolean.FALSE.toString();
    public static final Datum RAT_APPROVED_LICENSE_DATIM_TRUE = new Datum(RAT_URL_APPROVED_LICENSE, RAT_APPROVED_LICENSE_VALUE_TRUE);
    public static final Datum RAT_APPROVED_LICENSE_DATIM_FALSE = new Datum(RAT_URL_APPROVED_LICENSE, RAT_APPROVED_LICENSE_VALUE_FALSE);
     * Gets the value of the first datum matching the given name.
     * @param name not null
     * @return the value of the matchin datum first added when there is any matching data,
     * null otherwise
     */
    public String value(final String name) {
        final Datum datum = get(name);
        final String result;
        if (datum == null) {
            result = null;
        } else {
            result = datum.getValue();
        }
        return result;
    }
    
    /**
import org.apache.rat.api.MetaData.Datum;
    ;
    public DefaultPolicy() {
        this(APPROVED_LICENSES);
    public DefaultPolicy(final ILicenseFamily[] approvedLicenses) {
        this(toNames(approvedLicenses));
    public DefaultPolicy(final String[] approvedLicenseNames) {
                reportLicenseApprovalClaim(subject, isApproved);
    public void reportLicenseApprovalClaim(final IDocument subject, final boolean isAcceptable) throws RatReportFailedException {
        final Datum datum;
        if (isAcceptable) {
            datum = MetaData.RAT_APPROVED_LICENSE_DATIM_TRUE;
        } else {
            datum = MetaData.RAT_APPROVED_LICENSE_DATIM_FALSE;
        }
        subject.getMetaData().set(datum);
    protected void handleApprovedLicenseClaim(String licenseApproved) {
        final MetaData metaData = subject.getMetaData();
        writeHeaderCategory(metaData);
        writeLicenseFamilyName(metaData);
        final MetaData.Datum approvedLicenseDatum = metaData.get(MetaData.RAT_URL_APPROVED_LICENSE);
        if (approvedLicenseDatum != null) {
            final String approvedLicense = approvedLicenseDatum.getValue();
            if (approvedLicense != null) {
                handleApprovedLicenseClaim(approvedLicense);
            }
        }
    }

    private void writeHeaderCategory(final MetaData metaData) {
        final MetaData.Datum headerCategoryDatum = metaData.get(MetaData.RAT_URL_HEADER_CATEGORY);
    }

    private void writeLicenseFamilyName(final MetaData metaData) {
        final MetaData.Datum licenseFamilyNameDatum = metaData.get(MetaData.RAT_URL_LICENSE_FAMILY_NAME);
    protected void handleApprovedLicenseClaim(String licenseApproved) {
        if (MetaData.RAT_APPROVED_LICENSE_VALUE_TRUE.equals(licenseApproved)) {
        writeApprovedLicense(metaData);
        
    }

    private void writeApprovedLicense(final MetaData metaData) throws IOException, RatReportFailedException {
        final MetaData.Datum approvedLicenseDatum = metaData.get(MetaData.RAT_URL_APPROVED_LICENSE);
        if (approvedLicenseDatum != null) {
            final String approvedLicense = approvedLicenseDatum.getValue();
            if (approvedLicense != null) {
                writeClaim(LICENSE_APPROVAL_PREDICATE, approvedLicense, false);
            }
        }
        final DefaultPolicy policy = new DefaultPolicy(approvedLicenses);
        final IClaimReporter[] reporters = {policy, reporter};
    public static final String RAT_URL_DOCUMENT_CATEGORY = RAT_BASE_URL  "#FileCategory";
    public static final Datum RAT_DOCUMENT_CATEGORY_DATUM_GENERATED = new Datum(RAT_URL_DOCUMENT_CATEGORY, RAT_DOCUMENT_CATEGORY_VALUE_GENERATED);
    public static final Datum RAT_DOCUMENT_CATEGORY_DATUM_UNKNOWN = new Datum(RAT_URL_DOCUMENT_CATEGORY, RAT_DOCUMENT_CATEGORY_VALUE_UNKNOWN);
    public static final Datum RAT_DOCUMENT_CATEGORY_DATUM_ARCHIVE = new Datum(RAT_URL_DOCUMENT_CATEGORY, RAT_DOCUMENT_CATEGORY_VALUE_ARCHIVE);
    public static final Datum RAT_DOCUMENT_CATEGORY_DATUM_NOTICE = new Datum(RAT_URL_DOCUMENT_CATEGORY, RAT_DOCUMENT_CATEGORY_VALUE_NOTICE);
    public static final Datum RAT_DOCUMENT_CATEGORY_DATUM_BINARY = new Datum(RAT_URL_DOCUMENT_CATEGORY, RAT_DOCUMENT_CATEGORY_VALUE_BINARY);
    public static final Datum RAT_DOCUMENT_CATEGORY_DATUM_STANDARD = new Datum(RAT_URL_DOCUMENT_CATEGORY, RAT_DOCUMENT_CATEGORY_VALUE_STANDARD);
     * Clears all data.
     */
    public void clear() {
        data.clear();
        this.contentType = null;
    }
    
    /**
import org.apache.rat.document.IDocumentAnalyser;
import org.apache.rat.document.RatDocumentAnalysisException;
public class DefaultPolicy implements IDocumentAnalyser {
    public void reportLicenseApprovalClaim(final IDocument subject, final boolean isAcceptable) {
    public void analyse(final IDocument subject) throws RatDocumentAnalysisException {
        if (subject != null) {
            final String name = subject.getMetaData().value(MetaData.RAT_URL_LICENSE_FAMILY_NAME);
            if (name != null) {
                final boolean isApproved = Arrays.binarySearch(approvedLicenseNames, name) >= 0;
                reportLicenseApprovalClaim(subject, isApproved);
            }
        }
import org.apache.rat.api.MetaData;
        public void analyse(IDocument subject) throws RatDocumentAnalysisException {
            final MetaData.Datum documentCategory;
            if (NoteGuesser.isNote(subject)) {
                documentCategory = MetaData.RAT_DOCUMENT_CATEGORY_DATUM_NOTICE;
            } else if (ArchiveGuesser.isArchive(subject)) {
                documentCategory = MetaData.RAT_DOCUMENT_CATEGORY_DATUM_ARCHIVE;
            } else if (BinaryGuesser.isBinary(subject)) {
                documentCategory = MetaData.RAT_DOCUMENT_CATEGORY_DATUM_BINARY;
            } else {
                documentCategory = MetaData.RAT_DOCUMENT_CATEGORY_DATUM_STANDARD;
                final DocumentHeaderAnalyser headerAnalyser = new DocumentHeaderAnalyser(matcher, reporter);
                headerAnalyser.analyse(subject);
            subject.getMetaData().set(documentCategory);
    private Map documentCategoryMap, licenseFamilyCodeMap, licenseFamilyNameMap;
     * are file type names and the map values
    public void setDocumentCategoryMap(Map pDocumentCategoryMap) {
        documentCategoryMap = pDocumentCategoryMap;
     * are file type names and the map values
    public Map getDocumentCategoryMap() {
        return documentCategoryMap;
    protected void handleDocumentCategoryClaim(String documentCategoryName) {
        if (pClaim instanceof CustomClaim) {
        writeDocumentCategory(metaData);
        writeApprovedLicenseClaim(metaData);
    }

    private void writeApprovedLicenseClaim(final MetaData metaData) {
            final String licenseFamilyName = licenseFamilyNameDatum.getValue();
    private void writeDocumentCategory(final MetaData metaData) {
        final MetaData.Datum documentCategoryDatum = metaData.get(MetaData.RAT_URL_DOCUMENT_CATEGORY);
        if (documentCategoryDatum != null) {
            final String documentCategory = documentCategoryDatum.getValue();
            if (documentCategory != null) {
                handleDocumentCategoryClaim(documentCategory);
            }
    
    public void report(IDocument subject) throws RatReportFailedException {
        writeDocumentClaim(subject);
    }
    protected void handleDocumentCategoryClaim(String documentCategoryName) {
        incMapValue(numsByFileType, documentCategoryName);
        pStatistic.setDocumentCategoryMap(numsByFileType);
    private boolean firstTime = true;

    throws IOException, RatReportFailedException {
    throws IOException, RatReportFailedException {

        if (pClaim instanceof CustomClaim) {
                     " claim type: "
            if (firstTime) {
                firstTime = false;
            } else {
                writer.closeElement();
            writer.openElement("resource").attribute(NAME, subject.getName());
            writeDocumentClaims(subject);
        writeDocumentCategory(metaData);
        final String approvedLicense = metaData.value(MetaData.RAT_URL_APPROVED_LICENSE);
        if (approvedLicense != null) {
            writeClaim(LICENSE_APPROVAL_PREDICATE, approvedLicense, false);
        final String licenseFamilyName = metaData.value(MetaData.RAT_URL_LICENSE_FAMILY_NAME);
        if (licenseFamilyName != null) {
            writeClaim(LICENSE_FAMILY_PREDICATE, licenseFamilyName, false);
        final String headerCategory = metaData.value(MetaData.RAT_URL_HEADER_CATEGORY);
        if (headerCategory != null) {
        final String licenseFamilyCategory = metaData.value(MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY);
        if (licenseFamilyCategory != null) {
        final String sample = metaData.value(MetaData.RAT_URL_HEADER_SAMPLE);
        if (sample != null) {
            writeClaim(HEADER_SAMPLE_PREDICATE, sample, true);
    private void writeDocumentCategory(final MetaData metaData) throws IOException, RatReportFailedException {
        final String documentCategory = metaData.value(MetaData.RAT_URL_DOCUMENT_CATEGORY);
        if (documentCategory != null) {
            writeClaim(FILE_TYPE_PREDICATE, documentCategory, false);
        }
    }
import org.apache.rat.report.claim.IClaimReporter;
    private final IClaimReporter reporter;
    public XmlReport(final IXmlWriter writer, IDocumentAnalyser analyser, final IClaimReporter reporter) {
        this.reporter = reporter;
    public void report(IDocument subject) throws RatReportFailedException {
            analyser.analyse(subject);
            reporter.report(subject);
import org.apache.rat.document.impl.util.DocumentAnalyserMultiplexer;
            DefaultAnalyserFactory.createDefaultAnalyser(reporter, matcher);
        final IDocumentAnalyser[] analysers = {analyser, policy};
        DocumentAnalyserMultiplexer analysisMultiplexer = new DocumentAnalyserMultiplexer(analysers);
        
        final RatReport result = new XmlReport(writer, analysisMultiplexer, reporter);
            document.getMetaData().clear();
                document.getMetaData().clear();
    private int numApproved, numUnApproved, numGenerated, numUnknown;
        throw new IllegalStateException("Unsupported type of claim: "  pClaim.getClass().getName());
    private int numApproved, numUnApproved, numGenerated, numUnknown;
        throw new IllegalStateException("Invalid claim type: "  pClaim.getClass().getName());
import org.apache.rat.api.Document;
import org.apache.rat.api.RatException;
	   * @throws RatException
    private void processDirectory(RatReport  report, final File file) throws RatException {
    public void run(final RatReport report) throws RatException {
     * @throws RatException
    private void process(final RatReport report, final File file) throws RatException {
     * @throws RatException
    private void processDirectories(final RatReport report, final File[] files) throws RatException {
     * @throws RatException
    private void processNonDirectories(final RatReport report, final File[] files) throws RatException {
     * @throws RatException
    private void report(final RatReport report, File file) throws RatException {
        Document document = new FileDocument(file);
import org.apache.rat.api.RatException;
     * @throws RatException
           InterruptedException, RatException {
     * @throws RatException
                throws IOException, TransformerConfigurationException, FileNotFoundException, InterruptedException, RatException {
     * @throws RatException
             final ILicenseFamily[] approvedLicenseNames) throws IOException, RatException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
	public boolean match(Document subject, String line, Reporter reporter) throws RatHeaderAnalysisException;
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
    public boolean match(Document subject, String line, Reporter reporter) throws RatHeaderAnalysisException {
    private void reportOnLicense(Document subject, Reporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
    public boolean match(Document subject, String line, Reporter reporter) throws RatHeaderAnalysisException {
    private void reportOnLicense(Document subject, Reporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
	public boolean match(Document subject, String line, Reporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
    public final void reportOnLicense(Document subject, Reporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
    public boolean match(Document subject, String line, Reporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
    public boolean match(Document subject, String line, Reporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
    public boolean match(Document subject, String line, Reporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
    public boolean match(Document subject, String line, Reporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
    public boolean match(Document subject, String line, Reporter reporter) throws RatHeaderAnalysisException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
	public boolean match(Document subject, String line, Reporter reporter) throws RatHeaderAnalysisException {
 b/apache-rat-core/src/main/java/org/apache/rat/api/Document.java
package org.apache.rat.api;
import org.apache.rat.document.CompositeDocumentException;
public interface Document {
 b/apache-rat-core/src/main/java/org/apache/rat/api/RatException.java
package org.apache.rat.api;
public class RatException extends Exception {
    public RatException() {
    public RatException(String message, Throwable cause) {
    public RatException(String message) {
    public RatException(Throwable cause) {
 b/apache-rat-core/src/main/java/org/apache/rat/api/Reporter.java
package org.apache.rat.api;
public interface Reporter {
    void report(Document subject) throws RatException;
import org.apache.rat.api.Document;

    public void analyse(Document document) throws RatDocumentAnalysisException;
import org.apache.rat.api.Document;
        if (subject != null && subject instanceof Document) {
            Document location = (Document) subject;
import org.apache.rat.api.Document;
public abstract class AbstractMonolithicDocument implements Document {
import org.apache.rat.api.Document;
public class FileDocument implements Document {
import org.apache.rat.api.Document;
    public static Document newInstance(final URL url) {
import org.apache.rat.api.Document;
    public static final boolean isArchive(final Document document) {
import org.apache.rat.api.Document;
    private static boolean isBinaryDocument(Document document) {
    public static final boolean isBinary(final Document document) {
import org.apache.rat.api.Document;
    public static final boolean isNote(final Document document) {
import org.apache.rat.api.Document;
    public void analyse(Document document) throws RatDocumentAnalysisException {
import org.apache.rat.api.Document;
    public void reportLicenseApprovalClaim(final Document subject, final boolean isAcceptable) {
    public void analyse(final Document subject) throws RatDocumentAnalysisException {
import org.apache.rat.api.RatException;

    public void run(RatReport report) throws RatException;
import org.apache.rat.api.Document;
import org.apache.rat.api.RatException;
    public void startReport() throws RatException;
    public void report(Document document) throws RatException;
    public void endReport() throws RatException;
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
    public static final IDocumentAnalyser createDefaultAnalyser(final Reporter reporter, 
        private final Reporter reporter;
        public DefaultAnalyser(final Reporter reporter, final IHeaderMatcher matcher) {
        public void analyse(Document subject) throws RatDocumentAnalysisException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
    private final Reporter reporter;
    public DocumentHeaderAnalyser(final IHeaderMatcher matcher, final Reporter reporter) {
    public void analyse(Document document) throws RatDocumentAnalysisException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
	private final Reporter reporter;
    private final Document subject;
            final IHeaderMatcher matcher, final Reporter reporter, final Document name) {
	public HeaderCheckWorker(Reader reader, final IHeaderMatcher matcher, final Reporter reporter, final Document name) {
            final Reporter reporter, final Document name) {
            final Reporter reporter, final Document name) {
import org.apache.rat.api.RatException;
    public RatReportAnalysisResultException(RatException cause) {
    public RatReportAnalysisResultException(String msg, RatException cause) {
import org.apache.rat.api.Document;
import org.apache.rat.api.RatException;
import org.apache.rat.api.Reporter;
 * Abstract base implementation of {@link Reporter}.
public abstract class AbstractClaimReporter implements Reporter {
    private void writeDocumentClaim(Document subject)  {
    public void report(Document subject) throws RatException {
import org.apache.rat.api.Document;
import org.apache.rat.api.RatException;
import org.apache.rat.api.Reporter;
    private final Reporter reporter;
    public ClaimAggregator(Reporter pReporter) {
    public void report(Document document) throws RatException {
import org.apache.rat.api.Document;
import org.apache.rat.api.RatException;
import org.apache.rat.api.Reporter;
public class SimpleXmlClaimReporter implements Reporter {
     * @throws RatException Another error occurred while writing the claim.
    throws IOException, RatException {
    public void report(final Document subject) throws RatException {
            throw new RatException("XML writing failure: "  e.getMessage()
    private void writeDocumentClaims(final Document subject) throws IOException, RatException {
    private void writeApprovedLicense(final MetaData metaData) throws IOException, RatException {
    private void writeLicenseFamilyName(final MetaData metaData) throws IOException, RatException {
    private void writeHeaderCategory(final MetaData metaData) throws IOException, RatException {
    private void writeLicenseFamilyCategory(final MetaData metaData) throws IOException, RatException {
    private void writeHeaderSample(final MetaData metaData) throws IOException, RatException {
    private void writeDocumentCategory(final MetaData metaData) throws IOException, RatException {
import org.apache.rat.api.Document;
import org.apache.rat.api.RatException;
import org.apache.rat.api.Reporter;
public class ClaimReporterMultiplexer implements Reporter {
    private final Reporter[] reporters;
    public ClaimReporterMultiplexer(final Reporter[] reporters) {
    public void report(Document document) throws RatException {
import org.apache.rat.api.Document;
import org.apache.rat.api.RatException;
import org.apache.rat.api.Reporter;
    private final Reporter reporter;
    public XmlReport(final IXmlWriter writer, IDocumentAnalyser analyser, final Reporter reporter) {
    public void startReport() throws RatException {
            throw new RatException("Cannot open start element", e);
    public void endReport() throws RatException {
            throw new RatException("Cannot close last element", e);
    public void report(Document subject) throws RatException {
            throw new RatException("Analysis failed", e);
import org.apache.rat.api.Document;
import org.apache.rat.api.RatException;
import org.apache.rat.api.Reporter;
        final Reporter reporter;
            public void endReport() throws RatException {
            public void report(Document pDocument)
                    throws RatException {
            public void startReport() throws RatException {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
	public boolean match(Document subject, String line, Reporter reporter) {
import org.apache.rat.api.Document;
public class MockDocument implements Document {
import org.apache.rat.api.Document;

    public void analyse(Document document) throws RatDocumentAnalysisException {
import org.apache.rat.api.Document;
public class MockLocation implements Document {
import org.apache.rat.api.Document;
import org.apache.rat.api.RatException;
import org.apache.rat.api.Reporter;
public class MockClaimReporter implements Reporter {
    public void report(Document document) throws RatException {
import org.apache.rat.api.RatException;
        catch ( RatException e )
import org.apache.rat.api.Document;
import org.apache.rat.api.RatException;
    public void run( RatReport report ) throws RatException
    private class FileDocument implements Document
import org.apache.rat.api.RatException;
        } catch (RatException e) {
     * @throws RatException 
    private void createReport(PrintWriter out) throws IOException, TransformerException, InterruptedException, RatException {
import org.apache.rat.api.Document;
import org.apache.rat.api.RatException;
    public void run(RatReport report) throws RatException {
    private class ResourceDocument implements Document {
import org.apache.rat.api.Document;
import org.apache.rat.api.Reporter;
    public boolean match(Document subject, String line, Reporter reporter) throws RatHeaderAnalysisException {
	public boolean match(Document subject, String line) throws RatHeaderAnalysisException;
    public boolean match(Document subject, String line) throws RatHeaderAnalysisException {
                reportOnLicense(subject);
    private void reportOnLicense(Document subject) throws RatHeaderAnalysisException {
    public boolean match(Document subject, String line) throws RatHeaderAnalysisException {
            reportOnLicense(subject);
    private void reportOnLicense(Document subject) throws RatHeaderAnalysisException {
	public boolean match(Document subject, String line) throws RatHeaderAnalysisException {
			reportOnLicense(subject);
    public final void reportOnLicense(Document subject) throws RatHeaderAnalysisException {
    public boolean match(Document subject, String line) throws RatHeaderAnalysisException {
            reportOnLicense(subject);
    public boolean match(Document subject, String line) throws RatHeaderAnalysisException {
                reportOnLicense(subject);
    public boolean match(Document subject, String line) throws RatHeaderAnalysisException {
            reportOnLicense(subject);
    public boolean match(Document subject, String line) throws RatHeaderAnalysisException {
            reportOnLicense(subject);
    public boolean match(Document subject, String line) throws RatHeaderAnalysisException {
            reportOnLicense(subject);
	public boolean match(Document subject, String line) throws RatHeaderAnalysisException {
			result = matchers[i].match(subject, line);
            match = matcher.match(subject, line);
	public boolean match(Document subject, String line) {
    public boolean match(Document subject, String line) throws RatHeaderAnalysisException {
    	reportOnLicense(subject);
    public static final IDocumentAnalyser createDefaultAnalyser(final IHeaderMatcher matcher) {
        return new DefaultAnalyser(matcher);
        public DefaultAnalyser(final IHeaderMatcher matcher) {
                final DocumentHeaderAnalyser headerAnalyser = new DocumentHeaderAnalyser(matcher);
    public DocumentHeaderAnalyser(final IHeaderMatcher matcher) {
            HeaderCheckWorker worker = new HeaderCheckWorker(reader, matcher, document);
            final IHeaderMatcher matcher, final Document name) {
		this(new BufferedReader(reader), numberOfRetainedHeaderLine, matcher, name);
	 * @param name the name of the checked content, possibly null
	public HeaderCheckWorker(Reader reader, final IHeaderMatcher matcher, final Document name) {
		this(new BufferedReader(reader), matcher, name);
            final Document name) {
		this(reader, DEFAULT_NUMBER_OF_RETAINED_HEADER_LINES, matcher, name);
            final Document name) {
            DefaultAnalyserFactory.createDefaultAnalyser(matcher);
 b/apache-rat-core/src/main/java/org/apache/rat/analysis/DefaultAnalyserFactory.java
package org.apache.rat.analysis;
 b/apache-rat-core/src/main/java/org/apache/rat/analysis/DocumentHeaderAnalyser.java
package org.apache.rat.analysis;
 b/apache-rat-core/src/main/java/org/apache/rat/analysis/HeaderCheckWorker.java
package org.apache.rat.analysis;
 b/apache-rat-core/src/main/java/org/apache/rat/analysis/RatReportAnalysisResultException.java
package org.apache.rat.analysis;
import org.apache.rat.analysis.DefaultAnalyserFactory;
    //@SuppressWarnings("unchecked")
    public static final void main(String args[]) throws Exception {
        Options opts = new Options();
        Option help = new Option("h", "help", false,
        opts.addOption(help);
        Option addLicence = new Option(
                "a",
                "addLicence",
                false,
        opts.addOption(addLicence);

        Option write = new Option(
                "f",
                "force",
                false,
        opts.addOption(write);
        Option copyright = new Option(
                "c",
                "copyright",
                true,
        opts.addOption(copyright);

        Option xml = new Option(
                "x",
                "xml",
                false,
        opts.addOption(xml);
        PosixParser parser = new PosixParser();
        CommandLine cl = null;
        try {
            cl = parser.parse(opts, args);
        } catch (ParseException e) {
            System.err.println("Please use the \"--help\" option to see a list of valid commands and options");
            System.exit(1);
        }

        if (cl.hasOption('h')) {
            printUsage(opts);
        }


        args = cl.getArgs();
        if (args == null || args.length != 1) {
            printUsage(opts);
            Report report = new Report(args[0]);
            if (cl.hasOption('a')) {
                OutputStream reportOutput = new ByteArrayOutputStream();
                PrintStream stream = new PrintStream(reportOutput, true);
                report.report(stream);

                AbstractLicenceAppender  appender;
                String copyrightMsg = cl.getOptionValue("c");
                if ( copyrightMsg != null) {
                    appender = new ApacheV2LicenceAppender(copyrightMsg);
                } else {
                    appender = new ApacheV2LicenceAppender();
                }
                if (cl.hasOption("f")) {
                    appender.setForce(true);
                }

                DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
                factory.setValidating(false);
                ByteArrayInputStream xmlStream = new ByteArrayInputStream(reportOutput.toString().getBytes("UTF-8"));
                Document doc = factory.newDocumentBuilder().parse(xmlStream);

                NodeList resourceHeaders = doc.getElementsByTagName("header-type");
                String value = null;
                for (int i = 0; i < resourceHeaders.getLength(); i) {
                    Node headerType = resourceHeaders.item(i).getAttributes().getNamedItem("name");
                    if(headerType != null) {
                        value = headerType.getNodeValue();
                    } else {
                        value = null;
                    }
                    if (value != null &&value.equals("?????")) {
                        Node resource = resourceHeaders.item(i).getParentNode();
                        String filename = resource.getAttributes().getNamedItem("name").getNodeValue();
                        File document = new File(filename);
                        appender.append(document);
                    }
                }
            }

            if (cl.hasOption('x')) {
                report.report(System.out);
            } else {
                report.styleReport(System.out);
            }		  
        } 
    }

    private static final void printUsage(Options opts) {
        HelpFormatter f = new HelpFormatter();
        String header = "Options";

        StringBuffer footer = new StringBuffer("\n");
        footer.append("NOTE:\n");
        footer.append("RAT is really little more than a grep ATM\n");
        footer.append("RAT is also rather memory hungry ATM\n");
        footer.append("RAT is very basic ATM\n");
        footer.append("RAT ATM runs on unpacked releases\n");
        footer.append("RAT highlights possible issues\n");
        footer.append("RAT reports require intepretation\n");
        footer.append("RAT often requires some tuning before it runs well against a project\n");
        footer.append("RAT relies on heuristics: it may miss issues\n");

        f.printHelp("java rat.report [options] [DIR]",
                header, opts, footer.toString(), false);
        System.exit(0);
    }

    private final String baseDirectory;

    private Report(String baseDirectory) {
        this.baseDirectory = baseDirectory;
    }

    public ClaimStatistic report(PrintStream out) throws Exception {
    }


    throws IOException, TransformerConfigurationException, 
    InterruptedException, RatException {
    throws IOException, TransformerConfigurationException, FileNotFoundException, InterruptedException, RatException {

            final ILicenseFamily[] approvedLicenseNames) throws IOException, RatException {
import java.io.FilenameFilter;
    private static FilenameFilter regexFilter(final Pattern pattern) {
        return new FilenameFilter() {
            public boolean accept(File dir, String name) {
                final boolean result;
                if (pattern == null) {
                    result = true;
                } else {
                    result = !pattern.matcher(name).matches();
                }
                return result;
            }
        };
    }
    
    private final FilenameFilter filter;
	    this(file, (FilenameFilter) null);
    /**
     * Constructs a walker.
     * @param file not null
     * @param filter filters input files (optional), 
     * or null when no filtering should be performed
     */
    public DirectoryWalker(File file, final FilenameFilter filter) {
        this(file.getPath(), file, filter);
    }
    
        this(file.getPath(), file, regexFilter(ignoreNameRegex));
    private DirectoryWalker(final String name, final File file, final FilenameFilter filter) {
        this.filter = filter;
    protected final boolean ignored(final File file) {
        final String name = file.getName();
        final File dir = file.getParentFile();
        if (filter != null) {
            result = !filter.accept(dir, name);
            if (!ignored(file)) {
            if (!ignored(file)) {
import java.io.FilenameFilter;
    
    private FilenameFilter inputFileFilter = null;
    
    /**
     * Gets the current filter used to select files.
     * @return current file filter, or null when no filter has been set
     */
    public FilenameFilter getInputFileFilter() {
        return inputFileFilter;
    }

    /**
     * Sets the current filter used to select files.
     * @param inputFileFilter filter, or null when no filter has been set
     */
    public void setInputFileFilter(FilenameFilter inputFileFilter) {
        this.inputFileFilter = inputFileFilter;
    }
        final DirectoryWalker base = getDirectory(out);
            result = new DirectoryWalker(base, inputFileFilter);
        final DirectoryWalker base = getDirectory(out);
import java.io.UnsupportedEncodingException;
import javax.xml.parsers.ParserConfigurationException;
import org.apache.commons.cli.OptionBuilder;
import org.apache.commons.io.filefilter.AndFileFilter;
import org.apache.commons.io.filefilter.NotFileFilter;
import org.apache.commons.io.filefilter.WildcardFileFilter;
import org.xml.sax.SAXException;
    private static final char EXCLUDE_CLI = 'e';

        Options opts = buildOptions();
        
        PosixParser parser = new PosixParser();
        CommandLine cl = null;
        try {
            cl = parser.parse(opts, args);
        } catch (ParseException e) {
            System.err.println("Please use the \"--help\" option to see a list of valid commands and options");
            System.exit(1);
        }

        if (cl.hasOption('h')) {
            printUsage(opts);
        }

        args = cl.getArgs();
        if (args == null || args.length != 1) {
            printUsage(opts);
        } else {
            Report report = new Report(args[0]);

            if (cl.hasOption('a')) {
                configureForAddLicense(cl, report);
            }

            if (cl.hasOption(EXCLUDE_CLI)) {
                String[] excludes = cl.getOptionValues(EXCLUDE_CLI);
                if (excludes != null) {
                    final FilenameFilter filter = new NotFileFilter(new WildcardFileFilter(excludes));
                    report.setInputFileFilter(filter);
                }
            }
            
            if (cl.hasOption('x')) {
                report.report(System.out);
            } else {
                report.styleReport(System.out);
            }	
        } 
    }

    private static Options buildOptions() {
        
        final Option exclude = OptionBuilder
                            .withArgName("expression")
                            .withLongOpt("exclude")
                            .hasArgs()
                            .withDescription("Excludes files matching <expression>. " 
                                    "Note that --dir is required when using this parameter. " 
                                    "Allows multiple arguments.")
                            .create(EXCLUDE_CLI);
        opts.addOption(exclude);
        
        Option dir = new Option(
                "d",
                "dir",
                false,
        "Used to indicate source when using --exclude");
        opts.addOption(dir);
        
        return opts;
    }
    private static void configureForAddLicense(CommandLine cl, Report report) throws Exception, UnsupportedEncodingException, SAXException, IOException, ParserConfigurationException {
        OutputStream reportOutput = new ByteArrayOutputStream();
        PrintStream stream = new PrintStream(reportOutput, true);
        report.report(stream);
        AbstractLicenceAppender  appender;
        String copyrightMsg = cl.getOptionValue("c");
        if ( copyrightMsg != null) {
            appender = new ApacheV2LicenceAppender(copyrightMsg);
            appender = new ApacheV2LicenceAppender();
        }
        if (cl.hasOption("f")) {
            appender.setForce(true);
        }
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setValidating(false);
        ByteArrayInputStream xmlStream = new ByteArrayInputStream(reportOutput.toString().getBytes("UTF-8"));
        Document doc = factory.newDocumentBuilder().parse(xmlStream);
        NodeList resourceHeaders = doc.getElementsByTagName("header-type");
        String value = null;
        for (int i = 0; i < resourceHeaders.getLength(); i) {
            Node headerType = resourceHeaders.item(i).getAttributes().getNamedItem("name");
            if(headerType != null) {
                value = headerType.getNodeValue();
                value = null;
            }
            if (value != null &&value.equals("?????")) {
                Node resource = resourceHeaders.item(i).getParentNode();
                String filename = resource.getAttributes().getNamedItem("name").getNodeValue();
                File document = new File(filename);
                appender.append(document);
            }
        }
  private static final int TYPE_PYTHON = 8;
  private static final int TYPE_C      = 9;
  private static final int TYPE_H      = 10;
  private static final int TYPE_SH     = 11;
  private static final int TYPE_BAT    = 12;
        || type == TYPE_C
        || type == TYPE_H
    boolean first = true;
      if (first && type == TYPE_PYTHON) {
        doFirstLine(document, writer, line, "#!/usr/bin");
      } else if (first && type == TYPE_BAT) {
        doFirstLine(document, writer, line, "@echo off");
      } else if (first && type == TYPE_SH) {
        doFirstLine(document, writer, line, "#!/bin");
      } else {
        writer.write(line);
        writer.write('\n');
      }

      first = false;
   * Check first line for specified text and process.
   */
  private void doFirstLine(File document, FileWriter writer, String line, String lookfor) throws IOException  {
    if (line.startsWith(lookfor)) {
        writer.write(line);
        writer.write('\n');
        writer.write(getLicenceHeader(document));
    } else {
        writer.write(getLicenceHeader(document));
        writer.write(line);
        writer.write('\n');
    }
  }

  /**
    } else if (document.getPath().endsWith(".py")) {
      return TYPE_PYTHON;
    } else if (document.getPath().endsWith(".c")) {
      return TYPE_C;
    } else if (document.getPath().endsWith(".h")) {
      return TYPE_H;
    } else if (document.getPath().endsWith(".sh")) {
      return TYPE_SH;
    } else if (document.getPath().endsWith(".bat")) {
      return TYPE_BAT;
      case TYPE_C:    return "/*\n";
      case TYPE_H:    return "/*\n";
      case TYPE_PYTHON:     return "#\n";
      case TYPE_SH:         return "#\n";
      case TYPE_BAT:        return "rem\n";
      case TYPE_C:    return " */\n";
      case TYPE_H:    return " */\n";
      case TYPE_PYTHON:     return "#\n";
      case TYPE_SH:         return "#\n";
      case TYPE_BAT:        return "rem\n";
    if (content != null && content.length() > 0) {
        content = " "  content;
    }
      case TYPE_JAVA: return " *"  content  "\n";
      case TYPE_C:    return " *"  content  "\n";
      case TYPE_H:    return " *"  content  "\n";
      case TYPE_XML: return         content  "\n";
      case TYPE_HTML: return        content  "\n";
      case TYPE_CSS: return " *"   content  "\n";
      case TYPE_JAVASCRIPT: return " *"  content  "\n";
      case TYPE_APT: return "~~"  content  "\n";
      case TYPE_PROPERTIES: return "#"  content  "\n";
      case TYPE_PYTHON:     return "#"  content  "\n";
      case TYPE_SH:         return "#"  content  "\n";
      case TYPE_BAT:        return "rem"  content  "\n";
        "Forces any changes in files to be written directly to the source files (i.e. new files are not created)");
        f.printHelp("java org.apache.org.rat.report [options] [DIR]",
    } else if (document.getPath().endsWith(".rdf") || document.getPath().endsWith(".xsl")) {
        return TYPE_XML;
      sb.append(getLine(type, copyright));
import org.apache.rat.walker.DirectoryWalker;
import org.apache.rat.walker.GZIPWalker;
        final IReportable base = getDirectory(out);
    private IReportable getDirectory(PrintStream out) {
            return null;
        } 
        
        if (base.isDirectory()) {
            return new DirectoryWalker(base, inputFileFilter);
        }
        
        try {
        	return new GZIPWalker(base, inputFileFilter);
        } catch (IOException ex) {
            out.print(" is not valid gzip data.\n");
            return null;
        final IReportable base = getDirectory(out);
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.zip.ZipInputStream;
    
    public static final boolean isZipStream(InputStream stream) {
    	ZipInputStream zip = new ZipInputStream(stream);
    	try {
			zip.getNextEntry();
			return true;
		} catch (IOException e) {
			return false;
		} finally {
		}
    }

    public static final boolean isZip(File file) {
        try {
        	return isZipStream(new FileInputStream(file));
        } catch (IOException e) {
            return false;
package org.apache.rat.walker;
public class DirectoryWalker extends Walker implements IReportable {
    protected static final FileNameComparator COMPARATOR = new FileNameComparator();
	
        super(file.getPath(), file, filter);
        super(file.getPath(), file, regexFilter(ignoreNameRegex));
   
package org.apache.rat.walker;
import org.apache.rat.walker.ArchiveWalker;
        f.printHelp("java rat.report [options] [DIR|TARBALL]",
        	return new ArchiveWalker(base, inputFileFilter);
 b/apache-rat-core/src/main/java/org/apache/rat/walker/ArchiveWalker.java
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;
import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;
 * Walks various kinds of archives files
public class ArchiveWalker extends Walker implements IReportable {
    public ArchiveWalker(File file, final FilenameFilter filter) throws FileNotFoundException {
			ArchiveInputStream input;
		
            /* I am really sad that classes aren't first-class objects in
               Java :'( */
			try {
				input = new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(file)));
			} catch (IOException e) {
				try {
					input = new TarArchiveInputStream(new BZip2CompressorInputStream(new FileInputStream(file)));
				} catch (IOException e2) {
					input = new ZipArchiveInputStream(new FileInputStream(file));
				}
			}
        "ODP",
        "ICO", "ICNS",
/*
* Licensed to the Apache Software Foundation (ASF) under one   *
* or more contributor license agreements.  See the NOTICE file *
* distributed with this work for additional information        *
* regarding copyright ownership.  The ASF licenses this file   *
* to you under the Apache License, Version 2.0 (the            *
* "License"); you may not use this file except in compliance   *
* with the License.  You may obtain a copy of the License at   *
*                                                              *
*   http://www.apache.org/licenses/LICENSE-2.0                 *
*                                                              *
* Unless required by applicable law or agreed to in writing,   *
* software distributed under the License is distributed on an  *
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
* KIND, either express or implied.  See the License for the    *
* specific language governing permissions and limitations      *
* under the License.                                           *
*/

/*
* Licensed to the Apache Software Foundation (ASF) under one   *
* or more contributor license agreements.  See the NOTICE file *
* distributed with this work for additional information        *
* regarding copyright ownership.  The ASF licenses this file   *
* to you under the Apache License, Version 2.0 (the            *
* "License"); you may not use this file except in compliance   *
* with the License.  You may obtain a copy of the License at   *
*                                                              *
*   http://www.apache.org/licenses/LICENSE-2.0                 *
*                                                              *
* Unless required by applicable law or agreed to in writing,   *
* software distributed under the License is distributed on an  *
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
* KIND, either express or implied.  See the License for the    *
* specific language governing permissions and limitations      *
* under the License.                                           *
*/

/*
* Licensed to the Apache Software Foundation (ASF) under one   *
* or more contributor license agreements.  See the NOTICE file *
* distributed with this work for additional information        *
* regarding copyright ownership.  The ASF licenses this file   *
* to you under the Apache License, Version 2.0 (the            *
* "License"); you may not use this file except in compliance   *
* with the License.  You may obtain a copy of the License at   *
*                                                              *
*   http://www.apache.org/licenses/LICENSE-2.0                 *
*                                                              *
* Unless required by applicable law or agreed to in writing,   *
* software distributed under the License is distributed on an  *
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
* KIND, either express or implied.  See the License for the    *
* specific language governing permissions and limitations      *
* under the License.                                           *
*/

        sink.section1_();	
import java.io.InputStream;
import org.apache.tools.ant.types.EnumeratedAttribute;
import org.apache.tools.ant.types.Resource;
 *
 * <p>The attribute <code>format</code> defines the output format and
 * can take the values
 * <ul>
 *   <li>xml - RAT's native XML output.</li>
 *   <li>styled - transforms the XML output using the given
 *   stylesheet.  The stylesheet attribute must be set as well if this
 *   attribute is used.</li>
 *   <li>plain - plain text using RAT's built-in stylesheet.  This is
 *   the default.</li>
 * </ul>


    /**
     * Which format to use.
     */
    private Format format = Format.PLAIN;
    /**
     * Which stylesheet to use.
     */
    private Resource stylesheet;

     * Which format to use.
     */
    public void setFormat(Format f) {
        if (f == null) {
            throw new IllegalArgumentException("format must not be null");
        }
        format = f;
    }

    /**
     * Which stylesheet to use (only meaningful with format='styled').
     */
    public void setStylesheet(Resource r) {
        stylesheet = r;
    }

    /**
        if (format.getValue().equals(Format.STYLED_KEY)) {
            if (stylesheet == null) {
                throw new BuildException("You must specify a stylesheet when"
                                          " using the 'styled' format");
            }
            if (!stylesheet.isExists()) {
                throw new BuildException("Cannot find specified stylesheet '"
                                          stylesheet  "'");
            }
        } else if (stylesheet != null) {
            log("Ignoring stylesheet '"  stylesheet  "' when using format '"
                 format.getValue()  "'", Project.MSG_WARN);
        }
        if (format.getValue().equals(Format.XML_KEY)) {
            org.apache.rat.Report.report(rcElement, out, m,
                                         getApprovedLicenseNames());
        } else {
            InputStream style = null;
            try {
                if (format.getValue().equals(Format.PLAIN_KEY)) {
                    style = Defaults.getPlainStyleSheet();
                } else if (format.getValue().equals(Format.STYLED_KEY)) {
                    style = stylesheet.getInputStream();
                } else {
                    throw new BuildException("unsupported format '"
                                              format.getValue()  "'");
                }
                org.apache.rat.Report.report(out, rcElement, style,
                                             m, getApprovedLicenseNames());
            } finally {
                FileUtils.close(style);
            }
        }


    /**
     * Type for the format attribute.
     */
    public static class Format extends EnumeratedAttribute {
        static final String XML_KEY = "xml";
        static final String STYLED_KEY = "styled";
        static final String PLAIN_KEY = "plain";

        static final Format PLAIN = new Format(PLAIN_KEY);

        public Format() { super(); }

        private Format(String s) {
            this();
            setValue(s);
        }

        public String[] getValues() {
            return new String[] {
                XML_KEY, STYLED_KEY, PLAIN_KEY
            };
        }
    }
     * @param style The stylesheet to use, or <code>null</code> for raw XML
            if (style != null) {
                return Report.report( out, getResources(), style, m, getApprovedLicenseNames() );
            } else {
                return Report.report( getResources(), out, m, getApprovedLicenseNames() );
            }
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
     * Output style of the report. Use "plain" (the default) for a plain text
     * report or "xml" for the raw XML report. Alternatively you can give the
     * path of an XSL transformation that will be applied on the raw XML to
     * produce the report written to the output file. 
     * 
     * @parameter expression="${rat.outputStyle}" default-value="plain"
     */
    private String reportStyle;

    /**
            final ClaimStatistic statistic = createReport( fw, getStyleSheet() );
     * Returns the XSL stylesheet to be used for formatting the report.
     *
     * @see #reportStyle
     * @return report stylesheet, or <code>null</code> for raw XML
     * @throws MojoExecutionException if the stylesheet can not be found
     */
    private InputStream getStyleSheet() throws MojoExecutionException {
        if ( reportStyle == null || reportStyle.equals( "plain" ) )
        {
            return Defaults.getPlainStyleSheet();
        }
        else if ( reportStyle.equals( "xml" ) )
        {
            return null;
        }
        else
        {
            try
            {
                return new FileInputStream( reportStyle );
            }
            catch ( FileNotFoundException e )
            {
                throw new MojoExecutionException(
                        "Unable to find report stylesheet: "  reportStyle, e );
            }
        }
    }

    /**


            }







                return new ArchiveWalker(base, inputFileFilter);
        RatReport report = XmlReportFactory.createStandardReport(writer, matcher, approvedLicenseNames, statistic);
import java.io.FileInputStream;
    private static final char STYLESHEET_CLI = 's';
                if (!cl.hasOption(STYLESHEET_CLI)) {
                    report.styleReport(System.out);
                } else {
                    String[] style = cl.getOptionValues(STYLESHEET_CLI);
                    if (style.length != 1) {
                        System.err.println("please specify a single stylesheet");
                        System.exit(1);
                    }
                    try {
                        report.report(System.out,
                                      report.getDirectory(System.out),
                                      new FileInputStream(style[0]),
                                      Defaults.createDefaultMatcher(), null);
                    } catch (FileNotFoundException fnfe) {
                        System.err.println("stylesheet "  style[0]
                                            " doesn't exist");
                        System.exit(1);
                    }
                }
        }
        Option xslt = new Option(String.valueOf(STYLESHEET_CLI),
                                 "stylesheet",
                                 true,
                                 "XSLT stylesheet to use when creating the"
                                  " report");
        opts.addOption(xslt);
import org.apache.commons.cli.OptionGroup;
        OptionGroup outputType = new OptionGroup();

        Option xml = new Option(
                "x",
                "xml",
                false,
                "Output the report in raw XML format.  Not compatible with -s");
        outputType.addOption(xml);

                                  " report.  Not compatible with -x");
        outputType.addOption(xslt);
        opts.addOptionGroup(outputType);

    public void addConfiguredStylesheet(Union u) {
        if (stylesheet != null || u.size() != 1) {
            throw new BuildException("You must not specify more than one"
                                      " stylesheet.");
        }
        stylesheet = (Resource) u.iterator().next();
import org.apache.rat.walker.DirectoryWalker;
        final ReportConfiguration configuration = new ReportConfiguration();
                configuration.setAddingLicenses(true);
                configuration.setAddingLicensesForced(cl.hasOption('f'));
                configuration.setCopyrightMessage(cl.getOptionValue("c"));
                        configuration.setHeaderMatcher(Defaults.createDefaultMatcher());
                        report(System.out,
                                report.getDirectory(System.out),
                                new FileInputStream(style[0]),
                                configuration);
            final ReportConfiguration configuration = new ReportConfiguration();
            configuration.setHeaderMatcher(Defaults.createDefaultMatcher());
            return report(base, new OutputStreamWriter(out), configuration);
            final ReportConfiguration configuration = new ReportConfiguration();
            configuration.setHeaderMatcher(Defaults.createDefaultMatcher());
            report(out, base, style, configuration);
    public static void report(PrintStream out, IReportable base, final InputStream style,
                              ReportConfiguration pConfiguration) 
            throws IOException, TransformerConfigurationException,  InterruptedException, RatException {
        report(new OutputStreamWriter(out), base, style, pConfiguration);
            ReportConfiguration pConfiguration) 
        final ClaimStatistic statistic = report(base, writer, pConfiguration);
    public static ClaimStatistic report(final IReportable container, final Writer out,
            ReportConfiguration pConfiguration) throws IOException, RatException {
        RatReport report = XmlReportFactory.createStandardReport(writer, statistic, pConfiguration);
 
import org.apache.rat.api.RatException;
import org.apache.rat.report.AbstractReport;
public abstract class AbstractClaimReporter extends AbstractReport {
    private final ClaimStatistic statistic;
    public ClaimAggregator(ClaimStatistic pStatistic) {
        statistic = pStatistic;
    
    public void endReport() throws RatException {
        super.endReport();
        fillClaimStatistic(statistic);
import org.apache.rat.api.RatException;
import org.apache.rat.report.AbstractReport;
public class SimpleXmlClaimReporter extends AbstractReport {

    public void startReport() throws RatException {
        try {
            writer.openElement("rat-report");
        } catch (IOException e) {
            throw new RatException("Cannot open start element", e);
        }
    }

    public void endReport() throws RatException {
        try {
            writer.closeDocument();
        } catch (IOException e) {
            throw new RatException("Cannot close last element", e);
        }
    }
import java.util.List;

import org.apache.rat.document.IDocumentAnalyser;
import org.apache.rat.document.RatDocumentAnalysisException;
import org.apache.rat.report.RatReport;
public class ClaimReporterMultiplexer implements RatReport {
    private final IDocumentAnalyser analyser;
    private final List reporters;

    public ClaimReporterMultiplexer(final IDocumentAnalyser pAnalyser, final List reporters) {
        analyser = pAnalyser;
        if (analyser != null) {
            try {
                analyser.analyse(document);
            } catch (RatDocumentAnalysisException e) {
                throw new RatException(e.getMessage(), e);
            }
        }
        final int length = reporters.size();
        for (int i=0;  i<length;  i) {
            final RatReport report = (RatReport) reporters.get(i);
            report.report(document);
        } 
    }

    public void startReport() throws RatException {
        final int length = reporters.size();
        for (int i=0;  i<length;  i) {
            final RatReport report = (RatReport) reporters.get(i);
            report.startReport();
        } 
    }

    public void endReport() throws RatException {
        final int length = reporters.size();
        for (int i=0;  i<length;  i) {
            final RatReport report = (RatReport) reporters.get(i);
            report.endReport();
import java.util.ArrayList;
import java.util.List;

import org.apache.rat.ReportConfiguration;
import org.apache.rat.report.claim.util.ClaimReporterMultiplexer;
import org.apache.rat.report.claim.util.LicenseAddingReport;
    public static final RatReport createStandardReport(IXmlWriter writer,
            final ClaimStatistic pStatistic, ReportConfiguration pConfiguration) {
        final List reporters = new ArrayList();
        if (pStatistic != null) {
            reporters.add(new ClaimAggregator(pStatistic));
        if (pConfiguration.isAddingLicenses()) {
            reporters.add(new LicenseAddingReport(pConfiguration.getCopyrightMessage(), pConfiguration.isAddingLicensesForced()));
        }
        reporters.add(new SimpleXmlClaimReporter(writer));
            DefaultAnalyserFactory.createDefaultAnalyser(pConfiguration.getHeaderMatcher());
        final DefaultPolicy policy = new DefaultPolicy(pConfiguration.getApprovedLicenseNames());
        return new ClaimReporterMultiplexer(analysisMultiplexer, reporters);
import org.apache.rat.report.AbstractReport;
public class MockClaimReporter extends AbstractReport {
import org.apache.rat.ReportConfiguration;
    
        final ReportConfiguration configuration = getConfiguration();
                return Report.report( out, getResources(), style, configuration );
                return Report.report( getResources(), out, configuration );
    protected ReportConfiguration getConfiguration() throws MojoFailureException,
            MojoExecutionException {
        final ReportConfiguration configuration = new ReportConfiguration();
        configuration.setHeaderMatcher( new HeaderMatcherMultiplexer( getLicenseMatchers() ) );
        configuration.setApprovedLicenseNames(getApprovedLicenseNames());
        return configuration;
    }

import org.apache.rat.ReportConfiguration;
    /**
     * Whether to add license headers; possible values are
     * {@code forced}, {@code true}, and {@code false} (default).
     *
     * @parameter expression="${rat.addLicenseHeaders}" default-value="false"
     */
    private String addLicenseHeaders;

    /**
     * Copyright message to add to license headers. This option is
     * ignored, unless {@code addLicenseHeaders} is set to {@code true},
     * or {@code forced}.
     *
     * @parameter expression="${rat.copyrightMessage}"
     */
    private String copyrightMessage;


    protected ReportConfiguration getConfiguration()
            throws MojoFailureException, MojoExecutionException {
        final ReportConfiguration configuration = super.getConfiguration();
        if ("forced".equals(addLicenseHeaders)) {
            configuration.setAddingLicenses(true);
            configuration.setAddingLicensesForced(true);
            configuration.setCopyrightMessage(copyrightMessage);
        } else if ("true".equals(addLicenseHeaders)) {
            configuration.setAddingLicenses(true);
            configuration.setCopyrightMessage(copyrightMessage);
        } else if ("false".equals(addLicenseHeaders)) {
            // Nothing to do
        } else {
            throw new MojoFailureException("Invalid value for addLicenseHeaders: Expected forced|true|false, got "
                     addLicenseHeaders);
        }
        return configuration;
    }
import org.apache.rat.ReportConfiguration;
    /**
     * Whether to add license headers.
     */
    private AddLicenseHeaders addLicenseHeaders = new AddLicenseHeaders(AddLicenseHeaders.FALSE);
    /**
     * The copyright message.
     */
    private String copyrightMessage;
     * Wether to add license headers.
     */
    public void setAddLicenseHeaders(AddLicenseHeaders pAdd) {
        if (pAdd == null) {
            throw new IllegalArgumentException("addLicenseHeaders must not be null");
        }
        addLicenseHeaders = pAdd;
    }

    /**
     * Sets the copyright message.
     */
    public void setCopyrightMessage(String pMessage) {
        copyrightMessage = pMessage;
    }
    
    /**
        final ReportConfiguration configuration = new ReportConfiguration();
        configuration.setHeaderMatcher(new HeaderMatcherMultiplexer(getLicenseMatchers()));
        configuration.setApprovedLicenseNames(getApprovedLicenseNames());
        if (AddLicenseHeaders.FALSE.equalsIgnoreCase(addLicenseHeaders.getValue())) {
            // Nothing to do
        } else if (AddLicenseHeaders.FORCED.equalsIgnoreCase(addLicenseHeaders.getValue())) {
            configuration.setAddingLicenses(true);
            configuration.setAddingLicensesForced(true);
            configuration.setCopyrightMessage(copyrightMessage);
        } else if (AddLicenseHeaders.TRUE.equalsIgnoreCase(addLicenseHeaders.getValue())) {
            configuration.setAddingLicenses(true);
            configuration.setCopyrightMessage(copyrightMessage);
        } else {
            throw new BuildException("Invalid value for addLicenseHeaders: "  addLicenseHeaders.getValue());
        }
        ResourceCollectionContainer rcElement = new ResourceCollectionContainer(nestedResources);
            org.apache.rat.Report.report(rcElement, out, configuration);
                                             configuration);

    /**
     * Type for the addLicenseHeaders attribute.
     */
    public static class AddLicenseHeaders extends EnumeratedAttribute {
        static final String TRUE = "true";
        static final String FALSE = "false";
        static final String FORCED = "forced";

        public AddLicenseHeaders() {}
        public AddLicenseHeaders(String s) {
            setValue(s);
        }
        
        
        public String[] getValues() {
            return new String[] {
                TRUE, FALSE, FORCED
            };
        }
    }
    public static final String[] MAVEN_DEFAULT_EXCLUDES = new String[] {
        "target/**/*", "cobertura.ser", "release.properties",
        "pom.xml.releaseBackup"
    };
/*
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 */ 
/*
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 */ 
/*
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 */ 
/*
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 */ 
package org.apache.rat;

import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.license.ILicenseFamily;


/**
 * A configuration object is used by the frontend to invoke the
 * {@link Report}. Basically, the sole purpose of the frontends is
 * to create the configuration and invoke the {@link Report}.
 */
public class ReportConfiguration {
    private IHeaderMatcher headerMatcher;
    private ILicenseFamily[] approvedLicenseNames;
    private boolean addingLicenses;
    private boolean addingLicensesForced;
    private String copyrightMessage;

    /**
     * Returns the header matcher.
     */
    public IHeaderMatcher getHeaderMatcher() {
        return headerMatcher;
    }

    /**
     * Sets the header matcher.
     */
    public void setHeaderMatcher(IHeaderMatcher headerMatcher) {
        this.headerMatcher = headerMatcher;
    }

    /**
     * Returns the set of approved license names.
     */
    public ILicenseFamily[] getApprovedLicenseNames() {
        return approvedLicenseNames;
    }

    /**
     * Sets the set of approved license names.
     */
    public void setApprovedLicenseNames(ILicenseFamily[] approvedLicenseNames) {
        this.approvedLicenseNames = approvedLicenseNames;
    }

    /**
     * If RAT is adding license headers: Returns the optional
     * copyright message. This value is ignored, if no
     * license headers are added.
     * @see #isAddingLicenses()
     */
    public String getCopyrightMessage() {
        return copyrightMessage;
    }

    /**
     * If RAT is adding license headers: Sets the optional
     * copyright message. This value is ignored, if no
     * license headers are added.
     * @see #setAddingLicenses(boolean)
     */
    public void setCopyrightMessage(String copyrightMessage) {
        this.copyrightMessage = copyrightMessage;
    }

    /**
     * If RAT is adding license headers: Returns, whether adding
     * license headers is enforced. This value is ignored, if no
     * license headers are added.
     * @see #isAddingLicenses()
     */
    public boolean isAddingLicensesForced() {
        return addingLicensesForced;
    }

    /**
     * If RAT is adding license headers: Sets, whether adding
     * license headers is enforced. This value is ignored, if no
     * license headers are added.
     * @see #isAddingLicenses()
     */
    public void setAddingLicensesForced(boolean addingLicensesForced) {
        this.addingLicensesForced = addingLicensesForced;
    }

    /**
     * Returns, whether RAT should add missing license headers.
     * @see #isAddingLicensesForced()
     * @see #getCopyrightMessage()
     */
    public boolean isAddingLicenses() {
        return addingLicenses;
    }

    /**
     * Returns, whether RAT should add missing license headers.
     * @see #setAddingLicensesForced(boolean)
     * @see #setCopyrightMessage(String)
     */
    public void setAddingLicenses(boolean addingLicenses) {
        this.addingLicenses = addingLicenses;
    }

    
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 */ 
package org.apache.rat.report;

import org.apache.rat.api.Document;
import org.apache.rat.api.RatException;


/**
 * Abstract base class for deriving implementations of {@link RatReport}.
 */
public abstract class AbstractReport implements RatReport {
    public void startReport() throws RatException {
        // Does nothing
    }

    public void report(Document document) throws RatException {
        // Does nothing
    }

    public void endReport() throws RatException {
        // Does nothing
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 */ 
package org.apache.rat.report.claim.util;

import java.io.File;
import java.io.IOException;

import org.apache.rat.annotation.AbstractLicenceAppender;
import org.apache.rat.annotation.ApacheV2LicenceAppender;
import org.apache.rat.api.MetaData;
import org.apache.rat.api.MetaData.Datum;
import org.apache.rat.api.RatException;
import org.apache.rat.report.AbstractReport;


public class LicenseAddingReport extends AbstractReport {
    private final AbstractLicenceAppender appender;

    public LicenseAddingReport(String pCopyrightMsg, boolean pForced) {
        appender = pCopyrightMsg == null ? new ApacheV2LicenceAppender() : new ApacheV2LicenceAppender(pCopyrightMsg);
        appender.setForce(pForced);
    }

    public void report(org.apache.rat.api.Document document) throws RatException {
        final MetaData metaData = document.getMetaData();
        final Datum licenseHeader = metaData.get(MetaData.RAT_URL_HEADER_CATEGORY);
        if (licenseHeader == null
                ||  MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_UNKNOWN.getValue().equals(licenseHeader.getValue())) {
            final File file = new File(document.getName());
            if (file.isFile()) {
                try {
                    appender.append(file);
                } catch (IOException e) {
                    throw new RatException(e.getMessage(), e);
                }
            }
        }
        metaData.getData();
    }
}
  private static final int TYPE_VM     = 13;
        || type == TYPE_HTML
        || type == TYPE_VM) {
    } else if (document.getPath().endsWith(".vm")) {
      return TYPE_VM;
      case TYPE_VM:         return "##"  content  "\n";
        return isArchive(document.getName());
        for (int i = 0; i < ArchiveGuesser.ARCHIVE_EXTENSIONS.length; i) {
            if (nameToLower.endsWith("."  ArchiveGuesser.ARCHIVE_EXTENSIONS[i])) {
                return true;
            }
        return false;
                    return true;
        return false;
        for (int i = 0; i < exts.length; i) {
            if (name.indexOf("."  exts[i]  ".") >= 0) {
                return true;
            }
        return false;
        for (int i = 0; i < exts.length; i) {
            if (name.endsWith("."  exts[i])) {
                return true;
            }
        return false;
        return isBinary(document.getName())
            ||
            isBinaryDocument(document);
        if (l.contains(name) || l.contains(normalisedName)) {
            return true;

        for (int i = 0; i < NoteGuesser.NOTE_FILE_EXTENSIONS.length; i) {
            if (normalisedName.endsWith("."  NoteGuesser.NOTE_FILE_EXTENSIONS[i])) {
                return true;
            }
        }
        
        return false;
        return isNote(document.getName());
        private void setResource(Resource resource) {
                report.report(System.out, configuration);
                    report.styleReport(System.out, configuration);
    /**
     * @deprecated use the two-arg version instead
     */
        final ReportConfiguration configuration = new ReportConfiguration();
        configuration.setHeaderMatcher(Defaults.createDefaultMatcher());
        return report(out, configuration);
    }

    /**
     * @since RAT 0.8
     */
    public ClaimStatistic report(PrintStream out,
                                 ReportConfiguration configuration)
        throws Exception {
     * @deprecated use the two-arg version instead
        final ReportConfiguration configuration = new ReportConfiguration();
        configuration.setHeaderMatcher(Defaults.createDefaultMatcher());
        styleReport(out, configuration);
    }

    /**
     * Output a report in the default style and default licence
     * header matcher. 
     * 
     * @param out - the output stream to recieve the styled report
     * @param configuration the configuration to use
     * @throws Exception
     * @since RAT 0.8
     */
    public void styleReport(PrintStream out,
                            ReportConfiguration configuration)
        throws Exception {
    private static final int TYPE_UNKNOWN = 0;
    private static final int TYPE_JAVA = 1;
    private static final int TYPE_XML = 2;
    private static final int TYPE_HTML = 3;
    private static final int TYPE_CSS = 4;
    private static final int TYPE_JAVASCRIPT = 5;
    private static final int TYPE_APT = 6;
    private static final int TYPE_PROPERTIES = 7;
    private static final int TYPE_PYTHON = 8;
    private static final int TYPE_C      = 9;
    private static final int TYPE_H      = 10;
    private static final int TYPE_SH     = 11;
    private static final int TYPE_BAT    = 12;
    private static final int TYPE_VM     = 13;
    private boolean isForced;
    public AbstractLicenceAppender() {
        super();
    }
    /**
     * Append the default licence header to the supplied document.
     * 
     * @param document
     * @throws IOException
     *           if there is a problem either reading or writing the file
     */
    public void append(File document) throws IOException {
        int type = getType(document);
        if (type == TYPE_UNKNOWN) {
            return;
        }
        File newDocument = new File(document.getAbsolutePath()  ".new");
        FileWriter writer = new FileWriter(newDocument);
        FileReader fr = new FileReader(document);
        BufferedReader br = new BufferedReader(fr);
        if (type == TYPE_CSS 
            || type == TYPE_JAVASCRIPT 
            || type == TYPE_APT 
            || type == TYPE_PROPERTIES
            || type == TYPE_C
            || type == TYPE_H
            || type == TYPE_HTML
            || type == TYPE_VM) {
            writer.write(getLicenceHeader(document));
            writer.write('\n');
        }
        String line;
        boolean first = true;
        while ((line = br.readLine()) != null) {
            if (first && type == TYPE_PYTHON) {
                doFirstLine(document, writer, line, "#!/usr/bin");
            } else if (first && type == TYPE_BAT) {
                doFirstLine(document, writer, line, "@echo off");
            } else if (first && type == TYPE_SH) {
                doFirstLine(document, writer, line, "#!/bin");
            } else {
                writer.write(line);
                writer.write('\n');
            }
            if (type == TYPE_JAVA && line.startsWith("package ")) {
                writer.write(getLicenceHeader(document));
                writer.write('\n');
            }
            if (type == TYPE_XML && line.startsWith("<?xml ")) {
                writer.write(getLicenceHeader(document));
                writer.write('\n');
            }
            first = false;
        }
        br.close();
        writer.close();
        if (isForced) {
            document.delete();
            boolean renamed = newDocument.renameTo(document.getAbsoluteFile());
            if (!renamed) {
                System.err.println("Failed to rename new file, original file remains unchanged.");
            }
        }
    /**
     * Check first line for specified text and process.
     */
    private void doFirstLine(File document, FileWriter writer, String line, String lookfor) throws IOException  {
        if (line.startsWith(lookfor)) {
            writer.write(line);
            writer.write('\n');
            writer.write(getLicenceHeader(document));
        } else {
            writer.write(getLicenceHeader(document));
            writer.write(line);
            writer.write('\n');
        }

    /**
     * Detect the type of document.
     * 
     * @param document
     * @return not null
     * @TODO use existing mechanism to detect the type of a file and record it in the report output, thus we will not need this duplication here.
     */
    protected int getType(File document) {
        if (document.getPath().endsWith(".java")) {
            return TYPE_JAVA;
        } else if (document.getPath().endsWith(".xml") || document.getPath().endsWith(".xsl")) {
            return TYPE_XML;
        } else if (document.getPath().endsWith(".html") || document.getPath().endsWith(".htm")) {
            return TYPE_HTML;
        } else if (document.getPath().endsWith(".rdf") || document.getPath().endsWith(".xsl")) {
            return TYPE_XML;
        } else if (document.getPath().endsWith(".css")) {
            return TYPE_CSS;
        } else if (document.getPath().endsWith(".js")) {
            return TYPE_JAVASCRIPT;
        } else if (document.getPath().endsWith(".apt")) {
            return TYPE_APT;
        } else if (document.getPath().endsWith(".properties")) {
            return TYPE_PROPERTIES;
        } else if (document.getPath().endsWith(".py")) {
            return TYPE_PYTHON;
        } else if (document.getPath().endsWith(".c")) {
            return TYPE_C;
        } else if (document.getPath().endsWith(".h")) {
            return TYPE_H;
        } else if (document.getPath().endsWith(".sh")) {
            return TYPE_SH;
        } else if (document.getPath().endsWith(".bat")) {
            return TYPE_BAT;
        } else if (document.getPath().endsWith(".vm")) {
            return TYPE_VM;
        }
        return TYPE_UNKNOWN;

    /**
     * Set the force flag on this appender. If this flag is set
     * to true then files will be modified directly, otherwise
     * new files will be created alongside the existing files.
     * 
     * @param b
     */
    public void setForce(boolean b) {
        isForced = b;
    }

    /**
     * Get the licence header for a document.
     */
    public abstract String getLicenceHeader(File document);

    /**
     * Get the first line of the licence header formatted
     * for the given type of file.
     * 
     * @param type the type of file, see the TYPE_* constants
     * @return not null
     */
    protected String getFirstLine(int type) {
        switch (type) {
        case TYPE_JAVA: return "/*\n";
        case TYPE_C:    return "/*\n";
        case TYPE_H:    return "/*\n";
        case TYPE_XML: return "<!--\n";
        case TYPE_HTML: return "<!--\n";
        case TYPE_CSS: return "/*\n";
        case TYPE_JAVASCRIPT: return "/*\n";
        case TYPE_APT: return "~~\n";
        case TYPE_PROPERTIES: return "#\n";
        case TYPE_PYTHON:     return "#\n";
        case TYPE_SH:         return "#\n";
        case TYPE_BAT:        return "rem\n";
        default: return "";
        }
    }


    /**
     * Get the last line of the licence header formatted
     * for the given type of file.
     * 
     * @param type the type of file, see the TYPE_* constants
     * @return not null
     */
    protected String getLastLine(int type) {
        switch (type) {
        case TYPE_JAVA: return " */\n";
        case TYPE_C:    return " */\n";
        case TYPE_H:    return " */\n";
        case TYPE_XML: return "-->\n";
        case TYPE_HTML: return "-->\n";
        case TYPE_CSS: return " */\n";
        case TYPE_JAVASCRIPT: return " */\n";
        case TYPE_APT: return "~~\n";
        case TYPE_PROPERTIES: return "#\n";
        case TYPE_PYTHON:     return "#\n";
        case TYPE_SH:         return "#\n";
        case TYPE_BAT:        return "rem\n";
        default: return "";
        }
    }


    /**
     * Get a line of the licence header formatted
     * for the given type of file.
     * 
     * @param type the type of file, see the TYPE_* constants
     * @param content the content for this line
     * @return not null
     */
    protected String getLine(int type, String content) {
        if (content != null && content.length() > 0) {
            content = " "  content;
        }
        switch (type) {
        case TYPE_JAVA: return " *"  content  "\n";
        case TYPE_C:    return " *"  content  "\n";
        case TYPE_H:    return " *"  content  "\n";
        case TYPE_XML: return         content  "\n";
        case TYPE_HTML: return        content  "\n";
        case TYPE_CSS: return " *"   content  "\n";
        case TYPE_JAVASCRIPT: return " *"  content  "\n";
        case TYPE_APT: return "~~"  content  "\n";
        case TYPE_PROPERTIES: return "#"  content  "\n";
        case TYPE_PYTHON:     return "#"  content  "\n";
        case TYPE_SH:         return "#"  content  "\n";
        case TYPE_BAT:        return "rem"  content  "\n";
        case TYPE_VM:         return "##"  content  "\n";
        default: return "";
        }
    }
 * <p>IHeaderMatcher(s) can be specified as nested elements as well.</p>
 * Implementation of IReportable that traverses over a resource
    private static final int TYPE_SCALA = 14;

            || type == TYPE_VM
            || type == TYPE_SCALA) {
        } else if (document.getPath().endsWith(".scala")) {
            return TYPE_SCALA;
        case TYPE_SCALA: return "/*\n";
        case TYPE_SCALA: return " */\n";
        case TYPE_SCALA: return " *"  content  "\n";
    private static final int TYPE_RUBY = 15;
            if (first && (type == TYPE_PYTHON || type == TYPE_RUBY)) {
        } else if (document.getPath().endsWith(".rb")) {
            return TYPE_RUBY;
        case TYPE_RUBY:     return "#\n";
        case TYPE_RUBY:     return "#\n";
        case TYPE_RUBY:     return "#"  content  "\n";
        configuration.setHeaderMatcher(Defaults.createDefaultMatcher());
            return new ArchiveWalker(base, inputFileFilter);
public final class ApacheSoftwareLicense20 extends SimplePatternBasedLicense {
		super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_ASL, MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_APACHE_LICENSE_VERSION_2_0,
		        "", new String[]{FIRST_LICENSE_LINE, LICENSE_REFERENCE_LINE});

public class DojoLicenseHeader extends SimplePatternBasedLicense {
    private static final String LICENSE_URL  = "http://dojotoolkit.org/community/licensing.shtml";
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_DOJO, MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_MODIFIED_BSD_LICENSE, "Dual license AFL/BSD",
                new String[]{LICENSE_URL});
public class TMF854LicenseHeader extends SimplePatternBasedLicense {
    private static final String COPYRIGHT_HEADER = "TMF854 Version 1.0 - Copyright TeleManagement Forum";
                MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_MODIFIED_BSD_LICENSE, "BSD",
                new String[]{COPYRIGHT_HEADER});
public class W3CDocLicense extends SimplePatternBasedLicense {
                MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_W3C_DOCUMENT_COPYRIGHT,  NOTES,
                new String[]{COPYRIGHT_URL});
public class W3CLicense extends SimplePatternBasedLicense {
                MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_W3C_SOFTWARE_COPYRIGHT,  NOTES,
                new String[]{COPYRIGHT_URL});
     * Specifies the licenses to accept. Deprecated, use {@link #licenses} instead.
     * @deprecated Use {@link #licenses} instead.
     * Specifies the licenses to accept. By default, these are added to the default
     * licenses, unless you set {@link #addDefaultLicenseMatchers} to true.
     * @parameter
     * @since 0.8
     */
    private IHeaderMatcher[] licenses;

    /**
     * @deprecated Use {@link #licenseFamilies} instead.
     * Specifies the license families to accept.
     * @parameter
     * @since 0.8
     */
    private ILicenseFamily[] licenseFamilies;
    
    /**
        if ( licenses != null )
        {
            list.addAll( Arrays.asList( licenses ) );
        }

        final List list = new ArrayList();
        if ( licenseFamilies != null )
        {
            list.addAll( Arrays.asList( licenseFamilies ) );
        }
        if ( licenseFamilyNames != null)
        {
            for ( int i = 0; i < licenseFamilyNames.length; i )
            {
                LicenseFamilySpecification spec = licenseFamilyNames[i];
                list.add( newInstance( ILicenseFamily.class, spec.getClassName() ) );
            }
        }

        if ( list.isEmpty() )
        return (ILicenseFamily[]) list.toArray( new ILicenseFamily[ list.size() ] );
import java.util.Arrays;
    private static final int TYPE_C = 9;
    private static final int TYPE_H = 10;
    private static final int TYPE_SH = 11;
    private static final int TYPE_BAT = 12;
    private static final int TYPE_VM = 13;
    private static final int[] FAMILY_C = new int[] {
        TYPE_JAVA, TYPE_JAVASCRIPT, TYPE_C, TYPE_H, TYPE_SCALA,
        TYPE_CSS,
    };
    private static final int[] FAMILY_SGML = new int[] {
        TYPE_XML, TYPE_HTML,
    };
    private static final int[] FAMILY_SH = new int[] {
        TYPE_PROPERTIES, TYPE_PYTHON, TYPE_SH, TYPE_RUBY,
    };
    private static final int[] FAMILY_BAT = new int[] {
        TYPE_BAT,
    };
    private static final int[] FAMILY_APT = new int[] {
        TYPE_APT,
    };
    private static final int[] FAMILY_VELOCITY = new int[] {
        TYPE_VM,
    };

    static {
        // these arrays are used in Arrays.binarySearch so they must
        // be sorted
        Arrays.sort(FAMILY_C);
        Arrays.sort(FAMILY_SGML);
        Arrays.sort(FAMILY_SH);
        Arrays.sort(FAMILY_BAT);
        Arrays.sort(FAMILY_APT);
        Arrays.sort(FAMILY_VELOCITY);
    }

        if (isFamilyC(type)) {
            return "/*\n";
        } else if (isFamilySGML(type)) {
            return "<!--\n";
        } else if (isFamilyAPT(type)) {
            return "~~\n";
        } else if (isFamilySH(type)) {
            return "#\n";
        } else if (isFamilyBAT(type)) {
            return "rem\n";
        return "";
        if (isFamilyC(type)) {
            return "*/\n";
        } else if (isFamilySGML(type)) {
            return "-->\n";
        } else if (isFamilyAPT(type)) {
            return "~~\n";
        } else if (isFamilySH(type)) {
            return "#\n";
        } else if (isFamilyBAT(type)) {
            return "rem\n";
        return "";
        if (isFamilyC(type)) {
            return " *"  content  "\n";
        } else if (isFamilySGML(type)) {
            return content  "\n";
        } else if (isFamilyAPT(type)) {
            return "~~"  content  "\n";
        } else if (isFamilySH(type)) {
            return "#"  content  "\n";
        } else if (isFamilyBAT(type)) {
            return "rem"  content  "\n";
        } else if (isFamilyVelocity(type)) {
            return "##"  content  "\n";
        return "";
    }

    private static boolean isFamilyC(int type) {
        return isIn(FAMILY_C, type);
    }
    private static boolean isFamilySGML(int type) {
        return isIn(FAMILY_SGML, type);
    }
    private static boolean isFamilySH(int type) {
        return isIn(FAMILY_SH, type);
    }
    private static boolean isFamilyAPT(int type) {
        return isIn(FAMILY_APT, type);
    }
    private static boolean isFamilyBAT(int type) {
        return isIn(FAMILY_BAT, type);
    }
    private static boolean isFamilyVelocity(int type) {
        return isIn(FAMILY_VELOCITY, type);
    }
    private static boolean isIn(int[] arr, int key) {
        return Arrays.binarySearch(arr, key) >= 0;
    private static final int[] EXPECTS_HASH_PLING = new int[] {
        TYPE_PYTHON, TYPE_SH, TYPE_RUBY,
    };
    private static final int[] EXPECTS_AT_ECHO = new int[] {
        TYPE_BAT,
    };
    private static final int[] EXPECTS_PACKAGE = new int[] {
        TYPE_JAVA,
    };
    private static final int[] EXPECTS_XML_DECL = new int[] {
        TYPE_XML,
    };

        Arrays.sort(EXPECTS_HASH_PLING);
        Arrays.sort(EXPECTS_AT_ECHO);
        Arrays.sort(EXPECTS_PACKAGE);
        Arrays.sort(EXPECTS_XML_DECL);
        boolean expectsHashPling = expectsHashPling(type);
        boolean expectsAtEcho = expectsAtEcho(type);
        boolean expectsPackage = expectsPackage(type);
        boolean expectsXMLDecl = expectsXMLDecl(type);

        if (!expectsHashPling
            && !expectsAtEcho
            && !expectsPackage
            && !expectsXMLDecl) {
            if (first && expectsHashPling) {
                doFirstLine(document, writer, line, "#!");
            } else if (first && expectsAtEcho) {
                doFirstLine(document, writer, line, "@echo");
            if (expectsPackage && line.startsWith("package ")) {
            if (expectsXMLDecl && line.startsWith("<?xml ")) {
    private static boolean expectsHashPling(int type) {
        return isIn(EXPECTS_HASH_PLING, type);
    }
    private static boolean expectsAtEcho(int type) {
        return isIn(EXPECTS_AT_ECHO, type);
    }
    private static boolean expectsPackage(int type) {
        return isIn(EXPECTS_PACKAGE, type);
    }
    private static boolean expectsXMLDecl(int type) {
        return isIn(EXPECTS_XML_DECL, type);
    }
import java.util.HashMap;
import java.util.Map;
    private static final Map/*<String, Integer>*/ EXT2TYPE = new HashMap();


        EXT2TYPE.put("apt", Integer.valueOf(TYPE_APT));
        EXT2TYPE.put("bat", Integer.valueOf(TYPE_BAT));
        EXT2TYPE.put("c", Integer.valueOf(TYPE_C));
        EXT2TYPE.put("css", Integer.valueOf(TYPE_CSS));
        EXT2TYPE.put("h", Integer.valueOf(TYPE_H));
        EXT2TYPE.put("htm", Integer.valueOf(TYPE_HTML));
        EXT2TYPE.put("html", Integer.valueOf(TYPE_HTML));
        EXT2TYPE.put("java", Integer.valueOf(TYPE_JAVA));
        EXT2TYPE.put("js", Integer.valueOf(TYPE_JAVASCRIPT));
        EXT2TYPE.put("properties", Integer.valueOf(TYPE_PROPERTIES));
        EXT2TYPE.put("py", Integer.valueOf(TYPE_PYTHON));
        EXT2TYPE.put("rb", Integer.valueOf(TYPE_RUBY));
        EXT2TYPE.put("rdf", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("scala", Integer.valueOf(TYPE_SCALA));
        EXT2TYPE.put("sh", Integer.valueOf(TYPE_SH));
        EXT2TYPE.put("vm", Integer.valueOf(TYPE_VM));
        EXT2TYPE.put("xml", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("xsl", Integer.valueOf(TYPE_XML));
        String path = document.getPath();
        int lastDot = path.lastIndexOf(".");
        if (lastDot >= 0 && lastDot < path.length() - 1) {
            String ext = path.substring(lastDot  1);
            Object type = EXT2TYPE.get(ext);
            if (type instanceof Integer) {
                return ((Integer) type).intValue();
            }
    private static final int TYPE_PERL = 16;
    private static final int TYPE_TCL = 17;
    private static final int TYPE_CPP = 18;
    private static final int TYPE_CSHARP = 19;
    private static final int TYPE_PHP = 20;
        TYPE_CSS, TYPE_CPP, TYPE_CSHARP, TYPE_PHP,
        TYPE_PROPERTIES, TYPE_PYTHON, TYPE_SH, TYPE_RUBY, TYPE_PERL,
        TYPE_TCL,
        TYPE_PYTHON, TYPE_SH, TYPE_RUBY, TYPE_PERL, TYPE_TCL
    private static final int[] EXPECTS_PHP_PI = new int[] {
        TYPE_PHP,
    };
        EXT2TYPE.put("cc", Integer.valueOf(TYPE_CPP));
        EXT2TYPE.put("cpp", Integer.valueOf(TYPE_CPP));
        EXT2TYPE.put("cs", Integer.valueOf(TYPE_CSHARP));
        EXT2TYPE.put("hh", Integer.valueOf(TYPE_H));
        EXT2TYPE.put("hpp", Integer.valueOf(TYPE_H));
        EXT2TYPE.put("php", Integer.valueOf(TYPE_PHP));
        EXT2TYPE.put("pl", Integer.valueOf(TYPE_PERL));
        EXT2TYPE.put("tcl", Integer.valueOf(TYPE_TCL));
        boolean expectsPhpPI = expectsPhpPI(type);
            && !expectsXMLDecl
            && !expectsPhpPI) {
            } else if (expectsXMLDecl && line.startsWith("<?xml ")) {
                writer.write(getLicenceHeader(document));
                writer.write('\n');
            } else if (expectsPhpPI && line.startsWith("<?php")) {
    private static boolean expectsPhpPI(int type) {
        return isIn(EXPECTS_PHP_PI, type);
    }
    private static final int TYPE_GROOVY = 21;
        TYPE_CSS, TYPE_CPP, TYPE_CSHARP, TYPE_PHP, TYPE_GROOVY,
        EXT2TYPE.put("groovy", Integer.valueOf(TYPE_GROOVY));
            if (cl.hasOption('a') || cl.hasOption('A')) {
        OptionGroup addLicenceGroup = new OptionGroup();
        String addLicenceDesc = "Add the default licence header to any file with an unknown licence that is not in the exclusion list. By default new files will be created with the licence header, to force the modification of existing files use the --force option.";

                addLicenceDesc);
        addLicenceGroup.addOption(addLicence);
        Option addLicense = new Option(
                "A",
                "addLicense",
                false,
                addLicenceDesc);
        addLicenceGroup.addOption(addLicense);
        opts.addOptionGroup(addLicenceGroup);
    public Reader reader() throws IOException;
        InputStream stream = null;
            stream = document.inputStream();
            result = isBinary(stream);
                if (stream != null)
                    stream.close();
     *
     * <p>Any IOException is swallowed internally and the test returns
     * false.</p>
     *
     * <p>This method may lead to false negatives if the reader throws
     * an exception because it can't read characters according to the
     * reader's encoding from the underlying stream.</p>
    /**
     * Do the first few bytes of the stream hint at a binary file?
     *
     * <p>Any IOException is swallowed internally and the test returns
     * false.</p>
     *
     * <p>This method will try to read bytes from the stream and
     * translate them to characters according to the platform's
     * default encoding.  If any bytes can not be translated to
     * characters it will assume the original data must be binary and
     * return true.</p>
     */
    public static boolean isBinary(InputStream in) {
        byte[] taste = new byte[200];
        try {
            int bytesRead = in.read(taste);
            if (bytesRead > 0) {
                int highBytes = 0;
                for (int i=0;i<bytesRead;i) {
                    if (taste[i] > BinaryGuesser.NON_ASCII_THREASHOLD
                        || taste[i] <= BinaryGuesser.ASCII_CHAR_THREASHOLD) {
                        highBytes;
                    }
                }
                if (highBytes * BinaryGuesser.HIGH_BYTES_RATIO
                    > bytesRead * BinaryGuesser.TOTAL_READ_RATIO) {
                    return true;
                }
            }
        } catch (IOException e) {
            // SWALLOW 
        }
        return false;
    }

        Reader reader = null;
            reader = document.reader();
            result = isBinary(reader);
                if (reader != null)
                    reader.close();
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CoderResult;
import java.nio.charset.CodingErrorAction;
        InputStream stream = null;
            stream = document.inputStream();
            result = isBinary(stream);
                if (stream != null)
                    stream.close();
    private static boolean isBinary(CharSequence taste) {
        int highBytes = 0;
        final int length = taste.length();
        for (int i = 0; i < length; i) {
            char c = taste.charAt(i);
            if (c > BinaryGuesser.NON_ASCII_THREASHOLD
                || c <= BinaryGuesser.ASCII_CHAR_THREASHOLD) {
                highBytes;
            }
        }
        return highBytes * BinaryGuesser.HIGH_BYTES_RATIO
            > length * BinaryGuesser.TOTAL_READ_RATIO;
    }

     *
     * <p>Any IOException is swallowed internally and the test returns
     * false.</p>
     *
     * <p>This method may lead to false negatives if the reader throws
     * an exception because it can't read characters according to the
     * reader's encoding from the underlying stream.</p>
                return isBinary(new String(taste, 0, bytesRead));
            }
        } catch (IOException e) {
            // SWALLOW 
        }
        return false;
    }

    /**
     * Do the first few bytes of the stream hint at a binary file?
     *
     * <p>Any IOException is swallowed internally and the test returns
     * false.</p>
     *
     * <p>This method will try to read bytes from the stream and
     * translate them to characters according to the platform's
     * default encoding.  If any bytes can not be translated to
     * characters it will assume the original data must be binary and
     * return true.</p>
     */
    public static boolean isBinary(InputStream in) {
        try {
            byte[] taste = new byte[200];
            int bytesRead = in.read(taste);
            if (bytesRead > 0) {
                ByteBuffer bytes = ByteBuffer.wrap(taste, 0, bytesRead);
                CharBuffer chars = CharBuffer.allocate(2 * bytesRead);
                Charset cs = Charset.forName(System.getProperty("file.encoding"));
                CharsetDecoder cd = cs.newDecoder()
                    .onMalformedInput(CodingErrorAction.REPORT)
                    .onUnmappableCharacter(CodingErrorAction.REPORT);
                while (bytes.remaining() > 0) {
                    CoderResult res = cd.decode(bytes, chars, true);
                    if (res.isMalformed() || res.isUnmappable()) {
                        return true;
                    } else if (res.isOverflow()) {
                        chars.limit(chars.position());
                        chars.rewind();
                        int c = chars.capacity() * 2;
                        CharBuffer on = CharBuffer.allocate(c);
                        on.put(chars);
                        chars = on;
                chars.limit(chars.position());
                chars.rewind();
                return isBinary(chars);
        File newDocument = new File(document.getAbsolutePath()  ".new");
        FileWriter writer = new FileWriter(newDocument);
        try {
            FileReader fr = new FileReader(document);
            BufferedReader br = null;
            try {
                br = new BufferedReader(fr);
                if (!expectsHashPling
                    && !expectsAtEcho
                    && !expectsPackage
                    && !expectsXMLDecl
                    && !expectsPhpPI) {
                    writer.write(getLicenceHeader(document));
                    writer.write('\n');
                }

                String line;
                boolean first = true;
                while ((line = br.readLine()) != null) {
                    if (first && expectsHashPling) {
                        doFirstLine(document, writer, line, "#!");
                    } else if (first && expectsAtEcho) {
                        doFirstLine(document, writer, line, "@echo");
                    } else {
                        writer.write(line);
                        writer.write('\n');
                    }

                    if (expectsPackage && line.startsWith("package ")) {
                        writer.write(getLicenceHeader(document));
                        writer.write('\n');
                    } else if (expectsXMLDecl && line.startsWith("<?xml ")) {
                        writer.write(getLicenceHeader(document));
                        writer.write('\n');
                    } else if (expectsPhpPI && line.startsWith("<?php")) {
                        writer.write(getLicenceHeader(document));
                        writer.write('\n');
                    }
                    first = false;
                }
            } finally {
                if (br != null) {
                    br.close();
                }
                fr.close();
        } finally {
            writer.close();
import java.io.Writer;
        if (!attachLicense(new FileWriter(newDocument), document,
                           expectsHashPling, expectsAtEcho, expectsPackage,
                           expectsXMLDecl, expectsPhpPI)) {
            // Java File without package, XML file without decl or PHP
            // file without PI
            // for Java just place the license at the front, for XML add
            // an XML decl first - don't know how to handle PHP
            if (expectsPackage || expectsXMLDecl) {
                writer = new FileWriter(newDocument);
                try {
                    if (expectsXMLDecl) {
                        writer.write("<?xml version='1.0'?>\n");
                    }
                    attachLicense(writer, document,
                                  false, false, false, false, false);
                } finally {
                    writer.close();
                }
            }
        }
        if (isForced) {
            document.delete();
            boolean renamed = newDocument.renameTo(document.getAbsoluteFile());
            if (!renamed) {
                System.err.println("Failed to rename new file, original file remains unchanged.");
            }
        }
    }

    /**
     * Write document's content to writer attaching the license using
     * the given flags as hints for where to put it.
     * @return whether the license has actually been written
     */
    private boolean attachLicense(Writer writer, File document,
                                  boolean expectsHashPling,
                                  boolean expectsAtEcho,
                                  boolean expectsPackage,
                                  boolean expectsXMLDecl,
                                  boolean expectsPhpPI)
        throws IOException {
        boolean written = false;
                    written = true;
                        written = true;
                        written = true;
                        written = true;
                        written = true;
                        written = true;
        return written;
    private void doFirstLine(File document, Writer writer, String line, String lookfor) throws IOException  {
import java.util.Calendar;

import org.apache.commons.lang.time.DateFormatUtils;
            writer.openElement("rat-report")
                .attribute("timestamp",
                           DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT
                           .format(Calendar.getInstance()));
     * Whether to add license headers.
        
        if (AddLicenseHeaders.FORCED.equalsIgnoreCase(addLicenseHeaders.getValue())) {
        } else if (!AddLicenseHeaders.FALSE.equalsIgnoreCase(addLicenseHeaders.getValue())) {
            if (!r.isDirectory()) {
        metaData.set(new MetaData.Datum(MetaData.RAT_URL_LICENSE_FAMILY_NAME, getLicenseFamilyName()));
public class AcademicFree21LicenseFamily extends SimpleLicenseFamily {
    public AcademicFree21LicenseFamily() {
        super(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_ACADEMIC_FREE_LICENSE_VERSION_2_1);
public final class Apache20LicenseFamily extends SimpleLicenseFamily {
    public Apache20LicenseFamily() {
        super(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_APACHE_LICENSE_VERSION_2_0);
public class ModifiedBSDLicenseFamily extends SimpleLicenseFamily {
    public ModifiedBSDLicenseFamily() {
        super(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_MODIFIED_BSD_LICENSE);
public final class OASISLicenseFamily extends SimpleLicenseFamily {
    public OASISLicenseFamily() {
        super(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_OASIS_OPEN_LICENSE);
public class W3CDocumentLicenseFamily extends SimpleLicenseFamily {
    public W3CDocumentLicenseFamily() {
        super(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_W3C_DOCUMENT_COPYRIGHT);
public class W3CSoftwareLicenseFamily extends SimpleLicenseFamily {
    public W3CSoftwareLicenseFamily() {
        super(MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_W3C_SOFTWARE_COPYRIGHT);
import org.apache.tools.ant.BuildException;
    private boolean validated = false;
        validate();
    private void validate() {
        if (!validated) {
            validated  = true;
            if (patterns.size() == 0) {
                throw new BuildException("You must specify at least one nested"
                                          " pattern.");
            }
            if (getLicenseFamilyCategory() == null) {
                throw new BuildException("The licenseFamilyCategory attribute"
                                          " is required.");
            }
            if (getLicenseFamilyName() == null) {
                throw new BuildException("The licenseFamilyName attribute"
                                          " is required.");
            }
        }
    }

/**
 * @since RAT 0.8
 */
 * @since RAT 0.8
 * @since RAT Antlib 0.8
    /** the line separator for this OS */
    private static final String LINE_SEP = System.getProperty("line.separator");

                        writer.write("<?xml version='1.0'?>");
                        writer.write(LINE_SEP);
                    writer.write(LINE_SEP);
                        writer.write(LINE_SEP);
                        writer.write(LINE_SEP);
                        writer.write(LINE_SEP);
                        writer.write(LINE_SEP);
            writer.write(LINE_SEP);
            writer.write(LINE_SEP);
            return "/*"  LINE_SEP;
            return "<!--"  LINE_SEP;
            return "~~"  LINE_SEP;
            return "#"  LINE_SEP;
            return "rem"  LINE_SEP;
            return "*/"  LINE_SEP;
            return "-->"  LINE_SEP;
            return "~~"  LINE_SEP;
            return "#"  LINE_SEP;
            return "rem"  LINE_SEP;
            return " *"  content  LINE_SEP;
            return content  LINE_SEP;
            return "~~"  content  LINE_SEP;
            return "#"  content  LINE_SEP;
            return "rem"  content  LINE_SEP;
            return "##"  content  LINE_SEP;
        try {
        if (!attachLicense(writer, document,
            }
        }
        } finally {
            if (writer != null) {
                writer.close();
            if (!attachLicense(writer, document,
                               expectsHashPling, expectsAtEcho, expectsPackage,
                               expectsXMLDecl, expectsPhpPI)) {
                // Java File without package, XML file without decl or PHP
                // file without PI
                // for Java just place the license at the front, for XML add
                // an XML decl first - don't know how to handle PHP
                if (expectsPackage || expectsXMLDecl) {
                    writer = new FileWriter(newDocument);
                }
import java.io.FileInputStream;
import java.io.FilterInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
            FileInputStream fis = new FileInputStream(document);
                br = new BufferedReader(new InputStreamReader(new BOMInputStream(fis)));
                fis.close();

/**
 * Stripped down version of Commons IO 2.0's BOMInputStream.
 */
class BOMInputStream extends FilterInputStream {
    private int[] firstBytes;
    private int fbLength, fbIndex, markFbIndex;
    private boolean markedAtStart;
    private static final int[][] BOMS = {
        new int[] { 0xEF, 0xBB, 0xBF }, // UTF-8
        new int[] { 0xFE, 0xFF }, // UTF-16BE
        new int[] { 0xFF, 0xFE }, // UTF-16LE
    };

    BOMInputStream(InputStream s) {
        super(s);
    }

    public int read() throws IOException {
        int b = readFirstBytes();
        return (b >= 0) ? b : in.read();
    }

    public int read(byte[] buf, int off, int len) throws IOException {
        int firstCount = 0;
        int b = 0;
        while ((len > 0) && (b >= 0)) {
            b = readFirstBytes();
            if (b >= 0) {
                buf[off] = (byte) (b & 0xFF);
                len--;
                firstCount;
            }
        }
        int secondCount = in.read(buf, off, len);
        return (secondCount < 0)
            ? (firstCount > 0 ? firstCount : -1) : firstCount  secondCount;
    }

    public int read(byte[] buf) throws IOException {
        return read(buf, 0, buf.length);
    }

    private int readFirstBytes() throws IOException {
        getBOM();
        return (fbIndex < fbLength) ? firstBytes[fbIndex] : -1;
    }

    private void getBOM() throws IOException {
        if (firstBytes == null) {
            int max = 0;
            for (int i = 0; i < BOMS.length; i) {
                max = Math.max(max, BOMS[i].length);
            }
            firstBytes = new int[max];
            for (int i = 0; i < firstBytes.length; i) {
                firstBytes[i] = in.read();
                fbLength;
                if (firstBytes[i] < 0) {
                    break;
                }

                boolean found = find();
                if (found) {
                    fbLength = 0;
                    break;
                }
            }
        }
    }
    public synchronized void mark(int readlimit) {
        markFbIndex = fbIndex;
        markedAtStart = (firstBytes == null);
        in.mark(readlimit);
    }

    public synchronized void reset() throws IOException {
        fbIndex = markFbIndex;
        if (markedAtStart) {
            firstBytes = null;
        }

        in.reset();
    }

    public long skip(long n) throws IOException {
        while ((n > 0) && (readFirstBytes() >= 0)) {
            n--;
        }
        return in.skip(n);
    }

    private boolean find() {
        for (int i = 0; i < BOMS.length; i) {
            if (matches(BOMS[i])) {
                return true;
            }
        }
        return false;
    }

    private boolean matches(int[] bom) {
        if (bom.length != fbLength) {
            return false;
        }
        for (int i = 0; i < bom.length; i) {
            if (bom[i] != firstBytes[i]) {
                return false;
            }
        }
        return true;
    }

}
    private static final int TYPE_VISUAL_STUDIO_SOLUTION = 22;
        TYPE_TCL, TYPE_VISUAL_STUDIO_SOLUTION,
    private static final int[] EXPECTS_MSVSSF_HEADER = new int[] {
        TYPE_VISUAL_STUDIO_SOLUTION,
    };
        Arrays.sort(EXPECTS_MSVSSF_HEADER);
        EXT2TYPE.put("asax", Integer.valueOf(TYPE_HTML));
        EXT2TYPE.put("ascx", Integer.valueOf(TYPE_HTML));
        EXT2TYPE.put("aspx", Integer.valueOf(TYPE_HTML));
        EXT2TYPE.put("cmd", Integer.valueOf(TYPE_BAT));
        EXT2TYPE.put("config", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("csdproj", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("csproj", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("ndoc", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("resx", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("sln", Integer.valueOf(TYPE_VISUAL_STUDIO_SOLUTION));
        EXT2TYPE.put("vbdproj", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("vbproj", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("vcproj", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("vsdisco", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("webinfo", Integer.valueOf(TYPE_XML));
        boolean expectsMSVSSF = expectsMSVisualStudioSolutionFileHeader(type);
                               expectsXMLDecl, expectsPhpPI, expectsMSVSSF)) {
                                  false, false, false, false, false, false);
                                  boolean expectsPhpPI,
                                  boolean expectsMSVSSF)
                    && !expectsPhpPI
                    && !expectsMSVSSF) {
                    } else if (first && expectsMSVSSF) {
                        written = true;
                        if (line.startsWith("Microsoft Visual Studio Solution"
                                             " File")) {
                            writer.write(line);
                            writer.write(LINE_SEP);
                            line = br.readLine();
                            if (line == null) {
                                line = "";
                            }
                        }
                        doFirstLine(document, writer, line, "# Visual ");
    private static boolean expectsMSVisualStudioSolutionFileHeader(int type) {
        return isIn(EXPECTS_MSVSSF_HEADER, type);
    }
import java.util.List;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.filefilter.RegexFileFilter;
import org.apache.commons.io.filefilter.OrFileFilter;
    private static final char EXCLUDE_FILE_CLI = 'E';
            else if (cl.hasOption(EXCLUDE_FILE_CLI)) {
                String excludeFileName = cl.getOptionValue(EXCLUDE_FILE_CLI);
                if (excludeFileName != null) {
                    List excludes = FileUtils.readLines(new File(excludeFileName));
                    final OrFileFilter orFilter = new OrFileFilter();
                    for (int i=0; i< excludes.size(); i) {
                        orFilter.addFileFilter(new RegexFileFilter((String)excludes.get(i)));
                    }
                    final FilenameFilter filter = new NotFileFilter(orFilter);
                    report.setInputFileFilter(filter);
                }
            }
                            .withDescription("Excludes files matching wildcard <expression>. " 
        final Option excludeFile = OptionBuilder
                            .withArgName("fileName")
                            .withLongOpt("exclude-file")
                            .hasArgs()
                            .withDescription("Excludes files matching regular expression in <file> " 
                                    "Note that --dir is required when using this parameter. " )
                            .create(EXCLUDE_FILE_CLI);
        opts.addOption(excludeFile);

                        if ("".equals(line)) {
                            line = passThroughReadNext(writer, line, br);
                        }
                            line = passThroughReadNext(writer, line, br);

    private String passThroughReadNext(Writer writer, String line,
                                       BufferedReader br) throws IOException {
        writer.write(line);
        writer.write(LINE_SEP);
        String l = br.readLine();
        return l == null ? "" : l;
    }
/*
 * Licensed to the Apache Software Foundation (ASF) under one   *
 * or more contributor license agreements.  See the NOTICE file *
 * distributed with this work for additional information        *
 * regarding copyright ownership.  The ASF licenses this file   *
 * to you under the Apache License, Version 2.0 (the            *
 * "License"); you may not use this file except in compliance   *
 * with the License.  You may obtain a copy of the License at   *
 *                                                              *
 *   http://www.apache.org/licenses/LICENSE-2.0                 *
 *                                                              *
 * Unless required by applicable law or agreed to in writing,   *
 * software distributed under the License is distributed on an  *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
 * KIND, either express or implied.  See the License for the    *
 * specific language governing permissions and limitations      *
 * under the License.                                           *
 */ 
package org.apache.rat.analysis.license;

import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.api.Document;
import org.apache.rat.api.MetaData;
import org.apache.rat.api.MetaData.Datum;


/**
 * @since RAT 0.8
 */
public class SimplePatternBasedLicense implements IHeaderMatcher {
    private String licenseFamilyCategory;
    private String licenseFamilyName;
    private String notes;
    private String[] patterns;

    public SimplePatternBasedLicense() {
    }

    protected SimplePatternBasedLicense(Datum pLicenseFamilyCategory, Datum pLicenseFamilyName,
            String pNotes, String[] pPatterns) {
        if (!MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY.equals(pLicenseFamilyCategory.getName())) {
            throw new IllegalStateException("Expected "  MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY
                     ", got "  pLicenseFamilyCategory.getName());
        }
        setLicenseFamilyCategory(pLicenseFamilyCategory.getValue());
        if (!MetaData.RAT_URL_LICENSE_FAMILY_NAME.equals(pLicenseFamilyName.getName())) {
            throw new IllegalStateException("Expected "  MetaData.RAT_URL_LICENSE_FAMILY_NAME
                     ", got "  pLicenseFamilyName.getName());
        }
        setLicenseFamilyName(pLicenseFamilyName.getValue());
        setNotes(pNotes);
        setPatterns(pPatterns);
    }
    
    public String[] getPatterns() {
        return patterns;
    }

    public void setPatterns(String[] pPatterns) {
        patterns = pPatterns;
    }

    public String getLicenseFamilyCategory() {
        return licenseFamilyCategory;
    }

    public void setLicenseFamilyCategory(String pDocumentCategory) {
        licenseFamilyCategory = pDocumentCategory;
    }

    public String getLicenseFamilyName() {
        return licenseFamilyName;
    }

    public void setLicenseFamilyName(String pLicenseFamilyCategory) {
        licenseFamilyName = pLicenseFamilyCategory;
    }

    public String getNotes() {
        return notes;
    }

    public void setNotes(String pNotes) {
        notes = pNotes;
    }

    protected void reportOnLicense(Document subject) throws RatHeaderAnalysisException {
        final MetaData metaData = subject.getMetaData();
        metaData.set(new MetaData.Datum(MetaData.RAT_URL_HEADER_SAMPLE, notes));
        final String licFamilyCategory = getLicenseFamilyCategory();
        metaData.set(new MetaData.Datum(MetaData.RAT_URL_HEADER_CATEGORY, licFamilyCategory));
        metaData.set(new MetaData.Datum(MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY, licFamilyCategory));
        metaData.set(new MetaData.Datum(MetaData.RAT_URL_LICENSE_FAMILY_NAME, getLicenseFamilyName()));
    }

    protected boolean matches(String pLine) {
        if (pLine != null) {
            final String[] pttrns = getPatterns();
            if (pttrns != null) {
                for (int i = 0;  i < pttrns.length;  i) {
                    if (pLine.indexOf(pttrns [i], 0) >= 0) {
                        return true; 
                    }
                }
            }
        }
        return false;
    }
    
    public void reset() {
        // Nothing to do
    }

    public boolean match(Document pSubject, String pLine) throws RatHeaderAnalysisException {
        final boolean result = matches(pLine);
        if (result) {
            reportOnLicense(pSubject);
        }
        return result;
    }
}
 * Abstract base implementation of {@link AbstractReport}.
 * {@link org.apache.rat.analysis.IHeaderMatcher}.
 * {@link org.apache.rat.license.ILicenseFamily}.
        if(!parent.mkdirs()) {
            throw new MojoExecutionException("Could not create report parent directory "  parent);
        }
            if( !outputDirectory.mkdirs() ) {
                throw new IOException("Could not created output directory "  outputDirectory);
            }

        Pattern.compile(".*Autogenerated by Thrift.*"),
        if(!parent.isDirectory() && !parent.mkdirs()) {
            if( !outputDirectory.isDirectory() && !outputDirectory.mkdirs() ) {
import org.apache.commons.io.filefilter.RegexFileFilter;
import javax.xml.transform.TransformerConfigurationException;
import java.io.*;
import java.util.List;

                    for (Object exclude : excludes) {
                        orFilter.addFileFilter(new RegexFileFilter((String) exclude));
        StringBuilder footer = new StringBuilder("\n");
                for (String pttrn : pttrns) {
                    if (pLine.indexOf(pttrn, 0) >= 0) {
                        return true;
    private static final Map<String, Integer> EXT2TYPE = new HashMap();
            Integer type = EXT2TYPE.get(ext);
            if (type != null) {
                return type.intValue();
            for (int[] BOM : BOMS) {
                max = Math.max(max, BOM.length);
        for (int[] BOM : BOMS) {
            if (matches(BOM)) {
    StringBuilder sb = new StringBuilder();
        for (Object o : parameters.entrySet()) {
            final Map.Entry entry = (Map.Entry) o;
    private final List<Datum> data;
        this.data = new ArrayList<Datum>(16);
        for (Datum next : data) {
import java.util.Arrays;


import java.util.List;

        for (Object reporter : reporters) {
            final RatReport report = (RatReport) reporter;
        for (Object reporter : reporters) {
            final RatReport report = (RatReport) reporter;
        for (Object reporter : reporters) {
            final RatReport report = (RatReport) reporter;
import java.io.File;
import java.io.FilenameFilter;
import java.util.Arrays;
import java.util.regex.Pattern;

        for (final File file : files) {
        for (final File file : files) {
import javax.xml.transform.TransformerConfigurationException;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

            for (final HeaderMatcherSpecification spec : licenseMatchers) {
                final IHeaderMatcher headerMatcher = (IHeaderMatcher) newInstance(IHeaderMatcher.class, className);
                list.add(headerMatcher);
    private void add( List<String> pList, String[] pArray )
            Collections.addAll(pList, pArray);
        final List<String> excludeList1 = new ArrayList<String>();
            for (Object o : project.getModules()) {
                String moduleSubPath = (String) o;
                excludeList1.add(moduleSubPath  "/**/*");
        final List<String> excludeList = excludeList1;
            for ( String exclude : excludes)
                getLog().info( "Exclude: "  exclude);
            for (LicenseFamilySpecification spec : licenseFamilyNames) {
                list.add(newInstance(ILicenseFamily.class, spec.getClassName()));
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;

        for (String file : files) {
            document.setFile(new File(basedir, file));
            report.report(document);
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;

        Map<String, String> attributes = new HashMap<String, String>();
        for ( Iterator<Artifact> iter = getProject().getDependencyArtifacts().iterator(); iter.hasNext(); )
        if(!parent.mkdirs() && !parent.isDirectory()) {
            if( !outputDirectory.mkdirs() && !outputDirectory.isDirectory() ) {
import org.apache.rat.analysis.license.GPL1License;
import org.apache.rat.analysis.license.GPL2License;
import org.apache.rat.analysis.license.GPL3License;
import java.io.InputStream;

     * The standard list of licenses to include in the reports.
            new GPL1License(),
            new GPL2License(),
            new GPL3License(),
            new W3CLicense(),
            new W3CDocLicense(),
    public static InputStream getPlainStyleSheet() {
    public static InputStream getDefaultStyleSheet() {
    public static IHeaderMatcher createDefaultMatcher() {
    // Shortcuts used in report output, needs to have 5 characters
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_GPL1 ="GPL1  ";
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_GPL2 ="GPL2  ";
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_GPL3 = "GPL3  ";

    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_GPL1 = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY,RAT_LICENSE_FAMILY_CATEGORY_VALUE_GPL1);
    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_GPL2 = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY,RAT_LICENSE_FAMILY_CATEGORY_VALUE_GPL2);
    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_GPL3 = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY,RAT_LICENSE_FAMILY_CATEGORY_VALUE_GPL3);
    public static final String RAT_LICENSE_FAMILY_NAME_VALUE_GPL_VERSION_1 =
            "GNU General Public License, version 1";
    public static final String RAT_LICENSE_FAMILY_NAME_VALUE_GPL_VERSION_2 =
            "GNU General Public License, version 2";
    public static final String RAT_LICENSE_FAMILY_NAME_VALUE_GPL_VERSION_3 =
            "GNU General Public License, version 3";
    public static final Datum
            RAT_LICENSE_FAMILY_NAME_DATUM_GPL_VERSION_1 = new Datum(RAT_URL_LICENSE_FAMILY_NAME, RAT_LICENSE_FAMILY_CATEGORY_VALUE_GPL1);
    public static final Datum
            RAT_LICENSE_FAMILY_NAME_DATUM_GPL_VERSION_2 = new Datum(RAT_URL_LICENSE_FAMILY_NAME, RAT_LICENSE_FAMILY_CATEGORY_VALUE_GPL2);
    public static final Datum
            RAT_LICENSE_FAMILY_NAME_DATUM_GPL_VERSION_3 = new Datum(RAT_URL_LICENSE_FAMILY_NAME, RAT_LICENSE_FAMILY_NAME_VALUE_GPL_VERSION_3);
        Pattern.compile(".*DO NOT EDIT THIS FILE - it is machine generated.*"),
    // Shortcuts used in report output, must be exactly 5 characters
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_GPL1 ="GPL1 ";
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_GPL2 ="GPL2 ";
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_GPL3 = "GPL3 ";
import org.apache.rat.analysis.license.MITLicense;
            new MITLicense(),
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_MIT = "MIT  ";
    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_MIT = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY,RAT_LICENSE_FAMILY_CATEGORY_VALUE_MIT);
    public static final String RAT_LICENSE_FAMILY_NAME_VALUE_MIT =
            "The MIT License";
    public static final Datum
            RAT_LICENSE_FAMILY_NAME_DATUM_MIT = new Datum(RAT_URL_LICENSE_FAMILY_NAME, RAT_LICENSE_FAMILY_NAME_VALUE_MIT);
        MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_MODIFIED_BSD_LICENSE,
        MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_MIT,
    private String licenseFamilyCategory;
    private String licenseFamilyName;
    private String notes;
    public BaseLicense() {
    }

        if (!MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY.equals(licenseFamilyCategory.getName())) {
            throw new IllegalStateException("Expected "  MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY
                     ", got "  licenseFamilyCategory.getName());
        }
        setLicenseFamilyCategory(licenseFamilyCategory.getValue());
        if (!MetaData.RAT_URL_LICENSE_FAMILY_NAME.equals(licenseFamilyName.getName())) {
            throw new IllegalStateException("Expected "  MetaData.RAT_URL_LICENSE_FAMILY_NAME
                     ", got "  licenseFamilyName.getName());
        }
        setLicenseFamilyName(licenseFamilyName.getValue());
        setNotes(notes);
    public String getLicenseFamilyCategory() {
        return licenseFamilyCategory;
    }

    public void setLicenseFamilyCategory(String pDocumentCategory) {
        licenseFamilyCategory = pDocumentCategory;
    }

    public String getLicenseFamilyName() {
        return licenseFamilyName;
    }

    public void setLicenseFamilyName(String pLicenseFamilyCategory) {
        licenseFamilyName = pLicenseFamilyCategory;
    }

    public String getNotes() {
        return notes;
    }

    public void setNotes(String pNotes) {
        notes = pNotes;
    }

        final String licFamilyCategory = getLicenseFamilyCategory();
        metaData.set(new MetaData.Datum(MetaData.RAT_URL_HEADER_CATEGORY, licFamilyCategory));
        metaData.set(new MetaData.Datum(MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY, licFamilyCategory));
        metaData.set(new MetaData.Datum(MetaData.RAT_URL_LICENSE_FAMILY_NAME, getLicenseFamilyName()));
public class SimplePatternBasedLicense extends BaseLicense implements IHeaderMatcher {
        super(pLicenseFamilyCategory, pLicenseFamilyName, pNotes);

    public BaseLicense(final MetaData.Datum licenseFamilyCategory, final MetaData.Datum licenseFamilyName, final String notes)
    {
    }
public class OASISLicense extends FullTextMatchingLicense {
    = "This document and translations of it may be copied and furnished to others and derivative works" 
            "that comment on or otherwise explain it or assist in its implementation may be prepared" 
            "copied published and distributed";
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_OASIS,
              MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_OASIS_OPEN_LICENSE,
              "No modifications allowed",
              CLAUSE_DEFN);
    @Override
            result = super.match(subject, line);
    @Override
        super.reset();
public class MITLicense extends FullTextMatchingLicense {
		        "", FIRST_LICENSE_LINE  MIDDLE_LICENSE_LINE  AS_IS_LICENSE_LINE);
public class GPL1License extends FullTextMatchingLicense {
		        "", FIRST_LICENSE_LINE);
public class GPL2License extends FullTextMatchingLicense {
		        "", FIRST_LICENSE_LINE);
public class GPL3License extends FullTextMatchingLicense {
		        "", FIRST_LICENSE_LINE);
    @Override
    public final boolean hasFullText() {
        return fullTextPattern != null;
    }

        EXT2TYPE.put("fxcop", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("nunit", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("shfbproj", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("stylecop", Integer.valueOf(TYPE_XML));
        EXT2TYPE.put("svg", Integer.valueOf(TYPE_XML));
import org.apache.rat.api.Document;

	public final List<String> lines = new ArrayList<String>();
import org.apache.rat.api.Document;

    public List<Document> matches = new ArrayList<Document>();

import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.lang.reflect.UndeclaredThrowableException;
    /**
     * Private constructor, to prevent accidental instantiation.
     */
    private XmlUtils() {
        // Does nothing
    }
     * <em>Note:</em> This might include files with unknown
     * <em>Note:</em> This might include files with unknown
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.Parameter;
    @Parameter (property = "rat.basedir", defaultValue = "${basedir}", required = true)
    @Parameter
     *
    @Parameter
     *
    @Parameter
    @Parameter(property = "rat.addDefaultLicenseMatchers", defaultValue = "true")
    @Parameter
    @Parameter
    @Parameter(property = "rat.useDefaultExcludes", defaultValue = "true")
    @Parameter(property = "rat.useMavenDefaultExcludes", defaultValue = "true")
    @Parameter(property = "rat.useEclipseDefaultExcludes", defaultValue = "true")
    @Parameter(property = "rat.useIdeaDefaultExcludes", defaultValue = "true")
    @Parameter(property = "rat.excludeSubprojects", defaultValue = "true")
     *
    @Component
                final IHeaderMatcher headerMatcher = newInstance(IHeaderMatcher.class, className);
    private <T> T newInstance( final Class<T> clazz, final String className )
        final T o;
            o = (T) cl.loadClass( className ).newInstance();
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
 *
@Mojo (name = "check", defaultPhase = LifecyclePhase.VERIFY)
     *
    @Parameter (property = "rat.outputFile", defaultValue = "${project.build.directory}/rat.txt")
     * produce the report written to the output file.
     *
    @Parameter(property = "rat.outputStyle", defaultValue = "plain")
    @Parameter(property = "rat.numUnapprovedLicenses", defaultValue = "0")
    @Parameter(property = "rat.addLicenseHeaders", defaultValue = "false")
    @Parameter(property = "rat.copyrightMessage")
    /**
     * Will ignore rat errors and display a log message if any.
     * Its use is NOT RECOMMENDED, but quite convenient on occasion.
     * @since 0.9
     */
    @Parameter(property = "rat.ignoreErrors", defaultValue = "false")
    private boolean ignoreErrors;

     *
            if ( !ignoreErrors )
            {
                throw new RatCheckException( "Too many unapproved licenses: "  statistics.getNumUnApproved() );
            }
            else
            {
                getLog().warn( "Rat check:"  statistics.getNumUnApproved()  " errors on non approved has been ignored." );
            }



import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
@Mojo(name = "rat", requiresDependencyResolution = ResolutionScope.TEST)
    @Parameter(defaultValue = "${project.reporting.outputDirectory}", required = true)
    @Component
    @Component
    @Component
    @Parameter(defaultValue = "${localRepository}", required = true, readonly = true)
import org.apache.maven.doxia.sink.render.RenderingContext;
        sink.section1_();
        return "Example License";
    }
        super(new MetaData.Datum(MetaData.RAT_URL_LICENSE_FAMILY_CATEGORY, "EXMPL"),
        reportOnLicense(subject);
        return true;

    private final int numberOfRetainedHeaderLines;
    private final BufferedReader reader;
    private final IHeaderMatcher matcher;
    private boolean match = false;
    private int headerLinesToRead;
    private boolean finished = false;

    public HeaderCheckWorker(Reader reader, int numberOfRetainedHeaderLine,
        this(new BufferedReader(reader), numberOfRetainedHeaderLine, matcher, name);
    }


    /**
     * Convenience constructor wraps given <code>Reader</code>
     * in a <code>BufferedReader</code>.
     * @param reader a <code>Reader</code> for the content, not null
     * @param name the name of the checked content, possibly null
     */
    public HeaderCheckWorker(Reader reader, final IHeaderMatcher matcher, final Document name) {
        this(new BufferedReader(reader), matcher, name);
    }

    public HeaderCheckWorker(BufferedReader reader, final IHeaderMatcher matcher,
        this(reader, DEFAULT_NUMBER_OF_RETAINED_HEADER_LINES, matcher, name);
    }

    public HeaderCheckWorker(BufferedReader reader, int numberOfRetainedHeaderLine, final IHeaderMatcher matcher,
        this.reader = reader;
        this.numberOfRetainedHeaderLines = numberOfRetainedHeaderLine;
        this.matcher = matcher;
    }
    public boolean isFinished() {
        return finished;
    }
    public void read() throws RatHeaderAnalysisException {
        if (!finished) {
            final StringBuffer headers = new StringBuffer();
            headerLinesToRead = numberOfRetainedHeaderLines;
            try {
                while(readLine(headers));
                if (!match) {
                    final String notes = headers.toString();
                }
            } catch (IOException e) {
            try {
                reader.close();
            } catch (IOException e) {
                // swallow
            }
        }
        finished = true;
    }

    boolean readLine(StringBuffer headers) throws IOException, RatHeaderAnalysisException {
        String line = reader.readLine();
        boolean result = line != null;
        if (result) {
            if (headerLinesToRead-- > 0) {
                headers.append(line);
                headers.append('\n');
            }
            result = !match;
        }
        return result;
    }
    /**
     * Resets this matches.
     * Subsequent calls to {@link #match} will accumulate new text.
     */
    public void reset();

    /**
     * Matches the text accumulated to licenses.
     * @param subject TODO
     * @param line next line of text, not null
     * @return TODO
     */
    public boolean match(Document subject, String line) throws RatHeaderAnalysisException;
    public static final String FIRST_LICENSE_LINE = "Licensed under the Apache License, Version 2.0 (the \"License\")";
    public static final String LICENSE_REFERENCE_LINE = "http://www.apache.org/licenses/LICENSE-2.0";

    public ApacheSoftwareLicense20() {
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_ASL, MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_APACHE_LICENSE_VERSION_2_0,
                "", new String[]{FIRST_LICENSE_LINE, LICENSE_REFERENCE_LINE});
    }
    public static final String FIRST_LICENSE_LINE = "This program is free software; you can redistribute it and/or modify\n" 
    public GPL1License() {
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_GPL1,
                "", FIRST_LICENSE_LINE);
    }
    public static final String FIRST_LICENSE_LINE = "This program is free software; you can redistribute it and/or\n" 
    public GPL2License() {
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_GPL2,
                "", FIRST_LICENSE_LINE);
    }
    public static final String FIRST_LICENSE_LINE = "This program is free software: you can redistribute it and/or modify\n" 
    public GPL3License() {
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_GPL3,
                "", FIRST_LICENSE_LINE);
    }
    public static final String FIRST_LICENSE_LINE = "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:";
    public MITLicense() {
        super(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_MIT,
                "", FIRST_LICENSE_LINE  MIDDLE_LICENSE_LINE  AS_IS_LICENSE_LINE);
    }
    private final IHeaderMatcher[] matchers;
    private final int numberOfMatchers;

    public HeaderMatcherMultiplexer(final IHeaderMatcher[] matchers) {
        this.matchers = matchers;
        numberOfMatchers = matchers.length;
    }

    public boolean match(Document subject, String line) throws RatHeaderAnalysisException {
        for (int i=0;i<numberOfMatchers;i) {
            result = matchers[i].match(subject, line);
        }
    }
    public void reset() {
        for (int i=0;i<numberOfMatchers;i) {
            matchers[i].reset();
        }
    }
    private final String name;
    private final MetaData metaData;
    public AbstractMonolithicDocument(String pName) {
        name = pName;
    }
    public boolean isComposite() {
        return name;
    }

    private byte[] contents;
    public ArchiveEntryDocument(File file, byte[] contents) throws RatException {
        super();
        name = DocumentImplUtils.toName(file);
        this.contents = contents;
    }
    public MetaData getMetaData() {
        return metaData;
    }
    public String getName() {
        return name;
    }
    public InputStream inputStream() throws IOException {
        return new ByteArrayInputStream(contents);
    }
    public boolean isComposite() {
        return DocumentImplUtils.isZipStream(new ByteArrayInputStream(contents));
    }

    public Reader reader() throws IOException {
        return new InputStreamReader(new ByteArrayInputStream(contents));
    }
        ZipInputStream zip = new ZipInputStream(stream);
        try {
            zip.getNextEntry();
            return true;
        } catch (IOException e) {
            return false;
        } finally {
        }
            return isZipStream(new FileInputStream(file));
    private final File file;
        if ("file".equals(url.getProtocol())) {
            final File f = new File(url.getFile());
            return new MonolithicFileDocument(f);
        }
        return new AbstractMonolithicDocument(url.toExternalForm()){
            public Reader reader() throws IOException {
                return new InputStreamReader(inputStream(), "UTF-8");
           }
        };
        super(DocumentImplUtils.toName(file));


        try {
            ArchiveInputStream input;

            try {
                input = new TarArchiveInputStream(new GzipCompressorInputStream(new FileInputStream(file)));
            } catch (IOException e) {
                try {
                    input = new TarArchiveInputStream(new BZip2CompressorInputStream(new FileInputStream(file)));
                } catch (IOException e2) {
                    input = new ZipArchiveInputStream(new FileInputStream(file));
                }
            }
            ArchiveEntry entry = input.getNextEntry();
            while (entry != null) {
                File f = new File(entry.getName());
                byte[] contents = new byte[(int) entry.getSize()];
                int offset = 0;
                int length = contents.length;
                while (offset < entry.getSize()) {
                    int actualRead = input.read(contents, offset, length);
                    length -= actualRead;
                    offset = actualRead;
                }
                if (!entry.isDirectory() && !ignored(f)) {
                    report(report, contents, f);
                }

                entry = input.getNextEntry();
            }

            input.close();
        } catch (IOException e) {
            throw new RatException(e);
        }

    public DirectoryWalker(File file) {
        this(file, (FilenameFilter) null);
    }


    /**
     * Process a directory, restricted directories will be ignored.
     *
     * @param report The report to process the directory with
     * @param file the directory to process
     * @throws RatException
     */



    protected boolean isRestricted(File file) {
        String name = file.getName();
        boolean result = name.startsWith(".");
        return result;
    }


    public final List<String> lines = new ArrayList<String>();
    public int resets = 0;
    public boolean match(Document subject, String line) {
        lines.add(line);
        return result;
    }

    public void reset() {
        resets;
    }
        final SAXParserFactory spf = SAXParserFactory.newInstance();
        spf.setValidating(false);
        spf.setNamespaceAware(true);
        return spf.newSAXParser().getXMLReader();
        try {
            newXMLReader().parse(isource);
            return true;
        } catch (SAXException e) {
            System.out.println(e);
            e.printStackTrace();
            return false;
        } catch (IOException e) {
            throw new UndeclaredThrowableException(e);
        } catch (ParserConfigurationException e) {
            throw new UndeclaredThrowableException(e);
        }
        return isWellFormedXml(new InputSource(in));
    /**
     * Private constructor, to prevent accidental instantiation.
     */
    private Resources() {
        // Does nothing
    }
    /**
     * Locates a resource file in the class path.
     */
    public static File getResourceFile(String pResource) throws IOException {
        final File f = new File("src/test/resources", pResource);
        if (!f.isFile()) {
            throw new FileNotFoundException("Unable to locate resource file: "  pResource);
        }
        return f;
    }
    /**
     * Locates a resource file in the class path and returns an {@link InputStream}.
     */
    public static InputStream getResourceStream(String pResource) throws IOException {
        return new FileInputStream(getResourceFile(pResource));
    }
    /**
     * Locates a resource file in the class path and returns a {@link Reader}.
     */
    public static Reader getResourceReader(String pResource) throws IOException {
        return new InputStreamReader(getResourceStream(pResource), "UTF-8");
    }
    /**
     * Locates a resource file in the class path and returns a {@link BufferedReader}.
     */
    public static BufferedReader getBufferedResourceReader(String pResource) throws IOException {
        return new BufferedReader(getResourceReader(pResource));
    }
    /**
     * Locates the name of a directory, which contains the given
     * resource file.
     */
    public static String getResourceDirectory(String pResource) throws IOException {
        final File resource = getResourceFile(pResource);
        final File dir = resource.getParentFile();
        return DocumentImplUtils.toName(dir);
    }
        "Print help for the Rat command line interface and exit");
        footer.append("Rat is really little more than a grep ATM\n");
        footer.append("Rat is also rather memory hungry ATM\n");
        footer.append("Rat is very basic ATM\n");
        footer.append("Rat highlights possible issues\n");
        footer.append("Rat reports require intepretation\n");
        footer.append("Rat often requires some tuning before it runs well against a project\n");
        footer.append("Rat relies on heuristics: it may miss issues\n");
     * @since Rat 0.8
     * @since Rat 0.8
     * If Rat is adding license headers: Returns the optional
     * If Rat is adding license headers: Sets the optional
     * If Rat is adding license headers: Returns, whether adding
     * If Rat is adding license headers: Sets, whether adding
     * Returns, whether Rat should add missing license headers.
     * Returns, whether Rat should add missing license headers.
 * @since Rat 0.9
 * @since Rat 0.8
 * @since Rat 0.8
 * Abstract base class for Mojos, which are running Rat.
 * Run Rat to perform a violation check.
 * Generates a report with Rat's output.
     * Searches for a Rat artifact in the dependency list and returns its version.
 * @since Rat Antlib 0.9
 *   <li>xml - Rat's native XML output.</li>
 *   <li>plain - plain text using Rat's built-in stylesheet.  This is
 * @since Rat Antlib 0.8
    public static final String[] IDEA_DEFAULT_EXCLUDES = new String[] { "*.iml", "*.ipr", "*.iws", ".idea/**/*" };
     * given by the constant IDEA_DEFAULT_EXCLUDES: The *.iml, *.ipr and *.iws files and the .idea directory.
     * The default excludes are:
     * <ul>
     *   <li>meta data files for version control systems</li>
     *   <li>temporary files used by Maven, see <a href="#useMavenDefaultExcludes">useMavenDefaultExcludes</a></li>
     *   <li>configuration files for Eclipse, see <a href="#useEclipseDefaultExcludes">useEclipseDefaultExcludes</a></li>
     *   <li>configuration files for IDEA, see <a href="#useIdeaDefaultExcludes">useIdeaDefaultExcludes</a></li>
     * </ul>
     * given by the constant MAVEN_DEFAULT_EXCLUDES: The <code>target</code> directory, the <code>cobertura.ser</code>
     * file, and so on.
     * are given by the constant ECLIPSE_DEFAULT_EXCLUDES: The <code>.classpath</code> and <code>.project</code> files,
     * the <code>.settings</code> directory, and so on.
     * given by the constant IDEA_DEFAULT_EXCLUDES: The <code>*.iml</code>, <code>*.ipr</code> and <code>*.iws</code>
     * files and the <code>.idea</code> directory.
        getLog().info("Rat check: Summary of files. Unapproved: "  statistics.getNumUnApproved()  " unknown: "  statistics.getNumUnknown()  " generated: "  statistics.getNumGenerated()  " approved: "  statistics.getNumApproved()  " licence.");
            final String seeReport = " See RAT report in: "  reportFile;
                throw new RatCheckException( "Too many files with unapproved license: "  statistics.getNumUnApproved()  seeReport);
                getLog().warn( "Rat check: "  statistics.getNumUnApproved()  " files with unaproved licenses."  seeReport);
     *
     *

     *
     *
     *
     *

     *
     *
     *
        final List<String> excludeList = buildDefaultExclusions();
            getLog().info( "No excludes explicitly specified." );
    private List<String> buildDefaultExclusions() {
        final List<String> results = new ArrayList<String>();

        addPlexusDefaults(results);

        addMavenDefaults(results);

        addEclipseDefaults(results);

        addIdeaDefaults(results);

        if ( excludeSubProjects && project != null && project.getModules() != null )
        {
            for (Object o : project.getModules()) {
                String moduleSubPath = (String) o;
                results.add(moduleSubPath  "/**/*");
            }
        }

        getLog().debug("Finished creating list of implicit excludes.");
        if (results.isEmpty()) {
            getLog().info( "No excludes implicitly specified." );
        } else {
            getLog().info( results.size()  " implicit excludes (use -debug for more details)." );
            for ( final String exclude : results ) {
                getLog().debug( "Implicit exclude: "  exclude);
            }
        }

        return results;
    }

    private void addPlexusDefaults(final List<String> excludeList1) {
        if ( useDefaultExcludes )
        {
            getLog().debug("Adding plexus default exclusions...");
            add( excludeList1, DirectoryScanner.DEFAULTEXCLUDES );
        }
        else
        {
            getLog().debug("rat.useDefaultExcludes set to false. " 
            		"Plexus default exclusions will not be added");
        }
    }

    private void addMavenDefaults(final List<String> excludeList1) {
        if ( useMavenDefaultExcludes )
        {
            getLog().debug("Adding exclusions often needed by Maven projects...");
            add( excludeList1, MAVEN_DEFAULT_EXCLUDES );
        }
        else
        {
            getLog().debug("rat.useMavenDefaultExcludes set to false. " 
            		"Exclusions often needed by Maven projects will not be added.");
        }
    }

    private void addEclipseDefaults(final List<String> excludeList1) {
        if ( useEclipseDefaultExcludes )
        {
            getLog().debug("Adding exclusions often needed by projects " 
            		"developed in Eclipse...");
            add( excludeList1, ECLIPSE_DEFAULT_EXCLUDES );
        }
        else
        {
            getLog().debug("rat.useEclipseDefaultExcludes set to false. " 
                    "Exclusions often needed by projects developed in " 
                    "Eclipse will not be added.");
        }
    }

    private void addIdeaDefaults(final List<String> excludeList1) {
        if ( useIdeaDefaultExcludes )
        {
            getLog().debug("Adding exclusions often needed by projects " 
                    "developed in IDEA...");
            add( excludeList1, IDEA_DEFAULT_EXCLUDES );
        }
        else
        {
            getLog().debug("rat.useIdeaDefaultExcludes set to false. " 
                    "Exclusions often needed by projects developed in " 
                    "IDEA will not be added.");
        }
    }

     *
        final DirectoryScanner ds = new DirectoryScanner();
        whenDebuggingLogExcludedFiles(ds);
    private void whenDebuggingLogExcludedFiles(final DirectoryScanner ds) {
        if (getLog().isDebugEnabled()) {
            final String[] excludedFiles = ds.getExcludedFiles();
            if (excludedFiles.length == 0) {
                getLog().debug("No excluded resources.");
            } else {
                getLog().debug("Excluded "  excludedFiles.length  " resources:");
                for (final String resource : excludedFiles) {
                    getLog().debug(" - excluded "  resource);
                }
            }
        }
    }

        logAboutIncludedFiles(files);
    private void logAboutIncludedFiles(final String[] files) {
        if (files.length == 0) {
            getLog().warn("No resources included.");
        } else {
            getLog().info(files.length  " resources included (use -debug for more details)");
            if(getLog().isDebugEnabled()) {
                for (String resource: files) {
                    getLog().debug(" - included "  resource);
                }
            }
        }
    }

                getLog().warn( "Rat check: "  statistics.getNumUnApproved()  " files with unapproved licenses."  seeReport);
                    @SuppressWarnings("unchecked") // method generates list of Strings, but is not yet generic
                    List<String> excludes = FileUtils.readLines(new File(excludeFileName));
                    for (String exclude : excludes) {
                        orFilter.addFileFilter(new RegexFileFilter(exclude));
    @Deprecated
    @Deprecated
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
  @Override
        @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    public final List<Object> calls;
        calls = new ArrayList<Object>();
    private static final Map<String, Integer> EXT2TYPE = new HashMap<String, Integer>();
    private final Map<String, String> parameters;
    public ContentType(final String mediaType, final String subType, final Map<String, String> parameters) {
        this.parameters = new HashMap<String, String>(parameters.size());
        for (Map.Entry<String, String> entry : parameters.entrySet()) {
    public Map<String, String> getParameters() {
    public Collection<Datum> getData() {
        for (final Iterator<Datum> it = data.iterator();it.hasNext();) {
            final Datum datum = it.next();
import org.apache.commons.io.IOUtils;

            IOUtils.closeQuietly(zip);
        List<String> l = Arrays.asList(NoteGuesser.NOTE_FILE_NAMES);
    private Map<String, Integer> documentCategoryMap, licenseFamilyCodeMap, licenseFamilyNameMap;
    public void setDocumentCategoryMap(Map<String, Integer> pDocumentCategoryMap) {
    public Map<String, Integer> getDocumentCategoryMap() {
    public Map<String, Integer> getLicenseFileCodeMap() {
    public void setLicenseFileCodeMap(Map<String, Integer> pLicenseFamilyCodeMap) {
    public Map<String, Integer> getLicenseFileNameMap() {
    public void setLicenseFileNameMap(Map<String, Integer> pLicenseFamilyNameMap) {
    private final Map<String, Integer> numsByLicenseFamilyName = new HashMap<String, Integer>();
    private final Map<String, Integer> numsByLicenseFamilyCode = new HashMap<String, Integer>();
    private final Map<String, Integer> numsByFileType = new HashMap<String, Integer>();
    private void incMapValue(Map<String, Integer> pMap, String pKey) {
        final Integer num = pMap.get(pKey);
    private final List<? extends RatReport> reporters;
    public ClaimReporterMultiplexer(final IDocumentAnalyser pAnalyser, final List<? extends RatReport> reporters) {
        for (RatReport report : reporters) {
        for (RatReport report : reporters) {
        for (RatReport report : reporters) {
        final List<RatReport> reporters = new ArrayList<RatReport>();
    private final Set<CharSequence> currentAttributes = new HashSet<CharSequence>();
class FileNameComparator implements Comparator<File> {
    public int compare(File firstFile, File secondFile) {
    @Deprecated
    @Deprecated
        final List<IHeaderMatcher> list = new ArrayList<IHeaderMatcher>();
        return list.toArray( new IHeaderMatcher[list.size()] );
            @SuppressWarnings("unchecked") // incorrect cast will be caught below
            final T o = (T) cl.loadClass( className ).newInstance();

            if ( !clazz.isAssignableFrom( o.getClass() ) )
            {
                throw new MojoFailureException( "The class "  o.getClass().getName()  " does not implement "
                                 clazz.getName() );
            }
            return o;
            String[] allExcludes = excludeList.toArray( new String[excludeList.size()] );
        final List<ILicenseFamily> list = new ArrayList<ILicenseFamily>();
        return list.toArray( new ILicenseFamily[ list.size() ] );
        @Override
    @Override
            Artifact a = iter.next();
    private ArrayList<IHeaderMatcher> licenseMatchers = new ArrayList<IHeaderMatcher>();
    private ArrayList<ILicenseFamily> licenseNames = new ArrayList<ILicenseFamily>();
    @Override
            matchers = licenseMatchers.toArray(new IHeaderMatcher[0]);
            results = licenseNames.toArray(new ILicenseFamily[0]);
        @Override
        @Override
        for (Iterator<?> iter = rc.iterator(); iter.hasNext(); ) {
    private List<String> patterns = new ArrayList<String>();
        return patterns.toArray(new String[0]);
                while(readLine(headers)) {
                    // do nothing
                }
            return; // dummy return (won't be reached) to avoid Eclipse complaint about possible NPE for "cl"
        @SuppressWarnings("static-access") // ignore OptionBuilder design fault
        @SuppressWarnings("static-access") // ignore OptionBuilder design fault
     * @deprecated use {@link #report(PrintStream, ReportConfiguration)} instead
     * @deprecated use {@link #styleReport(PrintStream, ReportConfiguration)} instead
            writer.close();
        for ( @SuppressWarnings("unchecked") // library is not yet generified
        Iterator<Artifact> iter = getProject().getDependencyArtifacts().iterator(); iter.hasNext(); )
            final String name = file.getName();
            final File dir = file.getParentFile();
            final StringBuilder headers = new StringBuilder();
    boolean readLine(StringBuilder headers) throws IOException, RatHeaderAnalysisException {
 * It is useful to note these separately.
    private void reportOnLicense(Document subject) {
    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    private static final Pattern[] EMPTY_PATTERN_ARRAY = new Pattern[0];

    private static final String[] DEFAULT_PHRASES = {
        "generated by Cayenne",
        "Generated By:JJTree",
        "Generated By:JavaCC",
        "THIS FILE IS AUTOMATICALLY GENERATED",
        "NOTE: this file is autogenerated by XBeans",
        "This file was automatically generated by ",
        "# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!",
        "# Microsoft Developer Studio Generated NMAKE File",
        "# Microsoft Developer Studio Generated Build File",
        "Generated from configure.ac by autoheader",
        "generated automatically by aclocal",
        "build.xml generated by maven from project.xml",
        "This file was generated by",
        "This file has been automatically generated.",
        "Automatically generated - do not modify!",
        "Javadoc style sheet",
        "SOURCE FILE GENERATATED",
        "Generated by the Batik",
        "this file is autogenerated",
        "This class was autogenerated",
        "Generated by Maven",
        "Autogenerated by Thrift",
        "DO NOT EDIT THIS FILE - it is machine generated",
        "This class was generated by"};
    // Uses either patterns or strings currently (not both)
    private final String[] phrases;
        this(DEFAULT_PHRASES);
        this.phrases = EMPTY_STRING_ARRAY;
    }

    public GeneratedLicenseNotRequired(final String[] lines) {
        this.linePatterns = EMPTY_PATTERN_ARRAY;
        this.phrases = lines;
        for (Pattern pat : linePatterns) {
            if (pat.matcher(line).matches()) {
        for(String phrase : phrases) {
            if (line.contains(phrase)) {
                result = true;
                reportOnLicense(subject);
                break;
            }                
        }
    private void reportOnLicense(Document subject) {

    protected static final String prune(String text) {
        final int length = text.length();
        final StringBuilder buffer = new StringBuilder(length);
        for (int i = 0; i < length; i) {
            char at = text.charAt(i);
            if (Character.isLetterOrDigit(at)) {
                buffer.append(at);
            }
        }
        return buffer.toString();
    }

import java.util.Locale;
    private String fullText;

        fullText = prune(text).toLowerCase(Locale.ENGLISH);
        return fullText != null;
    // TODO this is still quite inefficient if the match does not occur near the start of the buffer
    // see RAT-138
        buffer.append(prune(line).toLowerCase(Locale.ENGLISH));
        if (buffer.toString().contains(fullText)) {
    private static final String COPYRIGHT_PATTERN_DEFN = ".*Copyright\\s.*OASIS Open.*";
     * Locates a set of resource files in the class path.
     */
    public static File[] getResourceFiles(String pResource) throws IOException {
        final File f = new File("src/test/resources", pResource);
        if (!f.isDirectory()) {
            throw new FileNotFoundException("Unable to locate resource directory: "  f);
        }
        return f.listFiles();
    }

    /**
     * Locates a resource file in the class path and returns a {@link BufferedReader}.
     */
    public static BufferedReader getBufferedReader(File file) throws IOException {
        return new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
    }

    /**
    // Number of match characters assumed to be present on first line
    private static final int DEFAULT_INITIAL_LINE_LENGTH = 20;

    
    private String firstLine;

    private boolean seenFirstLine = false;
        int offset = text.indexOf('\n');
        if (offset == -1) {
            offset = Math.min(DEFAULT_INITIAL_LINE_LENGTH, text.length());
        }
        firstLine = prune(text.substring(0, offset)).toLowerCase(Locale.ENGLISH);
        init();
        final String inputToMatch = prune(line).toLowerCase(Locale.ENGLISH);
        if (seenFirstLine) { // Accumulate more input
            buffer.append(inputToMatch);
        } else {
            int offset = inputToMatch.indexOf(firstLine);
            if (offset >= 0) {
                // we have a match, save the text starting with the match
                buffer.append(inputToMatch.substring(offset));
                seenFirstLine = true;
                // Drop out to check whether full text is matched
            } else {
                // we assume that the first line must appear in a single line
                return false; // no more to do here
            }
        }
 
        if (buffer.length() >= fullText.length()) { // we have enough data to match
            if (buffer.toString().contains(fullText)) {
                reportOnLicense(subject);
                return true; // we found a match
            } else { // buffer contains first line but does not contain full text
                // It's possible that the buffer contains the first line again
                int offset = buffer.substring(1).toString().indexOf(firstLine);
                if (offset >= 0) { // first line found again
                    buffer.delete(0,offset); // reset buffer to the new start
                } else { // buffer does not even contain first line, so cannot be used to match full text
                    init();
                }
            }
        init();
    }

    // This is called indirectly from a ctor so must be final or private
    private void init() {
        seenFirstLine = false;
    private static final String JAVADOC_REGEX_DEFN = "Generated by javadoc";
        boolean result = line.contains(JAVADOC_REGEX_DEFN);
    protected boolean matchCopyright(String s) {
    // Called by ctor, so must not be overridden
    public final void setCopyrightOwner(String copyrightOwner) {
        for (IHeaderMatcher matcher : matchers) {
            result = matcher.match(subject, line);
        for (IHeaderMatcher matcher : matchers) {
            matcher.reset();
        for (IDocumentAnalyser analyser : analysers) {
            analyser.analyse(document);
import org.junit.Assert;
        final File[] resourceFiles = Resources.getResourceFiles(directory);
        if (resourceFiles.length == 0) {
            Assert.fail("No files found under "directory);
        }
        for(File f : resourceFiles) {
import java.io.FileFilter;
        return f.listFiles(new FileFilter(){
            public boolean accept(File pathname) {
                return pathname.isFile();
            }});
    public final void reportOnLicense(Document subject) {
    private final FullTextMatchingLicense textMatcher;
        textMatcher = new FullTextMatchingLicense(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_ASL, MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_APACHE_LICENSE_VERSION_2_0,"",ASL20_LICENSE_DEFN);
            return textMatcher.match(subject, s); // will report the match if it has occurred
        textMatcher.reset();
                    "Plexus default exclusions will not be added");
                    "Exclusions often needed by Maven projects will not be added.");
                    "developed in Eclipse...");
 * Matches Apache License, Version 2.0
 * Add an Apache Licence V2 licence header to a 
 * Matches an applied AL 2.0 License header, including a <em>required</em>
 * from the AL 2.0 license itself.
 * This file does intentionally *NOT* contain an AL license header,
//    public List visitors = new ArrayList();
import org.apache.rat.analysis.license.CDDL1License;
            new TMF854LicenseHeader(),
            new CDDL1License(),
    public static final String RAT_LICENSE_FAMILY_CATEGORY_VALUE_CDDL1 = "CDDL1";
    public static final Datum RAT_LICENSE_FAMILY_CATEGORY_DATUM_CDLL1 = new Datum(RAT_URL_LICENSE_FAMILY_CATEGORY,RAT_LICENSE_FAMILY_CATEGORY_VALUE_CDDL1);
    public static final String RAT_LICENSE_FAMILY_NAME_VALUE_CDDL1 =
            "COMMON DEVELOPMENT AND DISTRIBUTION LICENSE Version 1.0";
    public static final Datum
            RAT_LICENSE_FAMILY_NAME_DATUM_CDDL1 = new Datum(RAT_URL_LICENSE_FAMILY_NAME, RAT_LICENSE_FAMILY_NAME_VALUE_CDDL1);
        MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_CDDL1,
@Mojo (name = "check", defaultPhase = LifecyclePhase.VALIDATE)
        "ear", "mar",
        "par", "xar",
    private static final int TYPE_BEANSHELL = 23;
    private static final int TYPE_JSP = 24;
    private static final int TYPE_FML = 25;
        TYPE_BEANSHELL,
        TYPE_XML, TYPE_HTML, TYPE_JSP, TYPE_FML,
        EXT2TYPE.put("bsh", Integer.valueOf(TYPE_BEANSHELL));
        EXT2TYPE.put("fml", Integer.valueOf(TYPE_FML));
        EXT2TYPE.put("jsp", Integer.valueOf(TYPE_JSP));
            return " * "  content  LINE_SEP;
            return "~~ "  content  LINE_SEP;
            return "# "  content  LINE_SEP;
            return "rem "  content  LINE_SEP;
            return "## "  content  LINE_SEP;
            return " */"  LINE_SEP;
                        writer.write(LINE_SEP);
                        writer.write(LINE_SEP);
                        writer.write(LINE_SEP);
        "odb", "odf",
        "odg", "odp",
        "ods", "odt",
    private static final Pattern LICENSE_LINE_PATTERN = Pattern.compile(LICENSE_LINE);
    private static final Pattern LICENSE_URL_PATTERN = Pattern.compile(LICENSE_URL);    

                "", new String[]{});
        	return 
        			super.matches(pLine) ||
        			LICENSE_LINE_PATTERN.matcher(pLine).find() ||
        			LICENSE_URL_PATTERN.matcher(pLine).find();
        final Datum licenseHeader = document.getMetaData().get(MetaData.RAT_URL_HEADER_CATEGORY);
     * @param out - the output stream to receive the styled report
     * @throws Exception in case of errors.
     * 
     * 
     * @return the currently collected numerical statistics.
     * @param out - the output stream to receive the styled report
     * @param configuration - current configuration options.
     * @throws Exception in case of errors.
     * 
     * @return the currently collected numerical statistics.
     * @param out - the output stream to receive the styled report
     * @throws Exception in case of errors.
     * @throws Exception in case of errors.
     * @param pConfiguration current report configuration.
     * 
     * @throws IOException in case of I/O errors.
     * @throws TransformerConfigurationException in case of XML errors.
     * @throws InterruptedException in case of threading errors.
     * @throws RatException in case of internal errors.
     * @param pConfiguration current report configuration.
     * 
     * @throws FileNotFoundException in case of I/O errors.
     * @throws IOException in case of I/O errors.
     * @throws TransformerConfigurationException in case of XML errors.
     * @throws InterruptedException in case of threading errors.
     * @throws RatException in case of internal errors.
     * 
     * @return the currently collected numerical statistics.
     * @param pConfiguration current report configuration.
     * 
     * @throws IOException in case of I/O errors.
     * @throws RatException in case of internal errors.
     * 
     * @return the currently collected numerical statistics.
     * @return the header matcher.
     * @param headerMatcher header matcher.
     * @return the set of approved license names.
     * @param approvedLicenseNames set of approved license names.
     * @return If Rat is adding license headers: Returns the optional
     * @param copyrightMessage message to set.
     * @return If Rat is adding license headers: Returns, whether adding
     * @param addingLicensesForced enable/disable forcibly adding licenses.
     * @return Returns, whether Rat should add missing license headers.
     * @param addingLicenses enabled/disables adding of licenses.
    void reset();
     * @param subject current document.
     * 
     * @return whether the current line matched in the document.
     * 
     * @throws RatHeaderAnalysisException in case of internal RAT errors.
    boolean match(Document subject, String line) throws RatHeaderAnalysisException;
 * Example supported Copyright header lines, using copyright owner &quot;FooBar&quot;
 * <ul>
 * can support additional regex but also requires escaping where needed,<br>
  * e.g. use &quot;FooBar \(www\.foobar\.com\)&quot; for matching &quot;FooBar (www.foobar.com)&quot;</p>
    private static final String DOT = ".";
	private static final int TYPE_UNKNOWN = 0;
     * @param document document to append to.
     *           if there is a problem while reading or writing the file
     * @param document to retrieve type from.
        int lastDot = path.lastIndexOf(DOT);
     * @param force force flag.
    public void setForce(boolean force) {
        isForced = force;
     * @return Get the licence header of a document.
     * @param document document to extract from. 
   * the form &quot;Copyright 2008 Foo&quot;
   * @param copyright copyright line. 
    String getName();
    Reader reader() throws IOException;
    InputStream inputStream() throws IOException;
    MetaData getMetaData();
    boolean isComposite();
     * @param datum datum to add.
     * @return guessed content type, not null.
     * @throws IOException in case of I/O errors.
    ContentType type(final InputStream inputStream, String name) throws IOException;
    private static final String UTF_8 = "UTF-8";
	private static final String FILE_URL_PREFIX = "file";
	
	private final File file;
     * @return Creates and returns a new instance. 
     * 
     * @param url The document is read from the given URL.
        if (FILE_URL_PREFIX.equals(url.getProtocol())) {
                return new InputStreamReader(inputStream(), UTF_8);
     public MonolithicFileDocument(final File file) {
     public Reader reader() throws IOException {
     public InputStream inputStream() throws IOException {
    private static final String DOT = ".";
	public static final String[] ARCHIVE_EXTENSIONS = {
    /**
     * @param document the current document. 
     * @return whether the given document is an archive.
     */
     * @return Is a file by that name an archive?
     * @param name file name to check against.
            if (nameToLower.endsWith(DOT  ArchiveGuesser.ARCHIVE_EXTENSIONS[i])) {
 * TODO: factor into MIME guesser and MIME-&gt;binary guesser
    private static final String DOT = ".";

	private static boolean isBinaryDocument(Document document) {
     * @param in the file to check.
     * 
     * @return Do the first few bytes of the stream hint at a binary file?
     * @param in the file to check.
     * 
     * @return Do the first few bytes of the stream hint at a binary file?
    
    /**
     * 
     * @param name current file name.
     * @return whether given name is binary.
     */
     * @return Is a file by that name a known non-binary file?
     * @param name current file name.
    /**
     * @return Is a file by that name an executable/binary file?
     * @param name current file name.
     */
            if (name.indexOf(DOT  exts[i]  DOT) >= 0) {
            if (name.endsWith(DOT  exts[i])) {
     * @return Is a file by that name a known binary file?
     * @param name file name.
    private static final String DOT = ".";
	public static final String[] NOTE_FILE_NAMES = {
     * @return Is a file by that name a note file?
     * @param name file name.
            if (normalisedName.endsWith(DOT  NoteGuesser.NOTE_FILE_EXTENSIONS[i])) {
    void run(RatReport report) throws RatException;
    void startReport() throws RatException;
    void report(Document document) throws RatException;
    void endReport() throws RatException;
     * @return Returns the number of files with approved licenses.
     * @param pNumApproved number of files with approved licenses.
     * @return Returns the number of files with unapproved licenses.
     * Sets the number of files with unapproved licenses.
     * @param pNumUnApproved number of files with unapproved licenses.
     * @return Returns the number of generated files.
     * Sets the number of generated files.
     * @param pNumGenerated the number of generated files.
     * @return Returns the number of files, which are neither
     * @param pNumUnknown set number of files. 
     * @param pDocumentCategoryMap doc-category map.
     * @return Returns a map with the file types. The map keys
     * @return Returns a map with the license family codes. The map
     * @param pLicenseFamilyCodeMap license family map.
     * @return Returns a map with the license family codes. The map
     * Sets map with the license family codes. The map
     * @param pLicenseFamilyNameMap license family-name map.
     * @throws FileNotFoundException in case of I/O errors. 
     * 
    @Parameter(name = "project", readonly = true)
     * @return Returns the Maven project.
     * 
     * @return the current statistic.
     * 
    /**
     * Will skip the plugin execution, e.g. for technical builds that do not take licence compliance into account.
     * @since 0.11
     */
    @Parameter(property = "rat.skip", defaultValue = "false")
    private boolean skip;

    	if(skip) {
    		getLog().info("RAT will not execute since it is configured to be skipped via system property 'rat.skip'.");
    		return;
    	}
    	
        final File parent = reportFile.getParentFile();
// MavenReport.java induces the deprecated Sink implementation
@SuppressWarnings("deprecation")
	
	/**
     * Specifies the directory where the report will be generated
     */
    @Parameter(defaultValue = "${project.reporting.outputDirectory}", required = true)
    private File outputDirectory;
     * 
    public void generate(Sink sink, Locale locale ) throws MavenReportException
     * @param rc resource to check.
     * @param matcher Adds a license matcher.
     * @param addDefaultLicenseMatchers Whether to add the default list of license matchers.
    public void setAddDefaultLicenseMatchers(boolean addDefaultLicenseMatchers) {
        this.addDefaultLicenseMatchers = addDefaultLicenseMatchers;
     * @param f report output file.
     * @param f format. 
     * @param pAdd Whether to add license headers. 
     * @param pMessage copyright message to set.
     * @param u stylesheet.
     * 
     * @param out stream to write report to.
     * 
     * @throws IOException in case of I/O errors.
     * @throws InterruptedException in case of threading errors.
     * @throws TransformerException in case of XML errors.
     * @throws RatException in case of general errors.
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.DateFormatUtils;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import javax.xml.transform.TransformerConfigurationException;

public abstract class AbstractRatMojo extends AbstractMojo {
	/**
	 * The Maven specific default excludes.
	 */
	static final List<String> MAVEN_DEFAULT_EXCLUDES = Collections
			.unmodifiableList(Arrays.asList("target/**/*", //
					"cobertura.ser", //
					"release.properties", //
					"pom.xml.releaseBackup"));
	/**
	 * The Eclipse specific default excludes.
	 */
	static final List<String> ECLIPSE_DEFAULT_EXCLUDES = Collections
			.unmodifiableList(Arrays.asList(".classpath",//
					".project", //
					".settings/**/*"));
	/**
	 * The IDEA specific default excludes.
	 */
	static final List<String> IDEA_DEFAULT_EXCLUDES = Collections
			.unmodifiableList(Arrays.asList(//
					"*.iml", //
					"*.ipr", //
					"*.iws", //
					".idea/**/*"));
	/**
	 * The base directory, in which to search for files.
	 *
	 */
	@Parameter(property = "rat.basedir", defaultValue = "${basedir}", required = true)
	protected File basedir;
	/**
	 * Specifies the licenses to accept. Deprecated, use {@link #licenses}
	 * instead.
	 *
	 * @deprecated Use {@link #licenses} instead.
	 */
	@Deprecated
	@Parameter
	private HeaderMatcherSpecification[] licenseMatchers;
	/**
	 * Specifies the licenses to accept. By default, these are added to the
	 * default licenses, unless you set {@link #addDefaultLicenseMatchers} to
	 * true.
	 *
	 * @since 0.8
	 */
	@Parameter
	private IHeaderMatcher[] licenses;
	/**
	 * The set of approved license family names.
	 * 
	 * @deprecated Use {@link #licenseFamilies} instead.
	 */
	@Deprecated
	private LicenseFamilySpecification[] licenseFamilyNames;
	/**
	 * Specifies the license families to accept.
	 *
	 * @since 0.8
	 */
	@Parameter
	private ILicenseFamily[] licenseFamilies;
	/**
	 * Whether to add the default list of license matchers.
	 *
	 */
	@Parameter(property = "rat.addDefaultLicenseMatchers", defaultValue = "true")
	private boolean addDefaultLicenseMatchers;
	/**
	 * Specifies files, which are included in the report. By default, all files
	 * are included.
	 *
	 */
	@Parameter
	private String[] includes;
	/**
	 * Specifies files, which are excluded in the report. By default, no files
	 * are excluded.
	 *
	 */
	@Parameter
	private String[] excludes;
	/**
	 * Whether to use the default excludes when scanning for files. The default
	 * excludes are:
	 * <ul>
	 * <li>meta data files for version control systems</li>
	 * <li>temporary files used by Maven, see <a
	 * href="#useMavenDefaultExcludes">useMavenDefaultExcludes</a></li>
	 * <li>configuration files for Eclipse, see <a
	 * href="#useEclipseDefaultExcludes">useEclipseDefaultExcludes</a></li>
	 * <li>configuration files for IDEA, see <a
	 * href="#useIdeaDefaultExcludes">useIdeaDefaultExcludes</a></li>
	 * </ul>
	 */
	@Parameter(property = "rat.useDefaultExcludes", defaultValue = "true")
	private boolean useDefaultExcludes;
	/**
	 * Whether to use the Maven specific default excludes when scanning for
	 * files. Maven specific default excludes are given by the constant
	 * MAVEN_DEFAULT_EXCLUDES: The <code>target</code> directory, the
	 * <code>cobertura.ser</code> file, and so on.
	 */
	@Parameter(property = "rat.useMavenDefaultExcludes", defaultValue = "true")
	private boolean useMavenDefaultExcludes;
	/**
	 * Whether to use the Eclipse specific default excludes when scanning for
	 * files. Eclipse specific default excludes are given by the constant
	 * ECLIPSE_DEFAULT_EXCLUDES: The <code>.classpath</code> and
	 * <code>.project</code> files, the <code>.settings</code> directory, and so
	 * on.
	 */
	@Parameter(property = "rat.useEclipseDefaultExcludes", defaultValue = "true")
	private boolean useEclipseDefaultExcludes;
	/**
	 * Whether to use the IDEA specific default excludes when scanning for
	 * files. IDEA specific default excludes are given by the constant
	 * IDEA_DEFAULT_EXCLUDES: The <code>*.iml</code>, <code>*.ipr</code> and
	 * <code>*.iws</code> files and the <code>.idea</code> directory.
	 */
	@Parameter(property = "rat.useIdeaDefaultExcludes", defaultValue = "true")
	private boolean useIdeaDefaultExcludes;
	/**
	 * Whether to exclude subprojects. This is recommended, if you want a
	 * separate apache-rat-plugin report for each subproject.
	 *
	 */
	@Parameter(property = "rat.excludeSubprojects", defaultValue = "true")
	private boolean excludeSubProjects;
	/**
	@Parameter(name = "project", readonly = true)
	private MavenProject project;
	/**
	 * @return Returns the Maven project.
	 */
	protected MavenProject getProject() {
		return project;
	}
	/**
	 * Returns the set of {@link IHeaderMatcher header matchers} to use.
	 *
	 * @throws MojoFailureException
	 *             An error in the plugin configuration was detected.
	 * @throws MojoExecutionException
	 *             An error occurred while calculating the result.
	 * @return Array of license matchers to use
	 */
	protected IHeaderMatcher[] getLicenseMatchers()
			throws MojoFailureException, MojoExecutionException {
		final List<IHeaderMatcher> list = new ArrayList<IHeaderMatcher>();
		if (licenses != null) {
			list.addAll(Arrays.asList(licenses));
		}
		if (licenseMatchers != null) {
			for (final HeaderMatcherSpecification spec : licenseMatchers) {
				final String className = spec.getClassName();
				final IHeaderMatcher headerMatcher = newInstance(
						IHeaderMatcher.class, className);
				list.add(headerMatcher);
			}
		}
		if (addDefaultLicenseMatchers) {
			list.addAll(Arrays.asList(Defaults.DEFAULT_MATCHERS));
		}
		return list.toArray(new IHeaderMatcher[list.size()]);
	}
	private <T> T newInstance(final Class<T> clazz, final String className)
			throws MojoExecutionException, MojoFailureException {
		try {
			final ClassLoader cl = Thread.currentThread()
					.getContextClassLoader();
			@SuppressWarnings("unchecked")
			// incorrect cast will be caught below
			final T o = (T) cl.loadClass(className).newInstance();
			if (!clazz.isAssignableFrom(o.getClass())) {
				throw new MojoFailureException("The class "
						 o.getClass().getName()  " does not implement "
						 clazz.getName());
			}
			return o;
		} catch (InstantiationException e) {
			throw new MojoExecutionException("Failed to instantiate class "
					 className  ": "  e.getMessage(), e);
		} catch (ClassCastException e) {
			throw new MojoExecutionException("The class "  className
					 " is not implementing "  clazz.getName()  ": "
					 e.getMessage(), e);
		} catch (IllegalAccessException e) {
			throw new MojoExecutionException("Illegal access to class "
					 className  ": "  e.getMessage(), e);
		} catch (ClassNotFoundException e) {
			throw new MojoExecutionException("Class "  className
					 " not found: "  e.getMessage(), e);
		}
	}
	/**
	 * Adds the given string array to the list.
	 *
	 * @param pList
	 *            The list to which the array elements are being added.
	 * @param pArray
	 *            The strings to add to the list.
	 */
	private static void add(List<String> pList, String[] pArray) {
		if (pArray != null) {
			Collections.addAll(pList, pArray);
		}
	}
	/**
	 * Creates an iterator over the files to check.
	 *
	 * @return A container of files, which are being checked.
	 */
	protected IReportable getResources() {
		final DirectoryScanner ds = new DirectoryScanner();
		ds.setBasedir(basedir);
		setExcludes(ds);
		setIncludes(ds);
		ds.scan();
		whenDebuggingLogExcludedFiles(ds);
		final String[] files = ds.getIncludedFiles();
		logAboutIncludedFiles(files);
		try {
			return new FilesReportable(basedir, files);
		} catch (IOException e) {
			throw new UndeclaredThrowableException(e);
		}
	}
	private void logAboutIncludedFiles(final String[] files) {
		if (files.length == 0) {
			getLog().warn("No resources included.");
		} else {
			getLog().info(
					files.length
							 " resources included (use -debug for more details)");
			if (getLog().isDebugEnabled()) {
				for (String resource : files) {
					getLog().debug(" - included "  resource);
				}
			}
		}
	}
	private void whenDebuggingLogExcludedFiles(final DirectoryScanner ds) {
		if (getLog().isDebugEnabled()) {
			final String[] excludedFiles = ds.getExcludedFiles();
			if (excludedFiles.length == 0) {
				getLog().debug("No excluded resources.");
			} else {
				getLog().debug(
						"Excluded "  excludedFiles.length  " resources:");
				for (final String resource : excludedFiles) {
					getLog().debug(" - excluded "  resource);
				}
			}
		}
	}
	private void setIncludes(DirectoryScanner ds) {
		if (includes != null) {
			ds.setIncludes(includes);
		}
	}
	private void setExcludes(DirectoryScanner ds) {
		final List<String> excludeList = buildDefaultExclusions();
		if (excludes == null || excludes.length == 0) {
			getLog().info("No excludes explicitly specified.");
		} else {
			for (String exclude : excludes) {
				getLog().info("Exclude: "  exclude);
			}
		}
		add(excludeList, excludes);
		if (!excludeList.isEmpty()) {
			String[] allExcludes = excludeList.toArray(new String[excludeList
					.size()]);
			ds.setExcludes(allExcludes);
		}
	}
	private List<String> buildDefaultExclusions() {
		final List<String> results = new ArrayList<String>();
		addPlexusDefaults(results);
		addMavenDefaults(results);
		addEclipseDefaults(results);
		addIdeaDefaults(results);
		if (excludeSubProjects && project != null
				&& project.getModules() != null) {
			for (Object o : project.getModules()) {
				String moduleSubPath = (String) o;
				results.add(moduleSubPath  "/**/*");
			}
		}
		getLog().debug("Finished creating list of implicit excludes.");
		if (results.isEmpty()) {
			getLog().info("No excludes implicitly specified.");
		} else {
			getLog().info(
					results.size()
							 " implicit excludes (use -debug for more details).");
			for (final String exclude : results) {
				getLog().debug("Implicit exclude: "  exclude);
			}
		}
		return results;
	}
	private void addPlexusDefaults(final List<String> excludeList1) {
		if (useDefaultExcludes) {
			getLog().debug("Adding plexus default exclusions...");
			Collections.addAll(excludeList1, DirectoryScanner.DEFAULTEXCLUDES);
		} else {
			getLog().debug(
					"rat.useDefaultExcludes set to false. "
							 "Plexus default exclusions will not be added");
		}
	}
	private void addMavenDefaults(final List<String> excludeList1) {
		if (useMavenDefaultExcludes) {
			getLog().debug(
					"Adding exclusions often needed by Maven projects...");
			excludeList1.addAll(MAVEN_DEFAULT_EXCLUDES);
		} else {
			getLog().debug(
					"rat.useMavenDefaultExcludes set to false. "
							 "Exclusions often needed by Maven projects will not be added.");
		}
	}
	private void addEclipseDefaults(final List<String> excludeList1) {
		if (useEclipseDefaultExcludes) {
			getLog().debug(
					"Adding exclusions often needed by projects "
							 "developed in Eclipse...");
			excludeList1.addAll(ECLIPSE_DEFAULT_EXCLUDES);
		} else {
			getLog().debug(
					"rat.useEclipseDefaultExcludes set to false. "
							 "Exclusions often needed by projects developed in "
							 "Eclipse will not be added.");
		}
	}
	private void addIdeaDefaults(final List<String> excludeList1) {
		if (useIdeaDefaultExcludes) {
			getLog().debug(
					"Adding exclusions often needed by projects "
							 "developed in IDEA...");
			excludeList1.addAll(IDEA_DEFAULT_EXCLUDES);
		} else {
			getLog().debug(
					"rat.useIdeaDefaultExcludes set to false. "
							 "Exclusions often needed by projects developed in "
							 "IDEA will not be added.");
		}
	}
	/**
	 * Writes the report to the given stream.
	 *
	 * @param out
	 *            The target writer, to which the report is being written.
	 * @param style
	 *            The stylesheet to use, or <code>null</code> for raw XML
	 * 
	 * @return the current statistic.
	 * 
	 * @throws MojoFailureException
	 *             An error in the plugin configuration was detected.
	 * @throws MojoExecutionException
	 *             Another error occurred while creating the report.
	 */
	protected ClaimStatistic createReport(Writer out, InputStream style)
			throws MojoExecutionException, MojoFailureException {
		final ReportConfiguration configuration = getConfiguration();
		try {
			if (style != null) {
				return Report.report(out, getResources(), style, configuration);
			} else {
				return Report.report(getResources(), out, configuration);
			}
		} catch (TransformerConfigurationException e) {
			throw new MojoExecutionException(e.getMessage(), e);
		} catch (IOException e) {
			throw new MojoExecutionException(e.getMessage(), e);
		} catch (InterruptedException e) {
			throw new MojoExecutionException(e.getMessage(), e);
		} catch (RatException e) {
			throw new MojoExecutionException(e.getMessage(), e);
		}
	}
	protected ReportConfiguration getConfiguration()
			throws MojoFailureException, MojoExecutionException {
		final ReportConfiguration configuration = new ReportConfiguration();
		configuration.setHeaderMatcher(new HeaderMatcherMultiplexer(
				getLicenseMatchers()));
		configuration.setApprovedLicenseNames(getApprovedLicenseNames());
		return configuration;
	}
	private ILicenseFamily[] getApprovedLicenseNames()
			throws MojoExecutionException, MojoFailureException {
		final List<ILicenseFamily> list = new ArrayList<ILicenseFamily>();
		if (licenseFamilies != null) {
			list.addAll(Arrays.asList(licenseFamilies));
		}
		if (licenseFamilyNames != null) {
			for (LicenseFamilySpecification spec : licenseFamilyNames) {
				list.add(newInstance(ILicenseFamily.class, spec.getClassName()));
			}
		}
		if (list.isEmpty()) {
			return null;
		}
		return list.toArray(new ILicenseFamily[list.size()]);
	}
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.time.DateFormatUtils;
 * Base implementation for GPLv1 or later.
 * Base implementation for GPLv2 or later.
import java.util.Collections;
import java.util.List;
            // FIXME Try to avoid NPE / found during 0.11-build checks
            // API is so old/without type information
			@SuppressWarnings("unchecked")
			List<ArtifactRepository> remoteArtifactRepositories = getProject().getRemoteArtifactRepositories();
            if(remoteArtifactRepositories == null) {
            	remoteArtifactRepositories = Collections.emptyList();
            }
            
			resolver.resolve( artifact, remoteArtifactRepositories, localRepository );
import org.apache.maven.plugins.annotations.Component;
	//@Parameter(name = "project", readonly = true)
	@Component
			resolver.resolve( artifact, getProject().getRemoteArtifactRepositories(), localRepository );
        * Holds the maven-internal project to allow resolution of artifact properties during mojo runs. 
        */
    * Holds the maven-internal project to allow resolution of artifact properties during mojo runs. 
    */
	@Parameter(property = "project", required = true, readonly = true)
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;

	private File basedir;
    @SuppressWarnings("boxing") // OK in test code
			@SuppressWarnings("unchecked") // incorrect cast will be caught below
@SuppressWarnings("deprecation") // MavenReport invokes the deprecated Sink implementation
    private static final Pattern LICENSE_URL_PATTERN = Pattern.compile(LICENSE_URL);
            return
                    super.matches(pLine) ||
                    LICENSE_LINE_PATTERN.matcher(pLine).find() ||
                    LICENSE_URL_PATTERN.matcher(pLine).find();
 */
 *
    private static final int TYPE_UNKNOWN = 0;
     *
     *
     *
     * @param document document to extract from.
     *
     *
     *
 */

    private static final String FILE_URL_PREFIX = "file";

    private final File file;
     * @return Creates and returns a new instance.
     *
 */


    public static final String[] ARCHIVE_EXTENSIONS = {
     * @param document the current document.
    private static boolean isBinaryDocument(Document document) {
 */

    public static final String[] NOTE_FILE_NAMES = {
        "README", "README.TXT",




    /**
     * The Maven specific default excludes.
     */
    static final List<String> MAVEN_DEFAULT_EXCLUDES = Collections
            .unmodifiableList(Arrays.asList("target/**/*", //
                    "cobertura.ser", //
                    "release.properties", //
                    "pom.xml.releaseBackup"));
    /**
     * The Eclipse specific default excludes.
     */
    static final List<String> ECLIPSE_DEFAULT_EXCLUDES = Collections
            .unmodifiableList(Arrays.asList(".classpath",//
                    ".project", //
                    ".settings/**/*"));
    /**
     * The IDEA specific default excludes.
     */
    static final List<String> IDEA_DEFAULT_EXCLUDES = Collections
            .unmodifiableList(Arrays.asList(//
                    "*.iml", //
                    "*.ipr", //
                    "*.iws", //
                    ".idea/**/*"));
    /**
     * The base directory, in which to search for files.
     *
     */
    @Parameter(property = "rat.basedir", defaultValue = "${basedir}", required = true)
    private File basedir;
    /**
     * Specifies the licenses to accept. Deprecated, use {@link #licenses}
     * instead.
     *
     * @deprecated Use {@link #licenses} instead.
     */
    @Deprecated
    @Parameter
    private HeaderMatcherSpecification[] licenseMatchers;
    /**
     * Specifies the licenses to accept. By default, these are added to the
     * default licenses, unless you set {@link #addDefaultLicenseMatchers} to
     * true.
     *
     * @since 0.8
     */
    @Parameter
    private IHeaderMatcher[] licenses;
    /**
     * The set of approved license family names.
     *
     * @deprecated Use {@link #licenseFamilies} instead.
     */
    @Deprecated
    private LicenseFamilySpecification[] licenseFamilyNames;
    /**
     * Specifies the license families to accept.
     *
     * @since 0.8
     */
    @Parameter
    private ILicenseFamily[] licenseFamilies;
    /**
     * Whether to add the default list of license matchers.
     *
     */
    @Parameter(property = "rat.addDefaultLicenseMatchers", defaultValue = "true")
    private boolean addDefaultLicenseMatchers;
    /**
     * Specifies files, which are included in the report. By default, all files
     * are included.
     *
     */
    @Parameter
    private String[] includes;
    /**
     * Specifies files, which are excluded in the report. By default, no files
     * are excluded.
     *
     */
    @Parameter
    private String[] excludes;
    /**
     * Whether to use the default excludes when scanning for files. The default
     * excludes are:
     * <ul>
     * <li>meta data files for version control systems</li>
     * <li>temporary files used by Maven, see <a
     * href="#useMavenDefaultExcludes">useMavenDefaultExcludes</a></li>
     * <li>configuration files for Eclipse, see <a
     * href="#useEclipseDefaultExcludes">useEclipseDefaultExcludes</a></li>
     * <li>configuration files for IDEA, see <a
     * href="#useIdeaDefaultExcludes">useIdeaDefaultExcludes</a></li>
     * </ul>
     */
    @Parameter(property = "rat.useDefaultExcludes", defaultValue = "true")
    private boolean useDefaultExcludes;
    /**
     * Whether to use the Maven specific default excludes when scanning for
     * files. Maven specific default excludes are given by the constant
     * MAVEN_DEFAULT_EXCLUDES: The <code>target</code> directory, the
     * <code>cobertura.ser</code> file, and so on.
     */
    @Parameter(property = "rat.useMavenDefaultExcludes", defaultValue = "true")
    private boolean useMavenDefaultExcludes;
    /**
     * Whether to use the Eclipse specific default excludes when scanning for
     * files. Eclipse specific default excludes are given by the constant
     * ECLIPSE_DEFAULT_EXCLUDES: The <code>.classpath</code> and
     * <code>.project</code> files, the <code>.settings</code> directory, and so
     * on.
     */
    @Parameter(property = "rat.useEclipseDefaultExcludes", defaultValue = "true")
    private boolean useEclipseDefaultExcludes;
    /**
     * Whether to use the IDEA specific default excludes when scanning for
     * files. IDEA specific default excludes are given by the constant
     * IDEA_DEFAULT_EXCLUDES: The <code>*.iml</code>, <code>*.ipr</code> and
     * <code>*.iws</code> files and the <code>.idea</code> directory.
     */
    @Parameter(property = "rat.useIdeaDefaultExcludes", defaultValue = "true")
    private boolean useIdeaDefaultExcludes;
    /**
     * Whether to exclude subprojects. This is recommended, if you want a
     * separate apache-rat-plugin report for each subproject.
     *
     */
    @Parameter(property = "rat.excludeSubprojects", defaultValue = "true")
    private boolean excludeSubProjects;
    /**
    * Holds the maven-internal project to allow resolution of artifact properties during mojo runs.
    @Parameter(property = "project", required = true, readonly = true)
    private MavenProject project;
    /**
     * @return Returns the Maven project.
     */
    protected MavenProject getProject() {
        return project;
    }
    /**
     * Returns the set of {@link IHeaderMatcher header matchers} to use.
     *
     * @throws MojoFailureException
     *             An error in the plugin configuration was detected.
     * @throws MojoExecutionException
     *             An error occurred while calculating the result.
     * @return Array of license matchers to use
     */
    protected IHeaderMatcher[] getLicenseMatchers()
            throws MojoFailureException, MojoExecutionException {
        final List<IHeaderMatcher> list = new ArrayList<IHeaderMatcher>();
        if (licenses != null) {
            list.addAll(Arrays.asList(licenses));
        }
        if (licenseMatchers != null) {
            for (final HeaderMatcherSpecification spec : licenseMatchers) {
                final String className = spec.getClassName();
                final IHeaderMatcher headerMatcher = newInstance(
                        IHeaderMatcher.class, className);
                list.add(headerMatcher);
            }
        }
        if (addDefaultLicenseMatchers) {
            list.addAll(Arrays.asList(Defaults.DEFAULT_MATCHERS));
        }
        return list.toArray(new IHeaderMatcher[list.size()]);
    }
    private <T> T newInstance(final Class<T> clazz, final String className)
            throws MojoExecutionException, MojoFailureException {
        try {
            final ClassLoader cl = Thread.currentThread()
                    .getContextClassLoader();
            @SuppressWarnings("unchecked") // incorrect cast will be caught below
            final T o = (T) cl.loadClass(className).newInstance();
            if (!clazz.isAssignableFrom(o.getClass())) {
                throw new MojoFailureException("The class "
                         o.getClass().getName()  " does not implement "
                         clazz.getName());
            }
            return o;
        } catch (InstantiationException e) {
            throw new MojoExecutionException("Failed to instantiate class "
                     className  ": "  e.getMessage(), e);
        } catch (ClassCastException e) {
            throw new MojoExecutionException("The class "  className
                     " is not implementing "  clazz.getName()  ": "
                     e.getMessage(), e);
        } catch (IllegalAccessException e) {
            throw new MojoExecutionException("Illegal access to class "
                     className  ": "  e.getMessage(), e);
        } catch (ClassNotFoundException e) {
            throw new MojoExecutionException("Class "  className
                     " not found: "  e.getMessage(), e);
        }
    }
    /**
     * Adds the given string array to the list.
     *
     * @param pList
     *            The list to which the array elements are being added.
     * @param pArray
     *            The strings to add to the list.
     */
    private static void add(List<String> pList, String[] pArray) {
        if (pArray != null) {
            Collections.addAll(pList, pArray);
        }
    }
    /**
     * Creates an iterator over the files to check.
     *
     * @return A container of files, which are being checked.
     */
    protected IReportable getResources() {
        final DirectoryScanner ds = new DirectoryScanner();
        ds.setBasedir(basedir);
        setExcludes(ds);
        setIncludes(ds);
        ds.scan();
        whenDebuggingLogExcludedFiles(ds);
        final String[] files = ds.getIncludedFiles();
        logAboutIncludedFiles(files);
        try {
            return new FilesReportable(basedir, files);
        } catch (IOException e) {
            throw new UndeclaredThrowableException(e);
        }
    }
    private void logAboutIncludedFiles(final String[] files) {
        if (files.length == 0) {
            getLog().warn("No resources included.");
        } else {
            getLog().info(
                    files.length
                             " resources included (use -debug for more details)");
            if (getLog().isDebugEnabled()) {
                for (String resource : files) {
                    getLog().debug(" - included "  resource);
                }
            }
        }
    }
    private void whenDebuggingLogExcludedFiles(final DirectoryScanner ds) {
        if (getLog().isDebugEnabled()) {
            final String[] excludedFiles = ds.getExcludedFiles();
            if (excludedFiles.length == 0) {
                getLog().debug("No excluded resources.");
            } else {
                getLog().debug(
                        "Excluded "  excludedFiles.length  " resources:");
                for (final String resource : excludedFiles) {
                    getLog().debug(" - excluded "  resource);
                }
            }
        }
    }
    private void setIncludes(DirectoryScanner ds) {
        if (includes != null) {
            ds.setIncludes(includes);
        }
    }
    private void setExcludes(DirectoryScanner ds) {
        final List<String> excludeList = buildDefaultExclusions();
        if (excludes == null || excludes.length == 0) {
            getLog().info("No excludes explicitly specified.");
        } else {
            for (String exclude : excludes) {
                getLog().info("Exclude: "  exclude);
            }
        }
        add(excludeList, excludes);
        if (!excludeList.isEmpty()) {
            String[] allExcludes = excludeList.toArray(new String[excludeList
                    .size()]);
            ds.setExcludes(allExcludes);
        }
    }
    private List<String> buildDefaultExclusions() {
        final List<String> results = new ArrayList<String>();
        addPlexusDefaults(results);
        addMavenDefaults(results);
        addEclipseDefaults(results);
        addIdeaDefaults(results);
        if (excludeSubProjects && project != null
                && project.getModules() != null) {
            for (Object o : project.getModules()) {
                String moduleSubPath = (String) o;
                results.add(moduleSubPath  "/**/*");
            }
        }
        getLog().debug("Finished creating list of implicit excludes.");
        if (results.isEmpty()) {
            getLog().info("No excludes implicitly specified.");
        } else {
            getLog().info(
                    results.size()
                             " implicit excludes (use -debug for more details).");
            for (final String exclude : results) {
                getLog().debug("Implicit exclude: "  exclude);
            }
        }
        return results;
    }
    private void addPlexusDefaults(final List<String> excludeList1) {
        if (useDefaultExcludes) {
            getLog().debug("Adding plexus default exclusions...");
            Collections.addAll(excludeList1, DirectoryScanner.DEFAULTEXCLUDES);
        } else {
            getLog().debug(
                    "rat.useDefaultExcludes set to false. "
                             "Plexus default exclusions will not be added");
        }
    }
    private void addMavenDefaults(final List<String> excludeList1) {
        if (useMavenDefaultExcludes) {
            getLog().debug(
                    "Adding exclusions often needed by Maven projects...");
            excludeList1.addAll(MAVEN_DEFAULT_EXCLUDES);
        } else {
            getLog().debug(
                    "rat.useMavenDefaultExcludes set to false. "
                             "Exclusions often needed by Maven projects will not be added.");
        }
    }
    private void addEclipseDefaults(final List<String> excludeList1) {
        if (useEclipseDefaultExcludes) {
            getLog().debug(
                    "Adding exclusions often needed by projects "
                             "developed in Eclipse...");
            excludeList1.addAll(ECLIPSE_DEFAULT_EXCLUDES);
        } else {
            getLog().debug(
                    "rat.useEclipseDefaultExcludes set to false. "
                             "Exclusions often needed by projects developed in "
                             "Eclipse will not be added.");
        }
    }
    private void addIdeaDefaults(final List<String> excludeList1) {
        if (useIdeaDefaultExcludes) {
            getLog().debug(
                    "Adding exclusions often needed by projects "
                             "developed in IDEA...");
            excludeList1.addAll(IDEA_DEFAULT_EXCLUDES);
        } else {
            getLog().debug(
                    "rat.useIdeaDefaultExcludes set to false. "
                             "Exclusions often needed by projects developed in "
                             "IDEA will not be added.");
        }
    }
    /**
     * Writes the report to the given stream.
     *
     * @param out
     *            The target writer, to which the report is being written.
     * @param style
     *            The stylesheet to use, or <code>null</code> for raw XML
     *
     * @return the current statistic.
     *
     * @throws MojoFailureException
     *             An error in the plugin configuration was detected.
     * @throws MojoExecutionException
     *             Another error occurred while creating the report.
     */
    protected ClaimStatistic createReport(Writer out, InputStream style)
            throws MojoExecutionException, MojoFailureException {
        final ReportConfiguration configuration = getConfiguration();
        try {
            if (style != null) {
                return Report.report(out, getResources(), style, configuration);
            } else {
                return Report.report(getResources(), out, configuration);
            }
        } catch (TransformerConfigurationException e) {
            throw new MojoExecutionException(e.getMessage(), e);
        } catch (IOException e) {
            throw new MojoExecutionException(e.getMessage(), e);
        } catch (InterruptedException e) {
            throw new MojoExecutionException(e.getMessage(), e);
        } catch (RatException e) {
            throw new MojoExecutionException(e.getMessage(), e);
        }
    }
    protected ReportConfiguration getConfiguration()
            throws MojoFailureException, MojoExecutionException {
        final ReportConfiguration configuration = new ReportConfiguration();
        configuration.setHeaderMatcher(new HeaderMatcherMultiplexer(
                getLicenseMatchers()));
        configuration.setApprovedLicenseNames(getApprovedLicenseNames());
        return configuration;
    }
    private ILicenseFamily[] getApprovedLicenseNames()
            throws MojoExecutionException, MojoFailureException {
        final List<ILicenseFamily> list = new ArrayList<ILicenseFamily>();
        if (licenseFamilies != null) {
            list.addAll(Arrays.asList(licenseFamilies));
        }
        if (licenseFamilyNames != null) {
            for (LicenseFamilySpecification spec : licenseFamilyNames) {
                list.add(newInstance(ILicenseFamily.class, spec.getClassName()));
            }
        }
        if (list.isEmpty()) {
            return null;
        }
        return list.toArray(new ILicenseFamily[list.size()]);
    }
        if(skip) {
            getLog().info("RAT will not execute since it is configured to be skipped via system property 'rat.skip'.");
            return;
        }


    /**
     *
            resolver.resolve( artifact, getProject().getRemoteArtifactRepositories(), localRepository );
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
    @Parameter(defaultValue = "${project}", required = true, readonly = true)
    @Parameter(property = "project", required = true, readonly = true)
    @Parameter(defaultValue = "${project}", required = true, readonly = true)
import static org.apache.rat.mp.ExclusionHelper.addEclipseDefaults;
import static org.apache.rat.mp.ExclusionHelper.addIdeaDefaults;
import static org.apache.rat.mp.ExclusionHelper.addMavenDefaults;
import static org.apache.rat.mp.ExclusionHelper.addPlexusAndScmDefaults;

import java.util.HashSet;
import java.util.Set;
import org.apache.rat.config.SourceCodeManagementSystems;
    
     * <li>meta data files for source code management / revision control systems,
     *  see {@link SourceCodeManagementSystems}</li>
        } catch (final InstantiationException e) {
        } catch (final ClassCastException e) {
        } catch (final IllegalAccessException e) {
        } catch (final ClassNotFoundException e) {
        } catch (final IOException e) {
                for (final String resource : files) {
            for (final String exclude : excludes) {
            final String[] allExcludes = excludeList.toArray(new String[excludeList
        final Set<String> results = new HashSet<String>();
        addPlexusAndScmDefaults(getLog(), useDefaultExcludes, results);
        addMavenDefaults(getLog(), useMavenDefaultExcludes, results);
        addEclipseDefaults(getLog(), useEclipseDefaultExcludes, results);
        addIdeaDefaults(getLog(), useIdeaDefaultExcludes, results);
            for (final Object o : project.getModules()) {
                final String moduleSubPath = (String) o;
        return new ArrayList<String>(results);
        } catch (final TransformerConfigurationException e) {
        } catch (final IOException e) {
        } catch (final InterruptedException e) {
        } catch (final RatException e) {
            for (final LicenseFamilySpecification spec : licenseFamilyNames) {
     * Will skip the plugin execution, e.g. for technical builds that do not take licence compliance into account.
     * @since 0.11
     */
    @Parameter(property = "rat.skip", defaultValue = "false")
    protected boolean skip;

    /**
        if(skip) {
            getLog().info("RAT will not execute since it is configured to be skipped via system property 'rat.skip'.");
            return;
        }

     * false.
    SUBVERSION(".svn", null), //
    GIT(".git", ".gitignore"), //
    BAZAAR(".bzr", ".bzrignore"), //
    MERCURIAL(".hg", ".hgignore"), //
    CVS("CVS", ".cvsignore")
    //
    ;
    /**
     * Technical directory of that SCM which contains SCM internals.
     */
    private String directory;
    /**
     * If there is a external way to configure files to be ignored: name of this
     * file, <code>null</code> otherwise.
     */
    private String ignoreFile;
    private SourceCodeManagementSystems(String directory, String ignoreFile) {
        this.directory = directory;
        this.ignoreFile = ignoreFile;
    }
    /**
     * If an ignore file exists it's added as
     * 
     * <pre>
     * *&frasl;.scm&frasl;*
     * </pre>
     * 
     * . Otherwise the technical directory of the SCM is added as
     * 
     * <pre>
     * **&frasl;.scmignore
     * </pre>
     * 
     * to be used as exclusion during RAT runs.
     * 
     * @return list of excludes if the current SCM is used.
     */
    public List<String> getExclusions() {
        List<String> excludes = new ArrayList<String>(2);
        if (hasIgnoreFile()) {
            excludes.add("**/"  ignoreFile);
        }
        excludes.add("*/"  directory  "/*");
        return excludes;
    }
    public Boolean hasIgnoreFile() {
        return ignoreFile != null && ignoreFile.length() != 0;
    }
    /**
     * Calls {@link #getExclusions()} on each SCM to generate a global list of
     * exclusions to be used during RAT runs.
     * 
     * @return the global list of exclusions usable for all known SCM.
     */
    public static List<String> getPluginExclusions() {
        List<String> pluginExclusions = new ArrayList<String>();
        for (SourceCodeManagementSystems scm : values()) {
            pluginExclusions.addAll(scm.getExclusions());
        }
        return pluginExclusions;
    }
    /**
     * The Maven specific default excludes.
     */
    static final List<String> MAVEN_DEFAULT_EXCLUDES = Collections
            .unmodifiableList(Arrays.asList(//
                    "target/**/*", //
                    "cobertura.ser", //
                    "release.properties", //
                    "pom.xml.releaseBackup"));
    /**
     * The Eclipse specific default excludes.
     */
    static final List<String> ECLIPSE_DEFAULT_EXCLUDES = Collections
            .unmodifiableList(Arrays.asList(".classpath",//
                    ".project", //
                    ".settings/**/*"));
    /**
     * The IDEA specific default excludes.
     */
    static final List<String> IDEA_DEFAULT_EXCLUDES = Collections
            .unmodifiableList(Arrays.asList(//
                    "*.iml", //
                    "*.ipr", //
                    "*.iws", //
                    ".idea/**/*"));
    static void addPlexusAndScmDefaults(Log log, final boolean useDefaultExcludes,
            final Set<String> excludeList1) {
        if (useDefaultExcludes) {
            log.debug("Adding plexus default exclusions...");
            Collections.addAll(excludeList1, DirectoryScanner.DEFAULTEXCLUDES);
            log.debug("Adding SCM default exclusions...");
            excludeList1.addAll(//
                    SourceCodeManagementSystems.getPluginExclusions());
        } else {
            log.debug("rat.useDefaultExcludes set to false. "
                     "Plexus and SCM default exclusions will not be added");
        }
    }
    static void addMavenDefaults(Log log, boolean useMavenDefaultExcludes,
            final Set<String> excludeList) {
        if (useMavenDefaultExcludes) {
            log.debug("Adding exclusions often needed by Maven projects...");
            excludeList.addAll(MAVEN_DEFAULT_EXCLUDES);
        } else {
            log.debug("rat.useMavenDefaultExcludes set to false. "
                     "Exclusions often needed by Maven projects will not be added.");
        }
    }
    static void addEclipseDefaults(Log log, boolean useEclipseDefaultExcludes,
            final Set<String> excludeList) {
        if (useEclipseDefaultExcludes) {
            log.debug("Adding exclusions often needed by projects "
                     "developed in Eclipse...");
            excludeList.addAll(ECLIPSE_DEFAULT_EXCLUDES);
        } else {
            log.debug("rat.useEclipseDefaultExcludes set to false. "
                     "Exclusions often needed by projects developed in "
                     "Eclipse will not be added.");
        }
    }
    static void addIdeaDefaults(Log log, boolean useIdeaDefaultExcludes,
            final Set<String> excludeList) {
        if (useIdeaDefaultExcludes) {
            log.debug("Adding exclusions often needed by projects "
                     "developed in IDEA...");
            excludeList.addAll(IDEA_DEFAULT_EXCLUDES);
        } else {
            log.debug("rat.useIdeaDefaultExcludes set to false. "
                     "Exclusions often needed by projects developed in "
                     "IDEA will not be added.");
        }
    }
    public boolean hasIgnoreFile() {
import org.apache.rat.analysis.license.CDDL1License;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
    public static final List<IHeaderMatcher> DEFAULT_MATCHERS = Collections.unmodifiableList(
            Arrays.asList(new IHeaderMatcher[] {
            }));
import java.util.List;

    private final List<IHeaderMatcher> matchers;
    public HeaderMatcherMultiplexer(final List<IHeaderMatcher> matchers) {

import javax.xml.transform.TransformerConfigurationException;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static org.apache.rat.mp.ExclusionHelper.addEclipseDefaults;
import static org.apache.rat.mp.ExclusionHelper.addIdeaDefaults;
import static org.apache.rat.mp.ExclusionHelper.addMavenDefaults;
import static org.apache.rat.mp.ExclusionHelper.addPlexusAndScmDefaults;
     * @return list of license matchers to use
    protected List<IHeaderMatcher> getLicenseMatchers()
        final List<IHeaderMatcher> matchers = new ArrayList<IHeaderMatcher>();
            matchers.addAll(Arrays.asList(licenses));
                matchers.add(headerMatcher);
            matchers.addAll(Defaults.DEFAULT_MATCHERS);
        return matchers;
 import org.apache.rat.Defaults;
 import org.apache.rat.ReportConfiguration;
 import org.apache.rat.analysis.IHeaderMatcher;
 import org.apache.rat.analysis.util.HeaderMatcherMultiplexer;
 import org.apache.rat.api.RatException;
 import org.apache.rat.license.ILicenseFamily;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.LogOutputStream;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.util.FileUtils;
 import javax.xml.transform.TransformerException;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
    private List<IHeaderMatcher> getLicenseMatchers() {
        List<IHeaderMatcher> matchers = new ArrayList<IHeaderMatcher>(Defaults.DEFAULT_MATCHERS);
            if (nestedSize != 0) {
                matchers.addAll(licenseMatchers);
            matchers = new ArrayList<IHeaderMatcher>();
    private static final String[] ARCHIVE_EXTENSIONS = {
    private static final String[] DATA_EXTENSIONS = {

    private static final String[] EXE_EXTENSIONS = {

    private static final String[] KEYSTORE_EXTENSIONS = {

    private static final String[] IMAGE_EXTENSIONS = {

    private static final String[] BYTECODE_EXTENSIONS = {
    private static final String[] NON_BINARY_EXTENSIONS = {
    private static final String[] NOTE_FILE_NAMES = {

    private static final String[] NOTE_FILE_EXTENSIONS = {
            Arrays.asList(new ApacheSoftwareLicense20(),
                    new GPL1License(),
                    new GPL2License(),
                    new GPL3License(),
                    new MITLicense(),
                    new W3CLicense(),
                    new W3CDocLicense(),
                    new OASISLicense(),
                    new JavaDocLicenseNotRequired(),
                    new GeneratedLicenseNotRequired(),
                    new DojoLicenseHeader(),
                    new TMF854LicenseHeader(),
                    new CDDL1License()));

import org.apache.rat.analysis.IHeaderMatcher;
import org.apache.rat.analysis.RatHeaderAnalysisException;
import org.apache.rat.api.Document;
public class CDDL1License extends BaseLicense implements IHeaderMatcher {
    public static final String CDDL1_LICENSE_DEFN
        = "The contents of this file are subject to the terms of the Common Development\n"
         "and Distribution License(\"CDDL\") (the \"License\"). You may not use this file\n"
         "except in compliance with the License.\n\n";
    public static final String CDDL1_LICENSE_DEFN_ILLUMOS_STYLE
        = "The contents of this file are subject to the terms of the\n"
         "Common Development and Distribution License (the \"License\")\n"
         "You may not use this file except in compliance with the License.\n";

    private final FullTextMatchingLicense textMatcherBase;
    private final FullTextMatchingLicense textMatcherIllumosStyle;
              MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_CDDL1,
              "");
        textMatcherBase = new FullTextMatchingLicense(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_CDLL1,
                                                      MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_CDDL1,
                                                      "", CDDL1_LICENSE_DEFN);
        textMatcherIllumosStyle = new FullTextMatchingLicense(MetaData.RAT_LICENSE_FAMILY_CATEGORY_DATUM_CDLL1,
                                                              MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_CDDL1,
                                                              "", CDDL1_LICENSE_DEFN_ILLUMOS_STYLE);
    public boolean match(Document subject, String s) throws RatHeaderAnalysisException {
        return (textMatcherBase.match(subject, s) ||
                textMatcherIllumosStyle.match(subject, s));

    public void reset() {
        textMatcherBase.reset();
        textMatcherIllumosStyle.reset();
    }

        "JKS", "KEYSTORE", "PEM", "CRL", "TRUSTSTORE"
        "BUILD", "BUILT.TXT",//
        "DEPENDENCIES"
        "PSD",
        "har", "sar",
        "wsr",
                    ".repository", // Used by Jenkins when a Maven job uses a private repository that is "Local to the workspace"
    public static final String UNAPPROVED_LICENSES_STYLESHEET = "org/apache/rat/unapproved-licenses.xsl";

    public static InputStream getUnapprovedLicensesStyleSheet() {
        InputStream result = Defaults.class.getClassLoader().getResourceAsStream(Defaults.UNAPPROVED_LICENSES_STYLESHEET);
        return result;
    }

import java.io.PrintWriter;
import java.io.StringWriter;
     * Creates the report as a string.
     *
     * @param styleSheet The style sheet to use when formatting the report
     * @throws MojoFailureException
     *             An error in the plugin configuration was detected.
     * @throws MojoExecutionException
     *             An error occurred while creating the report.
     * @return Report contents
     */
    protected String createReport( InputStream styleSheet )
        throws MojoExecutionException, MojoFailureException
    {
        StringWriter sw = new StringWriter();
        PrintWriter pw = null;
        try
        {
            pw = new PrintWriter( sw );
            createReport( new PrintWriter( sw ), styleSheet );
            final String result = sw.toString();
            pw.close();
            pw = null;
            sw.close();
            sw = null;
            return result;
        }
        catch ( IOException e )
        {
            throw new MojoExecutionException( e.getMessage(), e );
        }
        finally
        {
            if ( pw != null )
            {
                try
                {
                    pw.close();
                }
                catch ( Throwable t )
                {
                    // Ignore me
                }
            }
            if ( sw != null )
            {
                try
                {
                    sw.close();
                }
                catch ( Throwable t )
                {
                    // Ignore me
                }
            }
        }
    }

    /**
    /**
     * Whether to output the names of files that have unapproved licenses to the
     * console.
     *
     * @since 0.12
     */
    @Parameter(property = "rat.consoleOutput", defaultValue = "false")
    private boolean consoleOutput;

            if ( consoleOutput )
            {
                try
                {
                    getLog().warn( createReport( Defaults.getUnapprovedLicensesStyleSheet() ).trim() );
                }
                catch( MojoExecutionException e )
                {
                    getLog().warn( "Unable to print the files with unapproved licenses to the console." );
                }
            }

            sink.text( createReport( Defaults.getDefaultStyleSheet() ) );
 * Used to specify additional license families. A license family is basically a class, which implements
     * The license family's class name.
     * Sets the license family's class name. Required.
import org.apache.commons.io.IOUtils;

            IOUtils.closeQuietly( pw );
            IOUtils.closeQuietly( sw );
import org.apache.commons.io.IOUtils;
            IOUtils.closeQuietly( fw );
import org.apache.maven.doxia.siterenderer.RenderingContext;
     * @param out - the output stream to receive the styled report
    throws IOException, TransformerConfigurationException, InterruptedException, RatException {
 * <p>
                    ".mvn", // Project configuration since Maven 3.3.1 which contains maven.config, jvm.config, extensions.xml
import org.apache.maven.plugin.logging.Log;
import org.apache.rat.config.SourceCodeManagementSystems;
import org.codehaus.plexus.util.DirectoryScanner;


    /**
     * Maybe <code>null</code>, check before with
     * @see #hasIgnoreFile()
     *
     * @return the ignore file of the SCM.
     */
    public String getIgnoreFile() {
        return ignoreFile;
    }
import org.apache.rat.mp.util.ScmIgnoreParser;
import static org.apache.rat.mp.util.ExclusionHelper.addEclipseDefaults;
import static org.apache.rat.mp.util.ExclusionHelper.addIdeaDefaults;
import static org.apache.rat.mp.util.ExclusionHelper.addMavenDefaults;
import static org.apache.rat.mp.util.ExclusionHelper.addPlexusAndScmDefaults;


     * see {@link SourceCodeManagementSystems}</li>
     * Whether to parse source code management system (SCM) ignore files and use their contents as excludes.
     * At the moment this works for the following SCMs:
     *
     * @see org.apache.rat.config.SourceCodeManagementSystems
     */
    @Parameter(property = "rat.parseSCMIgnoresAsExcludes", defaultValue = "false")
    private boolean parseSCMIgnoresAsExcludes;

    /**
     *
     * Holds the maven-internal project to allow resolution of artifact properties during mojo runs.
     */
     * @throws MojoFailureException   An error in the plugin configuration was detected.
     * @throws MojoExecutionException An error occurred while calculating the result.
     * @param pList  The list to which the array elements are being added.
     * @param pArray The strings to add to the list.
        if(parseSCMIgnoresAsExcludes) {
            getLog().info("Will parse SCM ignores for exclusions...");
            results.addAll(ScmIgnoreParser.getExclusionsFromSCM(getLog(), project.getBasedir()));
            getLog().info("Finished adding exclusions from SCM ignore files.");
        }

     * @throws MojoFailureException   An error in the plugin configuration was detected.
     * @throws MojoExecutionException An error occurred while creating the report.
    protected String createReport(InputStream styleSheet)
            throws MojoExecutionException, MojoFailureException {
        try {
            pw = new PrintWriter(sw);
            createReport(new PrintWriter(sw), styleSheet);
        } catch (IOException e) {
            throw new MojoExecutionException(e.getMessage(), e);
        } finally {
            IOUtils.closeQuietly(pw);
            IOUtils.closeQuietly(sw);
     * @param out   The target writer, to which the report is being written.
     * @param style The stylesheet to use, or <code>null</code> for raw XML
     * @throws MojoFailureException   An error in the plugin configuration was detected.
     * @throws MojoExecutionException Another error occurred while creating the report.
 b/apache-rat-plugin/src/main/java/org/apache/rat/mp/util/ExclusionHelper.java
package org.apache.rat.mp.util;
 * Visibility is to allow testing and usage in the maven plugin itself.
    public static void addPlexusAndScmDefaults(Log log, final boolean useDefaultExcludes,
                                               final Set<String> excludeList1) {
    public static void addMavenDefaults(Log log, boolean useMavenDefaultExcludes,
                                        final Set<String> excludeList) {
    public static void addEclipseDefaults(Log log, boolean useEclipseDefaultExcludes,
                                          final Set<String> excludeList) {
    public static void addIdeaDefaults(Log log, boolean useIdeaDefaultExcludes,
                                       final Set<String> excludeList) {
    @Parameter(property = "rat.parseSCMIgnoresAsExcludes", defaultValue = "true")
                    "build.log", // RAT-160: until now maven-invoker-plugin runs create a build.log that is not part of a release
 */
import org.apache.rat.api.MetaData;
    /**
     * no instances
     */
    private Defaults() {
    }
     * Needs to match configuration in {@link org.apache.rat.policy.DefaultPolicy}.
                    new JavaDocLicenseNotRequired(), // does not have a MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_... entry
                    new GeneratedLicenseNotRequired(), // does not have a MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_... entry

    // all classes in license package implementing ILicenseFamily
    public static final List<String> DEFAULT_LICENSE_FAMILIES = Collections.unmodifiableList(
            Arrays.asList(
                    MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_ACADEMIC_FREE_LICENSE_VERSION_2_1, //
                    MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_APACHE_LICENSE_VERSION_2_0, //
                    MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_CDDL1, //
                    MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_GPL_VERSION_1, //
                    MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_GPL_VERSION_2, //
                    MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_GPL_VERSION_3, //
                    MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_MIT, //
                    MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_MODIFIED_BSD_LICENSE, //
                    MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_OASIS_OPEN_LICENSE, //
                    MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_W3C_DOCUMENT_COPYRIGHT, //
                    MetaData.RAT_LICENSE_FAMILY_NAME_VALUE_W3C_SOFTWARE_COPYRIGHT
                    //
            ));



        configuration.setApproveDefaultLicenses(true);
        configuration.setApproveDefaultLicenses(true);
        configuration.setApproveDefaultLicenses(true);
 */
import java.util.List;

    private boolean approveDefaultLicenses = true;

    /**
     * @return whether default licenses shall be approved by default.
     */
    public boolean isApproveDefaultLicenses() {
        return approveDefaultLicenses;
    }

    public void setApproveDefaultLicenses(boolean approveDefaultLicenses) {
        this.approveDefaultLicenses = approveDefaultLicenses;
    }
     *
     *
     *
     *
     * Sets the set of approved license names (convenience).
     *
     * @param approvedLicenseNames set of approved license names.
     */
    public void setApprovedLicenseNames(List<ILicenseFamily> approvedLicenseNames) {
        if (approvedLicenseNames != null && approvedLicenseNames.size() > 0) {
            setApprovedLicenseNames(approvedLicenseNames.toArray(new ILicenseFamily[approvedLicenseNames.size()]));
        }
    }

    /**
     *
     * @see #setAddingLicenses(boolean)
     *
     * @see #isAddingLicenses()
     *
     * @param addingLicenses enables/disables adding of licenses.

    void analyse(Document document) throws RatDocumentAnalysisException;
    String getFamilyName();
 */
import org.apache.rat.Defaults;
import org.apache.rat.config.ConfigurationUtil;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
    private List<String> approvedLicenseNames;

    /**
     * Creates a policy that matches the default licenses.
     * Mainly used for testing purposes.
     */
    DefaultPolicy() {
        this(new ArrayList<String>(0), true);
    }

    public DefaultPolicy(final ILicenseFamily[] approvedLicenses, boolean mergeWithDefault) {
        this(ConfigurationUtil.toNames(approvedLicenses), mergeWithDefault);
    }

    public DefaultPolicy(final List<String> approvedLicenseNames, boolean mergeWithDefault) {
        this.approvedLicenseNames = new ArrayList<String>();

        if (approvedLicenseNames == null || approvedLicenseNames.isEmpty()) {
            // used in tests only, no additional licenses given but defaults requested
            if(mergeWithDefault) {
                this.approvedLicenseNames = new ArrayList<String>(Defaults.DEFAULT_LICENSE_FAMILIES);
            // avoid duplicate entries and merge with defaults if requested
            Set<String> mergedLicenses = new HashSet<String>(approvedLicenseNames);
            if(mergeWithDefault) {
                mergedLicenses.addAll(Defaults.DEFAULT_LICENSE_FAMILIES);
            }
            this.approvedLicenseNames = new ArrayList<String>(mergedLicenses);
        Collections.sort(this.approvedLicenseNames);
                final boolean isApproved = (Collections.binarySearch(approvedLicenseNames, name) >= 0);

    public void reportLicenseApprovalClaim(final Document subject, final boolean isAcceptable) {
        subject.getMetaData().set(//
         isAcceptable ? MetaData.RAT_APPROVED_LICENSE_DATIM_TRUE: MetaData.RAT_APPROVED_LICENSE_DATIM_FALSE);
    }

    public List<String> getApprovedLicenseNames() {
        return Collections.unmodifiableList(approvedLicenseNames);
    }
import java.util.ArrayList;
import java.util.List;


        final IDocumentAnalyser analyser =
        final DefaultPolicy policy = new DefaultPolicy(pConfiguration.getApprovedLicenseNames(), pConfiguration.isApproveDefaultLicenses());

 */
import org.apache.rat.document.impl.DocumentImplUtils;

    // Does not work from within IntelliJ since root path is not module, but apache-rat-trunk
    private static File RESOURCE_BASE_PATH = new File("src/test/resources");

        final File f = new File(RESOURCE_BASE_PATH, pResource);
        final File f = new File(RESOURCE_BASE_PATH, pResource);
        return f.listFiles(new FileFilter() {
            }
        });
import static org.apache.rat.mp.util.ConfigurationHelper.newInstance;
    private List<IHeaderMatcher> mergeLicenseMatchers()
        List<IHeaderMatcher> matchers = new ArrayList<IHeaderMatcher>();

            getLog().info("Added "  licenses.length  " additional default licenses.");
                matchers.add(newInstance(IHeaderMatcher.class, spec.getClassName()));
            getLog().info("Enabled default license matchers.");
        logLicenseMatchers(matchers);

    private void logLicenseMatchers(List<IHeaderMatcher> matchers) {
        if (getLog().isDebugEnabled()) {
            getLog().debug("The following license matchers are activated:");
            for (IHeaderMatcher matcher : matchers) {
                getLog().debug("* "  matcher.toString());
        final List<String> excludeList = mergeDefaultExclusions();
        if (excludes != null) {
            Collections.addAll(excludeList, excludes);
        }
    private List<String> mergeDefaultExclusions() {
        if (parseSCMIgnoresAsExcludes) {
                mergeLicenseMatchers()));
        configuration.setApprovedLicenseNames(mergeApprovedLicenseNames());
        configuration.setApproveDefaultLicenses(addDefaultLicenseMatchers);
    private List<ILicenseFamily> mergeApprovedLicenseNames()
            int numberOfAddedApprovals = licenseFamilies == null ? 0 : licenseFamilies.length;
            getLog().info("Added "  numberOfAddedApprovals  " custom approved licenses.");
        return list;
import org.apache.rat.config.AddLicenseHeaders;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;


        if (AddLicenseHeaders.FORCED.name().equalsIgnoreCase(addLicenseHeaders)) {
        } else if (AddLicenseHeaders.TRUE.name().equalsIgnoreCase(addLicenseHeaders)) {
        } else if (AddLicenseHeaders.FALSE.name().equalsIgnoreCase(addLicenseHeaders)) {
        configuration.setApproveDefaultLicenses(true);
    FORCED;

    private static final char SEPARATOR = '|';

    /**
     * @return pretty-printed list of all available options.
     */
    public static String getValuesForHelp() {
        StringBuilder sb = new StringBuilder();
        for(AddLicenseHeaders headerOption : AddLicenseHeaders.values()) {
            sb.append(headerOption.name().toLowerCase()).append(SEPARATOR);
        }
        // remove last separator
        sb.setLength(sb.length() - 1);
        return sb.toString();
    }
@Mojo(name = "check", defaultPhase = LifecyclePhase.VALIDATE)
public class RatCheckMojo extends AbstractRatMojo {
    @Parameter(property = "rat.outputFile", defaultValue = "${project.build.directory}/rat.txt")
     *
            throws MojoExecutionException, MojoFailureException {
        try {
            fw = new FileWriter(reportFile);
            final ClaimStatistic statistic = createReport(fw, getStyleSheet());
        } catch (IOException e) {
            throw new MojoExecutionException(e.getMessage(), e);
        } finally {
            IOUtils.closeQuietly(fw);
     * @see #reportStyle
        if (reportStyle == null || reportStyle.equals("plain")) {
        } else if (reportStyle.equals("xml")) {
        } else {
            try {
                return new FileInputStream(reportStyle);
            } catch (FileNotFoundException e) {
                        "Unable to find report stylesheet: "  reportStyle, e);
     * @throws MojoFailureException   An error in the plugin configuration was detected.
     * @throws MojoExecutionException Another error occurred while executing the plugin.
    public void execute() throws MojoExecutionException, MojoFailureException {
        if (skip) {
        if (!parent.mkdirs() && !parent.isDirectory()) {
        check(report);
    protected void check(ClaimStatistic statistics)
            throws MojoFailureException {
        if (numUnapprovedLicenses < statistics.getNumUnApproved()) {
            if (consoleOutput) {
                try {
                    getLog().warn(createReport(Defaults.getUnapprovedLicensesStyleSheet()).trim());
                } catch (MojoExecutionException e) {
                    getLog().warn("Unable to print the files with unapproved licenses to the console.");
            if (!ignoreErrors) {
                throw new RatCheckException("Too many files with unapproved license: "  statistics.getNumUnApproved()  seeReport);
            } else {
                getLog().warn("Rat check: "  statistics.getNumUnApproved()  " files with unapproved licenses."  seeReport);
            throw new MojoFailureException("Invalid value for addLicenseHeaders: Expected "  AddLicenseHeaders.getValuesForHelp()  ", got "
    // DevHint: needs to be prefix with apache-rat-core to work properly from within IntelliJ
    public static final String SRC_TEST_RESOURCES = "src/test/resources";
    public static final String SRC_MAIN_RESOURCES = "src/main/resources";
    private static File TEST_RESOURCE_BASE_PATH = new File(SRC_TEST_RESOURCES);
    private static File RESOURCE_BASE_PATH =  new File(SRC_MAIN_RESOURCES);
     * Locates a test resource file in the class path.
        return getResourceFromBase(TEST_RESOURCE_BASE_PATH, pResource);
    }

    /**
     * Locates a main resource file in the class path.
     */
    public static File getMainResourceFile(String pResource) throws IOException {
        return getResourceFromBase(RESOURCE_BASE_PATH, pResource);
    }

    private static File getResourceFromBase(File baseDir, String pResource) throws IOException {
        final File f = new File(baseDir, pResource);
        final File f = new File(TEST_RESOURCE_BASE_PATH, pResource);
import java.util.regex.Pattern;

 * <p/>
 * <p/>
 * <li>* Copyright 2010 FooBar. *</li>
 * <li>* Copyright 2010-2012 FooBar. *</li>
 * <li>*copyright 2012 foobar*</li>
 * <p/>
 * e.g. use &quot;FooBar \(www\.foobar\.com\)&quot; for matching &quot;FooBar (www.foobar.com)&quot;</p>
    public CopyrightHeader() {
        this.copyrightPattern = Pattern.compile(COPYRIGHT_PREFIX_PATTERN_DEFN  copyrightOwner  ".*", Pattern.CASE_INSENSITIVE);
        if (!copyrightMatch && matchCopyright(s)) {
            reportOnLicense(subject);
    boolean isFilteredOut(char character);
    IXmlWriter startDocument() throws IOException;
    IXmlWriter openElement(CharSequence elementName) throws IOException;
    IXmlWriter attribute(CharSequence name, CharSequence value) throws IOException;
    IXmlWriter content(CharSequence content) throws IOException;
    IXmlWriter closeElement() throws IOException;
    IXmlWriter closeDocument() throws IOException;
 */
import org.apache.commons.collections.ArrayStack;
import org.apache.rat.report.xml.writer.IXmlWriter;
import org.apache.rat.report.xml.writer.InvalidXmlException;
import org.apache.rat.report.xml.writer.OperationNotAllowedException;


    private final static boolean[] ALLOWED_CHARACTERS = new boolean[1 << 16];


    private final static byte[] CHARACTER_CODES = new byte[1 << 16];





     *
     * @throws OperationNotAllowedException if called after the first element has been written
     *                                      or once a prolog has already been written

     *
     * @return this object
     * @throws InvalidXmlException          if the name is not valid for an xml element
     * @throws OperationNotAllowedException if called after the first element has been closed

     *
     * @param name  the attribute name, not null
     * @throws InvalidXmlException          if the name is not valid for an xml attribute
     *                                      or if a value for the attribute has already been written
     * @throws OperationNotAllowedException if called after {@link #content(CharSequence)}
     *                                      or {@link #closeElement()} or before any call to {@link #openElement(CharSequence)}
                throw new OperationNotAllowedException("Close called before an element has been opened.");

     * Calling this method will automatically
     *
     * @throws OperationNotAllowedException if called before any call to {@link #openElement}
     *                                      or after the first element has been closed
                throw new OperationNotAllowedException("An element must be opened before content can be written.");

        for (int i = 0; i < length; i) {

     *
     * @throws OperationNotAllowedException if called before any call to {@link #openElement}
     *                                      or after the first element has been closed
                throw new OperationNotAllowedException("Close called before an element has been opened.");


     *
     * @throws OperationNotAllowedException if called before any call to {@link #openElement}
        if (elementNames.isEmpty() && !elementsWritten) {
            throw new OperationNotAllowedException("Close called before an element has been opened.");
        while (!elementNames.isEmpty()) {

        for (int i = 0; i < sequence.length(); i) {

        for (int i = 0; i < length; i) {
            if (i == 0) {


import org.apache.rat.config.ReportFormat;
     *
        if (reportStyle == null || ReportFormat.PLAIN.is(reportStyle)) {
        } else if (ReportFormat.XML.is(reportStyle)) {
 * <br>
 * <br>The matching is done case insensitive<br>
 * <br>
 * can support additional regex but also requires escaping where needed,<p>
 * e.g. use &quot;FooBar \(www\.foobar\.com\)&quot; for matching &quot;FooBar (www.foobar.com)&quot;<p>
     * TODO use existing mechanism to detect the type of a file and record it in the report output, thus we will not need this duplication here.
            = "The contents of this file are subject to the terms of the Common Development\n"
             "and Distribution License(\"CDDL\") (the \"License\"). You may not use this file\n"
             "except in compliance with the License.\n\n";
            = "The contents of this file are subject to the terms of the\n"
             "Common Development and Distribution License (the \"License\")\n"
             "You may not use this file except in compliance with the License.\n";
                MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_CDDL1,
                "");
                MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_CDDL1,
                "", CDDL1_LICENSE_DEFN);
                MetaData.RAT_LICENSE_FAMILY_NAME_DATUM_CDDL1,
                "", CDDL1_LICENSE_DEFN_ILLUMOS_STYLE);
        return textMatcherBase.match(subject, s) ||
                textMatcherIllumosStyle.match(subject, s);
                final boolean isApproved = Collections.binarySearch(approvedLicenseNames, name) >= 0;
     *
     * @param file   not null
     * @param filter filters input files (optional),
     *               or null when no filtering should be performed


     * @param file   the directory to process
    private void processDirectory(RatReport report, final File file) throws RatException {

     *
     *
     * @param file   the run the report against
     *
     * @param files  the files to process (only directories will be processed)
            if (!ignored(file) && file.isDirectory()) {
                processDirectory(report, file);
     * Process all files in a set of file objects, ignoring any files set to be ignored.
     *
     * @param report the report to use in processing
     * @param files  the files to process (only files will be processed)
     * @throws RatException
     */
    private void processNonDirectories(final RatReport report, final File[] files) throws RatException {
        for (final File file : files) {
            if (!ignored(file) && !file.isDirectory()) {
                report(report, file);
            }
        }

    }

    /**
     *
     * @param file   the file to be reported on
        if (numUnapprovedLicenses > 0) {
            getLog().info("You requested to accept "  numUnapprovedLicenses  " files with unapproved licenses.");
        }

        int numApproved = statistics.getNumApproved();
        getLog().info("Rat check: Summary over all files. Unapproved: "  statistics.getNumUnApproved()  //
                ", unknown: "  statistics.getNumUnknown()  //
                ", generated: "  statistics.getNumGenerated()  //
                ", approved: "  numApproved  //
                (numApproved > 0 ? " licenses." : " license."));

        configuration.setApproveDefaultLicenses(addDefaultLicenseMatchers);
        final List<String> exclusionLines = new ArrayList<String>();
            BufferedReader reader = null;
                reader = new BufferedReader(new FileReader(scmIgnore));
            } finally {
                if (reader != null) {
                    try {
                        reader.close();
                    } catch (IOException e) {
                        log.error("Cannot close "  scmIgnore  " after exclusion parsing. Will give up.");
                    }
                }

 */
import org.apache.rat.api.Document;

        try {
        } catch (IOException e) {
        } finally {
            try {
                if (stream != null) {
            } catch (IOException e) {
            }

                    || c <= BinaryGuesser.ASCII_CHAR_THREASHOLD) {
                > length * BinaryGuesser.TOTAL_READ_RATIO;
     * <p/>
     * <p/>
     * <p/>
     * <p/>
                        .onMalformedInput(CodingErrorAction.REPORT)
                        .onUnmappableCharacter(CodingErrorAction.REPORT);

     * @return Is a file by that name a known non-binary file?
        if (name == null) {
            return false;
        }
                BinaryGuesser.NON_BINARY_EXTENSIONS);
     * @return Is a file by that name an executable/binary file?
                || containsExtension(name, EXE_EXTENSIONS);
                                            final String[] exts) {
                                           final String[] exts) {

     * @return Is a file by that name a known binary file?
        if (name == null) {
            return false;
        }
        return BinaryGuesser.JAR_MANIFEST.equalsIgnoreCase(name) || BinaryGuesser.isImage(normalisedName)
                || BinaryGuesser.isKeystore(normalisedName) || BinaryGuesser.isBytecode(normalisedName)
                || BinaryGuesser.isBinaryData(normalisedName) || BinaryGuesser.isExecutable(normalisedName);
            "DAT", "DOC",
            "NCB", "IDB",
            "SUO", "XCF",
            "RAJ", "CERT",
            "KS", "TS",
            "ODP", "SWF"
            "EXE", "DLL",
            "LIB", "SO",
            "A", "EXP",
            "JKS", "KEYSTORE", "PEM", "CRL", "TRUSTSTORE"
            "PNG", "PDF",
            "GIF", "GIFF",
            "TIF", "TIFF",
            "JPG", "JPEG",
            "ICO", "ICNS",
            "PSD",
            "CLASS", "PYD",
            "OBJ", "PYC",

            "AART",
            "AC",
            "AM",
            "BAT",
            "C",
            "CAT",
            "CGI",
            "CLASSPATH",
            "CMD",
            "CONFIG",
            "CPP",
            "CSS",
            "CWIKI",
            "DATA",
            "DCL",
            "DTD",
            "EGRM",
            "ENT",
            "FT",
            "FN",
            "FV",
            "GRM",
            "G",
            "H",
            "HTACCESS",
            "HTML",
            "IHTML",
            "IN",
            "JAVA",
            "JMX",
            "JSP",
            "JS",
            "JUNIT",
            "JX",
            "MANIFEST",
            "M4",
            "MF",
            "MF",
            "META",
            "MOD",
            "N3",
            "PEN",
            "PL",
            "PM",
            "POD",
            "POM",
            "PROJECT",
            "PROPERTIES",
            "PY",
            "RB",
            "RDF",
            "RNC",
            "RNG",
            "RNX",
            "ROLES",
            "RSS",
            "SH",
            "SQL",
            "SVG",
            "TLD",
            "TXT",
            "TYPES",
            "VM",
            "VSL",
            "WSDD",
            "WSDL",
            "XARGS",
            "XCAT",
            "XCONF",
            "XEGRM",
            "XGRM",
            "XLEX",
            "XLOG",
            "XMAP",
            "XML",
            "XROLES",
            "XSAMPLES",
            "XSD",
            "XSL",
            "XSLT",
            "XSP",
            "XUL",
            "XWEB",
            "XWELCOME",
                ||
                // try a taste
                isBinaryDocument(document);
import java.nio.charset.UnsupportedCharsetException;
    static final String FILE_ENCODING = "file.encoding";
    private static Charset CHARSET_FROM_FILE_ENCODING_OR_UTF8 = getFileEncodingOrUTF8AsFallback();

                CharsetDecoder cd = CHARSET_FROM_FILE_ENCODING_OR_UTF8.newDecoder()
    static Charset getFileEncodingOrUTF8AsFallback() {
        try {
            return Charset.forName(System.getProperty(FILE_ENCODING));
        } catch (UnsupportedCharsetException e) {
            return Charset.forName("UTF-8");
        }
    }
import java.util.Arrays;
import java.util.List;
    // If started in IntelliJ the working directory is different, thus tests are not running through
    public static final List<String> INTELLIJ_PROJECT_PREFIXES = Arrays.asList("", "apache-rat-core/" /*,"apache-rat-plugin/"*/);

    private static File RESOURCE_BASE_PATH = new File(SRC_MAIN_RESOURCES);
    /**
     * Try to to load the given file from baseDir, in case of errors try to add module names to fix behaviour from within IntelliJ.
     */
        File f = new File(baseDir, pResource);
            // try IntelliJ workaround before giving up
            for (String prefix : INTELLIJ_PROJECT_PREFIXES) {
                f = new File(new File(prefix  baseDir.getPath()), pResource);
                System.out.println("Trying: "  f.getAbsolutePath());
                if (!f.isFile()) continue;
            }

            if (!f.isFile()) {
                throw new FileNotFoundException("Unable to locate resource file: "  pResource);
            }

     * In case of errors try to add module names to fix behaviour from within IntelliJ.
        File f = new File(TEST_RESOURCE_BASE_PATH, pResource);
            // try IntelliJ workaround before giving up
            for (String prefix : INTELLIJ_PROJECT_PREFIXES) {
                f = new File(new File(prefix  TEST_RESOURCE_BASE_PATH.getPath()), pResource);
                System.out.println("Trying: "  f.getAbsolutePath());
                if (!f.isDirectory()) continue;
            }

            if (!f.isDirectory()) {
                throw new FileNotFoundException("Unable to locate resource directory: "  pResource);
            }

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;

public class RatReportMojo extends AbstractRatMojo implements MavenReport {
    public static final String DOT_HTML = ".html";
     * @throws MojoFailureException   An error in the plugin configuration was detected.
     * @throws MojoExecutionException An error occurred while searching for the artifact file.
    private File getSkinArtifactFile() throws MojoFailureException, MojoExecutionException {
        final Skin skin = Skin.getDefaultSkin();
        final Artifact artifact;
        try {
            if (version == null) {
            VersionRange versionSpec = VersionRange.createFromVersionSpec(version);
                    factory.createDependencyArtifact(skin.getGroupId(), skin.getArtifactId(), versionSpec, "jar", null,
                            null);
            resolver.resolve(artifact, getProject().getRemoteArtifactRepositories(), localRepository);
        } catch (InvalidVersionSpecificationException e) {
            throw new MojoFailureException("The skin version '"  version  "' is not valid: "  e.getMessage());
        } catch (ArtifactResolutionException e) {
            throw new MojoExecutionException("Unable to find skin", e);
        } catch (ArtifactNotFoundException e) {
            throw new MojoFailureException("The skin does not exist: "  e.getMessage());
     * @throws MojoFailureException   An error in the plugin configuration was detected.
     * @throws MojoExecutionException An error occurred while creating the report.
    public void execute() throws MojoExecutionException, MojoFailureException {
        if (skip) {
        final DecorationModel model = new DecorationModel();
        model.setBody(new Body());
        final Map<String, String> attributes = new HashMap<String, String>();
        attributes.put("outputEncoding", "UTF-8");
        final Locale locale = Locale.getDefault();
        try {
            final SiteRenderingContext siteContext =
                    siteRenderer.createContextForSkin(getSkinArtifactFile(), attributes, model, getName(locale),
                            locale);
            final RenderingContext context = new RenderingContext(outputDirectory, getOutputName()  DOT_HTML);
            final SiteRendererSink sink = new SiteRendererSink(context);
            generate(sink, locale);
            if (!outputDirectory.mkdirs() && !outputDirectory.isDirectory()) {
                throw new IOException("Could not create output directory "  outputDirectory);
            final Writer writer = new FileWriter(new File(outputDirectory, getOutputName()  DOT_HTML));
            siteRenderer.generateDocument(writer, sink, siteContext);
            siteRenderer.copyResources(siteContext, new File(getProject().getBasedir(), "src/site/resources"),
                    outputDirectory);
        } catch (IOException e) {
            throw new MojoExecutionException(e.getMessage(), e);
        } catch (MavenReportException e) {
            throw new MojoExecutionException(e.getMessage(), e);
        } catch (RendererException e) {
            throw new MojoExecutionException(e.getMessage(), e);
    public boolean canGenerateReport() {
    private String getRatVersion() {
        for (@SuppressWarnings("unchecked") // library is not yet generified
             Iterator<Artifact> iter = getProject().getDependencyArtifacts().iterator(); iter.hasNext(); ) {
            if ("rat-lib".equals(a.getArtifactId())) {
     * @param sink   The doxia sink, kind of a SAX handler.
     * @param locale The locale to use for writing the report.
     * @throws MavenReportException Writing the report failed.
    public void generate(Sink sink, Locale locale) throws MavenReportException {
        ResourceBundle bundle = getBundle(locale);
        final String title = bundle.getString("report.rat.title");
        sink.text(title);
        sink.text(title);
        sink.text(bundle.getString("report.rat.link")  " ");
        sink.link(bundle.getString("report.rat.url"));
        sink.text(bundle.getString("report.rat.fullName"));
        if (ratVersion != null) {
            sink.text(" "  ratVersion);
        sink.text(".");
        sink.verbatim(true);
        try {
            sink.text(createReport(Defaults.getDefaultStyleSheet()));
        } catch (MojoExecutionException e) {
            throw new MavenReportException(e.getMessage(), e);
        } catch (MojoFailureException e) {
            throw new MavenReportException(e.getMessage(), e);
    public String getCategoryName() {
     * @param locale Requested locale of the bundle
    private ResourceBundle getBundle(Locale locale) {
        return ResourceBundle.getBundle("org/apache/rat/mp/rat-report", locale, getClass().getClassLoader());
     * @param locale Requested locale of the bundle
    public String getDescription(Locale locale) {
        return getBundle(locale).getString("report.rat.description");
     * @param locale Requested locale of the bundle
    public String getName(Locale locale) {
        return getBundle(locale).getString("report.rat.name");
    public String getOutputName() {
    public File getReportOutputDirectory() {
    public boolean isExternalReport() {
     * @param pOutputDirectory Reports target directory.
    public void setReportOutputDirectory(File pOutputDirectory) {
 */
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PipedReader;
import java.io.PipedWriter;
import java.io.PrintStream;
import java.io.Writer;
            } else if (cl.hasOption(EXCLUDE_FILE_CLI)) {
                                 " doesn't exist");
                "Print help for the Rat command line interface and exit");
        OptionGroup addLicenseGroup = new OptionGroup();
        String addLicenseDesc = "Add the default license header to any file with an unknown license that is not in the exclusion list. " 
                "By default new files will be created with the license header, " 
                "to force the modification of existing files use the --force option.";
        // RAT-85/RAT-203: Deprecated! added only for convenience and for backwards compatibility
                addLicenseDesc);
        addLicenseGroup.addOption(addLicence);
                addLicenseDesc);
        addLicenseGroup.addOption(addLicense);
        opts.addOptionGroup(addLicenseGroup);
                "Forces any changes in files to be written directly to the source files (i.e. new files are not created)");
                "The copyright message to use in the license headers, usually in the form of \"Copyright 2008 Foo\"");
                .withArgName("expression")
                .withLongOpt("exclude")
                .hasArgs()
                .withDescription("Excludes files matching wildcard <expression>. " 
                        "Note that --dir is required when using this parameter. " 
                        "Allows multiple arguments.")
                .create(EXCLUDE_CLI);
                .withArgName("fileName")
                .withLongOpt("exclude-file")
                .hasArgs()
                .withDescription("Excludes files matching regular expression in <file> " 
                        "Note that --dir is required when using this parameter. ")
                .create(EXCLUDE_FILE_CLI);
                "Used to indicate source when using --exclude");
                "stylesheet",
                true,
                "XSLT stylesheet to use when creating the"
                         " report.  Not compatible with -x");
        footer.append("Rat reports require interpretation\n");
     *
     *
     * @throws Exception in case of errors.
     * @deprecated use {@link #report(PrintStream, ReportConfiguration)} instead
     * @param out           - the output stream to receive the styled report
     * @throws Exception in case of errors.
     * @since Rat 0.8
            throws Exception {
        }
     * Output a report in the default style and default license
     * header matcher.
     *
     * Output a report in the default style and default license
     * header matcher.
     *
     * @param out           - the output stream to receive the styled report
            throws Exception {
     *
     * @param out            the stream to write the report to
     * @param base           the files or directories to report on
     * @param style          an input stream representing the stylesheet to use for styling the report
     * @throws IOException                       in case of I/O errors.
     * @throws InterruptedException              in case of threading errors.
     * @throws RatException                      in case of internal errors.
                              ReportConfiguration pConfiguration)
            throws IOException, TransformerConfigurationException, InterruptedException, RatException {
     *
     * @param out            the writer to write the report to
     * @param base           the files or directories to report on
     * @param style          an input stream representing the stylesheet to use for styling the report
     * @throws IOException                       in case of I/O errors.
     * @throws TransformerConfigurationException in case of XML errors.
     * @throws InterruptedException              in case of threading errors.
     * @throws RatException                      in case of internal errors.
    public static ClaimStatistic report(Writer out, IReportable base, final InputStream style,
                                        ReportConfiguration pConfiguration)
            throws IOException, TransformerConfigurationException, InterruptedException, RatException {
     * @param container      the files or directories to report on
     * @param out            the writer to write the report to
     * @throws IOException  in case of I/O errors.
     * @throws RatException in case of internal errors.
                                        ReportConfiguration pConfiguration) throws IOException, RatException {
 */
 * License matches GPL1 or later.
 */
 * License matches GPL2 or later.
 */
 * License matches GPL3 or later.
 * Add a license header to a document. This appender does not check for the
 * existence of an existing license header, it is assumed that either a second
 * license header is intentional or that there is no license header present
    /**
     * the line separator for this OS
     */
    private static final int[] FAMILY_C = new int[]{
            TYPE_JAVA, TYPE_JAVASCRIPT, TYPE_C, TYPE_H, TYPE_SCALA,
            TYPE_CSS, TYPE_CPP, TYPE_CSHARP, TYPE_PHP, TYPE_GROOVY,
            TYPE_BEANSHELL,
    private static final int[] FAMILY_SGML = new int[]{
            TYPE_XML, TYPE_HTML, TYPE_JSP, TYPE_FML,
    private static final int[] FAMILY_SH = new int[]{
            TYPE_PROPERTIES, TYPE_PYTHON, TYPE_SH, TYPE_RUBY, TYPE_PERL,
            TYPE_TCL, TYPE_VISUAL_STUDIO_SOLUTION,
    private static final int[] FAMILY_BAT = new int[]{
            TYPE_BAT,
    private static final int[] FAMILY_APT = new int[]{
            TYPE_APT,
    private static final int[] FAMILY_VELOCITY = new int[]{
            TYPE_VM,
    private static final int[] EXPECTS_HASH_PLING = new int[]{
            TYPE_PYTHON, TYPE_SH, TYPE_RUBY, TYPE_PERL, TYPE_TCL
    private static final int[] EXPECTS_AT_ECHO = new int[]{
            TYPE_BAT,
    private static final int[] EXPECTS_PACKAGE = new int[]{
            TYPE_JAVA,
    private static final int[] EXPECTS_XML_DECL = new int[]{
            TYPE_XML,
    private static final int[] EXPECTS_PHP_PI = new int[]{
            TYPE_PHP,
    private static final int[] EXPECTS_MSVSSF_HEADER = new int[]{
            TYPE_VISUAL_STUDIO_SOLUTION,
     * Append the default license header to the supplied document.
     * @throws IOException if there is a problem while reading or writing the file
                    expectsHashPling, expectsAtEcho, expectsPackage,
                    expectsXMLDecl, expectsPhpPI, expectsMSVSSF)) {
                            false, false, false, false, false, false);
     *
            throws IOException {
                        && !expectsAtEcho
                        && !expectsPackage
                        && !expectsXMLDecl
                        && !expectsPhpPI
                        && !expectsMSVSSF) {
                    writer.write(getLicenseHeader(document));
                                 " File")) {
                        writer.write(getLicenseHeader(document));
                        writer.write(getLicenseHeader(document));
                        writer.write(getLicenseHeader(document));
    private void doFirstLine(File document, Writer writer, String line, String lookfor) throws IOException {
            writer.write(getLicenseHeader(document));
            writer.write(getLicenseHeader(document));
     * @return Get the license header of a document.
    public abstract String getLicenseHeader(File document);
     * Get the first line of the license header formatted
     * Get the last line of the license header formatted
     * Get a line of the license header formatted
     * @param type    the type of file, see the TYPE_* constants












            new int[]{0xEF, 0xBB, 0xBF}, // UTF-8
            new int[]{0xFE, 0xFF}, // UTF-16BE
            new int[]{0xFF, 0xFE}, // UTF-16LE
                ? (firstCount > 0 ? firstCount : -1) : firstCount  secondCount;

 * Add an Apache License V2 license header to a
 * existence of an existing license header, it is assumed that either a second
 * license header is intentional or that there is no license header present
 * already.
    private String copyright;
    /**
     * Create a license appender with the standard ASF license header.
     */
    public ApacheV2LicenceAppender() {
        super();

    /**
     * Create a license appender with the given copyright line. This should be of
     * the form &quot;Copyright 2008 Foo&quot;
     *
     * @param copyright copyright line.
     */
    public ApacheV2LicenceAppender(String copyright) {
        super();
        this.copyright = copyright;
    }

    @Override
    public String getLicenseHeader(File document) {
        int type = getType(document);
        StringBuilder sb = new StringBuilder();
        if (copyright == null) {
            sb.append(getFirstLine(type));
            sb.append(getLine(type, "Licensed to the Apache Software Foundation (ASF) under one"));
            sb.append(getLine(type, "or more contributor license agreements.  See the NOTICE file"));
            sb.append(getLine(type, "distributed with this work for additional information"));
            sb.append(getLine(type, "regarding copyright ownership.  The ASF licenses this file"));
            sb.append(getLine(type, "to you under the Apache License, Version 2.0 (the"));
            sb.append(getLine(type, "\"License\"); you may not use this file except in compliance"));
            sb.append(getLine(type, "with the License.  You may obtain a copy of the License at"));
            sb.append(getLine(type, ""));
            sb.append(getLine(type, "  http://www.apache.org/licenses/LICENSE-2.0"));
            sb.append(getLine(type, ""));
            sb.append(getLine(type, "Unless required by applicable law or agreed to in writing,"));
            sb.append(getLine(type, "software distributed under the License is distributed on an"));
            sb.append(getLine(type, "\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY"));
            sb.append(getLine(type, "KIND, either express or implied.  See the License for the"));
            sb.append(getLine(type, "specific language governing permissions and limitations"));
            sb.append(getLine(type, "under the License."));
            sb.append(getLastLine(type));
        } else {
            sb.append(getFirstLine(type));
            sb.append(getLine(type, copyright));
            sb.append(getLine(type, ""));
            sb.append(getLine(type, "Licensed under the Apache License, Version 2.0 (the \"License\");"));
            sb.append(getLine(type, "you may not use this file except in compliance with the License."));
            sb.append(getLine(type, "You may obtain a copy of the License at"));
            sb.append(getLine(type, ""));
            sb.append(getLine(type, "  http://www.apache.org/licenses/LICENSE-2.0"));
            sb.append(getLine(type, ""));
            sb.append(getLine(type, "Unless required by applicable law or agreed to in writing,"));
            sb.append(getLine(type, "software distributed under the License is distributed on an"));
            sb.append(getLine(type, "\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY"));
            sb.append(getLine(type, "KIND, either express or implied.  See the License for the"));
            sb.append(getLine(type, "specific language governing permissions and limitations"));
            sb.append(getLine(type, "under the License."));
            sb.append(getLastLine(type));
        }
        return sb.toString();
    }

     * Will skip the plugin execution, e.g. for technical builds that do not take license compliance into account.
 b/apache-rat-core/src/main/java/org/apache/rat/annotation/AbstractLicenseAppender.java
public abstract class AbstractLicenseAppender {
    public AbstractLicenseAppender() {
 b/apache-rat-core/src/main/java/org/apache/rat/annotation/ApacheV2LicenseAppender.java
public class ApacheV2LicenseAppender extends AbstractLicenseAppender {
    public ApacheV2LicenseAppender() {
    public ApacheV2LicenseAppender(String copyright) {
import org.apache.rat.annotation.AbstractLicenseAppender;
import org.apache.rat.annotation.ApacheV2LicenseAppender;
    private final AbstractLicenseAppender appender;
        appender = pCopyrightMsg == null ? new ApacheV2LicenseAppender() : new ApacheV2LicenseAppender(pCopyrightMsg);
            throw new FileNotFoundException("Unable to locate resource file: "  pResource);
            throw new FileNotFoundException("Unable to locate resource directory: "  pResource);
import java.io.IOException;
import java.util.Calendar;

    public static final String RAT_REPORT = "rat-report";
    public static final String TIMESTAMP = "timestamp";
    private static final String NAME = "name";
            writer.openElement(RAT_REPORT)
                .attribute(TIMESTAMP,
        return Defaults.class.getClassLoader().getResourceAsStream(Defaults.PLAIN_STYLESHEET);
        return Defaults.class.getClassLoader().getResourceAsStream(Defaults.UNAPPROVED_LICENSES_STYLESHEET);
        return getPlainStyleSheet();
        StringBuilder footer = new StringBuilder("\nNOTE:\n");
import org.apache.commons.io.IOUtils;
import java.io.IOException;
import java.io.Reader;

            IOUtils.closeQuietly(reader);
import org.apache.commons.io.IOUtils;
import org.apache.rat.api.Document;
import org.apache.rat.api.MetaData;

            IOUtils.closeQuietly(reader);
import org.apache.commons.io.IOUtils;

            IOUtils.closeQuietly(writer);
            boolean deleted = document.delete();
            if (!deleted) {
                System.err.println("Could not delete original file to prepare renaming.");
            }
        FileInputStream fis = null;
        BufferedReader br = null;
            fis = new FileInputStream(document);
            br = new BufferedReader(new InputStreamReader(new BOMInputStream(fis)));
            if (!expectsHashPling
                    && !expectsAtEcho
                    && !expectsPackage
                    && !expectsXMLDecl
                    && !expectsPhpPI
                    && !expectsMSVSSF) {
                written = true;
                writer.write(getLicenseHeader(document));
                writer.write(LINE_SEP);
            }

            String line;
            boolean first = true;
            while ((line = br.readLine()) != null) {
                if (first && expectsHashPling) {
                    doFirstLine(document, writer, line, "#!");
                } else if (first && expectsAtEcho) {
                    written = true;
                    doFirstLine(document, writer, line, "@echo");
                } else if (first && expectsMSVSSF) {
                    written = true;
                    if ("".equals(line)) {
                        line = passThroughReadNext(writer, line, br);
                    }
                    if (line.startsWith("Microsoft Visual Studio Solution"
                             " File")) {
                        line = passThroughReadNext(writer, line, br);
                    }
                    doFirstLine(document, writer, line, "# Visual ");
                } else {
                    writer.write(line);
                if (expectsPackage && line.startsWith("package ")) {
                    written = true;
                    writer.write(LINE_SEP);
                    writer.write(getLicenseHeader(document));
                    writer.write(LINE_SEP);
                } else if (expectsXMLDecl && line.startsWith("<?xml ")) {
                    written = true;
                    writer.write(LINE_SEP);
                    writer.write(getLicenseHeader(document));
                    writer.write(LINE_SEP);
                } else if (expectsPhpPI && line.startsWith("<?php")) {
                    written = true;
                    writer.write(LINE_SEP);
                    writer.write(getLicenseHeader(document));
                    writer.write(LINE_SEP);
                first = false;
            IOUtils.closeQuietly(br);
            IOUtils.closeQuietly(fis);
            IOUtils.closeQuietly(writer);
import org.apache.commons.io.IOUtils;
            IOUtils.closeQuietly(stream);
            if (name.contains(DOT  exts[i]  DOT)) {
import org.apache.rat.api.MetaData;
import org.apache.rat.api.RatException;
import org.apache.rat.report.claim.ClaimStatistic;

            newNum = num  1;
        pMap.put(pKey, newNum);
        return !ALLOWED_CHARACTERS[character];
        return (code & NAME_START_MASK) > 0;
        return (code & NAME_MASK) > 0;
            Arrays.sort(files, COMPARATOR);
import org.apache.rat.report.IReportable;

        return file.getName().startsWith(".");
import org.apache.rat.api.Document;
import org.apache.rat.api.MetaData;

    private final Reader reader;
    private final String name;
import org.apache.rat.report.xml.writer.IXmlWriter;

    public final List<Object> calls = new ArrayList<Object>();
            getLog().info("Added "  licenseFamilies.length  " custom approved licenses.");
import org.apache.commons.io.IOUtils;
                IOUtils.closeQuietly(reader);
 import org.apache.commons.io.IOUtils;
            IOUtils.closeQuietly(out);
package org.apache.rat.mp;

import static org.apache.rat.mp.util.ConfigurationHelper.newInstance;
import static org.apache.rat.mp.util.ExclusionHelper.addEclipseDefaults;
import static org.apache.rat.mp.util.ExclusionHelper.addIdeaDefaults;
import static org.apache.rat.mp.util.ExclusionHelper.addMavenDefaults;
import static org.apache.rat.mp.util.ExclusionHelper.addPlexusAndScmDefaults;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.xml.transform.TransformerConfigurationException;

     * Specifies a file, from which to read includes. Basically, an alternative to
     * specifying the includes as a list.
     */
    @Parameter(property="rat.includesFile")
    private String includesFile;

    /**
     * Specifies the include files character set. Defaults to @code{${project.build.sourceEncoding}),
     * or @code{UTF8}.
     */
    @Parameter(property="rat.includesFileCharset", defaultValue="${project.build.sourceEncoding}")
    private String includesFileCharset;
    
    /**
     * Specifies a file, from which to read excludes. Basically, an alternative to
     * specifying the excludes as a list.  The excludesFile is assumed to be using the
     * UFT8 character set.
     */
    @Parameter(property="rat.excludesFile")
    private String excludesFile;

    /**
     * Specifies the include files character set. Defaults to @code{${project.build.sourceEncoding}),
     * or @code{UTF8}.
     */
    @Parameter(property="rat.excludesFileCharset", defaultValue="${project.build.sourceEncoding}")
    private String excludesFileCharset;

    /**
    protected IReportable getResources() throws MojoExecutionException {
    private void setIncludes(DirectoryScanner ds) throws MojoExecutionException {
        if ((includes != null  &&  includes.length > 0)  ||  includesFile != null) {
        	final List<String> includeList = new ArrayList<String>();
        	if (includes != null) {
        		includeList.addAll(Arrays.asList(includes));
        	}
        	if (includesFile != null) {
        		final String charset = includesFileCharset == null ? "UTF8" : includesFileCharset;
        		final File f = new File(includesFile);
        		if (!f.isFile()) {
        			getLog().error("IncludesFile not found: "  f.getAbsolutePath());
        		} else {
        			getLog().info("Includes loaded from file "  includesFile  ", using character set "  charset);
        		}
        		includeList.addAll(getPatternsFromFile(f, charset));
        	}
            ds.setIncludes(includeList.toArray(new String[includeList.size()]));
    private List<String> getPatternsFromFile(File pFile, String pCharset) throws MojoExecutionException {
    	InputStream is = null;
    	BufferedInputStream bis = null;
    	Reader r = null;
    	BufferedReader br = null;
    	Throwable th = null;
    	final List<String> patterns = new ArrayList<String>();
    	try {
    		is = new FileInputStream(pFile);
    		bis = new BufferedInputStream(is);
    		r = new InputStreamReader(bis, pCharset);
    		br = new BufferedReader(r);
    		for (;;) {
    			final String s = br.readLine();
    			if (s == null) {
    				break;
    			}
    			patterns.add(s);
    		}
    		br.close();
    		br = null;
    		r.close();
    		r = null;
    		bis.close();
    		bis = null;
    		is.close();
    		is = null;
    	} catch (Throwable t) {
    		th = t;
    	} finally {
    		if (br != null) { try { br.close(); } catch (Throwable t) { if (th == null) { th = t; } } }
    		if (r != null) { try { r.close(); } catch (Throwable t) { if (th == null) { th = t; } } }
    		if (bis != null) { try { bis.close(); } catch (Throwable t) { if (th == null) { th = t; } } }
    		if (is != null) { try { is.close(); } catch (Throwable t) { if (th == null) { th = t; } } }
    	}
    	if (th != null) {
    		if (th instanceof RuntimeException) { throw (RuntimeException) th; }
    		if (th instanceof Error) { throw (Error) th; }
    		throw new MojoExecutionException(th.getMessage(), th);
    	}
    	return patterns;
    }
    
    private void setExcludes(DirectoryScanner ds) throws MojoExecutionException {
        	for (final String exclude : excludes) {
    private List<String> mergeDefaultExclusions() throws MojoExecutionException {
        if (excludesFile != null) {
        	final File f = new File(excludesFile);
        	if (!f.isFile()) {
        		getLog().error("Excludes file not found: "  f.getAbsolutePath());
        	}
        	if (!f.canRead()) {
        		getLog().error("Excludes file not readable: "  f.getAbsolutePath());
        	}
        	final String charset = excludesFileCharset == null ? "UTF8" : excludesFileCharset;
        	getLog().info("Loading excludes from file "  f  ", using character set "  charset);
        	results.addAll(getPatternsFromFile(f, charset));
        }
     * @throws MojoExecutionException in case of errors. I/O errors result in UndeclaredThrowableExceptions.
            "ODP", "SWF",
            // fonts
            "WOFF2", "WOFF", "TTF", "EOT"
package org.apache.rat.mp;

 * Licensed to the Apache Software Foundation (ASF) under one
    private static final int TYPE_GO = 26;
    private static final int TYPE_PM = 27;    
            TYPE_BEANSHELL, TYPE_GO,
            TYPE_TCL, TYPE_VISUAL_STUDIO_SOLUTION, TYPE_PM,
            TYPE_PYTHON, TYPE_SH, TYPE_RUBY, TYPE_PERL, TYPE_TCL,
            TYPE_JAVA, TYPE_GO, TYPE_PM,
        EXT2TYPE.put("go", Integer.valueOf(TYPE_GO));
        EXT2TYPE.put("pm", Integer.valueOf(TYPE_PM));
}
            "GO",
            "JSON",
            "M4",            
            "MD",
