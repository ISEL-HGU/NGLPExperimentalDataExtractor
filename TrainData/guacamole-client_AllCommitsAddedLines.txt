import java.util.concurrent.locks.ReentrantLock;
    private ReentrantLock instructionStreamLock;
            instructionStreamLock = (ReentrantLock) session.getAttribute("INSTRUCTION_STREAM_LOCK");
            instructionStreamLock = new ReentrantLock();
            session.setAttribute("INSTRUCTION_STREAM_LOCK", instructionStreamLock);

    public ReentrantLock getInstructionStreamLock() {
        return instructionStreamLock;
    }

import java.util.concurrent.locks.ReentrantLock;
        ReentrantLock instructionStreamLock = session.getInstructionStreamLock();
        instructionStreamLock.lock();
            response.setContentType("text/plain");
            OutputStream out = response.getOutputStream();
                            out = new GZIPOutputStream(out);
                            out = new DeflaterOutputStream(out);
            try {
                // Query new update from VNC server
                Client client = session.getClient();

                // For all messages, until another stream is ready (we send at least one message)
                Instruction message = client.nextInstruction(true); // Block until first message is read
                while (message != null) {

                    // Get message output bytes
                    byte[] outputBytes = message.toString().getBytes("UTF-8");
                    out.write(outputBytes);
                    out.flush();
                    response.flushBuffer();

                    // No more messages another stream can take over
                    if (instructionStreamLock.hasQueuedThreads())
                        break;

                    message = client.nextInstruction(false); // Read remaining messages, do not block.
                }

            }
            catch (GuacamoleException e) {
                Instruction message = new ErrorInstruction(e.getMessage());
                byte[] outputBytes = message.toString().getBytes("UTF-8");
                out.write(outputBytes);
                out.flush();
                response.flushBuffer();
            }

            // End-of-instructions marker
            out.write(';');
            response.flushBuffer();

        finally {
            instructionStreamLock.unlock();
        }
                if (blocking) {
                    try {
                        // Send framebuffer update request
                        synchronized (output) {
                            output.writeByte(MESSAGE_FRAMEBUFFER_UPDATE_REQUEST);
                            output.writeBoolean(!needRefresh); // Incremental
                            output.writeShort(0); // x
                            output.writeShort(0); // y
                            output.writeShort(frameBufferWidth); // width
                            output.writeShort(frameBufferHeight); // height
                            output.flush();
                        }
                    catch (IOException e) {
                        throw new GuacamoleException("Could not send framebuffer update request to VNC server (network error).", e);
                    }
import java.util.concurrent.locks.ReentrantLock;
    private ReentrantLock instructionStreamLock;
            instructionStreamLock = (ReentrantLock) session.getAttribute("INSTRUCTION_STREAM_LOCK");
            instructionStreamLock = new ReentrantLock();
            session.setAttribute("INSTRUCTION_STREAM_LOCK", instructionStreamLock);

    public ReentrantLock getInstructionStreamLock() {
        return instructionStreamLock;
    }

import java.util.concurrent.locks.ReentrantLock;
        ReentrantLock instructionStreamLock = session.getInstructionStreamLock();
        instructionStreamLock.lock();
            response.setContentType("text/plain");
            OutputStream out = response.getOutputStream();
                            out = new GZIPOutputStream(out);
                            out = new DeflaterOutputStream(out);
            try {
                // Query new update from VNC server
                Client client = session.getClient();

                // For all messages, until another stream is ready (we send at least one message)
                Instruction message = client.nextInstruction(true); // Block until first message is read
                while (message != null) {

                    // Get message output bytes
                    byte[] outputBytes = message.toString().getBytes("UTF-8");
                    out.write(outputBytes);
                    out.flush();
                    response.flushBuffer();

                    // No more messages another stream can take over
                    if (instructionStreamLock.hasQueuedThreads())
                        break;

                    message = client.nextInstruction(false); // Read remaining messages, do not block.
                }

            }
            catch (GuacamoleException e) {
                Instruction message = new ErrorInstruction(e.getMessage());
                byte[] outputBytes = message.toString().getBytes("UTF-8");
                out.write(outputBytes);
                out.flush();
                response.flushBuffer();
            }

            // End-of-instructions marker
            out.write(';');
            response.flushBuffer();

        finally {
            instructionStreamLock.unlock();
        }
                if (blocking) {
                    try {
                        // Send framebuffer update request
                        synchronized (output) {
                            output.writeByte(MESSAGE_FRAMEBUFFER_UPDATE_REQUEST);
                            output.writeBoolean(!needRefresh); // Incremental
                            output.writeShort(0); // x
                            output.writeShort(0); // y
                            output.writeShort(frameBufferWidth); // width
                            output.writeShort(frameBufferHeight); // height
                            output.flush();
                        }
                    catch (IOException e) {
                        throw new GuacamoleException("Could not send framebuffer update request to VNC server (network error).", e);
                    }
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.PointerEvent;
 b/guacamole/src/net/sourceforge/guacamole/GuacamoleException.java
package net.sourceforge.guacamole;
 b/guacamole/src/net/sourceforge/guacamole/event/Event.java
package net.sourceforge.guacamole.event;
 b/guacamole/src/net/sourceforge/guacamole/event/EventHandler.java
package net.sourceforge.guacamole.event;
 b/guacamole/src/net/sourceforge/guacamole/event/EventQueue.java
package net.sourceforge.guacamole.event;
 b/guacamole/src/net/sourceforge/guacamole/event/KeyEvent.java
package net.sourceforge.guacamole.event;
 b/guacamole/src/net/sourceforge/guacamole/event/PointerEvent.java
package net.sourceforge.guacamole.event;
import net.sourceforge.guacamole.GuacamoleException;
    public PNGImage(BufferedImage image) throws GuacamoleException {
            throw new GuacamoleException("I/O Error while creating PNG.", e);
    private static void writeImage(BufferedImage image, OutputStream outputStream) throws GuacamoleException, IOException  {
            throw new GuacamoleException("No useful image writers found.");
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
    private String protocol;
        protocol       = readParameter("protocol", "vnc", "vnc");
    public String getProtocol() {
        return protocol;
    }

import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.instruction.Instruction;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.PointerEvent;
    private class SessionClient extends Client implements HttpSessionBindingListener {
        private Client client;

        public SessionClient(Client client) {
            this.client = client;
        public void send(KeyEvent event) throws GuacamoleException {
            client.send(event);
        }

        public void send(PointerEvent event) throws GuacamoleException {
            client.send(event);
        }

        public void setClipboard(String clipboard) throws GuacamoleException {
            client.setClipboard(clipboard);
        }

        public void disconnect() throws GuacamoleException {
            client.disconnect();
        }

        public Instruction nextInstruction(boolean blocking) throws GuacamoleException {
            return client.nextInstruction(blocking);
        }

            String protocol = config.getProtocol();
            if (protocol.equals("vnc")) {
                // Connect to VNC server
                try {

                    // Read VNC-specific parameters
                    ServletContext context = session.getServletContext();
                    VNCConfiguration vncconfig = new VNCConfiguration(context);

                    client = new SessionClient(
                            new VNCClient(
                                vncconfig.getHostname(),
                                vncconfig.getPort(),
                                vncconfig.getPassword(),
                                vncconfig.getBPP(),
                                config.getOutputBPP()
                            )
                    );

                }
                catch (VNCException e) {
                    throw new GuacamoleException(e);
                }

            else
                throw new GuacamoleException("Unsupported protocol: "  protocol);
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.PointerEvent;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.PointerEvent;
import net.sourceforge.guacamole.event.EventQueue;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.EventHandler;
import net.sourceforge.guacamole.GuacamoleException;
    private void handleMessages(boolean blocking) throws IOException, VNCException, GuacamoleException {
    private void handleFramebufferUpdate() throws IOException, VNCException, GuacamoleException {
import net.sourceforge.guacamole.net.Configuration;
import net.sourceforge.guacamole.GuacamoleException;
    private String hostname;
    private int port;
        hostname       = readParameter("host", null);
        port           = readIntParameter("port", null);
    public String getHostname() {
        return hostname;
    }

    public int getPort() {
        return port;
    }

import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.PointerEvent;
 b/guacamole/src/net/sourceforge/guacamole/GuacamoleException.java
package net.sourceforge.guacamole;
 b/guacamole/src/net/sourceforge/guacamole/event/Event.java
package net.sourceforge.guacamole.event;
 b/guacamole/src/net/sourceforge/guacamole/event/EventHandler.java
package net.sourceforge.guacamole.event;
 b/guacamole/src/net/sourceforge/guacamole/event/EventQueue.java
package net.sourceforge.guacamole.event;
 b/guacamole/src/net/sourceforge/guacamole/event/KeyEvent.java
package net.sourceforge.guacamole.event;
 b/guacamole/src/net/sourceforge/guacamole/event/PointerEvent.java
package net.sourceforge.guacamole.event;
import net.sourceforge.guacamole.GuacamoleException;
    public PNGImage(BufferedImage image) throws GuacamoleException {
            throw new GuacamoleException("I/O Error while creating PNG.", e);
    private static void writeImage(BufferedImage image, OutputStream outputStream) throws GuacamoleException, IOException  {
            throw new GuacamoleException("No useful image writers found.");
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
    private String protocol;
        protocol       = readParameter("protocol", "vnc", "vnc");
    public String getProtocol() {
        return protocol;
    }

import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.instruction.Instruction;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.PointerEvent;
    private class SessionClient extends Client implements HttpSessionBindingListener {
        private Client client;

        public SessionClient(Client client) {
            this.client = client;
        public void send(KeyEvent event) throws GuacamoleException {
            client.send(event);
        }

        public void send(PointerEvent event) throws GuacamoleException {
            client.send(event);
        }

        public void setClipboard(String clipboard) throws GuacamoleException {
            client.setClipboard(clipboard);
        }

        public void disconnect() throws GuacamoleException {
            client.disconnect();
        }

        public Instruction nextInstruction(boolean blocking) throws GuacamoleException {
            return client.nextInstruction(blocking);
        }

            String protocol = config.getProtocol();
            if (protocol.equals("vnc")) {
                // Connect to VNC server
                try {

                    // Read VNC-specific parameters
                    ServletContext context = session.getServletContext();
                    VNCConfiguration vncconfig = new VNCConfiguration(context);

                    client = new SessionClient(
                            new VNCClient(
                                vncconfig.getHostname(),
                                vncconfig.getPort(),
                                vncconfig.getPassword(),
                                vncconfig.getBPP(),
                                config.getOutputBPP()
                            )
                    );

                }
                catch (VNCException e) {
                    throw new GuacamoleException(e);
                }

            else
                throw new GuacamoleException("Unsupported protocol: "  protocol);
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.PointerEvent;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.PointerEvent;
import net.sourceforge.guacamole.event.EventQueue;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.EventHandler;
import net.sourceforge.guacamole.GuacamoleException;
    private void handleMessages(boolean blocking) throws IOException, VNCException, GuacamoleException {
    private void handleFramebufferUpdate() throws IOException, VNCException, GuacamoleException {
import net.sourceforge.guacamole.net.Configuration;
import net.sourceforge.guacamole.GuacamoleException;
    private String hostname;
    private int port;
        hostname       = readParameter("host", null);
        port           = readIntParameter("port", null);
    public String getHostname() {
        return hostname;
    }

    public int getPort() {
        return port;
    }

import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.PointerEvent;
 b/guacamole/src/net/sourceforge/guacamole/GuacamoleException.java
package net.sourceforge.guacamole;
 b/guacamole/src/net/sourceforge/guacamole/event/Event.java
package net.sourceforge.guacamole.event;
 b/guacamole/src/net/sourceforge/guacamole/event/EventHandler.java
package net.sourceforge.guacamole.event;
 b/guacamole/src/net/sourceforge/guacamole/event/EventQueue.java
package net.sourceforge.guacamole.event;
 b/guacamole/src/net/sourceforge/guacamole/event/KeyEvent.java
package net.sourceforge.guacamole.event;
 b/guacamole/src/net/sourceforge/guacamole/event/PointerEvent.java
package net.sourceforge.guacamole.event;
import net.sourceforge.guacamole.GuacamoleException;
    public PNGImage(BufferedImage image) throws GuacamoleException {
            throw new GuacamoleException("I/O Error while creating PNG.", e);
    private static void writeImage(BufferedImage image, OutputStream outputStream) throws GuacamoleException, IOException  {
            throw new GuacamoleException("No useful image writers found.");
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
    private String protocol;
        protocol       = readParameter("protocol", "vnc", "vnc");
    public String getProtocol() {
        return protocol;
    }

import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.instruction.Instruction;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.PointerEvent;
    private class SessionClient extends Client implements HttpSessionBindingListener {
        private Client client;

        public SessionClient(Client client) {
            this.client = client;
        public void send(KeyEvent event) throws GuacamoleException {
            client.send(event);
        }

        public void send(PointerEvent event) throws GuacamoleException {
            client.send(event);
        }

        public void setClipboard(String clipboard) throws GuacamoleException {
            client.setClipboard(clipboard);
        }

        public void disconnect() throws GuacamoleException {
            client.disconnect();
        }

        public Instruction nextInstruction(boolean blocking) throws GuacamoleException {
            return client.nextInstruction(blocking);
        }

            String protocol = config.getProtocol();
            if (protocol.equals("vnc")) {
                // Connect to VNC server
                try {

                    // Read VNC-specific parameters
                    ServletContext context = session.getServletContext();
                    VNCConfiguration vncconfig = new VNCConfiguration(context);

                    client = new SessionClient(
                            new VNCClient(
                                vncconfig.getHostname(),
                                vncconfig.getPort(),
                                vncconfig.getPassword(),
                                vncconfig.getBPP(),
                                config.getOutputBPP()
                            )
                    );

                }
                catch (VNCException e) {
                    throw new GuacamoleException(e);
                }

            else
                throw new GuacamoleException("Unsupported protocol: "  protocol);
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.PointerEvent;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.event.PointerEvent;
import net.sourceforge.guacamole.event.EventQueue;
import net.sourceforge.guacamole.event.KeyEvent;
import net.sourceforge.guacamole.event.EventHandler;
import net.sourceforge.guacamole.GuacamoleException;
    private void handleMessages(boolean blocking) throws IOException, VNCException, GuacamoleException {
    private void handleFramebufferUpdate() throws IOException, VNCException, GuacamoleException {
import net.sourceforge.guacamole.net.Configuration;
import net.sourceforge.guacamole.GuacamoleException;
    private String hostname;
    private int port;
        hostname       = readParameter("host", null);
        port           = readIntParameter("port", null);
    public String getHostname() {
        return hostname;
    }

    public int getPort() {
        return port;
    }

        return false;
        greenMax = (1 << greenBits) - 1;
        redMax   = (1 << redBits)   - 1;
        redShift = greenBits  blueBits;
        int green = input.read();
        int red   = input.read();
                value = Short.reverseBytes(input.readShort());
                value = Integer.reverseBytes(input.readInt());

            // Pixel format
            int bpp = input.read();
            int depth = input.read();
            boolean bigEndian = input.readBoolean();
            boolean trueColor = input.readBoolean();
            int redMax = input.readUnsignedShort();
            int greenMax = input.readUnsignedShort();
            int blueMax = input.readUnsignedShort();
            int redShift = input.read();
            int greenShift = input.read();
            int blueShift = input.read();
            byte[] padding = new byte[3];
            input.readFully(padding);

                fullColorReader = new VNCFullColorImageReader(bigEndian, 3, 3, 2, 8);
                fullColorReader = new VNCFullColorImageReader(bigEndian, 5, 6, 5, outputBPP);
                fullColorReader = new VNCFullColorImageReader(bigEndian, 8, 8, 8, outputBPP);
    private boolean bigEndian;
        return bigEndian;
    public VNCFullColorImageReader(boolean bigEndian, int redBits, int greenBits, int blueBits, int outputBPP) throws VNCException {
        int red;
        int green;
        int blue;

        if (bigEndian) {
            red   = input.read();
            green = input.read();
            blue  = input.read();
        }
        else {
            blue  = input.read();
            green = input.read();
            red   = input.read();
        }

                short inputShort = input.readShort();
                if (!bigEndian) inputShort = Short.reverseBytes(inputShort);

                value = inputShort;

                int inputInt = input.readInt();
                if (!bigEndian) inputInt = Integer.reverseBytes(inputInt);

                value = inputInt;

            // Pixel format
            int bpp = input.read();
            int depth = input.read();
            boolean bigEndian = input.readBoolean();
            boolean trueColor = input.readBoolean();
            int redMax = input.readUnsignedShort();
            int greenMax = input.readUnsignedShort();
            int blueMax = input.readUnsignedShort();
            int redShift = input.read();
            int greenShift = input.read();
            int blueShift = input.read();
            byte[] padding = new byte[3];
            input.readFully(padding);

                fullColorReader = new VNCFullColorImageReader(bigEndian, 3, 3, 2, 8);
                fullColorReader = new VNCFullColorImageReader(bigEndian, 5, 6, 5, outputBPP);
                fullColorReader = new VNCFullColorImageReader(bigEndian, 8, 8, 8, outputBPP);
    private boolean bigEndian;
        return bigEndian;
    public VNCFullColorImageReader(boolean bigEndian, int redBits, int greenBits, int blueBits, int outputBPP) throws VNCException {
        greenMax = (1 << greenBits) - 1;
        redMax   = (1 << redBits)   - 1;
        redShift = greenBits  blueBits;
        int red;
        int green;
        int blue;

        if (bigEndian) {
            red   = input.read();
            green = input.read();
            blue  = input.read();
        }
        else {
            blue  = input.read();
            green = input.read();
            red   = input.read();
        }

                short inputShort = input.readShort();
                if (!bigEndian) inputShort = Short.reverseBytes(inputShort);

                value = inputShort;

                int inputInt = input.readInt();
                if (!bigEndian) inputInt = Integer.reverseBytes(inputInt);

                value = inputInt;
    private boolean swapRedAndBlue;
        swapRedAndBlue = readBooleanParameter("swap-red-blue", false);
    public boolean getSwapRedAndBlue() {
        return swapRedAndBlue;
    }

                                config.getOutputBPP(),
                                config.getSwapRedAndBlue()
    public VNCClient(String host, int port, String password, int colorBits, int outputBPP, boolean swapRedAndBlue)
                fullColorReader = new VNCFullColorImageReader(bigEndian, 3, 3, 2, 8, swapRedAndBlue);
                fullColorReader = new VNCFullColorImageReader(bigEndian, 5, 6, 5, outputBPP, swapRedAndBlue);
                fullColorReader = new VNCFullColorImageReader(bigEndian, 8, 8, 8, outputBPP, swapRedAndBlue);
    private boolean swapRedAndBlue;

    public VNCFullColorImageReader(boolean bigEndian, int redBits, int greenBits, int blueBits, int outputBPP, boolean swapRedAndBlue) throws VNCException {
        this.swapRedAndBlue = swapRedAndBlue;

        if (swapRedAndBlue)
            return (blue << 16) | (green << 8) | red;
        else
            return (red << 16) | (green << 8) | blue;
        if (swapRedAndBlue)
            return (blue << 16) | (green << 8) | red;
        else
            return (red << 16) | (green << 8) | blue;
    private boolean swapRedAndBlue;
        swapRedAndBlue = readBooleanParameter("swap-red-blue", false);
    public boolean getSwapRedAndBlue() {
        return swapRedAndBlue;
    }

                                config.getOutputBPP(),
                                config.getSwapRedAndBlue()
    public VNCClient(String host, int port, String password, int colorBits, int outputBPP, boolean swapRedAndBlue)
                fullColorReader = new VNCFullColorImageReader(bigEndian, 3, 3, 2, 8, swapRedAndBlue);
                fullColorReader = new VNCFullColorImageReader(bigEndian, 5, 6, 5, outputBPP, swapRedAndBlue);
                fullColorReader = new VNCFullColorImageReader(bigEndian, 8, 8, 8, outputBPP, swapRedAndBlue);
    private boolean swapRedAndBlue;

    public VNCFullColorImageReader(boolean bigEndian, int redBits, int greenBits, int blueBits, int outputBPP, boolean swapRedAndBlue) throws VNCException {
        this.swapRedAndBlue = swapRedAndBlue;

        if (swapRedAndBlue)
            return (blue << 16) | (green << 8) | red;
        else
            return (red << 16) | (green << 8) | blue;
        if (swapRedAndBlue)
            return (blue << 16) | (green << 8) | red;
        else
            return (red << 16) | (green << 8) | blue;
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
            client = new SessionClient(
                    null /* CLIENT GOES HERE */
            );
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
            throw new GuacamoleException("Error disconnecting from server: "  e.getMessage(), e);
 *  Guacamole - Clientless Remote Desktop
 * Servlet which sets the clipboard data.
 *  Guacamole - Clientless Remote Desktop
 * client associated with the session, and returns the result (if any)
 *  Guacamole - Clientless Remote Desktop
 *  Guacamole - Clientless Remote Desktop
                // Query new update from server
import net.sourceforge.guacamole.GuacamoleClient;
                    new GuacamoleClient (
                        "localhost", // Temporarily hard coded
                        1234
                    )
    private InputStream input;
            input = new BufferedInputStream(sock.getInputStream());
            while (blocking || input.available() > 0) {
import java.io.Reader;
import java.io.InputStreamReader;
    private Reader input;
            input = new InputStreamReader(sock.getInputStream());
    private int bufferPos = 0;
    private char[] buffer = new char[20000];
            while (blocking || input.ready()) {
                int numRead = input.read(buffer, bufferPos, buffer.length - bufferPos);
                if (numRead == -1)
                for (int i=bufferPosnumRead-1; i>=bufferPos; i--) {
                    char readChar = buffer[i];
                    // If end of instruction, return it.
                    if (readChar == ';') {
                        // Get instruction
                        final String instruction = new String(buffer, 0, i1);
                        // Reset buffer
                        bufferPos = bufferPos  numRead - i - 1;
                        System.arraycopy(buffer, i1, buffer, 0, bufferPos);
                        // Return instruction string wrapped in Instruction class
                        return new Instruction() {

                            public String toString() {
                                return instruction;
                            }

                        };
                    }

                bufferPos = numRead;
 
    private int usedLength = 0;
                // If past threshold, resize buffer before reading
                if (usedLength > buffer.length/2) {
                    char[] newbuffer = new char[buffer.length*2];
                    System.arraycopy(newbuffer, 0, buffer, 0, usedLength);
                    buffer = newbuffer;
                }

                // Attempt to fill buffer
                int numRead = input.read(buffer, usedLength, buffer.length - usedLength);
                int prevLength = usedLength;
                usedLength = numRead;

                for (int i=usedLength-1; i>=prevLength; i--) {
                        usedLength -= i1;
                        System.arraycopy(buffer, i1, buffer, 0, usedLength);
            do {
                    char[] biggerBuffer = new char[buffer.length*2];
                    System.arraycopy(buffer, 0, biggerBuffer, 0, usedLength);
                    buffer = biggerBuffer;
            } while (input.ready()); // End read loop
import java.io.OutputStream;
import java.io.Writer;
import java.io.OutputStreamWriter;

    private Writer output;
            output = new OutputStreamWriter(sock.getOutputStream());

        try {
            int pressed = 0;
            if (event.getPressed()) pressed = 1;

            output.write("key:"  event.getKeySym()  ","  pressed  ";");
            output.flush();
        }
        catch (IOException e) {
            throw new GuacamoleException(e);
        }


        try {
            int mask = 0;
            if (event.isLeftButtonPressed())   mask |= 1;
            if (event.isMiddleButtonPressed()) mask |= 2;
            if (event.isRightButtonPressed())  mask |= 4;
            if (event.isUpButtonPressed())     mask |= 8;
            if (event.isDownButtonPressed())   mask |= 16;


            output.write("mouse:"  event.getX()  ","  event.getY()  ","  mask  ";");
            output.flush();
        }
        catch (IOException e) {
            throw new GuacamoleException(e);
        }

import net.sourceforge.guacamole.event.EventQueue;
import net.sourceforge.guacamole.event.EventHandler;
    private static final int EVENT_DEADLINE = 500;

    private EventQueue<KeyEvent> keyEvents = new EventQueue<KeyEvent>(new EventHandler<KeyEvent>() {

        public void handle(KeyEvent event) throws IOException {
    }, EVENT_DEADLINE);
    private EventQueue<PointerEvent> pointerEvents = new EventQueue<PointerEvent>(new EventHandler<PointerEvent>() {
        public void handle(PointerEvent event) throws IOException {

    }, EVENT_DEADLINE);


    public void send(KeyEvent event) throws GuacamoleException {

        try {
            keyEvents.add(event);
        }
        catch (IOException e) {
            throw new GuacamoleException(e);
        }

    }

    public void send(PointerEvent event) throws GuacamoleException {

        try {
            pointerEvents.add(event);
        }
    public abstract void ready() throws GuacamoleException;
    public void ready() throws GuacamoleException {

        try {
            output.write("ready;");
            output.flush();
        }
        catch (IOException e) {
            throw new GuacamoleException(e);
        }

    }
        public void ready() throws GuacamoleException {
            client.ready();
        }

            for (;;) {
            } // End read loop
        try {
            output.write("clipboard:"  Instruction.escape(clipboard)  ";");
            output.flush();
        }
        catch (IOException e) {
            throw new GuacamoleException(e);
        }
    public static String escape(String str) {
    public abstract void write(char[] chunk, int off, int len) throws GuacamoleException;
    public abstract char[] read() throws GuacamoleException;
    public void write(char[] chunk, int off, int len) throws GuacamoleException {
            output.write(chunk, off, len);
    public char[] read() throws GuacamoleException {
                        char[] chunk = new char[i1];
                        System.arraycopy(buffer, 0, chunk, 0, i1);
                        // Return instruction string
                        return chunk;
        public void write(char[] data, int off, int len) throws GuacamoleException {
            client.write(data, off, len);
        public char[] read() throws GuacamoleException {
            return client.read();
 b/guacamole/client/src/net/sourceforge/guacamole/net/input/Inbound.java
import java.io.Reader;
import java.io.IOException;

public class Inbound extends XMLGuacamoleServlet {
        // Send data
            Reader input = request.getReader();
            char[] buffer = new char[8192];
            int length;
            while ((length = input.read(buffer, 0, buffer.length)) != -1)
                session.getClient().write(buffer, 0, length);
            throw new GuacamoleException("I/O Error sending data to server: "  e.getMessage(), e);
            throw new GuacamoleException("Error sending data to server: "  e.getMessage(), e);

import java.io.Writer;
            Writer out = response.getWriter();
                char[] message;
                while ((message = client.read()) != null) {
                    out.write(message, 0, message.length);
                out.write("error:"  e.getMessage()  ";");
    public boolean isConnected() {
        synchronized (session) {
            return client != null;
        }
    }

        if (client != null) {

            session.removeAttribute("CLIENT");
            client = null;
        }
    protected boolean shouldCreateSession() {
        return true;
    }
        if (!session.isConnected())
            session.connect();

    protected boolean shouldCreateSession() {
        return true;
    }

        if (!session.isConnected())
            session.connect();

                if (message == null) {
                    session.disconnect();
                    throw new GuacamoleException("Disconnected.");
                }

    private String hostname;
    private int port;
        hostname       = context.getInitParameter("hostname");
        port           = readIntParameter("port", null);
    public int getPort() {
        return port;
    public String getHostname() {
        return hostname;
                        config.getHostname(),
                        config.getPort()
 b/guacamole/web-client/src/net/sourceforge/guacamole/net/tunnel/Inbound.java
package net.sourceforge.guacamole.net.tunnel;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import net.sourceforge.guacamole.net.GuacamoleServlet;
public class Inbound extends GuacamoleServlet {
    protected void handleRequest(GuacamoleSession session, HttpServletRequest request, HttpServletResponse response) throws GuacamoleException {
 b/guacamole/web-client/src/net/sourceforge/guacamole/net/tunnel/Outbound.java
package net.sourceforge.guacamole.net.tunnel;
public class Outbound extends GuacamoleServlet {
    private String guacd_hostname;
    private int guacd_port;
        guacd_hostname       = context.getInitParameter("guacd-hostname");
        guacd_port           = readIntParameter("guacd-port", null);
    public int getProxyPort() {
        return guacd_port;
    public String getProxyHostname() {
        return guacd_hostname;
                        config.getProxyHostname(),
                        config.getProxyPort()
    private SessionClient client;
    public class SessionClient extends Client implements HttpSessionBindingListener {
        private ReentrantLock authorizedLock;

            authorizedLock = new ReentrantLock();
            authorizedLock.lock();
        }

        public void authorize() {
            authorizedLock.unlock();
        }

        public void waitForAuthorization() {
            if (authorizedLock.isLocked()) {
                try {
                    authorizedLock.lock();
                    authorizedLock.unlock();
                }
                catch (Throwable t) {
                    throw new Error("Internal error waiting for authorization", t);
                }
            }
            client = (SessionClient) session.getAttribute("CLIENT");
    public SessionClient getClient() {
        String connectString = "connect:vnc,localhost,5901,potato;";

            char[] connect = connectString.toCharArray();
            session.getClient().authorize();
        
        session.getClient().waitForAuthorization();
        session.getClient().waitForAuthorization();

    @Override
import java.lang.reflect.InvocationTargetException;
import javax.servlet.http.HttpSession;
    private GuacamoleSessionProvider sessionProvider;
        // Get session provider instance
        try {
            String sessionProviderClassName = context.getInitParameter("session-provider");
            Object obj = Class.forName(sessionProviderClassName).getConstructor().newInstance();
            if (!(obj instanceof GuacamoleSessionProvider))
                throw new GuacamoleException("Specified session provider class is not a GuacamoleSessionProvider");

            sessionProvider = (GuacamoleSessionProvider) obj;
        }
        catch (ClassNotFoundException e) {
            throw new GuacamoleException("Session provider class not found", e);
        }
        catch (NoSuchMethodException e) {
            throw new GuacamoleException("Default constructor for session provider not present", e);
        }
        catch (SecurityException e) {
            throw new GuacamoleException("Creation of session provider disallowed; check your security settings", e);
        }
        catch (InstantiationException e) {
            throw new GuacamoleException("Unable to instantiate session provider", e);
        }
        catch (IllegalAccessException e) {
            throw new GuacamoleException("Unable to access default constructor of session provider", e);
        }
        catch (InvocationTargetException e) {
            throw new GuacamoleException("Internal error in constructor of session provider", e.getTargetException());
        }


    public GuacamoleSession createSession(HttpSession session) throws GuacamoleException {
        return sessionProvider.createSession(session);
    }

import javax.servlet.ServletConfig;
import javax.servlet.http.HttpSession;
    private GuacamoleConfiguration config;

    @Override
    public void init(ServletConfig config) throws ServletException {
        try {
            this.config = new GuacamoleConfiguration(config.getServletContext());
        }
        catch (GuacamoleException e) {
            throw new ServletException(e);
        }
    }


        HttpSession httpSession = request.getSession(shouldCreateSession());

        if (httpSession != null) {
            GuacamoleSession session = config.createSession(httpSession);
            handleRequest(session, request, response);
        }
        else
            throw new GuacamoleException("No session");
    private String protocol;
    private String hostname;
    private int port;
    private String password;

    public void setConnection(String protocol, String hostname, int port) {
        this.protocol = protocol;
        this.hostname = hostname;
        this.port = port;
    }

    public String getProtocol() {
        return protocol;
    }

    public String getHostname() {
        return hostname;
    }

    public int getPort() {
        return port;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getConnectMessage() throws GuacamoleException {

        if (getProtocol() == null)
            throw new GuacamoleException("Protocol not specified");

        if (getHostname() == null)
            throw new GuacamoleException("Hostname not specified");

        if (getPassword() == null)
            return "connect:"  getProtocol()  ","  getHostname()  ","  getPort()  ";";
        else
            return "connect:"  getProtocol()  ","  getHostname()  ","  getPort()  ","  getPassword()  ";";
    }

            char[] connect = session.getConnectMessage().toCharArray();
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
    public static class AuthInfo {

        public static enum Encoding {
            PLAIN_TEXT,
            MD5
        }
        private Encoding auth_encoding;
        public AuthInfo(String auth_username, String auth_password, Encoding auth_encoding) {
            this.auth_encoding = auth_encoding;

        private static final char HEX_CHARS[] = {
            '0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
        };

        public static String getHexString(byte[] bytes) {

            if (bytes == null)
                return null;

            StringBuilder hex = new StringBuilder(2 * bytes.length);
            for (byte b : bytes) {
                hex.append(HEX_CHARS[(b & 0xF0) >> 4])
                   .append(HEX_CHARS[(b & 0x0F)     ]);
            }

            return hex.toString();

        }


        public boolean validate(String username, String password) {

            // If username matches
            if (username != null && password != null && username.equals(auth_username)) {

                switch (auth_encoding) {

                    case PLAIN_TEXT:

                        // Compare plaintext
                        return password.equals(auth_password);
                    
                    case MD5:

                        // Compare hashed password
                        try {
                            MessageDigest digest = MessageDigest.getInstance("MD5");
                            String hashedPassword = getHexString(digest.digest(password.getBytes()));
                            return hashedPassword.equals(auth_password);
                        }
                        catch (NoSuchAlgorithmException e) {
                            throw new UnsupportedOperationException("Unexpected lack of MD5 support.", e);
                        }
                    
                }
                
            }

            return false;
            
        }
            AuthInfo.Encoding encoding;
            String encodingString = attributes.getValue("encoding");
            if (encodingString == null)
                encoding = AuthInfo.Encoding.PLAIN_TEXT;
            else if (encodingString.equals("plain"))
                encoding = AuthInfo.Encoding.PLAIN_TEXT;
            else if (encodingString.equals("md5"))
                encoding = AuthInfo.Encoding.MD5;
            else
                throw new SAXException("Invalid encoding type");


                attributes.getValue("password"),
                encoding
            if (info.validate(username, password)) {
                            return hashedPassword.equals(auth_password.toUpperCase());
                current.auth_username,
import java.io.File;
    private long mappingTime;
    private File getUserMappingFile() {
        
            return null;

        return new File(filename);

    }

    @Override
    public synchronized void init() throws ServletException {

        // Get user mapping file
        File mapFile = getUserMappingFile();
        if (mapFile == null)
            parser.parse(mapFile.getAbsolutePath());
            mappingTime = mapFile.lastModified();
        // Check mapping file mod time
        File userMappingFile = getUserMappingFile();
        if (userMappingFile.exists() && mappingTime < userMappingFile.lastModified()) {

            // If modified recently, gain exclusive access and recheck
            synchronized (this) {
                if (userMappingFile.exists() && mappingTime < userMappingFile.lastModified())
                    init(); // If still not up to date, re-init
            }

        }

    protected String readParameter(String name) throws GuacamoleException {
        String value = GuacamoleProperties.getProperty(name);
        return value;
    }

        String value = GuacamoleProperties.getProperty(name);
        String value = GuacamoleProperties.getProperty(name);
        String parmString = GuacamoleProperties.getProperty(name);
import net.sourceforge.guacamole.net.authentication.GuacamoleSessionProvider;
    public GuacamoleConfiguration() throws GuacamoleException {
        guacd_hostname       = readParameter("guacd-hostname");
            String sessionProviderClassName = readParameter("session-provider");
    public void init() throws ServletException {
            this.config = new GuacamoleConfiguration();
            config = new GuacamoleConfiguration();
 b/guacamole/web-client/src/net/sourceforge/guacamole/net/authentication/GuacamoleSessionProvider.java
package net.sourceforge.guacamole.net.authentication;
import net.sourceforge.guacamole.net.GuacamoleSession;
 b/guacamole/web-client/src/net/sourceforge/guacamole/net/authentication/NullGuacamoleSessionProvider.java
package net.sourceforge.guacamole.net.authentication;
import net.sourceforge.guacamole.net.GuacamoleSession;
 b/guacamole/web-client/src/net/sourceforge/guacamole/net/authentication/basic/BasicGuacamoleSessionProvider.java
package net.sourceforge.guacamole.net.authentication.basic;
import net.sourceforge.guacamole.net.authentication.GuacamoleSessionProvider;
import java.io.InputStream;
    private static final Properties properties;
        properties = new Properties();


            InputStream stream = GuacamoleProperties.class.getResourceAsStream("/guacamole.properties");
            if (stream == null)
                throw new IOException("Resource /guacamole.properties not found.");

            properties.load(stream);
import net.sourceforge.guacamole.net.GuacamoleProperties;
    private File getUserMappingFile() throws GuacamoleException {
        String filename = GuacamoleProperties.getProperty("basic-user-mapping");
import java.lang.reflect.InvocationTargetException;
import net.sourceforge.guacamole.net.Configuration;
    private Config config;

    @Override
    public void init() throws ServletException {
        try {
            config = new Config();
        }
        catch (GuacamoleException e) {
            throw new ServletException(e);
        }
    }


    private class Config extends Configuration {

        private AuthenticationProvider authProvider;

        public Config() throws GuacamoleException {

            // Get auth provider instance
            try {
                String authProviderClassName = readParameter("auth-provider");
                Object obj = Class.forName(authProviderClassName).getConstructor().newInstance();
                if (!(obj instanceof AuthenticationProvider))
                    throw new GuacamoleException("Specified session provider class is not a GuacamoleSessionProvider");

                authProvider = (AuthenticationProvider) obj;
            }
            catch (ClassNotFoundException e) {
                throw new GuacamoleException("Session provider class not found", e);
            }
            catch (NoSuchMethodException e) {
                throw new GuacamoleException("Default constructor for session provider not present", e);
            }
            catch (SecurityException e) {
                throw new GuacamoleException("Creation of session provider disallowed; check your security settings", e);
            }
            catch (InstantiationException e) {
                throw new GuacamoleException("Unable to instantiate session provider", e);
            }
            catch (IllegalAccessException e) {
                throw new GuacamoleException("Unable to access default constructor of session provider", e);
            }
            catch (InvocationTargetException e) {
                throw new GuacamoleException("Internal error in constructor of session provider", e.getTargetException());
            }

        }

        public AuthenticationProvider getAuthenticationProvider() {
            return authProvider;
        }

    }
            AuthorizedConfiguration info = config.getAuthenticationProvider().getAuthorizedConfiguration(username, password);
/*
 *  Guacamole - Clientless Remote Desktop
 *  Copyright (C) 2010  Michael Jumper
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 *  Guacamole - Clientless Remote Desktop
 *  Copyright (C) 2010  Michael Jumper
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 *  Guacamole - Clientless Remote Desktop
 *  Copyright (C) 2010  Michael Jumper
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.util.HashMap;

    private HashMap<String, String> parameters = new HashMap<String, String>();

    public String getProtocol() {
        return protocol;
    }

    public void setProtocol(String protocol) {
        this.protocol = protocol;
    }

    public String getParameter(String name) {
        return parameters.get(name);
    }

    public void setParameter(String name, String value) {
        parameters.put(name, value);
    }


            // TODO: Send "select" and "connect" messages here.


    public SessionClient getClient() throws GuacamoleException {

            if (client == null)
                throw new GuacamoleException("Client not yet connected.");

        synchronized (session) {

            if (client != null) {
                client.disconnect();
                session.removeAttribute("CLIENT");
                client = null;
            }


import java.util.HashMap;

public class Configuration {
    private String protocol;
    private HashMap<String, String> parameters = new HashMap<String, String>();
    public String getProtocol() {
        return protocol;
    public void setProtocol(String protocol) {
        this.protocol = protocol;
    public String getParameter(String name) {
        return parameters.get(name);
    public void setParameter(String name, String value) {
        parameters.put(name, value);
import java.lang.reflect.InvocationTargetException;
import net.sourceforge.guacamole.net.authentication.GuacamoleClientProvider;
    public static String getProxyHostname() throws GuacamoleException {
        return GuacamoleProperties.getProperty("guacd-hostname");
    }

    public static int getProxyPort() throws GuacamoleException {
        return GuacamoleProperties.getIntProperty("guacd-port", null);
    }

    public static GuacamoleClientProvider getClientProvider() throws GuacamoleException {

        // Get client provider instance
        try {
            String sessionProviderClassName = GuacamoleProperties.getProperty("client-provider");
            Object obj = Class.forName(sessionProviderClassName).getConstructor().newInstance();
            if (!(obj instanceof GuacamoleClientProvider))
                throw new GuacamoleException("Specified client provider class is not a GuacamoleClientProvider");

            return (GuacamoleClientProvider) obj;
        }
        catch (ClassNotFoundException e) {
            throw new GuacamoleException("Session provider class not found", e);
        }
        catch (NoSuchMethodException e) {
            throw new GuacamoleException("Default constructor for client provider not present", e);
        }
        catch (SecurityException e) {
            throw new GuacamoleException("Creation of client provider disallowed; check your security settings", e);
        }
        catch (InstantiationException e) {
            throw new GuacamoleException("Unable to instantiate client provider", e);
        }
        catch (IllegalAccessException e) {
            throw new GuacamoleException("Unable to access default constructor of client provider", e);
        }
        catch (InvocationTargetException e) {
            throw new GuacamoleException("Internal error in constructor of client provider", e.getTargetException());
        }

    }

    protected static String humanReadableList(Object... values) {

        String list = "";
        for (int i=0; i<values.length; i) {

            if (i >= 1)
                list = ", ";

            if (i == values.length -1)
                list = " or ";

            list = "\""  values[i]  "\"";
        }

        return list;

    }

    public static String getProperty(String name, String defaultValue, String... allowedValues) throws GuacamoleException {

        String value = getProperty(name);

        // Use default if not specified
        if (value == null) {
            if (defaultValue == null)
                throw new GuacamoleException("Parameter \""  name  "\" is required.");

            return defaultValue;
        }

        // If not restricted to certain values, just return whatever is given.
        if (allowedValues.length == 0)
            return value;

        // If restricted, only return value within given list
        for (String allowedValue : allowedValues)
            if (value.equals(allowedValue))
                return value;

        throw new GuacamoleException("Parameter \""  name  "\" must be "  humanReadableList((Object) allowedValues));
    }

    public static boolean getBooleanProperty(String name, Boolean defaultValue) throws GuacamoleException {

        String value = getProperty(name);

        // Use default if not specified
        if (value == null) {
            if (defaultValue == null)
                throw new GuacamoleException("Parameter \""  name  "\" is required.");

            return defaultValue;
        }

        value = value.trim();
        if (value.equals("true"))
            return true;

        if (value.equals("false"))
            return false;

        throw new GuacamoleException("Parameter \""  name  "\" must be \"true\" or \"false\".");

    }

    public static int getIntProperty(String name, Integer defaultValue, Integer... allowedValues) throws GuacamoleException {

        String parmString = getProperty(name);

        // Use default if not specified
        if (parmString== null) {
            if (defaultValue == null)
                throw new GuacamoleException("Parameter \""  name  "\" is required.");

            return defaultValue;
        }

        try {
            int value = Integer.parseInt(parmString);

            // If not restricted to certain values, just return whatever is given.
            if (allowedValues.length == 0)
                return value;

            // If restricted, only return value within given list
            for (int allowedValue : allowedValues)
                if (value == allowedValue)
                    return value;

            throw new GuacamoleException("Parameter \""  name  "\" must be "  humanReadableList((Object) allowedValues));
        }
        catch (NumberFormatException e) {
            throw new GuacamoleException("Parameter \""  name  "\" must be an integer.", e);
        }

    }

        synchronized (session) {

    public void attachClient(GuacamoleClient client) throws GuacamoleException {
            this.client = new SessionClient(client);
            session.setAttribute("CLIENT", this.client);
                throw new GuacamoleException("Client not yet attached.");
    public void detachClient() throws GuacamoleException {
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/net/authentication/GuacamoleClientProvider.java
import net.sourceforge.guacamole.GuacamoleClient;
public interface GuacamoleClientProvider {
    public GuacamoleClient createClient(HttpSession session) throws GuacamoleException;
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/net/authentication/NullGuacamoleClientProvider.java
import net.sourceforge.guacamole.GuacamoleClient;
public class NullGuacamoleClientProvider implements GuacamoleClientProvider {
    public GuacamoleClient createClient(HttpSession session) throws GuacamoleException {
        throw new GuacamoleException("Null provider will not create clients.");
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpSession;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.GuacamoleProperties;

public class Connect extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        HttpSession httpSession = request.getSession(false);
        try {
            GuacamoleSession session = new GuacamoleSession(httpSession);
            session.attachClient(
                GuacamoleProperties.getClientProvider().createClient(httpSession)
            );

        }
        catch (GuacamoleException e) {
            throw new ServletException(e);
        }
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpSession;

public class Inbound extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException {

        HttpSession httpSession = request.getSession(false);

            GuacamoleSession session = new GuacamoleSession(httpSession);
            // Send data
            try {
                Reader input = request.getReader();
                char[] buffer = new char[8192];

                int length;
                while ((length = input.read(buffer, 0, buffer.length)) != -1)
                    session.getClient().write(buffer, 0, length);

            }
            catch (IOException e) {
                throw new GuacamoleException("I/O Error sending data to server: "  e.getMessage(), e);
            }

            throw new ServletException(e);
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpSession;
public class Outbound extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        HttpSession httpSession = request.getSession(false);
            GuacamoleSession session = new GuacamoleSession(httpSession);

            ReentrantLock instructionStreamLock = session.getInstructionStreamLock();
            instructionStreamLock.lock();
                response.setContentType("text/plain");
                Writer out = response.getWriter();
                try {
                    // Query new update from server
                    Client client = session.getClient();

                    // For all messages, until another stream is ready (we send at least one message)
                    char[] message;
                    while ((message = client.read()) != null) {

                        // Get message output bytes
                        out.write(message, 0, message.length);
                        out.flush();
                        response.flushBuffer();

                        // No more messages another stream can take over
                        if (instructionStreamLock.hasQueuedThreads())
                            break;

                    }

                    if (message == null) {
                        session.detachClient();
                        throw new GuacamoleException("Disconnected.");
                    }

                }
                catch (GuacamoleException e) {
                    out.write("error:"  e.getMessage()  ";");
                // End-of-instructions marker
                out.write(';');

            }
            catch (UnsupportedEncodingException e) {
                throw new ServletException("UTF-8 not supported by Java.", e);
            }
            catch (IOException e) {
                throw new ServletException("I/O error writing to servlet output stream.", e);
            }
            finally {
                instructionStreamLock.unlock();
        catch (GuacamoleException e) {
            throw new ServletException(e);
import net.sourceforge.guacamole.net.Configuration;
    public Configuration getAuthorizedConfiguration(String username, String password) throws GuacamoleException {
        if (info != null && info.validate(username, password)) {

            Configuration config = new Configuration();

            // TODO: Migrate user-mapping to general form
            config.setProtocol(info.getProtocol());
            config.setParameter("hostname", info.getHostname());
            config.setParameter("port", Integer.toString(info.getPort()));
            config.setParameter("password", info.getPassword());

            return config;

        }
 b/guacamole/src/main/java/net/sourceforge/guacamole/net/authentication/basic/BasicGuacamoleClientProvider.java
import net.sourceforge.guacamole.GuacamoleClient;
import net.sourceforge.guacamole.net.Configuration;
import net.sourceforge.guacamole.net.authentication.GuacamoleClientProvider;
public class BasicGuacamoleClientProvider implements GuacamoleClientProvider {
    public GuacamoleClient createClient(HttpSession session) throws GuacamoleException {
        Configuration config = (Configuration) session.getAttribute("BASIC-LOGIN-AUTH");
        GuacamoleClient client = new GuacamoleClient("localhost", 4822);

        // TODO: Send "select" and "connect" messages in client connect function (based on config) ... to be implemented.
        char[] initMessages = "select:vnc;connect:localhost,5901,potato;".toCharArray();
        client.write(initMessages, 0, initMessages.length);
        return client;
import net.sourceforge.guacamole.net.GuacamoleProperties;
    private AuthenticationProvider authProvider;

        // Get auth provider instance
            String authProviderClassName = GuacamoleProperties.getProperty("auth-provider");
            Object obj = Class.forName(authProviderClassName).getConstructor().newInstance();
            if (!(obj instanceof AuthenticationProvider))
                throw new ServletException("Specified authentication provider class is not a AuthenticationProvider.");

            authProvider = (AuthenticationProvider) obj;
        catch (ClassNotFoundException e) {
            throw new ServletException("Authentication provider class not found", e);
        catch (NoSuchMethodException e) {
            throw new ServletException("Default constructor for authentication provider not present", e);
        }
        catch (SecurityException e) {
            throw new ServletException("Creation of authentication provider disallowed; check your security settings", e);
        }
        catch (InstantiationException e) {
            throw new ServletException("Unable to instantiate authentication provider", e);
        }
        catch (IllegalAccessException e) {
            throw new ServletException("Unable to access default constructor of authentication provider", e);
        }
        catch (InvocationTargetException e) {
            throw new ServletException("Internal error in constructor of authentication provider", e.getTargetException());
        public Configuration getAuthorizedConfiguration(String username, String password) throws GuacamoleException;
            Configuration config = authProvider.getAuthorizedConfiguration(username, password);
            if (config != null) {
                    config
import net.sourceforge.guacamole.net.Configuration;

public abstract class GuacamoleClient {
    public abstract void write(char[] chunk, int off, int len) throws GuacamoleException;
    public abstract char[] read() throws GuacamoleException;
    public abstract void disconnect() throws GuacamoleException;
    public void connect(Configuration config) throws GuacamoleException {
        // TODO: Send "select" and "connect" messages in client connect function (based on config) ... to be implemented.
        char[] initMessages = "select:vnc;connect:localhost,5901,potato;".toCharArray();
        write(initMessages, 0, initMessages.length);
import net.sourceforge.guacamole.GuacamoleTCPClient;
    public class SessionClient extends GuacamoleClient implements HttpSessionBindingListener {
        private GuacamoleClient client;
        public SessionClient(GuacamoleClient client) {
    public void attachClient(GuacamoleTCPClient client) throws GuacamoleException {
import net.sourceforge.guacamole.GuacamoleTCPClient;
    public GuacamoleTCPClient createClient(HttpSession session) throws GuacamoleException;
import net.sourceforge.guacamole.GuacamoleTCPClient;
    public GuacamoleTCPClient createClient(HttpSession session) throws GuacamoleException {
import net.sourceforge.guacamole.GuacamoleClient;
                    GuacamoleClient client = session.getClient();
import net.sourceforge.guacamole.GuacamoleTCPClient;
import net.sourceforge.guacamole.net.GuacamoleProperties;
    public GuacamoleTCPClient createClient(HttpSession session) throws GuacamoleException {
        String hostname = GuacamoleProperties.getProperty("guacd-hostname");
        int port = GuacamoleProperties.getIntProperty("guacd-port", null);
        GuacamoleTCPClient client = new GuacamoleTCPClient(hostname, port);
import net.sourceforge.guacamole.GuacamoleInstruction.Operation;

    public void write(char[] chunk) throws GuacamoleException {
        write(chunk, 0, chunk.length);
    }

    public void write(GuacamoleInstruction instruction) throws GuacamoleException {
        write(instruction.toString().toCharArray());
    }


        // Send protocol
        write(new GuacamoleInstruction(Operation.CLIENT_SELECT, config.getProtocol()));

        // TODO: Wait for and read args message

        // Send args
        write(new GuacamoleInstruction(Operation.CLIENT_CONNECT, "localhost", "5901", "potato"));
import java.util.LinkedList;
    private int instructionStart;
    private char[] buffer;

    public GuacamoleInstruction readInstruction() throws GuacamoleException {

        // Fill buffer if not already filled
        if (buffer == null) {
            buffer = read();
            instructionStart = 0;
        }

        // Locate end-of-opcode and end-of-instruction
        int opcodeEnd = -1;
        int instructionEnd = -1;

        for (int i=instructionStart; i<buffer.length; i) {

            char c = buffer[i];

            if (c == ':')
                opcodeEnd = i;

            else if (c == ';') {
                instructionEnd = i;
                break;
            }

        }

        // If no end-of-instruction marker, malformed.
        if (instructionEnd == -1)
            throw new GuacamoleException("Malformed instruction.");

        // If no end-of-opcode marker, end is end-of-instruction
        if (opcodeEnd == -1)
            opcodeEnd = instructionEnd;

        // Parse opcode
        String opcode = new String(buffer, instructionStart, opcodeEnd - instructionStart);

        // Parse args
        String[] args;
        if (instructionEnd > opcodeEnd)
            args = new String(buffer, opcodeEnd1, instructionEnd - opcodeEnd - 1).split(",");
        else
            args = new String[0];

        // Create instruction
        GuacamoleInstruction instruction = new GuacamoleInstruction(
                Operation.fromOpcode(opcode),
                args
        );

        // Advance buffer
        instructionStart = instructionEnd  1;
        if (instructionStart >= buffer.length)
            buffer = null;

        return instruction;

    }

        // Wait for server args
        GuacamoleInstruction instruction;
        do {
            instruction = readInstruction();
        } while (instruction.getOperation() != Operation.SERVER_ARGS);

        // Build args list off provided names and config
        String[] args = new String[instruction.getArgs().length];
        for (int i=0; i<instruction.getArgs().length; i) {

            String requiredArg = instruction.getArgs()[i];

            String value = config.getParameter(requiredArg);
            if (value != null)
                args[i] = value;
            else
                args[i] = "";
            
        }
        write(new GuacamoleInstruction(Operation.CLIENT_CONNECT, args));
        public static Operation fromOpcode(String opcode) {
        buff.append(operation.getOpcode());
        client.connect(config);
        if (info != null && info.validate(username, password))
            return info.getConfiguration();
        private Configuration config;

            config = new Configuration();
        public Configuration getConfiguration() {
            return config;
        private enum State {
            ROOT,
            USER_MAPPING,
            AUTH_INFO,
            PARAMETER,
            END;
        }
        private State state = State.ROOT;
        private AuthInfo current = null;
        private String currentParameter = null;
            switch (state)  {
                case USER_MAPPING:

                    if (localName.equals("user-mapping")) {
                        state = State.END;
                        return;
                    }

                    break;

                case AUTH_INFO:

                    if (localName.equals("authorize")) {

                        // Finalize mapping for this user
                        authMapping.put(
                            current.auth_username,
                            current
                        );

                        state = State.USER_MAPPING;
                        return;
                    }

                    break;

                case PROTOCOL:

                    if (localName.equals("protocol")) {
                        state = State.AUTH_INFO;
                        return;
                    }

                    break;

                case PARAMETER:

                    if (localName.equals("param")) {
                        state = State.AUTH_INFO;
                        return;
                    }

                    break;
            throw new SAXException("Tag not yet complete: "  localName);
            switch (state)  {
                // Document must be <user-mapping>
                case ROOT:

                    if (localName.equals("user-mapping")) {
                        state = State.USER_MAPPING;
                        return;
                    }

                    break;

                // Only <authorize> tags allowed in main document
                case USER_MAPPING:

                    if (localName.equals("authorize")) {

                        AuthInfo.Encoding encoding;
                        String encodingString = attributes.getValue("encoding");
                        if (encodingString == null)
                            encoding = AuthInfo.Encoding.PLAIN_TEXT;
                        else if (encodingString.equals("plain"))
                            encoding = AuthInfo.Encoding.PLAIN_TEXT;
                        else if (encodingString.equals("md5"))
                            encoding = AuthInfo.Encoding.MD5;
                        else
                            throw new SAXException("Invalid encoding type");
                        current = new AuthInfo(
                            attributes.getValue("username"),
                            attributes.getValue("password"),
                            encoding
                        );
                        // Next state
                        state = State.AUTH_INFO;
                        return;
                    }

                    break;

                case AUTH_INFO:

                    if (localName.equals("protocol")) {
                        // Next state
                        state = State.PROTOCOL;
                        return;
                    }

                    if (localName.equals("param")) {

                        currentParameter = attributes.getValue("name");
                        if (currentParameter == null)
                            throw new SAXException("Attribute \"name\" required for param tag.");

                        // Next state
                        state = State.PARAMETER;
                        return;
                    }

                    break;
            throw new SAXException("Unexpected tag: "  localName);
            switch (state) {
                    current.getConfiguration().setProtocol(str);
                    return;
                case PARAMETER:
                    current.getConfiguration().setParameter(currentParameter, str);
                    return;
                
            if (str.trim().length() != 0)
                throw new SAXException("Unexpected character data.");

import net.sourceforge.guacamole.net.Configuration;
    public Configuration getAuthorizedConfiguration(String username, String password) throws GuacamoleException {
            return info.getConfiguration();
        private Configuration config;

            config = new Configuration();
        public Configuration getConfiguration() {
            return config;
        private enum State {
            ROOT,
            USER_MAPPING,
            AUTH_INFO,
            PARAMETER,
            END;
        }
        private State state = State.ROOT;
        private AuthInfo current = null;
        private String currentParameter = null;
            switch (state)  {
                case USER_MAPPING:

                    if (localName.equals("user-mapping")) {
                        state = State.END;
                        return;
                    }

                    break;

                case AUTH_INFO:

                    if (localName.equals("authorize")) {

                        // Finalize mapping for this user
                        authMapping.put(
                            current.auth_username,
                            current
                        );

                        state = State.USER_MAPPING;
                        return;
                    }

                    break;

                case PROTOCOL:

                    if (localName.equals("protocol")) {
                        state = State.AUTH_INFO;
                        return;
                    }

                    break;

                case PARAMETER:

                    if (localName.equals("param")) {
                        state = State.AUTH_INFO;
                        return;
                    }

                    break;
            throw new SAXException("Tag not yet complete: "  localName);
            switch (state)  {
                // Document must be <user-mapping>
                case ROOT:

                    if (localName.equals("user-mapping")) {
                        state = State.USER_MAPPING;
                        return;
                    }

                    break;

                // Only <authorize> tags allowed in main document
                case USER_MAPPING:

                    if (localName.equals("authorize")) {

                        AuthInfo.Encoding encoding;
                        String encodingString = attributes.getValue("encoding");
                        if (encodingString == null)
                            encoding = AuthInfo.Encoding.PLAIN_TEXT;
                        else if (encodingString.equals("plain"))
                            encoding = AuthInfo.Encoding.PLAIN_TEXT;
                        else if (encodingString.equals("md5"))
                            encoding = AuthInfo.Encoding.MD5;
                        else
                            throw new SAXException("Invalid encoding type");
                        current = new AuthInfo(
                            attributes.getValue("username"),
                            attributes.getValue("password"),
                            encoding
                        );
                        // Next state
                        state = State.AUTH_INFO;
                        return;
                    }

                    break;

                case AUTH_INFO:

                    if (localName.equals("protocol")) {
                        // Next state
                        state = State.PROTOCOL;
                        return;
                    }

                    if (localName.equals("param")) {

                        currentParameter = attributes.getValue("name");
                        if (currentParameter == null)
                            throw new SAXException("Attribute \"name\" required for param tag.");

                        // Next state
                        state = State.PARAMETER;
                        return;
                    }

                    break;
            throw new SAXException("Unexpected tag: "  localName);
            switch (state) {
                    current.getConfiguration().setProtocol(str);
                    return;
                case PARAMETER:
                    current.getConfiguration().setParameter(currentParameter, str);
                    return;
                
            if (str.trim().length() != 0)
                throw new SAXException("Unexpected character data.");

import net.sourceforge.guacamole.net.GuacamoleProperties;
    private AuthenticationProvider authProvider;

        // Get auth provider instance
            String authProviderClassName = GuacamoleProperties.getProperty("auth-provider");
            Object obj = Class.forName(authProviderClassName).getConstructor().newInstance();
            if (!(obj instanceof AuthenticationProvider))
                throw new ServletException("Specified authentication provider class is not a AuthenticationProvider.");

            authProvider = (AuthenticationProvider) obj;
        catch (ClassNotFoundException e) {
            throw new ServletException("Authentication provider class not found", e);
        catch (NoSuchMethodException e) {
            throw new ServletException("Default constructor for authentication provider not present", e);
        }
        catch (SecurityException e) {
            throw new ServletException("Creation of authentication provider disallowed; check your security settings", e);
        }
        catch (InstantiationException e) {
            throw new ServletException("Unable to instantiate authentication provider", e);
        }
        catch (IllegalAccessException e) {
            throw new ServletException("Unable to access default constructor of authentication provider", e);
        }
        catch (InvocationTargetException e) {
            throw new ServletException("Internal error in constructor of authentication provider", e.getTargetException());
        public Configuration getAuthorizedConfiguration(String username, String password) throws GuacamoleException;
            Configuration config = authProvider.getAuthorizedConfiguration(username, password);
            if (config != null) {
                    config
 b/guacamole/src/main/java/net/sourceforge/guacamole/net/basic/BasicFileAuthenticationProvider.java
package net.sourceforge.guacamole.net.basic;
 b/guacamole/src/main/java/net/sourceforge/guacamole/net/basic/BasicGuacamoleTunnelServlet.java
package net.sourceforge.guacamole.net.basic;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleTCPClient;
import net.sourceforge.guacamole.net.Configuration;
import net.sourceforge.guacamole.net.GuacamoleProperties;
import net.sourceforge.guacamole.net.GuacamoleSession;
import net.sourceforge.guacamole.net.tunnel.GuacamoleTunnelServlet;
public class BasicGuacamoleTunnelServlet extends GuacamoleTunnelServlet {

    @Override
    protected void doConnect(HttpServletRequest request, HttpServletResponse response) throws GuacamoleException {

        // Session must already exist from login
        HttpSession httpSession = request.getSession(false);
        Configuration config = (Configuration) httpSession.getAttribute("BASIC-LOGIN-AUTH");
        // Set client for session
        GuacamoleSession session = new GuacamoleSession(httpSession);
        session.attachClient(client);

 b/guacamole/src/main/java/net/sourceforge/guacamole/net/basic/BasicLogin.java
package net.sourceforge.guacamole.net.basic;
 b/guacamole/src/main/java/net/sourceforge/guacamole/net/basic/BasicFileAuthenticationProvider.java
package net.sourceforge.guacamole.net.basic;
 b/guacamole/src/main/java/net/sourceforge/guacamole/net/basic/BasicGuacamoleTunnelServlet.java
package net.sourceforge.guacamole.net.basic;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleTCPClient;
import net.sourceforge.guacamole.net.Configuration;
import net.sourceforge.guacamole.net.GuacamoleProperties;
import net.sourceforge.guacamole.net.GuacamoleSession;
import net.sourceforge.guacamole.net.tunnel.GuacamoleTunnelServlet;
public class BasicGuacamoleTunnelServlet extends GuacamoleTunnelServlet {

    @Override
    protected void doConnect(HttpServletRequest request, HttpServletResponse response) throws GuacamoleException {

        // Session must already exist from login
        HttpSession httpSession = request.getSession(false);
        Configuration config = (Configuration) httpSession.getAttribute("BASIC-LOGIN-AUTH");
        // Set client for session
        GuacamoleSession session = new GuacamoleSession(httpSession);
        session.attachClient(client);

 b/guacamole/src/main/java/net/sourceforge/guacamole/net/basic/BasicLogin.java
package net.sourceforge.guacamole.net.basic;
            // Note that although we are sending text, Webkit browsers will
            // buffer 1024 bytes before starting a normal stream if we use
            // anything but application/octet-stream.
            response.setContentType("application/octet-stream");

        // We still need to set the content type to avoid the default of
        // text/html, as such a content type would cause some browsers to
        // attempt to parse the result, even though the JavaScript client
        // does not explicitly request such parsing.
        response.setContentType("application/octet-stream");
        response.setContentLength(0);

import java.net.InetSocketAddress;
import java.net.SocketAddress;
    private static final int SOCKET_TIMEOUT = 5000;


            // Get address
            SocketAddress address = new InetSocketAddress(
                    InetAddress.getByName(hostname),
                    port
            );

            // Connect with timeout
            sock = new Socket();
            sock.connect(address, SOCKET_TIMEOUT);

            // On successful connect, retrieve I/O streams

    private static final int SOCKET_TIMEOUT = 15000;
            // Set read timeout
            sock.setSoTimeout(SOCKET_TIMEOUT);

import net.sourceforge.guacamole.net.tunnel.GuacamoleTunnel;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
    private ConcurrentMap<String, GuacamoleTunnel> tunnels;
            tunnels = (ConcurrentMap<String, GuacamoleTunnel>) session.getAttribute("GUAC_TUNNELS");
            if (tunnels == null) {
                tunnels = new ConcurrentHashMap<String, GuacamoleTunnel>();
                session.setAttribute("GUAC_TUNNELS", tunnels);
    public void invalidate() {
        session.invalidate();
    }

    public void attachTunnel(GuacamoleTunnel tunnel) throws GuacamoleException {
        tunnels.put(tunnel.getUUID().toString(), tunnel);
    }

    public void detachTunnel(GuacamoleTunnel tunnel) throws GuacamoleException {
        tunnels.remove(tunnel.getUUID().toString());
    }

    public GuacamoleTunnel getTunnel(String tunnelUUID) {
        return tunnels.get(tunnelUUID);
            if (query.equals("connect")) {
                GuacamoleTunnel tunnel = doConnect(request);
                if (tunnel != null) {
                    try {
                        response.getWriter().println(tunnel.getUUID().toString());
                    }
                    catch (IOException e) {
                        throw new GuacamoleException(e);
                    }
                }
            }

            else if(query.startsWith("read:"))
                doRead(request, response, query.substring(5));

            else if(query.startsWith("write:"))
                doWrite(request, response, query.substring(6));
    protected abstract GuacamoleTunnel doConnect(HttpServletRequest request) throws GuacamoleException;
    protected void doRead(HttpServletRequest request, HttpServletResponse response, String tunnelUUID) throws GuacamoleException {
        GuacamoleTunnel tunnel = session.getTunnel(tunnelUUID);
        if (tunnel == null)
            throw new GuacamoleException("No such tunnel.");

        ReentrantLock instructionStreamLock = tunnel.getInstructionStreamLock();
                GuacamoleClient client = tunnel.getClient();
                    session.detachTunnel(tunnel);
    protected void doWrite(HttpServletRequest request, HttpServletResponse response, String tunnelUUID) throws GuacamoleException {
        GuacamoleTunnel tunnel = session.getTunnel(tunnelUUID);
        if (tunnel == null)
            throw new GuacamoleException("No such tunnel.");

            GuacamoleClient client = tunnel.getClient();

                client.write(buffer, 0, length);
            // If connect operation, call doConnect() and return tunnel UUID
            // in response.
            // If read operation, call doRead() with tunnel UUID
            // If write operation, call doWrite() with tunnel UUID
            // Otherwise, invalid operation

        // Catch any thrown guacamole exception and attempt to pass within the
        // HTTP response.

            try {

                // If response not committed, send error code along with
                // message.
                if (!response.isCommitted()) {
                    response.setHeader("X-Guacamole-Error-Message", e.getMessage());
                    response.sendError(
                            HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                            e.getMessage()
                    );
                }

                // If unable to send error code, rethrow as servlet exception
                else
                    throw new ServletException(e);

            }
            catch (IOException ioe) {

                // If unable to send error at all due to I/O problems,
                // rethrow as servlet exception
                throw new ServletException(ioe);

            }

            // Query new update from server
            GuacamoleClient client = tunnel.getClient();
            // For all messages, until another stream is ready (we send at least one message)
            char[] message;
            while ((message = client.read()) != null) {
                // Get message output bytes
                out.write(message, 0, message.length);

                // No more messages another stream can take over
                if (instructionStreamLock.hasQueuedThreads())
                    break;

            }

            if (message == null) {
                session.detachTunnel(tunnel);
                throw new GuacamoleException("Disconnected.");
public class BasicFileAuthenticationProvider implements AuthenticationProvider {
import java.lang.reflect.InvocationTargetException;
import javax.servlet.ServletException;
import net.sourceforge.guacamole.net.tunnel.GuacamoleTunnel;
    private AuthenticationProvider authProvider;

    public void init() throws ServletException {
        // Get auth provider instance
        try {
            String authProviderClassName = GuacamoleProperties.getProperty("auth-provider");
            Object obj = Class.forName(authProviderClassName).getConstructor().newInstance();
            if (!(obj instanceof AuthenticationProvider))
                throw new ServletException("Specified authentication provider class is not a AuthenticationProvider.");
            authProvider = (AuthenticationProvider) obj;
        }
        catch (GuacamoleException e) {
            throw new ServletException(e);
        }
        catch (ClassNotFoundException e) {
            throw new ServletException("Authentication provider class not found", e);
        }
        catch (NoSuchMethodException e) {
            throw new ServletException("Default constructor for authentication provider not present", e);
        }
        catch (SecurityException e) {
            throw new ServletException("Creation of authentication provider disallowed; check your security settings", e);
        }
        catch (InstantiationException e) {
            throw new ServletException("Unable to instantiate authentication provider", e);
        }
        catch (IllegalAccessException e) {
            throw new ServletException("Unable to access default constructor of authentication provider", e);
        }
        catch (InvocationTargetException e) {
            throw new ServletException("Internal error in constructor of authentication provider", e.getTargetException());
        }
    }

    @Override
    protected GuacamoleTunnel doConnect(HttpServletRequest request) throws GuacamoleException {

        HttpSession httpSession = request.getSession(true);

        // Retrieve username and password from parms
        String username = request.getParameter("username");
        String password = request.getParameter("password");

        // Get authorized config
        Configuration config = authProvider.getAuthorizedConfiguration(username, password);
            throw new GuacamoleException("Invalid login");
        // Configure and connect client
        // Associate client with tunnel
        GuacamoleTunnel tunnel = new GuacamoleTunnel(client);

        // Attach tunnel to session
        session.attachTunnel(tunnel);

        return tunnel;
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/GuacamoleProperties.java
package net.sourceforge.guacamole;
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/net/GuacamoleSocket.java
import net.sourceforge.guacamole.protocol.Configuration;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.io.GuacamoleReader;
import net.sourceforge.guacamole.io.GuacamoleWriter;
public interface GuacamoleSocket {
    public GuacamoleReader getReader();
    public GuacamoleWriter getWriter();
    public void connect(Configuration config) throws GuacamoleException;
    public void disconnect() throws GuacamoleException;
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/protocol/Configuration.java
package net.sourceforge.guacamole.protocol;
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/protocol/GuacamoleInstruction.java
package net.sourceforge.guacamole.protocol;
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/servlet/GuacamoleSession.java
package net.sourceforge.guacamole.servlet;
import net.sourceforge.guacamole.net.GuacamoleTunnel;
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/servlet/GuacamoleTunnelServlet.java
package net.sourceforge.guacamole.servlet;
import net.sourceforge.guacamole.net.GuacamoleTunnel;
import net.sourceforge.guacamole.io.GuacamoleReader;
import net.sourceforge.guacamole.net.GuacamoleSocket;
import net.sourceforge.guacamole.io.GuacamoleWriter;
        // Obtain exclusive read access
        GuacamoleReader reader = tunnel.acquireReader();
            while ((message = reader.read()) != null) {
                if (tunnel.hasQueuedReaderThreads())
            tunnel.releaseReader();
            GuacamoleWriter writer = tunnel.acquireWriter();
                writer.write(buffer, 0, length);
        finally {
            tunnel.releaseWriter();
        }
    public void close() throws GuacamoleException;
public class TCPGuacamoleSocket implements GuacamoleSocket {
    public void close() throws GuacamoleException {
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/protocol/ConfiguredSocket.java
package net.sourceforge.guacamole.protocol;
import net.sourceforge.guacamole.net.GuacamoleSocket;
public class ConfiguredSocket implements GuacamoleSocket {
    private GuacamoleSocket socket;

    public ConfiguredSocket(GuacamoleSocket socket, Configuration config) throws GuacamoleException {

        this.socket = socket;
        GuacamoleReader reader = socket.getReader();
        GuacamoleWriter writer = socket.getWriter();
    @Override
    public GuacamoleWriter getWriter() {
        return socket.getWriter();
    }

    @Override
    public GuacamoleReader getReader() {
        return socket.getReader();
    }

    @Override
    public void close() throws GuacamoleException {
        socket.close();
    }

    @Override
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/protocol/ConfiguredGuacamoleSocket.java
public class ConfiguredGuacamoleSocket implements GuacamoleSocket {
    public ConfiguredGuacamoleSocket(GuacamoleSocket socket, GuacamoleConfiguration config) throws GuacamoleException {
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/protocol/GuacamoleConfiguration.java
public class GuacamoleConfiguration {
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/net/InetGuacamoleSocket.java
public class InetGuacamoleSocket implements GuacamoleSocket {
    public InetGuacamoleSocket(String hostname, int port) throws GuacamoleException {

/**
 * A generic exception thrown when parts of the Guacamole API encounter
 * errors.
 *
 * @author Michael Jumper
 */
    /**
     * Creates a new GuacamoleException with the given message and cause.
     *
     * @param message A human readable description of the exception that
     *                occurred.
     * @param cause The cause of this exception.
     */
    /**
     * Creates a new GuacamoleException with the given message.
     *
     * @param message A human readable description of the exception that
     *                occurred.
     */
    /**
     * Creates a new GuacamoleException with the given cause.
     *
     * @param cause The cause of this exception.
     */
    private GuacamoleProperties() {}

import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
    public GuacamoleConfiguration getAuthorizedConfiguration(String username, String password) throws GuacamoleException;
import net.sourceforge.guacamole.net.basic.properties.BasicGuacamoleProperties;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
import net.sourceforge.guacamole.properties.GuacamoleProperties;
        // Get user mapping file
        return GuacamoleProperties.getProperty(BasicGuacamoleProperties.BASIC_USER_MAPPING);
    public GuacamoleConfiguration getAuthorizedConfiguration(String username, String password) throws GuacamoleException {
        private GuacamoleConfiguration config;
            config = new GuacamoleConfiguration();
        public GuacamoleConfiguration getConfiguration() {
import net.sourceforge.guacamole.net.InetGuacamoleSocket;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
import net.sourceforge.guacamole.properties.GuacamoleProperties;
import net.sourceforge.guacamole.net.GuacamoleSocket;
import net.sourceforge.guacamole.servlet.GuacamoleSession;
import net.sourceforge.guacamole.net.GuacamoleTunnel;
import net.sourceforge.guacamole.net.basic.properties.BasicGuacamoleProperties;
import net.sourceforge.guacamole.protocol.ConfiguredGuacamoleSocket;
import net.sourceforge.guacamole.servlet.GuacamoleTunnelServlet;
            authProvider = GuacamoleProperties.getProperty(BasicGuacamoleProperties.AUTH_PROVIDER);
        GuacamoleConfiguration config = authProvider.getAuthorizedConfiguration(username, password);
        // Configure and connect socket
        String hostname = GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_HOSTNAME);
        int port = GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_PORT);
        GuacamoleSocket socket = new ConfiguredGuacamoleSocket(
                new InetGuacamoleSocket(hostname, port),
                config
        );
        // Associate socket with tunnel
        GuacamoleTunnel tunnel = new GuacamoleTunnel(socket);
/**
 * Provides abstract and raw character read access to a stream of Guacamole
 * instructions.
 *
 * @author Michael Jumper
 */
    /**
     * Reads at least one complete Guacamole instruction, returning a buffer
     * containing one or more complete Guacamole instructions and no
     * incomplete Guacamole instructions. This function will block until at
     * least one complete instruction is available.
     *
     * @return A buffer containing at least one complete Guacamole instruction,
     *         or null if no more instructions are available for reading.
     * @throws GuacamoleException If an error occurs while reading from the
     *                            stream.
     */

    /**
     * Reads exactly one complete Guacamole instruction and returns the fully
     * parsed instruction.
     *
     * @return The next complete instruction from the stream, fully parsed, or
     *         null if no more instructions are available for reading.
     * @throws GuacamoleException If an error occurs while reading from the
     *                            stream, or if the instruction cannot be
     *                            parsed.
     */
/**
 * Provides abstract and raw character write access to a stream of Guacamole
 * instructions.
 *
 * @author Michael Jumper
 */
    /**
     * Writes a portion of the given array of characters to the Guacamole
     * instruction stream. The portion must contain only complete Guacamole
     * instructions.
     *
     * @param chunk An array of characters containing Guacamole instructions.
     * @param off The start offset of the portion of the array to write.
     * @param len The length of the portion of the array to write.
     * @throws GuacamoleException If an error occurred while writing the
     *                            portion of the array specified.
     */

    /**
     * Writes the entire given array of characters to the Guacamole instruction
     * stream. The array must consist only of complete Guacamole instructions.
     *
     * @param chunk An array of characters consisting only of complete
     *              Guacamole instructions.
     * @throws GuacamoleException If an error occurred while writing the
     *                            the specified array.
     */

    /**
     * Writes the given fully parsed instruction to the Guacamole instruction
     * stream.
     *
     * @param instruction The Guacamole instruction to write.
     * @throws GuacamoleException If an error occurred while writing the
     *                            instruction.
     */
/**
 * A GuacamoleReader which wraps a standard Java Reader, using that Reader as
 * the Guacamole instruction stream.
 *
 * @author Michael Jumper
 */
    /**
     * Creates a new ReaderGuacamoleReader which will use the given Reader as
     * the Guacamole instruction stream.
     *
     * @param input The Reader to use as the Guacamole instruction stream.
     */
/**
 * A GuacamoleWriter which wraps a standard Java Writer, using that Writer as
 * the Guacamole instruction stream.
 *
 * @author Michael Jumper
 */
    /**
     * Creates a new WriterGuacamoleWriter which will use the given Writer as
     * the Guacamole instruction stream.
     *
     * @param output The Writer to use as the Guacamole instruction stream.
     */
/**
 * Provides abstract socket-like access to a Guacamole connection.
 *
 * @author Michael Jumper
 */
    /**
     * Returns a GuacamoleReader which can be used to read from the
     * Guacamole instruction stream associated with the connection
     * represented by this GuacamoleSocket.
     *
     * @return A GuacamoleReader which can be used to read from the
     *         Guacamole instruction stream.
     */

    /**
     * Returns a GuacamoleWriter which can be used to write to the
     * Guacamole instruction stream associated with the connection
     * represented by this GuacamoleSocket.
     *
     * @return A GuacamoleWriter which can be used to write to the
     *         Guacamole instruction stream.
     */
    /**
     * Releases all resources in use by the connection represented by this
     * GuacamoleSocket.
     *
     * @throws GuacamoleException If an error occurs while releasing resources.
     */
/**
 * Provides a unique identifier and synchronized access to the GuacamoleReader
 * and GuacamoleWriter associated with a GuacamoleSocket.
 *
 * @author Michael Jumper
 */
    /**
     * Creates a new GuacamoleTunnel which synchronizes access to the
     * Guacamole instruction stream associated with the given GuacamoleSocket.
     *
     * @param socket The GuacamoleSocket to provide synchronized access for.
     */
    public GuacamoleTunnel(GuacamoleSocket socket) {
    /**
     * Acquires exclusive read access to the Guacamole instruction stream
     * and returns a GuacamoleReader for reading from that stream.
     *
     * @return A GuacamoleReader for reading from the Guacamole instruction
     *         stream.
     */
    /**
     * Relinquishes exclusive read access to the Guacamole instruction
     * stream. This function should be called whenever a thread finishes using
     * a GuacamoleTunnel's GuacamoleReader.
     */
    /**
     * Returns whether there are threads waiting for read access to the
     * Guacamole instruction stream.
     *
     * @return true if threads are waiting for read access the Guacamole
     *         instruction stream, false otherwise.
     */
    /**
     * Acquires exclusive write access to the Guacamole instruction stream
     * and returns a GuacamoleWriter for writing to that stream.
     *
     * @return A GuacamoleWriter for writing to the Guacamole instruction
     *         stream.
     */
    /**
     * Relinquishes exclusive write access to the Guacamole instruction
     * stream. This function should be called whenever a thread finishes using
     * a GuacamoleTunnel's GuacamoleWriter.
     */
    /**
     * Returns whether there are threads waiting for write access to the
     * Guacamole instruction stream.
     *
     * @return true if threads are waiting for write access the Guacamole
     *         instruction stream, false otherwise.
     */
    /**
     * Returns the unique identifier associated with this GuacamoleTunnel.
     *
     * @return The unique identifier associated with this GuacamoleTunnel.
     */
/**
 * Provides abstract socket-like access to a Guacamole connection over a given
 * hostname and port.
 *
 * @author Michael Jumper
 */
    /**
     * Creates a new InetGuacamoleSocket which reads and writes instructions
     * to the Guacamole instruction stream of the Guacamole proxy server
     * running at the given hostname and port.
     *
     * @param hostname The hostname of the Guacamole proxy server to connect to.
     * @param port The port of the Guacamole proxy server to connect to.
     * @throws GuacamoleException If an error occurs while connecting to the
     *                            Guacamole proxy server.
     */
/**
 * A GuacamoleProperty whose value is a filename.
 *
 * @author Michael Jumper
 */
/**
 * Simple utility class for reading properties from the guacamole.properties
 * file in the root of the classpath.
 *
 * @author Michael Jumper
 */
    /**
     * The hostname of the server where guacd (the Guacamole proxy server) is
     * running.
     */
    /**
     * The port that guacd (the Guacamole proxy server) is listening on.
     */
    /**
     * Given a GuacamoleProperty, parses and returns the value set for that
     * property in guacamole.properties, if any.
     *
     * @param <Type> The type that the given property is parsed into.
     * @param property The property to read from guacamole.properties.
     * @return The parsed value of the property as read from
     *         guacamole.properties.
     * @throws GuacamoleException If an error occurs while parsing the value
     *                            for the given property in
     *                            guacamole.properties.
     */
/**
 * An abstract representation of a property in the guacamole.properties file,
 * which parses into a specific type.
 *
 * @author Michael Jumper
 * @param <Type> The type this GuacamoleProperty will parse into.
 */
    /**
     * Returns the name of the property in guacamole.properties that this
     * GuacamoleProperty will parse.
     *
     * @return The name of the property in guacamole.properties that this
     *         GuacamoleProperty will parse.
     */
    /**
     * Parses the given string value into the type associated with this
     * GuacamoleProperty.
     *
     * @param value The string value to parse.
     * @return The parsed value.
     * @throws GuacamoleException If an error occurs while parsing the
     *                            provided value.
     */
/**
 * A GuacamoleProperty whose value is an integer.
 *
 * @author Michael Jumper
 */
/**
 * A GuacamoleProperty whose value is a simple string.
 *
 * @author Michael Jumper
 */
/**
 * A GuacamoleSocket which pre-configures the connection based on a given
 * GuacamoleConfiguration, completing the initial protocol handshake before
 * accepting data for read or write.
 *
 * This is useful for forcing a connection to the Guacamole proxy server with
 * a specific configuration while disallowing the client that will be using
 * this GuacamoleSocket from manually controlling the initial protocol
 * handshake.
 *
 * @author Michael Jumper
 */
    /**
     * Creates a new ConfiguredGuacamoleSocket which uses the given
     * GuacamoleConfiguration to complete the initial protocol handshake over
     * the given GuacamoleSocket.
     *
     * @param socket The GuacamoleSocket to wrap.
     * @param config The GuacamoleConfiguration to use to complete the initial
     *               protocol handshake.
     * @throws GuacamoleException If an error occurs while completing the
     *                            initial protocol handshake.
     */
/**
 * All information necessary to complete the initial protocol handshake of a
 * Guacamole session.
 *
 * @author Michael Jumper
 */
    /**
     * Returns the name of the protocol to be used.
     * @return The name of the protocol to be used.
     */
    /**
     * Sets the name of the protocol to be used.
     * @param protocol The name of the protocol to be used.
     */
    /**
     * Returns the value set for the parameter with the given name, if any.
     * @param name The name of the parameter to return the value for.
     * @return The value of the parameter with the given name, or null if
     *         that parameter has not been set.
     */
    /**
     * Sets the value for the parameter with the given name.
     *
     * @param name The name of the parameter to set the value for.
     * @param value The value to set for the parameter with the given name.
     */
/**
 * An abstract representation of a Guacamole instruction, as defined by the
 * Guacamole protocol.
 *
 * @author Michael Jumper
 */
    /**
     * The operation performed by a particular Guacamole instruction. Each
     * Operation is associated with a unique opcode.
     */
        /**
         * Message sent from client to server specifying which protocol is
         * to be used.
         */

        /**
         * Message sent from client to server specifying which argument
         * values correspond to the arguments required by the selected
         * protocol.
         */
        /**
         * Message sent from server to client specifying which arguments
         * are required by the selected protocol.
         */
        private Operation(String opcode) {
            this.opcode = opcode;
        }
        /**
         * Returns the unique opcode associated with this Operation.
         * @return The unique opcode associated with this Operation.
         */
        /**
         * Static hash of all opcodes and their corresponding Operations.
         */
        /**
         * Returns the corresponding Operation having the given opcode, if any.
         *
         * @param opcode The unique opcode associated with an Operation.
         * @return The Operation associated with the given opcode, or null if
         *         no such Operation is defined.
         */
    /**
     * Creates a new GuacamoleInstruction having the given Operation and
     * list of arguments values.
     *
     * @param operation The Operation of the instruction to create.
     * @param args The list of argument values to provide in the new
     *             instruction if any.
     */
    /**
     * Returns the Operation associated with this GuacamoleInstruction.
     * @return The Operation associated with this GuacamoleInstruction.
     */
    /**
     * Returns an array of all argument values specified for this
     * GuacamoleInstruction.
     *
     * @return An array of all argument values specified for this
     *         GuacamoleInstruction.
     */
    /**
     * Returns this GuacamoleInstruction in the form it would be sent over the
     * Guacamole protocol.
     *
     * @return This GuacamoleInstruction in the form it would be sent over the
     *         Guacamole protocol.
     */
/**
 * Provides abstract access to the tunnels associated with a Guacamole session.
 *
 * @author Michael Jumper
 */
    /**
     * Creates a new GuacamoleSession, storing and retrieving tunnels from the
     * given HttpSession. Note that the true Guacamole session is tied to the
     * HttpSession provided, thus creating a new GuacamoleSession does not
     * create a new Guacamole session; it merely creates a new object for
     * accessing the tunnels of an existing Guacamole session represented by
     * the provided HttpSession.
     *
     * @param session The HttpSession to use as tunnel storage.
     * @throws GuacamoleException If session is null.
     */
    /**
     * Attaches the given tunnel to this GuacamoleSession.
     * @param tunnel The tunnel to attach to this GucacamoleSession.
     */
    public void attachTunnel(GuacamoleTunnel tunnel) {
    /**
     * Detaches the given tunnel to this GuacamoleSession.
     * @param tunnel The tunnel to detach to this GucacamoleSession.
     */
    public void detachTunnel(GuacamoleTunnel tunnel) {
    /**
     * Returns the tunnel with the given UUID attached to this GuacamoleSession,
     * if any.
     *
     * @param tunnelUUID The UUID of an attached tunnel.
     * @return The tunnel corresponding to the given UUID, if attached, or null
     *         if no such tunnel is attached.
     */
/**
 * A HttpServlet implementing and abstracting the operations required by the
 * JavaScript Guacamole client's tunnel.
 *
 * @author Michael Jumper
 */
    /**
     * Called whenever the JavaScript Guacamole client makes a connection
     * request. It it up to the implementor of this function to define what
     * conditions must be met for a tunnel to be configured and returned as a
     * result of this connection request (whether some sort of credentials must
     * be specified, for example).
     *
     * @param request The HttpServletRequest associated with the connection
     *                request received. Any parameters specified along with
     *                the connection request can be read from this object.
     * @return A newly constructed GuacamoleTunnel if successful,
     *         null otherwise.
     * @throws GuacamoleException If an error occurs while constructing the
     *                            GuacamoleTunnel, or if the conditions
     *                            required for connection are not met.
     */
    /**
     * Called whenever the JavaScript Guacamole client makes a read request.
     * This function should in general not be overridden, as it already
     * contains a proper implementation of the read operation.
     *
     * @param request The HttpServletRequest associated with the read request
     *                received.
     * @param response The HttpServletResponse associated with the write request
     *                 received. Any data to be sent to the client in response
     *                 to the write request should be written to the response
     *                 body of this HttpServletResponse.
     * @param tunnelUUID The UUID of the tunnel to read from, as specified in
     *                   the write request. This tunnel must be attached to
     *                   the Guacamole session.
     * @throws GuacamoleException If an error occurs while handling the read
     *                            request.
     */
    /**
     * Called whenever the JavaScript Guacamole client makes a write request.
     * This function should in general not be overridden, as it already
     * contains a proper implementation of the write operation.
     *
     * @param request The HttpServletRequest associated with the write request
     *                received. Any data to be written will be specified within
     *                the body of this request.
     * @param response The HttpServletResponse associated with the write request
     *                 received.
     * @param tunnelUUID The UUID of the tunnel to write to, as specified in
     *                   the write request. This tunnel must be attached to
     *                   the Guacamole session.
     * @throws GuacamoleException If an error occurs while handling the write
     *                            request.
     */
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.protocol.GuacamoleInstruction;

import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.protocol.GuacamoleInstruction;

import java.io.IOException;
import java.io.Reader;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.protocol.GuacamoleInstruction;
import net.sourceforge.guacamole.protocol.GuacamoleInstruction.Operation;

        // If data was previously read via readInstruction(), return remaining
        // data instead of reading more.
        if (instructionBuffer != null) {
            
            char[] chunk = new char[instructionBuffer.length - instructionStart];
            System.arraycopy(instructionBuffer, instructionStart, chunk, 0, chunk.length); 
            instructionBuffer = null;
            
            return chunk;
        }
        
import java.io.IOException;
import java.io.Writer;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.protocol.GuacamoleInstruction;

import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.io.GuacamoleReader;
import net.sourceforge.guacamole.io.GuacamoleWriter;

import net.sourceforge.guacamole.GuacamoleException;

import net.sourceforge.guacamole.io.GuacamoleReader;
import net.sourceforge.guacamole.io.GuacamoleWriter;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.GuacamoleSocket;
import net.sourceforge.guacamole.protocol.GuacamoleInstruction.Operation;

import java.util.HashMap;

import java.util.HashMap;

        handleTunnelRequest(request, response);
        handleTunnelRequest(request, response);
    /**
     * Dispatches every HTTP GET and POST request to the appropriate handler
     * function based on the query string.
     *
     * @param request The HttpServletRequest associated with the GET or POST
     *                request received.
     * @param response The HttpServletResponse associated with the GET or POST
     *                 request received.
     * @throws ServletException If an error occurs while servicing the request.
     */
    protected void handleTunnelRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException {
    @SuppressWarnings("unchecked")
            // Detach tunnel and throw error if EOF (and we haven't sent any
            // data yet.
            char[] message = reader.read();
            if (message == null) {
                session.detachTunnel(tunnel);
                throw new GuacamoleException("Disconnected.");
            }

            do {
            } while ((message = reader.read()) != null);
import net.sourceforge.guacamole.GuacamoleException;
    /**
     * Release all resources allocated to this GuacamoleTunnel.
     * 
     * @throws GuacamoleException if an error occurs while releasing
     *                            resources.
     */
    public void close() throws GuacamoleException {
        socket.close();
    }

            if (message == null)
        catch (GuacamoleException e) {

            // Detach and close
            session.detachTunnel(tunnel);
            tunnel.close();

            throw e;
        }

            // Detach and close
            session.detachTunnel(tunnel);
            tunnel.close();


            // Detach and close
            session.detachTunnel(tunnel);
            tunnel.close();
                

            // Detach and close
            session.detachTunnel(tunnel);
            tunnel.close();

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private Logger logger = LoggerFactory.getLogger(BasicGuacamoleTunnelServlet.class);
    
        if (config == null) {
            logger.warn("Failed login from {} for user \"{}\".", request.getRemoteAddr(), username);
        }

        logger.debug("Successful login from {} for user \"{}\".", request.getRemoteAddr(), username);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private Logger logger = LoggerFactory.getLogger(InetGuacamoleSocket.class);
    
            logger.debug("Connecting to guacd at {}:{}.", hostname, port);
            
            logger.debug("Closing socket to guacd.");
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private Logger logger = LoggerFactory.getLogger(GuacamoleSession.class);
    
        logger.debug("Attached tunnel {}.", tunnel.getUUID());
        logger.debug("Detached tunnel {}.", tunnel.getUUID());
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private Logger logger = LoggerFactory.getLogger(GuacamoleTunnelServlet.class);
    

                    logger.info("Connection from {} succeeded.", request.getRemoteAddr());
                
                    
                else
                    logger.info("Connection from {} failed.", request.getRemoteAddr());
            // Close tunnel immediately upon EOF
            if (message == null)
                tunnel.close();
            
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private Logger logger = LoggerFactory.getLogger(BasicFileAuthenticationProvider.class);
    
        logger.info("Reading user mapping file: {}", mapFile);
        
                if (userMappingFile.exists() && mappingTime < userMappingFile.lastModified()) {
                    logger.info("User mapping file {} has been modified.", userMappingFile);
                }
            logger.error("Error getting authentication provider from properties.", e);
        GuacamoleConfiguration config;
        try {
            config = authProvider.getAuthorizedConfiguration(username, password);
        }
        catch (GuacamoleException e) {
            logger.error("Error retrieving authorized configuration for user {}.", username);
            throw e;
        }
        
        logger.info("Successful login from {} for user \"{}\".", request.getRemoteAddr(), username);
        // If no mapping available, report as such
        if (mapping == null)
            throw new GuacamoleException("User mapping could not be read.");
        
        // Validate and return info for given user and pass
import java.util.Map;
import javax.servlet.http.HttpServletResponse;
        // Get ID of connection
        String id = request.getParameter("id");
        
        // Get authorized configs
        Map<String, GuacamoleConfiguration> configs =
                (Map<String, GuacamoleConfiguration>)
                httpSession.getAttribute("GUAC_AUTH_CONFIGS");

        // If no configs in session, not authorized
        if (configs == null)
            throw new GuacamoleException("No authorized configurations.");
        GuacamoleConfiguration config = configs.get(id);
        if (config == null) {
            logger.error("Error retrieving authorized configuration id={}.", id);
            throw new GuacamoleException("Unknown configuration ID.");
        logger.info("Successful connection from {} to \"{}\".", request.getRemoteAddr(), id);
import java.util.HashMap;
import java.util.Map;
        // Build map of authorized configs
        Map<String, GuacamoleConfiguration> configs = new HashMap<String, GuacamoleConfiguration>();
        configs.put("TEST-UID", config);
        
        httpSession.setAttribute("GUAC_AUTH_CONFIGS", configs);
import net.sourceforge.guacamole.net.auth.AuthenticationProvider;
import net.sourceforge.guacamole.net.auth.UserConfiguration;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
    public UserConfiguration getUserConfiguration(String username, String password) throws GuacamoleException {
            return info.getUserConfiguration();
        protected static final String CONFIG_ID = "DEFAULT";

        private BasicUserConfiguration userConfig;
            userConfig = new BasicUserConfiguration();
            userConfig.setConfiguration(CONFIG_ID, new GuacamoleConfiguration());

        public BasicUserConfiguration getUserConfiguration() {
            return userConfig;
                    current.getUserConfiguration().getConfiguration(AuthInfo.CONFIG_ID)
                            .setProtocol(str);
                    current.getUserConfiguration().getConfiguration(AuthInfo.CONFIG_ID)
                            .setParameter(currentParameter, str);
import net.sourceforge.guacamole.net.auth.AuthenticationProvider;
import net.sourceforge.guacamole.net.auth.UserConfiguration;
        UserConfiguration userConfig = (UserConfiguration) 
                httpSession.getAttribute("GUAC_USER_CONFIG");
        if (userConfig == null)
        GuacamoleConfiguration config = userConfig.getConfiguration(id);
import net.sourceforge.guacamole.net.auth.UserConfiguration;
import net.sourceforge.guacamole.net.auth.AuthenticationProvider;
        // Get authorized configs
        UserConfiguration config;
            config = authProvider.getUserConfiguration(username, password);
            logger.error("Error retrieving configuration for user {}.", username);
        // Associate configs with session
        httpSession.setAttribute("GUAC_USER_CONFIG", config);
import net.sourceforge.guacamole.net.auth.UserConfiguration;
        // Get user configuration
        UserConfiguration userConfig = (UserConfiguration)
                httpSession.getAttribute("GUAC_USER_CONFIG");
        // If no userConfig in session, not authorized
        if (userConfig == null) {
        for (String id : userConfig.listConfigurations()) {
            GuacamoleConfiguration config = userConfig.getConfiguration(id);
            out.print(id);
import net.sourceforge.guacamole.net.auth.AuthenticationProvider;
public interface AuthenticationProvider<CredentialType> {
    public UserConfiguration getUserConfiguration(CredentialType credentials) throws GuacamoleException;
import net.sourceforge.guacamole.net.auth.UsernamePassword;
public class BasicFileAuthenticationProvider implements AuthenticationProvider<UsernamePassword> {
    public UserConfiguration getUserConfiguration(UsernamePassword credentials) throws GuacamoleException {
        AuthInfo info = mapping.get(credentials.getUsername());
        if (info != null && info.validate(credentials.getUsername(), credentials.getPassword()))
import net.sourceforge.guacamole.net.auth.UsernamePassword;
        UsernamePassword credentials = new UsernamePassword();
        credentials.setUsername(username);
        credentials.setPassword(password);
        
            config = authProvider.getUserConfiguration(credentials);
    public Map<String, GuacamoleConfiguration> getAuthorizedConfigurations(UsernamePassword credentials) throws GuacamoleException {
        Map<String, GuacamoleConfiguration> configs = new HashMap<String, GuacamoleConfiguration>();
        
                configs.put("DEFAULT", info.getConfiguration());
        return configs;
        private GuacamoleConfiguration config;
            config = new GuacamoleConfiguration();
        public GuacamoleConfiguration getConfiguration() {
            return config;
                    current.getConfiguration()
                    current.getConfiguration()
import java.util.Map;
        Map<String, GuacamoleConfiguration> configs = (Map<String, GuacamoleConfiguration>) 
                httpSession.getAttribute("GUAC_CONFIGS");
        if (configs == null)
        GuacamoleConfiguration config = configs.get(id);
import java.util.Map;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
        Map<String, GuacamoleConfiguration> configs;
            configs = authProvider.getAuthorizedConfigurations(credentials);
            logger.error("Error retrieving configuration(s) for user {}.", username);
        if (configs == null) {
        httpSession.setAttribute("GUAC_CONFIGS", configs);
import java.util.Map;
        // Get authorized configs
        Map<String, GuacamoleConfiguration> configs = (Map<String, GuacamoleConfiguration>) 
                httpSession.getAttribute("GUAC_CONFIGS");
        // If no configs in session, not authorized
        if (configs == null) {
        for (Entry<String, GuacamoleConfiguration> entry : configs.entrySet()) {
            GuacamoleConfiguration config = entry.getValue();
            out.print(entry.getKey());
            configs.put("DEFAULT", info.getConfiguration());
        // If EOF, return EOF
        if (instructionBuffer == null)
            return null;

    /**
     * Given a GuacamoleProperty, parses and returns the value set for that
     * property in guacamole.properties. An exception is thrown if the value
     * is not provided.
     *
     * @param <Type> The type that the given property is parsed into.
     * @param property The property to read from guacamole.properties.
     * @return The parsed value of the property as read from
     *         guacamole.properties.
     * @throws GuacamoleException If an error occurs while parsing the value
     *                            for the given property in
     *                            guacamole.properties, or if the property is
     *                            not specified.
     */
    public static <Type> Type getRequiredProperty(GuacamoleProperty<Type> property)
            throws GuacamoleException {

        Type value = getProperty(property);
        if (value == null)
            throw new GuacamoleException("Property "  property.getName()  " is required.");

        return value;
        
    }
import net.sourceforge.guacamole.net.basic.GuacamoleClassLoader;
            Object obj = GuacamoleClassLoader.getInstance().loadClass(authProviderClassName)
                            .getConstructor().newInstance();

    public static final FileGuacamoleProperty LIB_DIRECTORY = new FileGuacamoleProperty() {

        @Override
        public String getName() { return "lib-directory"; }

    };

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import org.apache.commons.lang3.ArrayUtils;
        
        // Build list of elements
        LinkedList<String> elements = new LinkedList<String>();
        while (instructionStart < instructionBuffer.length) {
            // Find end of length 
            int lengthEnd = ArrayUtils.indexOf(instructionBuffer, '.', instructionStart);
            // Parse length
            int length = Integer.parseInt(new String(
                    instructionBuffer,
                    instructionStart,
                    lengthEnd - instructionStart
            ));
            // Parse element from just after period
            instructionStart = lengthEnd  1;
            String element = new String(
                    instructionBuffer,
                    instructionStart,
                    length
            );
            // Append element to list of elements
            elements.addLast(element);
            
            // Read terminator after element
            instructionStart = length;
            char terminator = instructionBuffer[instructionStart];
            // Continue reading instructions after terminator
            instructionStart;
           
            // If we've reached the end of the instruction
            if (terminator == ';')
        // Pull opcode off elements list
        String opcode = elements.removeFirst();
        
                elements.toArray(new String[elements.size()])
        // Detect end of buffer
        // Return parsed instruction
            out.write("0.;");
        buff.append(operation.getOpcode().length());
        buff.append('.');
            buff.append(',');
            buff.append(args[i].length());
            buff.append('.');
                        response.getWriter().print(tunnel.getUUID().toString());
/**
 * \example ExampleTunnelServlet.java
 *
 * A basic example demonstrating extending GuacamoleTunnelServlet and
 * implementing doConnect() to configure the Guacamole connection as
 * desired.
 */

/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
    private int parseStart;
    private char[] buffer = new char[20480];
    private int usedLength = 0;
                // Length of element
                int elementLength = 0;
                
                // Resume where we left off
                int i = parseStart;

                // Parse instruction in buffer
                while (i < usedLength) {

                    // Read character
                    char readChar = buffer[i];

                    // If digit, update length
                    if (readChar >= '0' && readChar <= '9')
                        elementLength = elementLength * 10  readChar - '0';

                    // If not digit, check for end-of-length character
                    else if (readChar == '.') {

                        // Check if element present in buffer
                        if (i  elementLength < usedLength) {

                            // Get terminator
                            char terminator = buffer[i  elementLength];
                            
                            // Move to character after terminator
                            i = elementLength  1;

                            // Reset length
                            elementLength = 0;

                            // Continue here if necessary
                            parseStart = i;

                            // If terminator is semicolon, we have a full
                            // instruction.
                            if (terminator == ';') {

                                // Copy instruction data
                                char[] instruction = new char[i];
                                System.arraycopy(buffer, 0, instruction, 0, i);

                                // Update buffer
                                usedLength -= i;
                                parseStart = 0;
                                System.arraycopy(buffer, i, buffer, 0, usedLength);

                                return instruction;
                                
                            }

                            // Handle invalid terminator characters
                            else if (terminator != ',')
                                throw new GuacamoleException("Element terminator of instruction was not ';' nor ','");
                            
                        }

                        // Otherwise, read more data
                        else
                            break;
                        
                    }

                    // Otherwise, parse error
                    else
                        throw new GuacamoleException("Non-numeric character in element length.");

                }

                // Update used length
        // Get instruction
        char[] instructionBuffer = read();
        
        // Start of element
        int elementStart = 0;
        
        while (elementStart < instructionBuffer.length) {
            int lengthEnd = ArrayUtils.indexOf(instructionBuffer, '.', elementStart);
                    elementStart,
                    lengthEnd - elementStart
            elementStart = lengthEnd  1;
                    elementStart,
            elementStart = length;
            char terminator = instructionBuffer[elementStart];
            elementStart;
     * Returns whether instruction data is available for reading. Note that
     * this does not guarantee an entire instruction is available. If a full
     * instruction is not available, this function can return true, and a call
     * to read() will still block.
     * 
     * @return true if instruction data is available for reading, false
     *         otherwise.
     * @throws GuacamoleException If an error occurs while checking for
     *                            available data.
     */
    public boolean available() throws GuacamoleException;
    
    /**
    public boolean available() throws GuacamoleException {
        try {
            return input.ready() || usedLength != 0;
        }
        catch (IOException e) {
            throw new GuacamoleException(e);
        }
    }

    @Override

                // Flush if we expect to wait
                if (!reader.available()) {
                    out.flush();
                    response.flushBuffer();
                }
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.Reader;
import org.xml.sax.InputSource;
            // Set up parser
            // Read and parse file
            Reader reader = new BufferedReader(new FileReader(mapFile));
            parser.parse(new InputSource(reader));
            reader.close();

            // Init mapping and record mod time of file
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/servlet/GuacamoleHTTPTunnelServlet.java
 * HTTP implementation of the JavaScript Guacamole client's tunnel.
public abstract class GuacamoleHTTPTunnelServlet extends HttpServlet {
    private Logger logger = LoggerFactory.getLogger(GuacamoleHTTPTunnelServlet.class);
import net.sourceforge.guacamole.servlet.GuacamoleHTTPTunnelServlet;
public class BasicGuacamoleTunnelServlet extends GuacamoleHTTPTunnelServlet {
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * Provides means of retrieving a set of named GuacamoleConfigurations for a
 * given arbitrary credentials object.
 * 
 * @author Michael Jumper
 * @param <CredentialType> The type to use as credentials for determining which
 *                         configurations are authorized.
 */
    /**
     * Given an arbitrary credentials object, returns a Map containing all
     * configurations authorized by those credentials. The keys of this Map
     * are Strings which uniquely identify each configuration.
     * 
     * @param credentials The credentials to use to retrieve authorized
     *                    configurations.
     * @return A Map of all configurations authorized by the given credentials.
     * @throws GuacamoleException If an error occurs while retrieving
     *                            configurations, or the credentials given
     *                            are invalid.
     */
    public Map<String, GuacamoleConfiguration>
            getAuthorizedConfigurations(CredentialType credentials)
            throws GuacamoleException;
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * Simple class containing username and password Strings. This class can be
 * used along with AuthenticationProvider to provide username/password
 * authentication.
 * 
 * @author Michael Jumper
 */
    /**
     * An arbitrary username.
     */

    /**
     * An arbitrary password.
     */
    /**
     * Returns the password associated with this username/password pair.
     * @return The password associated with this username/password pair, or
     *         null if no password has been set.
     */
    /**
     * Sets the password associated with this username/password pair.
     * @param password The password to associate with this username/password
     *                 pair.
     */
    /**
     * Returns the username associated with this username/password pair.
     * @return The username associated with this username/password pair, or
     *         null if no username has been set.
     */
    /**
     * Sets the username associated with this username/password pair.
     * @param username The username to associate with this username/password
     *                 pair.
     */
import net.sourceforge.guacamole.servlet.GuacamoleHTTPTunnelServlet;
public class ExampleTunnelServlet extends GuacamoleHTTPTunnelServlet {
    /**
     * Wrapped Reader to be used for all input.
     */
    /**
     * Wrapped Writer to be used for all output.
     */
 * The Original Code is guacamole-common-auth.
 * The Original Code is guacamole-common-auth.
import net.sourceforge.guacamole.properties.FileGuacamoleProperty;
/**
 * Authenticates users against a static list of username/password pairs.
 * Each username/password may be associated with exactly one configuration.
 * This list is stored in an XML file which is reread if modified.
 * 
 * @author Michael Jumper
 */
    /**
     * The filename of the XML file to read the user mapping from.
     */
    public static final FileGuacamoleProperty BASIC_USER_MAPPING = new FileGuacamoleProperty() {

        @Override
        public String getName() { return "basic-user-mapping"; }

    };

        return GuacamoleProperties.getProperty(BASIC_USER_MAPPING);
/**
 * Connects users to a tunnel associated with the authorized configuration
 * having the given ID.
 * 
 * @author Michael Jumper
 */
/**
 * Retrieves the authorized configurations associated with a given
 * username/password pair using the authentication provider defined in
 * guacamole.properties.
 * 
 * All authorized configurations will be stored in the current HttpSession.
 * 
 * Success and failure are logged.
 * 
 * @author Michael Jumper
 */
/**
 * Logs out the current user by invalidating the associated HttpSession and
 * redirecting the user to the login page.
 * 
 * @author Michael Jumper
 */
/**
 * Simple HttpServlet which outputs XML containing a list of all authorized
 * configurations for the current user.
 * 
 * @author Michael Jumper
 */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * A ClassLoader implementation which finds classes within a configurable
 * directory. This directory is set within guacamole.properties.
 * 
 * @author Michael Jumper
    /**
     * Returns an instance of a GuacamoleClassLoader which finds classes
     * within the directory configured in guacamole.properties.
     * 
     * @return An instance of a GuacamoleClassLoader.
     * @throws GuacamoleException If no instance could be returned due to an
     *                            error.
     */
/**
 * A GuacamoleProperty whose value is the name of a class to use to
 * authenticate users. This class must implement AuthenticationProvider.
 * 
 * @author Michael Jumper
 */
import net.sourceforge.guacamole.properties.FileGuacamoleProperty;

/**
 * Properties used by the default Guacamole web application.
 * 
 * @author Michael Jumper
 */
    /**
     * This class should not be instantiated.
     */
    /**
     * The authentication provider to user when retrieving the authorized
     * configurations of a user.
     */
    /**
     * The directory to search for authentication provider classes.
     */
            throw new GuacamoleException("Cannot connect - user not logged in.");
        // having a null value is acceptable. If value is null, no error thrown.
        if(value != null)
            return new File(value);
        else
            return null;
import net.sourceforge.guacamole.servlet.GuacamoleHTTPTunnelServlet;
public class ExampleTunnelServlet extends GuacamoleHTTPTunnelServlet {
    /**
     * Wrapped Reader to be used for all input.
     */
    /**
     * Wrapped Writer to be used for all output.
     */
        catch (NullPointerException e) {
            // On error, record exception
            e.printStackTrace(System.err);
        }
        
        // If no classloader, use default loader
            return Class.forName(name);
import net.sourceforge.guacamole.properties.FileGuacamoleProperty;
/**
 * Authenticates users against a static list of username/password pairs.
 * Each username/password may be associated with exactly one configuration.
 * This list is stored in an XML file which is reread if modified.
 * 
 * @author Michael Jumper
 */
    /**
     * The filename of the XML file to read the user mapping from.
     */
    public static final FileGuacamoleProperty BASIC_USER_MAPPING = new FileGuacamoleProperty() {

        @Override
        public String getName() { return "basic-user-mapping"; }

    };

        return GuacamoleProperties.getProperty(BASIC_USER_MAPPING);
/**
 * Connects users to a tunnel associated with the authorized configuration
 * having the given ID.
 * 
 * @author Michael Jumper
 */
            throw new GuacamoleException("Cannot connect - user not logged in.");
/**
 * Retrieves the authorized configurations associated with a given
 * username/password pair using the authentication provider defined in
 * guacamole.properties.
 * 
 * All authorized configurations will be stored in the current HttpSession.
 * 
 * Success and failure are logged.
 * 
 * @author Michael Jumper
 */
/**
 * Logs out the current user by invalidating the associated HttpSession and
 * redirecting the user to the login page.
 * 
 * @author Michael Jumper
 */
/**
 * Simple HttpServlet which outputs XML containing a list of all authorized
 * configurations for the current user.
 * 
 * @author Michael Jumper
 */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is guacamole-common.
 *
 * The Initial Developer of the Original Code is
 * Michael Jumper.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * A ClassLoader implementation which finds classes within a configurable
 * directory. This directory is set within guacamole.properties.
 * 
 * @author Michael Jumper
    /**
     * Returns an instance of a GuacamoleClassLoader which finds classes
     * within the directory configured in guacamole.properties.
     * 
     * @return An instance of a GuacamoleClassLoader.
     * @throws GuacamoleException If no instance could be returned due to an
     *                            error.
     */
/**
 * A GuacamoleProperty whose value is the name of a class to use to
 * authenticate users. This class must implement AuthenticationProvider.
 * 
 * @author Michael Jumper
 */
import net.sourceforge.guacamole.properties.FileGuacamoleProperty;

/**
 * Properties used by the default Guacamole web application.
 * 
 * @author Michael Jumper
 */
    /**
     * This class should not be instantiated.
     */
    /**
     * The authentication provider to user when retrieving the authorized
     * configurations of a user.
     */
    /**
     * The directory to search for authentication provider classes.
     */
        
        // If no property provided, return null.
        if (value == null)

        return new File(value);


        // If no property provided, return null.
        if (value == null)
            return null;

        // If no property provided, return null.
        if (authProviderClassName == null)
            return null;

            authProvider = GuacamoleProperties.getRequiredProperty(BasicGuacamoleProperties.AUTH_PROVIDER);
        if (info != null && info.validate(credentials.getUsername(), credentials.getPassword())) {
            return configs;
        }
        // Unauthorized
        return null;
            Map<String, GuacamoleConfiguration> configs = new HashMap<String, GuacamoleConfiguration>();
     * @return A Map of all configurations authorized by the given credentials,
     *         or null if the credentials given are not authorized.
     *                            configurations.
        // Do not cache
        response.setHeader("Cache-Control", "no-cache");
        
        // Do not cache
        response.setHeader("Cache-Control", "no-cache");
        
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 * Simple ServletContextListener which loads a WebSocket tunnel implementation
 * if available, using the Servlet 3.0 API to dynamically load and install
 * the tunnel servlet.
 * 
 * Note that because Guacamole depends on the Servlet 2.5 API, and 3.0 may
 * not be available or needed if WebSocket is not desired, the 3.0 API is
 * detected and invoked dynamically via reflection.
    private Logger logger = LoggerFactory.getLogger(WebSocketSupportLoader.class);

                "net.sourceforge.guacamole.net.basic.BasicGuacamoleWebSocketTunnelServlet"
                logger.info("WebSocket support found and loaded.");

            // Servlet API 3.0 unsupported
                logger.error("Servlet API 3.0 not found.", e);
                logger.error("Servlet API 3.0 found, but incomplete.", e);

            // Servlet API 3.0 found, but errors during use
                logger.error("Unable to load WebSocket tunnel servlet.", e);
                logger.error("Internal error loading WebSocket tunnel servlet.", e);
        // If no such servlet class, WebSocket support not present
        catch (ClassNotFoundException e) {
            logger.info("WebSocket support not found.");

        // Log all GuacamoleExceptions
            logger.error("Unable to load/detect WebSocket support.", e);
import java.io.Serializable;
public class GuacamoleConfiguration implements Serializable {
    private static final long serialVersionUID = 1L;
    
 * given Credentials object.
public interface AuthenticationProvider {
            getAuthorizedConfigurations(Credentials credentials)
 b/guacamole-ext/src/main/java/net/sourceforge/guacamole/net/auth/Credentials.java
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

public class Credentials {
     * The HttpServletRequest carrying additional credentials, if any.
     */
    private HttpServletRequest request;

    /**
     * The HttpSession carrying additional credentials, if any.
     */
    private HttpSession session;
    
    /**
    public HttpServletRequest getRequest() {
        return request;
    }

    public void setRequest(HttpServletRequest request) {
        this.request = request;
    }

    public HttpSession getSession() {
        return session;
    }

    public void setSession(HttpSession session) {
        this.session = session;
    }

import net.sourceforge.guacamole.net.auth.Credentials;
public class BasicFileAuthenticationProvider implements AuthenticationProvider {
    public Map<String, GuacamoleConfiguration> getAuthorizedConfigurations(Credentials credentials) throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.Credentials;
        // Build credentials object
        Credentials credentials = new Credentials ();
        credentials.setSession(httpSession);
        credentials.setRequest(request);
                logger.warn("Authentication attempt from {} for user \"{}\" failed.",
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
public class BasicGuacamoleTunnelServlet extends AuthenticatingHttpServlet {
   
    protected void authenticatedService(
            Map<String, GuacamoleConfiguration> configs,
            HttpServletRequest request, HttpServletResponse response)
    throws IOException, ServletException {
        // If authenticated, respond as tunnel
        tunnelServlet.service(request, response);
    /**
     * Wrapped GuacamoleHTTPTunnelServlet which will handle all authenticated
     * requests.
     */
    private GuacamoleHTTPTunnelServlet tunnelServlet = new GuacamoleHTTPTunnelServlet() {

        @Override
        protected GuacamoleTunnel doConnect(HttpServletRequest request) throws GuacamoleException {

            HttpSession httpSession = request.getSession(true);

            // Get ID of connection
            String id = request.getParameter("id");
            
            // Get authorized configs
            Map<String, GuacamoleConfiguration> configs = (Map<String, GuacamoleConfiguration>) 
                    httpSession.getAttribute("GUAC_CONFIGS");

            // If no configs in session, not authorized
            if (configs == null)
                throw new GuacamoleException("Cannot connect - user not logged in.");

            // Get authorized config
            GuacamoleConfiguration config = configs.get(id);
            if (config == null) {
                logger.error("Error retrieving authorized configuration id={}.", id);
                throw new GuacamoleException("Unknown configuration ID.");
            }
            
            logger.info("Successful connection from {} to \"{}\".", request.getRemoteAddr(), id);

            // Configure and connect socket
            String hostname = GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_HOSTNAME);
            int port = GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_PORT);

            GuacamoleSocket socket = new ConfiguredGuacamoleSocket(
                    new InetGuacamoleSocket(hostname, port),
                    config
            );

            // Associate socket with tunnel
            GuacamoleTunnel tunnel = new GuacamoleTunnel(socket);

            // Attach tunnel to session
            GuacamoleSession session = new GuacamoleSession(httpSession);
            session.attachTunnel(tunnel);

            return tunnel;

        }

    };

 * Simple dummy AuthenticatingHttpServlet which provides an endpoint for arbitrary
 * authentication requests that do not expect a response.
public class BasicLogin extends AuthenticatingHttpServlet {
    protected void authenticatedService(
            Map<String, GuacamoleConfiguration> configs,
            HttpServletRequest request, HttpServletResponse response)
        logger.info("Login was successful.");
public class ConfigurationList extends AuthenticatingHttpServlet {
    protected void authenticatedService(
            Map<String, GuacamoleConfiguration> configs,
            HttpServletRequest request, HttpServletResponse response)
 * The Original Code is guacamole-auth.
 * The Original Code is guacamole-auth.
 * Simple arbitrary set of credentials, including a username/password pair,
 * the HttpServletRequest associated with the request for authorization
 * (if any) and the HttpSession associated with that request.
 * 
 * This class is used along with AuthenticationProvider to provide arbitrary
 * HTTP-based authentication for Guacamole.
     * Returns the password associated with this set of credentials.
     * Sets the password associated with this set of credentials.
     * Returns the username associated with this set of credentials.
     * Sets the username associated with this set of credentials.
    /**
     * Returns the HttpServletRequest associated with this set of credentials.
     * @return The HttpServletRequest associated with this set of credentials,
     *         or null if no such request exists.
     */
    /**
     * Sets the HttpServletRequest associated with this set of credentials.
     * @param request  The HttpServletRequest to associated with this set of
     *                 credentials.
     */
    /**
     * Returns the HttpSession associated with this set of credentials.
     * @return The HttpSession associated with this set of credentials, or null
     *         if no such request exists.
     */
    /**
     * Sets the HttpSession associated with this set of credentials.
     * @param session The HttpSession to associated with this set of
     *                credentials.
     */
    private static final String AUTH_ERROR_MESSAGE = 
            "User not logged in or authentication failed.";
    

                response.setHeader("X-Guacamole-Error-Message", AUTH_ERROR_MESSAGE);
                
                response.setHeader("X-Guacamole-Error-Message", AUTH_ERROR_MESSAGE);
 * A listener whose authenticationFailed() hook will fire immediately
 * after a user's authentication attempt fails. Note that this hook cannot
 * be used to cancel the authentication failure.
    public void authenticationFailed(AuthenticationFailureEvent e);
import net.sourceforge.guacamole.GuacamoleException;
     * @throws GuacamoleException If an error occurs while handling the
     *                            authentication failure event. Note that
     *                            throwing an exception will NOT cause the
     *                            authentication failure to be canceled.
    public void authenticationFailed(AuthenticationFailureEvent e)
            throws GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
     * @throws GuacamoleException If an error occurs while handling the
     *                            authentication success event. Throwing an
     *                            exception will also cancel the authentication
     *                            success.
    public boolean authenticationSucceeded(AuthenticationSuccessEvent e)
            throws GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
     * @throws GuacamoleException If an error occurs while handling the
     *                            tunnel attach event. Throwing an exception
     *                            will also stop the tunnel from being attached.
    public boolean tunnelAttached(TunnelAttachEvent e)
            throws GuacamoleException;
import net.sourceforge.guacamole.GuacamoleException;
     * @throws GuacamoleException If an error occurs while handling the
     *                            tunnel detach event. Throwing an exception
     *                            will also stop the tunnel from being detached.
    public boolean tunnelDetached(TunnelDetachEvent e)
            throws GuacamoleException;
import java.util.Collection;
import net.sourceforge.guacamole.net.basic.event.SessionListenerCollection;
import net.sourceforge.guacamole.net.event.AuthenticationFailureEvent;
import net.sourceforge.guacamole.net.event.AuthenticationSuccessEvent;
import net.sourceforge.guacamole.net.event.listener.AuthenticationFailureListener;
import net.sourceforge.guacamole.net.event.listener.AuthenticationSuccessListener;
    /**
     * The error message to be provided to the client user if authentication
     * fails for ANY REASON.
     */
    /**
     * The AuthenticationProvider to use to authenticate all requests.
     */
    /**
     * Notifies all listeners in the given collection that authentication has
     * failed.
     * 
     * @param listeners A collection of all listeners that should be notified.
     * @param credentials The credentials associated with the authentication
     *                    request that failed.
     */
    private void notifyFailed(Collection listeners, Credentials credentials) {
        
        // Build event for auth failure
        AuthenticationFailureEvent event = new AuthenticationFailureEvent(credentials);
        
        // Notify all listeners
        for (Object listener : listeners) {
            try {
                if (listener instanceof AuthenticationFailureListener)
                    ((AuthenticationFailureListener) listener).authenticationFailed(event);
            }
            catch (GuacamoleException e) {
                logger.error("Error notifying AuthenticationFailureListener.", e);
            }
        }
        
    }

    /**
     * Notifies all listeners in the given collection that authentication was
     * successful.
     * 
     * @param listeners A collection of all listeners that should be notified.
     * @param credentials The credentials associated with the authentication
     *                    request that succeeded.
     * @return true if all listeners are allowing the authentication success,
     *         or if there are no listeners, and false if any listener is
     *         canceling the authentication success. Note that once one
     *         listener cancels, no other listeners will run.
     * @throws GuacamoleException If any listener throws an error while being
     *                            notified. Note that if any listener throws an
     *                            error, the success is canceled, and no other
     *                            listeners will run.
     */
    private boolean notifySuccess(Collection listeners, Credentials credentials)
            throws GuacamoleException {
        
        // Build event for auth success
        AuthenticationSuccessEvent event = new AuthenticationSuccessEvent(credentials);
        
        // Notify all listeners
        for (Object listener : listeners) {
            if (listener instanceof AuthenticationSuccessListener) {

                // Cancel immediately if hook returns false
                if (!((AuthenticationSuccessListener) listener).authenticationSucceeded(event))
                    return false;
                
            }
        }

        return true;
        
    }
  
    /**
     * Sends a predefined, generic error message to the user, along with a
     * "403 - Forbidden" HTTP status code in the response.
     * 
     * @param response The response to send the error within.
     * @throws IOException If an error occurs while sending the error.
     */
    private void failAuthentication(HttpServletResponse response) throws IOException {
        response.setHeader("X-Guacamole-Error-Message", AUTH_ERROR_MESSAGE);
        response.sendError(HttpServletResponse.SC_FORBIDDEN);
    }
    
            SessionListenerCollection listeners;
            try {
                listeners = new SessionListenerCollection(httpSession);
            }
            catch (GuacamoleException e) {
                logger.error("Failed to retrieve listeners. Authentication canceled.", e);
                failAuthentication(response);
                return;
            }
            

            /******** HANDLE FAILED AUTHENTICATION ********/
            
            // If error retrieving configs, fail authentication, notify listeners
            catch (GuacamoleException e) {
                logger.error("Error retrieving configuration(s) for user \"{}\".", username);

                notifyFailed(listeners, credentials);
                failAuthentication(response);
            // If no configs, fail authentication, notify listeners
                notifyFailed(listeners, credentials);
                failAuthentication(response);

            /******** HANDLE SUCCESSFUL AUTHENTICATION ********/
            
            try {

                // Otherwise, authentication has been succesful
                logger.info("User \"{}\" successfully authenticated from {}.",
                        username, request.getRemoteAddr());

                // Notify of success, cancel if requested
                if (!notifySuccess(listeners, credentials)) {
                    logger.info("Successful authentication canceled by hook.");
                    failAuthentication(response);
                    return;
                }
                
            }
            catch (GuacamoleException e) {
                
                // Cancel authentication success if hook throws exception
                logger.error("Successful authentication canceled by error in hook.");
                failAuthentication(response);
                return;
                
            }

    /**
     * Creates a new TunnelAttachEvent which represents the attaching of the
     * given tunnel via a request associated with the given credentials.
     * 
     * @param credentials The credentials associated with the request
     *                    attaching the tunnel.
     * @param tunnel The tunnel being attached.
     */
    public TunnelAttachEvent(Credentials credentials, GuacamoleTunnel tunnel) {
        this.credentials = credentials;
        this.tunnel = tunnel;
    }

    /**
     * Creates a new TunnelDetachEvent which represents the detaching of the
     * given tunnel via a request associated with the given credentials.
     * 
     * @param credentials The credentials associated with the request
     *                    detaching the tunnel.
     * @param tunnel The tunnel being detached.
     */
    public TunnelDetachEvent(Credentials credentials, GuacamoleTunnel tunnel) {
        this.credentials = credentials;
        this.tunnel = tunnel;
    }

    /**
     * Returns the credentials associated with the given session.
     * 
     * @param session The session to retrieve credentials from.
     * @return The credentials associated with the given session.
     */
    protected Credentials getCredentials(HttpSession session) {
        return (Credentials) session.getAttribute("GUAC_CREDS");
    }

    /**
     * Returns the configurations associated with the given session.
     * 
     * @param session The session to retrieve configurations from.
     * @return The configurations associated with the given session.
     */
    protected Map<String, GuacamoleConfiguration> getConfigurations(HttpSession session) {
        return (Map<String, GuacamoleConfiguration>) session.getAttribute("GUAC_CONFIGS");
    }
    
        Map<String, GuacamoleConfiguration> configs = getConfigurations(httpSession);
            Credentials credentials = new Credentials();

                logger.error("Error retrieving configuration(s) for user \"{}\".",
                        credentials.getUsername());
                        request.getRemoteAddr(), credentials.getUsername());
                        credentials.getUsername(), request.getRemoteAddr());
            // Associate configs and credentials with session
            httpSession.setAttribute("GUAC_CREDS",   credentials);
     * The session attribute holding the map of configurations.
     */
    private static final String CONFIGURATIONS_ATTRIBUTE = "GUAC_CONFIGS";
    
    /**
     * The session attribute holding the credentials authorizing this session.
     */
    private static final String CREDENTIALS_ATTRIBUTE = "GUAC_CREDS";
    
    /**
        return (Credentials) session.getAttribute(CREDENTIALS_ATTRIBUTE);
        return (Map<String, GuacamoleConfiguration>) session.getAttribute(CONFIGURATIONS_ATTRIBUTE);
            httpSession.setAttribute(CONFIGURATIONS_ATTRIBUTE, configs);
            httpSession.setAttribute(CREDENTIALS_ATTRIBUTE,    credentials);
import net.sourceforge.guacamole.net.event.TunnelConnectEvent;
     * @param e The TunnelConnectEvent describing the tunnel being attached and
    public boolean tunnelAttached(TunnelConnectEvent e)
import net.sourceforge.guacamole.net.event.TunnelCloseEvent;
     * @param e The TunnelCloseEvent describing the tunnel being detached and
    public boolean tunnelDetached(TunnelCloseEvent e)
import net.sourceforge.guacamole.net.auth.Credentials;

            // Get credentials
            Credentials credentials = getCredentials(httpSession);
            
            Map<String, GuacamoleConfiguration> configs = getConfigurations(httpSession);
            // If no configs/credentials in session, not authorized
            if (credentials == null || configs == null)
import java.util.Collection;
import net.sourceforge.guacamole.net.basic.event.SessionListenerCollection;
import net.sourceforge.guacamole.net.event.TunnelCloseEvent;
import net.sourceforge.guacamole.net.event.TunnelConnectEvent;
import net.sourceforge.guacamole.net.event.listener.TunnelCloseListener;
import net.sourceforge.guacamole.net.event.listener.TunnelConnectListener;
     * Notifies all listeners in the given collection that a tunnel has been
     * connected.
     * 
     * @param listeners A collection of all listeners that should be notified.
     * @param credentials The credentials associated with the authentication
     *                    request that connected the tunnel.
     * @return true if all listeners are allowing the tunnel to connect,
     *         or if there are no listeners, and false if any listener is
     *         canceling the connection. Note that once one listener cancels,
     *         no other listeners will run.
     * @throws GuacamoleException If any listener throws an error while being
     *                            notified. Note that if any listener throws an
     *                            error, the connect is canceled, and no other
     *                            listeners will run.
     */
    private boolean notifyConnect(Collection listeners,
            Credentials credentials, GuacamoleTunnel tunnel)
            throws GuacamoleException {
        
        // Build event for auth success
        TunnelConnectEvent event = new TunnelConnectEvent(credentials, tunnel);
        
        // Notify all listeners
        for (Object listener : listeners) {
            if (listener instanceof TunnelConnectListener) {

                // Cancel immediately if hook returns false
                if (!((TunnelConnectListener) listener).tunnelConnected(event))
                    return false;
                
            }
        }

        return true;
        
    }

    /**
     * Notifies all listeners in the given collection that a tunnel has been
     * closed.
     * 
     * @param listeners A collection of all listeners that should be notified.
     * @param credentials The credentials associated with the authentication
     *                    request that closed the tunnel.
     * @return true if all listeners are allowing the tunnel to close,
     *         or if there are no listeners, and false if any listener is
     *         canceling the close. Note that once one listener cancels,
     *         no other listeners will run.
     * @throws GuacamoleException If any listener throws an error while being
     *                            notified. Note that if any listener throws an
     *                            error, the close is canceled, and no other
     *                            listeners will run.
     */
    private boolean notifyClose(Collection listeners,
            Credentials credentials, GuacamoleTunnel tunnel)
            throws GuacamoleException {
        
        // Build event for auth success
        TunnelCloseEvent event = new TunnelCloseEvent(credentials, tunnel);
        
        // Notify all listeners
        for (Object listener : listeners) {
            if (listener instanceof TunnelCloseListener) {

                // Cancel immediately if hook returns false
                if (!((TunnelCloseListener) listener).tunnelClosed(event))
                    return false;
                
            }
        }

        return true;
        
    }

    /**
            
            // Get listeners
            final SessionListenerCollection listeners;
            try {
                listeners = new SessionListenerCollection(httpSession);
            }
            catch (GuacamoleException e) {
                logger.error("Failed to retrieve listeners. Authentication canceled.", e);
                throw e;
            }
            final Credentials credentials = getCredentials(httpSession);
            GuacamoleTunnel tunnel = new GuacamoleTunnel(socket) {
                @Override
                public void close() throws GuacamoleException {

                    // Only close if not canceled
                    if (!notifyClose(listeners, credentials, this))
                        throw new GuacamoleException("Tunnel close canceled by listener.");
                    
                    // Close if no exception due to listener
                    super.close();
                    
                }
                
            };

            // Notify listeners about connection
            if (!notifyConnect(listeners, credentials, tunnel)) {
                logger.info("Connection canceled by listener.");
                return null;
            }
            
    private static final String SESSION_ATTRIBUTE = "GUAC_LISTENERS";
                    // Get session
                    HttpSession httpSession = request.getSession(true);
                    GuacamoleSession session = new GuacamoleSession(httpSession);

                    // Attach tunnel to session
                    session.attachTunnel(tunnel);

import net.sourceforge.guacamole.net.basic.properties.BasicGuacamoleProperties;
import net.sourceforge.guacamole.properties.GuacamoleProperties;
                // Get all listener classes from properties
                Collection<Class> listenerClasses =
                        GuacamoleProperties.getProperty(BasicGuacamoleProperties.EVENT_LISTENERS);
                // Add an instance of each class to the list
                if (listenerClasses != null) {
                    for (Class listenerClass : listenerClasses) {
                        // Instantiate listener
                        Object listener = listenerClass.getConstructor().newInstance();
                        // Add listener to collection of listeners
                        listeners.add(listener);

                    }
                }

    /**
     * The comma-separated list of all classes to use as event listeners.
     */
    public static final EventListenersProperty EVENT_LISTENERS = new EventListenersProperty() {

        @Override
        public String getName() { return "event-listeners"; }

    };

 b/guacamole-common/src/main/java/net/sourceforge/guacamole/GuacamoleClientException.java
 * an error in the client's request. Such an error, if correctable, usually
 * requires correction on the client side, not the server.
public class GuacamoleClientException extends GuacamoleException {
    public GuacamoleClientException(String message, Throwable cause) {
    public GuacamoleClientException(String message) {
    public GuacamoleClientException(Throwable cause) {
public class GuacamoleResourceNotFoundException extends GuacamoleClientException {
public class GuacamoleSecurityException extends GuacamoleClientException {
 b/guacamole-common/src/main/java/net/sourceforge/guacamole/GuacamoleServerException.java
public class GuacamoleServerException extends GuacamoleException {
    public GuacamoleServerException(String message, Throwable cause) {
    public GuacamoleServerException(String message) {
    public GuacamoleServerException(Throwable cause) {
import net.sourceforge.guacamole.GuacamoleServerException;
            throw new GuacamoleServerException(e);
                                throw new GuacamoleServerException("Element terminator of instruction was not ';' nor ','");
                        throw new GuacamoleServerException("Non-numeric character in element length.");
            throw new GuacamoleServerException(e);
import net.sourceforge.guacamole.GuacamoleServerException;
            throw new GuacamoleServerException(e);
import net.sourceforge.guacamole.GuacamoleServerException;
            throw new GuacamoleServerException(e);
            throw new GuacamoleServerException(e);
import net.sourceforge.guacamole.GuacamoleServerException;
            exception = new GuacamoleServerException("Error reading guacamole.properties", e);
            throw new GuacamoleServerException("Property "  property.getName()  " is required.");
import net.sourceforge.guacamole.GuacamoleServerException;
            throw new GuacamoleServerException("Property \""  getName()  "\" must be an integer.", e);
import net.sourceforge.guacamole.*;
    private void sendError(HttpServletResponse response, int code) throws ServletException {

        try {

            // If response not committed, send error code
            if (!response.isCommitted())
                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);

        }
        catch (IOException ioe) {

            // If unable to send error at all due to I/O problems,
            // rethrow as servlet exception
            throw new ServletException(ioe);

        }

    }


    
                throw new GuacamoleClientException("No query string provided.");
                        // Send UUID to client
                        throw new GuacamoleServerException(e);

                // Failed to connect
                else {
                    try {
                        // Send error to client
                        response.sendError(HttpServletResponse.SC_NOT_FOUND);
                    }
                    catch (IOException e) {
                        throw new GuacamoleServerException(e);
                    }
                }

                throw new GuacamoleClientException("Invalid tunnel operation: "  query);
        // HTTP response, logging each error appropriately.
        catch (GuacamoleSecurityException e) {
            logger.warn("Authorization failed.", e);
            sendError(response, HttpServletResponse.SC_UNAUTHORIZED);
        }
        catch (GuacamoleResourceNotFoundException e) {
            logger.debug("Resource not found.", e);
            sendError(response, HttpServletResponse.SC_NOT_FOUND);
        }
        catch (GuacamoleClientException e) {
            logger.warn("Error in client request.", e);
            sendError(response, HttpServletResponse.SC_BAD_REQUEST);
        }
            logger.error("Server error in tunnel", e);
            sendError(response, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            throw new GuacamoleResourceNotFoundException("No such tunnel.");
                throw new GuacamoleResourceNotFoundException("Tunnel reached end of stream.");
            throw new GuacamoleServerException("I/O error writing to servlet output stream.", e);
            throw new GuacamoleResourceNotFoundException("No such tunnel.");
            throw new GuacamoleServerException("I/O Error sending data to server: "  e.getMessage(), e);
import net.sourceforge.guacamole.GuacamoleSecurityException;
            throw new GuacamoleSecurityException("User has no session.");
    /**
     * Sends an error on the given HTTP response with the given integer error
     * code.
     * 
     * @param response The HTTP response to use to send the error.
     * @param code The HTTP status code of the error.
     * @throws ServletException If an error prevents sending of the error
     *                          code.
     */
                    throw new GuacamoleResourceNotFoundException("No tunnel created.");
                response.sendError(code);
                logger.error("Configuration id={} not found.", id);
                return null;
import net.sourceforge.guacamole.GuacamoleSecurityException;
                throw new GuacamoleSecurityException("Requested configuration is not authorized.");
            sendError(response, HttpServletResponse.SC_FORBIDDEN);
            // Find end of length
            int lengthEnd = -1;
            for (int i=elementStart; i<instructionBuffer.length; i) {
                if (instructionBuffer[i] == '.') {
                    lengthEnd = i;
                    break;
                }
            }

            // read() is required to return a complete instruction. If it does
            // not, this is a severe internal error.
            if (lengthEnd == -1)
                throw new GuacamoleServerException("Read returned incomplete instruction.");
    /**
     * Returns whether this GuacamoleSocket is open and can be used for reading
     * and writing.
     * 
     * @return true if this GuacamoleSocket is open, false otherwise.
     */
    public boolean isOpen();

    private boolean open = true;

     * Returns the GuacamoleSocket used by this GuacamoleTunnel for reading
     * and writing.
     * 
     * @return The GuacamoleSocket used by this GuacamoleTunnel.
     */
    public GuacamoleSocket getSocket() {
        return socket;
    }

    /**
    /**
     * Returns whether this GuacamoleTunnel is open, or has been closed.
     * 
     * @return true if this GuacamoleTunnel is open, false if it is closed.
     */
    public boolean isOpen() {
        return socket.isOpen();
    }
    
    @Override
    public boolean isOpen() {
        return !sock.isClosed();
    }
    
    @Override
    public boolean isOpen() {
        return socket.isOpen();
    }

        // Get tunnel, ensure tunnel exists
        // Ensure tunnel is open
        if (!tunnel.isOpen())
            throw new GuacamoleResourceNotFoundException("Tunnel is closed.");
        
            } while (tunnel.isOpen() && (message = reader.read()) != null);
            while (tunnel.isOpen() && 
                    (length = input.read(buffer, 0, buffer.length)) != -1)
                throw new GuacamoleSecurityException("Cannot connect - user not logged in.");
                logger.warn("Configuration id={} not found.", id);
                logger.info("Servlet API 3.0 not found.", e);
                logger.warn("Servlet API 3.0 found, but incomplete.", e);
                        credentials.getUsername(), e);
                logger.error("Successful authentication canceled by error in hook.", e);
            // Load properties, always close stream
            try { properties.load(stream); }
            finally { stream.close(); }
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
            instance = AccessController.doPrivileged(new PrivilegedExceptionAction<GuacamoleClassLoader>() {

                @Override
                public GuacamoleClassLoader run() throws GuacamoleException {
                    return new GuacamoleClassLoader(
                        GuacamoleProperties.getProperty(BasicGuacamoleProperties.LIB_DIRECTORY)
                    );
                }

            });
        catch (PrivilegedActionException e) {
            exception = (GuacamoleException) e.getException();
import java.io.Serializable;
public class Credentials implements Serializable {

    private static final long serialVersionUID = 1L;
    private transient HttpServletRequest request;
    private transient HttpSession session;
    private GuacamoleConfiguration config;
    public ConfiguredGuacamoleSocket(GuacamoleSocket socket,
            GuacamoleConfiguration config) throws GuacamoleException {
    /**
     * Returns the GuacamoleConfiguration used to configure this
     * ConfiguredGuacamoleSocket.
     * 
     * @return The GuacamoleConfiguration used to configure this
     *         ConfiguredGuacamoleSocket.
     */
    public GuacamoleConfiguration getConfiguration() {
        return config;
    }

 * Each username/password may be associated with multiple configurations.
 * This is modified version of BasicFileAuthenticationProvider written by Michael Jumper.
 * 
 * @author Michal Kotas
            
            //Map<String, GuacamoleConfiguration> configs = new HashMap<String, GuacamoleConfiguration>();
            //configs.put("DEFAULT", info.getConfiguration());
            //return configs;
            
            Map<String, GuacamoleConfiguration> configs = info.getConfigurations();          
        private Map<String, GuacamoleConfiguration> configs;
            configs = new HashMap<String, GuacamoleConfiguration>();
        public GuacamoleConfiguration getConfiguration(String name) {
            //return configs;
            return configs.get(name);
        }
        public Map<String, GuacamoleConfiguration> getConfigurations() {
            return configs;
        }
        public void addConfiguration(String name) {
            configs.put(name, new GuacamoleConfiguration());
            REMOTE_SERVER,
        private String currentRemoteServer = null;
            case USER_MAPPING:
                if (localName.equals("user-mapping")) {
                    state = State.END;
                    return;
                }
                break;
            case AUTH_INFO:
                if (localName.equals("authorize")) {
                    // Finalize mapping for this user
                    authMapping.put(
                        current.auth_username,
                        current
                    );
                    state = State.USER_MAPPING;
                    return;
                }
                break;
                
            case REMOTE_SERVER:
                if (localName.equals("remote-server")) {
                    state = State.AUTH_INFO;
                    return;
                }
                break;                
            case PROTOCOL:
                if (localName.equals("protocol")) {
                    state = State.REMOTE_SERVER;
                    return;
                }
                break;
            case PARAMETER:
                if (localName.equals("param")) {
                    state = State.REMOTE_SERVER;
                    return;
                }

                break;

        }
                    if (localName.equals("remote-server")) {

                        currentRemoteServer = attributes.getValue("servername");
                        if (currentRemoteServer == null)
                            throw new SAXException("Attribute \"servername\" required for param tag.");
                        
                        current.addConfiguration(currentRemoteServer);
                        
                        // Next state
                        state = State.REMOTE_SERVER;
                        return;
                    }

                    break;
                    
                case REMOTE_SERVER:

                    break;                   
   
                    current.getConfiguration(currentRemoteServer)
                        .setProtocol(str);
                    current.getConfiguration(currentRemoteServer)
            CONNECTION,
        private String currentConnection = null;
            case CONNECTION:
                if (localName.equals("connection")) {
                    state = State.CONNECTION;
                    state = State.CONNECTION;
                    if (localName.equals("connection")) {
                        currentConnection = attributes.getValue("name");
                        if (currentConnection == null)
                            throw new SAXException("Attribute \"name\" required for param tag.");
                        current.addConfiguration(currentConnection);
                        state = State.CONNECTION;
                case CONNECTION:
                    current.getConfiguration(currentConnection)
                    current.getConfiguration(currentConnection)
                            throw new SAXException("Attribute \"name\" required for connection tag.");
                case USER_MAPPING:
                    if (localName.equals("user-mapping")) {
                        state = State.END;
                        return;
                    }
                    break;
                case AUTH_INFO:
                    if (localName.equals("authorize")) {
                        // Finalize mapping for this user
                        authMapping.put(
                            current.auth_username,
                            current
                        );
                        state = State.USER_MAPPING;
                        return;
                    }
                    break;
                    
                case CONNECTION:
                    if (localName.equals("connection")) {
                        state = State.AUTH_INFO;
                        return;
                    }
                    break;                
                case PROTOCOL:
                    if (localName.equals("protocol")) {
                        state = State.CONNECTION;
                        return;
                    }
                    break;
                case PARAMETER:
                    if (localName.equals("param")) {
                        state = State.CONNECTION;
                        return;
                    }
                    break;
            }
 * @author Michael Jumper, Michal Kotas
        if (info != null && info.validate(credentials.getUsername(), credentials.getPassword()))
            return info.getConfigurations();

            // Create new configuration if not already in map
            GuacamoleConfiguration config = configs.get(name);
            if (config == null) {
                config = new GuacamoleConfiguration();
                configs.put(name, config);
            }

            return config;



            /* Username/password pair */

            /* Connection configuration information */
            CONNECTION,

            /* Configuration information associated with default connection */
            DEFAULT_CONNECTION_PROTOCOL,
            DEFAULT_CONNECTION_PARAMETER,

                case DEFAULT_CONNECTION_PROTOCOL:

                    if (localName.equals("protocol")) {
                        state = State.AUTH_INFO;
                        return;
                    }

                    break;

                case DEFAULT_CONNECTION_PARAMETER:

                    if (localName.equals("param")) {
                        state = State.AUTH_INFO;
                        return;
                    }

                    break;

                    if (localName.equals("protocol")) {

                        // Associate protocol with default connection
                        currentConnection = "DEFAULT";
                        
                        // Next state
                        state = State.DEFAULT_CONNECTION_PROTOCOL;
                        return;
                    }

                    if (localName.equals("param")) {

                        // Associate parameter with default connection
                        currentConnection = "DEFAULT";
                        
                        currentParameter = attributes.getValue("name");
                        if (currentParameter == null)
                            throw new SAXException("Attribute \"name\" required for param tag.");

                        // Next state
                        state = State.DEFAULT_CONNECTION_PARAMETER;
                        return;
                    }

                case DEFAULT_CONNECTION_PROTOCOL:

                case DEFAULT_CONNECTION_PARAMETER:

            // Log typically frequent I/O error if desired
            logger.debug("Error writing to servlet output stream", e);
            
            reader = new ReaderGuacamoleReader(new InputStreamReader(sock.getInputStream(),   "UTF-8"));
            writer = new WriterGuacamoleWriter(new OutputStreamWriter(sock.getOutputStream(), "UTF-8"));
import java.io.*;
            Writer out = new BufferedWriter(new OutputStreamWriter(response.getOutputStream(), "UTF-8"));
            Reader input = new BufferedReader(new InputStreamReader(request.getInputStream(), "UTF-8"));
import net.sourceforge.guacamole.net.GuacamoleTunnel;
            Reader input = new InputStreamReader(request.getInputStream(), "UTF-8");
 *
 *
 *
 *



     *



     *





     *

     *
     *









 *




                    break;




                    break;


 *


     *




     *












 *

 *
 *


 *














     *



 *
 *
            );
 *

     *





 *
 *
 *

 *
     *
 *
 *

 *

     *


 *

     *


 *

     *
 *
     *
 *

     *
 *

     *
 *

     *

 *

     *
 *

     *
 *
     *
     *












     *
     *
     *
     *







     *


     *







            while (tunnel.isOpen() &&

    Credentials getCredentials();
    GuacamoleTunnel getTunnel();
    void authenticationFailed(AuthenticationFailureEvent e)
    boolean authenticationSucceeded(AuthenticationSuccessEvent e)
    boolean tunnelClosed(TunnelCloseEvent e)
    boolean tunnelConnected(TunnelConnectEvent e)
    Map<String, GuacamoleConfiguration>
    public void setPassword(final String password) {
    public void setUsername(final String username) {
    public void setRequest(final HttpServletRequest request) {
    public void setSession(final HttpSession session) {
    public AuthenticationFailureEvent(final Credentials credentials) {
    public AuthenticationSuccessEvent(final Credentials credentials) {
    public TunnelCloseEvent(final Credentials credentials,
            final GuacamoleTunnel tunnel) {

    public TunnelConnectEvent(final Credentials credentials,
            final GuacamoleTunnel tunnel) {

     * The credentials which failed authentication.
     * The credentials which passed authentication.
 * Provides classes for storing information about events that are
 * triggered when users log into and use the Guacamole web application.
 * These event classes are most useful when used with hooks implemented
 * using listener classes.
 *
 * @see net.sourceforge.guacamole.net.event.listener
    /**
     * The version number of this class, used during serialization.
     *
     * @see Serializable
     */
    public void setPassword(String password) {
    public void setUsername(String username) {
    public void setRequest(HttpServletRequest request) {
    public void setSession(HttpSession session) {
    public AuthenticationFailureEvent(Credentials credentials) {
    public AuthenticationSuccessEvent(Credentials credentials) {
    public TunnelCloseEvent(Credentials credentials, GuacamoleTunnel tunnel) {
    public TunnelConnectEvent(Credentials credentials, GuacamoleTunnel tunnel) {
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/AuthenticatingHttpServlet.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.basic.event.SessionListenerCollection;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.net.event.AuthenticationFailureEvent;
import org.glyptodon.guacamole.net.event.AuthenticationSuccessEvent;
import org.glyptodon.guacamole.net.event.listener.AuthenticationFailureListener;
import org.glyptodon.guacamole.net.event.listener.AuthenticationSuccessListener;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/BasicFileAuthenticationProvider.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.properties.FileGuacamoleProperty;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/BasicGuacamoleTunnelServlet.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.InetGuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.basic.event.SessionListenerCollection;
import org.glyptodon.guacamole.net.event.TunnelCloseEvent;
import org.glyptodon.guacamole.net.event.TunnelConnectEvent;
import org.glyptodon.guacamole.net.event.listener.TunnelCloseListener;
import org.glyptodon.guacamole.net.event.listener.TunnelConnectListener;
import org.glyptodon.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.glyptodon.guacamole.servlet.GuacamoleHTTPTunnelServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/BasicLogin.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/BasicLogout.java
package org.glyptodon.guacamole.net.basic;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/ConfigurationList.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/GuacamoleClassLoader.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/WebSocketSupportLoader.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
                "org.glyptodon.guacamole.net.basic.BasicGuacamoleWebSocketTunnelServlet"
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/event/SessionListenerCollection.java
package org.glyptodon.guacamole.net.basic.event;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/properties/AuthenticationProviderProperty.java
package org.glyptodon.guacamole.net.basic.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.basic.GuacamoleClassLoader;
import org.glyptodon.guacamole.properties.GuacamoleProperty;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/properties/BasicGuacamoleProperties.java
package org.glyptodon.guacamole.net.basic.properties;
import org.glyptodon.guacamole.properties.FileGuacamoleProperty;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/properties/EventListenersProperty.java
package org.glyptodon.guacamole.net.basic.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.GuacamoleClassLoader;
import org.glyptodon.guacamole.properties.GuacamoleProperty;
import org.glyptodon.guacamole.io.GuacamoleWriter;
import org.glyptodon.guacamole.net.GuacamoleResourcePipe;
import org.glyptodon.guacamole.net.InetGuacamoleSocket;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.protocol.GuacamoleInstruction;
        @Override
        protected void handleClientInstruction(GuacamoleTunnel tunnel,
            GuacamoleInstruction instruction, GuacamoleWriter writer)
            throws GuacamoleException {

            switch (instruction.getOperation()) {

                // Intercept reject
                case REJECT: {

                    // Get resource tunnel
                    GuacamoleResourcePipe resource = tunnel.getResourcePipe(
                            Integer.parseInt(instruction.getArgs()[0]));

                    // Detach resource
                    tunnel.detachResourcePipe(resource);
                    break;

                }

            }
            
            // Pass through all client-to-server instructions
            super.handleClientInstruction(tunnel, instruction, writer);
            
        }

        @Override
        protected void handleServerInstruction(GuacamoleTunnel tunnel,
            GuacamoleInstruction instruction, GuacamoleWriter writer)
            throws GuacamoleException {

            switch (instruction.getOperation()) {

                // Intercept resource instructions, handle on behalf of client.
                case RESOURCE: {

                    // Allocate resource
                    GuacamoleResourcePipe resource = new GuacamoleResourcePipe(
                            Integer.parseInt(instruction.getArgs()[0]));

                    // Attach resource
                    tunnel.attachResourcePipe(resource);

                    // Pass through to client
                    super.handleServerInstruction(tunnel, instruction, writer);
                    break;
                }

                // Intercept data instructions, appending received data to
                // allocated resources.
                case DATA: {

                    // Get resource tunnel
                    GuacamoleResourcePipe resource = tunnel.getResourcePipe(
                            Integer.parseInt(instruction.getArgs()[0]));

                    // Write data
                    resource.write(instruction.getArgs()[1]);
                    break;
                }

                // Intercept end instructions, closing associated resources.
                case END: {

                    // Get resource tunnel
                    GuacamoleResourcePipe resource = tunnel.getResourcePipe(
                            Integer.parseInt(instruction.getArgs()[0]));

                    // End of stream
                    resource.close();
                    break;
                }

                // Pass through all other instructions.
                default:
                    super.handleServerInstruction(tunnel, instruction, writer);
                
            }
            
        }

        String mimetype = request.getParameter("mimetype");
        // If mimetype provided, reflect back
        response.setContentType(mimetype);
        
import net.sourceforge.guacamole.GuacamoleServerException;
            
            // Read instruction, fail if end-of-stream
            if (instruction == null)
                throw new GuacamoleServerException("End of stream during initial handshake.");
            
    /**
     * The prefix of the query string which denotes a tunnel read operation.
     */
    private static final String READ_PREFIX  = "read:";

    /**
     * The prefix of the query string which denotes a tunnel write operation.
     */
    private static final String WRITE_PREFIX = "write:";

    /**
     * The length of the read prefix, in characters.
     */
    private static final int READ_PREFIX_LENGTH = READ_PREFIX.length();

    /**
     * The length of the write prefix, in characters.
     */
    private static final int WRITE_PREFIX_LENGTH = WRITE_PREFIX.length();

    /**
     * The length of every tunnel UUID, in characters.
     */
    private static final int UUID_LENGTH = 36;

            // If read operation, call doRead() with tunnel UUID, ignoring any
            // characters following the tunnel UUID.
            else if(query.startsWith(READ_PREFIX))
                doRead(request, response, query.substring(
                        READ_PREFIX_LENGTH,
                        READ_PREFIX_LENGTH  UUID_LENGTH));
            // If write operation, call doWrite() with tunnel UUID, ignoring any
            // characters following the tunnel UUID.
            else if(query.startsWith(WRITE_PREFIX))
                doWrite(request, response, query.substring(
                        WRITE_PREFIX_LENGTH,
                        WRITE_PREFIX_LENGTH  UUID_LENGTH));

        /**
         * Message sent from client to server specifying the optimal or
         * desired screen size.
         */
        CLIENT_SIZE("size"),

        /**
         * Message sent from client to server specifying which audio mimetypes
         * are supported.
         */
        CLIENT_AUDIO("audio"),

        /**
         * Message sent from client to server specifying which video mimetypes
         * are supported.
         */
        CLIENT_VIDEO("video"),

     * the given GuacamoleSocket. A default GuacamoleClientInformation object
     * is used to provide basic client information.
        this(socket, config, new GuacamoleClientInformation());
    }


    /**
     * Creates a new ConfiguredGuacamoleSocket which uses the given
     * GuacamoleConfiguration and GuacamoleClientInformation to complete the
     * initial protocol handshake over the given GuacamoleSocket.
     *
     * @param socket The GuacamoleSocket to wrap.
     * @param config The GuacamoleConfiguration to use to complete the initial
     *               protocol handshake.
     * @param info The GuacamoleClientInformation to use to complete the initial
     *             protocol handshake.
     * @throws GuacamoleException If an error occurs while completing the
     *                            initial protocol handshake.
     */
    public ConfiguredGuacamoleSocket(GuacamoleSocket socket,
            GuacamoleConfiguration config,
            GuacamoleClientInformation info) throws GuacamoleException {
        // Send size 
        writer.writeInstruction(
            new GuacamoleInstruction(
                Operation.CLIENT_SIZE,
                Integer.toString(info.getOptimalScreenWidth()),
                Integer.toString(info.getOptimalScreenHeight())
            )
        );

        // Send supported audio formats (STUB)
        writer.writeInstruction(new GuacamoleInstruction(Operation.CLIENT_AUDIO));

        // Send supported video formats (STUB)
        writer.writeInstruction(new GuacamoleInstruction(Operation.CLIENT_VIDEO));

import net.sourceforge.guacamole.net.InetGuacamoleSocket;
import net.sourceforge.guacamole.properties.GuacamoleProperties;
import net.sourceforge.guacamole.protocol.GuacamoleClientInformation;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
            // Get client information
            GuacamoleClientInformation info = new GuacamoleClientInformation();
           
            // Set width if provided
            String width  = request.getParameter("width");
            if (width != null)
                info.setOptimalScreenWidth(Integer.parseInt(width));

            // Set height if provided
            String height = request.getParameter("height");
            if (height != null)
                info.setOptimalScreenHeight(Integer.parseInt(height));
            
                    config, info
import java.util.ArrayList;
import java.util.List;
     * The list of audio mimetypes reported by the client to be supported.
    private List<String> audioMimetypes = new ArrayList<String>();
     * The list of audio mimetypes reported by the client to be supported.
    private List<String> videoMimetypes = new ArrayList<String>();
     * Returns the list of audio mimetypes supported by the client. To add or
     * removed supported mimetypes, the list returned by this function can be
    public List<String> getAudioMimetypes() {
     * Returns the list of video mimetypes supported by the client. To add or
     * removed supported mimetypes, the list returned by this function can be
    public List<String> getVideoMimetypes() {
import net.sourceforge.guacamole.io.GuacamoleReader;
import net.sourceforge.guacamole.io.GuacamoleWriter;
        // Send supported audio formats
        writer.writeInstruction(
                new GuacamoleInstruction(
                    Operation.CLIENT_AUDIO,
                    info.getAudioMimetypes().toArray(new String[0])
                ));
        // Send supported video formats
        writer.writeInstruction(
                new GuacamoleInstruction(
                    Operation.CLIENT_VIDEO,
                    info.getAudioMimetypes().toArray(new String[0])
                ));
import java.util.Arrays;
           
            // Add audio mimetypes
            String[] audio_mimetypes = request.getParameterValues("audio");
            if (audio_mimetypes != null)
                info.getAudioMimetypes().addAll(Arrays.asList(audio_mimetypes));
            // Add video mimetypes
            String[] video_mimetypes = request.getParameterValues("video");
            if (video_mimetypes != null)
                info.getVideoMimetypes().addAll(Arrays.asList(video_mimetypes));

                    info.getVideoMimetypes().toArray(new String[0])
/*
 *  Guacamole - Clientless Remote Desktop
 *  Copyright (C) 2010  Michael Jumper
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import net.sourceforge.guacamole.net.auth.AuthenticationProvider;
/*
 *  Guacamole - Clientless Remote Desktop
 *  Copyright (C) 2010  Michael Jumper
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 *  Guacamole - Clientless Remote Desktop
 *  Copyright (C) 2010  Michael Jumper
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

                        // Ensure buggy browsers do not cache response
                        response.setHeader("Cache-Control", "no-cache");
                        
            response.setHeader("Cache-Control", "no-cache");
        response.setHeader("Cache-Control", "no-cache");
import java.util.TreeMap;
            configs = new TreeMap<String, GuacamoleConfiguration>();

        // If no state, return null
        if (stack.isEmpty())
            return null;

        // If no handler returned, the element was not expected
        if (handler == null)
            throw new SAXException("Unexpected element: '"  localName  "'");
        
    private static class DocumentHandlerState {
import net.sourceforge.guacamole.net.basic.auth.Authorization;
import net.sourceforge.guacamole.net.basic.auth.UserMapping;
import net.sourceforge.guacamole.net.basic.xml.DocumentHandler;
import net.sourceforge.guacamole.net.basic.xml.user_mapping.UserMappingTagHandler;
    private UserMapping mapping;
            UserMappingTagHandler userMappingHandler =
                    new UserMappingTagHandler();
            
            DocumentHandler contentHandler = new DocumentHandler(
                    "user-mapping", userMappingHandler);
            mapping = userMappingHandler.asUserMapping();
        Authorization auth = mapping.getAuthorization(credentials.getUsername());
        if (auth != null && auth.validate(credentials.getUsername(), credentials.getPassword()))
            return auth.getConfigurations();
}
    /**
     * The time the user mapping file was last modified.
     */
    private long mod_time;
     * The parsed UserMapping read when the user mapping file was last parsed.
     */
    private UserMapping user_mapping;

    /**
     * The filename of the XML file to read the user user_mapping from.
    /**
     * Returns a UserMapping containing all authorization data given within
     * the XML file specified by the "basic-user-mapping" property in
     * guacamole.properties. If the XML file has been modified or has not yet
     * been read, this function may reread the file.
     * 
     * @return A UserMapping containing all authorization data within the
     *         user mapping XML file.
     * @throws GuacamoleException If the user mapping property is missing or
     *                            an error occurs while parsing the XML file.
     */
    private UserMapping getUserMapping() throws GuacamoleException {
        // Get user user_mapping file
        File user_mapping_file =
                GuacamoleProperties.getRequiredProperty(BASIC_USER_MAPPING);
        // If user_mapping not yet read, or user_mapping has been modified, reread
        if (user_mapping == null ||
                (user_mapping_file.exists()
                 && mod_time < user_mapping_file.lastModified())) {
            logger.info("Reading user mapping file: {}", user_mapping_file);
            // Parse document
            try {
                // Get handler for root element
                UserMappingTagHandler userMappingHandler =
                        new UserMappingTagHandler();
                
                // Set up document handler
                DocumentHandler contentHandler = new DocumentHandler(
                        "user-mapping", userMappingHandler);
                // Set up XML parser
                XMLReader parser = XMLReaderFactory.createXMLReader();
                parser.setContentHandler(contentHandler);
                // Read and parse file
                Reader reader = new BufferedReader(new FileReader(user_mapping_file));
                parser.parse(new InputSource(reader));
                reader.close();
                // Store mod time and user mapping
                mod_time = user_mapping_file.lastModified();
                user_mapping = userMappingHandler.asUserMapping();
            }
            catch (IOException e) {
                throw new GuacamoleException("Error reading basic user mapping file.", e);
            }
            catch (SAXException e) {
                throw new GuacamoleException("Error parsing basic user mapping XML.", e);
            }

        // Return (possibly cached) user mapping
        return user_mapping;
        Authorization auth = getUserMapping().getAuthorization(credentials.getUsername());
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;
        try {
            XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
            XMLStreamWriter xml = outputFactory.createXMLStreamWriter(response.getWriter());
            // Begin document
            xml.writeStartDocument();
            xml.writeStartElement("configs");
            
            // For each entry, write corresponding config element
            for (Entry<String, GuacamoleConfiguration> entry : configs.entrySet()) {

                // Get config
                GuacamoleConfiguration config = entry.getValue();

                // Write config
                xml.writeEmptyElement("config");
                xml.writeAttribute("id", entry.getKey());
                xml.writeAttribute("protocol", config.getProtocol());

            }

            // End document
            xml.writeEndElement();
            xml.writeEndDocument();
        catch (XMLStreamException e) {
            throw new IOException("Unable to write configuration list XML.", e);
        }
     * The name of the parameter
     */
    private String name;
    
    /**

        this.config = config;
        this.name = attributes.getValue("name");

        config.setParameter(name, textContent);
 * Provides means of accessing and managing the available
 * GuacamoleConfiguration objects and User objects. Access to each configuration
 * and each user is limited by a given Credentials object.
     * Given an arbitrary Credentials object, returns a Map containing all
     * GuacamoleConfigurations authorized by those credentials. The keys of
     * this Map are Strings which uniquely identify each configuration.
            getConfigurations(Credentials credentials)
    /**
     * Adds the given GuacamoleConfiguration to the overall set of available
     * GuacamoleConfigurations, using the given unique identifier and
     * credentials.
     * 
     * @param credentials The credentials to use when adding the given
     *                    configuration.
     * @param identifier The identifier to assign to the configuration.
     * @param config The configuration to add.
     * @throws GuacamoleException If an error occurs while adding the
     *                            configuration, or if adding the configuration
     *                            is not allowed.
     */
    void addConfiguration(Credentials credentials, String identifier,
            GuacamoleConfiguration config) throws GuacamoleException;
    
    /**
     * Updates the GuacamoleConfiguration having the given unique identifier
     * with the data contained in the given GuacamoleConfiguration, using the
     * given credentials.
     * 
     * @param credentials The credentials to use when updating the configuration
     *                    having the given identifier.
     * @param identifier The identifier to use when locating the configuration
     *                   to update.
     * @param config The configuration to use when updating the stored
     *               configuration.
     * @throws GuacamoleException If an error occurs while updating the
     *                            configuration, or if updating the
     *                            configuration is not allowed.
     */
    void updateConfiguration(Credentials credentials, String identifier,
            GuacamoleConfiguration config) throws GuacamoleException;
    
    /**
     * Removes the GuacamoleConfiguration having the given unique identifier,
     * using the given credentials.
     * 
     * @param credentials The credentials to use when removing the configuration
     *                    having the given identifier.
     * @param identifier The identifier of the configuration to remove.
     * @throws GuacamoleException If an error occurs while removing the
     *                            configuration, or if removing the
     *                            configuration is not allowed.
     */
    void removeConfiguration(Credentials credentials, String identifier)
            throws GuacamoleException;
    
import net.sourceforge.guacamole.GuacamoleException;

import java.util.Set;
     * Converts the given Credentials to a corresponding User, which need not
     * actually exist.
     * 
     * @param ownCredentials The credentials to use to authorize the conversion.
     * @param credentials The credentials to convert.
     * @return A User which corresponds to the given Credentials.
     * @throws GuacamoleException If an error occurs converting the Credentials
     *                            into a User, or if such conversion is not
     *                            allowed.
     */
    User toUser(Credentials ownCredentials, Credentials credentials)
            throws GuacamoleException;

    /**
     * GuacamoleConfigurations visible with those credentials. The keys of
 
    /**
     * Given an arbitrary Credentials object, returns a Set containing all
     * Users visible with those credentials.
     *
     * @param credentials The credentials to use to retrieve users. 
     * @return A Set of all users visible with the given credentials,
     *         or null if the credentials given are not authorized.
     * @throws GuacamoleException If an error occurs while retrieving
     *                            users.
     */
    Set<User> getUsers(Credentials credentials) throws GuacamoleException;

    /**
     * Adds the given User to the overall set of available Users, using the
     * given credentials.
     * 
     * @param credentials The credentials to use when adding the given
     *                    user.
     * @param user The user to add.
     * @throws GuacamoleException If an error occurs while adding the user, or
     *                            if adding the user is not allowed.
     */
    void addUser(Credentials credentials, User user)
            throws GuacamoleException;
    
    /**
     * Updates the User with the data contained in the given User, using the
     * given credentials. The user to update is identified using the username
     * of the User given.
     * 
     * @param credentials The credentials to use when updating the user. 
     * @param user The user to use when updating the stored user.
     * @throws GuacamoleException If an error occurs while updating the user,
     *                            or if updating the user is not allowed.
     */
    void updateUser(Credentials credentials, User user)
            throws GuacamoleException;
    
    /**
     * Removes the User using the given credentials.
     * 
     * @param credentials The credentials to use when removing the user. 
     * @throws GuacamoleException If an error occurs while removing the user,
     *                            or if removing user is not allowed.
     */
    void removeUser(Credentials credentials, User user)
            throws GuacamoleException;

     * Returns the Environment authorized by the given credentials, or null if
     * the given credentials are not authorized.
     * @param credentials The credentials to use to retrieve the environment.
     * @return An Environment containing all Users and GuacamoleConfigurations
     *         the credentials provide access to.
     * @throws GuacamoleException If an error occurs while creating the
     *                            Environment.
    Environment getAuthorizedEnvironment(Credentials credentials)
   
public abstract class AbstractUser implements User, Comparable<AbstractUser> {
     * Returns the environment exposed by this AuthenticationProvider. The
     * environment provides unrestricted access to all available users and
     * configurations, though operations which permanently affect users and
     * configurations are only possible through a UserContext.
     * 
     * @return An Environment containing all Users and GuacamoleConfigurations
     *         currently available through this AuthenticationProvider.
     * 
     * @throws GuacamoleException If an error occurs while retrieving the
     *                            environment.
     */
    Environment getEnvironment() throws GuacamoleException;
    
    /**
     * Returns the UserContext of the user authorized by the given credentials.
     * @return The UserContext of the user authorized by the given credentials,
     *         or null if the credentials are not authorized.
     * 
     *                            UserContext.
    UserContext getUserContext(Credentials credentials)
     * Returns a Map containing absolutely all GuacamoleConfigurations. The
     * keys of this Map are Strings which uniquely identify each configuration.
     * Returns a Set containing absolutely all Users.
     * @return A Set of all users.
public interface User {
 * The Original Code is guacamole-ext.
 * The Original Code is guacamole-ext.
 * The Original Code is guacamole-ext.
 * The Original Code is guacamole-ext.
 * The Original Code is guacamole-ext.
 * The Original Code is guacamole-ext.
    /**
     * This user's role.
     */
    private Role role;
    
    public String getUsername() {
    public void setUsername(String username) {
    public String getPassword() {
    public void setPassword(String password) {
    @Override
    public Role getRole() {
        return role;
    }

    @Override
    public void setRole(Role role) {
        this.role = role;
    }

    public String getUsername();
    public void setUsername(String username);
    public String getPassword();
    public void setPassword(String password);
    /**
     * Returns the role of this User. The role defines exactly which permissions
     * a particular user has.
     * 
     * @return The role of this User.
     */
    public Role getRole();

    /**
     * Sets the role of this User to the given Role.
     * 
     * @param role The role which this User should have.
     */
    public void setRole(Role role);
    
     * Retrieves a UserDirectory which can be used to view and manipulate other
     * users, but only as allowed by the permissions given to the user of this
     * UserContext.
     * @return A UserDirectory whose operations are bound by the restrictions
     *         of this UserContext.
     * @throws GuacamoleException If an error occurs while creating the
     *                            UserDirectory.
    UserDirectory getUserDirectory() throws GuacamoleException;
     * Retrieves a GuacamoleConfigurationDirectory which can be used to view
     * and manipulate configurations, but only as allowed by the permissions
     * given to the user of this UserContext.
     * 
     * @return A GuacamoleConfigurationdirectory whose operations are bound by
     *         the restrictions of this UserContext.
     * 
     * @throws GuacamoleException If an error occurs while creating the
     *                            GuacamoleConfigurationDirectory.
     */   
    GuacamoleConfigurationDirectory getGuacamoleConfigurationDirectory()
     * Retrieves a PermissionDirectory which can be used to view and manipulate
     * permissions, but only as allowed by the permissions given to the user of
     * this UserContext.
     * @return A PermissionDirectory whose operations are bound by the
     *         restrictions of this UserContext.
     * 
     * @throws GuacamoleException If an error occurs while creating the
     *                            PermissionDirectory.
    PermissionDirectory getPermissionDirectory() throws GuacamoleException;
import net.sourceforge.guacamole.net.auth.simple.SimpleAuthenticationProvider;
public class BasicFileAuthenticationProvider extends SimpleAuthenticationProvider {
    public Map<String, GuacamoleConfiguration>
            getAuthorizedConfigurations(Credentials credentials)
            throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.UserContext;
 * The user context is retrieved using the authentication provider defined in
 * guacamole.properties. The authentication provider has access to the request
 * and session, in addition to any submitted username and password, in order
 * to authenticate the user.
 * The user context will be stored in the current HttpSession.
     * The session attribute holding the current UserContext.
    private static final String CONTEXT_ATTRIBUTE = "GUAC_CONTEXT";
     * Returns the UserContext associated with the given session.
     * @param session The session to retrieve UserContext from.
     * @return The UserContext associated with the given session.
    protected UserContext getUserContext(HttpSession session) {
        return (UserContext) session.getAttribute(CONTEXT_ATTRIBUTE);
        // Try to get user context from session
        UserContext context = getUserContext(httpSession);
        // If no context, try to authenticate the user to get the context using
        if (context == null) {
            // Get authorized context
                context = authProvider.getUserContext(credentials);
            // If error retrieving context, fail authentication, notify listeners
                logger.error("Error retrieving context for user \"{}\".",
            // If no context, fail authentication, notify listeners
            if (context == null) {
            // Associate context and credentials with session
            httpSession.setAttribute(CONTEXT_ATTRIBUTE,     context);
            httpSession.setAttribute(CREDENTIALS_ATTRIBUTE, credentials);
        authenticatedService(context, request, response);
    /**
     * Function called after the credentials given in the request (if any)
     * are authenticated. If the current session is not associated with
     * valid credentials, this function will not be called.
     * 
     * @param context The current UserContext.
     * @param request The HttpServletRequest being serviced.
     * @param response An HttpServletResponse which controls the HTTP response
     *                 of this servlet.
     * 
     * @throws ServletException If an error occurs that interferes with the
     *                          normal operation of this servlet.
     * @throws IOException If an error occurs that prevents this servlet from
     *                     communicating.
     */
            UserContext context,
import net.sourceforge.guacamole.net.auth.GuacamoleConfigurationDirectory;
import net.sourceforge.guacamole.net.auth.UserContext;
            UserContext context,
            // Get context
            UserContext context = getUserContext(httpSession);

            // Get configuration directory
            GuacamoleConfigurationDirectory directory =
                    context.getGuacamoleConfigurationDirectory();
                
            // Attempt to get configurations from directory
            Map<String, GuacamoleConfiguration> configs =
                    directory.getConfigurations();
import net.sourceforge.guacamole.net.auth.UserContext;
            UserContext context,
import javax.servlet.ServletException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.GuacamoleConfigurationDirectory;
import net.sourceforge.guacamole.net.auth.UserContext;
            UserContext context,
    throws IOException, ServletException {
        // Write XML content type
        // Attempt to get configurations
        Map<String, GuacamoleConfiguration> configs;
        try {

            // Get configuration directory
            GuacamoleConfigurationDirectory directory =
                context.getGuacamoleConfigurationDirectory();
            
            // Get configurations
            configs = directory.getConfigurations();

        }
        catch (GuacamoleException e) {
            throw new ServletException("Unable to retrieve configurations.", e);
        }
        
        // Write actual XML
 * GuacamoleConfiguration. Note that this permission only refers to the
 * GuacamoleConfiguration by its identifier. The actual GuacamoleConfiguration
 * is not stored within.
    implements ObjectPermission<String> {
     * The identifier of the GuacamoleConfiguration associated with the
     * operation affected by this permission.
    private String subject;
     * @param subject The identifier of the GuacamoleConfiguration associated
     *                with the operation affected by this permission.
    public GuacamoleConfigurationPermission(Type type, String subject) {
    public String getSubject() {
public class UserPermission implements ObjectPermission<String> {
     * The username of the User associated with the operation affected by this
     * permission.
    private String subject;
     * @param subject The username of the User associated with the operation
     *                affected by this permission.
    public UserPermission(String subject, Type type) {
    public String getSubject() {
    private String identifier;
     * and identifier. The identifier must be the unique identifier assigned
     * to the GuacamoleConfiguration by the AuthenticationProvider in use.
     * @param identifier The identifier of the GuacamoleConfiguration associated
     *                   with the operation affected by this permission.
    public GuacamoleConfigurationPermission(Type type, String identifier) {
        this.identifier = identifier;
    public String getObjectIdentifier() {
        return identifier;
 * @param <T> The type of identifier used by the object this permission affects.
     * Returns the identifier of the specific object affected by this
     * permission.
     * 
     * @return The identifier of the specific object affected by this
     *         permission.
    public T getObjectIdentifier();
    private String identifier;
     * Creates a new UserPermission having the given type and identifier. The
     * identifier must be the user's username.
     * @param identifier The username of the User associated with the operation
     *                   affected by this permission.
    public UserPermission(String identifier, Type type) {
        this.identifier = identifier;
    public String getObjectIdentifier() {
        return identifier;
        this.config = config;

    /**
     * The PermissionDirectory describing which permissions are available for
     * the configurations provided.
     */
    private final PermissionDirectory permissionDirectory;

        this.permissionDirectory =
                new SimplePermissionDirectory(self, configs);

        return permissionDirectory;
 * hooks can be used to take action upon occurrence of an event and,
package net.sourceforge.guacamole.net.event.listener;
     * Returns a Map containing GuacamoleConfigurationTemplates which describe
     * legal parameters and value. These templates are expected to be used as
     * the blueprints for new connections.
     * 
     * @return A Map of configuration templates.
     * @throws GuacamoleException If an error occurs while retrieving the
     *                            templates.
     */
    Map<String, GuacamoleConfigurationTemplate> getTemplates()
            throws GuacamoleException;

    /**
import net.sourceforge.guacamole.net.auth.GuacamoleConfigurationTemplate;
    public Map<String, GuacamoleConfigurationTemplate> getTemplates()
            throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied.");
    }

    @Override
import java.io.UnsupportedEncodingException;
                        String hashedPassword = getHexString(digest.digest(password.getBytes("UTF-8")));
                    catch (UnsupportedEncodingException e) {
                        throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
                    }
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.InputStream;
                InputStream input = new BufferedInputStream(new FileInputStream(user_mapping_file));
                parser.parse(new InputSource(input));
                input.close();
                opcode,
        writer.writeInstruction(new GuacamoleInstruction("select", config.getProtocol()));
        } while (!instruction.getOpcode().equals("args"));
                "size",
                    "audio",
                    "video",
        writer.writeInstruction(new GuacamoleInstruction("connect", args));
    private String opcode;
     * @param operation The opcode of the instruction to create.
    public GuacamoleInstruction(String opcode, String... args) {
        this.opcode = opcode;
     * Returns the opcode associated with this GuacamoleInstruction.
     * @return The opcode associated with this GuacamoleInstruction.
    public String getOpcode() {
        return opcode;
        buff.append(opcode.length());
        buff.append(opcode);
import java.util.List;
        List<String> arg_names = instruction.getArgs();
        String[] arg_values = new String[arg_names.size()];
        for (int i=0; i<arg_names.size(); i) {
            // Retrieve argument name
            String arg_name = arg_names.get(i);
            // Get defined value for name
            String value = config.getParameter(arg_name);

            // If value defined, set that value
            if (value != null) arg_values[i] = value;

            // Otherwise, leave value blank
            else arg_values[i] = "";
        writer.writeInstruction(new GuacamoleInstruction("connect", arg_values));
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

    /**
     * The opcode of this instruction.
     */

    /**
     * All arguments of this instruction, in order.
     */
    private List<String> args;
        this.args = Collections.unmodifiableList(Arrays.asList(args));
     * Returns a List of all argument values specified for this
     * GuacamoleInstruction. Note that the List returned is immutable.
     * Attempts to modify the list will result in exceptions.
     * @return A List of all argument values specified for this
    public List<String> getArgs() {
        // Write opcode
        // Write argument values
        for (String value : args) {
            buff.append(value.length());
            buff.append(value);
        // Write terminator
            // Get writer for response
            Writer out = new BufferedWriter(new OutputStreamWriter(
                    response.getOutputStream(), "UTF-8"));
            // Stream data to response, ensuring output stream is closed
            try {
                // Detach tunnel and throw error if EOF (and we haven't sent any
                // data yet.
                char[] message = reader.read();
                if (message == null)
                    throw new GuacamoleResourceNotFoundException("Tunnel reached end of stream.");
                // For all messages, until another stream is ready (we send at least one message)
                do {
                    // Get message output bytes
                    out.write(message, 0, message.length);
                    // Flush if we expect to wait
                    if (!reader.available()) {
                        out.flush();
                        response.flushBuffer();
                    }
                    // No more messages another stream can take over
                    if (tunnel.hasQueuedReaderThreads())
                        break;
                } while (tunnel.isOpen() && (message = reader.read()) != null);
                // Close tunnel immediately upon EOF
                if (message == null)
                    tunnel.close();

                // End-of-instructions marker
                out.write("0.;");
                out.flush();
                response.flushBuffer();
            }

            // Always close output stream
            finally {
                out.close();
            }
            // Get writer from tunnel
            // Get input reader for HTTP stream
            Reader input = new InputStreamReader(
                    request.getInputStream(), "UTF-8");
            // Transfer data from input stream to tunnel output, ensuring
            // input is always closed
            try {

                // Buffer
                int length;
                char[] buffer = new char[8192];
                
                // Transfer data using buffer
                while (tunnel.isOpen() &&
                        (length = input.read(buffer, 0, buffer.length)) != -1)
                    writer.write(buffer, 0, length);
                
            }

            // Close input stream in all cases
            finally {
                input.close();
            }
        Collection<String> getPossibleValues();
import net.sourceforge.guacamole.GuacamoleSecurityException;
import net.sourceforge.guacamole.net.auth.PermissionDirectory;
import net.sourceforge.guacamole.net.auth.User;
import net.sourceforge.guacamole.net.auth.permission.GuacamoleConfigurationDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.GuacamoleConfigurationPermission;
import net.sourceforge.guacamole.net.auth.permission.ObjectPermission;
import net.sourceforge.guacamole.net.auth.permission.Permission;
import net.sourceforge.guacamole.net.auth.permission.SystemPermission;
    /**
     * Checks whether the given user has permission to perform the given
     * system operation. Security exceptions are handled appropriately - only
     * non-security exceptions pass through.
     * 
     * @param permissions The PermissionsDirectory to check.
     * @param user The user whose permissions should be verified.
     * @param type The type of operation to check for permission for.
     * @return true if permission is granted, false otherwise.
     * 
     * @throws GuacamoleException If an error occurs while checking permissions.
     */
    private boolean hasConfigPermission(PermissionDirectory permissions,
            User user, SystemPermission.Type type)
    throws GuacamoleException {

        // Build permission
        Permission permission =
                new GuacamoleConfigurationDirectoryPermission(type);

        try {
            // Return result of permission check, if possible
            return permissions.hasPermission(user, permission);
        }
        catch (GuacamoleSecurityException e) {
            // If cannot check due to security restrictions, no permission
            return false;
        }

    }

    /**
     * Checks whether the given user has permission to perform the given
     * object operation. Security exceptions are handled appropriately - only
     * non-security exceptions pass through.
     * 
     * @param permissions The PermissionsDirectory to check.
     * @param user The user whose permissions should be verified.
     * @param type The type of operation to check for permission for.
     * @param identifier The identifier of the configuration the operation
     *                   would be performed upon.
     * @return true if permission is granted, false otherwise.
     * 
     * @throws GuacamoleException If an error occurs while checking permissions.
     */
    private boolean hasConfigPermission(PermissionDirectory permissions,
            User user, ObjectPermission.Type type, String identifier)
    throws GuacamoleException {

        // Build permission
        Permission permission = new GuacamoleConfigurationPermission(
            type,
            identifier
        );

        try {
            // Return result of permission check, if possible
            return permissions.hasPermission(user, permission);
        }
        catch (GuacamoleSecurityException e) {
            // If cannot check due to security restrictions, no permission
            return false;
        }

    }
    
        // Try to get permission directory
        PermissionDirectory permissions = null;
        try {
            permissions = context.getPermissionDirectory();
        }
        catch (GuacamoleSecurityException e) {
            // Soft fail - can't check permissions ... assume have READ and
            // nothing else
        }
        catch (GuacamoleException e) {
            throw new ServletException("Unable to retrieve permissions.", e);
        }

                // Save config create permission attribute
                if (hasConfigPermission(permissions, context.self(),
                        SystemPermission.Type.CREATE))
                    xml.writeAttribute("create", "yes");
                
                // Check permissions and set attributes appropriately
                if (permissions != null) {

                    // Save update permission attribute
                    if (hasConfigPermission(permissions, context.self(),
                            ObjectPermission.Type.UPDATE, entry.getKey()))
                        xml.writeAttribute("update", "yes");
                    
                    // Save admin permission attribute
                    if (hasConfigPermission(permissions, context.self(),
                            ObjectPermission.Type.ADMINSTER, entry.getKey()))
                        xml.writeAttribute("admin", "yes");
                    
                    // Save delete permission attribute
                    if (hasConfigPermission(permissions, context.self(),
                            ObjectPermission.Type.DELETE, entry.getKey()))
                        xml.writeAttribute("delete", "yes");
                    
                }
                
        catch (GuacamoleException e) {
            throw new ServletException("Unable to read configurations.", e);
        }
    public UserPermission(Type type, String identifier) {
        ADMINISTER
import java.util.Set;
     * Lists all permissions given to the specified user.
     * 
     * @param user The username of the user to list permissions of.
     * @return A Set of all permissions granted to the specified user.
     * 
     * @throws GuacamoleException  If an error occurs while retrieving
     *                             permissions, or if reading all permissions
     *                             is not allowed.
     */
    Set<Permission> getPermissions(String user) throws GuacamoleException;
    
    /**
     * @param user The username of the user to check permissions for.
    boolean hasPermission(String user, Permission permission)
     * @param user The username of the user to add the permission to.
    void addPermission(String user, Permission permission)
     * @param user The username of the user to remove the permission from.
    void removePermission(String user, Permission permission)
import java.util.HashSet;
     * The username of the user that has access to all given configs.
    private String user;
        this.user = user.getUsername();
    public Set<Permission> getPermissions(String user) throws GuacamoleException {

        // No permssion to check permissions of other users
        if (!this.user.equals(user))
            throw new GuacamoleSecurityException("Permission denied.");
        
        // If correct user, build list all permissions
        Set<Permission> permissions = new HashSet<Permission>();
        for (String identifier : configIdentifiers) {
           
            // Add permission to set
            permissions.add(
                new GuacamoleConfigurationPermission(
                    ObjectPermission.Type.READ,
                    identifier
                )
            );
            
        }

        return permissions;
        
    }

    @Override
    public boolean hasPermission(String user, Permission permission) throws GuacamoleException {
    public void addPermission(String user, Permission permission) throws GuacamoleException {
    public void removePermission(String user, Permission permission) throws GuacamoleException {
            String user, SystemPermission.Type type)
            String user, ObjectPermission.Type type, String identifier)
            // Get username
            String username = context.self().getUsername();
            
            // Save config create permission attribute
            if (hasConfigPermission(permissions, username,
                    SystemPermission.Type.CREATE))
                xml.writeAttribute("create", "yes");
            
                    if (hasConfigPermission(permissions, username,
                    if (hasConfigPermission(permissions, username,
                            ObjectPermission.Type.ADMINISTER, entry.getKey()))
                    if (hasConfigPermission(permissions, username,
                    xml.writeEmptyElement("user");
            if (permissions != null && hasConfigPermission(permissions, username,
            if (permissions != null && hasUserPermission(permissions, username,
     * Removes the user with the given username from the overall set of
     * available Users.
    void removeUser(String username) throws GuacamoleException;
import java.util.Set;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.permission.Permission;

    /**
     * Lists all permissions given to this user.
     * 
     * @return A Set of all permissions granted to this user.
     * 
     * @throws GuacamoleException  If an error occurs while retrieving
     *                             permissions, or if reading all permissions
     *                             is not allowed.
     */
    Set<Permission> getPermissions() throws GuacamoleException;
    
    /**
     * Tests whether this user has the specified permission.
     * 
     * @param permission The permission to check.
     * @return true if the permission is granted to this user, false otherwise.
     * 
     * @throws GuacamoleException If an error occurs while checking permissions,
     *                            or if permissions cannot be checked due to
     *                            lack of permissions to do so.
     */
    boolean hasPermission(Permission permission) throws GuacamoleException;
    
    /**
     * Adds the specified permission to this user.
     * 
     * @param permission The permission to add.
     * 
     * @throws GuacamoleException If an error occurs while adding the
     *                            permission. or if permission to add
     *                            permissions is denied.
     */
    void addPermission(Permission permission) throws GuacamoleException;

    /**
     * Removes the specified permission from this specified user.
     * 
     * @param permission The permission to remove.
     * 
     * @throws GuacamoleException If an error occurs while removing the
     *                            permission. or if permission to remove
     *                            permissions is denied.
     */
    void removePermission(Permission permission) throws GuacamoleException;


        User user = new SimpleUser(credentials.getUsername(), configs);
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleSecurityException;
import net.sourceforge.guacamole.net.auth.permission.GuacamoleConfigurationPermission;
import net.sourceforge.guacamole.net.auth.permission.ObjectPermission;
import net.sourceforge.guacamole.net.auth.permission.Permission;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
     * The set of all permissions available to this user.
     */
    private Set<Permission> permissions = new HashSet<Permission>();
    
    /**
     * @param configs All configurations this user has read access to.
    public SimpleUser(String username,
            Map<String, GuacamoleConfiguration> configs) {

        // Set username

        // Add permissions
        for (String identifier : configs.keySet()) {

            // Create permission
            Permission permission = new GuacamoleConfigurationPermission(
                ObjectPermission.Type.READ,
                identifier
            );

            // Add to set
            permissions.add(permission);
            
        }
        
    }

    @Override
    public Set<Permission> getPermissions() throws GuacamoleException {
        return permissions;
    }

    @Override
    public boolean hasPermission(Permission permission) throws GuacamoleException {

        /* FIXME: STUB! */
        throw new UnsupportedOperationException("Not supported yet.");

    }

    @Override
    public void addPermission(Permission permission) throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied.");
    }

    @Override
    public void removePermission(Permission permission) throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied.");

    /**
     * Returns the User having the given username.
     * 
     * @param username The username of the User to return.
     * @return The User having the given username, or null if no such user
     *         exists.
     * 
     * @throws GuacamoleException If an error occurs while retrieving the user,
     *                            or if permission for retrieving the user is
     *                            denied.
     */
    User getUser(String username) throws GuacamoleException;
    
     * Returns the GuacamoleConfiguration having the given identifier.
     * 
     * @param identifier The identifier of the GuacamoleConfiguration to
     *                   return.
     * @return The GuacamoleConfiguration having the given identifier, or null
     *         if no such GuacamoleConfiguration exists.
     * 
     * @throws GuacamoleException If an error occurs while retrieving the
     *                            configuration, or if access to the
     *                            configuration is denied.
     */
    GuacamoleConfiguration getConfiguration(String identifier)
            throws GuacamoleException;

    /**
    public GuacamoleConfiguration getConfiguration(String identifier)
            throws GuacamoleException {
        return configs.get(identifier);
    }

    @Override
public abstract class AbstractUser implements User {
    @Override
    public int hashCode() {
        return type.hashCode();
    }

    @Override
    public boolean equals(Object obj) {

        // Not equal if null or wrong type
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;

        final GuacamoleConfigurationDirectoryPermission other =
                (GuacamoleConfigurationDirectoryPermission) obj;

        // Compare types
        if (type != other.type)
            return false;

        return true;
    }

    @Override
    public int hashCode() {
        int hash = 5;
        if (identifier != null) hash = 47 * hash  identifier.hashCode();
        if (type != null)       hash = 47 * hash  type.hashCode();
        return hash;
    }

    @Override
    public boolean equals(Object obj) {

        // Not equal if null or wrong type
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;

        final GuacamoleConfigurationPermission other =
                (GuacamoleConfigurationPermission) obj;

        // Not equal if different type
        if (this.type != other.type)
            return false;

        // If null identifier, equality depends on whether other identifier
        // is null
        if (identifier == null)
            return other.identifier != null;

        // Otherwise, equality depends entirely on identifier
        return identifier.equals(other.identifier);

    }

    @Override
    public int hashCode() {
        return type.hashCode();
    }

    @Override
    public boolean equals(Object obj) {

        // Not equal if null or wrong type
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;

        final UserDirectoryPermission other = (UserDirectoryPermission) obj;

        // Compare types
        if (type != other.type)
            return false;

        return true;
    }

    @Override
    public int hashCode() {
        int hash = 5;
        if (identifier != null) hash = 47 * hash  identifier.hashCode();
        if (type != null)       hash = 47 * hash  type.hashCode();
        return hash;
    }

    @Override
    public boolean equals(Object obj) {

        // Not equal if null or wrong type
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;

        final UserPermission other = (UserPermission) obj;

        // Not equal if different type
        if (this.type != other.type)
            return false;

        // If null identifier, equality depends on whether other identifier
        // is null
        if (identifier == null)
            return other.identifier != null;

        // Otherwise, equality depends entirely on identifier
        return identifier.equals(other.identifier);

    }

        return permissions.contains(permission);
import net.sourceforge.guacamole.net.auth.User;
    private boolean hasConfigPermission(User user, SystemPermission.Type type)
            return user.hasPermission(permission);
    private boolean hasConfigPermission(User user, ObjectPermission.Type type,
            String identifier)
            return user.hasPermission(permission);
       
            // Get self 
            User self = context.self();
            if (hasConfigPermission(self, SystemPermission.Type.CREATE))
                // Save update permission attribute
                if (hasConfigPermission(self, ObjectPermission.Type.UPDATE,
                        entry.getKey()))
                    xml.writeAttribute("update", "yes");
                
                // Save admin permission attribute
                if (hasConfigPermission(self, ObjectPermission.Type.ADMINISTER,
                        entry.getKey()))
                    xml.writeAttribute("admin", "yes");
                
                // Save delete permission attribute
                if (hasConfigPermission(self, ObjectPermission.Type.DELETE,
                        entry.getKey()))
                    xml.writeAttribute("delete", "yes");
import net.sourceforge.guacamole.net.auth.User;
import net.sourceforge.guacamole.net.auth.UserDirectory;
            // Get user directory
            UserDirectory users = context.getUserDirectory();
            
            // Get specific user
            User user = users.getUser(username);
            
            for (Permission permission : user.getPermissions()) {
    private boolean hasUserPermission(User user, SystemPermission.Type type)
            return user.hasPermission(permission);
    private boolean hasUserPermission(User user, ObjectPermission.Type type,
            String identifier)
            return user.hasPermission(permission);
            // Get self
            User self = context.self();
            if (hasUserPermission(self, SystemPermission.Type.CREATE))
                // Save update permission attribute
                if (hasUserPermission(self, ObjectPermission.Type.UPDATE,
                        user.getUsername()))
                    xml.writeAttribute("update", "yes");
                
                // Save admin permission attribute
                if (hasUserPermission(self, ObjectPermission.Type.ADMINISTER,
                        user.getUsername()))
                    xml.writeAttribute("admin", "yes");
                
                // Save delete permission attribute
                if (hasUserPermission(self, ObjectPermission.Type.DELETE,
                        user.getUsername()))
                    xml.writeAttribute("delete", "yes");
     * The UserDirectory with access only to the User associated with this
     * UserContext.
     */
    private final UserDirectory userDirectory;
    
    /**
        this.userDirectory = new SimpleUserDirectory(self);
        
        return userDirectory;
            if (user == null)
                throw new GuacamoleSecurityException("No such user.");
import java.io.File;
import java.io.FileInputStream;
            // Attempt to find Guacamole home
            File guacHome;
            
            // Get explicitly specified directory, if any
            String desiredDir = System.getProperty("guacamole.home");
            if (desiredDir != null)
                guacHome = new File(desiredDir);

            // If not explicitly-define directory, use ~/.guacamole
            else
                guacHome = new File(System.getProperty("user.home"), ".guacamole");

            InputStream stream;
            
            // If not a directory, load from classpath
            if (!guacHome.isDirectory()) {

                // Read from classpath
                stream = GuacamoleProperties.class.getResourceAsStream("/guacamole.properties");
                if (stream == null)
                    throw new IOException(
                        "guacamole.properties not loaded from "  guacHome
                       " (not a directory), and guacamole.properties could"
                       " not be found as a resource in the classpath.");

            }

            // Otherwise, try to load from file
            else
                stream = new FileInputStream(new File(guacHome, "guacamole.properties"));
 * file. The guacamole.properties file is preferably located in the servlet
 * container's user's home directory, in a subdirectory called .guacamole, or
 * in the directory set by the system property: guacamole.home.
 * 
 * If none of those locations are possible, guacamole.properties will also
 * be read from the root of the classpath.
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
    Directory<String, User> getUserDirectory() throws GuacamoleException;
    Directory<String, GuacamoleConfiguration>
            getGuacamoleConfigurationDirectory()
import java.util.Set;
import net.sourceforge.guacamole.net.auth.Directory;
 * An extremely simple read-only implementation of a Directory of
 * GuacamoleConfigurations which provides access to a pre-defined Map of
 * GuacamoleConfigurations.
    implements Directory<String, GuacamoleConfiguration> {
    public GuacamoleConfiguration get(String identifier)
    public Set<String> getIdentifiers() throws GuacamoleException {
        return configs.keySet();
    public void add(String identifier, GuacamoleConfiguration config)
            throws GuacamoleException {
    public void update(String identifier, GuacamoleConfiguration config)
            throws GuacamoleException {
    public void remove(String identifier) throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.Directory;
    private final Directory<String, GuacamoleConfiguration> configDirectory;
    private final Directory<String, User> userDirectory;
    public Directory<String, GuacamoleConfiguration>
            getGuacamoleConfigurationDirectory()
    public Directory<String, User> getUserDirectory()
            throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.Directory;
 * An extremely simple read-only implementation of a Directory of Users which
public class SimpleUserDirectory implements Directory<String, User> {
    public User get(String username) throws GuacamoleException {
    public Set<String> getIdentifiers() throws GuacamoleException {
        return Collections.singleton(user.getUsername());
    public void add(String username, User user) throws GuacamoleException {
    public void update(String username, User user) throws GuacamoleException {
    public void remove(String username) throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.Directory;
            Directory<String, GuacamoleConfiguration> directory =
            if (credentials == null)
            GuacamoleConfiguration config = directory.get(id);
import net.sourceforge.guacamole.net.auth.Directory;
        Directory<String, GuacamoleConfiguration> directory;
            directory = context.getGuacamoleConfigurationDirectory();
            for (String identifier : directory.getIdentifiers()) {
                GuacamoleConfiguration config = directory.get(identifier);
                xml.writeAttribute("id", identifier);
                        identifier))
                        identifier))
                        identifier))
import net.sourceforge.guacamole.net.auth.Directory;
            Directory<String, User> users = context.getUserDirectory();
            User user = users.get(username);
import net.sourceforge.guacamole.net.auth.Directory;
            Directory<String, User> directory = context.getUserDirectory();
            Set<String> users = directory.getIdentifiers();
            for (String username : users) {
                // Get user
                User user = directory.get(username);
                
 * @param <IdentifierType> The type of identifier used to identify objects
 *                         stored within this Directory.
 * @param <ObjectType> The type of objects stored within this Directory.
    void add(ObjectType object)
    void update(ObjectType object)
     * Retrieves a Directory which can be used to view and manipulate other
     * @return A Directory whose operations are bound by the restrictions
     *                            Directory.
     * Retrieves a Directory which can be used to view and manipulate
     * connections and their configurations, but only as allowed by the
     * permissions given to the user of this UserContext.
     * @return A Directory whose operations are bound by the restrictions
     *         of this UserContext.
     *                            Directory.
    Directory<String, Connection> getConnectionDirectory()
 b/guacamole-ext/src/main/java/net/sourceforge/guacamole/net/auth/permission/ConnectionDirectoryPermission.java
public class ConnectionDirectoryPermission
     * Creates a new ConnectionDirectoryPermission with the given
    public ConnectionDirectoryPermission(Type type) {
        final ConnectionDirectoryPermission other =
                (ConnectionDirectoryPermission) obj;
 b/guacamole-ext/src/main/java/net/sourceforge/guacamole/net/auth/permission/ConnectionPermission.java
public class ConnectionPermission
     * Creates a new ConnectionPermission having the given type
    public ConnectionPermission(Type type, String identifier) {
        final ConnectionPermission other =
                (ConnectionPermission) obj;
 b/guacamole-ext/src/main/java/net/sourceforge/guacamole/net/auth/simple/SimpleConnectionDirectory.java
import java.util.HashMap;
import java.util.Map.Entry;
import net.sourceforge.guacamole.net.auth.Connection;
public class SimpleConnectionDirectory 
    implements Directory<String, Connection> {
     * The Map of Connections to provide access to.
    private Map<String, Connection> connections =
            new HashMap<String, Connection>();
     * Creates a new SimpleConnectionDirectory which provides
    public SimpleConnectionDirectory(

        // Create connections for each config
        for (Entry<String, GuacamoleConfiguration> entry : configs.entrySet())
            connections.put(entry.getKey(),
                    new SimpleConnection(entry.getKey(), entry.getValue()));
        
    public Connection get(String identifier)
        return connections.get(identifier);
        return connections.keySet();
    public void add(Connection connection)
    public void update(Connection connection)
import net.sourceforge.guacamole.net.auth.permission.ConnectionPermission;
            Permission permission = new ConnectionPermission(
import net.sourceforge.guacamole.net.auth.Connection;
     * The Directory with access only to those Connections that the User
     * associated with this UserContext has access to.
    private final Directory<String, Connection> connectionDirectory;
     * The Directory with access only to the User associated with this
        this.connectionDirectory =
                new SimpleConnectionDirectory(configs);
    public Directory<String, Connection> getConnectionDirectory()
        return connectionDirectory;
    public void add(User user) throws GuacamoleException {
    public void update(User user) throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.Connection;
 * Connects users to a tunnel associated with the authorized connection
            // Get connection directory
            Directory<String, Connection> directory = context.getConnectionDirectory();
            // If no credentials in session, not authorized
            // Get authorized connection 
            Connection connection = directory.get(id);
            if (connection == null) {
                logger.warn("Connection id={} not found.", id);
                throw new GuacamoleSecurityException("Requested connection is not authorized.");
            // Connect socket
            GuacamoleSocket socket = connection.connect(info);
 b/guacamole/src/main/java/net/sourceforge/guacamole/net/basic/ConnectionList.java
import net.sourceforge.guacamole.net.auth.Connection;
import net.sourceforge.guacamole.net.auth.permission.ConnectionDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.ConnectionPermission;
public class ConnectionList extends AuthenticatingHttpServlet {
                new ConnectionDirectoryPermission(type);
     * @param identifier The identifier of the connection the operation
        Permission permission = new ConnectionPermission(
        // Attempt to get connections 
        Directory<String, Connection> directory;
            // Get connection directory
            directory = context.getConnectionDirectory();
            throw new ServletException("Unable to retrieve connections.", e);
            xml.writeStartElement("connections");
            // Save connection create permission attribute
            // For each entry, write corresponding connection element
                // Get connection 
                Connection connection = directory.get(identifier);
                // Write connection
                xml.writeEmptyElement("connection");
                xml.writeAttribute("protocol",
                        connection.getConfiguration().getProtocol());
import net.sourceforge.guacamole.net.auth.permission.ConnectionDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.ConnectionPermission;
                if (permission instanceof ConnectionDirectoryPermission) {
                    ConnectionDirectoryPermission cdp =
                            (ConnectionDirectoryPermission) permission;
                    xml.writeEmptyElement("connections");
                    xml.writeAttribute("type", toString(cdp.getType()));
                else if (permission instanceof ConnectionPermission) {
                    ConnectionPermission cp =
                            (ConnectionPermission) permission;
                    xml.writeEmptyElement("connection");
                    xml.writeAttribute("type", toString(cp.getType()));
                    xml.writeAttribute("name", cp.getObjectIdentifier());
            case CREATE: return "create";
 b/guacamole/src/main/java/net/sourceforge/guacamole/net/basic/crud/connections/List.java
package net.sourceforge.guacamole.net.basic.crud.connections;
import net.sourceforge.guacamole.net.basic.AuthenticatingHttpServlet;
public class List extends AuthenticatingHttpServlet {
 b/guacamole/src/main/java/net/sourceforge/guacamole/net/basic/crud/permissions/List.java
package net.sourceforge.guacamole.net.basic.crud.permissions;
import net.sourceforge.guacamole.net.basic.AuthenticatingHttpServlet;
public class List extends AuthenticatingHttpServlet {
 b/guacamole/src/main/java/net/sourceforge/guacamole/net/basic/crud/users/List.java
package net.sourceforge.guacamole.net.basic.crud.users;
import net.sourceforge.guacamole.net.basic.AuthenticatingHttpServlet;
public class List extends AuthenticatingHttpServlet {
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.Directory;
import net.sourceforge.guacamole.net.auth.User;
        // Create user as specified
        String username = request.getParameter("name");
        String password = request.getParameter("password");
        
        try {

            // Attempt to get user directory
            Directory<String, User> directory =
                    context.getUserDirectory();

            // Create user skeleton
            User user = new DummyUser();
            user.setUsername(username);
            user.setPassword(password);
            
            // Add user
            directory.add(user);
            
        }
        catch (GuacamoleException e) {
            throw new ServletException("Unable to create connection.", e);
        }
 
import java.util.Enumeration;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.Connection;
import net.sourceforge.guacamole.net.auth.Directory;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
    /**
     * Prefix given to a parameter name when that parameter is a protocol-
     * specific parameter meant for the configuration.
     */
    public static final String PARAMETER_PREFIX = "_";
    
        // Get ID and protocol
        String identifier = request.getParameter("id");
        String protocol = request.getParameter("protocol");
        
        try {

            // Attempt to get connection directory
            Directory<String, Connection> directory =
                    context.getConnectionDirectory();

            // Create config
            GuacamoleConfiguration config = new GuacamoleConfiguration();
            config.setProtocol(protocol);

            // Load parameters into config
            Enumeration<String> params = request.getParameterNames();
            while (params.hasMoreElements()) {

                // If parameter starts with prefix, load corresponding parameter
                // value into config
                String param = params.nextElement();
                if (param.startsWith(PARAMETER_PREFIX))
                    config.setParameter(
                        param.substring(PARAMETER_PREFIX.length()),
                        request.getParameter(param));
                
            }
            
            // Create connection skeleton
            Connection connection = new DummyConnection();
            connection.setIdentifier(identifier);
            connection.setConfiguration(config);
            
            // Add connection
            directory.add(connection);
            
        }
        catch (GuacamoleException e) {
            throw new ServletException("Unable to create connection.", e);
        }
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.Connection;
import net.sourceforge.guacamole.net.auth.Directory;
        // Get ID
        String identifier = request.getParameter("id");
        
        try {

            // Attempt to get connection directory
            Directory<String, Connection> directory =
                    context.getConnectionDirectory();
           
            // Remove connection
            directory.remove(identifier);
 
        }
        catch (GuacamoleException e) {
            throw new ServletException("Unable to remove connection.", e);
        }
import java.util.Enumeration;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.Connection;
import net.sourceforge.guacamole.net.auth.Directory;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
    /**
     * Prefix given to a parameter name when that parameter is a protocol-
     * specific parameter meant for the configuration.
     */
    public static final String PARAMETER_PREFIX = "_";
 
        // Get ID and protocol
        String identifier = request.getParameter("id");
        String protocol = request.getParameter("protocol");
        
        try {

            // Attempt to get connection directory
            Directory<String, Connection> directory =
                    context.getConnectionDirectory();

            // Create config
            GuacamoleConfiguration config = new GuacamoleConfiguration();
            config.setProtocol(protocol);

            // Load parameters into config
            Enumeration<String> params = request.getParameterNames();
            while (params.hasMoreElements()) {

                // If parameter starts with prefix, load corresponding parameter
                // value into config
                String param = params.nextElement();
                if (param.startsWith(PARAMETER_PREFIX))
                    config.setParameter(
                        param.substring(PARAMETER_PREFIX.length()),
                        request.getParameter(param));
                
            }
            
            // Create connection skeleton
            Connection connection = new DummyConnection();
            connection.setIdentifier(identifier);
            connection.setConfiguration(config);
            
            // Update connection
            directory.update(connection);
 
        }
        catch (GuacamoleException e) {
            throw new ServletException("Unable to update connection.", e);
        }
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.Directory;
import net.sourceforge.guacamole.net.auth.User;
        // Get username 
        String username = request.getParameter("name");
        
        try {

            // Attempt to get user directory
            Directory<String, User> directory = context.getUserDirectory();
           
            // Remove user 
            directory.remove(username);
 
        }
        catch (GuacamoleException e) {
            throw new ServletException("Unable to remove user.", e);
        }
            throw new ServletException("Unable to create user.", e);
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.Directory;
import net.sourceforge.guacamole.net.auth.User;
import net.sourceforge.guacamole.net.auth.permission.ConnectionDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.ConnectionPermission;
import net.sourceforge.guacamole.net.auth.permission.ObjectPermission;
import net.sourceforge.guacamole.net.auth.permission.Permission;
import net.sourceforge.guacamole.net.auth.permission.SystemPermission;
import net.sourceforge.guacamole.net.auth.permission.UserDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.UserPermission;
    /**
     * String given for directory creation permission.
     */
    private static final String CREATE_PERMISSION = "create";
    
    /**
     * Prefix given before an object identifier for read permission.
     */
    private static final String READ_PREFIX   = "read:";
    
    /**
     * Prefix given before an object identifier for delete permission.
     */
    private static final String DELETE_PREFIX = "delete:";
    
    /**
     * Prefix given before an object identifier for update permission.
     */
    private static final String UPDATE_PREFIX = "update:";
    
    /**
     * Prefix given before an object identifier for administration permission.
     */
    private static final String ADMIN_PREFIX  = "admin:";

    /**
     * Given a permission string, returns the corresponding user permission.
     * 
     * @param str The permission string to parse.
     * @return The parsed user permission.
     * @throws GuacamoleException If the given string could not be parsed.
     */
    private Permission parseUserPermission(String str)
            throws GuacamoleException {

        // Create permission
        if (str.equals(CREATE_PERMISSION))
            return new UserDirectoryPermission(SystemPermission.Type.CREATE);
        
        // Read
        if (str.startsWith(READ_PREFIX))
            return new UserPermission(ObjectPermission.Type.READ,
                    str.substring(READ_PREFIX.length()));
        
        // Update 
        if (str.startsWith(UPDATE_PREFIX))
            return new UserPermission(ObjectPermission.Type.UPDATE,
                    str.substring(UPDATE_PREFIX.length()));

        // Delete 
        if (str.startsWith(DELETE_PREFIX))
            return new UserPermission(ObjectPermission.Type.DELETE,
                    str.substring(DELETE_PREFIX.length()));

        // Administration
        if (str.startsWith(ADMIN_PREFIX))
            return new UserPermission(ObjectPermission.Type.ADMINISTER,
                    str.substring(ADMIN_PREFIX.length()));
        
        throw new GuacamoleException("Invalid permission string.");
        
    }

    /**
     * Given a permission string, returns the corresponding connection
     * permission.
     * 
     * @param str The permission string to parse.
     * @return The parsed connection permission.
     * @throws GuacamoleException If the given string could not be parsed.
     */
    private Permission parseConnectionPermission(String str)
            throws GuacamoleException {

        // Create permission
        if (str.equals(CREATE_PERMISSION))
            return new ConnectionDirectoryPermission(SystemPermission.Type.CREATE);
        
        // Read
        if (str.startsWith(READ_PREFIX))
            return new ConnectionPermission(ObjectPermission.Type.READ,
                    str.substring(READ_PREFIX.length()));
        
        // Update 
        if (str.startsWith(UPDATE_PREFIX))
            return new ConnectionPermission(ObjectPermission.Type.UPDATE,
                    str.substring(UPDATE_PREFIX.length()));

        // Delete 
        if (str.startsWith(DELETE_PREFIX))
            return new ConnectionPermission(ObjectPermission.Type.DELETE,
                    str.substring(DELETE_PREFIX.length()));

        // Administration
        if (str.startsWith(ADMIN_PREFIX))
            return new ConnectionPermission(ObjectPermission.Type.ADMINISTER,
                    str.substring(ADMIN_PREFIX.length()));
        
        throw new GuacamoleException("Invalid permission string.");
        
    }
    
        // Create user as specified
        String username = request.getParameter("name");
        String password = request.getParameter("password");
        try {

            // Attempt to get user directory
            Directory<String, User> directory =
                    context.getUserDirectory();

            // Create user skeleton
            User user = new DummyUser();
            user.setUsername(username);
            user.setPassword(password);
            
            // Set user permissions
            String[] user_permission = request.getParameterValues("user");
            if (user_permission != null) {
                for (String str : user_permission)
                    user.addPermission(parseUserPermission(str));
            }

            // Set connection permissions
            String[] connection_permission = request.getParameterValues("connection");
            if (connection_permission != null) {
                for (String str : connection_permission)
                    user.addPermission(parseConnectionPermission(str));
            }
            
            // Update user
            directory.update(user);
            
        }
        catch (GuacamoleException e) {
            throw new ServletException("Unable to update user.", e);
        }
 
import java.util.Map;
    private Map<String, String> parameters = new HashMap<String, String>();
                xml.writeStartElement("connection");
                // Save update permission attribute, include parameters
                if (hasConfigPermission(self, ObjectPermission.Type.UPDATE,
                        identifier)) {

                    xml.writeAttribute("update", "yes");

                    // FIXME: Read available parameters, parameter title, type, etc. from XML
                    // As update permission is present, also list parameters
                    for (String name : new String[]{"hostname", "port"}) {

                        String value = connection.getConfiguration().getParameter(name);
                        xml.writeStartElement("param");
                        xml.writeAttribute("name", name);
                        xml.writeAttribute("title", name);
                        xml.writeAttribute("type", "text");

                        if (value != null)
                            xml.writeCharacters(value);

                        xml.writeEndElement();
                    }

                }

                xml.writeEndElement();

import java.util.UUID;
            user.setPassword(UUID.randomUUID().toString());
            User user;
            
            if (username != null) {
                // Get user directory
                Directory<String, User> users = context.getUserDirectory();
                
                // Get specific user
                user = users.get(username);
                if (user == null)
                    throw new GuacamoleSecurityException("No such user.");

            }
            else
                user = context.self();
            xml.writeAttribute("user", user.getUsername());
            // Get user data, setting password if given
            User user = directory.get(username);
            if (password != null)
                user.setPassword(password);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private Logger logger = LoggerFactory.getLogger(MySQLUserContext.class);
    
        MySQLUserContext context = injector.getInstance(MySQLUserContext.class);
        context.init(credentials);
                    bind(MySQLUserContext.class);
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
    private Logger logger = LoggerFactory.getLogger(MySQLUserContext.class);
    
    void init(Credentials credentials) {
        // load the required data with the provided credentials
 * The Original Code is guacamole-auth-mysql.
 * James Muehlner.
 * @author James Muehlner
 * The Original Code is guacamole-auth-mysql.
 * James Muehlner.
 * @author James Muehlner
 * The Original Code is guacamole-auth-mysql.
 * James Muehlner.
 * @author James Muehlner
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is guacamole-auth-mysql.
 *
 * The Initial Developer of the Original Code is
 * James Muehlner.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
 * @author James Muehlner
            File guacHome = GuacamoleHome.getDirectory();
import net.sourceforge.guacamole.net.auth.mysql.utility.PasswordEncryptionUtility;
import net.sourceforge.guacamole.net.auth.mysql.utility.SaltUtility;
import net.sourceforge.guacamole.net.auth.mysql.utility.SecureRandomSaltUtility;
import net.sourceforge.guacamole.net.auth.mysql.utility.Sha256PasswordEncryptionUtility;
                    bind(MySQLUser.class);
                    bind(SaltUtility.class).to(SecureRandomSaltUtility.class);
                    bind(PasswordEncryptionUtility.class).to(Sha256PasswordEncryptionUtility.class);
import com.google.inject.Inject;
import java.io.UnsupportedEncodingException;
import java.util.HashSet;
import java.util.List;
import net.sourceforge.guacamole.net.auth.mysql.dao.guacamole.UserMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.guacamole.UserExample;
import net.sourceforge.guacamole.net.auth.mysql.utility.PasswordEncryptionUtility;
import net.sourceforge.guacamole.net.auth.mysql.utility.SaltUtility;
 * A MySQL based implementation of the User object.
    private net.sourceforge.guacamole.net.auth.mysql.model.guacamole.User user;
    @Inject
    UserMapper userDao;
    
    @Inject
    PasswordEncryptionUtility passwordUtility;
    
    @Inject
    SaltUtility saltUtility;
    
    Set<Permission> permissions;
    
    MySQLUser() {
        user = new net.sourceforge.guacamole.net.auth.mysql.model.guacamole.User();
        permissions = new HashSet<Permission>();
    }
    
    /**
     * Create the user, throwing an exception if the credentials do not match what's in the database.
     * @param credentials
     * @throws GuacamoleException 
     */
    void init (Credentials credentials) throws GuacamoleException {
        UserExample userExample = new UserExample();
        userExample.createCriteria().andUsernameEqualTo(credentials.getUsername());
        List<net.sourceforge.guacamole.net.auth.mysql.model.guacamole.User> users = userDao.selectByExample(userExample);
        if(users.size() > 1)  // the unique constraint on the table should prevent this
            throw new GuacamoleException("Multiple users found with the same username: "  credentials.getUsername());
        if(users.isEmpty())
            throw new GuacamoleException("No user found with the supplied credentials");
        user = users.get(0);
        // check password
        if(!passwordUtility.checkCredentials(credentials, user.getPassword_hash(), user.getUsername(), user.getPassword_salt()))
            throw new GuacamoleException("No user found with the supplied credentials");
    }
    
    void init (User user) {
        this.setPassword(user.getPassword());
        this.setUsername(user.getUsername());
    }
    
    public net.sourceforge.guacamole.net.auth.mysql.model.guacamole.User getUser() {
        return user;
        return user.getUsername();
        user.setUsername(username);
        try {
            return new String(user.getPassword_hash(), "UTF-8");
        } catch (UnsupportedEncodingException ex) {
            throw new RuntimeException(ex); // should not happen
        }
        String salt = saltUtility.generateSalt();
        user.setPassword_salt(salt);
        byte[] hash = passwordUtility.createPasswordHash(password, salt);
        user.setPassword_hash(hash);
        return permissions;
        return permissions.contains(permission);
        permissions.add(permission);
        permissions.remove(permission);
    @Inject
    private MySQLUser user;
    
    void init(Credentials credentials) throws GuacamoleException {
        user.init(credentials);
        return user;
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is guacamole-auth-mysql.
 *
 * The Initial Developer of the Original Code is
 * James Muehlner.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionParameterMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.SystemPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.UserMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.UserPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.UserMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.UserExample;
import net.sourceforge.guacamole.net.auth.mysql.model.UserWithBLOBs;
    private UserWithBLOBs user;
        user = new UserWithBLOBs();
        List<UserWithBLOBs> users = userDao.selectByExampleWithBLOBs(userExample);
    public UserWithBLOBs getUser() {
        byte[] salt = saltUtility.generateSalt();
import net.sourceforge.guacamole.net.auth.mysql.dao.UserMapper;
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/dao/ConnectionMapper.java
package net.sourceforge.guacamole.net.auth.mysql.dao;
import net.sourceforge.guacamole.net.auth.mysql.model.Connection;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionExample;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/dao/ConnectionParameterMapper.java
package net.sourceforge.guacamole.net.auth.mysql.dao;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameter;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameterExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameterKey;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/dao/ConnectionPermissionMapper.java
package net.sourceforge.guacamole.net.auth.mysql.dao;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionPermissionKey;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/dao/SystemPermissionMapper.java
package net.sourceforge.guacamole.net.auth.mysql.dao;
import net.sourceforge.guacamole.net.auth.mysql.model.SystemPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.SystemPermissionKey;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/dao/UserMapper.java
package net.sourceforge.guacamole.net.auth.mysql.dao;
import net.sourceforge.guacamole.net.auth.mysql.model.User;
import net.sourceforge.guacamole.net.auth.mysql.model.UserExample;
import net.sourceforge.guacamole.net.auth.mysql.model.UserWithBLOBs;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
    int insert(UserWithBLOBs record);
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
    int insertSelective(UserWithBLOBs record);
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
    List<UserWithBLOBs> selectByExampleWithBLOBs(UserExample example);
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
    UserWithBLOBs selectByPrimaryKey(Integer user_id);
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
    int updateByExampleSelective(@Param("record") UserWithBLOBs record, @Param("example") UserExample example);
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
    int updateByExampleWithBLOBs(@Param("record") UserWithBLOBs record, @Param("example") UserExample example);
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
    int updateByPrimaryKeySelective(UserWithBLOBs record);
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
    int updateByPrimaryKeyWithBLOBs(UserWithBLOBs record);
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/dao/UserPermissionMapper.java
package net.sourceforge.guacamole.net.auth.mysql.dao;
import net.sourceforge.guacamole.net.auth.mysql.model.UserPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.UserPermissionKey;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/model/Connection.java
package net.sourceforge.guacamole.net.auth.mysql.model;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
        this.connection_name = connection_name;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
        this.protocol = protocol;
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/model/ConnectionExample.java
package net.sourceforge.guacamole.net.auth.mysql.model;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/model/ConnectionParameter.java
package net.sourceforge.guacamole.net.auth.mysql.model;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
        this.parameter_value = parameter_value;
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/model/ConnectionParameterExample.java
package net.sourceforge.guacamole.net.auth.mysql.model;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/model/ConnectionParameterKey.java
package net.sourceforge.guacamole.net.auth.mysql.model;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
        this.parameter_name = parameter_name;
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/model/ConnectionPermissionExample.java
package net.sourceforge.guacamole.net.auth.mysql.model;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/model/ConnectionPermissionKey.java
package net.sourceforge.guacamole.net.auth.mysql.model;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
        this.permission = permission;
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/model/SystemPermissionExample.java
package net.sourceforge.guacamole.net.auth.mysql.model;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/model/SystemPermissionKey.java
package net.sourceforge.guacamole.net.auth.mysql.model;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
        this.permission = permission;
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/model/UserExample.java
package net.sourceforge.guacamole.net.auth.mysql.model;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/model/UserPermissionExample.java
package net.sourceforge.guacamole.net.auth.mysql.model;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/model/UserPermissionKey.java
package net.sourceforge.guacamole.net.auth.mysql.model;
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
     * @mbggenerated Tue Feb 12 10:51:12 PST 2013
        this.permission = permission;
    public boolean checkCredentials(Credentials credentials, byte[] dbPasswordHash, String dbUsername, byte[] dbSalt);
    public byte[] createPasswordHash(String password, byte[] salt);
    public byte[] generateSalt();
    public byte[] generateSalt() {
        return salt;
import javax.xml.bind.DatatypeConverter;
    public boolean checkCredentials(Credentials credentials, byte[] dbPasswordHash, String dbUsername, byte[] dbSalt) {
    public byte[] createPasswordHash(String password, byte[] salt) {
            builder.append(DatatypeConverter.printHexBinary(salt));
            return other.identifier == null;
            return other.identifier == null;
import net.sourceforge.guacamole.net.auth.mysql.utility.PermissionCheckUtility;
                    bind(PermissionCheckUtility.class);
import net.sourceforge.guacamole.net.auth.mysql.utility.PermissionCheckUtility;
    UserMapper userDAO;
    @Inject
    PermissionCheckUtility permissionCheckUtility;
    
    /**
     * Create a default, empty user.
     */
        List<UserWithBLOBs> users = userDAO.selectByExampleWithBLOBs(userExample);
        
        this.permissions = permissionCheckUtility.getAllPermissions(user.getUser_id());
    /**
     * Create a new user from the provided information. This represents a user that has not yet been inserted.
     * @param user
     * @throws GuacamoleException 
     */
    public void initNew (User user) throws GuacamoleException {
        this.permissions = user.getPermissions();
    /**
     * Loads a user by username.
     * @param userName
     * @throws GuacamoleException 
     */
    public void initExisting (String username) throws GuacamoleException {
        UserExample example = new UserExample();
        example.createCriteria().andUsernameEqualTo(username);
        List<UserWithBLOBs> userList = userDAO.selectByExampleWithBLOBs(example);
        if(userList.size() > 1) // this should never happen; the unique constraint should prevent it
            throw new GuacamoleException("Multiple users found with username '"  username  "'.");
        if(userList.size() == 0)
            throw new GuacamoleException("No user found with username '"  username  "'.");
        
        this.user = userList.get(0);
        this.permissions = permissionCheckUtility.getAllPermissions(user.getUser_id());
    }
    
    /**
     * Initialize from a database record.
     * @param user 
     */
    public void init(UserWithBLOBs user) {
        this.user = user;
        this.permissions = permissionCheckUtility.getAllPermissions(user.getUser_id());
    }
    
    /**
     * Get the user id.
     * @return 
     */
    public int getUserID() {
        return user.getUser_id();
    }
    
    /**
     * Return the database record held by this object.
     * @return 
     */
 * 
    @Inject UserDirectory userDirectory;
    
        userDirectory.init(user);
        return userDirectory;
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is guacamole-auth-mysql.
 *
 * The Initial Developer of the Original Code is
 * James Muehlner.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
import com.google.common.base.Preconditions;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.SystemPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.dao.UserPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionPermissionKey;
import net.sourceforge.guacamole.net.auth.mysql.model.SystemPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.SystemPermissionKey;
import net.sourceforge.guacamole.net.auth.mysql.model.UserExample;
import net.sourceforge.guacamole.net.auth.mysql.model.UserPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.UserPermissionKey;
import net.sourceforge.guacamole.net.auth.mysql.utility.PermissionCheckUtility;
import net.sourceforge.guacamole.net.auth.permission.ConnectionDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.ConnectionPermission;
import net.sourceforge.guacamole.net.auth.permission.Permission;
import net.sourceforge.guacamole.net.auth.permission.SystemPermission;
import net.sourceforge.guacamole.net.auth.permission.UserDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.UserPermission;
import org.mybatis.guice.transactional.Transactional;
    
    /**
     * The user who this user directory belongs to.
     * Access is based on his/her permission settings.
     */
    private MySQLUser user;
    ConnectionMapper connectionDAO;
    
    @Inject
    UserPermissionMapper userPermissionDAO;
    
    @Inject
    ConnectionPermissionMapper connectionPermissionDAO;
    
    @Inject
    SystemPermissionMapper systemPermissionDAO;
    
    @Inject
    PermissionCheckUtility permissionCheckUtility;
    
    @Inject
    /**
     * Set the user for this directory.
     * @param user 
     */
    void init(MySQLUser user) {
        this.user = user;
    }
    
    /**
     * Create a new user based on the provided object.
     * @param user
     * @return
     * @throws GuacamoleException 
     */
    private MySQLUser getNewMySQLUser(User user) throws GuacamoleException {
        mySQLUser.initNew(user);
    /**
     * Get the user based on the username of the provided object.
     * @param user
     * @return
     * @throws GuacamoleException 
     */
    private MySQLUser getExistingMySQLUser(User user) throws GuacamoleException {
        return getExistingMySQLUser(user.getUsername());
    }
    
    /**
     * Get the user based on the username of the provided object.
     * @param user
     * @return
     * @throws GuacamoleException 
     */
    private MySQLUser getExistingMySQLUser(String name) throws GuacamoleException {
        MySQLUser mySQLUser = mySQLUserProvider.get();
        mySQLUser.initExisting(name);
        return mySQLUser;
    }
    
    @Transactional
        return getExistingMySQLUser(identifier);
    @Transactional
        Set<String> userNameSet = new HashSet<String>();
        List<MySQLUser> users = permissionCheckUtility.getReadableUsers(user.getUserID());
        for(MySQLUser mySQLUser : users) {
            userNameSet.add(mySQLUser.getUsername());
        }
        return userNameSet;
    @Transactional
        Preconditions.checkNotNull(object);
        //create user in database
        MySQLUser mySQLUser = getNewMySQLUser(object);
        
        //create permissions in database
        updatePermissions(mySQLUser);
    }
    
    /**
     * Update all the permissions for a given user to be only those specified in the user object.
     * Delete any permissions not in the list, and create any in the list that do not exist
     * in the database.
     * @param user
     * @throws GuacamoleException 
     */
    private void updatePermissions(MySQLUser user) throws GuacamoleException {
        List<UserPermission> userPermissions = new ArrayList<UserPermission>();
        List<ConnectionPermission> connectionPermissions = new ArrayList<ConnectionPermission>();
        List<SystemPermission> systemPermissions = new ArrayList<SystemPermission>();
        
        for(Permission permission : user.getPermissions()) {
            if(permission instanceof UserPermission)
                userPermissions.add((UserPermission)permission);
            else if(permission instanceof ConnectionPermission)
                connectionPermissions.add((ConnectionPermission)permission);
            else if(permission instanceof SystemPermission)
                systemPermissions.add((SystemPermission)permission);
        }
        
        updateUserPermissions(userPermissions, user);
        updateConnectionPermissions(connectionPermissions, user);
        updateSystemPermissions(systemPermissions, user);
    }
    
    /**
     * Update all the permissions having to do with users for a given user.
     * @param permissions
     * @param user 
     */
    private void updateUserPermissions(Iterable<UserPermission> permissions, MySQLUser user) throws GuacamoleException {
        
        List<String> usernames = new ArrayList<String>();
        for(UserPermission permission : permissions) {
            usernames.add(permission.getObjectIdentifier());
        }
            
        // find all the users by username
        UserExample userExample = new UserExample();
        userExample.createCriteria().andUsernameIn(usernames);
        List<net.sourceforge.guacamole.net.auth.mysql.model.User> dbUsers = userDAO.selectByExample(userExample);
        List<Integer> userIDs = new ArrayList<Integer>();
        
        Map<String, net.sourceforge.guacamole.net.auth.mysql.model.User> dbUserMap = new HashMap<String, net.sourceforge.guacamole.net.auth.mysql.model.User>();
        for(net.sourceforge.guacamole.net.auth.mysql.model.User dbUser : dbUsers) {
            dbUserMap.put(dbUser.getUsername(), dbUser);
            userIDs.add(dbUser.getUser_id());
        }
        
        // find any user permissions that may already exist
        UserPermissionExample userPermissionExample = new UserPermissionExample();
        userPermissionExample.createCriteria().andAffected_user_idIn(userIDs);
        List<UserPermissionKey> existingPermissions = userPermissionDAO.selectByExample(userPermissionExample);
        Set<Integer> existingUserIDs = new HashSet<Integer>();
        for(UserPermissionKey userPermission : existingPermissions) {
            existingUserIDs.add(userPermission.getAffected_user_id());
        }
        
        // delete any permissions that are not in the provided list
        userPermissionExample.clear();
        userPermissionExample.createCriteria().andAffected_user_idNotIn(userIDs);
        userPermissionDAO.deleteByExample(userPermissionExample);
        
        // finally, insert the new permissions
        for(UserPermission permission : permissions) {
            net.sourceforge.guacamole.net.auth.mysql.model.User dbAffectedUser = dbUserMap.get(permission.getObjectIdentifier());
            if(dbAffectedUser == null)
                throw new GuacamoleException("User '"  permission.getObjectIdentifier()  "' not found.");
            
            // the permission for this user already exists, we don't need to create it again
            if(existingUserIDs.contains(dbAffectedUser.getUser_id()))
                continue;
            
            UserPermissionKey newPermission = new UserPermissionKey();
            newPermission.setAffected_user_id(dbAffectedUser.getUser_id());
            newPermission.setPermission(permission.getType().name());
            newPermission.setUser_id(user.getUserID());
            userPermissionDAO.insert(newPermission);
        }
    }
    
    /**
     * Update all the permissions having to do with connections for a given user.
     * @param permissions
     * @param user 
     */
    private void updateConnectionPermissions(Iterable<ConnectionPermission> permissions, MySQLUser user) throws GuacamoleException {
        
        List<String> connectionnames = new ArrayList<String>();
        for(ConnectionPermission permission : permissions) {
            connectionnames.add(permission.getObjectIdentifier());
        }
            
        // find all the connections by connectionname
        ConnectionExample connectionExample = new ConnectionExample();
        connectionExample.createCriteria().andConnection_nameIn(connectionnames);
        List<net.sourceforge.guacamole.net.auth.mysql.model.Connection> dbConnections = connectionDAO.selectByExample(connectionExample);
        List<Integer> connectionIDs = new ArrayList<Integer>();
        
        Map<String, net.sourceforge.guacamole.net.auth.mysql.model.Connection> dbConnectionMap = new HashMap<String, net.sourceforge.guacamole.net.auth.mysql.model.Connection>();
        for(net.sourceforge.guacamole.net.auth.mysql.model.Connection dbConnection : dbConnections) {
            dbConnectionMap.put(dbConnection.getConnection_name(), dbConnection);
            connectionIDs.add(dbConnection.getConnection_id());
        }
        
        // find any connection permissions that may already exist
        ConnectionPermissionExample connectionPermissionExample = new ConnectionPermissionExample();
        connectionPermissionExample.createCriteria().andConnection_idIn(connectionIDs);
        List<ConnectionPermissionKey> existingPermissions = connectionPermissionDAO.selectByExample(connectionPermissionExample);
        Set<Integer> existingConnectionIDs = new HashSet<Integer>();
        for(ConnectionPermissionKey connectionPermission : existingPermissions) {
            existingConnectionIDs.add(connectionPermission.getConnection_id());
        }
        
        // delete any permissions that are not in the provided list
        connectionPermissionExample.clear();
        connectionPermissionExample.createCriteria().andConnection_idNotIn(connectionIDs);
        connectionPermissionDAO.deleteByExample(connectionPermissionExample);
        
        // finally, insert the new permissions
        for(ConnectionPermission permission : permissions) {
            net.sourceforge.guacamole.net.auth.mysql.model.Connection dbConnection = dbConnectionMap.get(permission.getObjectIdentifier());
            if(dbConnection == null)
                throw new GuacamoleException("Connection '"  permission.getObjectIdentifier()  "' not found.");
            
            // the permission for this connection already exists, we don't need to create it again
            if(existingConnectionIDs.contains(dbConnection.getConnection_id()))
                continue;
            
            ConnectionPermissionKey newPermission = new ConnectionPermissionKey();
            newPermission.setConnection_id(dbConnection.getConnection_id());
            newPermission.setPermission(permission.getType().name());
            newPermission.setConnection_id(user.getUserID());
            connectionPermissionDAO.insert(newPermission);
        }
    }
    
    /**
     * Update all system permissions for a given user.
     * @param permissions
     * @param user 
     */
    private void updateSystemPermissions(Iterable<SystemPermission> permissions, MySQLUser user) {
        List<String> systemPermissionTypes = new ArrayList<String>();
        for(SystemPermission permission : permissions) {
            String operation = permission.getType().name();
            if(permission instanceof ConnectionDirectoryPermission)
                systemPermissionTypes.add(operation  "_CONNECTION");
            else if(permission instanceof UserDirectoryPermission)
                systemPermissionTypes.add(operation  "_USER");
        }
        
        //delete all system permissions not in the list
        SystemPermissionExample systemPermissionExample = new SystemPermissionExample();
        systemPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID()).andPermissionNotIn(systemPermissionTypes);
        systemPermissionDAO.deleteByExample(systemPermissionExample);
        
        // find all existing system permissions
        systemPermissionExample.clear();
        systemPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID()).andPermissionIn(systemPermissionTypes);
        List<SystemPermissionKey> existingPermissions = systemPermissionDAO.selectByExample(systemPermissionExample);
        Set<String> existingPermissionTypes = new HashSet<String>();
        for(SystemPermissionKey existingPermission : existingPermissions) {
            existingPermissionTypes.add(existingPermission.getPermission());
        }
        
        // finally, insert any new system permissions for this user
        for(String systemPermissionType : systemPermissionTypes) {
            //do not insert the permission if it already exists 
            if(existingPermissionTypes.contains(systemPermissionType))
                continue;
            
            SystemPermissionKey newSystemPermission = new SystemPermissionKey();
            newSystemPermission.setUser_id(user.getUserID());
            newSystemPermission.setPermission(systemPermissionType);
            systemPermissionDAO.insert(newSystemPermission);
        }
    @Transactional
        //update the user in the database
        MySQLUser mySQLUser = getExistingMySQLUser(object);
        
        //update permissions in database
        updatePermissions(mySQLUser);
    @Transactional
        
        MySQLUser mySQLUser = getExistingMySQLUser(identifier);
        
        //delete all the user permissions in the database
        deleteAllPermissions(mySQLUser);
                
        //delete the user in the database
        userDAO.deleteByPrimaryKey(mySQLUser.getUserID());
    }
    
    /**
     * Delete all permissions associated with the provided user.
     * @param user 
     */
    private void deleteAllPermissions(MySQLUser user) {
        //delete all user permissions
        UserPermissionExample userPermissionExample = new UserPermissionExample();
        userPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID());
        userPermissionDAO.deleteByExample(userPermissionExample);
        
        //delete all connection permissions
        ConnectionPermissionExample connectionPermissionExample = new ConnectionPermissionExample();
        connectionPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID());
        connectionPermissionDAO.deleteByExample(connectionPermissionExample);
        
        //delete all system permissions
        SystemPermissionExample systemPermissionExample = new SystemPermissionExample();
        systemPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID());
        systemPermissionDAO.deleteByExample(systemPermissionExample);
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
     * @mbggenerated Tue Feb 12 20:35:54 PST 2013
 * @author James Muehlner
            return other.identifier == null;
            return other.identifier == null;
import net.sourceforge.guacamole.net.auth.permission.ConnectionDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.ConnectionPermission;
import net.sourceforge.guacamole.net.auth.permission.UserDirectoryPermission;
import net.sourceforge.guacamole.net.auth.permission.UserPermission;

 * A set of constants that useful for the MySQL-based authentication provider.
public final class MySQLConstants {
    /**
     * This class should not be instantiated.
     */
    private MySQLConstants() {}
    // Permission constants
    public static final String USER_READ = UserPermission.Type.READ.name();
    public static final String USER_UPDATE = UserPermission.Type.UPDATE.name();
    public static final String USER_DELETE = UserPermission.Type.DELETE.name();
    public static final String USER_ADMINISTER = UserPermission.Type.ADMINISTER.name();
    public static final String USER_CREATE = UserDirectoryPermission.Type.CREATE.name();
    public static final String CONNECTION_READ = ConnectionPermission.Type.READ.name();
    public static final String CONNECTION_UPDATE = ConnectionPermission.Type.UPDATE.name();
    public static final String CONNECTION_DELETE = ConnectionPermission.Type.DELETE.name();
    public static final String CONNECTION_ADMINISTER = ConnectionPermission.Type.ADMINISTER.name();
    public static final String CONNECTION_CREATE = ConnectionDirectoryPermission.Type.CREATE.name();
    public static final String SYSTEM_USER_CREATE = "USER_CREATE";
    public static final String SYSTEM_CONNECTION_CREATE = "CONNECTION_CREATE";
        return checkUserAccess(userID, affectedUserID, MySQLConstants.USER_READ);
    public boolean checkUserUpdateAccess(int userID, int affectedUserID) {
        return checkUserAccess(userID, affectedUserID, MySQLConstants.USER_UPDATE);
        return checkUserAccess(userID, affectedUserID, MySQLConstants.USER_DELETE);
        return checkUserAccess(userID, affectedUserID, MySQLConstants.USER_ADMINISTER);
        return checkUserAccess(userID, affectedUsername, MySQLConstants.USER_READ);
    public boolean checkUserUpdateAccess(int userID, String affectedUsername) {
        return checkUserAccess(userID, affectedUsername, MySQLConstants.USER_UPDATE);
        return checkUserAccess(userID, affectedUsername, MySQLConstants.USER_DELETE);
        return checkUserAccess(userID, affectedUsername, MySQLConstants.USER_ADMINISTER);
        return getUsers(userID, MySQLConstants.USER_ADMINISTER);
        return getUsers(userID, MySQLConstants.USER_DELETE);
    public List<MySQLUser> getUpdateableUsers(int userID) {
        return getUsers(userID, MySQLConstants.USER_UPDATE);
        return getUsers(userID, MySQLConstants.USER_READ);
        return checkConnectionAccess(userID, affectedConnectionID, MySQLConstants.CONNECTION_READ);
    public boolean checkConnectionUpdateAccess(int userID, int affectedConnectionID) {
        return checkConnectionAccess(userID, affectedConnectionID, MySQLConstants.CONNECTION_UPDATE);
        return checkConnectionAccess(userID, affectedConnectionID, MySQLConstants.CONNECTION_DELETE);
        return checkConnectionAccess(userID, affectedConnectionID, MySQLConstants.CONNECTION_ADMINISTER);
        return checkConnectionAccess(userID, affectedConnectionname, MySQLConstants.CONNECTION_READ);
    public boolean checkConnectionUpdateAccess(int userID, String affectedConnectionname) {
        return checkConnectionAccess(userID, affectedConnectionname, MySQLConstants.CONNECTION_UPDATE);
        return checkConnectionAccess(userID, affectedConnectionname, MySQLConstants.CONNECTION_DELETE);
        return checkConnectionAccess(userID, affectedConnectionname, MySQLConstants.CONNECTION_ADMINISTER);
        return getConnections(userID, MySQLConstants.CONNECTION_ADMINISTER);
        return getConnections(userID, MySQLConstants.CONNECTION_DELETE);
    public List<MySQLConnection> getUpdateableConnections(int userID) {
        return getConnections(userID, MySQLConstants.CONNECTION_UPDATE);
        return getConnections(userID, MySQLConstants.CONNECTION_READ);
        return checkSystemPermission(userID, MySQLConstants.SYSTEM_USER_CREATE);
        return checkSystemPermission(userID, MySQLConstants.SYSTEM_CONNECTION_CREATE);
     * @return all permissions a user has. 
            if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_USER_CREATE))
            else if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_CONNECTION_CREATE))
 * A set of constants that are useful for the MySQL-based authentication provider.
            User user = new DummyUser();
            user.setUsername(username);
        permissionCheckUtility.verifyUserReadAccess(this.user.getUserID(), identifier);
        permissionCheckUtility.verifyCreateUserPermission(this.user.getUserID());
        permissionCheckUtility.verifyUserUpdateAccess(user.getUserID(), object.getUsername());
        
        permissionCheckUtility.verifyUserUpdateAccess(this.user.getUserID(), object.getUsername());
        permissionCheckUtility.verifyUserDeleteAccess(this.user.getUserID(), identifier);
import net.sourceforge.guacamole.net.auth.mysql.GuacamolePermissionException;
    /**
     * Verifies that the user has read access to the given user. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedUserID
     * @throws GuacamolePermissionException
     */
    public void verifyUserReadAccess(int userID, int affectedUserID) throws GuacamolePermissionException {
        if(!checkUserReadAccess(userID, affectedUserID))
            throw new GuacamolePermissionException("User "  userID  " does not have read access to user "  affectedUserID);
    }
    
    /**
     * Verifies that the user has update access to the given user. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedUserID
     * @throws GuacamolePermissionException
     */
    public void verifyUserUpdateAccess(int userID, int affectedUserID) throws GuacamolePermissionException {
        if(!checkUserUpdateAccess(userID, affectedUserID))
            throw new GuacamolePermissionException("User "  userID  " does not have update access to user "  affectedUserID);
    }
    
    /**
     * Verifies that the user has delete access to the given user. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedUserID
     * @throws GuacamolePermissionException
     */
    public void verifyUserDeleteAccess(int userID, int affectedUserID) throws GuacamolePermissionException {
        if(!checkUserDeleteAccess(userID, affectedUserID))
            throw new GuacamolePermissionException("User "  userID  " does not have delete access to user "  affectedUserID);
    }
    
    /**
     * Verifies that the user has administer access to the given user. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedUserID
     * @throws GuacamolePermissionException
     */
    public void verifyUserAdministerAccess(int userID, int affectedUserID) throws GuacamolePermissionException {
        if(!checkUserAdministerAccess(userID, affectedUserID))
            throw new GuacamolePermissionException("User "  userID  " does not have administer access to user "  affectedUserID);
    }
    
    /**
     * Verifies that the user has read access to the given user. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedUsername
     * @throws GuacamolePermissionException
     */
    public void verifyUserReadAccess(int userID, String affectedUsername) throws GuacamolePermissionException {
        if(!checkUserReadAccess(userID, affectedUsername))
            throw new GuacamolePermissionException("User "  userID  " does not have read access to user '"  affectedUsername  "'");
    }
    
    /**
     * Verifies that the user has update access to the given user. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedUsername
     * @throws GuacamolePermissionException
     */
    public void verifyUserUpdateAccess(int userID, String affectedUsername) throws GuacamolePermissionException {
        if(!checkUserUpdateAccess(userID, affectedUsername))
            throw new GuacamolePermissionException("User "  userID  " does not have update access to user '"  affectedUsername  "'");
    }
    
    /**
     * Verifies that the user has delete access to the given user. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedUsername
     * @throws GuacamolePermissionException
     */
    public void verifyUserDeleteAccess(int userID, String affectedUsername) throws GuacamolePermissionException {
        if(!checkUserDeleteAccess(userID, affectedUsername))
            throw new GuacamolePermissionException("User "  userID  " does not have delete access to user '"  affectedUsername  "'");
    }
    
    /**
     * Verifies that the user has administer access to the given user. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedUsername
     * @throws GuacamolePermissionException
     */
    public void verifyUserAdministerAccess(int userID, String affectedUsername) throws GuacamolePermissionException {
        if(!checkUserAdministerAccess(userID, affectedUsername))
            throw new GuacamolePermissionException("User "  userID  " does not have administer access to user '"  affectedUsername  "'");
    }
    
    /**
     * Checks if the user has read access to the given user.
     * @param userID
     * @param affectedUserID
     * @return true if the user has access to this user.
     */
    /**
     * Checks if the user has update access to the given user.
     * @param userID
     * @param affectedUserID
     * @return true if the user has access to this user.
     */
    /**
     * Checks if the user has delete access to the given user.
     * @param userID
     * @param affectedUserID
     * @return true if the user has access to this user.
     */
    /**
     * Checks if the user has administer access to the given user.
     * @param userID
     * @param affectedUserID
     * @return true if the user has access to this user.
     */
    /**
     * Checks if the user has read access to the given user.
     * @param userID
     * @param affectedUsername
     * @return true if the user has access to this user.
     */
    /**
     * Checks if the user has update access to the given user.
     * @param userID
     * @param affectedUsername
     * @return true if the user has access to this user.
     */
    /**
     * Checks if the user has delete access to the given user.
     * @param userID
     * @param affectedUsername
     * @return true if the user has access to this user.
     */
    /**
     * Checks if the user has administer access to the given user.
     * @param userID
     * @param affectedUsername
     * @return true if the user has access to this user.
     */
    /**
     * Verifies that the user has read access to the given connection. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedConnectionID
     * @throws GuacamolePermissionException
     */
    public void verifyConnectionReadAccess(int userID, int affectedConnectionID) throws GuacamolePermissionException {
        if(!checkConnectionReadAccess(userID, affectedConnectionID))
            throw new GuacamolePermissionException("User "  userID  " does not have read access to connection "  affectedConnectionID);
    }
    
    /**
     * Verifies that the user has update access to the given connection. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedConnectionID
     * @throws GuacamolePermissionException
     */
    public void verifyConnectionUpdateAccess(int userID, int affectedConnectionID) throws GuacamolePermissionException {
        if(!checkConnectionUpdateAccess(userID, affectedConnectionID))
            throw new GuacamolePermissionException("User "  userID  " does not have update access to connection "  affectedConnectionID);
    }
    
    /**
     * Verifies that the user has delete access to the given connection. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedConnectionID
     * @throws GuacamolePermissionException
     */
    public void verifyConnectionDeleteAccess(int userID, int affectedConnectionID) throws GuacamolePermissionException {
        if(!checkConnectionDeleteAccess(userID, affectedConnectionID))
            throw new GuacamolePermissionException("User "  userID  " does not have delete access to connection "  affectedConnectionID);
    }
    
    /**
     * Verifies that the user has administer access to the given connection. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedConnectionID
     * @throws GuacamolePermissionException
     */
    public void verifyConnectionAdministerAccess(int userID, int affectedConnectionID) throws GuacamolePermissionException {
        if(!checkConnectionAdministerAccess(userID, affectedConnectionID))
            throw new GuacamolePermissionException("User "  userID  " does not have administer access to connection "  affectedConnectionID);
    }
    
    /**
     * Verifies that the user has read access to the given connection. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedConnectionName
     * @throws GuacamolePermissionException
     */
    public void verifyConnectionReadAccess(int userID, String affectedConnectionName) throws GuacamolePermissionException {
        if(!checkConnectionReadAccess(userID, affectedConnectionName))
            throw new GuacamolePermissionException("User "  userID  " does not have read access to connection '"  affectedConnectionName  "'");
    }
    
    /**
     * Verifies that the user has update access to the given connection. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedConnectionName
     * @throws GuacamolePermissionException
     */
    public void verifyConnectionUpdateAccess(int userID, String affectedConnectionName) throws GuacamolePermissionException {
        if(!checkConnectionUpdateAccess(userID, affectedConnectionName))
            throw new GuacamolePermissionException("User "  userID  " does not have update access to connection '"  affectedConnectionName  "'");
    }
    
    /**
     * Verifies that the user has delete access to the given connection. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedConnectionName
     * @throws GuacamolePermissionException
     */
    public void verifyConnectionDeleteAccess(int userID, String affectedConnectionName) throws GuacamolePermissionException {
        if(!checkConnectionDeleteAccess(userID, affectedConnectionName))
            throw new GuacamolePermissionException("User "  userID  " does not have delete access to connection '"  affectedConnectionName  "'");
    }
    
    /**
     * Verifies that the user has administer access to the given connection. If not, throws a GuacamolePermissionException.
     * @param userID
     * @param affectedConnectionName
     * @throws GuacamolePermissionException
     */
    public void verifyConnectionAdministerAccess(int userID, String affectedConnectionName) throws GuacamolePermissionException {
        if(!checkConnectionAdministerAccess(userID, affectedConnectionName))
            throw new GuacamolePermissionException("User "  userID  " does not have administer access to connection '"  affectedConnectionName  "'");
    }
    
    /**
     * Checks if the user has read access to the given connection.
     * @param userID
     * @param affectedConnectionID
     * @return true if the user has access to this connection.
     */
    /**
     * Checks if the user has update access to the given connection.
     * @param userID
     * @param affectedConnectionID
     * @return true if the user has access to this connection.
     */
    /**
     * Checks if the user has delete access to the given connection.
     * @param userID
     * @param affectedConnectionID
     * @return true if the user has access to this connection.
     */
    /**
     * Checks if the user has administer access to the given connection.
     * @param userID
     * @param affectedConnectionID
     * @return true if the user has access to this connection.
     */
    /**
     * Checks if the user has read access to the given connection.
     * @param userID
     * @param affectedConnectionName
     * @return true if the user has access to this connection.
     */
    public boolean checkConnectionReadAccess(int userID, String affectedConnectionName) {
        return checkConnectionAccess(userID, affectedConnectionName, MySQLConstants.CONNECTION_READ);
    /**
     * Checks if the user has update access to the given connection.
     * @param userID
     * @param affectedConnectionName
     * @return true if the user has access to this connection.
     */
    public boolean checkConnectionUpdateAccess(int userID, String affectedConnectionName) {
        return checkConnectionAccess(userID, affectedConnectionName, MySQLConstants.CONNECTION_UPDATE);
    /**
     * Checks if the user has delete access to the given connection.
     * @param userID
     * @param affectedConnectionID
     * @return true if the user has access to this connection.
     */
    /**
     * Checks if the user has administer access to the given connection.
     * @param userID
     * @param affectedConnectionName
     * @return true if the user has access to this connection.
     */
    public boolean checkConnectionAdministerAccess(int userID, String affectedConnectionName) {
        return checkConnectionAccess(userID, affectedConnectionName, MySQLConstants.CONNECTION_ADMINISTER);
    public void verifyCreateUserPermission(int userID) throws GuacamolePermissionException {
        if(!checkCreateUserPermission(userID))
            throw new GuacamolePermissionException("User "  userID  " does not have permission to create users.");
    }
    
    public void verifyCreateConnectionPermission(int userID) throws GuacamolePermissionException {
        if(!checkCreateConnectionPermission(userID))
            throw new GuacamolePermissionException("User "  userID  " does not have permission to create connections.");
    }
    
import java.util.Collections;
import java.util.Set;
    /**
     * Removes the value set for the parameter with the given name.
     * 
     * @param name The name of the parameter to remove the value of.
     */
    public void unsetParameter(String name) {
        parameters.remove(name);
    }
    
    /**
     * Returns a set of all currently defined parameter names. Each name
     * corresponds to a parameter that has a value set on this
     * GuacamoleConfiguration via setParameter().
     * 
     * @return A set of all currently defined parameter names.
     */
    public Set<String> getParameterNames() {
        return Collections.unmodifiableSet(parameters.keySet());
    }

import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
                    GuacamoleConfiguration config = connection.getConfiguration();
                    for (String name : config.getParameterNames()) {
    }
    
    /**
     * Get the ID of the underlying connection record.
     * @return the ID of the underlying connection
     */
    public int getConnectionID() {
        return connection.getConnection_id();
    }
    
    /**
     * Get the underlying connection database record.
     * @return the underlying connection record.
     */
    public net.sourceforge.guacamole.net.auth.mysql.model.Connection getConnection() {
        return connection;
    }
    @Override
    public boolean equals(Object other) {
        if(!(other instanceof MySQLConnection))
            return false;
        return ((MySQLConnection)other).getConnectionID() == this.getConnectionID();
    }
    
    @Override
    public boolean equals(Object other) {
        if(!(other instanceof MySQLUser))
            return false;
        return ((MySQLUser)other).getUserID() == this.getUserID();
    }
        Set<MySQLUser> users = permissionCheckUtility.getReadableUsers(user.getUserID());
        // Get the list of all the users and connections that the user performing the user save action has.
        // Need to make sure the user saving this user has permission to administrate all the objects in the permission list.
        Set<Integer> administerableUsers = permissionCheckUtility.getAdministerableUserIDs(this.user.getUserID());
        Set<Integer> administerableConnections = permissionCheckUtility.getAdministerableConnectionIDs(this.user.getUserID());
        
        updateUserPermissions(userPermissions, user, administerableUsers);
        updateConnectionPermissions(connectionPermissions, user, administerableConnections);
    private void updateUserPermissions(Iterable<UserPermission> permissions, MySQLUser user, Set<Integer> administerableUsers) throws GuacamoleException {
        List<UserPermissionKey> permissionsToDelete = userPermissionDAO.selectByExample(userPermissionExample);
        
        // verify that the user actually has permission to administrate every one of these users
        for(UserPermissionKey permissionToDelete : permissionsToDelete) {
            if(!administerableUsers.contains(permissionToDelete.getAffected_user_id()))
                throw new GuacamolePermissionException("User '"  this.user.getUsername()  "' does not have permission to administrate user "  permissionToDelete.getAffected_user_id());
        }
        
            
            // verify that the user actually has permission to administrate every one of these users
            if(!administerableUsers.contains(dbAffectedUser.getUser_id()))
                throw new GuacamolePermissionException("User '"  this.user.getUsername()  "' does not have permission to administrate user "  dbAffectedUser.getUser_id());
            
    private void updateConnectionPermissions(Iterable<ConnectionPermission> permissions, MySQLUser user, Set<Integer> administerableConnections) throws GuacamoleException {
        
        //make sure the user has permission to administrate each of these connections
        List<ConnectionPermissionKey> connectionPermissionsToDelete = connectionPermissionDAO.selectByExample(connectionPermissionExample);
        
        for(ConnectionPermissionKey connectionPermissionToDelete : connectionPermissionsToDelete) {
            if(!administerableConnections.contains(connectionPermissionToDelete.getConnection_id()))
                throw new GuacamolePermissionException("User '"  this.user.getUsername()  "' does not have permission to administrate connection "  connectionPermissionToDelete.getConnection_id());
        }
        
            if(!administerableConnections.contains(dbConnection.getConnection_id()))
                throw new GuacamolePermissionException("User '"  this.user.getUsername()  "' does not have permission to administrate connection "  dbConnection.getConnection_id());
        
            
import com.google.common.collect.Lists;
     * Find the list of all user IDs a user has permission to administer.
     * @param userID
     * @return the list of all user IDs this user has administer access to
     */
    public Set<Integer> getAdministerableUserIDs(int userID) {
        return getUserIDs(userID, MySQLConstants.USER_ADMINISTER);
    }
    
    /**
     * Find the list of all user IDs a user has permission to delete.
     * @param userID
     * @return the list of all user IDs this user has delete access to
     */
    public Set<Integer> getDeletableUserIDs(int userID) {
        return getUserIDs(userID, MySQLConstants.USER_DELETE);
    }
    
    /**
     * Find the list of all user IDs a user has permission to write.
     * @param userID
     * @return the list of all user IDs this user has write access to
     */
    public Set<Integer> getUpdateableUserIDs(int userID) {
        return getUserIDs(userID, MySQLConstants.USER_UPDATE);
    }
    
    /**
     * Find the list of all user IDs a user has permission to read.
     * @param userID
     * @return the list of all user IDs this user has read access to
     */
    public Set<Integer> getReadableUserIDs(int userID) {
        return getUserIDs(userID, MySQLConstants.USER_READ);
    }
    
    /**
    public Set<MySQLUser> getAdministerableUsers(int userID) {
    public Set<MySQLUser> getDeletableUsers(int userID) {
    public Set<MySQLUser> getUpdateableUsers(int userID) {
    public Set<MySQLUser> getReadableUsers(int userID) {
    private Set<MySQLUser> getUsers(int userID, String permissionType) {
        Set<Integer> affectedUserIDs = getUserIDs(userID, permissionType);
        example.createCriteria().andUser_idIn(Lists.newArrayList(affectedUserIDs));
        Set<MySQLUser> affectedUsers = new HashSet<MySQLUser>();
    private Set<Integer> getUserIDs(int userID, String permissionType) {
        Set<Integer> userIDs = new HashSet<Integer>();
     * Find the list of all connection IDs a user has permission to administer.
     * @param userID
     * @return the list of all connection IDs this user has administer access to
    public Set<Integer> getAdministerableConnectionIDs(int userID) {
        return getConnectionIDs(userID, MySQLConstants.CONNECTION_ADMINISTER);
    }
    
    /**
     * Find the list of all connection IDs a user has permission to delete.
     * @param userID
     * @return the list of all connection IDs this user has delete access to
     */
    public Set<Integer> getDeletableConnectionIDs(int userID) {
        return getConnectionIDs(userID, MySQLConstants.CONNECTION_DELETE);
    }
    
    /**
     * Find the list of all connection IDs a user has permission to write.
     * @param userID
     * @return the list of all connection IDs this user has write access to
     */
    public Set<Integer> getUpdateableConnectionIDs(int userID) {
        return getConnectionIDs(userID, MySQLConstants.CONNECTION_UPDATE);
    }
    
    /**
     * Find the list of all connection IDs a user has permission to read.
     * @param userID
     * @return the list of all connection IDs this user has ready access to
     */
    public Set<Integer> getReadableConnectionIDs(int userID) {
        return getConnectionIDs(userID, MySQLConstants.CONNECTION_READ);
    }
    
    /**
     * Find the list of all connections a user has permission to administer.
     * @param userID
     * @return the list of all connections this user has administer access to
     */
    public Set<MySQLConnection> getAdministerableConnections(int userID) {
     * @param userID
     * @return the list of all connections this user has delete access to
    public Set<MySQLConnection> getDeletableConnections(int userID) {
     * @param userID
     * @return the list of all connections this user has write access to
    public Set<MySQLConnection> getUpdateableConnections(int userID) {
     * @param userID
     * @return the list of all connections this user has read access to
    public Set<MySQLConnection> getReadableConnections(int userID) {
    private Set<MySQLConnection> getConnections(int userID, String permissionType) {
        Set<Integer> affectedConnectionIDs = getConnectionIDs(userID, permissionType);
        example.createCriteria().andConnection_idIn(Lists.newArrayList(affectedConnectionIDs));
        Set<MySQLConnection> affectedConnections = new HashSet<MySQLConnection>();
    private Set<Integer> getConnectionIDs(int userID, String permissionType) {
        Set<Integer> connectionIDs = new HashSet<Integer>();
        
        //finally, give the current user full access to the newly created user.
        UserPermissionKey newUserPermission = new UserPermissionKey();
        newUserPermission.setUser_id(this.user.getUserID());
        newUserPermission.setAffected_user_id(mySQLUser.getUserID());
        newUserPermission.setPermission(MySQLConstants.USER_READ);
        userPermissionDAO.insert(newUserPermission);
        newUserPermission.setPermission(MySQLConstants.USER_UPDATE);
        userPermissionDAO.insert(newUserPermission);
        newUserPermission.setPermission(MySQLConstants.USER_DELETE);
        userPermissionDAO.insert(newUserPermission);
        newUserPermission.setPermission(MySQLConstants.USER_ADMINISTER);
        userPermissionDAO.insert(newUserPermission);
    private void deleteAllPermissions(MySQLUser user) throws GuacamolePermissionException {
        // Get the list of all the users and connections that the user performing the user save action has.
        // Need to make sure the user saving this user has permission to administrate all the objects in the permission list.
        Set<Integer> administerableUsers = permissionCheckUtility.getAdministerableUserIDs(this.user.getUserID());
        Set<Integer> administerableConnections = permissionCheckUtility.getAdministerableConnectionIDs(this.user.getUserID());
        
        List<UserPermissionKey> permissionsToDelete = userPermissionDAO.selectByExample(userPermissionExample);
        
        // verify that the user actually has permission to administrate every one of these users
        for(UserPermissionKey permissionToDelete : permissionsToDelete) {
            if(!administerableUsers.contains(permissionToDelete.getAffected_user_id()))
                throw new GuacamolePermissionException("User '"  this.user.getUsername()  "' does not have permission to administrate user "  permissionToDelete.getAffected_user_id());
        }
        
        
        //make sure the user has permission to administrate each of these connections
        List<ConnectionPermissionKey> connectionPermissionsToDelete = connectionPermissionDAO.selectByExample(connectionPermissionExample);
        
        for(ConnectionPermissionKey connectionPermissionToDelete : connectionPermissionsToDelete) {
            if(!administerableConnections.contains(connectionPermissionToDelete.getConnection_id()))
                throw new GuacamolePermissionException("User '"  this.user.getUsername()  "' does not have permission to administrate connection "  connectionPermissionToDelete.getConnection_id());
        }
        
     * Delete all permissions associated with the provided user. This is only used when deleting a user.
import java.util.List;
    /**
     * Returns a list of ConnectionRecords representing the usage history
     * of this Connection, including any active users. ConnectionRecords
     * in this list will be sorted in descending order of end time (active
     * connections are first), and then in descending order of start time
     * (newer connections are first).
     * 
     * @return A list of ConnectionRecrods representing the usage history
     *         of this Connection.
     * 
     * @throws GuacamoleException If an error occurs while reading the history
     *                            of this connection, or if permission is
     *                            denied.
     */
    public List<ConnectionRecord> getHistory() throws GuacamoleException;
            
import java.util.Collections;
import java.util.List;
import net.sourceforge.guacamole.net.auth.ConnectionRecord;
    @Override
    public List<ConnectionRecord> getHistory() throws GuacamoleException {
        return Collections.EMPTY_LIST;
    }

import java.util.List;
import net.sourceforge.guacamole.net.auth.ConnectionRecord;
    @Override
    public List<ConnectionRecord> getHistory() throws GuacamoleException {
        throw new UnsupportedOperationException("History unsuppported in DummyConnection.");
    }

import net.sourceforge.guacamole.net.auth.ConnectionRecord;
                // Write history
                xml.writeStartElement("history");
                for (ConnectionRecord record : connection.getHistory()) {
                    xml.writeStartElement("record");

                    // Start date
                    xml.writeAttribute("start",
                        Long.toString(record.getStartDate().getTime()));

                    // End date
                    if (record.getEndDate() != null)
                        xml.writeAttribute("end",
                            Long.toString(record.getEndDate().getTime()));
                    
                    // User involved
                    xml.writeCharacters(record.getUser().getUsername());

                    xml.writeEndElement();
                }
                xml.writeEndElement();

    public List<? extends ConnectionRecord> getHistory() throws GuacamoleException;
import net.sourceforge.guacamole.net.auth.mysql.utility.PermissionCheckUtility;
import net.sourceforge.guacamole.net.auth.mysql.utility.ProviderUtility;
                    bind(UserDirectory.class);
                    bind(ProviderUtility.class);
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is guacamole-auth-mysql.
 *
 * The Initial Developer of the Original Code is
 * James Muehlner.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
import net.sourceforge.guacamole.net.auth.ConnectionRecord;
import net.sourceforge.guacamole.net.auth.mysql.utility.ProviderUtility;
    @Inject
    ProviderUtility providerUtility;
    
    private GuacamoleConfiguration configuration;
    
     * Create a new MySQLConnection from this new connection. This is a connection that has not yet been inserted.
     * @param connection 
     */
    public void initNew(Connection connection) {
        configuration = connection.getConfiguration();
        this.connection.setConnection_name(connection.getIdentifier());
        this.configuration = connection.getConfiguration();
    }
    
    /**
    public void initExisting(String connectionName) throws GuacamoleException {
        return configuration;
        this.configuration = config;
    
    @Override
    public List<? extends ConnectionRecord> getHistory() throws GuacamoleException {
        return providerUtility.getExistingMySQLConnectionRecords(connection.getConnection_id());
    }
        if(userList.isEmpty())
 * The MySQL representation of a UserContext.
    @Inject
    private UserDirectory userDirectory;
    
    @Inject
    private ConnectionDirectory connectionDirectory;
        connectionDirectory.init(user);
        return connectionDirectory;
import net.sourceforge.guacamole.net.auth.mysql.utility.ProviderUtility;
    ProviderUtility providerUtility;
        return providerUtility.getExistingMySQLUser(identifier);
        MySQLUser mySQLUser = providerUtility.getNewMySQLUser(object);
        MySQLUser mySQLUser = providerUtility.getExistingMySQLUser(object);
        MySQLUser mySQLUser = providerUtility.getExistingMySQLUser(identifier);
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated do_not_delete_during_merge Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
     * @mbggenerated Tue Feb 19 23:09:22 PST 2013
        boolean idsAreEqual = ((MySQLConnection)other).getConnectionID() == this.getConnectionID();
        // they are both new, check if they have the same name
        if(idsAreEqual && this.getConnectionID() == 0)
            return this.getIdentifier().equals(((MySQLConnection)other).getIdentifier());
        return idsAreEqual;
    }

    @Override
    public int hashCode() {
        int hash = 7;
        hash = 73 * hash  getConnectionID();
        hash = 73 * hash  getIdentifier().hashCode();
        return hash;
        boolean idsAreEqual = ((MySQLUser)other).getUserID() == this.getUserID();
        // they are both new, check if they have the same name
        if(idsAreEqual && this.getUserID() == 0)
            return this.getUsername().equals(((MySQLUser)other).getUsername());
        return idsAreEqual;
    }

    @Override
    public int hashCode() {
        int hash = 7;
        hash = 73 * hash  getUserID();
        hash = 73 * hash  getUsername().hashCode();
        return hash;
    /**
     * The location within the received data buffer that parsing should begin
     * when more data is read.
     */
    /**
     * The buffer holding all received, unparsed data.
     */

    /**
     * The number of characters currently used within the data buffer. All
     * other characters within the buffer are free space available for
     * future reads.
     */
    /**
     * The UUID associated with this tunnel. Every tunnel must have a
     * corresponding UUID such that tunnel read/write requests can be
     * directed to the proper tunnel.
     */

    /**
     * The GuacamoleSocket that tunnel should use for communication on
     * behalf of the connecting user.
     */
    /**
     * Lock acquired when a read operation is in progress.
     */

    /**
     * Lock acquired when a write operation is in progress.
     */
    /**
     * Logger for this class.
     */
    /**
     * The GuacamoleReader this socket should read from.
     */

    /**
     * The GuacamoleWriter this socket should write to.
     */
    /**
     * The number of milliseconds to wait for data on the TCP socket before
     * timing out.
     */

    /**
     * The TCP socket that the GuacamoleReader and GuacamoleWriter exposed
     * by this class should affect.
     */
    /**
     * The wrapped socket.
     */

    /**
     * The configuration to use when performing the Guacamole protocol
     * handshake.
     */
    /**
     * Identifier unique to this version of GuacamoleConfiguration.
     */
    /**
     * The name of the protocol associated with this configuration.
     */

    /**
     * Map of all associated parameter values, indexed by parameter name.
     */
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

     * @param opcode The opcode of the instruction to create.
    /**
     * Logger for this class.
     */
    /**
     * Logger for this class.
     */
    /**
     * Map of all currently attached tunnels, indexed by tunnel UUID.
     */
    public void setConfiguration(GuacamoleConfiguration config);
    /**
     * Unique identifier associated with this specific version of Credentials.
     */
    /**
     * GuacamoleHome is a utility class and cannot be instantiated.
     */
    /**
     * GuacamoleProperties is a utility class and cannot be instantiated.
     */
    /**
     * All properties read from guacamole.properties when this class was first
     * used.
     */

    /**
     * Any error encountered when reading guacamole.properties was last
     * attempted.
     */
    public void setConfiguration(GuacamoleConfiguration config) {
    /**
     * Logger for this class.
     */
    /**
     * Logger for this class.
     */
    /**
     * Logger for this class.
     */
     * @param tunnel The tunnel being connected.
     * @param tunnel The tunnel being closed.
    /**
     * Logger for this class.
     */
    /**
     * Class loader which will load classes from the classpath specified
     * in guacamole.properties.
     */
    /**
     * Any exception that occurs while the class loader is being instantiated.
     */

    /**
     * Singleton instance of the GuacamoleClassLoader.
     */
    /**
     * Creates a new GuacamoleClassLoader which reads classes from the given
     * directory.
     * 
     * @param libDirectory The directory to load classes from.
     * @throws GuacamoleException If the file given is not a director, or if
     *                            an error occurs while constructing the URL
     *                            for the backing classloader.
     */
    /**
     * Logger for this class.
     */
     * The name of the parameter.
 *
 * @author Michael Jumper

        // If null, equal only if this username is null
     *
     *

 *
     *
     *
     *
     *

     *
     *

 *
     *
     *
     *
     *
     *

 *
     *
     *

     *
     *

     *
     *

     *
     *

 *
 * @author Michael Jumper
     *
     *
     *
     *
     *
     *

     *
     *

     *
     *
     *
     *
 *
     *
     *
     *

     *
     *
     */
 *
     *

 *
     *

 *
     *

 *


 *

 *
     *

 *
     *
 *
public abstract class SimpleAuthenticationProvider




 *


     *


 *
public class SimpleConnectionDirectory
     *


 *


     *



 *


     *



 *
     *
 *

     *

 *




        // Send size


     *
     *
     *

     *



     *
     *
     *


            // Get authorized connection



     *
 *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *

     *
 *

     *
     *












 *
     *
     *
     *
     *

        // Attempt to get connections

            // Get self



                // Get connection











     *
     *
    private String toString(SystemPermission.Type type)

     *
     *
    private String toString(ObjectPermission.Type type)







                    // Write permission

                    // Write permission

                    // Write permission

                    // Write permission





        // Get username


            // Remove user



     *
     *
     *
     *





                // Write user







     *


        // Update
        // Delete


     *


        // Update
        // Delete








 *

     *

     *






         *
         *
         *

 *
 * @author Mike Jumper
     *

     *

 *
 * @author Mike Jumper

     *




     *

 *
 * @author Mike Jumper


     *


     *
     *

 *
 * @author Mike Jumper


     *

 *
 * @author Mike Jumper

     *

 *
 * @author Mike Jumper





     *

}
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Map;
import java.util.TreeMap;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;

               .append(HEX_CHARS[ b & 0x0F      ]);
import java.util.Deque;
    private Deque<DocumentHandlerState> stack =
import java.util.Deque;
        Deque<String> elements = new LinkedList<String>();
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import net.sourceforge.guacamole.GuacamoleClientException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.GuacamoleResourceNotFoundException;
import net.sourceforge.guacamole.GuacamoleSecurityException;
import net.sourceforge.guacamole.GuacamoleServerException;
     * property in guacamole.properties, if any. If no value is found, the
     * provided default value is returned.
     *
     * @param <Type> The type that the given property is parsed into.
     * @param property The property to read from guacamole.properties.
     * @param defaultValue The value to return if no value was given in
     *                     guacamole.properties.
     * @return The parsed value of the property as read from
     *         guacamole.properties, or the provided default value if no value
     *         was found.
     * @throws GuacamoleException If an error occurs while parsing the value
     *                            for the given property in
     *                            guacamole.properties.
     */
    public static <Type> Type getProperty(GuacamoleProperty<Type> property,
            Type defaultValue) throws GuacamoleException {

        Type value = getProperty(property);
        if (value == null)
            return defaultValue;

        return value;

    }

    /**
     * Given a GuacamoleProperty, parses and returns the value set for that
import com.google.common.collect.Lists;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionPermissionExample;






     * @param user





     * @param connection
        example.createCriteria().andConnection_idEqualTo(mySQLConnection.getConnectionID());



            String parameterValue = configuration.getParameter(parameterName);
            if(existingConfiguration.containsKey(parameterName)) {
                String existingValue = existingConfiguration.get(parameterName);
                // the value is different; we'll have to update this one in the database
                if(!parameterValue.equals(existingValue)) {
                    ConnectionParameter parameterToUpdate = new ConnectionParameter();
                    parameterToUpdate.setConnection_id(mySQLConnection.getConnectionID());
                    parameterToUpdate.setParameter_name(parameterName);
                    parameterToUpdate.setParameter_value(parameterValue);
                    parametersToUpdate.add(parameterToUpdate);
                }
            } else {
                // the value is new, we need to insert it
                ConnectionParameter parameterToInsert = new ConnectionParameter();
                parameterToInsert.setConnection_id(mySQLConnection.getConnectionID());
                parameterToInsert.setParameter_name(parameterName);
                parameterToInsert.setParameter_value(parameterValue);
                parametersToInsert.add(parameterToInsert);
            }
        }

        // First, delete all parameters that are not in the new configuration.
        example.clear();
        example.createCriteria().
            andConnection_idEqualTo(mySQLConnection.getConnectionID()).
            andParameter_nameNotIn(Lists.newArrayList(existingConfiguration.keySet()));

        //Second, update all the parameters that need to be modified.
        for(ConnectionParameter parameter : parametersToUpdate) {
            example.clear();
            example.createCriteria().
                andConnection_idEqualTo(mySQLConnection.getConnectionID()).
                andParameter_nameEqualTo(parameter.getParameter_name());

            connectionParameterDAO.updateByExample(parameter, example);
        }

        //Finally, insert any new parameters.
        for(ConnectionParameter parameter : parametersToInsert) {
            example.clear();
            example.createCriteria().
                andConnection_idEqualTo(mySQLConnection.getConnectionID()).
                andParameter_nameEqualTo(parameter.getParameter_name());

            connectionParameterDAO.insert(parameter);
        permissionCheckUtility.verifyConnectionUpdateAccess(this.user.getUserID(), object.getIdentifier());

        MySQLConnection mySQLConnection = providerUtility.getExistingMySQLConnection(object);
        connectionDAO.updateByPrimaryKey(mySQLConnection.getConnection());

        updateConfigurationValues(mySQLConnection);
        permissionCheckUtility.verifyConnectionDeleteAccess(this.user.getUserID(), identifier);

        MySQLConnection mySQLConnection = providerUtility.getExistingMySQLConnection(identifier);

        // delete all configuration values
        ConnectionParameterExample connectionParameterExample = new ConnectionParameterExample();
        connectionParameterExample.createCriteria().andConnection_idEqualTo(mySQLConnection.getConnectionID());
        connectionParameterDAO.deleteByExample(connectionParameterExample);
        
        // delete all permissions that refer to this connection
        ConnectionPermissionExample connectionPermissionExample = new ConnectionPermissionExample();
        connectionPermissionExample.createCriteria().andConnection_idEqualTo(mySQLConnection.getConnectionID());
        connectionPermissionDAO.deleteByExample(connectionPermissionExample);

        // delete the connection itself
        connectionDAO.deleteByPrimaryKey(mySQLConnection.getConnectionID());


import net.sourceforge.guacamole.net.auth.mysql.utility.ConfigurationTranslationUtility;

    private ActiveConnectionSet activeConnectionSet = new ActiveConnectionSet();



        //set the mysql properties for MyBatis.
        // Set up Guice injector.
                    bind(ConfigurationTranslationUtility.class);
                    bind(ActiveConnectionSet.class).toInstance(activeConnectionSet);
import net.sourceforge.guacamole.net.InetGuacamoleSocket;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionParameterMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameter;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameterExample;
import net.sourceforge.guacamole.net.auth.mysql.properties.MySQLGuacamoleProperties;
import net.sourceforge.guacamole.net.auth.mysql.utility.ConfigurationTranslationUtility;
import net.sourceforge.guacamole.properties.GuacamoleProperties;
import net.sourceforge.guacamole.protocol.ConfiguredGuacamoleSocket;


    @Inject
    ConnectionParameterMapper connectionParameterDAO;


    @Inject
    ActiveConnectionSet activeConnectionSet;

    @Inject
    ConfigurationTranslationUtility configurationTranslationUtility;



        configuration = new GuacamoleConfiguration();



     * @param connection

    /**
     * Initializes the GuacamoleConfiguration based on the ConnectionParameter values in the database.
     */
    private void initConfiguration() {
        ConnectionParameterExample connectionParameterExample = new ConnectionParameterExample();
        connectionParameterExample.createCriteria().andConnection_idEqualTo(connection.getConnection_id());

        List<ConnectionParameter> connectionParameters = connectionParameterDAO.selectByExample(connectionParameterExample);

        configuration = configurationTranslationUtility.getConfiguration(connection.getProtocol(), connectionParameters);
    }

     * @param connectionName


        initConfiguration();

     * Initialize from a database record. This also initializes the configuration values.
     * @param connection
        initConfiguration();

        // If the current connection is active, and multiple simultaneous connections are not allowed.
        if(GuacamoleProperties.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS, false)
                && activeConnectionSet.contains(getConnectionID()))
            throw new GuacamoleException("Cannot connect. This connection is in use.");

        String host = GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_HOSTNAME);
        int port = GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_PORT);

        InetGuacamoleSocket inetSocket = new InetGuacamoleSocket(host, port);
        ConfiguredGuacamoleSocket configuredSocket = new ConfiguredGuacamoleSocket(inetSocket, configuration);

        MySQLGuacamoleSocket mySQLSocket = providerUtility.getMySQLGuacamoleSocket(configuredSocket, getConnectionID());

        // mark this connection as active
        activeConnectionSet.add(getConnectionID());

        return mySQLSocket;






     * @param connectionHistory









     * @throws GuacamoleException


     * @throws GuacamoleException

     * @throws GuacamoleException


     * @param user

     * @return

     * @return

















     * @param user





     * @throws GuacamoleException




     * @param user













     * @param user














     * @param user



            //do not insert the permission if it already exists






     * @param user



        //delete all permissions that refer to this user
        userPermissionExample.createCriteria();
        userPermissionExample.createCriteria().andAffected_user_idEqualTo(user.getUserID());
        userPermissionDAO.deleteByExample(userPermissionExample);
import net.sourceforge.guacamole.properties.BooleanGuacamoleProperty;







    /**
     * Whether or not multiple users accessing the same connection at the same time should be disallowed.
     */
    public static final BooleanGuacamoleProperty MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS = new BooleanGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-disallow-simultaneous-connections"; }

    };
























     * @return


     * @return





























     * @return


     * @return















     * @return

     * @return

     * @param systemPermissionType
     * @return

     * @return


     * @return


     * @return all permissions a user has.









import net.sourceforge.guacamole.net.auth.mysql.MySQLGuacamoleSocket;
import net.sourceforge.guacamole.protocol.ConfiguredGuacamoleSocket;
 * Provides convenient provider methods for MySQL specific implementations.
    @Inject
    Provider<MySQLGuacamoleSocket> mySQLGuacamoleSocketProvider;
    
        // we want to return the newest records first
        example.setOrderByClause("start_date DESC");
    
    /**
     * Create a MySQLGuacamoleSocket using the provided ConfiguredGuacamoleSocket and connection ID.
     * @param socket
     * @param connectionID
     * @return 
     */
    public MySQLGuacamoleSocket getMySQLGuacamoleSocket(ConfiguredGuacamoleSocket socket, int connectionID) {
        MySQLGuacamoleSocket mySQLGuacamoleSocket = mySQLGuacamoleSocketProvider.get();
        mySQLGuacamoleSocket.init(socket, connectionID);
        return mySQLGuacamoleSocket;
    }





 * Provides functions for translating between GuacamoleConfiguration objects

     * @return



     * @return












     * @throws GuacamoleException

     * @throws GuacamoleException

     * @throws GuacamoleException




     * @throws GuacamoleException

     * @throws GuacamoleException

     * @throws GuacamoleException





     * @return



package net.sourceforge.guacamole.net.auth.mysql;

import net.sourceforge.guacamole.net.auth.mysql.model.Connection;
import net.sourceforge.guacamole.net.auth.mysql.model.User;
public class UserDirectory implements Directory<String, net.sourceforge.guacamole.net.auth.User> {
    /**
     * DAO for accessing users, which will be injected.
     */
    /**
     * DAO for accessing connections, which will be injected.
     */
    /**
     * DAO for accessing user permissions, which will be injected.
     */
    /**
     * DAO for accessing connection permissions, which will be injected.
     */
    /**
     * DAO for accessing system permissions, which will be injected.
     */
    /**
     * Utility class for checking various permissions, which will be injected.
     */
    /**
     * Utility class that provides convenient access to object creation and
     * retrieval functions.
     */
    public net.sourceforge.guacamole.net.auth.User get(String identifier)
            throws GuacamoleException {

        // Get set of all readable users
        
        // Build set of usernames of readable users
        Set<String> userNameSet = new HashSet<String>();
        for (MySQLUser mySQLUser : users)

    public void add(net.sourceforge.guacamole.net.auth.User object)
            throws GuacamoleException {

        // Verify current user has permission to create users
        // Create user in database
        // Create permissions of new user in database
        // Give the current user full access to the newly created user.

        // READ permission on new user

        // UPDATE permission on new user

        // DELETE permission on new user

        // ADMINISTER permission on new user

     * 
     * @param user The user whose permissions should be updated.
     * @throws GuacamoleException If an error occurs while updating the
     *                            permissions of the given user.

        // Partition given permissions by permission type
        
        for (Permission permission : user.getPermissions()) {
            if (permission instanceof UserPermission)
                userPermissions.add((UserPermission) permission);
            else if (permission instanceof ConnectionPermission)
                connectionPermissions.add((ConnectionPermission) permission);

            else if (permission instanceof SystemPermission)
                systemPermissions.add((SystemPermission) permission);

        // Update each type of permission appropriately
        updateUserPermissions(userPermissions, user);
        updateConnectionPermissions(connectionPermissions, user);
        
     * 
     * @param permissions The permissions the given user should have when
     *                    this operation completes.
     * @param user The user to change the permissions of.
     * @throws GuacamoleException If permission to alter the access permissions
     *                            of affected objects is denied.
    private void updateUserPermissions(Iterable<UserPermission> permissions,
            MySQLUser user)
            throws GuacamoleException {
        // Get set of administerable users
        Set<Integer> administerableUsers =
                permissionCheckUtility.getAdministerableUserIDs(this.user.getUserID());

        // Get list of usernames for all given user permissions.
        for (UserPermission permission : permissions)
        // Find all the users by username
        List<User> dbUsers = userDAO.selectByExample(userExample);
        // Build map of found users, indexed by username
        Map<String, User> dbUserMap = new HashMap<String, User>();
        for (User dbUser : dbUsers) {
        // Find any user permissions that may already exist
        List<UserPermissionKey> existingPermissions =
                userPermissionDAO.selectByExample(userPermissionExample);
        // Build list of currently-present permissions
        Set<Integer> existingUserIDs = new HashSet<Integer>();
        for (UserPermissionKey userPermission : existingPermissions)
            existingUserIDs.add(userPermission.getAffected_user_id());

        // Delete any permissions that are not in the provided list
        List<UserPermissionKey> permissionsToDelete =
                userPermissionDAO.selectByExample(userPermissionExample);
        // Verify that the user actually has permission to administrate every one of these users
        for (UserPermissionKey permissionToDelete : permissionsToDelete) {
            if (!administerableUsers.contains(permissionToDelete.getAffected_user_id()))
                throw new GuacamolePermissionException(
                      "User '"  this.user.getUsername()
                     "' does not have permission to administrate user "
                     permissionToDelete.getAffected_user_id());
        // Finally, insert the new permissions
        for (UserPermission permission : permissions) {
            // Get user
            User dbAffectedUser = dbUserMap.get(permission.getObjectIdentifier());
            if (dbAffectedUser == null)
                throw new GuacamoleException(
                          "User '"  permission.getObjectIdentifier()
                         "' not found.");

            // If the permission for this user already exists, we don't need to
            // create it again
            if (existingUserIDs.contains(dbAffectedUser.getUser_id()))
            // Verify that the user actually has permission to administrate
            // every one of these users
            if (!administerableUsers.contains(dbAffectedUser.getUser_id()))
                throw new GuacamolePermissionException(
                      "User '"  this.user.getUsername()
                     "' does not have permission to administrate user "
                     dbAffectedUser.getUser_id());
            // Create new permission

     * Update all the permissions having to do with connections for a given
     * user.
     * 
     * @param permissions The permissions the user should have after this
     *                    operation completes.
     * @param user The user to assign or remove permissions from.
     * @throws GuacamoleException If permission to alter the access permissions
     *                            of affected objects is deniedD
    private void updateConnectionPermissions(
            Iterable<ConnectionPermission> permissions, MySQLUser user)
            throws GuacamoleException {
        // Get adminsterable connection identifiers
        Set<Integer> administerableConnections =
                permissionCheckUtility.getAdministerableConnectionIDs(this.user.getUserID());
        // Build list of affected connection names from the permissions given
        List<String> connectionNames = new ArrayList<String>();
        for (ConnectionPermission permission : permissions)
            connectionNames.add(permission.getObjectIdentifier());

        // Find all the connections by connection name
        connectionExample.createCriteria().andConnection_nameIn(connectionNames);
        List<Connection> dbConnections = connectionDAO.selectByExample(connectionExample);
        // Build map of found connections, indexed by name
        Map<String, Connection> dbConnectionMap = new HashMap<String, Connection>();
        for (Connection dbConnection : dbConnections) {
        // Find any connection permissions that may already exist
        List<ConnectionPermissionKey> existingPermissions =
                connectionPermissionDAO.selectByExample(connectionPermissionExample);
        for (ConnectionPermissionKey connectionPermission : existingPermissions)
        // Delete any permissions that are not in the provided list
        List<ConnectionPermissionKey> connectionPermissionsToDelete =
                connectionPermissionDAO.selectByExample(connectionPermissionExample);
        // Make sure the user has permission to administrate each of these connections
        // corresponding to the permissions we are about to delete
        for (ConnectionPermissionKey connectionPermissionToDelete : connectionPermissionsToDelete) {
            if (!administerableConnections.contains(connectionPermissionToDelete.getConnection_id()))
                throw new GuacamolePermissionException(
                    "User '"  this.user.getUsername() 
                    "' does not have permission to administrate connection "
                     connectionPermissionToDelete.getConnection_id());
        // Finally, insert the new permissions
        for (ConnectionPermission permission : permissions) {
            // Get permission
            Connection dbConnection = dbConnectionMap.get(permission.getObjectIdentifier());
            if (dbConnection == null)
                throw new GuacamoleException(
                    "Connection '"  permission.getObjectIdentifier()
                     "' not found.");

            // If the permission for this connection already exists, we don't need to create it again
            if (existingConnectionIDs.contains(dbConnection.getConnection_id()))
            // Throw exception if permission to administer this connection
            // is not granted
            if (!administerableConnections.contains(dbConnection.getConnection_id()))
                throw new GuacamolePermissionException(
                      "User '"  this.user.getUsername()
                     "' does not have permission to administrate connection "
                     dbConnection.getConnection_id());
            // Insert previously-non-existent connection permission

     * Update all system permissions for a given user. All permissions in
     * the given list not already granted to the user will be inserted, and all
     * permissions not in the list but already granted to the user will be
     * deleted.
     * 
     * @param permissions The system permissions that the given user should
     *                    have.
     * @param user The user whose permissions should be updated.
    private void updateSystemPermissions(Iterable<SystemPermission> permissions,
            MySQLUser user) {

        // Build list of requested system permissions
        for (SystemPermission permission : permissions) {

            // Connection directory permission
            if (permission instanceof ConnectionDirectoryPermission)

            // User directory permission
            else if (permission instanceof UserDirectoryPermission)

        // Delete all system permissions not in the list
        // Find all existing system permissions
        for (SystemPermissionKey existingPermission : existingPermissions) {
        // Finally, insert any NEW system permissions for this user
        for (String systemPermissionType : systemPermissionTypes) {

            // Do not insert the permission if it already exists
            if (existingPermissionTypes.contains(systemPermissionType))
            // Insert permission


    public void update(net.sourceforge.guacamole.net.auth.User object)
            throws GuacamoleException {

        // Validate permission to update this user is granted
        permissionCheckUtility.verifyUserUpdateAccess(this.user.getUserID(),
                object.getUsername());

        // Update the user in the database
        // Update permissions in database

        // Validate current user has permission to remove the specified user
        permissionCheckUtility.verifyUserDeleteAccess(this.user.getUserID(),
                identifier);

        // Get specified user
        // Delete all the user permissions in the database
        // Delete the user in the database

     * Delete all permissions associated with the provided user. This is only
     * used when deleting a user.
     * 
     * @param user The user to delete all permissions of.
    private void deleteAllPermissions(MySQLUser user) {

        // Delete all user permissions
        // Delete all connection permissions
        // Delete all system permissions
        // Delete all permissions that refer to this user


import net.sourceforge.guacamole.GuacamoleSecurityException;
                throw new GuacamoleSecurityException(
                throw new GuacamoleSecurityException(
                throw new GuacamoleSecurityException(
                throw new GuacamoleSecurityException(
import net.sourceforge.guacamole.GuacamoleSecurityException;
     * Verifies that the user has read access to the given user. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyUserReadAccess(int userID, int affectedUserID) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have read access to user "  affectedUserID);
     * Verifies that the user has update access to the given user. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyUserUpdateAccess(int userID, int affectedUserID) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have update access to user "  affectedUserID);
     * Verifies that the user has delete access to the given user. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyUserDeleteAccess(int userID, int affectedUserID) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have delete access to user "  affectedUserID);
     * Verifies that the user has administer access to the given user. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyUserAdministerAccess(int userID, int affectedUserID) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have administer access to user "  affectedUserID);
     * Verifies that the user has read access to the given user. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyUserReadAccess(int userID, String affectedUsername) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have read access to user '"  affectedUsername  "'");
     * Verifies that the user has update access to the given user. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyUserUpdateAccess(int userID, String affectedUsername) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have update access to user '"  affectedUsername  "'");
     * Verifies that the user has delete access to the given user. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyUserDeleteAccess(int userID, String affectedUsername) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have delete access to user '"  affectedUsername  "'");
     * Verifies that the user has administer access to the given user. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyUserAdministerAccess(int userID, String affectedUsername) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have administer access to user '"  affectedUsername  "'");
     * Verifies that the user has read access to the given connection. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyConnectionReadAccess(int userID, int affectedConnectionID) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have read access to connection "  affectedConnectionID);
     * Verifies that the user has update access to the given connection. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyConnectionUpdateAccess(int userID, int affectedConnectionID) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have update access to connection "  affectedConnectionID);
     * Verifies that the user has delete access to the given connection. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyConnectionDeleteAccess(int userID, int affectedConnectionID) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have delete access to connection "  affectedConnectionID);
     * Verifies that the user has administer access to the given connection. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyConnectionAdministerAccess(int userID, int affectedConnectionID) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have administer access to connection "  affectedConnectionID);
     * Verifies that the user has read access to the given connection. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyConnectionReadAccess(int userID, String affectedConnectionName) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have read access to connection '"  affectedConnectionName  "'");
     * Verifies that the user has update access to the given connection. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyConnectionUpdateAccess(int userID, String affectedConnectionName) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have update access to connection '"  affectedConnectionName  "'");
     * Verifies that the user has delete access to the given connection. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyConnectionDeleteAccess(int userID, String affectedConnectionName) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have delete access to connection '"  affectedConnectionName  "'");
     * Verifies that the user has administer access to the given connection. If not, throws a GuacamoleSecurityException.
     * @throws GuacamoleSecurityException
    public void verifyConnectionAdministerAccess(int userID, String affectedConnectionName) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have administer access to connection '"  affectedConnectionName  "'");
    public void verifyCreateUserPermission(int userID) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have permission to create users.");
    public void verifyCreateConnectionPermission(int userID) throws GuacamoleSecurityException {
            throw new GuacamoleSecurityException("User "  userID  " does not have permission to create connections.");

package net.sourceforge.guacamole.net.auth.mysql.utility;

    public boolean checkCredentials(Credentials credentials,
        byte[] dbPasswordHash, String dbUsername, byte[] dbSalt) {

        // If usernames don't match, don't bother comparing passwords, just fail
        if (!dbUsername.equals(credentials.getUsername()))
            return false;
        
        // Compare bytes of password in credentials against hashed password

        try {

            // Build salted password
            
            // Hash UTF-8 bytes of salted password
            MessageDigest md = MessageDigest.getInstance("SHA-256");

        }

        // Should not happen
        catch (UnsupportedEncodingException ex) {

        // Should not happen
        catch (NoSuchAlgorithmException ex) {
            throw new RuntimeException(ex);
        }


package net.sourceforge.guacamole.net.auth.mysql.utility;

 * Generates password salts via SecureRandom.
    /**
     * Instance of SecureRandom for generating the salt.
     */
    private SecureRandom secureRandom = new SecureRandom();


package net.sourceforge.guacamole.net.auth.mysql;

 * Represents the set of currently active Connections. Whenever a socket is
 * opened, the connection ID should be added to this set, and whenever a socket
 * is closed, the connection ID should be removed from this set.
 *
 * @author James Muehlner
public class ActiveConnectionSet extends HashSet<Integer> {}

package net.sourceforge.guacamole.net.auth.mysql;

 *
    /**
     * Set of all active connections.
     */
    /**
     * Injector which will manage the object graph of this authentication
     * provider.
     */
    /**
     * Creates a new MySQLAuthenticationProvider that reads and writes
     * authentication data to a MySQL database defined by properties in
     * guacamole.properties.
     *
     * @throws GuacamoleException If a required property is missing, or
     *                            an error occurs while parsing a property.
     */


        // Set the mysql properties for MyBatis.

            },

            new MyBatisModule() {

                    // Datasource

                    // Add MyBatis mappers

                    // Bind interfaces

            } // end of mybatis module

    } // end of constructor

     *
     * @param user The user whose permissions define the visibility of other
     *             users in this directory.

     *


     *
     *
     *
     *



package net.sourceforge.guacamole.net.auth.mysql;

 * A ConnectionRecord which is based on data stored in MySQL.
    /**
     * DAO for accessing users.
     */
    /**
     * DAO for accessing connections.
     */
    /**
     * Service for creating and retrieving objects.
     */
     * Initialize this MySQLConnectionRecord with the database record it
     * represents.
     *
     * @param connectionHistory The ConnectionHistory entry from the database
     *                          corresponding to this connection record.
        // If the end date hasn't been stored yet, the connection is still open.

package net.sourceforge.guacamole.net.auth.mysql.utility;

     * Get a GuacamoleConfiguration based on the provided protocol and
     * parameters.
     *
     * @param protocol The protocol used (VNC, RDP, etc)
     * @param parameters The parameter database records to translate
     * @return A new GuacamoleConfiguration based on the given protocol and
     *         parameters.
    public GuacamoleConfiguration getConfiguration(String protocol,
            Iterable<ConnectionParameter> parameters) {

        // Create new configuration, set protocol
        // Copy parameters from given parameters
        for(ConnectionParameter parameter : parameters)
     * Creates a list of ConnectionParameter database records based on the
     * provided connectionID and GuacamoleConfiguration.
     *
     * @param connectionID The ID of the connection that these parameters are
     *                     for.
     * @param configuration The configuration to pull the parameter values from.
     * @return A list of ConnectionParameter database records.
    public List<ConnectionParameter> getConnectionParameters(int connectionID,
            GuacamoleConfiguration configuration) {
        List<ConnectionParameter> connectionParameters =
                new ArrayList<ConnectionParameter>();

        // Each connection parameter in the given configuration, create
        // a corresponding database record
        for (String parameterName : configuration.getParameterNames()) {

            // Get value of parameter

            // Create corresponding ConnectionParameter
            ConnectionParameter connectionParameter = new ConnectionParameter();
            // Add parameter to list


package net.sourceforge.guacamole.net.auth.mysql;

    /**
     * Injected ActiveConnectionSet which will contain all active connections.
     */
    /**
     * The wrapped socket.
     */
    private GuacamoleSocket socket;

    /**
     * The ID associated with the connection associated with the wrapped
     * socket.
     */
     * Initialize this MySQLGuacamoleSocket with the provided GuacamoleSocket.
     * 
     * @param socket The ConfiguredGuacamoleSocket to wrap.
     * @param connectionID The ID of the connection associated with the given
     *                     socket.
    public void init(GuacamoleSocket socket, int connectionID) {

        // Close socket

        // Mark this connection as inactive

     *

package net.sourceforge.guacamole.net.auth.mysql;

    /**
     * The user owning this context. The permissions of this user dictate
     * the access given via the user and connection directories.
     */
    /**
     * User directory restricted by the permissions of the user associated
     * with this context.
     */
    /**
     * Connection directory restricted by the permissions of the user associated
     * with this context.
     */
    /**
     * Initializes the user and directories associated with this context.
     *
     * @param credentials The credentials of the user owning this context.
     * @throws GuacamoleException If the credentials given are not valid,
     *                            or an error occurs while initializing the
     *                            directories.
     */
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionHistoryMapper;
import org.apache.ibatis.transaction.jdbc.JdbcTransactionFactory;
                    // Transaction factory
                    bindTransactionFactoryType(JdbcTransactionFactory.class);

                    addMapperClass(ConnectionHistoryMapper.class);

        // No null users in database
        if (credentials.getUsername() == null)
            return null;

    void init(Credentials credentials) throws GuacamoleException {

        // Query user

        // The unique constraint on the table should prevent this.
        if (users.size() > 1)
            throw new GuacamoleException(
                "Multiple users found with the same username: "
                 credentials.getUsername());

        // Check that a user was found
        if (users.isEmpty())
        // Get first (and only) user
        user = users.get(0);

        // Check password
        if (!passwordUtility.checkCredentials(credentials,
                user.getPassword_hash(), user.getUsername(), user.getPassword_salt()))
            throw new GuacamoleException("No user found with the supplied credentials");

        // Init permissions

import java.util.Collections;

        // If connections available, query them
        if (!affectedConnectionIDs.isEmpty()) {

            // Query available connections
            ConnectionExample example = new ConnectionExample();
            example.createCriteria().andConnection_idIn(Lists.newArrayList(affectedConnectionIDs));
            List<Connection> connectionDBOjects = connectionDAO.selectByExample(example);

            // Add connections to final set
            Set<MySQLConnection> affectedConnections = new HashSet<MySQLConnection>();
            for(Connection affectedConnection : connectionDBOjects) {
                MySQLConnection mySQLConnection = mySQLConnectionProvider.get();
                mySQLConnection.init(affectedConnection);
                affectedConnections.add(mySQLConnection);
            }

            return affectedConnections;
        // Otherwise, no connections available
        return Collections.EMPTY_SET;
        
        // First, user permissions
        List<UserPermissionKey> userPermissions =
                userPermissionDAO.selectByExample(userPermissionExample);

        // If user permissions present, add permissions
        if (!userPermissions.isEmpty()) {

            // Get list of affected user IDs
            List<Integer> affectedUserIDs = new ArrayList<Integer>();
            for(UserPermissionKey userPermission : userPermissions)
                affectedUserIDs.add(userPermission.getAffected_user_id());

            // Query all affected users, store in map indexed by user ID
            UserExample userExample = new UserExample();
            userExample.createCriteria().andUser_idIn(affectedUserIDs);
            List<User> users = userDAO.selectByExample(userExample);
            Map<Integer, User> userMap = new HashMap<Integer, User>();
            for(User user : users)
                userMap.put(user.getUser_id(), user);

            // Add user permissions
            for(UserPermissionKey userPermission : userPermissions) {
                User affectedUser = userMap.get(userPermission.getAffected_user_id());
                UserPermission newPermission = new UserPermission(
                    UserPermission.Type.valueOf(userPermission.getPermission()),
                    affectedUser.getUsername()
                );
                allPermissions.add(newPermission);
            }

        // Secondly, connection permissions
        List<ConnectionPermissionKey> connectionPermissions =
                connectionPermissionDAO.selectByExample(connectionPermissionExample);

        // If connection permissions present, add permissions 
        if (!connectionPermissions.isEmpty()) {

            // Get list of affected connection IDs
            List<Integer> affectedConnectionIDs = new ArrayList<Integer>();
            for(ConnectionPermissionKey connectionPermission : connectionPermissions)
                affectedConnectionIDs.add(connectionPermission.getConnection_id());

            // Query connections, store in map indexed by connection ID
            ConnectionExample connectionExample = new ConnectionExample();
            connectionExample.createCriteria().andConnection_idIn(affectedConnectionIDs);
            List<Connection> connections = connectionDAO.selectByExample(connectionExample);
            Map<Integer, Connection> connectionMap = new HashMap<Integer, Connection>();
            for(Connection connection : connections)
                connectionMap.put(connection.getConnection_id(), connection);

            // Add connection permissions
            for(ConnectionPermissionKey connectionPermission : connectionPermissions) {
                Connection affectedConnection = connectionMap.get(connectionPermission.getConnection_id());
                ConnectionPermission newPermission = new ConnectionPermission(
                    ConnectionPermission.Type.valueOf(connectionPermission.getPermission()),
                    affectedConnection.getConnection_name()
                );
                allPermissions.add(newPermission);
            }

        // And finally, system permissions
        List<SystemPermissionKey> systemPermissions =
                systemPermissionDAO.selectByExample(systemPermissionExample);
    /**
     * The string stored in the database to represent READ access to a user.
     */
    public static final String USER_READ = "READ";
    /**
     * The string stored in the database to represent UPDATE access to a user.
     */
    public static final String USER_UPDATE = "UPDATE";
    /**
     * The string stored in the database to represent DELETE access to a user.
     */
    public static final String USER_DELETE = "DELETE";

    /**
     * The string stored in the database to represent ADMINISTER access to a
     * user.
     */
    public static final String USER_ADMINISTER = "ADMINISTER";

    /**
     * The string stored in the database to represent READ access to a
     * connection.
     */
    public static final String CONNECTION_READ = "READ";

    /**
     * The string stored in the database to represent UPDATE access to a
     * connection.
     */
    public static final String CONNECTION_UPDATE = "UPDATE";

    /**
     * The string stored in the database to represent DELETE access to a
     * connection.
     */
    public static final String CONNECTION_DELETE = "DELETE";

    /**
     * The string stored in the database to represent ADMINISTER access to a
     * connection.
     */
    public static final String CONNECTION_ADMINISTER = "ADMINISTER";

    /**
     * The string stored in the database to represent permission to create
     * users.
     */
    public static final String SYSTEM_USER_CREATE = "CREATE_USER";

    /**
     * The string stored in the database to represent permission to create
     * connections.
     */
    public static final String SYSTEM_CONNECTION_CREATE = "CREATE_CONNECTION";

            if (permission instanceof ConnectionDirectoryPermission) {
                switch (permission.getType()) {

                    // Create permission
                    case CREATE:
                        systemPermissionTypes.add(MySQLConstants.SYSTEM_CONNECTION_CREATE);
                        break;

                    // Fail if unexpected type encountered
                    default:
                        assert false : "Unsupported type: "  permission.getType();

                }
            }
            else if (permission instanceof UserDirectoryPermission) {
                switch (permission.getType()) {
                    // Create permission
                    case CREATE:
                        systemPermissionTypes.add(MySQLConstants.SYSTEM_USER_CREATE);
                        break;

                    // Fail if unexpected type encountered
                    default:
                        assert false : "Unsupported type: "  permission.getType();

                }
            }

        } // end for each system permission
        for (SystemPermissionKey existingPermission : existingPermissions)
            // User creation permission
            if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_USER_CREATE))
                allPermissions.add(new UserDirectoryPermission(UserDirectoryPermission.Type.CREATE));

            // System creation permission
            else if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_CONNECTION_CREATE))
                allPermissions.add(new ConnectionDirectoryPermission(ConnectionDirectoryPermission.Type.CREATE));

import net.sourceforge.guacamole.net.auth.mysql.service.PermissionCheckService;
import net.sourceforge.guacamole.net.auth.mysql.service.ProviderService;
    PermissionCheckService permissionCheckUtility;
    ProviderService providerUtility;
import net.sourceforge.guacamole.net.auth.mysql.service.ConfigurationTranslationService;
import net.sourceforge.guacamole.net.auth.mysql.service.PasswordEncryptionService;
import net.sourceforge.guacamole.net.auth.mysql.service.PermissionCheckService;
import net.sourceforge.guacamole.net.auth.mysql.service.ProviderService;
import net.sourceforge.guacamole.net.auth.mysql.service.SaltService;
import net.sourceforge.guacamole.net.auth.mysql.service.SecureRandomSaltService;
import net.sourceforge.guacamole.net.auth.mysql.service.Sha256PasswordEncryptionService;
                    bind(SaltService.class).to(SecureRandomSaltService.class);
                    bind(PasswordEncryptionService.class).to(Sha256PasswordEncryptionService.class);
                    bind(PermissionCheckService.class);
                    bind(ProviderService.class);
                    bind(ConfigurationTranslationService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.ConfigurationTranslationService;
import net.sourceforge.guacamole.net.auth.mysql.service.ProviderService;
    ProviderService providerUtility;
    ConfigurationTranslationService configurationTranslationUtility;
import net.sourceforge.guacamole.net.auth.mysql.service.ProviderService;
    ProviderService providerUtility;
import net.sourceforge.guacamole.net.auth.mysql.service.PasswordEncryptionService;
import net.sourceforge.guacamole.net.auth.mysql.service.PermissionCheckService;
import net.sourceforge.guacamole.net.auth.mysql.service.SaltService;
    PasswordEncryptionService passwordUtility;
    SaltService saltUtility;
    PermissionCheckService permissionCheckUtility;
import net.sourceforge.guacamole.net.auth.mysql.service.PermissionCheckService;
import net.sourceforge.guacamole.net.auth.mysql.service.ProviderService;
    PermissionCheckService permissionCheckUtility;
    ProviderService providerUtility;
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/service/ConfigurationTranslationService.java
package net.sourceforge.guacamole.net.auth.mysql.service;
public class ConfigurationTranslationService {
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/service/PasswordEncryptionService.java
package net.sourceforge.guacamole.net.auth.mysql.service;
 * A service to perform password encryption and checking.
public interface PasswordEncryptionService {
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/service/PermissionCheckService.java
package net.sourceforge.guacamole.net.auth.mysql.service;
 * A service to retrieve information about what objects a user has permission to.
public class PermissionCheckService {
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/service/ProviderService.java
package net.sourceforge.guacamole.net.auth.mysql.service;
public class ProviderService {
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/service/SaltService.java
package net.sourceforge.guacamole.net.auth.mysql.service;
 * A service to generate password salts.
public interface SaltService {
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/service/SecureRandomSaltService.java
package net.sourceforge.guacamole.net.auth.mysql.service;
public class SecureRandomSaltService implements SaltService {
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/service/Sha256PasswordEncryptionService.java
package net.sourceforge.guacamole.net.auth.mysql.service;
public class Sha256PasswordEncryptionService implements PasswordEncryptionService {
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/service/package-info.java
package net.sourceforge.guacamole.net.auth.mysql.service;
            User user = directory.get(username);
            String[] add_user_permission = request.getParameterValues("user");
            if (add_user_permission != null) {
                for (String str : add_user_permission)
            String[] add_connection_permission = request.getParameterValues("connection");
            if (add_connection_permission != null) {
                for (String str : add_connection_permission)
            // Set user permissions
            String[] remove_user_permission = request.getParameterValues("-user");
            if (remove_user_permission != null) {
                for (String str : remove_user_permission)
                    user.removePermission(parseUserPermission(str));
            }

            // Set connection permissions
            String[] remove_connection_permission = request.getParameterValues("-connection");
            if (remove_connection_permission != null) {
                for (String str : remove_connection_permission)
                    user.removePermission(parseConnectionPermission(str));
            }

import java.util.Collections;
    /**
     * The set of current permissions a user has.
     */
    
    /**
     * Any newly added permissions that have yet to be committed.
     */
    Set<Permission> newPermissions;
    
    /**
     * Any newly deleted permissions that have yet to be deleted.
     */
    Set<Permission> removedPermissions;
    
    /**
     * Get the current set of permissions this user has.
     * @return the current set of permissions.
     */
    Set<Permission> getCurrentPermissions() {
        return permissions;
    }
    
    /**
     * Get any new permissions that have yet to be inserted.
     * @return the new set of permissions.
     */
    Set<Permission> getNewPermissions() {
        return newPermissions;
    }
    
    /**
     * Get any permissions that have not yet been deleted.
     * @return the permissions that need to be deleted.
     */
    Set<Permission> getRemovedPermissions() {
        return removedPermissions;
    }
    
    /**
     * Reset the new and removed permission sets after they are
     * no longer needed.
     */
    void resetPermissions() {
        newPermissions.clear();
        removedPermissions.clear();
    }
        return Collections.unmodifiableSet(permissions);
        newPermissions.add(permission);
        removedPermissions.remove(permission);
import java.util.Collection;
        List<UserPermission> newUserPermissions = new ArrayList<UserPermission>();
        List<ConnectionPermission> newConnectionPermissions = new ArrayList<ConnectionPermission>();
        List<SystemPermission> newSystemPermissions = new ArrayList<SystemPermission>();
        for (Permission permission : user.getNewPermissions()) {
                newUserPermissions.add((UserPermission) permission);
                newConnectionPermissions.add((ConnectionPermission) permission);
                newSystemPermissions.add((SystemPermission) permission);
        
        // Partition given permissions by permission type
        List<UserPermission> removedUserPermissions = new ArrayList<UserPermission>();
        List<ConnectionPermission> removedConnectionPermissions = new ArrayList<ConnectionPermission>();
        List<SystemPermission> removedSystemPermissions = new ArrayList<SystemPermission>();
        for (Permission permission : user.getRemovedPermissions()) {
            if (permission instanceof UserPermission)
                removedUserPermissions.add((UserPermission) permission);

            else if (permission instanceof ConnectionPermission)
                removedConnectionPermissions.add((ConnectionPermission) permission);

            else if (permission instanceof SystemPermission)
                removedSystemPermissions.add((SystemPermission) permission);
        }
        
        // Create the new permissions
        createUserPermissions(newUserPermissions, user);
        createConnectionPermissions(newConnectionPermissions, user);
        createSystemPermissions(newSystemPermissions, user);
        
        // Delete the removed permissions.
        deleteUserPermissions(removedUserPermissions, user);
        deleteConnectionPermissions(removedConnectionPermissions, user);
        deleteSystemPermissions(removedSystemPermissions, user);
        
        // The appropriate permissions have been inserted and deleted, so
        // reset the new and removed permission sets.
        user.resetPermissions();
     * Create any new permissions having to do with users for a given user.
     * @param permissions The new permissions the given user should have when
    private void createUserPermissions(Collection<UserPermission> permissions,
        
        if(permissions.isEmpty())
            return;

        // Get set of administerable users
        Set<Integer> administerableUsers =
                permissionCheckUtility.getAdministerableUserIDs(this.user.getUserID());

        // Get list of usernames for all given user permissions.
        List<String> usernames = new ArrayList<String>();
        for (UserPermission permission : permissions)
            usernames.add(permission.getObjectIdentifier());

        // Find all the users by username
        UserExample userExample = new UserExample();
        userExample.createCriteria().andUsernameIn(usernames);
        List<User> dbUsers = userDAO.selectByExample(userExample);

        // Build map of found users, indexed by username
        Map<String, User> dbUserMap = new HashMap<String, User>();
        for (User dbUser : dbUsers) {
            dbUserMap.put(dbUser.getUsername(), dbUser);
        }
        
        for (UserPermission permission : permissions) {

            // Get user
            User dbAffectedUser = dbUserMap.get(permission.getObjectIdentifier());
            if (dbAffectedUser == null)
                throw new GuacamoleException(
                          "User '"  permission.getObjectIdentifier()
                         "' not found.");

            // Verify that the user actually has permission to administrate
            // every one of these users
            if (!administerableUsers.contains(dbAffectedUser.getUser_id()))
                throw new GuacamoleSecurityException(
                      "User '"  this.user.getUsername()
                     "' does not have permission to administrate user "
                     dbAffectedUser.getUser_id());

            // Create new permission
            UserPermissionKey newPermission = new UserPermissionKey();
            newPermission.setAffected_user_id(dbAffectedUser.getUser_id());
            newPermission.setPermission(permission.getType().name());
            newPermission.setUser_id(user.getUserID());
            userPermissionDAO.insert(newPermission);
         }
    }

    /**
     * Delete permissions having to do with users for a given user.
     *
     * @param permissions The permissions the given user should no longer have
     *                    when this operation completes.
     * @param user The user to change the permissions of.
     * @throws GuacamoleException If permission to alter the access permissions
     *                            of affected objects is denied.
     */
    private void deleteUserPermissions(Collection<UserPermission> permissions,
            MySQLUser user)
            throws GuacamoleException {
        
        if(permissions.isEmpty())
            return;
        
        // Verify we have permission to delete each user permission.
        }
        
        if(!userIDs.isEmpty()) {
            UserPermissionExample userPermissionExample = new UserPermissionExample();
            userPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID())
                    .andAffected_user_idIn(userIDs);
            userPermissionDAO.deleteByExample(userPermissionExample);
     * Create any new permissions having to do with connections for a given
     * @param permissions The new permissions the user should have after this
    private void createConnectionPermissions(
            Collection<ConnectionPermission> permissions, MySQLUser user)
        
        if(permissions.isEmpty())
            return;
     * Delete permissions having to do with connections for a given user.
     * @param permissions The permissions the given user should no longer have
     *                    when this operation completes.
     * @param user The user to change the permissions of.
     * @throws GuacamoleException If permission to alter the access permissions
     *                            of affected objects is denied.
     */
    private void deleteConnectionPermissions(Collection<ConnectionPermission> permissions,
            MySQLUser user)
            throws GuacamoleException {
        
        if(permissions.isEmpty())
            return;

        // Get set of administerable users
        Set<Integer> administerableConnections =
                permissionCheckUtility.getAdministerableConnectionIDs(this.user.getUserID());

        // Get list of identifiers for all given user permissions.
        List<String> identifiers = new ArrayList<String>();
        for (ConnectionPermission permission : permissions)
            identifiers.add(permission.getObjectIdentifier());

        // Find all the connections by identifiers
        ConnectionExample connectionExample = new ConnectionExample();
        connectionExample.createCriteria().andConnection_nameIn(identifiers);
        List<Connection> dbConnections = connectionDAO.selectByExample(connectionExample);
        List<Integer> connectionIDs = new ArrayList<Integer>();

        // Build map of found connections, indexed by identifier
        Map<String, Connection> dbConnectionMap = new HashMap<String, Connection>();
        for (Connection dbConnection : dbConnections) {
            dbConnectionMap.put(dbConnection.getConnection_name(), dbConnection);
            connectionIDs.add(dbConnection.getConnection_id());
        }
        
        // Verify we have permission to delete each connection permission.
        for (ConnectionPermission permission : permissions) {

            // Get user
            Connection dbConnection = dbConnectionMap.get(permission.getObjectIdentifier());
            if (dbConnection == null)
                throw new GuacamoleException(
                          "User '"  permission.getObjectIdentifier()
                         "' not found.");

            // Verify that the user actually has permission to administrate
            // every one of these connections
            if (!administerableConnections.contains(dbConnection.getConnection_id()))
                throw new GuacamoleSecurityException(
                      "User '"  this.user.getUsername()
                     "' does not have permission to administrate connection "
                     dbConnection.getConnection_id());
        }
        
        if(!connectionIDs.isEmpty()) {
            ConnectionPermissionExample connectionPermissionExample = new ConnectionPermissionExample();
            connectionPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID())
                    .andConnection_idIn(connectionIDs);
            connectionPermissionDAO.deleteByExample(connectionPermissionExample);
        }
    }

    /**
     * Create any new system permissions for a given user. All permissions in
     * the given list will be inserted.
     *
     * @param permissions The new system permissions that the given user should
     *                    have when this operation completes.
    private void createSystemPermissions(Collection<SystemPermission> permissions,
        if(permissions.isEmpty())
            return;
        
        // Build list of requested system permissions
        List<String> systemPermissionTypes = new ArrayList<String>();
        for (SystemPermission permission : permissions) {

            // Connection directory permission
            if (permission instanceof ConnectionDirectoryPermission) {
                switch (permission.getType()) {

                    // Create permission
                    case CREATE:
                        systemPermissionTypes.add(MySQLConstants.SYSTEM_CONNECTION_CREATE);
                        break;

                    // Fail if unexpected type encountered
                    default:
                        assert false : "Unsupported type: "  permission.getType();

                }
            }

            // User directory permission
            else if (permission instanceof UserDirectoryPermission) {
                switch (permission.getType()) {

                    // Create permission
                    case CREATE:
                        systemPermissionTypes.add(MySQLConstants.SYSTEM_USER_CREATE);
                        break;

                    // Fail if unexpected type encountered
                    default:
                        assert false : "Unsupported type: "  permission.getType();

                }
            }

        } // end for each system permission

        // Finally, insert any NEW system permissions for this user
        for (String systemPermissionType : systemPermissionTypes) {

            // Insert permission
            SystemPermissionKey newSystemPermission = new SystemPermissionKey();
            newSystemPermission.setUser_id(user.getUserID());
            newSystemPermission.setPermission(systemPermissionType);
            systemPermissionDAO.insert(newSystemPermission);

        }

    }/**
     * Delete system permissions for a given user. All permissions in
     * the given list will be removed from the user.
     *
     * @param permissions The permissions the given user should no longer have
     *                    when this operation completes.
     * @param user The user whose permissions should be updated.
     */
    private void deleteSystemPermissions(Collection<SystemPermission> permissions,
            MySQLUser user) {
        
        if(permissions.isEmpty())
            return;

        // Finally, delete the requested system permissions for this user
        if(!systemPermissionTypes.isEmpty()) {
            SystemPermissionExample systemPermissionExample = new SystemPermissionExample();
            systemPermissionExample.createCriteria().andUser_idEqualTo(user.getUserID())
                    .andPermissionIn(systemPermissionTypes);
            systemPermissionDAO.deleteByExample(systemPermissionExample);
    private Set<Permission> permissions;
    private Set<Permission> newPermissions = new HashSet<Permission>();
    private Set<Permission> removedPermissions = new HashSet<Permission>();
    public Set<Permission> getCurrentPermissions() {
    public Set<Permission> getNewPermissions() {
    public Set<Permission> getRemovedPermissions() {
    public void resetPermissions() {
        removedPermissions.remove(permission);
        newPermissions.remove(permission);
        removedPermissions.add(permission);
        userPermissionExample.clear();
     * The ID of the user who this connection directory belongs to.
    private int user_id;
     * 
     * @param user_id The ID of the user owning this connection directory.
    void init(int user_id) {
        this.user_id = user_id;
        permissionCheckUtility.verifyConnectionReadAccess(this.user_id, identifier);
        Set<MySQLConnection> connections = permissionCheckUtility.getReadableConnections(this.user_id);
        permissionCheckUtility.verifyCreateConnectionPermission(this.user_id);
        newConnectionPermission.setUser_id(this.user_id);
        permissionCheckUtility.verifyConnectionUpdateAccess(this.user_id, object.getIdentifier());
        permissionCheckUtility.verifyConnectionDeleteAccess(this.user_id, identifier);
import java.util.List;
import net.sourceforge.guacamole.net.auth.mysql.model.UserExample;
import net.sourceforge.guacamole.net.auth.mysql.model.UserWithBLOBs;
        // Get user DAO
        UserMapper userDAO = injector.getInstance(UserMapper.class);

        // Query user
        UserExample userExample = new UserExample();
        userExample.createCriteria().andUsernameEqualTo(credentials.getUsername());
        List<UserWithBLOBs> users = userDAO.selectByExampleWithBLOBs(userExample);

        // The unique constraint on the table should prevent this.
        if (users.size() > 1)
            throw new GuacamoleException(
                "Multiple users found with the same username: "
                 credentials.getUsername());

        // Check that a user was found
        if (users.isEmpty())
            throw new GuacamoleException("No user found with the supplied credentials");

        // Get first (and only) user
        UserWithBLOBs user = users.get(0);

        // Get password service
        PasswordEncryptionService passwordService = injector.getInstance(PasswordEncryptionService.class);

        // Check password, if invalid return null
        if (!passwordService.checkCredentials(credentials,
                user.getPassword_hash(), user.getUsername(), user.getPassword_salt()))
            return null;

        context.init(user.getUser_id());

import net.sourceforge.guacamole.net.auth.AbstractUser;
public class MySQLUser extends AbstractUser {
    /**
     * The ID of this user in the database, if any.
     */
    private Integer userID;
    
    private Set<Permission> permissions = new HashSet<Permission>();
     * Creates a new, empty MySQLUser.
     */
    public MySQLUser() {
    }
    
    /**
     * Initializes a new MySQLUser having the given username.
     * 
     * @param name The name to assign to this MySQLUser.
     */
    public void init(String name) {
        setUsername(name);
    }

    /**
     * Initializes a new MySQLUser, copying all data from the given user
     * object.
     * 
     * @param user The user object to copy.
     * @throws GuacamoleException If an error occurs while reading the user
     *                            data in the given object.
     */
    public void init(User user) throws GuacamoleException {
        setUsername(user.getUsername());
        setPassword(user.getPassword());
        permissions.addAll(user.getPermissions());
    }

    /**
     * Initializes a new MySQLUser initialized from the given data from the
     * database.
     * 
     * @param user The user object, as retrieved from the database.
     */
    public void init(UserWithBLOBs user) {
        this.userID = user.getUser_id();
        setUsername(user.getUsername());

        permissions.addAll(
                permissionCheckUtility.getAllPermissions(user.getUser_id()));
    }
    
    /**
     * Returns the ID of this user in the database, if it exists.
     * 
     * @return The ID of this user in the database, or null if this user
     *         was not retrieved from the database.
    public Integer getUserID() {
        return userID;
     * Sets the ID of this user to the given value.
     * 
     * @param userID The ID to assign to this user.
    public void setUserID(Integer userID) {
        this.userID = userID;
    /**
     * Converts this MySQLUser into an object that can be inserted/updated
     * into the database. Beware that this object does not have associated
     * permissions. The permissions of this MySQLUser must be dealt with
     * separately.
     * 
     * @return A new UserWithBLOBs containing all associated data of this
     *         MySQLUser.
     */
    public UserWithBLOBs toUserWithBLOBs() {

        // Create new user
        UserWithBLOBs user = new UserWithBLOBs();
        user.setUser_id(userID);
        user.setUsername(getUsername());

        // Set password if specified
        if (getPassword() != null) {
            byte[] salt = saltUtility.generateSalt();
            user.setPassword_salt(salt);
            user.setPassword_hash(
                passwordUtility.createPasswordHash(getPassword(), salt));
        }

        return user;
        
import net.sourceforge.guacamole.net.auth.mysql.service.ProviderService;
     * The ID of the user owning this context. The permissions of this user
     * dictate the access given via the user and connection directories.
    private int user_id;
     * Service for retrieving existing objects or creating new ones.
     */
    @Inject
    private ProviderService providerService;
    
    /**
     * @param user_id The ID of the user owning this context.
    void init(int user_id) {
        this.user_id = user_id;
        userDirectory.init(user_id);
        connectionDirectory.init(user_id);
        return providerService.getExistingMySQLUser(user_id);
import net.sourceforge.guacamole.net.auth.mysql.model.UserWithBLOBs;
import net.sourceforge.guacamole.net.auth.mysql.service.PasswordEncryptionService;
import net.sourceforge.guacamole.net.auth.mysql.service.SaltService;
     * The ID of the user who this user directory belongs to.
    private int user_id;
    
    @Inject
    PasswordEncryptionService passwordUtility;

    @Inject
    SaltService saltUtility;
     * @param user_id The ID of the user whose permissions define the visibility
     *                of other users in this directory.
    void init(int user_id) {
        this.user_id = user_id;
        permissionCheckUtility.verifyUserReadAccess(this.user_id, identifier);
        Set<MySQLUser> users = permissionCheckUtility.getReadableUsers(this.user_id);
        permissionCheckUtility.verifyCreateUserPermission(this.user_id);
        UserWithBLOBs user = new UserWithBLOBs();
        user.setUsername(object.getUsername());

        // Set password if specified
        if (object.getPassword() != null) {
            byte[] salt = saltUtility.generateSalt();
            user.setPassword_salt(salt);
            user.setPassword_hash(
                passwordUtility.createPasswordHash(object.getPassword(), salt));
        }
        
        userDAO.insert(user);
        createPermissions(user.getUser_id(), object.getPermissions());
        newUserPermission.setUser_id(this.user_id);
        newUserPermission.setAffected_user_id(user.getUser_id());
    private void createPermissions(int user_id, Set<Permission> permissions) throws GuacamoleException {
        for (Permission permission : permissions) {

        // Create the new permissions
        createUserPermissions(newUserPermissions, user_id);
        createConnectionPermissions(newConnectionPermissions, user_id);
        createSystemPermissions(newSystemPermissions, user_id);

    }


    private void removePermissions(int user_id, Set<Permission> permissions) throws GuacamoleException {
        for (Permission permission : permissions) {
        deleteUserPermissions(removedUserPermissions, user_id);
        deleteConnectionPermissions(removedConnectionPermissions, user_id);
        deleteSystemPermissions(removedSystemPermissions, user_id);
     * @param user_id The ID of the user to change the permissions of.
            int user_id)
                permissionCheckUtility.getAdministerableUserIDs(this.user_id);
                      "User #"  this.user_id
                     " does not have permission to administrate user "
            newPermission.setUser_id(user_id);
     * @param user_id The ID of the user to change the permissions of.
            int user_id)
                permissionCheckUtility.getAdministerableUserIDs(this.user_id);
                      "User #"  this.user_id
                     " does not have permission to administrate user "
            userPermissionExample.createCriteria().andUser_idEqualTo(user_id)
     * @param user_id The ID of the user to assign or remove permissions from.
            Collection<ConnectionPermission> permissions, int user_id)
                permissionCheckUtility.getAdministerableConnectionIDs(this.user_id);
                      "User #"  this.user_id
                     " does not have permission to administrate connection "
            newPermission.setConnection_id(user_id);
     * @param user_id The ID of the user to change the permissions of.
            int user_id)
                permissionCheckUtility.getAdministerableConnectionIDs(this.user_id);
                      "User #"  this.user_id
                     " does not have permission to administrate connection "
            connectionPermissionExample.createCriteria().andUser_idEqualTo(user_id)
     * @param user_id The ID of the user whose permissions should be updated.
            int user_id) {
            newSystemPermission.setUser_id(user_id);
    }
    
    /**
     * @param user_id The ID of the user whose permissions should be updated.
            int user_id) {
            systemPermissionExample.createCriteria().andUser_idEqualTo(user_id)
        // If user not actually from this auth provider, we can't handle updated
        // permissions.
        if (!(object instanceof MySQLUser))
            throw new GuacamoleException("User not from database.");
        
        permissionCheckUtility.verifyUserUpdateAccess(this.user_id,
        MySQLUser mySQLUser = (MySQLUser) object;
        userDAO.updateByPrimaryKeySelective(mySQLUser.toUserWithBLOBs());
        createPermissions(0 /* STUB */, mySQLUser.getNewPermissions());
        removePermissions(0 /* STUB */, mySQLUser.getRemovedPermissions());

        // The appropriate permissions have been inserted and deleted, so
        // reset the new and removed permission sets.
        mySQLUser.resetPermissions();
        permissionCheckUtility.verifyUserDeleteAccess(this.user_id,
        deleteAllPermissions(mySQLUser.getUserID());
     * @param user_id The ID of the user to delete all permissions of.
    private void deleteAllPermissions(int user_id) {
        userPermissionExample.createCriteria().andUser_idEqualTo(user_id);
        connectionPermissionExample.createCriteria().andUser_idEqualTo(user_id);
        systemPermissionExample.createCriteria().andUser_idEqualTo(user_id);
        userPermissionExample.createCriteria().andAffected_user_idEqualTo(user_id);
    @Deprecated /* FIXME: Totally useless (we only ever need usernames, and querying ALL USER DATA will take ages) */

        // Get all IDs of all users that the given user can perform the given
        // operation on

        // If no affected users at all, return empty set
        if (affectedUserIDs.isEmpty())
            return Collections.EMPTY_SET;
        
        // Query corresponding user data for each retrieved ID

        // Build set of MySQLUsers from retrieved user data

import java.util.Collections;
        mySQLUser.init(user);

        // Query user by ID
        UserExample example = new UserExample();
        example.createCriteria().andUsernameEqualTo(name);
        List<UserWithBLOBs> users = userDAO.selectByExampleWithBLOBs(example);

        // If no user found, return null
        if(users.isEmpty())
            return null;

        // Otherwise, return found user
        return getExistingMySQLUser(users.get(0));


        // Query user by ID

        // If no user found, return null

        // Otherwise, return found user

            newPermission.setUser_id(user_id);
        createPermissions(mySQLUser.getUserID(), mySQLUser.getNewPermissions());
        removePermissions(mySQLUser.getUserID(), mySQLUser.getRemovedPermissions());
    private PermissionCheckService permissionCheckUtility;
    private ProviderService providerUtility;
    private ConnectionMapper connectionDAO;
    private ConnectionPermissionMapper connectionPermissionDAO;
    private ConnectionParameterMapper connectionParameterDAO;
    public void init(int user_id) {
    private ConnectionMapper connectionDAO;
    private ConnectionParameterMapper connectionParameterDAO;
    private ProviderService providerUtility;
    private ActiveConnectionSet activeConnectionSet;
    private ConfigurationTranslationService configurationTranslationUtility;
    public MySQLConnection() {
    private UserMapper userDAO;
    private ConnectionMapper connectionDAO;
    private ProviderService providerUtility;
    private ActiveConnectionSet activeConnectionSet;
    /**
     * Service for encrypting passwords.
     */
    private PasswordEncryptionService passwordUtility;
    /**
     * Service for generating random salts.
     */
    private SaltService saltUtility;
    /**
     * Service for checking permissions.
     */
    private PermissionCheckService permissionCheckUtility;
    public void init(int user_id) {
    private UserMapper userDAO;
    private ConnectionMapper connectionDAO;
    private UserPermissionMapper userPermissionDAO;
    private ConnectionPermissionMapper connectionPermissionDAO;
    private SystemPermissionMapper systemPermissionDAO;
    private PermissionCheckService permissionCheckUtility;
    private ProviderService providerUtility;
    /**
     * Service for encrypting passwords.
     */
    private PasswordEncryptionService passwordUtility;
    /**
     * Service for generating random salts.
     */
    private SaltService saltUtility;
    public void init(int user_id) {
    private UserMapper userDAO;
    private ConnectionMapper connectionDAO;
    private UserPermissionMapper userPermissionDAO;
    private ConnectionPermissionMapper connectionPermissionDAO;
    private SystemPermissionMapper systemPermissionDAO;
    private Provider<MySQLUser> mySQLUserProvider;
    private Provider<MySQLConnection> mySQLConnectionProvider;
     *





     *
     *
     *




     *
     *
     *




     * Add the given permissions to the given user.
     * @param user_id The ID of the user whose permissions should be updated.
     * @param permissions The permissions to add.
        createUserPermissions(user_id, newUserPermissions);
        createConnectionPermissions(user_id, newConnectionPermissions);
        createSystemPermissions(user_id, newSystemPermissions);

    /**
     * Remove the given permissions from the given user.
     *
     * @param user_id The ID of the user whose permissions should be updated.
     * @param permissions The permissions to remove.
     * @throws GuacamoleException If an error occurs while updating the
     *                            permissions of the given user.
     */
    private void removePermissions(int user_id, Set<Permission> permissions)
            throws GuacamoleException {


        deleteUserPermissions(user_id, removedUserPermissions);
        deleteConnectionPermissions(user_id, removedConnectionPermissions);
        deleteSystemPermissions(user_id, removedSystemPermissions);

     * Create the given user permissions for the given user.
     * @param user_id The ID of the user to change the permissions of.
    private void createUserPermissions(int user_id,
            Collection<UserPermission> permissions)


     * @param user_id The ID of the user to change the permissions of.
    private void deleteUserPermissions(int user_id,
            Collection<UserPermission> permissions)



     * @param user_id The ID of the user to assign or remove permissions from.
    private void createConnectionPermissions(int user_id,
            Collection<ConnectionPermission> permissions)

     * @param user_id The ID of the user to change the permissions of.
    private void deleteConnectionPermissions(int user_id,
            Collection<ConnectionPermission> permissions)



     * @param user_id The ID of the user whose permissions should be updated.
    private void createSystemPermissions(int user_id,
            Collection<SystemPermission> permissions) {


     * @param user_id The ID of the user whose permissions should be updated.
    private void deleteSystemPermissions(int user_id,
            Collection<SystemPermission> permissions) {




        // If connection permissions present, add permissions

package net.sourceforge.guacamole.net.auth.mysql;

        PasswordEncryptionService passwordService =
                injector.getInstance(PasswordEncryptionService.class);
        if (!passwordService.checkPassword(credentials.getPassword(),
                user.getPassword_hash(), user.getPassword_salt()))

package net.sourceforge.guacamole.net.auth.mysql.service;

     * Checks whether the provided, unhashed password matches the given
     * hash/salt pair.
     *
     * @param credentials The credentials to validate.
     * @param hashedPassword The hashed password to compare the given password
     *                       against.
     * @param salt The salt used when the hashed password given was created.
     * @return true if the provided credentials match the values given, false
     *         otherwise.
    public boolean checkPassword(String password, byte[] hashedPassword,
            byte[] salt);
     * Creates a password hash based on the provided username, password, and
     * salt.
     *
     * @param password The password to hash.
     * @param salt The salt to use when hashing the password.
     * @return The generated password hash.
    public boolean checkPassword(String password, byte[] hashedPassword,
        byte[] salt) {
        byte[] passwordBytes = createPasswordHash(password, salt);
        return Arrays.equals(passwordBytes, hashedPassword);
     * @param password The unhashed password to validate.
    private PermissionCheckService permissionCheckService;
    private ProviderService providerService;
        permissionCheckService.verifyConnectionReadAccess(this.user_id, identifier);
        return providerService.getExistingMySQLConnection(identifier);
        Set<MySQLConnection> connections = permissionCheckService.getReadableConnections(this.user_id);
        permissionCheckService.verifyCreateConnectionPermission(this.user_id);
        MySQLConnection mySQLConnection = providerService.getNewMySQLConnection(object);
        permissionCheckService.verifyConnectionUpdateAccess(this.user_id, object.getIdentifier());
        MySQLConnection mySQLConnection = providerService.getExistingMySQLConnection(object);
        permissionCheckService.verifyConnectionDeleteAccess(this.user_id, identifier);
        MySQLConnection mySQLConnection = providerService.getExistingMySQLConnection(identifier);
    private ProviderService providerService;
    private ConfigurationTranslationService configurationTranslationService;
        configuration = configurationTranslationService.getConfiguration(connection.getProtocol(), connectionParameters);
        MySQLGuacamoleSocket mySQLSocket = providerService.getMySQLGuacamoleSocket(configuredSocket, getConnectionID());
        return providerService.getExistingMySQLConnectionRecords(connection.getConnection_id());
    private ProviderService providerService;
        return providerService.getExistingMySQLUser(connectionHistory.getUser_id());
        return providerService.getExistingMySQLConnection(connectionHistory.getConnection_id());
    private PasswordEncryptionService passwordService;
    private SaltService saltService;
    private PermissionCheckService permissionCheckService;
                permissionCheckService.getAllPermissions(user.getUser_id()));
            byte[] salt = saltService.generateSalt();
                passwordService.createPasswordHash(getPassword(), salt));
     * Service for checking various permissions, which will be injected.
    private PermissionCheckService permissionCheckService;
     * Service providing convenient access to object creation and
    private ProviderService providerService;
    private PasswordEncryptionService passwordService;
    private SaltService saltService;
        permissionCheckService.verifyUserReadAccess(this.user_id, identifier);
        return providerService.getExistingMySQLUser(identifier);
        Set<MySQLUser> users = permissionCheckService.getReadableUsers(this.user_id);
        permissionCheckService.verifyCreateUserPermission(this.user_id);
            byte[] salt = saltService.generateSalt();
                passwordService.createPasswordHash(object.getPassword(), salt));
                permissionCheckService.getAdministerableUserIDs(this.user_id);
                permissionCheckService.getAdministerableUserIDs(this.user_id);
                permissionCheckService.getAdministerableConnectionIDs(this.user_id);
                permissionCheckService.getAdministerableConnectionIDs(this.user_id);
        permissionCheckService.verifyUserUpdateAccess(this.user_id,
        permissionCheckService.verifyUserDeleteAccess(this.user_id,
        MySQLUser mySQLUser = providerService.getExistingMySQLUser(identifier);
        init(null, name, null, Collections.EMPTY_SET);
        init(null, user.getUsername(), user.getPassword(), user.getPermissions());
     * @param userID The ID of the user in the database, if any.
     * @param username The username of this user.
     * @param password The password to assign to this user.
     * @param permissions The permissions to assign to this user, as
     *                    retrieved from the database.
    public void init(Integer userID, String username, String password,
            Set<Permission> permissions) {
        this.userID = userID;
        setUsername(username);
        setPassword(password);
        permissions.addAll(permissions);
        // Build database user from non-database structure
        UserWithBLOBs user = new UserWithBLOBs();
        user.setUser_id(mySQLUser.getUserID());
        user.setUsername(mySQLUser.getUsername());

        // Set password if specified
        if (mySQLUser.getPassword() != null) {
            byte[] salt = saltService.generateSalt();
            user.setPassword_salt(salt);
            user.setPassword_hash(
                passwordService.createPasswordHash(mySQLUser.getPassword(), salt));
        }

        // Update the user in the database
        userDAO.updateByPrimaryKeySelective(user);
            mySQLUser.init(affectedUser.getUsername());
     * Service for checking permissions.
     */
    @Inject
    private PermissionCheckService permissionCheckService;

    /**
        mySQLUser.init(
            user.getUser_id(),
            user.getUsername(),
            permissionCheckService.getAllPermissions(user.getUser_id())
        );

            null,

package net.sourceforge.guacamole.net.auth.mysql;

 * A MySQL-based implementation of the connection directory.
 * 
    /**
     * Service for checking permissions.
     */
    /**
     * Service for creating and retrieving objects.
     */
    /**
     * Service for manipulating connections in the database.
     */
    /**
     * Service for manipulating connection permissions in the database.
     */
    /**
     * Service for manipulating connection parameters in the database.
     */

        // Verify permission to create
        // Create database object for insert
        net.sourceforge.guacamole.net.auth.mysql.model.Connection connection =
            new net.sourceforge.guacamole.net.auth.mysql.model.Connection();
        connection.setConnection_name(object.getIdentifier());
        connection.setProtocol(object.getConfiguration().getProtocol());
        connectionDAO.insert(connection);
        // Add connection parameters
        createConfigurationValues(connection.getConnection_id(),
                object.getConfiguration());

        // Finally, give the current user full access to the newly created
        // connection.
        newConnectionPermission.setConnection_id(connection.getConnection_id());

        // Read permission
        newConnectionPermission.setPermission(MySQLConstants.CONNECTION_READ);

        // Update permission
        newConnectionPermission.setPermission(MySQLConstants.CONNECTION_UPDATE);

        // Delete permission
        newConnectionPermission.setPermission(MySQLConstants.CONNECTION_DELETE);

        // Administer permission
        newConnectionPermission.setPermission(MySQLConstants.CONNECTION_ADMINISTER);

     * Inserts all parameter values from the given configuration into the
     * database, associating them with the connection having the givenID.
     * 
     * @param connection_id The ID of the connection to associate all
     *                      parameters with.
     * @param config The GuacamoleConfiguration to read parameters from.
    private void createConfigurationValues(int connection_id,
            GuacamoleConfiguration config) {
        // Insert new parameters for each parameter in the config
        for (String name : config.getParameterNames()) {
            // Create a ConnectionParameter based on the current parameter
            ConnectionParameter parameter = new ConnectionParameter();
            parameter.setConnection_id(connection_id);
            parameter.setParameter_name(name);
            parameter.setParameter_value(config.getParameter(name));
            // Insert connection parameter



        // Verify permission to update
        // TODO: Rely on update() to be given MySQLConnection
        MySQLConnection mySQLConnection =
                providerService.getExistingMySQLConnection(object);
        // Create database object for insert
        net.sourceforge.guacamole.net.auth.mysql.model.Connection connection =
            new net.sourceforge.guacamole.net.auth.mysql.model.Connection();

        connection.setConnection_id(mySQLConnection.getConnectionID());
        connection.setConnection_name(object.getIdentifier());
        connection.setProtocol(object.getConfiguration().getProtocol());
        connectionDAO.updateByPrimaryKey(connection);

        // Delete old connection parameters
        ConnectionParameterExample parameterExample = new ConnectionParameterExample();
        parameterExample.createCriteria().andConnection_idEqualTo(connection.getConnection_id());
        connectionParameterDAO.deleteByExample(parameterExample);
        
        // Add connection parameters
        createConfigurationValues(connection.getConnection_id(),
                object.getConfiguration());


        // Verify permission to delete
        // Delete all configuration values
        // Delete all permissions that refer to this connection
        // Delete the connection itself

import java.util.ArrayList;
import java.util.Collections;
import net.sourceforge.guacamole.net.auth.AbstractConnection;
public class MySQLConnection extends AbstractConnection {
    /**
     * The ID associated with this connection in the database.
     */
    private Integer connectionID;
    /**
     * History of this connection.
     */
    private List<ConnectionRecord> history = new ArrayList<ConnectionRecord>();
     * Get the ID of the corresponding connection record.
     * @return The ID of the corresponding connection, if any.
    public Integer getConnectionID() {
        return connectionID;
     * Sets the ID of the corresponding connection record.
     * @param connectionID The ID to assign to this connection.
    public void setConnectionID(Integer connectionID) {
        this.connectionID = connectionID;
     * Initialize a new MySQLConnection from this existing connection.
     *
     * @param connection The connection to use when populating the identifier
     *                   and configuration of this connection.
     * @throws GuacamoleException If permission to read the given connection's
     *                            history is denied.
    public void init(Connection connection) throws GuacamoleException {
        init(null, connection.getIdentifier(), connection.getConfiguration(), connection.getHistory());
     * Initialize from explicit values.
     *
     * @param connectionID The ID of the associated database record, if any.
     * @param identifier The unique identifier associated with this connection.
     * @param config The GuacamoleConfiguration associated with this connection.
     * @param history All ConnectionRecords associated with this connection.
    public void init(Integer connectionID, String identifier,
            GuacamoleConfiguration config,
            List<? extends ConnectionRecord> history) {
        this.connectionID = connectionID;
        setIdentifier(identifier);
        setConfiguration(config);
        this.history.addAll(history);

        // Get guacd connection information
        // Get socket
        GuacamoleSocket socket = providerService.getMySQLGuacamoleSocket(
            new ConfiguredGuacamoleSocket(
                    new InetGuacamoleSocket(host, port),
                    getConfiguration()
            ),
            getConnectionID()
        );
        // Mark this connection as active
        return socket;
        return Collections.unmodifiableList(history);

        this.permissions.addAll(permissions);
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
    @Deprecated /* FIXME: Totally useless (we only ever need identifiers, and querying ALL CONNECTION DATA will take ages) */
                mySQLConnection.init(
                    affectedConnection.getConnection_id(),
                    affectedConnection.getConnection_name(),
                    new GuacamoleConfiguration(),
                    Collections.EMPTY_LIST
                );
import java.util.Collections;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionParameterMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameter;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionParameterExample;
import net.sourceforge.guacamole.protocol.GuacamoleConfiguration;
    private UserMapper userDAO;
    private ConnectionMapper connectionDAO;
    private ConnectionParameterMapper connectionParameterDAO;
    private ConnectionHistoryMapper connectionHistoryDAO;
    private Provider<MySQLUser> mySQLUserProvider;
    private Provider<MySQLConnection> mySQLConnectionProvider;

    @Inject
    private Provider<MySQLConnectionRecord> mySQLConnectionRecordProvider;

    @Inject
    private Provider<MySQLGuacamoleSocket> mySQLGuacamoleSocketProvider;
        UserWithBLOBs user = userDAO.selectByPrimaryKey(id);
        if(user == null)
        return getExistingMySQLUser(user);

        // Query connection by ID
        ConnectionExample example = new ConnectionExample();
        example.createCriteria().andConnection_nameEqualTo(name);
        List<net.sourceforge.guacamole.net.auth.mysql.model.Connection> connections =
                connectionDAO.selectByExample(example);

        // If no connection found, return null
        if(connections.isEmpty())
            return null;

        // Otherwise, return found connection
        return getExistingMySQLConnection(connections.get(0));


        // Build configuration
        GuacamoleConfiguration config = new GuacamoleConfiguration();

        // Query parameters for configuration
        ConnectionParameterExample connectionParameterExample = new ConnectionParameterExample();
        connectionParameterExample.createCriteria().andConnection_idEqualTo(connection.getConnection_id());
        List<ConnectionParameter> connectionParameters =
                connectionParameterDAO.selectByExample(connectionParameterExample);

        // Set protocol
        config.setProtocol(connection.getProtocol());

        // Set all values for all parameters
        for (ConnectionParameter parameter : connectionParameters)
            config.setParameter(parameter.getParameter_name(),
                    parameter.getParameter_value());

        // Create new MySQLConnection from retrieved data
        mySQLConnection.init(
            connection.getConnection_id(),
            connection.getConnection_name(),
            config,
            Collections.EMPTY_LIST // TODO: Read history
        );



        // Query connection by ID
        net.sourceforge.guacamole.net.auth.mysql.model.Connection connection =
                connectionDAO.selectByPrimaryKey(id);

        // If no connection found, return null
        if(connection == null)

        // Otherwise, return found connection
        return getExistingMySQLConnection(connection);

    @Override
    public int hashCode() {
        if (identifier == null) return 0;
        return identifier.hashCode();
    }

    @Override
    public boolean equals(Object obj) {

        // Not equal if null or not a User
        if (obj == null) return false;
        if (!(obj instanceof AbstractConnection)) return false;

        // Get identifier
        String objIdentifier = ((AbstractConnection) obj).identifier;

        // If null, equal only if this identifier is null
        if (objIdentifier == null) return identifier == null;

        // Otherwise, equal only if strings are identical
        return objIdentifier.equals(identifier);

    }

 *
     *

    /**
     * Service for creating and retrieving objects.
     */
    /**
     * Set of all currently active connections.
     */
            Connection connection = directory.get(identifier);
        // If connection not actually from this auth provider, we can't handle
        // the update
        if (!(object instanceof MySQLConnection))
            throw new GuacamoleException("Connection not from database.");

        MySQLConnection mySQLConnection = (MySQLConnection) object;
public class SystemPermission implements Permission<SystemPermission.Type> {
         * Create users.
        CREATE_USER,

        /**
         * Create connections.
         */
        CREATE_CONNECTION,

        /**
         * Administer the system in general, including adding permissions
         * which affect the system (like user creation, connection creation,
         * and system administration).
         */
        ADMINISTER
    /**
     * The type of operation affected by this permission.
     */
    private Type type;

    /**
     * Creates a new SystemPermission with the given
     * type.
     *
     * @param type The type of operation controlled by this permission.
     */
    public SystemPermission(Type type) {
        this.type = type;
    }

    @Override
    public Type getType() {
        return type;
    }

    @Override
    public int hashCode() {
        return type.hashCode();
    }

    @Override
    public boolean equals(Object obj) {

        // Not equal if null or wrong type
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;

        final SystemPermission other = (SystemPermission) obj;

        // Compare types
        if (type != other.type)
            return false;

        return true;
    }


            switch (permission.getType()) {
                // Create connection permission
                case CREATE_CONNECTION:
                    systemPermissionTypes.add(MySQLConstants.SYSTEM_CONNECTION_CREATE);
                    break;
                // Create user permission
                case CREATE_USER:
                    systemPermissionTypes.add(MySQLConstants.SYSTEM_USER_CREATE);
                    break;
                // Fail if unexpected type encountered
                default:
                    assert false : "Unsupported type: "  permission.getType();
        if (permissions.isEmpty())
            switch (permission.getType()) {
                // Create connection permission
                case CREATE_CONNECTION:
                    systemPermissionTypes.add(MySQLConstants.SYSTEM_CONNECTION_CREATE);
                    break;
                // Create user permission
                case CREATE_USER:
                    systemPermissionTypes.add(MySQLConstants.SYSTEM_USER_CREATE);
                    break;
                // Fail if unexpected type encountered
                default:
                    assert false : "Unsupported type: "  permission.getType();
        SystemPermissionExample systemPermissionExample = new SystemPermissionExample();
        systemPermissionExample.createCriteria().andUser_idEqualTo(user_id)
                .andPermissionIn(systemPermissionTypes);
        systemPermissionDAO.deleteByExample(systemPermissionExample);

import net.sourceforge.guacamole.net.auth.permission.SystemPermission;
                allPermissions.add(new SystemPermission(SystemPermission.Type.CREATE_USER));
                allPermissions.add(new SystemPermission(SystemPermission.Type.CREATE_CONNECTION));
                // If update permission available, include parameters
            case CREATE_USER:       return "create-user";
            case CREATE_CONNECTION: return "create-connection";
            case ADMINISTER:        return "admin";
                // System permission
                if (permission instanceof SystemPermission) {
                    SystemPermission sp = (SystemPermission) permission;
                    xml.writeEmptyElement("system");
                    xml.writeAttribute("type", toString(sp.getType()));
     * String given for user creation permission.
    private static final String CREATE_USER_PERMISSION = "create-user";

    /**
     * String given for connection creation permission.
     */
    private static final String CREATE_CONNECTION_PERMISSION = "create-connection";

    /**
     * String given for system administration permission.
     */
    private static final String ADMIN_PERMISSION = "admin";
     * Given a permission string, returns the corresponding system permission.
     *
     * @param str The permission string to parse.
     * @return The parsed system permission.
     * @throws GuacamoleException If the given string could not be parsed.
     */
    private Permission parseSystemPermission(String str)
            throws GuacamoleException {

        // Create user 
        if (str.startsWith(CREATE_USER_PERMISSION))
            return new SystemPermission(SystemPermission.Type.CREATE_USER);

        // Create connection 
        if (str.startsWith(CREATE_CONNECTION_PERMISSION))
            return new SystemPermission(SystemPermission.Type.CREATE_CONNECTION);

        // Administration
        if (str.startsWith(ADMIN_PERMISSION))
            return new SystemPermission(SystemPermission.Type.ADMINISTER);

        throw new GuacamoleException("Invalid permission string.");

    }

    /**
            /*
             * NEW PERMISSIONS
             */
            
            // Set added system permissions
            String[] add_sys_permission = request.getParameterValues("sys");
            if (add_sys_permission != null) {
                for (String str : add_sys_permission)
                    user.addPermission(parseSystemPermission(str));
            }

            // Set added user permissions
            // Set added connection permissions
            /*
             * REMOVED PERMISSIONS
             */
            
            // Unset removed system permissions
            String[] remove_sys_permission = request.getParameterValues("-sys");
            if (remove_sys_permission != null) {
                for (String str : remove_sys_permission)
                    user.removePermission(parseSystemPermission(str));
            }

            // Unset removed user permissions
            // Unset removed connection permissions
        // Create user
        // Create connection


import net.sourceforge.guacamole.net.auth.mysql.service.UserService;
        // Get user service
        UserService userService = injector.getInstance(UserService.class);
        
        // Get user
        MySQLUser authenticatedUser = userService.retrieveUser(credentials);
        if (authenticatedUser != null) {
            MySQLUserContext context = injector.getInstance(MySQLUserContext.class);
            context.init(authenticatedUser.getUserID());
            return context;
        }
        // Otherwise, unauthorized
        return null;
                    bind(UserService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.UserService;
     * Service for accessing users.
    private UserService userService;
        // FIXME: This will be SLOW - history is queried in bulk. When listed
        // to the user in the webapp, this will result in one query per record.
        return userService.retrieveUser(connectionHistory.getUser_id());
import net.sourceforge.guacamole.net.auth.mysql.service.UserService;
     * Service for accessing users.
    private UserService userService;
        return userService.retrieveUser(user_id);
import net.sourceforge.guacamole.net.auth.mysql.service.UserService;
     * Service for accessing users.
    private UserService userService;
        return userService.retrieveUser(identifier);
        // Create new user
        MySQLUser user = userService.createUser(object.getUsername(),
                object.getPassword());
        createPermissions(user.getUserID(), object.getPermissions());
        newUserPermission.setAffected_user_id(user.getUserID());
        List<MySQLUser> users = userService.retrieveUsersByUsername(usernames);
        Map<String, MySQLUser> userMap = new HashMap<String, MySQLUser>();
        for (MySQLUser user : users)
            userMap.put(user.getUsername(), user);
            MySQLUser affectedUser =
                    userMap.get(permission.getObjectIdentifier());
            if (affectedUser == null)
            if (!administerableUsers.contains(affectedUser.getUserID()))
                     affectedUser.getUsername());
            newPermission.setAffected_user_id(affectedUser.getUserID());
        List<MySQLUser> users = userService.retrieveUsersByUsername(usernames);
        Map<String, MySQLUser> userMap = new HashMap<String, MySQLUser>();
        for (MySQLUser user : users) {
            userMap.put(user.getUsername(), user);
            userIDs.add(user.getUserID());
            MySQLUser affectedUser = userMap.get(permission.getObjectIdentifier());
            if (affectedUser == null)
            if (!administerableUsers.contains(affectedUser.getUserID()))
                     affectedUser.getUsername());
        MySQLUser mySQLUser = (MySQLUser) object;
        userService.updateUser(mySQLUser);
        // FIXME: Querying permissions here will query the user to determine
        // its ID, and that same user will be queried AGAIN later when
        // deleted, again - to determine its ID. Perhaps we want cascading
        // deletes in the schema?
        
        // Delete specified user
        userService.deleteUser(identifier);
    private UserService userService;
        MySQLUser affectedUser = userService.retrieveUser(affectedUsername);
            return checkUserAccess(userID, affectedUser.getUserID(), permissionType);
        return new HashSet<MySQLUser>(userService.retrieveUsersByID(
                Lists.newArrayList(affectedUserIDs)));
            List<MySQLUser> users = userService.retrieveUsersByID(affectedUserIDs);
            Map<Integer, MySQLUser> userMap = new HashMap<Integer, MySQLUser>();
            for (MySQLUser user : users)
                userMap.put(user.getUserID(), user);
                MySQLUser affectedUser = userMap.get(userPermission.getAffected_user_id());
    /**
     * The string stored in the database to represent permission to administer
     * the system as a whole.
     */
    public static final String SYSTEM_ADMINISTER = "ADMINISTER";

            // System administration permission
            else if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_ADMINISTER))
                allPermissions.add(new SystemPermission(SystemPermission.Type.ADMINISTER));



     *
     *
     *

     *
     *

     *

     *
     *
     *


     *
    public MySQLUser retrieveUser(int id) {
     * Deletes the user having the given username from the database.
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
     * Service managing connections.
    private ConnectionService connectionService;
        return connectionService.retrieveConnection(identifier);
        // Get connection
        MySQLConnection mySQLConnection =
                connectionService.retrieveConnection(identifier);
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
                    bind(ConnectionService.class);

package net.sourceforge.guacamole.net.auth.mysql;

import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
     * Service for managing connections.
    private ConnectionService connectionService;
        return connectionService.connect(this, info);
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
     * Service for accessing connections.
    private ConnectionService connectionService;
        return connectionService.retrieveConnection(connectionHistory.getConnection_id());
 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/service/SHA256PasswordEncryptionService.java
public class SHA256PasswordEncryptionService implements PasswordEncryptionService {
        // Create connection
        MySQLConnection connection = connectionService.createConnection(
                object.getIdentifier(), object.getConfiguration().getProtocol());
        createConfigurationValues(connection.getConnectionID(),
        newConnectionPermission.setConnection_id(connection.getConnectionID());
        connectionService.updateConnection(mySQLConnection);
        parameterExample.createCriteria().andConnection_idEqualTo(mySQLConnection.getConnectionID());
        createConfigurationValues(mySQLConnection.getConnectionID(),
        connectionService.deleteConnection(mySQLConnection.getConnectionID());
import net.sourceforge.guacamole.net.auth.mysql.service.SHA256PasswordEncryptionService;
                    bind(PasswordEncryptionService.class).to(SHA256PasswordEncryptionService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
     * Service for accessing connections.
    private ConnectionService connectionService;
        List<MySQLConnection> connections = connectionService.retrieveConnectionsByName(connectionNames);
        Map<String, MySQLConnection> connectionMap = new HashMap<String, MySQLConnection>();
        for (MySQLConnection connection : connections)
            connectionMap.put(connection.getIdentifier(), connection);
            MySQLConnection connection = connectionMap.get(permission.getObjectIdentifier());
            if (connection == null)
            if (!administerableConnections.contains(connection.getConnectionID()))
                     connection.getIdentifier());
            newPermission.setConnection_id(connection.getConnectionID());
        List<MySQLConnection> connections = connectionService.retrieveConnectionsByName(identifiers);
        Map<String, MySQLConnection> connectionMap = new HashMap<String, MySQLConnection>();
        for (MySQLConnection connection : connections) {
            connectionMap.put(connection.getIdentifier(), connection);
            connectionIDs.add(connection.getConnectionID());
            MySQLConnection connection = connectionMap.get(permission.getObjectIdentifier());
            if (connection == null)
            if (!administerableConnections.contains(connection.getConnectionID()))
                     connection.getIdentifier());
     * Retrieves the connections having the given IDs from the database.
     *
     * @param ids The IDs of the connections to retrieve.
     * @return A list of existing MySQLConnection objects.
     */
    public List<MySQLConnection> retrieveConnectionsByID(List<Integer> ids) {

        // If no IDs given, just return empty list
        if (ids.isEmpty())
            return Collections.EMPTY_LIST;

        // Query connections by ID
        ConnectionExample example = new ConnectionExample();
        example.createCriteria().andConnection_idIn(ids);
        List<Connection> connections = connectionDAO.selectByExample(example);

        // Convert to MySQLConnection list
        List<MySQLConnection> mySQLConnections = new ArrayList<MySQLConnection>(connections.size());
        for (Connection connection : connections)
            mySQLConnections.add(toMySQLConnection(connection));

        // Return found connections
        return mySQLConnections;

    }

    /**
     * Retrieves the connections having the given names from the database.
     *
     * @param names The names of the connections to retrieve.
     * @return A list of existing MySQLConnection objects.
     */
    public List<MySQLConnection> retrieveConnectionsByName(List<String> names) {

        // If no names given, just return empty list
        if (names.isEmpty())
            return Collections.EMPTY_LIST;

        // Query connections by ID
        ConnectionExample example = new ConnectionExample();
        example.createCriteria().andConnection_nameIn(names);
        List<Connection> connections = connectionDAO.selectByExample(example);

        // Convert to MySQLConnection list
        List<MySQLConnection> mySQLConnections = new ArrayList<MySQLConnection>(connections.size());
        for (Connection connection : connections)
            mySQLConnections.add(toMySQLConnection(connection));

        // Return found connections
        return mySQLConnections;

    }

    /**
    /**
     * Creates a new connection having the given name and protocol.
     *
     * @param name The name to assign to the new connection.
     * @param protocol The protocol to assign to the new connection.
     * @return A new MySQLConnection containing the data of the newly created
     *         connection.
     */
    public MySQLConnection createConnection(String name, String protocol) {

        // Initialize database connection
        Connection connection = new Connection();
        connection.setConnection_name(name);
        connection.setProtocol(protocol);

        // Create connection
        connectionDAO.insert(connection);
        return toMySQLConnection(connection);

    }

    /**
     * Deletes the connection having the given name from the database.
     * @param name The name of the connection to delete.
     */
    public void deleteConnection(String name) {

        // Get specified connection
        MySQLConnection mySQLConnection = retrieveConnection(name);
        int connection_id = mySQLConnection.getConnectionID();

        // Delete the connection in the database
        deleteConnection(connection_id);

    }

    /**
     * Deletes the connection having the given ID from the database.
     * @param id The ID of the connection to delete.
     */
    public void deleteConnection(int id) {
        connectionDAO.deleteByPrimaryKey(id);
    }

    /**
     * Updates the connection in the database corresponding to the given
     * MySQLConnection.
     *
     * @param mySQLConnection The MySQLConnection to update (save) to the
     *                        database. This connection must already exist.
     */
    public void updateConnection(MySQLConnection mySQLConnection) {

        // Populate connection
        Connection connection = new Connection();
        connection.setConnection_id(mySQLConnection.getConnectionID());
        connection.setConnection_name(mySQLConnection.getIdentifier());
        connection.setProtocol(mySQLConnection.getConfiguration().getProtocol());

        // Update the connection in the database
        connectionDAO.updateByPrimaryKeySelective(connection);

    }


    /**
     * Service for accessing users.
     */
    /**
     * Service for accessing connections.
     */
    private ConnectionService connectionService;
        MySQLConnection connection = connectionService.retrieveConnection(affectedConnectionName);
            return checkConnectionAccess(userID, connection.getConnectionID(), permissionType);
        return new HashSet<MySQLConnection>(
                connectionService.retrieveConnectionsByID(Lists.newArrayList(affectedConnectionIDs)));
            List<MySQLConnection> connections =
                    connectionService.retrieveConnectionsByID(affectedConnectionIDs);
            Map<Integer, MySQLConnection> connectionMap = new HashMap<Integer, MySQLConnection>();
            for(MySQLConnection connection : connections)
                connectionMap.put(connection.getConnectionID(), connection);
                MySQLConnection affectedConnection =
                        connectionMap.get(connectionPermission.getConnection_id());
                    affectedConnection.getIdentifier()
import net.sourceforge.guacamole.net.auth.permission.ObjectPermission;
import net.sourceforge.guacamole.net.auth.permission.SystemPermission;

    /**
     * Given the type of a permission affecting a user, returns the MySQL
     * constant representing that permission type.
     *
     * @param type The type of permission to look up.
     * @return The MySQL constant corresponding to the given permission type.
     */
    public static String getUserConstant(ObjectPermission.Type type) {

        // Convert permission type to MySQL constant
        switch (type) {
            case READ:       return USER_READ;
            case UPDATE:     return USER_UPDATE;
            case ADMINISTER: return USER_ADMINISTER;
            case DELETE:     return USER_DELETE;
        }

        // If we get here, permission support was not properly implemented
        throw new UnsupportedOperationException(
            "Unsupported permission type: "  type);

    }

    /**
     * Given the type of a permission affecting a connection, returns the MySQL
     * constant representing that permission type.
     *
     * @param type The type of permission to look up.
     * @return The MySQL constant corresponding to the given permission type.
     */
    public static String getConnectionConstant(ObjectPermission.Type type) {

        // Convert permission type to MySQL constant
        switch (type) {
            case READ:       return CONNECTION_READ;
            case UPDATE:     return CONNECTION_UPDATE;
            case ADMINISTER: return CONNECTION_ADMINISTER;
            case DELETE:     return CONNECTION_DELETE;
        }

        // If we get here, permission support was not properly implemented
        throw new UnsupportedOperationException(
            "Unsupported permission type: "  type);

    }


    /**
     * Given the type of a permission affecting the system, returns the MySQL
     * constant representing that permission type.
     *
     * @param type The type of permission to look up.
     * @return The MySQL constant corresponding to the given permission type.
     */
    public static String getSystemConstant(SystemPermission.Type type) {

        // Convert permission type to MySQL constant
        switch (type) {
            case CREATE_USER:       return SYSTEM_USER_CREATE;
            case CREATE_CONNECTION: return SYSTEM_CONNECTION_CREATE;
            case ADMINISTER:        return SYSTEM_ADMINISTER;
        }

        // If we get here, permission support was not properly implemented
        throw new UnsupportedOperationException(
            "Unsupported permission type: "  type);

    }

import java.util.List;

        // Get connection
        MySQLConnection connection =
                connectionService.retrieveConnection(identifier);

        // Verify access is granted
        permissionCheckService.verifyConnectionAccess(
                this.user_id,
                connection.getConnectionID(),
                MySQLConstants.CONNECTION_READ);

        // Return connection
        return connection;


        // List of all connection IDs for which this user has read access
        List<Integer> connectionIDs =
                permissionCheckService.retrieveConnectionIDs(this.user_id,
                MySQLConstants.CONNECTION_READ);

        // Query all associated connections
        return connectionService.translateNames(connectionIDs).keySet();

        permissionCheckService.verifySystemAccess(this.user_id,
                MySQLConstants.SYSTEM_CONNECTION_CREATE);

        // Verify permission to update
        permissionCheckService.verifyConnectionAccess(this.user_id,
                mySQLConnection.getConnectionID(),
                MySQLConstants.CONNECTION_UPDATE);

        // Perform update
        // Verify permission to delete
        permissionCheckService.verifyConnectionAccess(this.user_id,
                mySQLConnection.getConnectionID(),
                MySQLConstants.CONNECTION_DELETE);


        // Get user
        MySQLUser user = userService.retrieveUser(identifier);

        // Verify access is granted
        permissionCheckService.verifyUserAccess(this.user_id,
                user.getUserID(),
                MySQLConstants.USER_READ);

        // Return user

        // List of all user IDs for which this user has read access
        List<Integer> userIDs =
                permissionCheckService.retrieveConnectionIDs(this.user_id,
                MySQLConstants.USER_READ);
        // Query all associated users
        return userService.translateUsernames(userIDs).keySet();
        permissionCheckService.verifySystemAccess(this.user_id,
                MySQLConstants.SYSTEM_USER_CREATE);
        // If no permissions given, stop now
        // Get list of administerable user IDs
        List<Integer> administerableUserIDs =
            permissionCheckService.retrieveUserIDs(this.user_id,
                MySQLConstants.USER_ADMINISTER);
        // Get set of usernames corresponding to administerable users
        Map<String, Integer> administerableUsers =
                userService.translateUsernames(administerableUserIDs);
        // Insert all given permissions
            // Get original ID
            Integer affected_id =
                    administerableUsers.get(permission.getObjectIdentifier());
            if (affected_id == null)
                     permission.getObjectIdentifier());
            newPermission.setPermission(MySQLConstants.getUserConstant(permission.getType()));
            newPermission.setAffected_user_id(affected_id);


        // If no permissions given, stop now
        // Get list of administerable user IDs
        List<Integer> administerableUserIDs =
            permissionCheckService.retrieveUserIDs(this.user_id,
                MySQLConstants.USER_ADMINISTER);
        // Get set of usernames corresponding to administerable users
        Map<String, Integer> administerableUsers =
                userService.translateUsernames(administerableUserIDs);
        // Delete requested permissions
            // Get original ID
            Integer affected_id =
                    administerableUsers.get(permission.getObjectIdentifier());
            if (affected_id == null)
                     permission.getObjectIdentifier());

            // Delete requested permission
            UserPermissionExample userPermissionExample = new UserPermissionExample();
            userPermissionExample.createCriteria()
                .andUser_idEqualTo(user_id)
                .andPermissionEqualTo(MySQLConstants.getUserConstant(permission.getType()))
                .andAffected_user_idEqualTo(affected_id);
            userPermissionDAO.deleteByExample(userPermissionExample);

        // If no permissions given, stop now
        // Get list of administerable connection IDs
        List<Integer> administerableConnectionIDs =
            permissionCheckService.retrieveUserIDs(this.user_id,
                MySQLConstants.CONNECTION_ADMINISTER);
        // Get set of names corresponding to administerable connections
        Map<String, Integer> administerableConnections =
                userService.translateUsernames(administerableConnectionIDs);
        // Insert all given permissions
            // Get original ID
            Integer connection_id =
                    administerableConnections.get(permission.getObjectIdentifier());
            if (connection_id == null)
                     permission.getObjectIdentifier());
            // Create new permission
            newPermission.setPermission(MySQLConstants.getConnectionConstant(permission.getType()));
            newPermission.setConnection_id(connection_id);

        // If no permissions given, stop now
        // Get list of administerable connection IDs
        List<Integer> administerableConnectionIDs =
            permissionCheckService.retrieveUserIDs(this.user_id,
                MySQLConstants.CONNECTION_ADMINISTER);
        // Get set of names corresponding to administerable connections
        Map<String, Integer> administerableConnections =
                userService.translateUsernames(administerableConnectionIDs);
        // Delete requested permissions
            // Get original ID
            Integer connection_id =
                    administerableConnections.get(permission.getObjectIdentifier());
            if (connection_id == null)
                     permission.getObjectIdentifier());

            ConnectionPermissionExample connectionPermissionExample = new ConnectionPermissionExample();
            connectionPermissionExample.createCriteria()
                .andUser_idEqualTo(user_id)
                .andPermissionEqualTo(MySQLConstants.getConnectionConstant(permission.getType()))
                .andConnection_idEqualTo(connection_id);
            connectionPermissionDAO.deleteByExample(connectionPermissionExample);

            switch (permission.getType()) { // TODO: Move this into MySQLConstants
        MySQLUser mySQLUser = (MySQLUser) object;

        permissionCheckService.verifyUserAccess(this.user_id,
                mySQLUser.getUserID(),
                MySQLConstants.USER_UPDATE);
        // Get user pending deletion
        MySQLUser user = userService.retrieveUser(identifier);
        permissionCheckService.verifyUserAccess(this.user_id,
                user.getUserID(),
                MySQLConstants.USER_DELETE);
        userService.deleteUser(user.getUserID());
import java.util.HashMap;
import java.util.Map;
     * Retrieves a translation map of connection names to their corresponding
     * IDs.
     * @param ids The IDs of the connections to retrieve the names of.
     * @return A map containing the names of all connections and their
     *         corresponding IDs.
    public Map<String, Integer> translateNames(List<Integer> ids) {
        // If no IDs given, just return empty map
            return Collections.EMPTY_MAP;
        // Map of all names onto their corresponding IDs.
        Map<String, Integer> names = new HashMap<String, Integer>();

        // Get all connections having the given IDs
        // Produce set of names
            names.put(connection.getConnection_name(),
                      connection.getConnection_id());
        return names;
     * Retrieves a map of all connection names for the given IDs.
     * @param ids The IDs of the connections to retrieve the names of.
     * @return A map containing the names of all connections and their
     *         corresponding IDs.
    public Map<Integer, String> retrieveNames(List<Integer> ids) {
        // If no IDs given, just return empty map
        if (ids.isEmpty())
            return Collections.EMPTY_MAP;
        // Map of all names onto their corresponding IDs.
        Map<Integer, String> names = new HashMap<Integer, String>();

        // Get all connections having the given IDs
        example.createCriteria().andConnection_idIn(ids);
        // Produce set of names
            names.put(connection.getConnection_id(),
                      connection.getConnection_name());
        return names;
    /**
     * DAO for accessing permissions related to users.
     */
    /**
     * DAO for accessing permissions related to connections.
     */
    /**
     * DAO for accessing permissions related to the system as a whole.
     */
     * Verifies that the user has the specified access to the given other
     * user. If permission is denied, a GuacamoleSecurityException is thrown.
     *
     * @param userID The ID of the user to check.
     * @param affectedUserID The user that would be affected by the operation
     *                       if permission is granted.
     * @param permissionType The type of permission to check for.
     * @throws GuacamoleSecurityException If the specified permission is not
     *                                    granted.
    public void verifyUserAccess(int userID, int affectedUserID,
            String permissionType) throws GuacamoleSecurityException {

        // If permission does not exist, throw exception
        if(!checkUserAccess(userID, affectedUserID, permissionType))
            throw new GuacamoleSecurityException("Permission denied.");

     * Verifies that the user has the specified access to the given connection.
     * If permission is denied, a GuacamoleSecurityException is thrown.
     *
     * @param userID The ID of the user to check.
     * @param affectedConnectionID The connection that would be affected by the
     *                             operation if permission is granted.
     * @param permissionType The type of permission to check for.
     * @throws GuacamoleSecurityException If the specified permission is not
     *                                    granted.
    public void verifyConnectionAccess(int userID, int affectedConnectionID, String permissionType) throws GuacamoleSecurityException {

        // If permission does not exist, throw exception
        if(!checkConnectionAccess(userID, affectedConnectionID, permissionType))
            throw new GuacamoleSecurityException("Permission denied.");

    }
    /**
     * Verifies that the user has the specified access to the system. If
     * permission is denied, a GuacamoleSecurityException is thrown.
     *
     * @param userID The ID of the user to check.
     * @param systemPermissionType The type of permission to check for.
     * @throws GuacamoleSecurityException If the specified permission is not
     *                                    granted.
     */
    public void verifySystemAccess(int userID, String systemPermissionType)
            throws GuacamoleSecurityException {

        // If permission does not exist, throw exception
        if(!checkSystemAccess(userID, systemPermissionType))
            throw new GuacamoleSecurityException("Permission denied.");

     * Checks whether a user has the specified type of access to the affected
     * user.
     *
     * @param userID The ID of the user to check.
     * @param affectedUserID The user that would be affected by the operation
     *                       if permission is granted.
     * @param permissionType The type of permission to check for.
     * @return true if the specified permission is granted, false otherwise.
    public boolean checkUserAccess(int userID, Integer affectedUserID, String permissionType) {
        // Check existence of requested permission
        return userPermissionDAO.countByExample(example) > 0;

     * Checks whether a user has the specified type of access to the affected
     * connection.
     *
     * @param userID The ID of the user to check.
     * @param affectedConnectionID The connection that would be affected by the
     *                             operation if permission is granted.
     * @param permissionType The type of permission to check for.
     * @return true if the specified permission is granted, false otherwise.
    public boolean checkConnectionAccess(int userID, Integer affectedConnectionID, String permissionType) {

        // Check existence of requested permission
        ConnectionPermissionExample example = new ConnectionPermissionExample();
        example.createCriteria().andUser_idEqualTo(userID).andConnection_idEqualTo(affectedConnectionID).andPermissionEqualTo(permissionType);
        return connectionPermissionDAO.countByExample(example) > 0;

     * Checks whether a user has the specified type of access to the system.
     *
     * @param userID The ID of the user to check.
     * @param systemPermissionType The type of permission to check for.
     * @return true if the specified permission is granted, false otherwise.
    private boolean checkSystemAccess(int userID, String systemPermissionType) {
        // Check existence of requested permission
        SystemPermissionExample example = new SystemPermissionExample();
        example.createCriteria().andUser_idEqualTo(userID).andPermissionEqualTo(systemPermissionType);
        return systemPermissionDAO.countByExample(example) > 0;
     *
     * @param userID The ID of the user to check.
     * @param permissionType The type of permission to check for.
     * @return A list of all user IDs this user has the specified access to.
    public List<Integer> retrieveUserIDs(int userID, String permissionType) {

        // Query all user permissions for the given user and permission type
        example.setDistinct(true);
        List<UserPermissionKey> userPermissions =
                userPermissionDAO.selectByExample(example);

        // Convert result into list of IDs
        List<Integer> userIDs = new ArrayList<Integer>(userPermissions.size());
     *
     * @param userID The ID of the user to check.
     * @param permissionType The type of permission to check for.
     * @return A list of all connection IDs this user has the specified access
     *         to.
    public List<Integer> retrieveConnectionIDs(int userID,
            String permissionType) {

        // Query all connection permissions for the given user and permission type
        example.setDistinct(true);
        List<ConnectionPermissionKey> connectionPermissions =
                connectionPermissionDAO.selectByExample(example);

        // Convert result into list of IDs
        List<Integer> connectionIDs = new ArrayList<Integer>(connectionPermissions.size());
     * Retrieves all user permissions granted to the user having the given ID.
     *
     * @param userID The ID of the user to retrieve permissions of.
     * @return A set of all user permissions granted to the user having the
     *         given ID.
    public Set<UserPermission> retrieveUserPermissions(int userID) {
        // Set of all permissions
        Set<UserPermission> permissions = new HashSet<UserPermission>();
        // Query all user permissions
        // Get list of affected user IDs
        List<Integer> affectedUserIDs = new ArrayList<Integer>();
        for(UserPermissionKey userPermission : userPermissions)
            affectedUserIDs.add(userPermission.getAffected_user_id());
        // Get corresponding usernames
        Map<Integer, String> affectedUsers =
                userService.retrieveUsernames(affectedUserIDs);
        // Add user permissions
        for(UserPermissionKey userPermission : userPermissions) {
            // Construct permission from data
            UserPermission permission = new UserPermission(
                UserPermission.Type.valueOf(userPermission.getPermission()),
                affectedUsers.get(userPermission.getUser_id())
            );

            // Add to set
            permissions.add(permission);
        return permissions;

    }

    /**
     * Retrieves all connection permissions granted to the user having the
     * given ID.
     *
     * @param userID The ID of the user to retrieve permissions of.
     * @return A set of all user permissions granted to the user having the
     *         given ID.
     */
    public Set<ConnectionPermission> retrieveConnectionPermissions(int userID) {

        // Set of all permissions
        Set<ConnectionPermission> permissions = new HashSet<ConnectionPermission>();

        // Query all connection permissions
        // Get list of affected connection IDs
        List<Integer> connectionIDs = new ArrayList<Integer>();
        for(ConnectionPermissionKey connectionPermission : connectionPermissions)
            connectionIDs.add(connectionPermission.getConnection_id());
        // Get corresponding names
        Map<Integer, String> affectedUsers =
                connectionService.retrieveNames(connectionIDs);
        // Add connection permissions
        for(ConnectionPermissionKey connectionPermission : connectionPermissions) {
            // Construct permission from data
            ConnectionPermission permission = new ConnectionPermission(
                ConnectionPermission.Type.valueOf(connectionPermission.getPermission()),
                affectedUsers.get(connectionPermission.getUser_id())
            );

            // Add to set
            permissions.add(permission);
        return permissions;

    }

    /**
     * Retrieves all permissions granted to the user having the given ID.
     *
     * @param userID The ID of the user to retrieve permissions of.
     * @return A set of all permissions granted to the user having the given
     *         ID.
     */
    public Set<Permission> retrieveAllPermissions(int userID) {

        // Set which will contain all permissions
        Set<Permission> allPermissions = new HashSet<Permission>();

        // Add user permissions
        allPermissions.addAll(retrieveUserPermissions(userID));

        // Add connection permissions
        allPermissions.addAll(retrieveConnectionPermissions(userID));

        // TODO: Move to retrieveSystemPermissions()


import java.util.HashMap;
import java.util.Map;
            permissionCheckService.retrieveAllPermissions(user.getUser_id())
     * Retrieves a translation map of usernames to their corresponding IDs.
     *
     * @param ids The IDs of the users to retrieve the usernames of.
     * @return A map containing the names of all users and their corresponding
     *         IDs.
     */
    public Map<String, Integer> translateUsernames(List<Integer> ids) {

        // If no IDs given, just return empty map
        if (ids.isEmpty())
            return Collections.EMPTY_MAP;

        // Map of all names onto their corresponding IDs
        Map<String, Integer> names = new HashMap<String, Integer>();

        // Get all users having the given IDs
        UserExample example = new UserExample();
        example.createCriteria().andUser_idIn(ids);
        List<net.sourceforge.guacamole.net.auth.mysql.model.User> users =
                userDAO.selectByExample(example);

        // Produce set of names
        for (net.sourceforge.guacamole.net.auth.mysql.model.User user : users)
            names.put(user.getUsername(), user.getUser_id());

        return names;

    }

    /**
     * Retrieves a map of all usernames for the given IDs.
     *
     * @param ids The IDs of the users to retrieve the usernames of.
     * @return A map containing the names of all users and their corresponding
     *         IDs.
     */
    public Map<Integer, String> retrieveUsernames(List<Integer> ids) {

        // If no IDs given, just return empty map
        if (ids.isEmpty())
            return Collections.EMPTY_MAP;

        // Map of all names onto their corresponding IDs
        Map<Integer, String> names = new HashMap<Integer, String>();

        // Get all users having the given IDs
        UserExample example = new UserExample();
        example.createCriteria().andUser_idIn(ids);
        List<net.sourceforge.guacamole.net.auth.mysql.model.User> users =
                userDAO.selectByExample(example);

        // Produce set of names
        for (net.sourceforge.guacamole.net.auth.mysql.model.User user : users)
            names.put(user.getUser_id(), user.getUsername());

        return names;

    }

    /**
     * Deletes the user having the given ID from the database.
     * @param user_id The ID of the user to delete.
    public void deleteUser(int user_id) {
            permissionCheckService.retrieveConnectionIDs(this.user_id,
                connectionService.translateNames(administerableConnectionIDs);
                affectedUsers.get(userPermission.getAffected_user_id())
        Map<Integer, String> affectedConnections =
                affectedConnections.get(connectionPermission.getConnection_id())
        // If no permissions given, stop now
        // Insert all requested permissions
            newSystemPermission.setPermission(MySQLConstants.getSystemConstant(permission.getType()));
        // If no permissions given, stop now
        for (SystemPermission permission : permissions)
            systemPermissionTypes.add(MySQLConstants.getSystemConstant(permission.getType()));
        // Delete the requested system permissions for this user
            retrieveHistory(connection.getConnection_id())
        // TODO: Actually update history...
        
     * @return A set of all connection permissions granted to the user having
     *         the given ID.
     * Retrieves all system permissions granted to the user having the
     * given ID.
     *
     * @param userID The ID of the user to retrieve permissions of.
     * @return A set of all system permissions granted to the user having the
     *         given ID.
     */
    public Set<SystemPermission> retrieveSystemPermissions(int userID) {

        // Set of all permissions
        Set<SystemPermission> permissions = new HashSet<SystemPermission>();
        
        // And finally, system permissions
        SystemPermissionExample systemPermissionExample = new SystemPermissionExample();
        systemPermissionExample.createCriteria().andUser_idEqualTo(userID);
        List<SystemPermissionKey> systemPermissions =
                systemPermissionDAO.selectByExample(systemPermissionExample);
        for(SystemPermissionKey systemPermission : systemPermissions) {

            // User creation permission
            if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_USER_CREATE))
                permissions.add(new SystemPermission(SystemPermission.Type.CREATE_USER));

            // System creation permission
            else if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_CONNECTION_CREATE))
                permissions.add(new SystemPermission(SystemPermission.Type.CREATE_CONNECTION));

            // System administration permission
            else if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_ADMINISTER))
                permissions.add(new SystemPermission(SystemPermission.Type.ADMINISTER));

        }

        return permissions;

    }

    /**
        // Add system permissions
        allPermissions.addAll(retrieveSystemPermissions(userID));
import net.sourceforge.guacamole.GuacamoleClientException;
import net.sourceforge.guacamole.GuacamoleResourceNotFoundException;
import net.sourceforge.guacamole.GuacamoleSecurityException;
     * Sends an error on the given HTTP response with the given integer error
     * code.
     *
     * @param response The HTTP response to use to send the error.
     * @param code The HTTP status code of the error.
     * @param message A human-readable message that can be presented to the
     *                user.
     * @throws ServletException If an error prevents sending of the error
     *                          code.
     */
    private void sendError(HttpServletResponse response, int code,
            String message) throws ServletException {

        try {

            // If response not committed, send error code
            if (!response.isCommitted()) {
                response.sendError(code);
                response.addHeader("Guacamole-Error-Message", message);
            }

        }
        catch (IOException ioe) {

            // If unable to send error at all due to I/O problems,
            // rethrow as servlet exception
            throw new ServletException(ioe);

        }

    }


    /**
        try {

            // Allow servlet to run now that authentication has been validated
            authenticatedService(context, request, response);

        }

        // Catch any thrown guacamole exception and attempt to pass within the
        // HTTP response, logging each error appropriately.
        catch (GuacamoleSecurityException e) {
            logger.warn("Permission denied: {}", e.getMessage());
            sendError(response, HttpServletResponse.SC_FORBIDDEN,
                    "Permission denied.");
        }
        catch (GuacamoleResourceNotFoundException e) {
            logger.debug("Resource not found: {}", e.getMessage());
            sendError(response, HttpServletResponse.SC_NOT_FOUND,
                    e.getMessage());
        }
        catch (GuacamoleClientException e) {
            logger.warn("Error in client request: {}", e.getMessage());
            sendError(response, HttpServletResponse.SC_BAD_REQUEST,
                    e.getMessage());
        }
        catch (GuacamoleException e) {
            logger.error("Internal server error.", e);
            sendError(response, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                      "Internal server error.");
        }
     * @throws GuacamoleException If an error occurs that interferes with the
     *                            normal operation of this servlet.
            throws GuacamoleException;
    throws GuacamoleException {
        try {

            // If authenticated, respond as tunnel
            tunnelServlet.service(request, response);
        }

        catch (ServletException e) {
            logger.info("Error from tunnel (see previous log messages): {}",
                    e.getMessage());
        }

        catch (IOException e) {
            logger.info("I/O error from tunnel (see previous log messages): {}",
                    e.getMessage());
        }
            HttpServletRequest request, HttpServletResponse response) {
    throws GuacamoleException {
        // Attempt to get connection directory
        Directory<String, Connection> directory =
                context.getConnectionDirectory();
        // Create config
        GuacamoleConfiguration config = new GuacamoleConfiguration();
        config.setProtocol(protocol);
        // Load parameters into config
        Enumeration<String> params = request.getParameterNames();
        while (params.hasMoreElements()) {
            // If parameter starts with prefix, load corresponding parameter
            // value into config
            String param = params.nextElement();
            if (param.startsWith(PARAMETER_PREFIX))
                config.setParameter(
                    param.substring(PARAMETER_PREFIX.length()),
                    request.getParameter(param));

        // Create connection skeleton
        Connection connection = new DummyConnection();
        connection.setIdentifier(identifier);
        connection.setConfiguration(config);

        // Add connection
        directory.add(connection);
    throws GuacamoleException {
        // Attempt to get connection directory
        Directory<String, Connection> directory =
                context.getConnectionDirectory();
        // Remove connection
        directory.remove(identifier);
import net.sourceforge.guacamole.GuacamoleServerException;
    throws GuacamoleException {
        // Get connection directory
        Directory<String, Connection> directory = context.getConnectionDirectory();
            throw new GuacamoleServerException(
                    "Unable to write configuration list XML.", e);
        catch (IOException e) {
            throw new GuacamoleServerException(
                    "I/O error writing configuration list XML.", e);
    throws GuacamoleException {
        // Attempt to get connection directory
        Directory<String, Connection> directory =
                context.getConnectionDirectory();
        // Create config
        GuacamoleConfiguration config = new GuacamoleConfiguration();
        config.setProtocol(protocol);
        // Load parameters into config
        Enumeration<String> params = request.getParameterNames();
        while (params.hasMoreElements()) {
            // If parameter starts with prefix, load corresponding parameter
            // value into config
            String param = params.nextElement();
            if (param.startsWith(PARAMETER_PREFIX))
                config.setParameter(
                    param.substring(PARAMETER_PREFIX.length()),
                    request.getParameter(param));

        // Create connection skeleton
        Connection connection = directory.get(identifier);
        connection.setConfiguration(config);

        // Update connection
        directory.update(connection);
import net.sourceforge.guacamole.GuacamoleClientException;
import net.sourceforge.guacamole.GuacamoleServerException;
    throws GuacamoleException {
                    throw new GuacamoleClientException(
                            "Unsupported permission type.");
            throw new GuacamoleServerException(
                    "Unable to write permission list XML.", e);
        catch (IOException e) {
            throw new GuacamoleServerException(
                    "I/O error writing permission list XML.", e);
    throws GuacamoleException {
        // Attempt to get user directory
        Directory<String, User> directory =
                context.getUserDirectory();
        // Create user skeleton
        User user = new DummyUser();
        user.setUsername(username);
        user.setPassword(UUID.randomUUID().toString());
        // Add user
        directory.add(user);
    throws GuacamoleException {
        // Attempt to get user directory
        Directory<String, User> directory = context.getUserDirectory();
        // Remove user
        directory.remove(username);
import net.sourceforge.guacamole.GuacamoleServerException;
    throws GuacamoleException {
            throw new GuacamoleServerException(
                    "Unable to write configuration list XML.", e);
        catch (IOException e) {
            throw new GuacamoleServerException(
                    "I/O error writing configuration list XML.", e);
import net.sourceforge.guacamole.GuacamoleClientException;
        throw new GuacamoleClientException("Invalid permission string.");
    throws GuacamoleException {
        // Attempt to get user directory
        Directory<String, User> directory =
                context.getUserDirectory();
        // Get user data, setting password if given
        User user = directory.get(username);
        user.setUsername(username);
        if (password != null)
            user.setPassword(password);
        /*
         * NEW PERMISSIONS
         */
        // Set added system permissions
        String[] add_sys_permission = request.getParameterValues("sys");
        if (add_sys_permission != null) {
            for (String str : add_sys_permission)
                user.addPermission(parseSystemPermission(str));

        // Set added user permissions
        String[] add_user_permission = request.getParameterValues("user");
        if (add_user_permission != null) {
            for (String str : add_user_permission)
                user.addPermission(parseUserPermission(str));
        // Set added connection permissions
        String[] add_connection_permission = request.getParameterValues("connection");
        if (add_connection_permission != null) {
            for (String str : add_connection_permission)
                user.addPermission(parseConnectionPermission(str));
        }

        /*
         * REMOVED PERMISSIONS
         */

        // Unset removed system permissions
        String[] remove_sys_permission = request.getParameterValues("-sys");
        if (remove_sys_permission != null) {
            for (String str : remove_sys_permission)
                user.removePermission(parseSystemPermission(str));
        }

        // Unset removed user permissions
        String[] remove_user_permission = request.getParameterValues("-user");
        if (remove_user_permission != null) {
            for (String str : remove_user_permission)
                user.removePermission(parseUserPermission(str));
        }

        // Unset removed connection permissions
        String[] remove_connection_permission = request.getParameterValues("-connection");
        if (remove_connection_permission != null) {
            for (String str : remove_connection_permission)
                user.removePermission(parseConnectionPermission(str));
        }

        // Update user
        directory.update(user);

     * Returns the name of the user who used or is using the connection at the
     * times given by this connection record.
     * @return The name of the user who used or is using the associated
     *         connection.
    public String getUsername();
                    xml.writeCharacters(record.getUsername());
import com.google.inject.Inject;
import java.util.Date;
import java.util.Set;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionHistoryMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionHistory;
public class ActiveConnectionSet {

    /**
     * DAO for accessing connection history.
     */
    @Inject
    private ConnectionHistoryMapper connectionHistoryDAO;
    
    /**
     * Set of all the connections that are currently active.
     */
    private Set<Integer> activeConnectionSet = new HashSet<Integer>();
    
    /**
     * Check if a connection is currently in use.
     * @param connectionID The connection to check the status of.
     * @return true if the connection is currently in use.
     */
    public boolean isActive(int connectionID) {
        return activeConnectionSet.contains(connectionID);
    }
    
    /**
     * Set a connection as open.
     * @param connectionID The ID of the connection that is being opened.
     * @param userID The ID of the user who is opening the connection.
     * @return The ID of the history record created for this open connection.
     */
    public int openConnection(int connectionID, int userID) {
        
        // Create the connection history record
        ConnectionHistory connectionHistory = new ConnectionHistory();
        connectionHistory.setConnection_id(connectionID);
        connectionHistory.setUser_id(userID);
        connectionHistory.setStart_date(new Date());
        connectionHistoryDAO.insert(connectionHistory);
        
        // Mark the connection as active
        activeConnectionSet.add(connectionID);
        
        return connectionHistory.getHistory_id();
    }
    
    /**
     * Set a connection as closed.
     * @param connectionID The ID of the connection that is being opened.
     * @param historyID The ID of the history record about the open connection.
     * @throws GuacamoleException If the open connection history is not found.
     */
    public void closeConnection(int connectionID, int historyID)
            throws GuacamoleException {
        
        // Get the existing history record
        ConnectionHistory connectionHistory = 
                connectionHistoryDAO.selectByPrimaryKey(historyID);
        
        if(connectionHistory == null)
            throw new GuacamoleException("History record not found.");
        
        // Update the connection history record to mark that it is now closed
        connectionHistory.setEnd_date(new Date());
        connectionHistoryDAO.updateByPrimaryKey(connectionHistory);
        
        // Remove the connection from the set of active connections.
        activeConnectionSet.remove(connectionID);
    }
}
                connectionService.retrieveConnection(identifier, user_id);
                object.getIdentifier(), object.getConfiguration().getProtocol(),
                user_id);
                connectionService.retrieveConnection(identifier, user_id);
    
    /**
     * The ID of the user who queried or created this connection.
     */
    private int userID;
     * @param userID The IID of the user who queried this connection.
            List<? extends ConnectionRecord> history, int userID) {
        this.userID = userID;
        
        return connectionService.connect(this, info, userID);
     * The start date of the ConnectionRecord.
    private Date startDate;
    
    /**
     * The end date of the ConnectionRecord.
     */
    private Date endDate;
    
    /**
     * The name of the user that is associated with this ConnectionRecord.
     */
    private String username;
     * Initialize this MySQLConnectionRecord with the start/end dates,
     * and the name of the user it represents.
     * @param startDate The start date of the connection history.
     * @param endDate The end date of the connection history.
     * @param username The name of the user that used the connection.
    public MySQLConnectionRecord(Date startDate, Date endDate,
            String username) {
        this.startDate = startDate;
        this.endDate = endDate;
        this.username = username;
        return startDate;
        return endDate;
    public String getUsername() {
        return username;
        return endDate == null;
    
    /**
     * The ID of the history record associated with this instance of the
     * connection.
     */
    private int historyID;
     * @param historyID The ID of the history record associated with this
     *                  instance of the connection.
    public void init(GuacamoleSocket socket, int connectionID, int historyID) {
        this.historyID = historyID;
        activeConnectionSet.closeConnection(connectionID, historyID);
import com.google.common.collect.Lists;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;
    
    /**
     * Service managing users.
     */
    @Inject
    private UserService userService;
     * @param userID The ID of the user who queried this connection.
    public MySQLConnection retrieveConnection(String name, int userID) {
        return toMySQLConnection(connections.get(0), userID);
     * @param userID The ID of the user who queried this connection.
    public MySQLConnection retrieveConnection(int id, int userID) {
        return toMySQLConnection(connection, userID);
    public Map<Integer, String> retrieveNames(Collection<Integer> ids) {
        example.createCriteria().andConnection_idIn(Lists.newArrayList(ids));
     * @param userID The user who queried this connection.
    private MySQLConnection toMySQLConnection(Connection connection, int userID) {
            retrieveHistory(connection.getConnection_id()),
            userID
        
        Set<Integer> userIDSet = new HashSet<Integer>();
            userIDSet.add(history.getUser_id());
        }
        
        // Get all the usernames for the users who are in the history
        Map<Integer, String> usernameMap = userService.retrieveUsernames(userIDSet);
        
        // Create the new ConnectionRecords
        for(ConnectionHistory history : connectionHistories) {
            Date startDate = history.getStart_date();
            Date endDate = history.getEnd_date();
            String username = usernameMap.get(history.getUser_id());
            MySQLConnectionRecord connectionRecord = new MySQLConnectionRecord(startDate, endDate, username);
            connectionRecords.add(connectionRecord);
     * @param userID The ID of the user who is connecting to the socket.
            GuacamoleClientInformation info, int userID)
                && activeConnectionSet.isActive(connection.getConnectionID()))
        int historyID = activeConnectionSet.openConnection(connection.getConnectionID(), userID);
                
        mySQLGuacamoleSocket.init(socket, connection.getConnectionID(), historyID);
     * @param userID The ID of the user who created this connection.
    public MySQLConnection createConnection(String name, String protocol, int userID) {
        return toMySQLConnection(connection, userID);
import com.google.common.collect.Lists;
import java.util.Collection;
    public Map<Integer, String> retrieveUsernames(Collection<Integer> ids) {
        example.createCriteria().andUser_idIn(Lists.newArrayList(ids));








        ConnectionHistory connectionHistory =














        this.startDate = new Date(startDate.getTime());
        this.endDate = new Date(endDate.getTime());
        return new Date(startDate.getTime());
        return new Date(endDate.getTime());
        if (startDate != null) this.startDate = new Date(startDate.getTime());
        if (endDate != null) this.endDate = new Date(endDate.getTime());
        if (startDate == null) return null;
        if (endDate == null) return null;
                    // Whether connection currently active
                    if (record.isActive())
                        xml.writeAttribute("active", "yes");

import org.apache.ibatis.session.RowBounds;
        
        // Set the maximum number of history records returned to 100
        RowBounds rowBounds = new RowBounds(0, 100);
        List<ConnectionHistory> connectionHistories = 
                connectionHistoryDAO.selectByExampleWithRowbounds(example, rowBounds);
import net.sourceforge.guacamole.GuacamoleClientException;
        if(object.getIdentifier().isEmpty())
            throw new GuacamoleClientException("The connection identifier cannot be blank.");
        
        // Verify that no connection already exists with this identifier.
        MySQLConnection previousConnection = 
                connectionService.retrieveConnection(object.getIdentifier(), user_id);
        if(previousConnection != null)
            throw new GuacamoleClientException("That connection identifier is already in use.");
        
import net.sourceforge.guacamole.GuacamoleClientException;
        if(object.getUsername().isEmpty())
            throw new GuacamoleClientException("The username cannot be blank.");

        // Verify that no user already exists with this username.
        MySQLUser previousUser = 
                userService.retrieveUser(object.getUsername());
        if(previousUser != null)
            throw new GuacamoleClientException("That username is already in use.");

import net.sourceforge.guacamole.GuacamoleClientException;
            throw new GuacamoleClientException("Cannot connect. This connection is in use.");
    
    /**
     * Get all the connections defined in the system.
     * @param userID The ID of the user who is querying the connections.
     * @return A list of all connections defined in the system.
     */
    public List<MySQLConnection> getAllConnections(int userID) {
        
        // Get all connections defined in the system.
        List<Connection> allConnections = connectionDAO.selectByExample(new ConnectionExample());
        
        // Translate database records to MySQLConnections
        List<MySQLConnection> allMySQLConnections = new ArrayList<MySQLConnection>();
        
        for(Connection connection : allConnections) {
            allMySQLConnections.add(toMySQLConnection(connection, userID));
        }
        
        return allMySQLConnections;
    }
    
    /**
     * Get the IDs of all the connection defined in the system.
     * @param userID The ID of the user who is querying the connections.
     * @return A list of IDs of all the connections defined in the system.
     */
    public List<Integer> getAllConnectionIDs(int userID) {
        List<Integer> connectionIDs = new ArrayList<Integer>();
        for(MySQLConnection connection : getAllConnections(userID)) {
            connectionIDs.add(connection.getConnectionID());
        }
        
        return connectionIDs;
    }
        // A system administrator has full access to everything.
        if(checkSystemAdministratorAccess(userID))
            return true;
        
        // A system administrator has full access to everything.
        if(checkSystemAdministratorAccess(userID))
            return true;
        
        // A system administrator has full access to everything.
        if(checkSystemAdministratorAccess(userID))
            return true;
        
    

    /**
     * Checks whether a user has system administrator access to the system.
     *
     * @param userID The ID of the user to check.
     * @return true if the system administrator access exists, false otherwise.
     */
    private boolean checkSystemAdministratorAccess(int userID) {

        // Check existence of system administrator permission
        SystemPermissionExample example = new SystemPermissionExample();
        example.createCriteria().andUser_idEqualTo(userID).
                andPermissionEqualTo(MySQLConstants.SYSTEM_ADMINISTER);
        return systemPermissionDAO.countByExample(example) > 0;
    }
        // A system administrator has access to all users.
        if(checkSystemAdministratorAccess(userID)) {
            return userService.getAllUserIDs();
        }
        
        // A system administrator has access to all connections.
        if(checkSystemAdministratorAccess(userID)) {
            return connectionService.getAllConnectionIDs(userID);
        }

import java.util.ArrayList;
    
    /**
     * Get all the users defined in the system.
     * @return A list of all users defined in the system.
     */
    public List<MySQLUser> getAllUsers() {
        
        // Get all users defined in the system.
        List<UserWithBLOBs> allUsers = userDAO.selectByExampleWithBLOBs(new UserExample());
        
        // Translate database records to MySQLUsers
        List<MySQLUser> allMySQLUsers = new ArrayList<MySQLUser>();
        
        for(UserWithBLOBs user : allUsers) {
            allMySQLUsers.add(toMySQLUser(user));
        }
        
        return allMySQLUsers;
    }
    
    /**
     * Get the IDs of all the user defined in the system.
     * @return A list of IDs of all the users defined in the system.
     */
    public List<Integer> getAllUserIDs() {
        List<Integer> userIDs = new ArrayList<Integer>();
        for(MySQLUser user : getAllUsers()) {
            userIDs.add(user.getUserID());
        }
        
        return userIDs;
    }
            Collection<SystemPermission> permissions) throws GuacamoleException {
        // Only a system administrator can add system permissions.
        permissionCheckService.verifySystemAccess(
                this.user_id, SystemPermission.Type.ADMINISTER.name());

            
        return permissionCheckService.retrieveConnectionNames(user_id,
        return permissionCheckService.retrieveUsernames(user_id,
            permissionCheckService.retrieveConnectionIDs(this.user_id,
                connectionService.translateNames(administerableConnectionIDs);
     * Get the names of all the connections defined in the system.
     * 
     * @return A Set of names of all the connections defined in the system.
    public Set<String> getAllConnectionNames() {

        // Set of all present connection names
        Set<String> names = new HashSet<String>();

        // Query all connection names
        List<Connection> connections =
                connectionDAO.selectByExample(new ConnectionExample());
        for (Connection connection : connections)
            names.add(connection.getConnection_name());
        return names;

    /**
     * Get the connection IDs of all the connections defined in the system.
     * 
     * @return A list of connection IDs of all the connections defined in the system.
     */
    public List<Integer> getAllConnectionIDs() {

        // Set of all present connection IDs 
        List<Integer> connectionIDs = new ArrayList<Integer>();

        // Query all connection IDs
        List<Connection> connections =
                connectionDAO.selectByExample(new ConnectionExample());
        for (Connection connection : connections)
            connectionIDs.add(connection.getConnection_id());
        
        return connectionIDs;

    }
        if(checkSystemAdministratorAccess(userID))
        if(checkSystemAdministratorAccess(userID))
            return connectionService.getAllConnectionIDs();
     * Retrieve all existing usernames that the given user has permission to
     * perform the given operation upon.
     * 
     * @param userID The user whose permissions should be checked.
     * @param permissionType The permission to check.
     * @return A set of all usernames for which the given user has the given
     *         permission.
     */
    public Set<String> retrieveUsernames(int userID, String permissionType) {

        // A system administrator has access to all users.
        if(checkSystemAdministratorAccess(userID))
            return userService.getAllUsernames();

        // List of all user IDs for which this user has read access
        List<Integer> userIDs =
                retrieveUserIDs(userID, MySQLConstants.USER_READ);

        // Query all associated users
        return userService.translateUsernames(userIDs).keySet();

    }

    /**
     * Retrieve all existing usernames that the given user has permission to
     * perform the given operation upon.
     * 
     * @param userID The user whose permissions should be checked.
     * @param permissionType The permission to check.
     * @return A set of all usernames for which the given user has the given
     *         permission.
     */
    public Set<String> retrieveConnectionNames(int userID, String permissionType) {

        // A system administrator has access to all connections.
        if(checkSystemAdministratorAccess(userID))
            return connectionService.getAllConnectionNames();

        // List of all connection IDs for which this connection has read access
        List<Integer> connectionIDs =
                retrieveUserIDs(userID, MySQLConstants.CONNECTION_READ);

        // Query all associated connections
        return connectionService.translateNames(connectionIDs).keySet();

    }

    /**
import java.util.HashSet;
import java.util.Set;
import net.sourceforge.guacamole.net.auth.mysql.model.User;
    public MySQLUser toMySQLUser(net.sourceforge.guacamole.net.auth.User user) throws GuacamoleException {
        List<User> users =
        for (User user : users)
        List<User> users =
        for (User user : users)
     * Get the usernames of all the users defined in the system.
     * 
     * @return A Set of usernames of all the users defined in the system.
    public Set<String> getAllUsernames() {

        // Set of all present usernames
        Set<String> usernames = new HashSet<String>();

        // Query all usernames
        List<User> users =
                userDAO.selectByExample(new UserExample());
        for (User user : users)
            usernames.add(user.getUsername());
        return usernames;

    /**
     * Get the user IDs of all the users defined in the system.
     * 
     * @return A list of user IDs of all the users defined in the system.
     */
    public List<Integer> getAllUserIDs() {

        // Set of all present user IDs 
        List<Integer> userIDs = new ArrayList<Integer>();

        // Query all user IDs
        List<User> users =
                userDAO.selectByExample(new UserExample());
        for (User user : users)
            userIDs.add(user.getUser_id());
        
        return userIDs;

    }
        String identifier = object.getIdentifier().trim();
        if(identifier.isEmpty())
                connectionService.retrieveConnection(identifier, user_id);
                identifier, object.getConfiguration().getProtocol(),
        String username = object.getUsername().trim();
        if(username.isEmpty())
        MySQLUser previousUser = userService.retrieveUser(username);
        MySQLUser user = userService.createUser(username, object.getPassword());
                response.sendError(code);
     * @throws GuacamoleException If the permissions specified could not be
     *                            removed due to system restrictions.
            Collection<SystemPermission> permissions)
            throws GuacamoleException {
        // Prevent self-de-adminifying
        if (user_id == this.user_id)
            throw new GuacamoleClientException("Removing your own administrative permissions is not allowed.");
        
        // Prevent self-deletion
        if (user.getUserID() == this.user_id)
            throw new GuacamoleClientException("Deleting your own user is not allowed.");
        
import net.sourceforge.guacamole.net.auth.permission.SystemPermission;
        // Sys-admin permission
        Permission systemPermission =
                new SystemPermission(SystemPermission.Type.ADMINISTER);
        
                if (self.hasPermission(systemPermission) ||
                        hasConfigPermission(self, ObjectPermission.Type.UPDATE,

        MySQLConnection previousConnection =

     * @throws GuacamoleException If permission to administer system permissions
     *                            is denied.




        List<ConnectionHistory> connectionHistories =

     *

     *
        // Set of all present connection IDs






     *
     *

     *

     *
        // Set of all present user IDs

     * Retrieve all existing connection names that the given user has permission
     * to perform the given operation upon.
     * @return A set of all connection names for which the given user has the
     *         given permission.
                retrieveConnectionIDs(userID, MySQLConstants.CONNECTION_READ);
     * Retrieve all existing connection names that the given user has permission
     * to perform the given operation upon.
     * @return A set of all connection names for which the given user has the
     *         given permission.
                retrieveConnectionIDs(userID, MySQLConstants.CONNECTION_READ);
            handler = parent_handler.childElement(localName);
        // Initialize handler
        handler.init(attributes);
        
    public TagHandler childElement(String localName)
     * Called when the element corresponding to this TagHandler is first seen,
     * just after an instance is created.
     * 
     * @param attributes The attributes of the element seen.
     * @throws SAXException If an error prevents a the TagHandler from being
     *                      from being initialized.
     */
    public void init(Attributes attributes) throws SAXException;
    
    /**
    @Override
    public void init(Attributes attributes) throws SAXException {
    public TagHandler childElement(String localName) throws SAXException {
            ConnectionTagHandler tagHandler = new ConnectionTagHandler();
            return new ParamTagHandler(default_config);
    @Override
    public void init(Attributes attributes) throws SAXException {
    public TagHandler childElement(String localName) throws SAXException {
            return new ParamTagHandler(config);
    public ParamTagHandler(GuacamoleConfiguration config) {
    public void init(Attributes attributes) throws SAXException {
        this.name = attributes.getValue("name");
    }

    @Override
    public TagHandler childElement(String localName) throws SAXException {
    public void init(Attributes attributes) throws SAXException {
        // Do nothing
    }

    @Override
    public TagHandler childElement(String localName) throws SAXException {
    public void init(Attributes attributes) throws SAXException {
        // Do nothing
    }

    @Override
    public TagHandler childElement(String localName) throws SAXException {
            AuthorizeTagHandler tagHandler = new AuthorizeTagHandler();
import java.util.HashMap;
import java.util.Map;
     * Array of all known protocol names.
     */
    private static final String[] KNOWN_PROTOCOLS = new String[]{
        "vnc", "rdp", "ssh"};
    
    /**
        // Map of all available protocols
        Map<String, ProtocolInfo> protocols = new HashMap<String, ProtocolInfo>();

        // Read protocols
        
        /* STUB */
        
        // If known protocols are not already defined, read from classpath
        for (String protocol : KNOWN_PROTOCOLS) {

            // If protocol not defined yet, attempt to load from classpath
            if (!protocols.containsKey(protocol)) {

                InputStream stream = List.class.getResourceAsStream(
                        "/net/sourceforge/guacamole/net/protocols/"
                         protocol  ".xml");

                // Parse XML if available
                if (stream != null)
                    protocols.put(protocol, getProtocol(stream));

            }

        }
       
            // Write all protocols
            for (ProtocolInfo protocol : protocols.values())
                writeProtocol(xml, protocol);
import java.io.File;
import java.io.FileInputStream;
import java.io.FilenameFilter;
import net.sourceforge.guacamole.properties.GuacamoleHome;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private Logger logger = LoggerFactory.getLogger(List.class);

    /**
        // Get protcols directory
        File protocol_directory = new File(GuacamoleHome.getDirectory(),
                "protocols");

        // Read protocols from directory if it exists
        if (protocol_directory.isDirectory()) {

            // Get all XML files
            File[] files = protocol_directory.listFiles(
                new FilenameFilter() {

                    @Override
                    public boolean accept(File file, String string) {
                        return string.endsWith(".xml");
                    }

                }
            );

            // Load each protocol from each file
            for (File file : files) {

                try {

                    // Parse protocol
                    FileInputStream stream = new FileInputStream(file);
                    ProtocolInfo protocol = getProtocol(stream);
                    stream.close();

                    // Store protocol
                    protocols.put(protocol.getName(), protocol);

                }
                catch (IOException e) {
                    logger.error("Unable to read protocol XML.", e);
                }

            }
            
        }

import net.sourceforge.guacamole.net.basic.auth.UserMapping;
    /**
     * The UserMapping this authorization belongs to.
     */
    private UserMapping parent;
    
    /**
     * Creates a new AuthorizeTagHandler that parses an Authorization owned
     * by the given UserMapping.
     * 
     * @param parent The UserMapping that owns the Authorization this handler
     *               will parse.
     */
    public AuthorizeTagHandler(UserMapping parent) {
        this.parent = parent;
    }
    
        parent.addAuthorization(this.asAuthorization());
        
        if (localName.equals("connection"))
            return new ConnectionTagHandler(authorization);
import net.sourceforge.guacamole.net.basic.auth.Authorization;
    /**
     * The Authorization this connection belongs to.
     */
    private Authorization parent;
    
    /**
     * Creates a new ConnectionTagHandler that parses a Connection owned by
     * the given Authorization.
     * 
     * @param parent The Authorization that will own this Connection once
     *               parsed.
     */
    public ConnectionTagHandler(Authorization parent) {
        this.parent = parent;
    }
    
        parent.addConfiguration(name, this.asGuacamoleConfiguration());
        if (localName.equals("authorize"))
            return new AuthorizeTagHandler(user_mapping);
    
    /**
     * The value of this parameter, for boolean parameters.
     */
    private String value;
    
     * Returns the value associated with this protocol parameter.
     * @return The value associated with this protocol parameter.
     */
    public String getValue() {
        return value;
    }

    /**
     * Sets the value associated with this protocol parameter. The value must
     * be a human-readable string which describes accurately this parameter.
     * 
     * @param value A human-readable string describing this parameter.
     */
    public void setValue(String value) {
        this.value = value;
    }

    /**
                    xml.writeAttribute("value", param.getValue());
        protocolParameter.setValue(attributes.getValue("value"));
import net.sourceforge.guacamole.net.basic.auth.UserMapping;
    /**
     * The UserMapping this authorization belongs to.
     */
    private UserMapping parent;
    
    /**
     * Creates a new AuthorizeTagHandler that parses an Authorization owned
     * by the given UserMapping.
     * 
     * @param parent The UserMapping that owns the Authorization this handler
     *               will parse.
     */
    public AuthorizeTagHandler(UserMapping parent) {
        this.parent = parent;
    }
    
        parent.addAuthorization(this.asAuthorization());
        
        if (localName.equals("connection"))
            return new ConnectionTagHandler(authorization);
import net.sourceforge.guacamole.net.basic.auth.Authorization;
    /**
     * The Authorization this connection belongs to.
     */
    private Authorization parent;
    
    /**
     * Creates a new ConnectionTagHandler that parses a Connection owned by
     * the given Authorization.
     * 
     * @param parent The Authorization that will own this Connection once
     *               parsed.
     */
    public ConnectionTagHandler(Authorization parent) {
        this.parent = parent;
    }
    
        parent.addConfiguration(name, this.asGuacamoleConfiguration());
        if (localName.equals("authorize"))
            return new AuthorizeTagHandler(user_mapping);
        else if ("boolean".equals(type)) {
            
            if(protocolParameter.getValue() == null)
                throw new SAXException
                        ("A value is required for the boolean parameter type.");
        }
 *

     *
     *
     *
     *
     *
 *




     *
     *
     *
     *
 *

     * Returns the value that will be sent to the client plugin if this option
     *
     *



     *
     *
        // Write protocol




        // End protocol





     *

 *
 * @author Mike Jumper



 *
 * @author Mike Jumper




        // Start parsing of option tags


 *
 * @author Mike Jumper


        // Start parsing of param tags, add to list of all parameters




     *



     *

            
            if (user == null)
                throw new GuacamoleSecurityException("No such user.");
        final Properties driverProperties = new Properties();
        driverProperties.setProperty("characterEncoding","UTF-8");
                    binder.bind(Properties.class)
                        .annotatedWith(Names.named("JDBC.driverProperties"))
                        .toInstance(driverProperties);
        
        // Set encoding
        response.setCharacterEncoding("UTF-8");
        
        // Set encoding
        response.setCharacterEncoding("UTF-8");
        
        // Set encoding
        response.setCharacterEncoding("UTF-8");
        
        // Set encoding
        response.setCharacterEncoding("UTF-8");
        final Properties driverProperties = new Properties();
        driverProperties.setProperty("characterEncoding","UTF-8");
                    binder.bind(Properties.class)
                        .annotatedWith(Names.named("JDBC.driverProperties"))
                        .toInstance(driverProperties);
import java.io.UnsupportedEncodingException;
        
        // Set character encoding to UTF-8 if it's not already set
        if(request.getCharacterEncoding() == null) {
            try {
                request.setCharacterEncoding("UTF-8");
            } catch (UnsupportedEncodingException exception) {
               throw new ServletException(exception);
            }
        }
        
        // Set encoding
        response.setCharacterEncoding("UTF-8");
        
        // Set encoding
        response.setCharacterEncoding("UTF-8");
        
        // Set encoding
        response.setCharacterEncoding("UTF-8");
        
        // Set encoding
        response.setCharacterEncoding("UTF-8");
import java.io.UnsupportedEncodingException;
        
        // Set character encoding to UTF-8 if it's not already set
        if(request.getCharacterEncoding() == null) {
            try {
                request.setCharacterEncoding("UTF-8");
            } catch (UnsupportedEncodingException exception) {
               throw new ServletException(exception);
            }
        }
import java.io.UnsupportedEncodingException;
        
        // Set character encoding to UTF-8 if it's not already set
        if(request.getCharacterEncoding() == null) {
            try {
                request.setCharacterEncoding("UTF-8");
            } catch (UnsupportedEncodingException exception) {
               throw new ServletException(exception);
            }
        }
import net.sourceforge.guacamole.net.SSLGuacamoleSocket;
        GuacamoleSocket socket;
        if (GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_SSL, false))
            socket = new ConfiguredGuacamoleSocket(
                new SSLGuacamoleSocket(host, port),
                connection.getConfiguration(), info
            );
        else
            socket = new ConfiguredGuacamoleSocket(
                new InetGuacamoleSocket(host, port),
                connection.getConfiguration(), info
            );
import net.sourceforge.guacamole.net.SSLGuacamoleSocket;
        // If guacd requires SSL, use it
        if (GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_SSL, false))
            return new ConfiguredGuacamoleSocket(
                new SSLGuacamoleSocket(hostname, port),
                config, info
            );

            new InetGuacamoleSocket(hostname, port),
            config, info
     * Whether guacd requires SSL/TLS on connections.
     */
    public static final BooleanGuacamoleProperty GUACD_SSL = new BooleanGuacamoleProperty() {

        @Override
        public String getName() { return "guacd-ssl"; }

    };

    /**
     * Creates a new SSLGuacamoleSocket which reads and writes instructions
     * running at the given hostname and port using SSL.
    @Override
    public UserContext updateUserContext(UserContext context,
        Credentials credentials) throws GuacamoleException {

        // No need to update the context
        return context;

    }

    /**
     * Returns a new or updated UserContext for the user authorized by the
     * give credentials and having the given existing UserContext. Note that
     * because this function will be called for all future requests after
     * initial authentication, including tunnel requests, care must be taken
     * to avoid using functions of HttpServletRequest which invalidate the
     * entire request body, such as getParameter().
     * 
     * @param context The existing UserContext belonging to the user in
     *                question.
     * @param credentials The credentials to use to retrieve or update the
     *                    environment.
     * @return The updated UserContext, which need not be the same as the
     *         UserContext given, or null if the user is no longer authorized.
     *         
     * @throws GuacamoleException If an error occurs while updating the
     *                            UserContext.
     */
    UserContext updateUserContext(UserContext context, Credentials credentials)
            throws GuacamoleException;
    
    @Override
    public UserContext updateUserContext(UserContext context,
        Credentials credentials) throws GuacamoleException {

        // Simply return the given context, updating nothing
        return context;
        
    }

import java.util.HashMap;
import java.util.Map;
    private static final long serialVersionUID = 2L;
     * Map of query parameter names to values.
     */
    private Map<String, String> queryParameters = null;
    
    /**
     * Returns the password provided by the user in the request. Note that
     * this function will potentially read from the entire request body in
     * search of the "username" parameter, and thus can interfere with tunnel
     * usage if used at a time that the user is POSTing data to the tunnel
     * (such as while updating the UserContext during a tunnel write).
     *
     * This function will prefer parameters in the query string of a request to
     * those of the entire request body, so if it is known that the password
     * will always be present in the query string, this function is safe to
     * call at all times.
     *
     * @return The password given in the associated request, or null if no
     *         password was provided.

        // Attempt to pull from GET parameters first
        String get_password = getQueryParameter("password");
        if (get_password != null)
            return get_password;
        
        // Otherwise, resort to parameters anywhere in the request body
        return request.getParameter("password");
        
     * Returns the username provided by the user in the request. Note that
     * this function will potentially read from the entire request body in
     * search of the "username" parameter, and thus can interfere with tunnel
     * usage if used at a time that the user is POSTing data to the tunnel
     * (such as while updating the UserContext during a tunnel write).
     * 
     * This function will prefer parameters in the query string of a request to
     * those of the entire request body, so if it is known that the username
     * will always be present in the query string, this function is safe to
     * call at all times.
     * 
     * @return The username given in the associated request, or null if no
     *         username was provided.

        // Attempt to pull from GET parameters first
        String get_password = getQueryParameter("username");
        if (get_password != null)
            return get_password;
        
        // Otherwise, resort to parameters anywhere in the request body
        return request.getParameter("username");

     * Returns the contents of the given parameter, if present. Unlike
     * getParameter() of HttpServletRequest, this function is safe to call
     * when POST data is still required (such as during tunnel requests or
     * when the UserContext is being updated).
     * 
     * @param parameter The name of the parameter to read.
     * @return The value of the parameter, or null if no such parameter exists.
    public String getQueryParameter(String parameter) {
        // Parse parameters, if not yet parsed
        if (queryParameters == null) {
        
            // If no request, then no parameters
            if (request == null)
                return null;

            // If no query string, then no parameters
            String query_string = request.getQueryString();
            if (query_string == null)
                return null;

            // Get name/value pairs
            String[] nv_pairs = query_string.split("&");

            // Add each pair to hash
            queryParameters = new HashMap<String, String>();
            for (String nv_pair : nv_pairs) {

                String name;
                String value;
                
                int eq = nv_pair.indexOf('=');

                // If no equals sign, parameter is blank
                if (eq == -1) {
                    name  = nv_pair;
                    value = "";
                }

                // Otherwise, parse pair
                else {
                    name  = nv_pair.substring(0, eq);
                    value = nv_pair.substring(eq1);
                }
                
                // Save pair to hash
                queryParameters.put(name, value);
                
            }
            
        } // end if parameters cached

        // Return parsed parameter, if any
        return queryParameters.get(parameter);

    }
    
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.nio.charset.UnsupportedCharsetException;
            try {
                // Add each pair to hash
                for (String nv_pair : nv_pairs) {

                    String name;
                    String value;
                    
                    int eq = nv_pair.indexOf('=');

                    // If no equals sign, parameter is blank
                    if (eq == -1) {
                        name  = nv_pair;
                        value = "";
                    }

                    // Otherwise, parse pair
                    else {
                        name  = nv_pair.substring(0, eq);
                        value = nv_pair.substring(eq1);
                    }
                    
                    // Decode and save pair to hash
                    queryParameters.put(
                        URLDecoder.decode(name,  "UTF-8"),
                        URLDecoder.decode(value, "UTF-8")
                    );
                    
            }

            // If UTF-8 unsupported, throw fatal error
            catch (UnsupportedEncodingException e) {
                throw new UnsupportedOperationException("Unexpected lack of support for UTF-8", e);
import net.sourceforge.guacamole.net.auth.UserContext;
 * 
 * Note that this event is only triggered when the UserContext is initially
 * created. Any further updates to the UserContext to not trigger this event.
public class AuthenticationSuccessEvent implements UserEvent, CredentialEvent {

    /**
     * The UserContext associated with the request that is connecting the
     * tunnel, if any.
     */
    private UserContext context;
     * @param context The UserContext created as a result of successful
     *                authentication.
    public AuthenticationSuccessEvent(UserContext context, Credentials credentials) {
        this.context = context;
    public UserContext getUserContext() {
        return context;
    }

    @Override
import net.sourceforge.guacamole.net.auth.UserContext;
public class TunnelCloseEvent implements UserEvent, TunnelEvent {
     * The UserContext associated with the request that is connecting the
    private UserContext context;
     * @param context The UserContext associated with the request connecting
     *                the tunnel.
    public TunnelCloseEvent(UserContext context, GuacamoleTunnel tunnel) {
        this.context = context;
    public UserContext getUserContext() {
        return context;
import net.sourceforge.guacamole.net.auth.UserContext;
public class TunnelConnectEvent implements UserEvent, TunnelEvent {
     * The UserContext associated with the request that is connecting the
    private UserContext context;
     * @param context The UserContext associated with the request connecting
     *                the tunnel.
    public TunnelConnectEvent(UserContext context, GuacamoleTunnel tunnel) {
        this.context = context;
    public UserContext getUserContext() {
        return context;
     * @param context The UserContext created as a result of authentication
     *                success.
    private boolean notifySuccess(Collection listeners, UserContext context,
            Credentials credentials) throws GuacamoleException {
        AuthenticationSuccessEvent event =
                new AuthenticationSuccessEvent(context, credentials);
        SessionListenerCollection listeners;
        try {
            listeners = new SessionListenerCollection(httpSession);
        }
        catch (GuacamoleException e) {
            logger.error("Failed to retrieve listeners. Authentication canceled.", e);
            failAuthentication(response);
            return;
        }

        // Build credentials object
        Credentials credentials = new Credentials();
        credentials.setSession(httpSession);
        credentials.setRequest(request);

        // If no cached context, attempt to get new context
            // Log any authentication errors
            // If successful, log success and notify listeners
            if (context != null) {
                
                // Log successful authentication
                        context.self().getUsername(), request.getRemoteAddr());
                // Notify any listeners of success, cancel if requested
                try {
                    if (!notifySuccess(listeners, context, credentials)) {
                        logger.info("Successful authentication canceled by hook.");
                        context = null;
                    }
                catch (GuacamoleException e) {
                    logger.error("Successful authentication canceled by error in hook.", e);
                    context = null;
                }
            } // end if auth success

        } // end if no cached context

        // Otherwise, update existing context
        else {

            try {
                context = authProvider.updateUserContext(context, credentials);
            // If error updating context, fail authentication, notify listeners
            catch (GuacamoleException e) {
                logger.error("Error updating context for user \"{}\".",
                        context.self().getUsername(), e);
            }
        } // end if cached context
        // If no context, fail authentication, notify listeners
        if (context == null) {
            logger.warn("Authentication attempt from {} for user \"{}\" failed.",
                    request.getRemoteAddr(), credentials.getUsername());

            notifyFailed(listeners, credentials);
            failAuthentication(response);
            return;
        // Associate context and credentials with session
        httpSession.setAttribute(CONTEXT_ATTRIBUTE, context);

     * @param context The UserContext associated with the current session.
            UserContext context, GuacamoleTunnel tunnel)
        TunnelConnectEvent event = new TunnelConnectEvent(context, tunnel);
     * @param context The UserContext associated with the current session.
            UserContext context, GuacamoleTunnel tunnel)
        TunnelCloseEvent event = new TunnelCloseEvent(context, tunnel);
            final UserContext context = getUserContext(httpSession);
            if (context == null)
                throw new GuacamoleSecurityException("Cannot connect - user not logged in.");
                    if (!notifyClose(listeners, context, this))
            if (!notifyConnect(listeners, context, tunnel)) {
        try {
            SessionListenerCollection listeners = new SessionListenerCollection(httpSession);
            // If no cached context, attempt to get new context
            UserContext context = getUserContext(httpSession);
            if (context == null) {

                // If successful, log success and notify listeners
                if (context != null) {
                    
                    // Log successful authentication
                    logger.info("User \"{}\" successfully authenticated from {}.",
                            context.self().getUsername(), request.getRemoteAddr());
                } // end if auth success
            }
            // Otherwise, update existing context
            else

            // If no context, fail authentication, notify listeners
            if (context == null) {
                logger.warn("Authentication attempt from {} for user \"{}\" failed.",
                        request.getRemoteAddr(), credentials.getUsername());

                notifyFailed(listeners, credentials);
                sendError(response, HttpServletResponse.SC_FORBIDDEN,
                    "Permission denied.");
                return;
            // Associate (possibly updated) context with session
            httpSession.setAttribute(CONTEXT_ATTRIBUTE, context);
import java.util.Collections;
     * Returns a map of all query parameters in the request, if any. Unlike
     * @return An unmodifiable map of all query parameters in the request,
     *         where each key corresponds to a given parameter name.
    public Map<String, String> getQueryParameters() {
        // Return unmodifiable map of all parameters
        return Collections.unmodifiableMap(queryParameters);
        
    }
    /**
     * Returns the contents of the given parameter, if present. Unlike
     * getParameter() of HttpServletRequest, this function is safe to call
     * when POST data is still required (such as during tunnel requests or
     * when the UserContext is being updated).
     * 
     * @param parameter The name of the parameter to read.
     * @return The value of the parameter, or null if no such parameter exists.
     */
    public String getQueryParameter(String parameter) {
        return getQueryParameters().get(parameter);
    /**
     * Returns whether the request given has updated credentials. If this
     * function returns false, the UserContext will not be updated.
     * 
     * @param request The request to check for credentials.
     * @return true if the request contains credentials, false otherwise.
     */
    protected boolean hasNewCredentials(HttpServletRequest request) {
        return true;
    }
    
            else if (hasNewCredentials(request))
    @Override
    protected boolean hasNewCredentials(HttpServletRequest request) {

        String query = request.getQueryString();
        if (query == null)
            return false;

        // Only connections are given new credentials
        return query.equals("connect");

    }

    private static final long serialVersionUID = 1L;

    /**
     * An arbitrary username.
     */
    private String username;

    /**
     * An arbitrary password.
     */
    private String password;
     * Returns the password associated with this set of credentials.
     * @return The password associated with this username/password pair, or
     *         null if no password has been set.
        return password;
     * Sets the password associated with this set of credentials.
     * @param password The password to associate with this username/password
     *                 pair.
     */
    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * Returns the username associated with this set of credentials.
     * @return The username associated with this username/password pair, or
     *         null if no username has been set.
        return username;
     * Sets the username associated with this set of credentials.
     * @param username The username to associate with this username/password
     *                 pair.
    public void setUsername(String username) {
        this.username = username;
        // Retrieve username and password from parms
        String username = request.getParameter("username");
        String password = request.getParameter("password");

        credentials.setUsername(username);
        credentials.setPassword(password);
 * being closed can be accessed through getTunnel(), and the UserContext
 * associated with the request which is closing the tunnel can be retrieved
 * with getUserContext().
 * being connected can be accessed through getTunnel(), and the UserContext
 * associated with the request which is connecting the tunnel can be retrieved
 * with getUserContext().

            // Obtain context from session
            HttpSession httpSession = request.getSession(true);
            // If new credentials present, update/create context
            if (hasNewCredentials(request)) {
                // Retrieve username and password from parms
                String username = request.getParameter("username");
                String password = request.getParameter("password");

                // Build credentials object
                Credentials credentials = new Credentials();
                credentials.setSession(httpSession);
                credentials.setRequest(request);
                credentials.setUsername(username);
                credentials.setPassword(password);

                SessionListenerCollection listeners = new SessionListenerCollection(httpSession);

                // If no cached context, attempt to get new context
                if (context == null)
                    context = authProvider.getUserContext(credentials);

                // Otherwise, update existing context
                else
                    context = authProvider.updateUserContext(context, credentials);

                // If no context, fail authentication, notify listeners
                if (context == null) {
                    logger.warn("Authentication attempt from {} for user \"{}\" failed.",
                            request.getRemoteAddr(), credentials.getUsername());

                    notifyFailed(listeners, credentials);
                }

                // Otherwise, associate (possibly updated) context with session
                // and notify listeners
                else {

                    httpSession.setAttribute(CONTEXT_ATTRIBUTE, context);
                }
            } // end if credentials present
            // If no context, no authorizaton present
            if (context == null)
                throw new GuacamoleSecurityException("Not authenticated");
                if (context == null) {

                    // Log successful authentication
                    if (context != null)
                        logger.info("User \"{}\" successfully authenticated from {}.",
                                context.self().getUsername(), request.getRemoteAddr());
                    
                }

                // If auth failed, notify listeners
                // If auth succeeded, notify and check with listeners
                else if (!notifySuccess(listeners, context, credentials)) {
                    logger.info("Successful authentication canceled by hook.");
                    context = null;
                // If auth still OK, associate context with session
                else
                    httpSession.setAttribute(CONTEXT_ATTRIBUTE, context);

import net.sourceforge.guacamole.net.auth.Credentials;
public class TunnelCloseEvent implements UserEvent, CredentialEvent, TunnelEvent {
     * The UserContext associated with the request that is closing the
     * The credentials associated with the request that connected the
     * tunnel, if any.
     */
    private Credentials credentials;

    /**
     * @param context The UserContext associated with the request closing 
     * @param credentials The credentials associated with the request that 
     *                    connected the tunnel.
    public TunnelCloseEvent(UserContext context, Credentials credentials,
            GuacamoleTunnel tunnel) {
        this.credentials = credentials;
    public Credentials getCredentials() {
        return credentials;
    }

    @Override
import net.sourceforge.guacamole.net.auth.Credentials;
public class TunnelConnectEvent implements UserEvent, CredentialEvent, TunnelEvent {
     * The credentials associated with the request that is connecting the
     * tunnel, if any.
     */
    private Credentials credentials;

    /**
     * @param credentials The credentials associated with the request connecting
     *                    the tunnel.
    public TunnelConnectEvent(UserContext context, Credentials credentials,
            GuacamoleTunnel tunnel) {
        this.credentials = credentials;
    public Credentials getCredentials() {
        return credentials;
    }

    @Override
     * The session attribute holding the credentials authorizing this session.
     */
    private static final String CREDENTIALS_ATTRIBUTE = "GUAC_CREDS";

    /**
     * Returns the credentials associated with the given session.
     *
     * @param session The session to retrieve credentials from.
     * @return The credentials associated with the given session.
     */
    protected Credentials getCredentials(HttpSession session) {
        return (Credentials) session.getAttribute(CREDENTIALS_ATTRIBUTE);
    }

    /**
                else {
                    httpSession.setAttribute(CONTEXT_ATTRIBUTE,     context);
                    httpSession.setAttribute(CREDENTIALS_ATTRIBUTE, credentials);
                }
import net.sourceforge.guacamole.net.auth.Credentials;
     * @param credentials The credentials associated with the current session.
    private boolean notifyConnect(Collection listeners, UserContext context,
            Credentials credentials, GuacamoleTunnel tunnel)
        TunnelConnectEvent event = new TunnelConnectEvent(context,
                credentials, tunnel);
     * @param credentials The credentials associated with the current session.
    private boolean notifyClose(Collection listeners, UserContext context,
            Credentials credentials, GuacamoleTunnel tunnel)
        TunnelCloseEvent event = new TunnelCloseEvent(context,
                credentials, tunnel);
            // Get credentials
            final Credentials credentials = getCredentials(httpSession);


            // If no context or no credentials, not logged in
            if (context == null || credentials == null)
                    if (!notifyClose(listeners, context, credentials, this))
            if (!notifyConnect(listeners, context, credentials, tunnel)) {
        // Not equal if null or not a Connection
public interface Connection extends ConnectionGroupMember {
 * Contributor(s): James Muehlner
    /**
     * Retrieves a Directory which can be used to view and manipulate
     * connection groups and their members, but only as allowed by the
     * permissions given to the user of this UserContext.
     *
     * @return A Directory whose operations are bound by the restrictions
     *         of this UserContext.
     *
     * @throws GuacamoleException If an error occurs while creating the
     *                            Directory.
     */
    Directory<String, ConnectionGroup> getConnectionGroupDirectory()
            throws GuacamoleException;

public interface Connection {
 * Represents a connection group, which can contain both other connection groups
 * as well as connections.
public interface ConnectionGroup {
     * Sets the identifier assigned to this ConnectionGroup.

     * Retrieves a Directory which can be used to view and manipulate
     * connections and their configurations, but only as allowed by the
     * permissions given to the user.
     *
     * @return A Directory whose operations are bound by the permissions of 
     *         the user.
     *
     * @throws GuacamoleException If an error occurs while creating the
     *                            Directory.
    Directory<String, Connection> getConnectionDirectory()
            throws GuacamoleException;

     * Retrieves a Directory which can be used to view and manipulate
     * connection groups and their members, but only as allowed by the
     * permissions given to the user.
     *
     * @return A Directory whose operations are bound by the permissions of
     *         the user.
     *
     * @throws GuacamoleException If an error occurs while creating the
     *                            Directory.
    Directory<String, ConnectionGroup> getConnectionGroupDirectory()
            throws GuacamoleException;
     * Retrieves a connection group which can be used to view and manipulate
     * connections, but only as allowed by the permissions given to the user of 
     * this UserContext.
     * @return A connection group whose operations are bound by the restrictions
    ConnectionGroup getConnectionGroup() throws GuacamoleException;
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
     * The Directory with access only to those Connection Groups that the User
     * associated with this UserContext has access to.
     */
    private final Directory<String, ConnectionGroup> connectionGroupDirectory;

    /**
     * The ConnectionGroup with access only to those Connections that the User
     * associated with this UserContext has access to.
     */
    private final ConnectionGroup connectionGroup;

    /**
        
        this.connectionGroupDirectory = new SimpleConnectionGroupDirectory();
        
        this.connectionGroup = new SimpleConnectionGroup(this.connectionDirectory,
                this.connectionGroupDirectory);
    @Override
    public ConnectionGroup getConnectionGroup() throws GuacamoleException {
        return connectionGroup;
    }

import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupMapper;
                    addMapperClass(ConnectionGroupMapper.class);
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
    public ConnectionGroup getConnectionGroup() throws GuacamoleException {
        throw new UnsupportedOperationException("Not supported yet.");
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionGroupService;
import net.sourceforge.guacamole.net.auth.mysql.service.SHA256PasswordEncryptionService;
                    bind(ConnectionGroupService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionGroupService;

    /**
     * Service managing connection groups.
     */
    @Inject
    private ConnectionGroupService connectionGroupService;
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnectionGroup;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupMapper;
 * manipulating connection groups.
 * @author James Muehlner
    
    
    /**
     * Service managing connections.
     */
    @Inject
    private ConnectionService connectionService;
    
    /**
     * DAO for accessing connection groups.
     */
    @Inject
    private ConnectionGroupMapper connectionGroupDAO;
     * Provider which creates MySQLConnectionGroups.
    @Inject
    private Provider<MySQLConnectionGroup> mysqlConnectionGroupProvider;
    public GuacamoleSocket connect(MySQLConnectionGroup aThis, 
            GuacamoleClientInformation info, int userID) {
        throw new UnsupportedOperationException("Not yet implemented");
    
    
    private Directory<String, Connection> connectionDirectory = null;
    private Directory<String, ConnectionGroup> connectionGroupDirectory = null;
    public void init(Integer connectionGroupID, String identifier, int userID) {
    
    private void loadConnectionDirectory() {
        
    }
    
        if(connectionDirectory == null)
            loadConnectionDirectory();
    
    private void loadConnectionGroupDirectory() {
        
    }
        if(connectionGroupDirectory == null)
            loadConnectionGroupDirectory();
import com.google.common.collect.Lists;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import net.sourceforge.guacamole.net.auth.mysql.model.Connection;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroup;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupExample;
    public GuacamoleSocket connect(MySQLConnectionGroup group, 
    //public Collection<MySQLConnection> getConnectionGroupConnections()
    

    /**
     * Retrieves a map of all connection group names for the given IDs.
     *
     * @param ids The IDs of the connection groups to retrieve the names of.
     * @return A map containing the names of all connection groups and their
     *         corresponding IDs.
     */
    public Map<Integer, String> retrieveNames(Collection<Integer> ids) {

        // If no IDs given, just return empty map
        if (ids.isEmpty())
            return Collections.EMPTY_MAP;

        // Map of all names onto their corresponding IDs.
        Map<Integer, String> names = new HashMap<Integer, String>();

        // Get all connection groups having the given IDs
        ConnectionGroupExample example = new ConnectionGroupExample();
        example.createCriteria().andConnection_group_idIn(Lists.newArrayList(ids));
        List<ConnectionGroup> connectionGroups = connectionGroupDAO.selectByExample(example);

        // Produce set of names
        for (ConnectionGroup connectionGroup : connectionGroups)
            names.put(connectionGroup.getConnection_group_id(),
                      connectionGroup.getConnection_group_name());

        return names;

    }

    /**
     * Get the names of all the connection groups defined in the system.
     *
     * @return A Set of names of all the connection groups defined in the system.
     */
    public Set<String> getAllConnectionGroupNames() {

        // Set of all present connection group names
        Set<String> names = new HashSet<String>();

        // Query all connection group names
        List<ConnectionGroup> connectionGroups =
                connectionGroupDAO.selectByExample(new ConnectionGroupExample());
        for (ConnectionGroup connectionGroup : connectionGroups)
            names.add(connectionGroup.getConnection_group_name());

        return names;

    }

    /**
     * Get the connection group IDs of all the connection groups defined in the system.
     *
     * @return A list of connection group IDs of all the connection groups defined in the system.
     */
    public List<Integer> getAllConnectionGroupIDs() {

        // Set of all present connection group IDs
        List<Integer> connectionGroupIDs = new ArrayList<Integer>();

        // Query all connection IDs
        List<ConnectionGroup> connections =
                connectionGroupDAO.selectByExample(new ConnectionGroupExample());
        for (ConnectionGroup connection : connections)
            connectionGroupIDs.add(connection.getConnection_group_id());

        return connectionGroupIDs;

    }
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupPermissionKey;
import net.sourceforge.guacamole.net.auth.permission.ConnectionGroupPermission;
     * Service for accessing connection groups.
     */
    @Inject
    private ConnectionGroupService connectionGroupService;

    /**
    
    /**
     * DAO for accessing permissions related to connection groups.
     */
    @Inject
    private ConnectionGroupPermissionMapper connectionGroupPermissionDAO;

    /**
     * Verifies that the user has the specified access to the given connection group.
     * If permission is denied, a GuacamoleSecurityException is thrown.
     *
     * @param userID The ID of the user to check.
     * @param affectedConnectionGroupID The connection group that would be affected by the
     *                                  operation if permission is granted.
     * @param permissionType The type of permission to check for.
     * @throws GuacamoleSecurityException If the specified permission is not
     *                                    granted.
     */
    public void verifyConnectionGroupAccess(int userID, int affectedConnectionGroupID, String permissionType) throws GuacamoleSecurityException {

        // If permission does not exist, throw exception
        if(!checkConnectionGroupAccess(userID, affectedConnectionGroupID, permissionType))
            throw new GuacamoleSecurityException("Permission denied.");

    }
    
     * Checks whether a user has the specified type of access to the affected
     * connection group.
     *
     * @param userID The ID of the user to check.
     * @param affectedConnectionGroupID The connection group that would be affected by the
     *                                  operation if permission is granted.
     * @param permissionType The type of permission to check for.
     * @return true if the specified permission is granted, false otherwise.
     */
    public boolean checkConnectionGroupAccess(int userID, Integer affectedConnectionGroupID, String permissionType) {

        // A system administrator has full access to everything.
        if(checkSystemAdministratorAccess(userID))
            return true;

        // Check existence of requested permission
        ConnectionGroupPermissionExample example = new ConnectionGroupPermissionExample();
        example.createCriteria().andUser_idEqualTo(userID).andConnection_group_idEqualTo(affectedConnectionGroupID).andPermissionEqualTo(permissionType);
        return connectionGroupPermissionDAO.countByExample(example) > 0;

    }

    /**
     * Find the list of the IDs of all connection groups a user has permission to.
     * The access type is defined by permissionType.
     *
     * @param userID The ID of the user to check.
     * @param permissionType The type of permission to check for.
     * @return A list of all connection group IDs this user has the specified access
     *         to.
     */
    public List<Integer> retrieveConnectionGroupIDs(int userID,
            String permissionType) {

        // A system administrator has access to all connections.
        if(checkSystemAdministratorAccess(userID))
            return connectionGroupService.getAllConnectionGroupIDs();

        // Query all connection permissions for the given user and permission type
        ConnectionGroupPermissionExample example = new ConnectionGroupPermissionExample();
        example.createCriteria().andUser_idEqualTo(userID).andPermissionEqualTo(permissionType);
        example.setDistinct(true);
        List<ConnectionGroupPermissionKey> connectionGroupPermissions =
                connectionGroupPermissionDAO.selectByExample(example);

        // Convert result into list of IDs
        List<Integer> connectionGroupIDs = new ArrayList<Integer>(connectionGroupPermissions.size());
        for(ConnectionGroupPermissionKey permission : connectionGroupPermissions)
            connectionGroupIDs.add(permission.getConnection_group_id());

        return connectionGroupIDs;

    }

    /**
     * Retrieves all connection group permissions granted to the user having the
     * given ID.
     *
     * @param userID The ID of the user to retrieve permissions of.
     * @return A set of all connection group permissions granted to the user having
     *         the given ID.
     */
    public Set<ConnectionGroupPermission> retrieveConnectionGroupPermissions(int userID) {

        // Set of all permissions
        Set<ConnectionGroupPermission> permissions = new HashSet<ConnectionGroupPermission>();

        // Query all connection permissions
        ConnectionGroupPermissionExample connectionGroupPermissionExample = new ConnectionGroupPermissionExample();
        connectionGroupPermissionExample.createCriteria().andUser_idEqualTo(userID);
        List<ConnectionGroupPermissionKey> connectionGroupPermissions =
                connectionGroupPermissionDAO.selectByExample(connectionGroupPermissionExample);

        // Get list of affected connection IDs
        List<Integer> connectionGroupIDs = new ArrayList<Integer>();
        for(ConnectionGroupPermissionKey connectionGroupPermission : connectionGroupPermissions)
            connectionGroupIDs.add(connectionGroupPermission.getConnection_group_id());

        // Get corresponding names
        Map<Integer, String> affectedConnectionGroups =
                connectionGroupService.retrieveNames(connectionGroupIDs);

        // Add connection permissions
        for(ConnectionGroupPermissionKey connectionGroupPermission : connectionGroupPermissions) {

            // Construct permission from data
            ConnectionGroupPermission permission = new ConnectionGroupPermission(
                ConnectionGroupPermission.Type.valueOf(connectionGroupPermission.getPermission()),
                affectedConnectionGroups.get(connectionGroupPermission.getConnection_group_id())
            );

            // Add to set
            permissions.add(permission);

        }

        return permissions;

    }

    /**
        
        // add connection group permissions
        allPermissions.addAll(retrieveConnectionGroupPermissions(userID));
     * The ID of the parent connection for this connection group.
     */
    private Integer parentID;

    /**
     * Get the ID of the parent connection group for this connection, if any.
     * @return The ID of the parent connection group for this connection, if any.
     */
    public Integer getParentID() {
        return parentID;
    }

    /**
     * Sets the ID of the parent connection group for this connection.
     * @param connectionID The ID of the parent connection group for this connection.
     */
    public void setParentID(Integer parentID) {
        this.parentID = parentID;
    }

    /**
     * @param parentID The D of the parent connection group for this connection, if any.
    public void init(Integer connectionID, Integer parentID, String identifier,
        this.parentID = parentID;
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
import net.sourceforge.guacamole.net.auth.mysql.service.PermissionCheckService;
     * The ID of the parent connection group for this connection group.
     */
    private Integer parentID;

    /**
     * Service managing connections.
     */
    @Inject
    private ConnectionService connectionService;

    /**
     * Service for checking permissions.
     */
    @Inject
    private PermissionCheckService permissionCheckService;

    /**
     * Get the ID of the parent connection group for this connection group, if any.
     * @return The ID of the parent connection group for this connection group, if any.
     */
    public Integer getParentID() {
        return parentID;
    }

    /**
     * Sets the ID of the parent connection group for this connection group.
     * @param connectionID The ID of the parent connection group for this connection group.
     */
    public void setParentID(Integer parentID) {
        this.parentID = parentID;
    }

    /**
     * @param parentID The D of the parent connection group for this connection group, if any.
    public void init(Integer connectionGroupID, Integer parentID, String identifier, int userID) {
        this.parentID = parentID;
    
    
    /**
     * Retrieves all connection groups with a given parent connection group ID.
     * 
     * @param parentID The parent ID of the connection groups.
     * @param userID The ID of the user who queried these connection groups.
     * @return All connection groups with a given parent connection group ID.
     */
    public Collection<MySQLConnectionGroup> getConnectionGroupsByParentConnectionGroup(Integer parentID, int userID) {
        
        // A null parentID indicates the root-level group
        ConnectionGroupExample example = new ConnectionGroupExample();
        if(parentID != null)
            example.createCriteria().andParent_group_idEqualTo(parentID);
        else
            example.createCriteria().andParent_group_idIsNull();
        
        // Get all connections with the given parent ID
        List<ConnectionGroup> connectionGroups = connectionGroupDAO.selectByExample(example);
        
        List<MySQLConnectionGroup> mySQLConnectionGroups = new ArrayList<MySQLConnectionGroup>();
        
        for(ConnectionGroup connectionGroup : connectionGroups) {
            mySQLConnectionGroups.add(toMySQLConnectionGroup(connectionGroup, userID));
        }
        
        return mySQLConnectionGroups;
    }
     * Convert the given database-retrieved Connection into a MySQLConnection.
     * The parameters of the given connection will be read and added to the
     * MySQLConnection in the process.
     *
     * @param connection The connection to convert.
     * @param userID The user who queried this connection.
     * @return A new MySQLConnection containing all data associated with the
     *         specified connection.
     */
    private MySQLConnectionGroup toMySQLConnectionGroup(ConnectionGroup connectionGroup, int userID) {

        // Create new MySQLConnection from retrieved data
        MySQLConnectionGroup mySQLConnectionGroup = mysqlConnectionGroupProvider.get();
        mySQLConnectionGroup.init(
            connectionGroup.getConnection_group_id(),
            connectionGroup.getParent_group_id(),
            connectionGroup.getConnection_group_name(),
            userID
        );

        return mySQLConnectionGroup;

    }

    /**
    
    /**
     * Retrieves all connections with a given parent connection group ID.
     * 
     * @param parentID The parent ID of the connections.
     * @param userID The ID of the user who queried these connections.
     * @return All connections with a given parent connection group ID.
     */
    public Collection<MySQLConnection> getConnectionsByParentConnectionGroup(Integer parentID, int userID) {
        
        // A null parentID indicates the root-level group
        ConnectionExample example = new ConnectionExample();
        if(parentID != null)
            example.createCriteria().andConnection_group_idEqualTo(parentID);
        else
            example.createCriteria().andConnection_group_idIsNull();
        
        // Get all connections with the given parent ID
        List<Connection> connections = connectionDAO.selectByExample(example);
        
        List<MySQLConnection> mySQLConnections = new ArrayList<MySQLConnection>();
        
        for(Connection connection : connections) {
            mySQLConnections.add(toMySQLConnection(connection, userID));
        }
        
        return mySQLConnections;
    }
            connection.getConnection_group_id(),
     * The ID of the parent connection group.
     */
    private Integer parentID;

    /**
     * Set the user and parentID for this directory.
     * @param parentID The ID of the parent connection group.
    public void init(int user_id, Integer parentID) {
        this.parentID = parentID;
    public Connection get(String name) throws GuacamoleException {
                connectionService.retrieveConnection(name, parentID, user_id);
        
        // Verify permission to use the connection group for organizational purposes
        permissionCheckService.verifyConnectionGroupUsageAccess
                (parentID, user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        
        return permissionCheckService.retrieveConnectionNames(user_id, 
                parentID, MySQLConstants.CONNECTION_READ);
        
        
        // Verify permission to edit the connection group
        permissionCheckService.verifyConnectionGroupAccess(this.user_id, 
                this.parentID, MySQLConstants.CONNECTION_GROUP_UPDATE);
        
        // Verify permission to use the connection group for organizational purposes
        permissionCheckService.verifyConnectionGroupUsageAccess
                (parentID, user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
                connectionService.retrieveConnection(identifier, user_id, parentID);
                connectionService.retrieveConnection(identifier, parentID, user_id);
     * The ID of the parent connection for this connection.
    public void init(Integer connectionID, Integer parentID, String name, 
            String identifier, GuacamoleConfiguration config,
        setName(name);
import com.google.inject.Provider;
    
    /**
     * The type of this connection group.
     */
    private String type;
    private ConnectionDirectory connectionDirectory = null;
    private ConnectionGroupDirectory connectionGroupDirectory = null;
    
    /**
     * Service for creating new ConnectionDirectory objects.
     */
    @Inject Provider<ConnectionDirectory> connectionDirectoryProvider;
    
    /**
     * Service for creating new ConnectionGroupDirectory objects.
     */
    @Inject Provider<ConnectionGroupDirectory> connectionGroupDirectoryProvider;
     * @param parentID The ID of the parent connection group for this connection group, if any.
     * @param type The type of this connection group.
    public void init(Integer connectionGroupID, Integer parentID, String name, 
            String identifier, String type, int userID) {
        setName(name);
        this.type = type;
        
        connectionDirectory = connectionDirectoryProvider.get();
        connectionDirectory.init(userID, parentID);
        
        connectionGroupDirectory = connectionGroupDirectoryProvider.get();
        //connectionGroupDirectory.init(userID, parentID);
        // Verify permission to use the connection group for balancing purposes
        permissionCheckService.verifyConnectionGroupUsageAccess
                (this.connectionGroupID, this.userID, MySQLConstants.CONNECTION_GROUP_BALANCING);
        
        return connectionGroupService.connect(this, info, userID);
    
    /**
     * Returns the connection group type.
     * @return the connection group type.
     */
    public String getType() {
        return type;
    }
    
    /**
     * Sets the connection group type.
     * @param type the connection group type.
     */
    public void setType(String type) {
        this.type = type;
    }

    @Override
    public void setBalancing(boolean balancing) {
        if(balancing)
            this.type = MySQLConstants.CONNECTION_GROUP_BALANCING;
        else
            this.type = MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL;
    }

    @Override
    public boolean isBalancing() {
        return MySQLConstants.CONNECTION_GROUP_BALANCING.equals(this.type);
    }
     * The string stored in the database to represent READ access to a
     * connection.
     */
    public static final String CONNECTION_GROUP_READ = "READ";

    /**
     * The string stored in the database to represent UPDATE access to a
     * connection group.
     */
    public static final String CONNECTION_GROUP_UPDATE = "UPDATE";

    /**
     * The string stored in the database to represent DELETE access to a
     * connection group.
     */
    public static final String CONNECTION_GROUP_DELETE = "DELETE";

    /**
     * The string stored in the database to represent ADMINISTER access to a
     * connection group.
     */
    public static final String CONNECTION_GROUP_ADMINISTER = "ADMINISTER";

    /**
     * The string stored in the database to represent a BALANCING
     * connection group.
     */
    public static final String CONNECTION_GROUP_BALANCING = "BALANCING";

    /**
     * The string stored in the database to represent an ORGANIZATIONAL
     * connection group.
     */
    public static final String CONNECTION_GROUP_ORGANIZATIONAL = 
            "ORGANIZATIONAL";

    /**
    /**
     * Given the type of a permission affecting a connection group, 
     * returns the MySQL constant representing that permission type.
     *
     * @param type The type of permission to look up.
     * @return The MySQL constant corresponding to the given permission type.
     */
    public static String getConnectionGroupConstant(ObjectPermission.Type type) {

        // Convert permission type to MySQL constant
        switch (type) {
            case READ:       return CONNECTION_GROUP_READ;
            case UPDATE:     return CONNECTION_GROUP_UPDATE;
            case ADMINISTER: return CONNECTION_GROUP_ADMINISTER;
            case DELETE:     return CONNECTION_GROUP_DELETE;
        }

        // If we get here, permission support was not properly implemented
        throw new UnsupportedOperationException(
            "Unsupported permission type: "  type);

    }
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnection;
import net.sourceforge.guacamole.net.auth.mysql.model.Connection;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupExample.Criteria;

     * Retrieves the connection group having the given 
     * name from the database.
     *
     * @param name The name of the connection to return.
     * @param parentID The ID of the parent connection group.
     * @param userID The ID of the user who queried this connection group.
     * @return The connection having the given name, or null if no such
     *         connection group could be found.
    public MySQLConnectionGroup retrieveConnectionGroup(String name, Integer parentID,
            int userID) {

        // Create criteria
        Criteria criteria = example.createCriteria().andConnection_group_nameEqualTo(name);
            criteria.andParent_idEqualTo(parentID);
            criteria.andParent_idIsNull();
        // Query connection group by name and parentID
        List<ConnectionGroup> connectionGroups =
                connectionGroupDAO.selectByExample(example);

        // If no connection group found, return null
        if(connectionGroups.isEmpty())
            return null;

        // Otherwise, return found connection
        return toMySQLConnectionGroup(connectionGroups.get(0), userID);

    }
    
    /**
     * Retrieves the connection group having the given ID from the database.
     *
     * @param id The ID of the connection group to retrieve.
     * @param userID The ID of the user who queried this connection.
     * @return The connection group having the given ID, or null if no such
     *         connection was found.
     */
    public MySQLConnectionGroup retrieveConnectionGroup(int id, int userID) {

        // Query connection by ID
        ConnectionGroup connectionGroup = connectionGroupDAO.selectByPrimaryKey(id);

        // If no connection found, return null
        if(connectionGroup == null)
            return null;

        // Otherwise, return found connection
        return toMySQLConnectionGroup(connectionGroup, userID);
     * Retrieves a translation map of connection group names to their 
     * corresponding IDs.
     *
     * @param ids The IDs of the connection groups to retrieve the names of.
     * @return A map containing the names of all connection groups and their
     *         corresponding IDs.
     */
    public Map<String, Integer> translateNames(List<Integer> ids) {

        // If no IDs given, just return empty map
        if (ids.isEmpty())
            return Collections.EMPTY_MAP;

        // Map of all names onto their corresponding IDs.
        Map<String, Integer> names = new HashMap<String, Integer>();

        // Get all connections having the given IDs
        ConnectionGroupExample example = new ConnectionGroupExample();
        example.createCriteria().andConnection_group_idIn(ids);
        List<ConnectionGroup> connectionGroups = connectionGroupDAO.selectByExample(example);

        // Produce set of names
        for (ConnectionGroup connectionGroup : connectionGroups)
            names.put(connectionGroup.getConnection_group_name(),
                      connectionGroup.getConnection_group_id());

        return names;

    }
    
    /**
     * Returns a list of the IDs of all connection groups with a given parent ID.
     * @param parentID The ID of the parent for all the queried connection groups.
     * @return a list of the IDs of all connection groups with a given parent ID.
     */
    public List<Integer> getAllConnectionGroupIDs(Integer parentID) {
        
        // Create criteria
        ConnectionGroupExample example = new ConnectionGroupExample();
        Criteria criteria = example.createCriteria();
        
        if(parentID != null)
            criteria.andConnection_group_idEqualTo(parentID);
        else
            criteria.andConnection_group_idIsNull();
        
        // Query the connections
        List<ConnectionGroup> connectionGroups = connectionGroupDAO.selectByExample(example);
        
        // List of IDs of connections with the given parent
        List<Integer> connectionGroupIDs = new ArrayList<Integer>();
        
        for(ConnectionGroup connectionGroup : connectionGroups) {
            connectionGroupIDs.add(connectionGroup.getConnection_group_id());
        }
        
        return connectionGroupIDs;
    }

    /**
            connectionGroup.getParent_id(),
            Integer.toString(connectionGroup.getConnection_group_id()),
            connectionGroup.getType(),
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionExample.Criteria;
     * @param parentID The ID of the parent connection group.
    public MySQLConnection retrieveConnection(String name, Integer parentID,
            int userID) {
        // Create criteria
        Criteria criteria = example.createCriteria().andConnection_nameEqualTo(name);
        if(parentID != null)
            criteria.andParent_idEqualTo(parentID);
        else
            criteria.andParent_idIsNull();
        
        // Query connection by name and parentID
    
    /**
     * Returns a list of the IDs of all connections with a given parent ID.
     * @param parentID The ID of the parent for all the queried connections.
     * @return a list of the IDs of all connections with a given parent ID.
     */
    public List<Integer> getAllConnectionIDs(Integer parentID) {
        
        // Create criteria
        ConnectionExample example = new ConnectionExample();
        Criteria criteria = example.createCriteria();
        
        if(parentID != null)
            criteria.andConnection_idEqualTo(parentID);
        else
            criteria.andConnection_idIsNull();
        
        // Query the connections
        List<Connection> connections = connectionDAO.selectByExample(example);
        
        // List of IDs of connections with the given parent
        List<Integer> connectionIDs = new ArrayList<Integer>();
        
        for(Connection connection : connections) {
            connectionIDs.add(connection.getConnection_id());
        }
        
        return connectionIDs;
    }
            connection.getParent_id(),
            Integer.toString(connection.getConnection_id()),
     * Get the names of all the connections defined in the system 
     * with a certain parentID.
     * @return A Set of names of all the connections defined in the system
     * with the given parentID.
    public Set<String> getAllConnectionNames(Integer parentID) {
        
        // Set up Criteria
        ConnectionExample example = new ConnectionExample();
        Criteria criteria = example.createCriteria();
        if(parentID != null)
            criteria.andParent_idEqualTo(parentID);
        else
            criteria.andParent_idIsNull();
        // Query connection names
                connectionDAO.selectByExample(example);
     * Get the connection IDs of all the connections defined in the system 
     * with a certain parent connection group.
     * 
     * @param parentID The parent connection group ID.
        // Create the criteria
        ConnectionExample example = new ConnectionExample();
        /*Criteria criteria = example.createCriteria();
        if(parentID != null)
            criteria.andParent_idEqualTo(parentID);
        else
            criteria.andParent_idIsNull();*/
        
        // Query the connections
                connectionDAO.selectByExample(example);
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnectionGroup;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionPermissionExample.Criteria;
    
    /**
     * Verifies that the specified group can be used for organization 
     * by the given user.
     * 
     * @param connectionGroupID The ID of the affected ConnectionGroup.
     * @param userID The ID of the user to check.
     * @throws GuacamoleSecurityException If the connection group 
     *                                    cannot be used for organization.
     */
    public void verifyConnectionGroupUsageAccess(Integer connectionGroupID, 
            int userID, String type) throws GuacamoleSecurityException {

        // If permission does not exist, throw exception
        if(!checkConnectionGroupUsageAccess(connectionGroupID, userID, type))
            throw new GuacamoleSecurityException("Permission denied.");

    }
    
    /**
     * Check whether a user can use connectionGroup for the given usage.
     * @param connectionGroupID the ID of the affected connection group.
     * @param userID The ID of the user to check.
     * @param usage The desired usage.
     * @return true if the user can use the connection group for the given usage.
     */
    private boolean checkConnectionGroupUsageAccess(
            Integer connectionGroupID, int userID, String usage) {
        
        // The root level connection group can only be used for organization
        if(connectionGroupID == null)
            return MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL.equals(usage);

        // A system administrator has full access to everything.
        if(checkSystemAdministratorAccess(userID))
            return true;
        
        // Query the connection group
        MySQLConnectionGroup connectionGroup = connectionGroupService.
                retrieveConnectionGroup(connectionGroupID, userID);
        
        // If the connection group is not found, it cannot be used.
        if(connectionGroup == null)
            return false;

        // Verify that the desired usage matches the type.
        return connectionGroup.getType().equals(usage);
        
    }
    
    /**
     * 
     * @param userID
     * @throws GuacamoleSecurityException 
     */
    private void verifySystemAdministratorAccess(int userID)
            throws GuacamoleSecurityException {

        // If permission does not exist, throw exception
        if(!checkSystemAdministratorAccess(userID))
            throw new GuacamoleSecurityException("Permission denied.");
    }

        return retrieveConnectionIDs(userID, null, permissionType, false);

    }

    /**
     * Find the list of the IDs of all connections a user has permission to.
     * The access type is defined by permissionType.
     *
     * @param userID The ID of the user to check.
     * @param parentID the parent connection group.
     * @param permissionType The type of permission to check for.
     * @return A list of all connection IDs this user has the specified access
     *         to.
     */
    public List<Integer> retrieveConnectionIDs(int userID, Integer parentID,
            String permissionType) {

        return retrieveConnectionIDs(userID, parentID, permissionType, true);

    }

    /**
     * Find the list of the IDs of all connections a user has permission to.
     * The access type is defined by permissionType.
     *
     * @param userID The ID of the user to check.
     * @param parentID the parent connection group.
     * @param permissionType The type of permission to check for.
     * @param checkParentID Whether the parentID should be checked or not.
     * @return A list of all connection IDs this user has the specified access
     *         to.
     */
    private List<Integer> retrieveConnectionIDs(int userID, Integer parentID,
            String permissionType, boolean checkParentID) {

        if(checkSystemAdministratorAccess(userID)) {
            if(checkParentID)
                return connectionService.getAllConnectionIDs(parentID);
            else
                return connectionService.getAllConnectionIDs();
        }
        Criteria criteria = example.createCriteria().andUser_idEqualTo(userID)
                .andPermissionEqualTo(permissionType);
        
        // Ensure that the connections are all under the parent ID, if needed
        if(checkParentID) {
            // Get the IDs of all connections in the connection group
            List<Integer> allConnectionIDs = connectionService.getAllConnectionIDs(parentID);
            criteria.andConnection_idIn(allConnectionIDs);
        }
                                              
        return retrieveConnectionGroupIDs(userID, null, permissionType, false);

    }

    /**
     * Find the list of the IDs of all connection groups a user has permission to.
     * The access type is defined by permissionType.
     *
     * @param userID The ID of the user to check.
     * @param parentID the parent connection group.
     * @param permissionType The type of permission to check for.
     * @return A list of all connection group IDs this user has the specified access
     *         to.
     */
    public List<Integer> retrieveConnectionGroupIDs(int userID, Integer parentID,
            String permissionType) {

        return retrieveConnectionGroupIDs(userID, parentID, permissionType, true);

    }

    /**
     * Find the list of the IDs of all connection groups a user has permission to.
     * The access type is defined by permissionType.
     *
     * @param userID The ID of the user to check.
     * @param parentID the parent connection group.
     * @param permissionType The type of permission to check for.
     * @param checkParentID Whether the parentID should be checked or not.
     * @return A list of all connection group IDs this user has the specified access
     *         to.
     */
    private List<Integer> retrieveConnectionGroupIDs(int userID, Integer parentID,
            String permissionType, boolean checkParentID) {

        // A system administrator has access to all connectionGroups .
        if(checkSystemAdministratorAccess(userID)) {
            if(checkParentID)
                return connectionGroupService.getAllConnectionGroupIDs(parentID);
            else
                return connectionGroupService.getAllConnectionGroupIDs();
        }
        ConnectionGroupPermissionExample.Criteria criteria = 
                example.createCriteria().andUser_idEqualTo(userID)
                .andPermissionEqualTo(permissionType);
        
        // Ensure that the connection groups are all under the parent ID, if needed
        if(checkParentID) {
            // Get the IDs of all connection groups in the connection group
            List<Integer> allConnectionGroupIDs = connectionGroupService
                    .getAllConnectionGroupIDs(parentID);
            criteria.andConnection_group_idIn(allConnectionGroupIDs);
        }
                                              
     * @param parentID The parent connection group.
    public Set<String> retrieveConnectionNames(int userID, Integer parentID,
            String permissionType) {
            return connectionService.getAllConnectionNames(parentID);
        // List of all connection IDs for which this user has access
                retrieveConnectionIDs(userID, parentID, permissionType);
     * Retrieve all existing connection names that the given user has permission
     * to perform the given operation upon.
     *
     * @param userID The user whose permissions should be checked.
     * @param permissionType The permission to check.
     * @param parentID The parent connection group.
     * @return A set of all connection names for which the given user has the
     *         given permission.
     */
    public Set<String> retrieveConnectionGroupNames(int userID, Integer parentID,
            String permissionType) {

        // A system administrator has access to all connections.
        if(checkSystemAdministratorAccess(userID))
            return connectionService.getAllConnectionNames(parentID);

        // List of all connection group IDs for which this user has access
        List<Integer> connectionGroupIDs =
                retrieveConnectionGroupIDs(userID, parentID, permissionType);

        // Query all associated connections
        return connectionGroupService.translateNames(connectionGroupIDs).keySet();

    }

    /**
     * The name associated with this connection.
     */
    private String name;

    /**
    public String getName() {
        return name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }

    @Override
     * The name associated with this connection group.
     */
    private String name;

    /**
    
    @Override
    public String getName() {
        return name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }
     * Returns the name assigned to this Connection.
     * @return The name assigned to this Connection.
     */
    public String getName();

    /**
     * Sets the name assigned to this Connection.
     *
     * @param identifier The name to assign.
     */
    public void setName(String name);

    /**
     * Returns the name assigned to this ConnectionGroup.
     * @return The name assigned to this ConnectionGroup.
     */
    public String getName();

    /**
     * Sets the name assigned to this ConnectionGroup.
     *
     * @param identifier The name to assign.
     */
    public void setName(String name);

    /**
    
    /**
     * Sets whether this is a balancing ConnectionGroup.
     *
     * @param balancing whether this is a balancing ConnectionGroup.
     */
    public void setBalancing(boolean balancing);
    
    /**
     * Returns true if this is a balancing ConnectionGroup, false otherwise.
     * @return true if this is a balancing ConnectionGroup, false otherwise.
     */
    public boolean isBalancing();
     * @param name The name to associate with this connection.
     * @param identifier The identifier to associate with this connection.
    public SimpleConnection(String name, String identifier,
        
        // Set name
        setName(name);
                    new SimpleConnection(entry.getKey(), entry.getKey(), 
                entry.getValue()));
    @Override
    public void setBalancing(boolean balancing) {
        // All SimpleConnectionGroups are organizational only
    }

    @Override
    public boolean isBalancing() {
        // All SimpleConnectionGroups are organizational only 
        return false;
    }

import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupPermissionExample;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupPermissionKey;
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionGroupService;
import net.sourceforge.guacamole.net.auth.permission.ConnectionGroupPermission;
     * Service for accessing connection groups.
     */
    @Inject
    private ConnectionGroupService connectionGroupService;

    /**
     * DAO for accessing connection group permissions, which will be injected.
     */
    @Inject
    private ConnectionGroupPermissionMapper connectionGroupPermissionDAO;

    /**
        List<ConnectionGroupPermission> newConnectionGroupPermissions = new ArrayList<ConnectionGroupPermission>();
            else if (permission instanceof ConnectionGroupPermission)
                newConnectionGroupPermissions.add((ConnectionGroupPermission) permission);

        createConnectionGroupPermissions(user_id, newConnectionGroupPermissions);
        List<ConnectionGroupPermission> removedConnectionGroupPermissions = new ArrayList<ConnectionGroupPermission>();
            else if (permission instanceof ConnectionGroupPermission)
                removedConnectionGroupPermissions.add((ConnectionGroupPermission) permission);

        deleteConnectionGroupPermissions(user_id, removedConnectionGroupPermissions);
     * Create any new permissions having to do with connection groups 
     * for a given user.
     *
     * @param user_id The ID of the user to assign or remove permissions from.
     * @param permissions The new permissions the user should have after this
     *                    operation completes.
     * @throws GuacamoleException If permission to alter the access permissions
     *                            of affected objects is deniedD
     */
    private void createConnectionGroupPermissions(int user_id,
            Collection<ConnectionGroupPermission> permissions)
            throws GuacamoleException {

        // If no permissions given, stop now
        if(permissions.isEmpty())
            return;

        // Get list of administerable connection group IDs
        List<Integer> administerableConnectionGroupIDs =
            permissionCheckService.retrieveConnectionGroupIDs(this.user_id,
                MySQLConstants.CONNECTION_GROUP_ADMINISTER);

        // Get set of names corresponding to administerable connection groups
        Map<String, Integer> administerableConnectionGroups =
                connectionGroupService.translateNames(administerableConnectionGroupIDs);

        // Insert all given permissions
        for (ConnectionGroupPermission permission : permissions) {

            // Get original ID
            Integer connection_group_id =
                    administerableConnectionGroups.get(permission.getObjectIdentifier());

            // Throw exception if permission to administer this connection group
            // is not granted
            if (connection_group_id == null)
                throw new GuacamoleSecurityException(
                      "User #"  this.user_id
                     " does not have permission to administrate connection group"
                     permission.getObjectIdentifier());


            // Create new permission
            ConnectionGroupPermissionKey newPermission = new ConnectionGroupPermissionKey();
            newPermission.setUser_id(user_id);
            newPermission.setPermission(MySQLConstants.getConnectionConstant(permission.getType()));
            newPermission.setConnection_group_id(connection_group_id);
            connectionGroupPermissionDAO.insert(newPermission);

        }
    }

    /**
     * Delete permissions having to do with connection groups for a given user.
     *
     * @param user_id The ID of the user to change the permissions of.
     * @param permissions The permissions the given user should no longer have
     *                    when this operation completes.
     * @throws GuacamoleException If permission to alter the access permissions
     *                            of affected objects is denied.
     */
    private void deleteConnectionGroupPermissions(int user_id,
            Collection<ConnectionGroupPermission> permissions)
            throws GuacamoleException {

        // If no permissions given, stop now
        if(permissions.isEmpty())
            return;

        // Get list of administerable connection group IDs
        List<Integer> administerableConnectionGroupIDs =
            permissionCheckService.retrieveConnectionGroupIDs(this.user_id,
                MySQLConstants.CONNECTION_GROUP_ADMINISTER);

        // Get set of names corresponding to administerable connection groups
        Map<String, Integer> administerableConnectionGroups =
                connectionGroupService.translateNames(administerableConnectionGroupIDs);

        // Delete requested permissions
        for (ConnectionGroupPermission permission : permissions) {

            // Get original ID
            Integer connection_group_id =
                    administerableConnectionGroups.get(permission.getObjectIdentifier());

            // Verify that the user actually has permission to administrate
            // every one of these connection groups
            if (connection_group_id == null)
                throw new GuacamoleSecurityException(
                      "User #"  this.user_id
                     " does not have permission to administrate connection group"
                     permission.getObjectIdentifier());

            ConnectionGroupPermissionExample connectionGroupPermissionExample = new ConnectionGroupPermissionExample();
            connectionGroupPermissionExample.createCriteria()
                .andUser_idEqualTo(user_id)
                .andPermissionEqualTo(MySQLConstants.getConnectionGroupConstant(permission.getType()))
                .andConnection_group_idEqualTo(connection_group_id);
            connectionGroupPermissionDAO.deleteByExample(connectionGroupPermissionExample);

        }

    }

    /**
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionGroupService;
     * Service managing connection groups.
     */
    @Inject
    private ConnectionGroupService connectionGroupService;

    /**
    public Connection get(String identifier) throws GuacamoleException {
                connectionService.retrieveConnection(identifier, user_id);
        
        if(connection == null)
            return null;
        
        // Verify permission to use the parent connection group for organizational purposes
        permissionCheckService.verifyConnectionGroupUsageAccess
                (connection.getParentID(), user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        return permissionCheckService.retrieveConnectionIdentifiers(user_id, 
        String name = object.getName().trim();
        if(name.isEmpty())
            throw new GuacamoleClientException("The connection name cannot be blank.");
        // Verify that no connection already exists with this name.
                connectionService.retrieveConnection(name, user_id, parentID);
            throw new GuacamoleClientException("That connection name is already in use.");
                name, object.getConfiguration().getProtocol(), user_id);
                connectionService.retrieveConnection(identifier, user_id);
        
        if(mySQLConnection == null)
            throw new GuacamoleException("Connection not found.");
        
        // Verify permission to use the parent connection group for organizational purposes
        permissionCheckService.verifyConnectionGroupUsageAccess
                (mySQLConnection.getParentID(), user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
    @Override
    public void move(String identifier, String groupIdentifier) 
            throws GuacamoleException {

        // Get connection
        MySQLConnection mySQLConnection =
                connectionService.retrieveConnection(identifier, user_id);
        
        if(mySQLConnection == null)
            throw new GuacamoleException("Connection not found.");

        // Verify permission to update the connection
        permissionCheckService.verifyConnectionAccess(this.user_id,
                mySQLConnection.getConnectionID(),
                MySQLConstants.CONNECTION_UPDATE);
        
        // Verify permission to use the from connection group for organizational purposes
        permissionCheckService.verifyConnectionGroupUsageAccess
                (mySQLConnection.getParentID(), user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);

        // Verify permission to update the from connection group
        permissionCheckService.verifyConnectionGroupAccess(this.user_id,
                mySQLConnection.getParentID(), MySQLConstants.CONNECTION_GROUP_UPDATE);
        
        Integer toConnectionGroupID;
        if(groupIdentifier.equals(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER))
            toConnectionGroupID = null;
        try {
            toConnectionGroupID = Integer.valueOf(groupIdentifier);
        } catch(NumberFormatException e) {
            throw new GuacamoleException("Invalid connection group identifier.");
        }
        
        // Verify permission to use the to connection group for organizational purposes
        permissionCheckService.verifyConnectionGroupUsageAccess
                (toConnectionGroupID, user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);

        // Verify permission to update the to connection group
        permissionCheckService.verifyConnectionGroupAccess(this.user_id,
                toConnectionGroupID, MySQLConstants.CONNECTION_GROUP_UPDATE);
        
        // Update the connection
        mySQLConnection.setParentID(toConnectionGroupID);
        connectionService.updateConnection(mySQLConnection);
    }

import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionGroupPermissionKey;
     * Service for manipulating connection group permissions in the database.
    private ConnectionGroupPermissionMapper connectionGroupPermissionDAO;
     * Set the user and parentID for this directory.
     *
     * @param user_id The ID of the user owning this connection group directory.
     * @param parentID The ID of the parent connection group.
    public void init(int user_id, Integer parentID) {
        this.parentID = parentID;
        this.user_id = user_id;
    }
    public ConnectionGroup get(String identifier) throws GuacamoleException {
                connectionGroupService.retrieveConnectionGroup(identifier, user_id);
        
        if(connectionGroup == null)
            return null;
        
        // Verify permission to use the parent connection group for organizational purposes
        permissionCheckService.verifyConnectionGroupUsageAccess
                (connectionGroup.getParentID(), user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        return permissionCheckService.retrieveConnectionGroupIdentifiers(user_id, 
    @Transactional

        String name = object.getName().trim();
        if(name.isEmpty())
            throw new GuacamoleClientException("The connection group name cannot be blank.");
        
        // Verify permission to create
        permissionCheckService.verifySystemAccess(this.user_id,
                MySQLConstants.SYSTEM_CONNECTION_GROUP_CREATE);
        
        // Verify permission to edit the parent connection group
        permissionCheckService.verifyConnectionGroupAccess(this.user_id, 
                this.parentID, MySQLConstants.CONNECTION_GROUP_UPDATE);
        
        // Verify permission to use the parent connection group for organizational purposes
        permissionCheckService.verifyConnectionGroupUsageAccess
                (parentID, user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);

        // Verify that no connection already exists with this name.
        MySQLConnectionGroup previousConnectionGroup =
                connectionGroupService.retrieveConnectionGroup(name, user_id, parentID);
        if(previousConnectionGroup != null)
            throw new GuacamoleClientException("That connection group name is already in use.");

        // Create connection group
        MySQLConnectionGroup connectionGroup = connectionGroupService
                .createConnectionGroup(name, user_id);

        // Finally, give the current user full access to the newly created
        // connection group.
        ConnectionGroupPermissionKey newConnectionGroupPermission = new ConnectionGroupPermissionKey();
        newConnectionGroupPermission.setUser_id(this.user_id);
        newConnectionGroupPermission.setConnection_group_id(connectionGroup.getConnectionGroupID());

        // Read permission
        newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_READ);
        connectionGroupPermissionDAO.insert(newConnectionGroupPermission);

        // Update permission
        newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_UPDATE);
        connectionGroupPermissionDAO.insert(newConnectionGroupPermission);

        // Delete permission
        newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_DELETE);
        connectionGroupPermissionDAO.insert(newConnectionGroupPermission);

        // Administer permission
        newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_ADMINISTER);
        connectionGroupPermissionDAO.insert(newConnectionGroupPermission);

    @Transactional

        // If connection not actually from this auth provider, we can't handle
        // the update
        if (!(object instanceof MySQLConnectionGroup))
            throw new GuacamoleException("Connection not from database.");

        MySQLConnectionGroup mySQLConnectionGroup = (MySQLConnectionGroup) object;

        // Verify permission to update
        permissionCheckService.verifyConnectionAccess(this.user_id,
                mySQLConnectionGroup.getConnectionGroupID(),
                MySQLConstants.CONNECTION_UPDATE);

        // Perform update
        connectionGroupService.updateConnectionGroup(mySQLConnectionGroup);
    }

    @Transactional
    @Override
    public void remove(String identifier) throws GuacamoleException {

        // Get connection
        MySQLConnectionGroup mySQLConnectionGroup =
                connectionGroupService.retrieveConnectionGroup(identifier, user_id);
        
        if(mySQLConnectionGroup == null)
            throw new GuacamoleException("Connection group not found.");
        
        // Verify permission to use the parent connection group for organizational purposes
        permissionCheckService.verifyConnectionGroupUsageAccess
                (mySQLConnectionGroup.getParentID(), user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);

        // Verify permission to delete
        permissionCheckService.verifyConnectionGroupAccess(this.user_id,
                mySQLConnectionGroup.getConnectionGroupID(),
                MySQLConstants.CONNECTION_GROUP_DELETE);

        // Delete the connection group itself
        connectionGroupService.deleteConnectionGroup
                (mySQLConnectionGroup.getConnectionGroupID());

    public void move(String identifier, String groupIdentifier) 
            throws GuacamoleException {

        // Get connection
        MySQLConnectionGroup mySQLConnectionGroup =
                connectionGroupService.retrieveConnectionGroup(identifier, user_id);
        
        if(mySQLConnectionGroup == null)
            throw new GuacamoleException("Connection not found.");

        // Verify permission to update the connection
        permissionCheckService.verifyConnectionAccess(this.user_id,
                mySQLConnectionGroup.getConnectionGroupID(),
                MySQLConstants.CONNECTION_GROUP_UPDATE);
        
        // Verify permission to use the from connection group for organizational purposes
        permissionCheckService.verifyConnectionGroupUsageAccess
                (mySQLConnectionGroup.getParentID(), user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);

        // Verify permission to update the from connection group
        permissionCheckService.verifyConnectionGroupAccess(this.user_id,
                mySQLConnectionGroup.getParentID(), MySQLConstants.CONNECTION_GROUP_UPDATE);
        
        Integer toConnectionGroupID;
        if(groupIdentifier.equals(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER))
            toConnectionGroupID = null;
        try {
            toConnectionGroupID = Integer.valueOf(groupIdentifier);
        } catch(NumberFormatException e) {
            throw new GuacamoleException("Invalid connection group identifier.");
        }
        
        // Verify permission to use the to connection group for organizational purposes
        permissionCheckService.verifyConnectionGroupUsageAccess
                (toConnectionGroupID, user_id, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);

        // Verify permission to update the to connection group
        permissionCheckService.verifyConnectionGroupAccess(this.user_id,
                toConnectionGroupID, MySQLConstants.CONNECTION_GROUP_UPDATE);
        
        // Update the connection
        mySQLConnectionGroup.setParentID(toConnectionGroupID);
        connectionGroupService.updateConnectionGroup(mySQLConnectionGroup);

        connectionGroupDirectory.init(userID, parentID);
    
    /**
     * The identifier used to mark the root connection group.
     */
    public static final String CONNECTION_GROUP_ROOT_IDENTIFIER = "ROOT";
     * The string stored in the database to represent permission to create
     * connection groups.
     */
    public static final String SYSTEM_CONNECTION_GROUP_CREATE = "CREATE_CONNECTION_GROUP";

    /**
     * User directory restricted by the permissions of the user associated
     * with this context.
     */
    @Inject
    private MySQLConnectionGroup mySQLConnectionGroup;

    /**
        mySQLConnectionGroup.init(null, null, MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER, 
                MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER, 
                MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL, user_id);
        return mySQLConnectionGroup;
    @Override
    public void move(String identifier, String groupIdentifier) 
            throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied.");
    }


    /**
     * Retrieves the connection group having the given unique identifier 
     * from the database.
     *
     * @param uniqueIdentifier The unique identifier of the connection group to retrieve.
     * @param userID The ID of the user who queried this connection group.
     * @return The connection group having the given unique identifier, 
     *         or null if no such connection group was found.
     */
    public MySQLConnectionGroup retrieveConnectionGroup(String uniqueIdentifier, int userID) {

        // The unique identifier for a MySQLConnectionGroup is the database ID
        int connectionGroupID;
        try {
            connectionGroupID = Integer.parseInt(uniqueIdentifier);
        } catch(NumberFormatException e) {
            // Invalid number means it can't be a DB record; not found
            return null;
        }
        
        return retrieveConnectionGroup(connectionGroupID, userID);
    }

    /**
     * Creates a new connection group having the given name and protocol.
     *
     * @param name The name to assign to the new connection group.
     * @param userID The ID of the user who created this connection group.
     * @return A new MySQLConnectionGroup containing the data of the newly created
     *         connection group.
     */
    public MySQLConnectionGroup createConnectionGroup(String name, int userID) {

        // Initialize database connection
        ConnectionGroup connectionGroup = new ConnectionGroup();
        connectionGroup.setConnection_group_name(name);

        // Create connection
        connectionGroupDAO.insert(connectionGroup);
        return toMySQLConnectionGroup(connectionGroup, userID);

    }

    /**
     * Updates the connection group in the database corresponding to the given
     * MySQLConnectionGroup.
     *
     * @param mySQLConnectionGroup The MySQLConnectionGroup to update (save) 
     *                             to the database. 
     *                             This connection must already exist.
     */
    public void updateConnectionGroup(MySQLConnectionGroup mySQLConnectionGroup) {

        // Populate connection
        ConnectionGroup connectionGroup = new ConnectionGroup();
        connectionGroup.setConnection_group_id(mySQLConnectionGroup.getConnectionGroupID());
        connectionGroup.setParent_id(mySQLConnectionGroup.getParentID());
        connectionGroup.setConnection_group_name(mySQLConnectionGroup.getName());
        connectionGroup.setType(mySQLConnectionGroup.getType());

        // Update the connection in the database
        connectionGroupDAO.updateByPrimaryKeySelective(connectionGroup);

    }

    /**
     * Deletes the connection group having the given ID from the database.
     * @param id The ID of the connection group to delete.
     */
    public void deleteConnectionGroup(int id) {
        connectionGroupDAO.deleteByPrimaryKey(id);
    }
     * Retrieves the connection having the given unique identifier 
     * from the database.
     *
     * @param uniqueIdentifier The unique identifier of the connection to retrieve.
     * @param userID The ID of the user who queried this connection.
     * @return The connection having the given unique identifier, 
     *         or null if no such connection was found.
     */
    public MySQLConnection retrieveConnection(String uniqueIdentifier, int userID) {

        // The unique identifier for a MySQLConnection is the database ID
        int connectionID;
        try {
            connectionID = Integer.parseInt(uniqueIdentifier);
        } catch(NumberFormatException e) {
            // Invalid number means it can't be a DB record; not found
            return null;
        }
        
        return retrieveConnection(connectionID, userID);
    }

    /**
        connection.setParent_id(mySQLConnection.getParentID());
        connection.setConnection_name(mySQLConnection.getName());
        // All users have implicit permission to use the root group
        if(affectedConnectionGroupID == null)
            return true;
        
     * Retrieve all existing connection identifiers that the given user has 
     * permission to perform the given operation upon.
     * @return A set of all connection identifiers for which the given user 
     *         has the given permission.
    public Set<String> retrieveConnectionIdentifiers(int userID, Integer parentID,
        
        // Unique Identifiers for MySQLConnections are the database IDs
        Set<String> connectionIdentifiers = new HashSet<String>();
        
        for(Integer connectionID : connectionIDs)
            connectionIdentifiers.add(Integer.toString(connectionID));
        return connectionIdentifiers;
     * Retrieve all existing connection group identifiers that the given user 
     * has permission to perform the given operation upon.
     * @return A set of all connection group identifiers for which the given 
     *         user has the given permission.
    public Set<String> retrieveConnectionGroupIdentifiers(int userID, Integer parentID,
        
        // Unique Identifiers for MySQLConnectionGroups are the database IDs
        Set<String> connectionGroupIdentifiers = new HashSet<String>();
        
        for(Integer connectionGroupID : connectionGroupIDs)
            connectionGroupIdentifiers.add(Integer.toString(connectionGroupID));
        return connectionGroupIdentifiers;
    /**
     * Moves the object with the given identifier to the group with the given
     * group identifier.
     *
     * @param identifier The identifier of the object to remove.
     * @param groupIdentifier The identifier of the group to move the object to.
     *
     * @throws GuacamoleException If an error occurs while moving the object,
     *                            or if moving object is not allowed.
     */
    void move(IdentifierType identifier, IdentifierType groupIdentifier) 
            throws GuacamoleException;

    @Override
    public void move(String identifier, String groupIdentifier) 
            throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied.");
    }

    @Override
    public void move(String identifier, String groupIdentifier) 
            throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied.");
    }

    @Override
    public void move(String identifier, String groupIdentifier) 
            throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied.");
    }


        // Verify permission to delete
        permissionCheckService.verifyConnectionGroupAccess(this.userID,
                this.connectionGroupID,
                MySQLConstants.CONNECTION_GROUP_READ);
import net.sourceforge.guacamole.net.auth.mysql.MySQLConstants;
        
        switch(mySQLConnectionGroup.getType()) {
            case BALANCING :
                connectionGroup.setType(MySQLConstants.CONNECTION_GROUP_BALANCING);
                break;
            case ORGANIZATIONAL:
                connectionGroup.setType(MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
                break;
        }
    /**
     * The type of this connection group.
     */
    private ConnectionGroup.Type type;
    
    
    @Override
    public ConnectionGroup.Type getType() {
        return type;
    }
    
    @Override
    public void setType(ConnectionGroup.Type type) {
        this.type = type;
    }
    
    public enum Type {
        ORGANIZATIONAL, BALANCING
    };
     * Set the type of this ConnectionGroup.
     * @param type The type of this ConnectionGroup.
    public void setType(Type type);
     * Returns the type of this connection.
     * @return the type of this connection.
    public Type getType();
        this.setType(ConnectionGroup.Type.ORGANIZATIONAL);

        // Verify that no connection already exists with this name.
        MySQLConnection previousConnection =
                connectionService.retrieveConnection(mySQLConnection.getName(), user_id, parentID);
        if(previousConnection != null)
            throw new GuacamoleClientException("That connection name is already in use.");

        // Verify that no connection already exists with this name.
        MySQLConnectionGroup previousConnectionGroup =
                connectionGroupService.retrieveConnectionGroup(mySQLConnectionGroup.getName(), user_id, parentID);
        if(previousConnectionGroup != null)
            throw new GuacamoleClientException("That connection group name is already in use.");
import com.google.common.collect.Sets;
        Set<Integer> administerableConnectionIDs = Sets.<Integer>newHashSet(
                MySQLConstants.CONNECTION_ADMINISTER));
            Integer connection_id = Integer.valueOf(permission.getObjectIdentifier());
            if (!administerableConnectionIDs.contains(connection_id))
        Set<Integer> administerableConnectionGroupIDs = Sets.<Integer>newHashSet(
                MySQLConstants.CONNECTION_GROUP_ADMINISTER));
            Integer connection_group_id = Integer.valueOf(permission.getObjectIdentifier());
            if (!administerableConnectionGroupIDs.contains(connection_group_id))
        Set<Integer> administerableConnectionIDs = Sets.<Integer>newHashSet(
                MySQLConstants.CONNECTION_ADMINISTER));
            Integer connection_id = Integer.valueOf(permission.getObjectIdentifier());
            if (!administerableConnectionIDs.contains(connection_id))
        Set<Integer> administerableConnectionGroupIDs = Sets.<Integer>newHashSet(
                MySQLConstants.CONNECTION_GROUP_ADMINISTER));
            Integer connection_group_id = Integer.valueOf(permission.getObjectIdentifier());
            if (!administerableConnectionGroupIDs.contains(connection_group_id))
     * Get the identifiers of all the connection groups defined in the system 
     * with a certain parentID.
     *
     * @return A Set of identifiers of all the connection groups defined 
     * in the system with the given parentID.
     */
    public Set<String> getAllConnectionGroupIdentifiers(Integer parentID) {

        // Set of all present connection identifiers
        Set<String> identifiers = new HashSet<String>();
        
        // Set up Criteria
        ConnectionGroupExample example = new ConnectionGroupExample();
        Criteria criteria = example.createCriteria();
        if(parentID != null)
            criteria.andParent_idEqualTo(parentID);
        else
            criteria.andParent_idIsNull();

        // Query connection identifiers
        List<ConnectionGroup> connectionGroups =
                connectionGroupDAO.selectByExample(example);
        for (ConnectionGroup connectionGroup : connectionGroups)
            identifiers.add(String.valueOf(connectionGroup.getConnection_group_id()));

        return identifiers;

    }

    /**
     * Get the identifiers of all the connections defined in the system 
     * @return A Set of identifiers of all the connections defined in the system
    public Set<String> getAllConnectionIdentifiers(Integer parentID) {
        // Set of all present connection identifiers
        Set<String> identifiers = new HashSet<String>();
        // Query connection identifiers
            identifiers.add(String.valueOf(connection.getConnection_id()));
        return identifiers;
            return connectionService.getAllConnectionIdentifiers(parentID);
            return connectionGroupService.getAllConnectionGroupIdentifiers(parentID);
                String.valueOf(connectionPermission.getConnection_id())
                String.valueOf(connectionGroupPermission.getConnection_group_id())
                name, object.getConfiguration().getProtocol(), user_id, parentID);
                .createConnectionGroup(name, user_id, parentID);
    public MySQLConnectionGroup createConnectionGroup(String name, int userID, 
            Integer parentID) {
        connectionGroup.setParent_id(parentID);
     * @param parentID The ID of the parent connection group.
    public MySQLConnection createConnection(String name, String protocol,
            int userID, Integer parentID) {
        connection.setParent_id(parentID);
    private ActiveConnectionMap activeConnectionSet = new ActiveConnectionMap();
                    bind(ActiveConnectionMap.class).toInstance(activeConnectionSet);
     * Injected ActiveConnectionMap which will contain all active connections.
    private ActiveConnectionMap activeConnectionSet;
import net.sourceforge.guacamole.GuacamoleClientException;
import net.sourceforge.guacamole.GuacamoleException;
import net.sourceforge.guacamole.net.auth.mysql.ActiveConnectionMap;
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnection;
import net.sourceforge.guacamole.net.auth.mysql.properties.MySQLGuacamoleProperties;
import net.sourceforge.guacamole.properties.GuacamoleProperties;
     * Service for managing connections.
     */
    @Inject
    private ConnectionService connectionService;
    
    /**
    /**
     * The map of all active connections.
     */
    @Inject
    private ActiveConnectionMap activeConnectionMap;

    /**
     * Connect to the connection within the given group with the lowest number
     * of currently active users.
     *
     * @param connection The group to load balance across.
     * @param info The information to use when performing the connection
     *             handshake.
     * @param userID The ID of the user who is connecting to the socket.
     * @return The connected socket.
     * @throws GuacamoleException If an error occurs while connecting the
     *                            socket.
     */
            GuacamoleClientInformation info, int userID) throws GuacamoleException {
        
        // Get all connections in the group.
        List<Integer> connectionIDs = connectionService.getAllConnectionIDs
                (group.getConnectionGroupID());
        
        // Get the least used connection.
        Integer leastUsedConnectionID = 
                activeConnectionMap.getLeastUsedConnection(connectionIDs);
        
        if(leastUsedConnectionID == null)
            throw new GuacamoleException("No connections found in group.");
        
        if(GuacamoleProperties.getProperty(
                MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS, false)
                && activeConnectionMap.isActive(leastUsedConnectionID))
            throw new GuacamoleClientException
                    ("Cannot connect. All connections are in use.");
        
        // Get the connection 
        MySQLConnection connection = connectionService
                .retrieveConnection(leastUsedConnectionID, userID);
        
        // Connect to the connection
        return connectionService.connect(connection, info, userID);
import net.sourceforge.guacamole.net.auth.mysql.ActiveConnectionMap;
     * Map of all currently active connections.
    private ActiveConnectionMap activeConnectionMap;
                && activeConnectionMap.isActive(connection.getConnectionID()))
        int historyID = activeConnectionMap.openConnection(connection.getConnectionID(), userID);
    private ActiveConnectionMap activeConnectionMap = new ActiveConnectionMap();
                    bind(ActiveConnectionMap.class).toInstance(activeConnectionMap);
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupPermissionMapper;
                    addMapperClass(ConnectionGroupPermissionMapper.class);
            String identifier, ConnectionGroup.Type type, int userID) {
        setType(type);
    
     * The root connection group.
    private MySQLConnectionGroup rootConnectionGroup;
        rootConnectionGroup.init(null, null, 
                MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER, 
                ConnectionGroup.Type.ORGANIZATIONAL, user_id);
        return rootConnectionGroup;
        
        String mySqlType = connectionGroup.getType();
        net.sourceforge.guacamole.net.auth.ConnectionGroup.Type authType;
        
        if(mySqlType.equals(MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL))
            authType = net.sourceforge.guacamole.net.auth.ConnectionGroup.Type.ORGANIZATIONAL;
        else
            authType = net.sourceforge.guacamole.net.auth.ConnectionGroup.Type.BALANCING;
        
            authType,
     * @param connectionIDs The subset of connection IDs to find the least
     *                      used connection within.
        int minUserCount = Integer.MAX_VALUE;
        Integer minConnectionID = null;
            /*
             * If the connection is not found in the map, it has not been used,
             * and therefore will be count 0.
             */
                minUserCount = 0;
                minConnectionID = connectionID;
            // If this is the least active connection
            else if(connection.getCurrentUserCount() < minUserCount) {
                minUserCount = connection.getCurrentUserCount();
                minConnectionID = connection.getConnectionID();
            }
        return minConnectionID;
    public void move(String identifier, Directory<String, Connection> directory) 
        
        if(!(directory instanceof ConnectionDirectory))
            throw new GuacamoleException("Directory not from database");
        
        int toConnectionGroupID = ((ConnectionDirectory)directory).parentID;
        
     * The ID of the parent connection group.
    public void move(String identifier, Directory<String, ConnectionGroup> directory) 
        
        if(!(directory instanceof ConnectionGroupDirectory))
            throw new GuacamoleException("Directory not from database");
        
        int toConnectionGroupID = ((ConnectionGroupDirectory)directory).parentID;
     * The ID of the parent connection group for this connection.
    public ConnectionGroup getRootConnectionGroup() throws GuacamoleException {
import net.sourceforge.guacamole.net.auth.User;
public class UserDirectory implements Directory<String, User> {
    public void move(String identifier, Directory<String, User> groupIdentifier) 
     * Moves the object with the given identifier to the given directory.
     * @param directory The directory to move the object to.
    void move(IdentifierType identifier, Directory<IdentifierType, ObjectType> directory) 
    ConnectionGroup getRootConnectionGroup() throws GuacamoleException;
    public void move(String identifier, Directory<String, Connection> directory) 
    public void move(String identifier, Directory<String, ConnectionGroup> directory) 
    public ConnectionGroup getRootConnectionGroup() throws GuacamoleException {
    public void move(String identifier, Directory<String, User> directory) 
    public class Connection {
            Directory<String, Connection> directory =
                context.getRootConnectionGroup().getConnectionDirectory();
                context.getRootConnectionGroup().getConnectionDirectory();
                context.getRootConnectionGroup().getConnectionDirectory();
        Directory<String, Connection> directory =
                context.getRootConnectionGroup().getConnectionDirectory();
                context.getRootConnectionGroup().getConnectionDirectory();
        // Get name and protocol
        String name     = request.getParameter("name");
        connection.setName(name);
                xml.writeAttribute("name", connection.getName());
        // Get ID, name, and protocol
        String name       = request.getParameter("name");
        String protocol   = request.getParameter("protocol");
        connection.setName(name);
import java.util.Set;
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
     * System administration permission.
     */
    private static final Permission SYSTEM_PERMISSION = 
                new SystemPermission(SystemPermission.Type.ADMINISTER);

    
    /**
    /**
     * Writes the XML for the given connection group.
     * 
     * @param self The user whose permissions dictate the availability of the
     *             data written.
     * @param xml The XMLStremWriter to use when writing the data.
     * @param group The connection group whose XML representation will be
     *              written.
     * @throws GuacamoleException If an error occurs while reading the
     *                            requested data.
     * @throws XMLStreamException If an error occurs while writing the XML.
     */
    private void writeConnectionGroup(User self, XMLStreamWriter xml,
            ConnectionGroup group) throws GuacamoleException, XMLStreamException {

        // Write group 
        xml.writeStartElement("group");
        xml.writeAttribute("id", group.getIdentifier());
        xml.writeAttribute("name", group.getName());

        // Write group type
        switch (group.getType()) {

            case ORGANIZATIONAL:
                xml.writeAttribute("type", "organizational");
                break;

            case BALANCING:
                xml.writeAttribute("type", "balancing");
                break;

        }

        // Write contained groups and connections
        writeConnections(self, xml, group.getConnectionDirectory());
        writeConnectionGroups(self, xml, group.getConnectionGroupDirectory());

        // End of group
        xml.writeEndElement();

    }

    /**
     * Writes the XML for the given connection.
     * 
     * @param self The user whose permissions dictate the availability of the
     *             data written.
     * @param xml The XMLStremWriter to use when writing the data.
     * @param connection The connection whose XML representation will be
     *                   written.
     * @throws GuacamoleException If an error occurs while reading the
     *                            requested data.
     * @throws XMLStreamException If an error occurs while writing the XML.
     */
    private void writeConnection(User self, XMLStreamWriter xml,
            Connection connection) throws GuacamoleException, XMLStreamException {

        // Write connection
        xml.writeStartElement("connection");
        xml.writeAttribute("id", connection.getIdentifier());
        xml.writeAttribute("name", connection.getName());
        xml.writeAttribute("protocol",
                connection.getConfiguration().getProtocol());

        // If update permission available, include parameters
        if (self.hasPermission(SYSTEM_PERMISSION) ||
                hasConfigPermission(self, ObjectPermission.Type.UPDATE,
                connection.getIdentifier())) {

            // As update permission is present, also list parameters
            GuacamoleConfiguration config = connection.getConfiguration();
            for (String name : config.getParameterNames()) {

                String value = connection.getConfiguration().getParameter(name);
                xml.writeStartElement("param");
                xml.writeAttribute("name", name);

                if (value != null)
                    xml.writeCharacters(value);

                xml.writeEndElement();
            }

        }

        // Write history
        xml.writeStartElement("history");
        for (ConnectionRecord record : connection.getHistory()) {
            xml.writeStartElement("record");

            // Start date
            xml.writeAttribute("start",
                Long.toString(record.getStartDate().getTime()));

            // End date
            if (record.getEndDate() != null)
                xml.writeAttribute("end",
                    Long.toString(record.getEndDate().getTime()));

            // Whether connection currently active
            if (record.isActive())
                xml.writeAttribute("active", "yes");

            // User involved
            xml.writeCharacters(record.getUsername());

            xml.writeEndElement();
        }
        xml.writeEndElement();

        // End connection
        xml.writeEndElement();
        
    }

    /**
     * Writes the XML for the given directory of connection groups.
     * 
     * @param self The user whose permissions dictate the availability of the
     *             data written.
     * @param xml The XMLStremWriter to use when writing the data.
     * @param directory The directory whose XML representation will be
     *                  written.
     * @throws GuacamoleException If an error occurs while reading the
     *                            requested data.
     * @throws XMLStreamException If an error occurs while writing the XML.
     */
    private void writeConnectionGroups(User self, XMLStreamWriter xml,
            Directory<String, ConnectionGroup> directory)
            throws GuacamoleException, XMLStreamException {

        // If no connections, write nothing
        Set<String> identifiers = directory.getIdentifiers();
        if (identifiers.isEmpty())
            return;
        
        // Begin connections
        xml.writeStartElement("groups");

        // For each entry, write corresponding connection element
        for (String identifier : identifiers) {

            // Write each group
            ConnectionGroup group = directory.get(identifier);
            writeConnectionGroup(self, xml, group);

        }

        // End connections
        xml.writeEndElement();

    }

    /**
     * Writes the XML for the given directory of connections.
     * 
     * @param self The user whose permissions dictate the availability of the
     *             data written.
     * @param xml The XMLStremWriter to use when writing the data.
     * @param directory The directory whose XML representation will be
     *                  written.
     * @throws GuacamoleException If an error occurs while reading the
     *                            requested data.
     * @throws XMLStreamException If an error occurs while writing the XML.
     */
    private void writeConnections(User self, XMLStreamWriter xml,
            Directory<String, Connection> directory)
            throws GuacamoleException, XMLStreamException {

        // If no connections, write nothing
        Set<String> identifiers = directory.getIdentifiers();
        if (identifiers.isEmpty())
            return;
        
        // Begin connections
        xml.writeStartElement("connections");

        // For each entry, write corresponding connection element
        for (String identifier : identifiers) {

            // Write each connection
            Connection connection = directory.get(identifier);
            writeConnection(self, xml, connection);

        }

        // End connections
        xml.writeEndElement();

    }

        // Get root group
        ConnectionGroup root = context.getRootConnectionGroup();
            // Write content of root group
            writeConnectionGroup(self, xml, root);
        connectionDirectory.init(userID, connectionGroupID);
        connectionGroupDirectory.init(userID, connectionGroupID);
                connectionService.retrieveConnection(name, parentID, user_id);
                connectionService.retrieveConnection(mySQLConnection.getName(), parentID, user_id);
                connectionGroupService.retrieveConnectionGroup(name, parentID, user_id);
                connectionGroupService.retrieveConnectionGroup(mySQLConnectionGroup.getName(), parentID, user_id);
import java.util.Collections;
    public void verifyConnectionGroupAccess(int userID, Integer affectedConnectionGroupID, String permissionType) throws GuacamoleSecurityException {
            
            if(allConnectionIDs.isEmpty())
                return Collections.EMPTY_LIST;
            
            
            if(allConnectionGroupIDs.isEmpty())
                return Collections.EMPTY_LIST;
            
            criteria.andParent_idEqualTo(parentID);
            criteria.andParent_idIsNull();
            criteria.andParent_idEqualTo(parentID);
            criteria.andParent_idIsNull();
            case CREATE_USER:             return SYSTEM_USER_CREATE;
            case CREATE_CONNECTION:       return SYSTEM_CONNECTION_CREATE;
            case CREATE_CONNECTION_GROUP: return SYSTEM_CONNECTION_GROUP_CREATE;
            case ADMINISTER:              return SYSTEM_ADMINISTER;
            // System creation permission
            else if(systemPermission.getPermission().equals(MySQLConstants.SYSTEM_CONNECTION_GROUP_CREATE))
                permissions.add(new SystemPermission(SystemPermission.Type.CREATE_CONNECTION_GROUP));

         * Create connection groups.
         */
        CREATE_CONNECTION_GROUP,

        /**
            newPermission.setPermission(MySQLConstants.getConnectionGroupConstant(permission.getType()));
        
        // Get the ID of the parent connection group
        String parentID = request.getParameter("parentID");
        // Find the correct connection directory
        Directory<String, Connection> directory = 
                ConnectionUtility.findConnectionDirectory(context, parentID);
        
        if(directory == null)
            throw new GuacamoleException("Connection directory not found.");
        throw new UnsupportedOperationException("Connection unsupported in DummyConnection.");
        throw new UnsupportedOperationException("History unsupported in DummyConnection.");
import net.sourceforge.guacamole.net.auth.permission.ConnectionGroupPermission;
            case CREATE_USER:             return "create-user";
            case CREATE_CONNECTION:       return "create-connection";
            case CREATE_CONNECTION_GROUP: return "create-connection-group";
            case ADMINISTER:              return "admin";
                // Connection group permission
                else if (permission instanceof ConnectionGroupPermission) {

                    // Get permission
                    ConnectionGroupPermission cgp =
                            (ConnectionGroupPermission) permission;

                    // Write permission
                    xml.writeEmptyElement("connection-group");
                    xml.writeAttribute("type", toString(cgp.getType()));
                    xml.writeAttribute("name", cgp.getObjectIdentifier());

                }

        // Get name and type
        String type     = request.getParameter("type");
        
        if("balancing".equals(type))
            connectionGroup.setType(ConnectionGroup.Type.BALANCING);
        else if("organizational".equals(type))
            connectionGroup.setType(ConnectionGroup.Type.ORGANIZATIONAL);
        // Get ID, name, and type
        String type       = request.getParameter("type");
        
        if("balancing".equals(type))
            connectionGroup.setType(ConnectionGroup.Type.BALANCING);
        else if("organizational".equals(type))
            connectionGroup.setType(ConnectionGroup.Type.ORGANIZATIONAL);
import net.sourceforge.guacamole.net.auth.ConnectionGroup.Type;
import net.sourceforge.guacamole.net.auth.permission.ObjectPermission;
        Type type = object.getType();
        
        String mySQLType = MySQLConstants.getConnectionGroupTypeConstant(type);
        
                .createConnectionGroup(name, user_id, parentID, mySQLType);
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
     * Given the type of a connection group, returns the MySQL constant
     * representing that type.
     *
     * @param type The connection group type to look up.
     * @return The MySQL constant corresponding to the given type.
     */
    public static String getConnectionGroupTypeConstant(ConnectionGroup.Type type) {

        // Convert permission type to MySQL constant
        switch (type) {
            case ORGANIZATIONAL: return CONNECTION_GROUP_ORGANIZATIONAL;
            case BALANCING:      return CONNECTION_GROUP_BALANCING;
        }

        // If we get here, permission support was not properly implemented
        throw new UnsupportedOperationException(
            "Unsupported connection group type: "  type);

    }

    /**
    public MySQLConnectionGroup retrieveConnectionGroup(String uniqueIdentifier, 
            int userID) throws GuacamoleException {
        Integer connectionGroupID = null;
        
        // Try to parse the connectionID if it's not the root group
        if(!MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER.equals(uniqueIdentifier)) {
            try {
                connectionGroupID = Integer.parseInt(uniqueIdentifier);
            } catch(NumberFormatException e) {
                throw new GuacamoleException("Invalid connection group ID.");
            }
    public MySQLConnectionGroup retrieveConnectionGroup(Integer id, int userID) {
        // This is the root connection group, so just create it here
        if(id == null) {
            MySQLConnectionGroup connectionGroup = mysqlConnectionGroupProvider.get();
            connectionGroup.init(null, null, 
                    MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER, 
                    MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER, 
                    net.sourceforge.guacamole.net.auth.ConnectionGroup.Type.BALANCING, 
                    userID);
            
            return connectionGroup;
        }
        
     * @param Type The type of the new connection group.
            Integer parentID, String type) {
        connectionGroup.setType(type);
                    net.sourceforge.guacamole.net.auth.ConnectionGroup.Type.ORGANIZATIONAL, 
                connectionService.retrieveConnection(mySQLConnection.getName(), 
                toConnectionGroupID, user_id);
                connectionGroupService.retrieveConnectionGroup(mySQLConnectionGroup.getName(), 
                toConnectionGroupID, user_id);
        if (str.equals(CREATE_USER_PERMISSION))
        if (str.equals(CREATE_CONNECTION_PERMISSION))
        if (str.equals(ADMIN_PERMISSION))
import net.sourceforge.guacamole.net.auth.permission.ConnectionGroupPermission;
     * String given for connection group creation permission.
     */
    private static final String CREATE_CONNECTION_GROUP_PERMISSION = "create-connection-group";

    /**
    /**
     * Given a permission string, returns the corresponding connection group
     * permission.
     *
     * @param str The permission string to parse.
     * @return The parsed connection group permission.
     * @throws GuacamoleException If the given string could not be parsed.
     */
    private Permission parseConnectionGroupPermission(String str)
            throws GuacamoleException {

        // Read
        if (str.startsWith(READ_PREFIX))
            return new ConnectionGroupPermission(ObjectPermission.Type.READ,
                    str.substring(READ_PREFIX.length()));

        // Update
        if (str.startsWith(UPDATE_PREFIX))
            return new ConnectionGroupPermission(ObjectPermission.Type.UPDATE,
                    str.substring(UPDATE_PREFIX.length()));

        // Delete
        if (str.startsWith(DELETE_PREFIX))
            return new ConnectionGroupPermission(ObjectPermission.Type.DELETE,
                    str.substring(DELETE_PREFIX.length()));

        // Administration
        if (str.startsWith(ADMIN_PREFIX))
            return new ConnectionGroupPermission(ObjectPermission.Type.ADMINISTER,
                    str.substring(ADMIN_PREFIX.length()));

        throw new GuacamoleClientException("Invalid permission string.");

    }

        // Set added connection group permissions
        String[] add_connection_group_permission = request.getParameterValues("connection-group");
        if (add_connection_group_permission != null) {
            for (String str : add_connection_group_permission)
                user.addPermission(parseConnectionGroupPermission(str));
        }

        // Unset removed connection group permissions
        String[] remove_connection_group_permission = request.getParameterValues("-connection-group");
        if (remove_connection_group_permission != null) {
            for (String str : remove_connection_group_permission)
                user.removePermission(parseConnectionGroupPermission(str));
        }

        // Create connection group
        if (str.equals(CREATE_CONNECTION_GROUP_PERMISSION))
            return new SystemPermission(SystemPermission.Type.CREATE_CONNECTION_GROUP);

import net.sourceforge.guacamole.GuacamoleClientException;
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
    /**
     * All supported identifier types.
     */
    private static enum IdentifierType {

        /**
         * The unique identifier of a connection.
         */
        CONNECTION("c/"),

        /**
         * The unique identifier of a connection group.
         */
        CONNECTION_GROUP("g/");
        
        /**
         * The prefix which precedes an identifier of this type.
         */
        final String PREFIX;
        
        /**
         * Defines an IdentifierType having the given prefix.
         * @param prefix The prefix which will precede any identifier of this
         *               type, thus differentiating it from other identifier
         *               types.
         */
        IdentifierType(String prefix) {
            PREFIX = prefix;
        }

        /**
         * Given an identifier, determines the corresponding identifier type.
         * 
         * @param identifier The identifier whose type should be identified.
         * @return The identified identifier type.
         */
        static IdentifierType getType(String identifier) {

            // If null, no known identifier
            if (identifier == null)
                return null;

            // Connection identifiers
            if (identifier.startsWith(CONNECTION.PREFIX))
                return CONNECTION;
            
            // Connection group identifiers
            if (identifier.startsWith(CONNECTION_GROUP.PREFIX))
                return CONNECTION_GROUP;
            
            // Otherwise, unknown
            return null;
            
        }
        
    };
    
            IdentifierType id_type = IdentifierType.getType(id);

            // Do not continue if unable to determine type
            if (id_type == null)
                throw new GuacamoleClientException("Illegal identifier - unknown type.");

            // Remove prefix
            id = id.substring(id_type.PREFIX.length());
            // Create connected socket from identifier
            GuacamoleSocket socket;
            switch (id_type) {

                // Connection identifiers
                case CONNECTION: {

                    // Get connection directory
                    Directory<String, Connection> directory =
                        context.getRootConnectionGroup().getConnectionDirectory();

                    // Get authorized connection
                    Connection connection = directory.get(id);
                    if (connection == null) {
                        logger.warn("Connection id={} not found.", id);
                        throw new GuacamoleSecurityException("Requested connection is not authorized.");
                    }

                    // Connect socket
                    socket = connection.connect(info);
                    logger.info("Successful connection from {} to \"{}\".", request.getRemoteAddr(), id);
                    break;
                }

                // Connection group identifiers
                case CONNECTION_GROUP: {

                    // Get connection group directory
                    Directory<String, ConnectionGroup> directory =
                        context.getRootConnectionGroup().getConnectionGroupDirectory();

                    // Get authorized connection group
                    ConnectionGroup group = directory.get(id);
                    if (group == null) {
                        logger.warn("Connection group id={} not found.", id);
                        throw new GuacamoleSecurityException("Requested connection group is not authorized.");
                    }

                    // Connect socket
                    socket = group.connect(info);
                    logger.info("Successful connection from {} to group \"{}\".", request.getRemoteAddr(), id);
                    break;
                }

                // Fail if unsupported type
                default:
                    throw new GuacamoleClientException("Connection not supported for provided identifier type.");

            }
        // A connection group administrator can use the group either way.
        if(checkConnectionGroupAccess(userID, connectionGroupID,
                MySQLConstants.CONNECTION_GROUP_ADMINISTER))
            return true;
        
import net.sourceforge.guacamole.GuacamoleClientException;
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
    /**
     * All supported identifier types.
     */
    private static enum IdentifierType {

        /**
         * The unique identifier of a connection.
         */
        CONNECTION("c/"),

        /**
         * The unique identifier of a connection group.
         */
        CONNECTION_GROUP("g/");
        
        /**
         * The prefix which precedes an identifier of this type.
         */
        final String PREFIX;
        
        /**
         * Defines an IdentifierType having the given prefix.
         * @param prefix The prefix which will precede any identifier of this
         *               type, thus differentiating it from other identifier
         *               types.
         */
        IdentifierType(String prefix) {
            PREFIX = prefix;
        }

        /**
         * Given an identifier, determines the corresponding identifier type.
         * 
         * @param identifier The identifier whose type should be identified.
         * @return The identified identifier type.
         */
        static IdentifierType getType(String identifier) {

            // If null, no known identifier
            if (identifier == null)
                return null;

            // Connection identifiers
            if (identifier.startsWith(CONNECTION.PREFIX))
                return CONNECTION;
            
            // Connection group identifiers
            if (identifier.startsWith(CONNECTION_GROUP.PREFIX))
                return CONNECTION_GROUP;
            
            // Otherwise, unknown
            return null;
            
        }
        
    };
    
            IdentifierType id_type = IdentifierType.getType(id);

            // Do not continue if unable to determine type
            if (id_type == null)
                throw new GuacamoleClientException("Illegal identifier - unknown type.");

            // Remove prefix
            id = id.substring(id_type.PREFIX.length());
            // Create connected socket from identifier
            GuacamoleSocket socket;
            switch (id_type) {

                // Connection identifiers
                case CONNECTION: {

                    // Get connection directory
                    Directory<String, Connection> directory =
                        context.getRootConnectionGroup().getConnectionDirectory();

                    // Get authorized connection
                    Connection connection = directory.get(id);
                    if (connection == null) {
                        logger.warn("Connection id={} not found.", id);
                        throw new GuacamoleSecurityException("Requested connection is not authorized.");
                    }

                    // Connect socket
                    socket = connection.connect(info);
                    logger.info("Successful connection from {} to \"{}\".", request.getRemoteAddr(), id);
                    break;
                }

                // Connection group identifiers
                case CONNECTION_GROUP: {

                    // Get connection group directory
                    Directory<String, ConnectionGroup> directory =
                        context.getRootConnectionGroup().getConnectionGroupDirectory();

                    // Get authorized connection group
                    ConnectionGroup group = directory.get(id);
                    if (group == null) {
                        logger.warn("Connection group id={} not found.", id);
                        throw new GuacamoleSecurityException("Requested connection group is not authorized.");
                    }

                    // Connect socket
                    socket = group.connect(info);
                    logger.info("Successful connection from {} to group \"{}\".", request.getRemoteAddr(), id);
                    break;
                }

                // Fail if unsupported type
                default:
                    throw new GuacamoleClientException("Connection not supported for provided identifier type.");

            }
        return MySQLConstants.getConnectionGroupTypeConstant(
                connectionGroup.getType()).equals(usage);
import net.sourceforge.guacamole.net.auth.permission.ConnectionGroupPermission;
        Permission group_admin_permission = new ConnectionGroupPermission(
                ObjectPermission.Type.ADMINISTER, group.getIdentifier());

        // Attempt to list contained groups and connections ONLY if the group
        // is organizational or we have admin rights to it
        if (group.getType() == ConnectionGroup.Type.ORGANIZATIONAL
                || self.hasPermission(SYSTEM_PERMISSION)
                || self.hasPermission(group_admin_permission)) {
            writeConnections(self, xml, group.getConnectionDirectory());
            writeConnectionGroups(self, xml, group.getConnectionGroupDirectory());
        }
     * Set the user and relativeParentID for this directory.
     * @param relativeParentID The ID of the parent connection group.
        if(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER.equals(identifier))
            throw new GuacamoleException("The root connection group cannot be moved.");
        
        // Get connection group
            throw new GuacamoleException("Connection group not found.");
        // Verify that moving this connectionGroup would not cause a cycle
        Integer relativeParentID = toConnectionGroupID;
        while(relativeParentID != null) {
            if(relativeParentID == mySQLConnectionGroup.getConnectionGroupID())
                throw new GuacamoleException("Connection group cycle detected.");
            
            MySQLConnectionGroup relativeParentGroup = connectionGroupService.
                    retrieveConnectionGroup(relativeParentID, user_id);
            
            relativeParentID = relativeParentGroup.getParentID();
        }
        
            throw new GuacamoleClientException("Directory not from database");
        Integer toConnectionGroupID = ((ConnectionDirectory)directory).parentID;
            throw new GuacamoleClientException("Connection not found.");
            throw new GuacamoleClientException("The root connection group cannot be moved.");
            throw new GuacamoleClientException("Directory not from database");
        Integer toConnectionGroupID = ((ConnectionGroupDirectory)directory).parentID;
            throw new GuacamoleClientException("Connection group not found.");
                throw new GuacamoleClientException("Connection group cycle detected.");
        // Update the connection group in the database
        connectionGroupDAO.updateByPrimaryKey(connectionGroup);
        connectionDAO.updateByPrimaryKey(connection);
     * Set the user and parentID for this directory.
     * @param parentID The ID of the parent connection group.
        
        // All users have implicit access to read and update the root group
        if(MySQLConstants.CONNECTION_GROUP_READ.equals(permissionType)
                && MySQLConstants.CONNECTION_GROUP_UPDATE.equals(permissionType)
                && !checkParentID)
            connectionGroupIDs.add(null);
        
        // All users have implict access to read the root connection group
        permissions.add(new ConnectionGroupPermission(
            ConnectionGroupPermission.Type.READ,
            MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER
        ));
        
        // All users have implict access to update the root connection group
        permissions.add(new ConnectionGroupPermission(
            ConnectionGroupPermission.Type.UPDATE,
            MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER
        ));
        // All users have implicit permission to read and update the root connection group
        if(affectedConnectionGroupID == null && 
                MySQLConstants.CONNECTION_GROUP_READ.equals(permissionType) ||
                MySQLConstants.CONNECTION_GROUP_UPDATE.equals(permissionType))
    
    /*
     * Represents a user connected to a connection or BALANCING connection group.
     */
    public class ConnectionUser {
        /**
         * The ID of the connection or connection group that this ConnectionUser refers to.
         */
        private int connectionID; 
        
        /**
         * The user that this ConnectionUser refers to.
         */
        private int userID;

        /**
         * Returns ID of the connection or connection group that this ConnectionUser refers to.
         * @return ID of the connection or connection group that this ConnectionUser refers to.
         */
        public int getConnectionGroupID() {
            return connectionID;
        }

        /**
         * Returns the user ID that this ConnectionUser refers to.
         * @return the user ID that this ConnectionUser refers to.
         */
        public int getUserID() {
            return userID;
        }
        
        /**
         * Create a ConnectionUser with the given connection or connection group
         * ID and user ID.
         * 
         * @param connectionID The connection or connection group ID that this 
         *                          ConnectionUser refers to.
         * @param userID The user ID that this ConnectionUser refers to.
         */
        public ConnectionUser(int connectionID, int userID) {
            this.connectionID = connectionID;
            this.userID = userID;
        }
        
        @Override
        public boolean equals(Object other) {
            
            // Only another ConnectionUser can equal this ConnectionUser
            if(!(other instanceof ConnectionUser))
                return false;
            
            ConnectionUser otherConnectionGroupUser = 
                    (ConnectionUser)other;
            
            /* 
             * Two ConnectionGroupUsers are equal iff they represent the exact 
             * same pairing of connection or connection group and user.
             */
            return this.connectionID == otherConnectionGroupUser.connectionID
                    && this.userID == otherConnectionGroupUser.userID;
        }

        @Override
        public int hashCode() {
            int hash = 3;
            hash = 23 * hash  this.connectionID;
            hash = 23 * hash  this.userID;
            return hash;
        }
    }
     * Map of all the connections that are currently active to the

    /**
     * Map of all the connection group users to the count of current usages.
     */
    private Map<ConnectionUser, Integer> activeConnectionGroupUserMap =
            new HashMap<ConnectionUser, Integer>();

    /**
     * Map of all the connection users to the count of current usages.
     */
    private Map<ConnectionUser, Integer> activeConnectionUserMap =
            new HashMap<ConnectionUser, Integer>();
    
    /**
     * Returns the number of connectionGroups opened by the given user using 
     * the given ConnectionGroup.
     * 
     * @param connectionID The connection group ID that this 
     *                          ConnectionUser refers to.
     * @param userID The user ID that this ConnectionUser refers to.
     * 
     * @return The number of connections opened by the given user to the given
     *         ConnectionGroup.
     */
    public int getConnectionGroupUserCount(int connectionGroupID, int userID) {
        Integer count = activeConnectionGroupUserMap.get
                (new ConnectionUser(connectionGroupID, userID));
        
        // No ConnectionUser found means this combination was never used
        if(count == null)
            return 0;
        
        return count;
    }
    
    /**
     * Checks if the given user is currently connected to the given BALANCING
     * connection group.
     * 
     * @param connectionGroupID The connection group ID that this 
     *                          ConnectionUser refers to.
     * @param userID The user ID that this ConnectionUser refers to.
     * 
     * @return True if the given user is currently connected to the given 
     *         BALANCING connection group, false otherwise.
     */
    public boolean isConnectionGroupUserActive(int connectionGroupID, int userID) {
        Integer count = activeConnectionGroupUserMap.get
                (new ConnectionUser(connectionGroupID, userID));
        
        // The connection group is in use if the ConnectionUser count > 0
        return count != null && count > 0;
    }
    
    /**
     * Increment the count of the number of connections opened by the given user
     * to the given ConnectionGroup.
     * 
     * @param connectionGroupID The connection group ID that this 
     *                          ConnectionUser refers to.
     * @param userID The user ID that this ConnectionUser refers to.
     */
    private void incrementConnectionGroupUserCount(int connectionGroupID, int userID) {
        int currentCount = getConnectionGroupUserCount(connectionGroupID, userID);
        
        activeConnectionGroupUserMap.put
                (new ConnectionUser(connectionGroupID, userID), currentCount  1);
    }
    
    /**
     * Decrement the count of the number of connections opened by the given user
     * to the given ConnectionGroup.
     * 
     * @param connectionGroupID The connection group ID that this 
     *                          ConnectionUser refers to.
     * @param userID The user ID that this ConnectionUser refers to.
     */
    private void decrementConnectionGroupUserCount(int connectionGroupID, int userID) {
        int currentCount = getConnectionGroupUserCount(connectionGroupID, userID);
        
        activeConnectionGroupUserMap.put
                (new ConnectionUser(connectionGroupID, userID), currentCount - 1);
    }
    
    /**
     * Returns the number of connections opened by the given user using 
     * the given Connection.
     * 
     * @param connectionID The connection ID that this ConnectionUser refers to.
     * @param userID The user ID that this ConnectionUser refers to.
     * 
     * @return The number of connections opened by the given user to the given
     *         connection.
     */
    public int getConnectionUserCount(int connectionID, int userID) {
        Integer count = activeConnectionUserMap.get
                (new ConnectionUser(connectionID, userID));
        
        // No ConnectionUser found means this combination was never used
        if(count == null)
            return 0;
        
        return count;
    }
    
    /**
     * Checks if the given user is currently connected to the given connection.
     * 
     * @param connectionID The connection ID that this ConnectionUser refers to.
     * @param userID The user ID that this ConnectionUser refers to.
     * 
     * @return True if the given user is currently connected to the given 
     *         connection, false otherwise.
     */
    public boolean isConnectionUserActive(int connectionID, int userID) {
        Integer count = activeConnectionUserMap.get
                (new ConnectionUser(connectionID, userID));
        
        // The connection is in use if the ConnectionUser count > 0
        return count != null && count > 0;
    }
    
    /**
     * Increment the count of the number of connections opened by the given user
     * to the given Connection.
     * 
     * @param connectionID The connection ID that this ConnectionUser refers to.
     * @param userID The user ID that this ConnectionUser refers to.
     */
    private void incrementConnectionUserCount(int connectionID, int userID) {
        int currentCount = getConnectionGroupUserCount(connectionID, userID);
        
        activeConnectionUserMap.put
                (new ConnectionUser(connectionID, userID), currentCount  1);
    }
    
    /**
     * Decrement the count of the number of connections opened by the given user
     * to the given Connection.
     * 
     * @param connectionID The connection ID that this ConnectionUser refers to.
     * @param userID The user ID that this ConnectionUser refers to.
     */
    private void decrementConnectionUserCount(int connectionID, int userID) {
        int currentCount = getConnectionGroupUserCount(connectionID, userID);
        
        activeConnectionUserMap.put
                (new ConnectionUser(connectionID, userID), currentCount - 1);
    }
     * @param connectionID The ID of the BALANCING connection group that is
     *                          being connected to; null if not used.
    public int openConnection(int connectionID, int userID, Integer connectionGroupID) {
        
        // Increment the connection user count
        incrementConnectionUserCount(connectionID, userID);
        
        // If this is a connection to a BALANCING ConnectionGroup, increment the count
        if(connectionGroupID != null)
            incrementConnectionGroupUserCount(connectionGroupID, userID);
     * @param userID The ID of the user who is opening the connection.
     * @param connectionID The ID of the BALANCING connection group that is
     *                          being connected to; null if not used.
    public void closeConnection(int connectionID, int userID, int historyID, 
            Integer connectionGroupID) throws GuacamoleException {
        
        // Decrement the connection user count
        decrementConnectionUserCount(connectionID, userID);
        
        // If this is a connection to a BALANCING ConnectionGroup, decrement the count
        if(connectionGroupID != null)
            decrementConnectionGroupUserCount(connectionGroupID, userID);
        return connectionService.connect(this, info, userID, null);
     * The ID of the user who is connecting to the socket.
     */
    private int userID;

    /**
     * The ID of the balancing connection group that is being connected to; 
     * null if not used.
     */
    private Integer connectionGroupID;

    /**
     * @param userID The ID of the user who is connecting to the socket.
     * @param connectionGroupID The ID of the balancing connection group that is
     *                          being connected to; null if not used.
    public void init(GuacamoleSocket socket, int connectionID, int userID, 
            int historyID, Integer connectionGroupID) {
        this.userID = userID;
        this.connectionGroupID = connectionGroupID;
        activeConnectionSet.closeConnection(connectionID, userID, 
                historyID, connectionGroupID);

    /**
     * Whether or not the same user accessing the same connection or connection group at the same time should be disallowed.
     */
    public static final BooleanGuacamoleProperty MYSQL_DISALLOW_DUPLICATE_CONNECTIONS = new BooleanGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-disallow-duplicate-connections"; }

    };
    
    
        if(GuacamoleProperties.getProperty(
                MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS, true)
                && activeConnectionMap.isConnectionGroupUserActive(group.getConnectionGroupID(), userID))
            throw new GuacamoleClientException
                    ("Cannot connect. Connection group already in use by this user.");
        
        return connectionService.connect(connection, info, userID, group.getConnectionGroupID());
    
    
     * @param connectionGroupID The ID of the balancing connection group that is
     *                          being connected to; null if not used.
            GuacamoleClientInformation info, int userID, Integer connectionGroupID)
        
        if(GuacamoleProperties.getProperty(
                MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS, true)
                && activeConnectionMap.isConnectionUserActive(connection.getConnectionID(), userID))
            throw new GuacamoleClientException
                    ("Cannot connect. Connection already in use by this user.");
        int historyID = activeConnectionMap.openConnection(connection.getConnectionID(), 
                userID, connectionGroupID);
        mySQLGuacamoleSocket.init(socket, connection.getConnectionID(), userID, 
                historyID, connectionGroupID);
        
        private int identifier; 
        public int getIdentifier() {
            return identifier;
         * @param identifier The connection or connection group ID that this 
         *                   ConnectionUser refers to.
        public ConnectionUser(int identifier, int userID) {
            this.identifier = identifier;
            return this.identifier == otherConnectionGroupUser.identifier
            hash = 23 * hash  this.identifier;
     * Returns the number of connections opened by the given user using 
     * @param connectionGroupID The connection group ID that this 
     * @param connectionGroupID The ID of the BALANCING connection group that is
     * @param connectionGroupID The ID of the BALANCING connection group that is
    public void closeConnection(int historyID, Integer connectionGroupID) 
            throws GuacamoleException {
        
        // Get the connection and user IDs
        int connectionID = connectionHistory.getConnection_id();
        int userID = connectionHistory.getUser_id();
        activeConnectionSet.closeConnection(historyID, connectionGroupID);
        String host = GuacamoleProperties.getRequiredProperty(GuacamoleProperties.GUACD_HOSTNAME);
        int port = GuacamoleProperties.getRequiredProperty(GuacamoleProperties.GUACD_PORT);
        
        if(connections.containsKey(connection.getIdentifier()))
            throw new GuacamoleException("Connection identifier already present.");
        
        connections.put(connection.getIdentifier(), connection);
        
        if(!connections.containsKey(connection.getIdentifier()))
            throw new GuacamoleException("Connection not found.");
        
        connections.put(connection.getIdentifier(), connection);
        
        if(!connections.containsKey(identifier))
            throw new GuacamoleException("Connection not found.");
        
        connections.remove(identifier);
        throw new GuacamoleSecurityException("Permission denied.");
        throw new GuacamoleSecurityException("Permission denied.");
        throw new GuacamoleSecurityException("Permission denied.");
    
    /**
     * An internal method for modifying the Connections in this Directory.
     * Returns the previous connection for the given identifier, if found.
     * 
     * @param connection The connection to add or update the Directory with.
     * @return The previous connection for the connection identifier, if found.
     */
    public Connection putConnection(Connection connection) {
        return connections.put(connection.getIdentifier(), connection);
    }
    
    /**
     * An internal method for removing a Connection from this Directory.
     * @param identifier The identifier of the Connection to remove.
     * @return The previous connection for the given identifier, if found.
     */
    public Connection removeConnection(String identifier) {
        return connections.remove(identifier);
    }
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

    /**
     * Logger for this class.
     */
    private Logger logger = LoggerFactory.getLogger(LDAPAuthenticationProvider.class);
    
                logger.info("Anonymous bind is not currently allowed by the LDAP authentication provider.");
                logger.info("Anonymous bind is not currently allowed by the LDAP authentication provider.");













 *
            String user_dn =
            // Bind as user
                        credentials.getPassword().getBytes("UTF-8")
                // Get CN
 *

    /**
     * Underlying connection directory, containing all connections within this
     * group.
     */

    /**
     * Underlying connection group directory, containing all connections within
     * this group.
     */
    /**
     * Creates a new SimpleConnectionGroup having the given name and identifier
     * which will expose the given directories as its contents.
     * 
     * @param name The name to associate with this connection.
     * @param identifier The identifier to associate with this connection.
     * @param connectionDirectory The connection directory to expose when
     *                            requested.
     * @param connectionGroupDirectory The connection group directory to expose
     *                                 when requested.
     */
    public SimpleConnectionGroup(String name, String identifier,
            Directory<String, Connection> connectionDirectory, 

        // Set name
        setName(name);

        // Set identifier
        setIdentifier(identifier);
        
        // Set group type
        setType(ConnectionGroup.Type.ORGANIZATIONAL);

        // Assign directories

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
 * ConnectionGroup which provides which provides access to a pre-defined
 * Collection of ConnectionGroups.

     * The Map of ConnectionGroups to provide access to.
     */
    private Map<String, ConnectionGroup> connectionGroups =
            new HashMap<String, ConnectionGroup>();

    /**
     * Creates a new SimpleConnectionGroupDirectory which contains the given
     * groups.
     * 
     * @param groups A Collection of all groups that should be present in this
     *               connection group directory.
     */
    public SimpleConnectionGroupDirectory(Collection<ConnectionGroup> groups) {

        // Add all given groups
        for (ConnectionGroup group : groups)
            connectionGroups.put(group.getIdentifier(), group);

    }
        return connectionGroups.get(identifier);
        return connectionGroups.keySet();
    /**
     * An internal method for modifying the ConnectionGroups in this Directory.
     * Returns the previous connection group for the given identifier, if found.
     * 
     * @param connectionGroup The connection group to add or update the
     *                        Directory with.
     * @return The previous connection group for the connection group
     *         identifier, if found.
     */
    public ConnectionGroup putConnectionGroup(ConnectionGroup connectionGroup) {
        return connectionGroups.put(connectionGroup.getIdentifier(), connectionGroup);
    }
    
    /**
     * An internal method for removing a ConnectionGroup from this Directory.
     * 
     * @param identifier The identifier of the ConnectionGroup to remove.
     * @return The previous connection group for the given identifier, if found.
     */
    public ConnectionGroup removeConnectionGroup(String identifier) {
        return connectionGroups.remove(identifier);
    }

import java.util.Collections;
        // Add root group that contains only configurations
        this.connectionGroup = new SimpleConnectionGroup("ROOT", "ROOT",
                new SimpleConnectionDirectory(configs),
                new SimpleConnectionGroupDirectory(Collections.EMPTY_LIST));
        return new SimpleUserContext(configs);
import java.util.Collection;
import net.sourceforge.guacamole.net.auth.ConnectionGroup;
import net.sourceforge.guacamole.net.auth.permission.ConnectionGroupPermission;
     * @param groups All groups this user has read access to.
            Map<String, GuacamoleConfiguration> configs,
            Collection<ConnectionGroup> groups) {
        // Add connection permissions
        // Add group permissions
        for (ConnectionGroup group : groups) {

            // Create permission
            Permission permission = new ConnectionGroupPermission(
                ObjectPermission.Type.READ,
                group.getIdentifier()
            );

            // Add to set
            permissions.add(permission);

        }

     * configurations within the given Map.
     * 
    public SimpleUserContext(Map<String, GuacamoleConfiguration> configs) {
        // Build new user from credentials, giving the user an arbitrary name
        this.self = new SimpleUser("user",
                configs, Collections.singleton(connectionGroup));

        // Create user directory for new user
        this.userDirectory = new SimpleUserDirectory(self);
        
 * The Original Code is guacamole-auth-noauth.
 * Laurent Meunier
import net.sourceforge.guacamole.GuacamoleServerException;
 * @author Laurent Meunier
    /**
     * Logger for this class.
     */

    /**
     * Map of all known configurations, indexed by identifier.
     */

    /**
     * The last time the configuration XML was modified, as milliseconds since
     * UNIX epoch.
     */


    /**
     * Retrieves the configuration file, as defined within guacamole.properties.
     * 
     * @return The configuration file, as defined within guacamole.properties.
     * @throws GuacamoleException If an error occurs while reading the
     *                            property.
     */
        return GuacamoleProperties.getRequiredProperty(NOAUTH_CONFIG);



            throw new GuacamoleServerException("Error reading configuration file: "  e.getMessage(), e);
            throw new GuacamoleServerException("Error parsing XML file: "  e.getMessage(), e);



        if (configs == null)
            throw new GuacamoleServerException("Configuration could not be read.");

 * XML parser for the configuration file used by the NoAuth auth provider.
 * 
    /**
     * Map of all configurations, indexed by name.
     */

    /**
     * The name of the current configuration, if any.
     */

    /**
     * The current configuration being parsed, if any.
     */
    /**
     * Returns the a map of all available configurations as parsed from the
     * XML file. This map is unmodifiable.
     * 
     * @return A map of all available configurations.
     */

        // If end of config element, add to map

            // Add to map
            
            // Reset state for next configuration
            currentConfig = null;
            current = null;
            
        
        // Begin configuration parsing if config element

            // Ensure this config is on the top level
            if (current != null)
                throw new SAXException("Configurations cannot be nested.");

            // Read name
            String name = attributes.getValue("name");
            if (name == null)
                throw new SAXException("Each configuration must have a name.");

            // Read protocol
            String protocol = attributes.getValue("protocol");
            if (protocol == null)
                throw new SAXException("Each configuration must have a protocol.");

            // Create config stub
            current = name;
            currentConfig.setProtocol(protocol);


        // Add parameters to existing configuration

            // Ensure a corresponding config exists
            if (currentConfig == null)
                throw new SAXException("Parameter without corresponding configuration.");


        // Fail on unexpected elements
        else
            throw new SAXException("Unexpected element: "  localName);

 *
     *



     *
 b/doc/guacamole-example/src/main/java/org/glyptodon/guacamole/net/example/DummyGuacamoleTunnelServlet.java
package org.glyptodon.guacamole.net.example;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.InetGuacamoleSocket;
import org.glyptodon.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.servlet.GuacamoleHTTPTunnelServlet;
import org.glyptodon.guacamole.servlet.GuacamoleSession;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.simple.SimpleAuthenticationProvider;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.properties.IntegerGuacamoleProperty;
import org.glyptodon.guacamole.properties.StringGuacamoleProperty;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.ConnectionGroup.Type;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.auth.AbstractConnection;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.auth.AbstractConnectionGroup;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.GuacamoleWriter;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AbstractUser;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.auth.permission.UserPermission;
    public org.glyptodon.guacamole.net.auth.User get(String identifier)
    public void add(org.glyptodon.guacamole.net.auth.User object)
    public void update(org.glyptodon.guacamole.net.auth.User object)
import org.glyptodon.guacamole.properties.BooleanGuacamoleProperty;
import org.glyptodon.guacamole.properties.IntegerGuacamoleProperty;
import org.glyptodon.guacamole.properties.StringGuacamoleProperty;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
                    org.glyptodon.guacamole.net.auth.ConnectionGroup.Type.ORGANIZATIONAL, 
        org.glyptodon.guacamole.net.auth.ConnectionGroup.Type authType;
            authType = org.glyptodon.guacamole.net.auth.ConnectionGroup.Type.ORGANIZATIONAL;
            authType = org.glyptodon.guacamole.net.auth.ConnectionGroup.Type.BALANCING;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.InetGuacamoleSocket;
import org.glyptodon.guacamole.net.SSLGuacamoleSocket;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.auth.permission.UserPermission;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Credentials;
    public MySQLUser toMySQLUser(org.glyptodon.guacamole.net.auth.User user) throws GuacamoleException {
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.net.auth.simple.SimpleAuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.properties.FileGuacamoleProperty;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/GuacamoleClientException.java
package org.glyptodon.guacamole;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/GuacamoleException.java
package org.glyptodon.guacamole;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/GuacamoleResourceNotFoundException.java
package org.glyptodon.guacamole;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/GuacamoleSecurityException.java
package org.glyptodon.guacamole;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/GuacamoleServerException.java
package org.glyptodon.guacamole;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/io/GuacamoleReader.java
package org.glyptodon.guacamole.io;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.protocol.GuacamoleInstruction;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/io/GuacamoleWriter.java
package org.glyptodon.guacamole.io;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.protocol.GuacamoleInstruction;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/io/ReaderGuacamoleReader.java
package org.glyptodon.guacamole.io;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.protocol.GuacamoleInstruction;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/io/WriterGuacamoleWriter.java
package org.glyptodon.guacamole.io;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.protocol.GuacamoleInstruction;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/io/package-info.java
package org.glyptodon.guacamole.io;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/net/GuacamoleSocket.java
package org.glyptodon.guacamole.net;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.GuacamoleWriter;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/net/GuacamoleTunnel.java
package org.glyptodon.guacamole.net;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.GuacamoleWriter;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/net/InetGuacamoleSocket.java
package org.glyptodon.guacamole.net;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.ReaderGuacamoleReader;
import org.glyptodon.guacamole.io.WriterGuacamoleWriter;
import org.glyptodon.guacamole.io.GuacamoleWriter;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/net/SSLGuacamoleSocket.java
package org.glyptodon.guacamole.net;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.GuacamoleWriter;
import org.glyptodon.guacamole.io.ReaderGuacamoleReader;
import org.glyptodon.guacamole.io.WriterGuacamoleWriter;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/net/package-info.java
package org.glyptodon.guacamole.net;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/package-info.java
package org.glyptodon.guacamole;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/protocol/ConfiguredGuacamoleSocket.java
package org.glyptodon.guacamole.protocol;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.GuacamoleWriter;
import org.glyptodon.guacamole.net.GuacamoleSocket;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/protocol/GuacamoleClientInformation.java
package org.glyptodon.guacamole.protocol;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/protocol/GuacamoleConfiguration.java
package org.glyptodon.guacamole.protocol;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/protocol/GuacamoleInstruction.java
package org.glyptodon.guacamole.protocol;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/protocol/package-info.java
package org.glyptodon.guacamole.protocol;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/servlet/GuacamoleHTTPTunnelServlet.java
package org.glyptodon.guacamole.servlet;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.io.GuacamoleReader;
import org.glyptodon.guacamole.io.GuacamoleWriter;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/servlet/GuacamoleSession.java
package org.glyptodon.guacamole.servlet;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/servlet/package-info.java
package org.glyptodon.guacamole.servlet;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/AbstractConnection.java
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/AbstractConnectionGroup.java
package org.glyptodon.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/AbstractUser.java
package org.glyptodon.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/AuthenticationProvider.java
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/Connection.java
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/ConnectionGroup.java
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/ConnectionRecord.java
package org.glyptodon.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/Credentials.java
package org.glyptodon.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/Directory.java
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/User.java
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.permission.Permission;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/UserContext.java
package org.glyptodon.guacamole.net.auth;
import org.glyptodon.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/package-info.java
package org.glyptodon.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/permission/ConnectionGroupPermission.java
package org.glyptodon.guacamole.net.auth.permission;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/permission/ConnectionPermission.java
package org.glyptodon.guacamole.net.auth.permission;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/permission/ObjectPermission.java
package org.glyptodon.guacamole.net.auth.permission;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/permission/Permission.java
package org.glyptodon.guacamole.net.auth.permission;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/permission/SystemPermission.java
package org.glyptodon.guacamole.net.auth.permission;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/permission/UserPermission.java
package org.glyptodon.guacamole.net.auth.permission;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/permission/package-info.java
package org.glyptodon.guacamole.net.auth.permission;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/simple/SimpleAuthenticationProvider.java
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/simple/SimpleConnection.java
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.InetGuacamoleSocket;
import org.glyptodon.guacamole.net.SSLGuacamoleSocket;
import org.glyptodon.guacamole.net.auth.AbstractConnection;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/simple/SimpleConnectionDirectory.java
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/simple/SimpleConnectionGroup.java
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.auth.AbstractConnectionGroup;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/simple/SimpleConnectionGroupDirectory.java
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/simple/SimpleUser.java
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.AbstractUser;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/simple/SimpleUserContext.java
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/simple/SimpleUserDirectory.java
package org.glyptodon.guacamole.net.auth.simple;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/auth/simple/package-info.java
package org.glyptodon.guacamole.net.auth.simple;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/AuthenticationFailureEvent.java
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.auth.Credentials;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/AuthenticationSuccessEvent.java
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/CredentialEvent.java
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.auth.Credentials;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/TunnelCloseEvent.java
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/TunnelConnectEvent.java
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/TunnelEvent.java
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/UserEvent.java
package org.glyptodon.guacamole.net.event;
import org.glyptodon.guacamole.net.auth.UserContext;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/listener/AuthenticationFailureListener.java
package org.glyptodon.guacamole.net.event.listener;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.event.AuthenticationFailureEvent;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/listener/AuthenticationSuccessListener.java
package org.glyptodon.guacamole.net.event.listener;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.event.AuthenticationSuccessEvent;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/listener/TunnelCloseListener.java
package org.glyptodon.guacamole.net.event.listener;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.event.TunnelCloseEvent;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/listener/TunnelConnectListener.java
package org.glyptodon.guacamole.net.event.listener;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.event.TunnelConnectEvent;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/listener/package-info.java
package org.glyptodon.guacamole.net.event.listener;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/net/event/package-info.java
 * @see org.glyptodon.guacamole.net.event.listener
package org.glyptodon.guacamole.net.event;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/properties/BooleanGuacamoleProperty.java
package org.glyptodon.guacamole.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/properties/FileGuacamoleProperty.java
package org.glyptodon.guacamole.properties;
import org.glyptodon.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/properties/GuacamoleHome.java
package org.glyptodon.guacamole.properties;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/properties/GuacamoleProperties.java
package org.glyptodon.guacamole.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/properties/GuacamoleProperty.java
package org.glyptodon.guacamole.properties;
import org.glyptodon.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/properties/IntegerGuacamoleProperty.java
package org.glyptodon.guacamole.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/properties/StringGuacamoleProperty.java
package org.glyptodon.guacamole.properties;
import org.glyptodon.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/properties/package-info.java
package org.glyptodon.guacamole.properties;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/AuthenticatingHttpServlet.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.event.SessionListenerCollection;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.net.event.AuthenticationFailureEvent;
import org.glyptodon.guacamole.net.event.AuthenticationSuccessEvent;
import org.glyptodon.guacamole.net.event.listener.AuthenticationFailureListener;
import org.glyptodon.guacamole.net.event.listener.AuthenticationSuccessListener;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/BasicFileAuthenticationProvider.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.simple.SimpleAuthenticationProvider;
import org.glyptodon.guacamole.net.basic.auth.Authorization;
import org.glyptodon.guacamole.net.basic.auth.UserMapping;
import org.glyptodon.guacamole.net.basic.xml.DocumentHandler;
import org.glyptodon.guacamole.net.basic.xml.user_mapping.UserMappingTagHandler;
import org.glyptodon.guacamole.properties.FileGuacamoleProperty;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/BasicGuacamoleTunnelServlet.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.event.SessionListenerCollection;
import org.glyptodon.guacamole.net.event.TunnelCloseEvent;
import org.glyptodon.guacamole.net.event.TunnelConnectEvent;
import org.glyptodon.guacamole.net.event.listener.TunnelCloseListener;
import org.glyptodon.guacamole.net.event.listener.TunnelConnectListener;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
import org.glyptodon.guacamole.servlet.GuacamoleHTTPTunnelServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/BasicLogin.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.net.auth.UserContext;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/BasicLogout.java
package org.glyptodon.guacamole.net.basic;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/GuacamoleClassLoader.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/ProtocolInfo.java
package org.glyptodon.guacamole.net.basic;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/ProtocolParameter.java
package org.glyptodon.guacamole.net.basic;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/ProtocolParameterOption.java
package org.glyptodon.guacamole.net.basic;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/WebSocketSupportLoader.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.GuacamoleException;
                "org.glyptodon.guacamole.net.basic.BasicGuacamoleWebSocketTunnelServlet"
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/auth/Authorization.java
package org.glyptodon.guacamole.net.basic.auth;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/auth/UserMapping.java
package org.glyptodon.guacamole.net.basic.auth;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/auth/package-info.java
package org.glyptodon.guacamole.net.basic.auth;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connectiongroups/ConnectionGroupUtility.java
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connectiongroups/Create.java
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connectiongroups/Delete.java
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connectiongroups/DummyConnectionGroup.java
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.auth.AbstractConnectionGroup;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connectiongroups/List.java
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connectiongroups/Move.java
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connectiongroups/Update.java
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connections/ConnectionUtility.java
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connections/Create.java
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connections/Delete.java
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connections/DummyConnection.java
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.auth.AbstractConnection;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connections/List.java
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connections/Move.java
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/connections/Update.java
package org.glyptodon.guacamole.net.basic.crud.connections;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/permissions/List.java
package org.glyptodon.guacamole.net.basic.crud.permissions;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.auth.permission.UserPermission;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/protocols/List.java
package org.glyptodon.guacamole.net.basic.crud.protocols;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
import org.glyptodon.guacamole.net.basic.ProtocolInfo;
import org.glyptodon.guacamole.net.basic.ProtocolParameter;
import org.glyptodon.guacamole.net.basic.ProtocolParameterOption;
import org.glyptodon.guacamole.net.basic.xml.DocumentHandler;
import org.glyptodon.guacamole.net.basic.xml.protocol.ProtocolTagHandler;
import org.glyptodon.guacamole.properties.GuacamoleHome;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/users/Create.java
package org.glyptodon.guacamole.net.basic.crud.users;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/users/Delete.java
package org.glyptodon.guacamole.net.basic.crud.users;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/users/DummyUser.java
package org.glyptodon.guacamole.net.basic.crud.users;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AbstractUser;
import org.glyptodon.guacamole.net.auth.permission.Permission;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/users/List.java
package org.glyptodon.guacamole.net.basic.crud.users;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleServerException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/crud/users/Update.java
package org.glyptodon.guacamole.net.basic.crud.users;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Directory;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.auth.permission.UserPermission;
import org.glyptodon.guacamole.net.basic.AuthenticatingHttpServlet;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/event/SessionListenerCollection.java
package org.glyptodon.guacamole.net.basic.event;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/event/package-info.java
package org.glyptodon.guacamole.net.basic.event;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/package-info.java
package org.glyptodon.guacamole.net.basic;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/properties/AuthenticationProviderProperty.java
package org.glyptodon.guacamole.net.basic.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.basic.GuacamoleClassLoader;
import org.glyptodon.guacamole.properties.GuacamoleProperty;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/properties/BasicGuacamoleProperties.java
package org.glyptodon.guacamole.net.basic.properties;
import org.glyptodon.guacamole.properties.FileGuacamoleProperty;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/properties/EventListenersProperty.java
package org.glyptodon.guacamole.net.basic.properties;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.GuacamoleClassLoader;
import org.glyptodon.guacamole.properties.GuacamoleProperty;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/properties/package-info.java
package org.glyptodon.guacamole.net.basic.properties;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/DocumentHandler.java
package org.glyptodon.guacamole.net.basic.xml;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/TagHandler.java
package org.glyptodon.guacamole.net.basic.xml;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/package-info.java
package org.glyptodon.guacamole.net.basic.xml;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/protocol/OptionTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.protocol;
import org.glyptodon.guacamole.net.basic.ProtocolParameterOption;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/protocol/ParamTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.protocol;
import org.glyptodon.guacamole.net.basic.ProtocolParameter;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/protocol/ProtocolTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.protocol;
import org.glyptodon.guacamole.net.basic.ProtocolInfo;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/protocol/package-info.java
package org.glyptodon.guacamole.net.basic.xml.protocol;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/user_mapping/AuthorizeTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
import org.glyptodon.guacamole.net.basic.auth.Authorization;
import org.glyptodon.guacamole.net.basic.auth.UserMapping;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/user_mapping/ConnectionTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
import org.glyptodon.guacamole.net.basic.auth.Authorization;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/user_mapping/ParamTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/user_mapping/ProtocolTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/user_mapping/UserMappingTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.user_mapping;
import org.glyptodon.guacamole.net.basic.auth.UserMapping;
import org.glyptodon.guacamole.net.basic.xml.TagHandler;
 b/guacamole/src/main/java/net/sourceforge/guacamole/net/basic/BasicFileAuthenticationProvider.java
package net.sourceforge.guacamole.net.basic;
 b/guacamole/src/main/java/net/sourceforge/guacamole/net/basic/BasicFileAuthenticationProvider.java
package net.sourceforge.guacamole.net.basic;
    public static final String CONTEXT_ATTRIBUTE = "GUAC_CONTEXT";
    public static final String CREDENTIALS_ATTRIBUTE = "GUAC_CREDS";
    /**
     * Classname of the Jetty-specific WebSocket tunnel implementation.
     */
    private static final String JETTY_WEBSOCKET =
        "net.sourceforge.guacamole.net.basic.websocket.jetty.BasicGuacamoleWebSocketTunnelServlet";
    /**
     * Classname of the Tomcat-specific WebSocket tunnel implementation.
     */
    private static final String TOMCAT_WEBSOCKET =
        "net.sourceforge.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet";

    private boolean loadWebSocketTunnel(ServletContext context, String classname) {
            Class<Servlet> servlet = (Class<Servlet>)
                    GuacamoleClassLoader.getInstance().findClass(classname);
                Method addServlet = ServletContext.class.getMethod("addServlet",
                        String.class, Class.class);
                Object reg = addServlet.invoke(context, "WebSocketTunnel", servlet);
                return true;
            logger.info("WebSocket support not found.", e);
        }
        catch (NoClassDefFoundError e) {
            logger.info("WebSocket support not found.", e);
        // Load attempt failed
        return false;

    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
    }

    @Override
    public void contextInitialized(ServletContextEvent sce) {

        // Try to load websocket support for Jetty
        logger.info("Attempting to load Jetty-specific WebSocket support...");
        if (loadWebSocketTunnel(sce.getServletContext(), JETTY_WEBSOCKET))
            return;

        // Try to load websocket support for Tomcat
        logger.info("Attempting to load Tomcat-specific WebSocket support...");
        if (loadWebSocketTunnel(sce.getServletContext(), TOMCAT_WEBSOCKET))
            return;

        // Inform of lack of support
        logger.info("No WebSocket support could be loaded. Only HTTP will be used.");

import org.glyptodon.guacamole.properties.BooleanGuacamoleProperty;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
 * 
 * Tests have shown that while WebSocket is negligibly more responsive than
 * Guacamole's native HTTP tunnel, downstream performance is not yet a match.
 * This may be because browser WebSocket implementations are not optimized for
 * throughput, or it may be because servlet container WebSocket implementations
 * are in their infancy, or it may be that OUR WebSocket-backed tunnel
 * implementations are not efficient. Because of this, WebSocket support is
 * disabled by default. To enable it, add the following property to
 * your guacamole.properties:
 * 
 *     enable-websocket: true
    private static final BooleanGuacamoleProperty ENABLE_WEBSOCKET =
            new BooleanGuacamoleProperty() {

        @Override
        public String getName() {
            return "enable-websocket";
        }

    };
    
            logger.info("WebSocket support not found.");
            logger.info("WebSocket support not found.");
        try {

            // Stop if WebSocket not explicitly enabled.
            if (!GuacamoleProperties.getProperty(ENABLE_WEBSOCKET, false)) {
                logger.info("WebSocket support not enabled.");
                return;
            }

        }
        catch (GuacamoleException e) {
            logger.error("Error parsing enable-websocket property.", e);
        }
        
    public static final String CONTEXT_ATTRIBUTE = "GUAC_CONTEXT";
    public static final String CREDENTIALS_ATTRIBUTE = "GUAC_CREDS";
    public static Credentials getCredentials(HttpSession session) {
    public static UserContext getUserContext(HttpSession session) {
    private static Logger logger = LoggerFactory.getLogger(BasicGuacamoleTunnelServlet.class);
    public static enum IdentifierType {
    public static boolean notifyConnect(Collection listeners, UserContext context,
    public static boolean notifyClose(Collection listeners, UserContext context,
     * Creates a new tunnel using the parameters and credentials present in
     * the given request.
     * 
     * @param request The HttpServletRequest describing the tunnel to create.
     * @return The created tunnel, or null if the tunnel could not be created.
     * @throws GuacamoleException If an error occurs while creating the tunnel.
     */
    public static GuacamoleTunnel createTunnel(HttpServletRequest request)
            throws GuacamoleException {

        HttpSession httpSession = request.getSession(true);

        // Get listeners
        final SessionListenerCollection listeners;
        try {
            listeners = new SessionListenerCollection(httpSession);
        }
        catch (GuacamoleException e) {
            logger.error("Failed to retrieve listeners. Authentication canceled.", e);
            throw e;
        }

        // Get ID of connection
        String id = request.getParameter("id");
        IdentifierType id_type = IdentifierType.getType(id);

        // Do not continue if unable to determine type
        if (id_type == null)
            throw new GuacamoleClientException("Illegal identifier - unknown type.");

        // Remove prefix
        id = id.substring(id_type.PREFIX.length());

        // Get credentials
        final Credentials credentials = getCredentials(httpSession);

        // Get context
        final UserContext context = getUserContext(httpSession);

        // If no context or no credentials, not logged in
        if (context == null || credentials == null)
            throw new GuacamoleSecurityException("Cannot connect - user not logged in.");

        // Get client information
        GuacamoleClientInformation info = new GuacamoleClientInformation();

        // Set width if provided
        String width  = request.getParameter("width");
        if (width != null)
            info.setOptimalScreenWidth(Integer.parseInt(width));

        // Set height if provided
        String height = request.getParameter("height");
        if (height != null)
            info.setOptimalScreenHeight(Integer.parseInt(height));

        // Add audio mimetypes
        String[] audio_mimetypes = request.getParameterValues("audio");
        if (audio_mimetypes != null)
            info.getAudioMimetypes().addAll(Arrays.asList(audio_mimetypes));

        // Add video mimetypes
        String[] video_mimetypes = request.getParameterValues("video");
        if (video_mimetypes != null)
            info.getVideoMimetypes().addAll(Arrays.asList(video_mimetypes));

        // Create connected socket from identifier
        GuacamoleSocket socket;
        switch (id_type) {

            // Connection identifiers
            case CONNECTION: {

                // Get connection directory
                Directory<String, Connection> directory =
                    context.getRootConnectionGroup().getConnectionDirectory();

                // Get authorized connection
                Connection connection = directory.get(id);
                if (connection == null) {
                    logger.warn("Connection id={} not found.", id);
                    throw new GuacamoleSecurityException("Requested connection is not authorized.");
                }

                // Connect socket
                socket = connection.connect(info);
                logger.info("Successful connection from {} to \"{}\".", request.getRemoteAddr(), id);
                break;
            }

            // Connection group identifiers
            case CONNECTION_GROUP: {

                // Get connection group directory
                Directory<String, ConnectionGroup> directory =
                    context.getRootConnectionGroup().getConnectionGroupDirectory();

                // Get authorized connection group
                ConnectionGroup group = directory.get(id);
                if (group == null) {
                    logger.warn("Connection group id={} not found.", id);
                    throw new GuacamoleSecurityException("Requested connection group is not authorized.");
                }

                // Connect socket
                socket = group.connect(info);
                logger.info("Successful connection from {} to group \"{}\".", request.getRemoteAddr(), id);
                break;
            }

            // Fail if unsupported type
            default:
                throw new GuacamoleClientException("Connection not supported for provided identifier type.");

        }

        // Associate socket with tunnel
        GuacamoleTunnel tunnel = new GuacamoleTunnel(socket) {

            @Override
            public void close() throws GuacamoleException {

                // Only close if not canceled
                if (!notifyClose(listeners, context, credentials, this))
                    throw new GuacamoleException("Tunnel close canceled by listener.");

                // Close if no exception due to listener
                super.close();

            }

        };

        // Notify listeners about connection
        if (!notifyConnect(listeners, context, credentials, tunnel)) {
            logger.info("Connection canceled by listener.");
            return null;
        }

        return tunnel;

    }

    /**
            return createTunnel(request);
import org.glyptodon.guacamole.properties.BooleanGuacamoleProperty;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
 * 
 * Tests have shown that while WebSocket is negligibly more responsive than
 * Guacamole's native HTTP tunnel, downstream performance is not yet a match.
 * This may be because browser WebSocket implementations are not optimized for
 * throughput, or it may be because servlet container WebSocket implementations
 * are in their infancy, or it may be that OUR WebSocket-backed tunnel
 * implementations are not efficient. Because of this, WebSocket support is
 * disabled by default. To enable it, add the following property to
 * your guacamole.properties:
 * 
 *     enable-websocket: true
    private static final BooleanGuacamoleProperty ENABLE_WEBSOCKET =
            new BooleanGuacamoleProperty() {
        @Override
        public String getName() {
            return "enable-websocket";
        }

    };
    
    /**
     * Classname of the Jetty-specific WebSocket tunnel implementation.
     */
    private static final String JETTY_WEBSOCKET =
        "org.glyptodon.guacamole.net.basic.websocket.jetty.BasicGuacamoleWebSocketTunnelServlet";

    /**
     * Classname of the Tomcat-specific WebSocket tunnel implementation.
     */
    private static final String TOMCAT_WEBSOCKET =
        "org.glyptodon.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet";

    private boolean loadWebSocketTunnel(ServletContext context, String classname) {
            Class<Servlet> servlet = (Class<Servlet>)
                    GuacamoleClassLoader.getInstance().findClass(classname);
                Method addServlet = ServletContext.class.getMethod("addServlet",
                        String.class, Class.class);
                Object reg = addServlet.invoke(context, "WebSocketTunnel", servlet);
                return true;
        catch (NoClassDefFoundError e) {
            logger.info("WebSocket support not found.");
        }
        // Load attempt failed
        return false;

    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
    }

    @Override
    public void contextInitialized(ServletContextEvent sce) {

        try {

            // Stop if WebSocket not explicitly enabled.
            if (!GuacamoleProperties.getProperty(ENABLE_WEBSOCKET, false)) {
                logger.info("WebSocket support not enabled.");
                return;
            }

        }
        catch (GuacamoleException e) {
            logger.error("Error parsing enable-websocket property.", e);
        }
        
        // Try to load websocket support for Jetty
        logger.info("Attempting to load Jetty-specific WebSocket support...");
        if (loadWebSocketTunnel(sce.getServletContext(), JETTY_WEBSOCKET))
            return;

        // Try to load websocket support for Tomcat
        logger.info("Attempting to load Tomcat-specific WebSocket support...");
        if (loadWebSocketTunnel(sce.getServletContext(), TOMCAT_WEBSOCKET))
            return;

        // Inform of lack of support
        logger.info("No WebSocket support could be loaded. Only HTTP will be used.");

            return BasicTunnelRequestUtility.createTunnel(request);
    public void init() throws ServletException {
        auth_servlet.init();
    }

    @Override
import org.glyptodon.guacamole.net.basic.BasicTunnelRequestUtility;
            return BasicTunnelRequestUtility.createTunnel(request);
    public void init() throws ServletException {
        auth_servlet.init();
    }

    @Override
import org.glyptodon.guacamole.net.basic.BasicTunnelRequestUtility;
            return BasicTunnelRequestUtility.createTunnel(request);
import java.util.List;
    protected String selectSubProtocol(List<String> subProtocols) {

        // Search for expected protocol
        for (String protocol : subProtocols)
            if ("guacamole".equals(protocol))
                return "guacamole";
        
        // Otherwise, fail
        return null;

    }

    @Override
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static Logger logger = LoggerFactory.getLogger(GuacamoleWebSocketTunnelServlet.class);
    
    /**
            logger.error("Error connecting WebSocket tunnel.", e);
            return null;
                    logger.debug("Tunnel write failed.", e);
                            logger.debug("Tunnel read failed due to I/O error.", e);
                            logger.debug("Tunnel read failed.", e);
                    logger.debug("Unable to close WebSocket tunnel.", e);
                    logger.debug("Tunnel write failed.", e);
                            logger.debug("Tunnel read failed due to I/O error.", e);
                            logger.debug("Tunnel read failed.", e);
                    logger.debug("Unable to close WebSocket tunnel.", e);
        ENUM,

        /**
         * A text parameter that can span more than one line.
         */
        MULTILINE

                // Multiline parameter
                case MULTILINE:
                    xml.writeAttribute("type", "multiline");
                    break;

        // Multiline field
        else if ("multiline".equals(type))
            protocolParameter.setType(ProtocolParameter.Type.MULTILINE);

        Guice.createInjector(
            new RESTServletModule(), 
            new RESTModule()
        );
/*
 *  Guacamole - Clientless Remote Desktop
 *  Copyright (C) 2010  Michael Jumper
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import com.google.inject.Inject;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.net.basic.rest.auth.TokenUserContextMap;
    /**
     * The map of auth tokens to users for the REST endpoints.
     */
    @Inject
    private TokenUserContextMap tokenUserMap;
    
    public String getConnections(@QueryParam("token") String authToken) {
        UserContext userContext = tokenUserMap.get(authToken);
       
        // authentication failed.
        if(userContext == null)
            throw new WebApplicationException(Response.Status.UNAUTHORIZED);
        
        try {
            //TODO: Make this work for realzies
            return userContext.getRootConnectionGroup().getConnectionDirectory().getIdentifiers().toString();
        } catch(GuacamoleSecurityException e) {
            throw new WebApplicationException(e, Response.Status.UNAUTHORIZED);
        } catch(GuacamoleException e) {
            throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);
        }
import org.glyptodon.guacamole.net.basic.rest.connection.ConnectionService;
        bind(ConnectionService.class);
import com.google.inject.Scopes;
import org.codehaus.jackson.jaxrs.JacksonJsonProvider;
import org.glyptodon.guacamole.net.basic.rest.auth.LoginRESTService;
import org.glyptodon.guacamole.net.basic.rest.connection.ConnectionRESTService;
        
        // Set up the API endpoints
        bind(ConnectionRESTService.class);
        bind(LoginRESTService.class);
        
        // Set up the servlet and JSON mappings
        bind(GuiceContainer.class);
        bind(JacksonJsonProvider.class).in(Scopes.SINGLETON);
        serve("/*").with(GuiceContainer.class);
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/auth/LoginRESTService.java
public class LoginRESTService {
    private static final Logger logger = LoggerFactory.getLogger(LoginRESTService.class);
import java.util.ArrayList;
import java.util.List;
import org.glyptodon.guacamole.GuacamoleException;

 * A service for performing useful manipulations on REST Connections.
     * Converts a list of org.glyptodon.guacamole.net.auth.Connection to
     * Connection objects for exposure with the REST endpoints.
     * 
     * @param connections The org.glyptodon.guacamole.net.auth.Connection to
     *                    convert for REST endpoint use.
     * @return A List of Connection objects for use with the REST endpoint.
     * @throws GuacamoleException If an error occurs while converting the 
     *                            connections.
    public List<Connection> convertConnectionList(List<? extends org.glyptodon.guacamole.net.auth.Connection> connections) 
            throws GuacamoleException {
        List<Connection> restConnections = new ArrayList<Connection>();
        for(org.glyptodon.guacamole.net.auth.Connection connection : connections) {
            restConnections.add(new Connection(connection));
            
        return restConnections;
    }
import java.util.HashMap;
import java.util.Map;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.glyptodon.guacamole.net.basic.rest.APIError;
@Produces(MediaType.APPLICATION_JSON)
    public APIAuthToken login(@QueryParam("username") String username,
            throw new WebApplicationException(
                Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(e).build());
            throw new WebApplicationException(
                Response.status(Response.Status.UNAUTHORIZED)
                .entity(new APIError("Permission Denied.")).build());
        return new APIAuthToken(authToken);
    /**
     * Get the name of this connection.
     * @return The name of this connection.
     */
    /**
     * Set the name of this connection.
     * @param name The name of this connection.
     */
    /**
     * Get the identifier of this connection.
     * @return The identifier of this connection.
     */
    
    /**
     * Set the identifier of this connection.
     * @param identifier The identifier of this connection.
     */
    /**
     * Get the configuration for this connection.
     * @return The configuration for this connection.
     */
    
    /**
     * Set the configuration for this connection.
     * @param configuration The configuration for this connection.
     */
    /**
     * Get the history records for this connection.
     * @return The history records for this connection.
     */
    /**
     * Set the history records for this connection.
     * @param history The history records for this connection.
     */
@Produces(MediaType.APPLICATION_JSON)
            throw new WebApplicationException(
                Response.status(Response.Status.UNAUTHORIZED)
                .entity(new APIError("Permission Denied.")).build());
            throw new WebApplicationException(
                Response.status(Response.Status.UNAUTHORIZED)
                .entity(new APIError("Permission Denied.")).build());
            throw new WebApplicationException(
                Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                    .entity(e).build());
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
        bind(AuthenticationService.class);
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
     * A service for authenticating users from auth tokens.
    private AuthenticationService authenticationService;
        UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
    }

 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/connection/APIConnection.java
import org.glyptodon.guacamole.net.auth.Connection;
public class APIConnection {
     * Create an empty APIConnection.
    public APIConnection() {}
     * Create an APIConnection from a Connection record.
     * @param connection The connection to create this APIConnection from.
     *                            instantiating this new APIConnection.
    public APIConnection(Connection connection) 
import javax.ws.rs.PathParam;
import org.glyptodon.guacamole.net.auth.Connection;
     * A service for managing the REST endpoint APIConnection objects. 
    /**
     * Gets a list of connections with the given ConnectionGroup parentID.
     * If no parentID is provided, returns the connections from the root group.
     * 
     * @param authToken The authentication token that is used to authenticate
     *                  the user performing the operation.
     * @param parentID The ID of the ConnectionGroup the connections
     *                 belong to. If null, the root connection group will be used.
     * @return The connection list.
     */
    public List<APIConnection> getConnections(@QueryParam("token") String authToken, @QueryParam("parentID") String parentID) {
            Directory<String, Connection> connectionDirectory = 
            List<Connection> connections = new ArrayList<Connection>();
    
    /**
     * Gets an individual connection.
     * 
     * @param authToken The authentication token that is used to authenticate
     *                  the user performing the operation.
     * @param connectionID The ID of the APIConnection..
     * @return The connection.
     */
    @GET
    @Path("/{connectionID}")
    public APIConnection getConnection(@QueryParam("token") String authToken, @PathParam("connectionID") String connectionID) {
        UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
        
        try {
            
            // Get the connection directory
            ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
            Directory<String, Connection> connectionDirectory =
                    rootGroup.getConnectionDirectory();
            
            // Get the connection
            Connection connection = connectionDirectory.get(connectionID);
            
            if(connection == null)
                throw new WebApplicationException(
                    Response.status(Response.Status.BAD_REQUEST)
                    .entity(new APIError("No Connection found with the provided ID."))
                    .build());
            
            return new APIConnection(connection);
        } catch(GuacamoleSecurityException e) {
            throw new WebApplicationException(
                Response.status(Response.Status.UNAUTHORIZED)
                .entity(new APIError("Permission Denied.")).build());
        } catch(GuacamoleException e) {
            throw new WebApplicationException(
                Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                    .entity(e).build());
        }
    }
     * Converts a list of org.glyptodon.guacamole.net.auth.APIConnection to
     * APIConnection objects for exposure with the REST endpoints.
     * @param connections The org.glyptodon.guacamole.net.auth.APIConnection to
     * @return A List of APIConnection objects for use with the REST endpoint.
    public List<APIConnection> convertConnectionList(List<? extends org.glyptodon.guacamole.net.auth.Connection> connections) 
        List<APIConnection> restConnections = new ArrayList<APIConnection>();
            restConnections.add(new APIConnection(connection));
import javax.ws.rs.core.Response.Status;
import org.glyptodon.guacamole.net.basic.rest.HTTPException;
            throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
import javax.ws.rs.core.Response.Status;
import org.glyptodon.guacamole.net.basic.rest.HTTPException;
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR, 
                    "Unexpected server error.");
            throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
import javax.ws.rs.core.Response.Status;
import org.glyptodon.guacamole.net.basic.rest.HTTPException;
                throw new HTTPException(Status.BAD_REQUEST,
                        "No ConnectionGroup found with the provided parentID.");
                throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR, 
                    "Unexpected server error.");
                throw new HTTPException(Status.BAD_REQUEST, 
                        "No Connection found with the provided ID.");
                throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR, 
                    "Unexpected server error.");
import org.glyptodon.guacamole.net.auth.Connection;
     * Converts a list of Connection to a list of APIConnection objects for 
     * exposing with the REST endpoints.
     * @param connections The Connection to convert for REST endpoint use.
    public List<APIConnection> convertConnectionList(List<? extends Connection> connections) 
        for(Connection connection : connections) {
import javax.ws.rs.DELETE;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

    /**
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(ConnectionRESTService.class);
            logger.error("Unexpected GuacamoleException caught while listing connections.", e);
                    "Unexpected server error. "  e.getMessage());
     * @param connectionID The ID of the Connection..
            logger.error("Unexpected GuacamoleException caught while getting a connection.", e);
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR,
                    "Unexpected server error. "  e.getMessage());
        }
    }
    
    /**
     * Deletes an individual connection.
     * 
     * @param authToken The authentication token that is used to authenticate
     *                  the user performing the operation.
     * @param connectionID The ID of the Connection.
     */
    @DELETE
    @Path("/{connectionID}")
    public void deleteConnection(@QueryParam("token") String authToken, @PathParam("connectionID") String connectionID) {
        UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
        
        try {
            // Get the connection directory
            ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
            Directory<String, Connection> connectionDirectory =
                    rootGroup.getConnectionDirectory();
            
            // Make sure the connection is there before trying to delete
            if(connectionDirectory.get(connectionID) == null)
                throw new HTTPException(Status.BAD_REQUEST, 
                        "No Connection found with the provided ID.");
            
            // Delete the connection
            connectionDirectory.remove(connectionID);
        } catch(GuacamoleSecurityException e) {
                throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
        } catch(GuacamoleException e) {
            logger.error("Unexpected GuacamoleException caught while deleting a connection.", e);
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR,
                    "Unexpected server error. "  e.getMessage());
import org.glyptodon.guacamole.properties.LongGuacamoleProperty;
    /**
     * The session timeout for the API, in milliseconds.
     */
    public static final LongGuacamoleProperty API_SESSION_TIMEOUT = new LongGuacamoleProperty() {

        @Override
        public String getName() { return "api-session-timeout"; }

    };

import java.util.Date;
import java.util.Map;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 * A basic, HashMap-based implementation of the TokenUserContextMap with support
 * for session timeouts.
public class BasicTokenUserContextMap implements TokenUserContextMap {

    /**
     * Logger for this class.
     */
    private static Logger logger = LoggerFactory.getLogger(BasicTokenUserContextMap.class);
    
    /**
     * The last time a user with a specific auth token accessed the API. 
     */
    private Map<String, Long> lastAccessTimeMap = new HashMap<String, Long>();
    
    /**
     * Keeps track of the authToken to UserContext mapping.
     */
    private Map<String, UserContext> userContextMap = new HashMap<String, UserContext>();
    
    /**
     * The session timeout configuration for an API session.
     */
    private final long SESSION_TIMEOUT;
    
    /**
     * Create a new BasicTokenUserContextMap and initialize the session timeout value.
     */
    public BasicTokenUserContextMap() {
        
        // Set up the authToken => userContext hashmap
        super();
        
        // Set up the SESSION_TIMEOUT value, with a one hour default.
        long sessionTimeoutValue = 3600000l;
        try {
            sessionTimeoutValue = GuacamoleProperties.getProperty(BasicGuacamoleProperties.API_SESSION_TIMEOUT, 3600000l);
        } catch (GuacamoleException e) {
            logger.error("Unexpected GuacamoleException caught while reading API_SESSION_TIMEOUT property.", e);
        }
        
        SESSION_TIMEOUT = sessionTimeoutValue;
    }
    
    /**
     * Evict an authentication token from the map of logged in users and last
     * access times.
     * 
     * @param authToken The authentication token to evict.
     */
    private void evict(String authToken) {
        userContextMap.remove(authToken);
        lastAccessTimeMap.remove(authToken);
    }
    
    /**
     * Log that the user represented by this auth token has just used the API.
     * 
     * @param authToken The authentication token to record access time for.
     */
    private void logAccessTime(String authToken) {
        lastAccessTimeMap.put(authToken, new Date().getTime());
    }
    
    private boolean sessionHasTimedOut(String authToken) {
        if(!lastAccessTimeMap.containsKey(authToken))
            return true;
        
        long lastAccessTime = lastAccessTimeMap.get(authToken);
        long currentTime = new Date().getTime();
        
        return currentTime - lastAccessTime > SESSION_TIMEOUT;
    }

    @Override
    public UserContext get(String authToken) {
        
        // If the session has timed out, evict the token and force the user to log in again
        if(sessionHasTimedOut(authToken)) {
            evict(authToken);
            return null;
        }
        
        // Update the last access time and return the UserContext
        logAccessTime(authToken);
        return userContextMap.get(authToken);
    }

    @Override
    public void put(String authToken, UserContext userContext) {
        
        // Update the last access time, and create the token/UserContext mapping
        logAccessTime(authToken);
        userContextMap.put(authToken, userContext);
    }
    
}
public interface TokenUserContextMap {
    
    /**
     * Registers that a user has just logged in with the specified authToken and
     * UserContext.
     * 
     * @param authToken The authentication token for the logged in user.
     * @param userContext The UserContext for the logged in user.
     */
    public void put(String authToken, UserContext userContext);
    
    /**
     * Get the UserContext for a logged in user. If the auth token does not
     * represent a user who is currently logged in, returns null. 
     * 
     * @param authToken The authentication token for the logged in user.
     * @return The UserContext for the given auth token, if the auth token
     *         represents a currently logged in user, null otherwise.
     */
    public UserContext get(String authToken);
}
     * The session timeout configuration for an API session, in milliseconds.
        long sessionTimeoutValue;
        }
        catch (GuacamoleException e) {
            logger.error("Unexpected GuacamoleException caught while reading API_SESSION_TIMEOUT property. Defaulting to 1 hour.", e);
            sessionTimeoutValue = 3600000l;
        
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
public class APIConnection implements Connection {
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override

    @Override
    public GuacamoleSocket connect(GuacamoleClientInformation info) throws GuacamoleException {
        throw new UnsupportedOperationException("Not supported.");
    }
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
    public APIConnection getConnection(@QueryParam("token") String authToken, 
            @PathParam("connectionID") String connectionID) {
     * @param connectionID The ID of the Connection to delete.
    
    /**
     * Creates a new connection and returns the identifier of the new connection.
     * If a parentID is provided, the connection will be created in the
     * connection group with the parentID. Otherwise, the root connection group
     * will be used.
     * 
     * @param authToken The authentication token that is used to authenticate
     *                  the user performing the operation.
     * @param parentID The ID of the ConnectionGroup the connections
     *                 belong to. If null, the root connection group will be used.
     * @param connection The connection to create.
     * @return The identifier of the new connection.
     */
    @POST
    public String createConnection(@QueryParam("token") String authToken, 
            @QueryParam("parentID") String parentID, APIConnection connection) {
        UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
        
        if(connection == null)
            throw new HTTPException(Status.BAD_REQUEST,
                    "A connection is required for this request.");
        
        try {
            // If the parent connection group is passed in, try to find it.
            ConnectionGroup parentConnectionGroup;
            if(parentID == null)
                parentConnectionGroup = userContext.getRootConnectionGroup();
            else {
                ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
                Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
                parentConnectionGroup = connectionGroupDirectory.get(parentID);
            }
            
            if(parentConnectionGroup == null)
                throw new HTTPException(Status.BAD_REQUEST,
                        "No ConnectionGroup found with the provided parentID.");
            
            Directory<String, Connection> connectionDirectory = 
                    parentConnectionGroup.getConnectionDirectory();
            
            // Create the connection
            connectionDirectory.add(connection);
            
            // Return the new connection identifier
            return connection.getIdentifier();
        } catch(GuacamoleSecurityException e) {
                throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
        } catch(GuacamoleException e) {
            logger.error("Unexpected GuacamoleException caught while listing connections.", e);
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR, 
                    "Unexpected server error. "  e.getMessage());
        }
    }
    
    /**
     * Updates a connection.
     * 
     * @param authToken The authentication token that is used to authenticate
     *                  the user performing the operation.
     * @param connectionID The ID of the Connection to delete.
     * @param connection The connection to update.
     */
    @POST
    @Path("/{connectionID}")
    public void updateConnection(@QueryParam("token") String authToken, 
            @PathParam("connectionID") String connectionID, APIConnection connection) {
        UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
        
        if(connection == null)
            throw new HTTPException(Status.BAD_REQUEST,
                    "A connection is required for this request.");
        
        try {
            // Get the connection directory
            ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
            Directory<String, Connection> connectionDirectory =
                    rootGroup.getConnectionDirectory();
            
            // Make sure the connection is there before trying to update
            if(connectionDirectory.get(connectionID) == null)
                throw new HTTPException(Status.BAD_REQUEST, 
                        "No Connection with the provided ID.");
            
            // Update the connection
            connectionDirectory.update(connection);
        } catch(GuacamoleSecurityException e) {
                throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
        } catch(GuacamoleException e) {
            logger.error("Unexpected GuacamoleException caught while listing connections.", e);
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR, 
                    "Unexpected server error. "  e.getMessage());
        }
    }
    
    /**
     * Moves an individual connection to a different connection group.
     * 
     * @param authToken The authentication token that is used to authenticate
     *                  the user performing the operation.
     * @param connectionID The ID of the Connection to delete.
     * @param parentID The ID of the ConnectionGroup the connections
     *                 belong to. If null, the root connection group will be used.
     */
    @PUT
    @Path("/{connectionID}")
    public void moveConnection(@QueryParam("token") String authToken, 
            @PathParam("connectionID") String connectionID, @QueryParam("parentID") String parentID) {
        UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
        
        try {
            // Get the connection directory
            ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
            Directory<String, Connection> connectionDirectory =
                    rootGroup.getConnectionDirectory();
            
            // Find the new parent connection group
            Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
            ConnectionGroup parentConnectionGroup = connectionGroupDirectory.get(parentID);
            
            if(parentConnectionGroup == null)
                throw new HTTPException(Status.BAD_REQUEST,
                        "No ConnectionGroup found with the provided parentID.");
            
            // Make sure the connection is there before trying to delete
            if(connectionDirectory.get(connectionID) == null)
                throw new HTTPException(Status.BAD_REQUEST, 
                        "No Connection found with the provided ID.");
            
            // Move the connection
            connectionDirectory.move(connectionID, connectionDirectory);
        } catch(GuacamoleSecurityException e) {
                throw new HTTPException(Status.UNAUTHORIZED, "Permission Denied.");
        } catch(GuacamoleException e) {
            logger.error("Unexpected GuacamoleException caught while deleting a connection.", e);
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR,
                    "Unexpected server error. "  e.getMessage());
        }
    }
        
        // Set the connection ID
        object.setIdentifier(connection.getIdentifier());
        
        // Set the connection group ID
        object.setIdentifier(connectionGroup.getIdentifier());
import javax.ws.rs.Consumes;
@Consumes(MediaType.APPLICATION_JSON)
import org.glyptodon.guacamole.GuacamoleClientException;
                throw new GuacamoleClientException("No ConnectionGroup found with the provided parentID.");
                throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
        } catch(GuacamoleClientException e) {
                throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
                throw new GuacamoleClientException("No Connection found with the provided ID.");
                throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
        } catch(GuacamoleClientException e) {
                throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            logger.error("Unexpected GuacamoleException caught while getting connection.", e);
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
                throw new GuacamoleClientException("No Connection found with the provided ID.");
                throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
        } catch(GuacamoleClientException e) {
                throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            logger.error("Unexpected GuacamoleException caught while deleting connection.", e);
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
            if(connection == null)
                throw new GuacamoleClientException("A connection is required for this request.");
            
                throw new GuacamoleClientException("No ConnectionGroup found with the provided parentID.");
                throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
        } catch(GuacamoleClientException e) {
                throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            logger.error("Unexpected GuacamoleException caught while creating connection.", e);
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
            if(connection == null)
                throw new GuacamoleClientException("A connection is required for this request.");
        
                throw new GuacamoleClientException("No Connection with the provided ID.");
                throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
        } catch(GuacamoleClientException e) {
                throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            logger.error("Unexpected GuacamoleException caught updating connection.", e);
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
                throw new GuacamoleClientException("No ConnectionGroup found with the provided parentID.");
                throw new GuacamoleClientException("No Connection found with the provided ID.");
                throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
        } catch(GuacamoleClientException e) {
                throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            logger.error("Unexpected GuacamoleException caught moving connection.", e);
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
import java.util.HashMap;
import java.util.Map;
public class APIConnection {

    /**
     * Map of all associated parameter values, indexed by parameter name.
     */
    private Map<String, String> parameters = new HashMap<String, String>();
    /**
     * Returns the name of this connection.
     * @return The name of this connection.
     */
    /**
     * Set the name of this connection.
     * @param name The name of this connection.
     */
    
    /**
     * Returns the unique identifier for this connection.
     * @return The unique identifier for this connection.
     */
    /**
     * Sets the unique identifier for this connection.
     */
    /**
     * Returns the history records associated with this connection.
     * @return The history records associated with this connection.
     */
     * Returns the parameter map for this connection.
     * @return The parameter map for this connection.
    public Map<String, String> getParameters() {
        return parameters;
    /**
     * Sets the parameter map for this connection.
     * @param parameters The parameter map for this connection.
     */
    public void setParameters(Map<String, String> parameters) {
        this.parameters = parameters;
            connectionDirectory.add(new APIConnectionWrapper(connection));
            connectionDirectory.update(new APIConnectionWrapper(connection));
package org.glyptodon.guacamole.net.basic.rest.auth;
     * Creates a new connection group having the given name and type.
import org.glyptodon.guacamole.net.basic.rest.connectiongroup.ConnectionGroupService;
        bind(ConnectionGroupService.class);
import org.glyptodon.guacamole.net.basic.rest.connectiongroup.ConnectionGroupRESTService;
        bind(ConnectionGroupRESTService.class);
     * @param connectionID The ID of the Connection to move.
     * @param connectionID The ID of the Connection to move.
            connectionDirectory.move(connectionID, parentConnectionGroup.getConnectionDirectory());
import org.glyptodon.guacamole.net.basic.rest.permission.PermissionService;
        bind(PermissionService.class);
import org.glyptodon.guacamole.net.basic.rest.permission.PermissionRESTService;
        bind(PermissionRESTService.class);
    public List<APIConnection> convertConnectionList(Iterable<? extends Connection> connections) 
            Iterable<? extends ConnectionGroup> connectionGroups) {
            Set<Permission> permissionsToRemove = new HashSet<Permission>(originalPermissions);
import org.codehaus.jackson.map.annotate.JsonSerialize;
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
            this.objectIdentifier = ((ConnectionPermission) permission).getObjectIdentifier();
            this.objectIdentifier = ((ConnectionGroupPermission) permission).getObjectIdentifier();
            this.objectIdentifier = ((UserPermission) permission).getObjectIdentifier();
    public Permission toPermission() {
            permissions.add(restPermission.toPermission());
        
        if(user == null)
            return null;
        return user;
     * Adds a permissions for a user with the given userID.
     * @param userID The user ID to add the permission for.
     * @param permission The permission to add for the user with the given userID.
    public void addPermission(@QueryParam("token") String authToken, 
            @PathParam("userID") String userID, APIPermission permission) {
            // Add the new permission
            user.addPermission(permission.toPermission());
            logger.error("Unexpected GuacamoleException caught adding permission.", e);
            throw new HTTPException(Status.INTERNAL_SERVER_ERROR, e.getMessage() != null ? e.getMessage() : "Unexpected server error.");
        }
    }
    
    /**
     * Removes a permissions for a user with the given userID.
     * 
     * @param authToken The authentication token that is used to authenticate
     *                  the user performing the operation.
     * @param userID The user ID to remove the permission for.
     * @param permission The permission to remove for the user with the given userID.
     */
    @POST
    @Path("/{userID}/remove")
    public void removePermission(@QueryParam("token") String authToken, 
            @PathParam("userID") String userID, APIPermission permission) {
        UserContext userContext = authenticationService.getUserContextFromAuthToken(authToken);
        
        try {
            // Get the user
            User user = userContext.getUserDirectory().get(userID);
            
            if(user == null)
                throw new HTTPException(Status.NOT_FOUND, "User not found with the provided userID.");
            
            // Remove the permission
            user.removePermission(permission.toPermission());
        } catch(GuacamoleSecurityException e) {
                throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
        } catch(GuacamoleClientException e) {
                throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
        } catch(GuacamoleException e) {
            logger.error("Unexpected GuacamoleException caught adding permission.", e);
    @Path("/remove{userID}/")
import org.glyptodon.guacamole.net.basic.rest.user.UserService;
        bind(UserService.class);
import org.glyptodon.guacamole.net.basic.rest.user.UserRESTService;
        bind(UserRESTService.class);
    public List<APIPermission> convertPermissionList(Iterable<? extends Permission> permissions) {
    /**
     * Check if a session has timed out.
     * @param authToken The auth token for the session.
     * @return True if the session has timed out, false otherwise.
     */
     * Gets a list of users in the system.
     * Gets an individual user.
     * Creates a new user and returns the username.
    public String createUser(@QueryParam("token") String authToken, APIUser user) {
            
            return user.getUsername();
     * Updates an individual existing user.
     * Deletes an individual existing user.
                throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided parentID.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
                throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided parentID.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
                throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
                throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided parentID.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
                throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
                throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided parentID.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
                throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
                throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided ID.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
                throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided ID.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
                throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
                throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided ID.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            if(parentConnectionGroup == null)
                throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            throw new HTTPException(Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            throw new HTTPException(Response.Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Response.Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            throw new HTTPException(Response.Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Response.Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            throw new HTTPException(Response.Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Response.Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            throw new HTTPException(Response.Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Response.Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            throw new HTTPException(Response.Status.UNAUTHORIZED, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Response.Status.BAD_REQUEST, e.getMessage() != null ? e.getMessage() : "Invalid Request.");
            logger.error("Unexpected GuacamoleException caught while creating connection group.", e);
            logger.error("Unexpected GuacamoleException caught updating connection group.", e);
            logger.error("Unexpected GuacamoleException caught moving connection group.", e);
            logger.error("Unexpected GuacamoleException caught removing permission.", e);
            logger.error("Unexpected GuacamoleException caught while listing users.", e);
            logger.error("Unexpected GuacamoleException caught while getting user.", e);
            logger.error("Unexpected GuacamoleException caught while creating user.", e);
            logger.error("Unexpected GuacamoleException caught while updating user.", e);
            logger.error("Unexpected GuacamoleException caught while deleting user.", e);
                throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
                throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");
                throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
                throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");
            // Return the converted connection directory
            return connectionService.convertConnectionList(connectionDirectory);
import org.glyptodon.guacamole.net.auth.Directory;
     *                            connection directory.
    public List<APIConnection> convertConnectionList(Directory<String, Connection> connectionDirectory) 
        for(String connectionID : connectionDirectory.getIdentifiers()) {
            restConnections.add(new APIConnection(connectionDirectory.get(connectionID)));
            // return the converted connection group list
            return connectionGroupService.convertConnectionGroupList(connectionGroupDirectory);
            // Return the connectiion group
            // Move the connection group
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.Directory;
     * @throws GuacamoleException If an error occurs while converting the 
     *                            connection group directory.
            Directory<String, ConnectionGroup> connectionGroupDirectory) throws GuacamoleException {
        for(String connectionGroupID : connectionGroupDirectory.getIdentifiers()) {
            restConnectionGroups.add(new APIConnectionGroup(connectionGroupDirectory.get(connectionGroupID)));
     * Converts a Connection Directory to a list of APIConnection objects for 
     * @param connectionDirectory The Connection Directory to convert for REST endpoint use.
     * Converts a ConnectionGroup directory to a list of APIConnectionGroup
     * @param connectionGroupDirectory The ConnectionGroup Directory to convert for REST endpoint use.
/*
 *  Guacamole - Clientless Remote Desktop
 *  Copyright (C) 2010  Michael Jumper
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 *  Guacamole - Clientless Remote Desktop
 *  Copyright (C) 2010  Michael Jumper
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

        
        // Set the connection ID
        object.setIdentifier(connection.getIdentifier());
        
        // Set the connection group ID
        object.setIdentifier(connectionGroup.getIdentifier());
        
        if(user == null)
            return null;
        return user;
     * Creates a new connection group having the given name and type.
import org.glyptodon.guacamole.properties.LongGuacamoleProperty;
    /**
     * The session timeout for the API, in milliseconds.
     */
    public static final LongGuacamoleProperty API_SESSION_TIMEOUT = new LongGuacamoleProperty() {

        @Override
        public String getName() { return "api-session-timeout"; }

    };

        for(Map.Entry<String, String> entry : parameters.entrySet())
            configuration.setParameter(entry.getKey(), entry.getValue());
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Response.Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Response.Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Response.Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Response.Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
            throw new HTTPException(Response.Status.FORBIDDEN, e.getMessage() != null ? e.getMessage() : "Permission denied.");
import com.google.inject.matcher.Matchers;
        
        bindInterceptor(Matchers.any(), Matchers.annotatedWith(AuthProviderRESTExposure.class), new AuthProviderRESTExceptionWrapper());
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
    @AuthProviderRESTExposure
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
     * @throws GuacamoleException If a problem is encountered while listing connections.
    @AuthProviderRESTExposure
    public List<APIConnection> getConnections(@QueryParam("token") String authToken, @QueryParam("parentID") String parentID) 
            throws GuacamoleException {
        // If the parent connection group is passed in, try to find it.
        ConnectionGroup parentConnectionGroup;
        if(parentID == null)
            parentConnectionGroup = userContext.getRootConnectionGroup();
        else {
            ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
            Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
            parentConnectionGroup = connectionGroupDirectory.get(parentID);

        if(parentConnectionGroup == null)
            throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");

        Directory<String, Connection> connectionDirectory = 
                parentConnectionGroup.getConnectionDirectory();

        // Return the converted connection directory
        return connectionService.convertConnectionList(connectionDirectory);
     * @throws GuacamoleException If a problem is encountered while retrieving the connection.
    @AuthProviderRESTExposure
            @PathParam("connectionID") String connectionID) throws GuacamoleException {
        // Get the connection directory
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        Directory<String, Connection> connectionDirectory =
                rootGroup.getConnectionDirectory();

        // Get the connection
        Connection connection = connectionDirectory.get(connectionID);

        if(connection == null)
            throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");

        return new APIConnection(connection);
     * @throws GuacamoleException If a problem is encountered while deleting the connection.
    @AuthProviderRESTExposure
    public void deleteConnection(@QueryParam("token") String authToken, @PathParam("connectionID") String connectionID) 
            throws GuacamoleException {

        // Get the connection directory
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        Directory<String, Connection> connectionDirectory =
                rootGroup.getConnectionDirectory();

        // Make sure the connection is there before trying to delete
        if(connectionDirectory.get(connectionID) == null)
            throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");

        // Delete the connection
        connectionDirectory.remove(connectionID);
     * @throws GuacamoleException If a problem is encountered while creating the connection.
    @AuthProviderRESTExposure
            @QueryParam("parentID") String parentID, APIConnection connection) throws GuacamoleException {
        if(connection == null)
            throw new GuacamoleClientException("A connection is required for this request.");

        // If the parent connection group is passed in, try to find it.
        ConnectionGroup parentConnectionGroup;
        if(parentID == null)
            parentConnectionGroup = userContext.getRootConnectionGroup();
        else {
            ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
            Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
            parentConnectionGroup = connectionGroupDirectory.get(parentID);

        if(parentConnectionGroup == null)
            throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");

        Directory<String, Connection> connectionDirectory = 
                parentConnectionGroup.getConnectionDirectory();

        // Create the connection
        connectionDirectory.add(new APIConnectionWrapper(connection));

        // Return the new connection identifier
        return connection.getIdentifier();
     * @throws GuacamoleException If a problem is encountered while updating the connection.
    @AuthProviderRESTExposure
            @PathParam("connectionID") String connectionID, APIConnection connection) throws GuacamoleException {
        if(connection == null)
            throw new GuacamoleClientException("A connection is required for this request.");

        // Get the connection directory
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        Directory<String, Connection> connectionDirectory =
                rootGroup.getConnectionDirectory();

        // Make sure the connection is there before trying to update
        if(connectionDirectory.get(connectionID) == null)
            throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");

        // Update the connection
        connectionDirectory.update(new APIConnectionWrapper(connection));
     * @param parentID The ID of the ConnectionGroup the connection is to be moved to.
     * @throws GuacamoleException If a problem is encountered while moving the connection.
    @AuthProviderRESTExposure
            @PathParam("connectionID") String connectionID, @QueryParam("parentID") String parentID) 
            throws GuacamoleException {

        // Get the connection directory
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        Directory<String, Connection> connectionDirectory =
                rootGroup.getConnectionDirectory();

        // Find the new parent connection group
        Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
        ConnectionGroup parentConnectionGroup = connectionGroupDirectory.get(parentID);

        if(parentConnectionGroup == null)
            throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");

        // Move the connection
        connectionDirectory.move(connectionID, parentConnectionGroup.getConnectionDirectory());
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
     * @throws GuacamoleException If a problem is encountered while listing connection groups.
    @AuthProviderRESTExposure
    public List<APIConnectionGroup> getConnectionGroups(@QueryParam("token") String authToken, @QueryParam("parentID") String parentID) 
            throws GuacamoleException {
        // If the parent connection group is passed in, try to find it.
        ConnectionGroup parentConnectionGroup;
        if(parentID == null)
            parentConnectionGroup = userContext.getRootConnectionGroup();
        else {
            ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
            Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
            parentConnectionGroup = connectionGroupDirectory.get(parentID);

        if(parentConnectionGroup == null)
            throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");

        Directory<String, ConnectionGroup> connectionGroupDirectory = 
                parentConnectionGroup.getConnectionGroupDirectory();

        // return the converted connection group list
        return connectionGroupService.convertConnectionGroupList(connectionGroupDirectory);
     * @throws GuacamoleException If a problem is encountered while retrieving the connection group.
    @AuthProviderRESTExposure
            @PathParam("connectionGroupID") String connectionGroupID) throws GuacamoleException {
        // Get the connection group directory
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        Directory<String, ConnectionGroup> connectionGroupDirectory =
                rootGroup.getConnectionGroupDirectory();

        // Get the connection group
        ConnectionGroup connectionGroup = connectionGroupDirectory.get(connectionGroupID);

        if(connectionGroup == null)
            throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided ID.");

        // Return the connectiion group
        return new APIConnectionGroup(connectionGroup);
     * @throws GuacamoleException If a problem is encountered while deleting the connection group.
    @AuthProviderRESTExposure
    public void deleteConnectionGroup(@QueryParam("token") String authToken, 
            @PathParam("connectionGroupID") String connectionGroupID) throws GuacamoleException {

        // Get the connection group directory
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        Directory<String, ConnectionGroup> connectionGroupDirectory =
                rootGroup.getConnectionGroupDirectory();

        // Make sure the connection is there before trying to delete
        if(connectionGroupDirectory.get(connectionGroupID) == null)
            throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided ID.");

        // Delete the connection group
        connectionGroupDirectory.remove(connectionGroupID);
     * @throws GuacamoleException If a problem is encountered while creating the connection group.
    @AuthProviderRESTExposure
            @QueryParam("parentID") String parentID, APIConnectionGroup connectionGroup) throws GuacamoleException {

        if(connectionGroup == null)
            throw new GuacamoleClientException("A connection group is required for this request.");

        // If the parent connection group is passed in, try to find it.
        ConnectionGroup parentConnectionGroup;
        if(parentID == null)
            parentConnectionGroup = userContext.getRootConnectionGroup();
        else {
            ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
            Directory<String, ConnectionGroup> connectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
            parentConnectionGroup = connectionGroupDirectory.get(parentID);

        if(parentConnectionGroup == null)
            throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");

        Directory<String, ConnectionGroup> connectionGroupDirectory = 
                parentConnectionGroup.getConnectionGroupDirectory();

        // Create the connection group
        connectionGroupDirectory.add(new APIConnectionGroupWrapper(connectionGroup));

        // Return the new connection group identifier
        return connectionGroup.getIdentifier();
     * @throws GuacamoleException If a problem is encountered while updating the connection group.
    @AuthProviderRESTExposure
            @PathParam("connectionGroupID") String connectionGroupID, APIConnectionGroup connectionGroup) 
            throws GuacamoleException {
        if(connectionGroup == null)
            throw new GuacamoleClientException("A connection group is required for this request.");

        // Get the connection directory
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        Directory<String, ConnectionGroup> connectionGroupDirectory =
                rootGroup.getConnectionGroupDirectory();

        // Make sure the connection group is there before trying to update
        if(connectionGroupDirectory.get(connectionGroupID) == null)
            throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided ID.");

        // Update the connection group
        connectionGroupDirectory.update(new APIConnectionGroupWrapper(connectionGroup));
     * @param connectionGroupID The ID of the ConnectionGroup to move.
     * @param parentID The ID of the ConnectionGroup the connection group is to be moved to.
     * @throws GuacamoleException If a problem is encountered while moving the connection group.
    @AuthProviderRESTExposure
            @PathParam("connectionGroupID") String connectionGroupID, 
            @QueryParam("parentID") String parentID) throws GuacamoleException {
        // Get the connection group directory
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        Directory<String, ConnectionGroup> connectionGroupDirectory =
                rootGroup.getConnectionGroupDirectory();

        // Find the new parent connection group
        Directory<String, ConnectionGroup> newConnectionGroupDirectory = rootGroup.getConnectionGroupDirectory();
        ConnectionGroup parentConnectionGroup = newConnectionGroupDirectory.get(parentID);

        if(parentConnectionGroup == null)
            throw new HTTPException(Status.NOT_FOUND, "No ConnectionGroup found with the provided parentID.");

        // Move the connection group
        connectionGroupDirectory.move(connectionGroupID, parentConnectionGroup.getConnectionGroupDirectory());
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
     * @throws GuacamoleException If a problem is encountered while listing permissions.
    @AuthProviderRESTExposure
    public List<APIPermission> getPermissions(@QueryParam("token") String authToken, @PathParam("userID") String userID) 
            throws GuacamoleException {

        // Get the user
        User user = userContext.getUserDirectory().get(userID);

        if(user == null)
            throw new HTTPException(Status.NOT_FOUND, "User not found with the provided userID.");

        return permissionService.convertPermissionList(user.getPermissions());
     * @throws GuacamoleException If a problem is encountered while adding the permission.
    @AuthProviderRESTExposure
            @PathParam("userID") String userID, APIPermission permission) 
            throws GuacamoleException {

        // Get the user
        User user = userContext.getUserDirectory().get(userID);

        if(user == null)
            throw new HTTPException(Status.NOT_FOUND, "User not found with the provided userID.");

        // Add the new permission
        user.addPermission(permission.toPermission());
     * @throws GuacamoleException If a problem is encountered while removing the permission.
    @AuthProviderRESTExposure
            @PathParam("userID") String userID, APIPermission permission) 
            throws GuacamoleException {
        // Get the user
        User user = userContext.getUserDirectory().get(userID);

        if(user == null)
            throw new HTTPException(Status.NOT_FOUND, "User not found with the provided userID.");

        // Remove the permission
        user.removePermission(permission.toPermission());
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
     * @throws GuacamoleException If a problem is encountered while listing users.
    @AuthProviderRESTExposure
    public List<APIUser> getUsers(@QueryParam("token") String authToken) throws GuacamoleException {

        // Get the directory
        Directory<String, User> userDirectory = userContext.getUserDirectory();

        // Convert and return the user directory listing
        return userService.convertUserList(userDirectory);
     * @throws GuacamoleException If a problem is encountered while retrieving the user.
    @AuthProviderRESTExposure
    public APIUser getUser(@QueryParam("token") String authToken, @PathParam("userID") String userID) 
            throws GuacamoleException {

        // Get the directory
        Directory<String, User> userDirectory = userContext.getUserDirectory();

        // Get the user
        User user = userDirectory.get(userID);

        if(user == null)
            throw new HTTPException(Response.Status.NOT_FOUND, "User not found with the provided userID.");

        // Return the user
        return new APIUser(user);
     * @throws GuacamoleException If a problem is encountered while creating the user.
    @AuthProviderRESTExposure
    public String createUser(@QueryParam("token") String authToken, APIUser user) 
            throws GuacamoleException {
        // Get the directory
        Directory<String, User> userDirectory = userContext.getUserDirectory();

        // Create the user
        userDirectory.add(new APIUserWrapper(user));

        return user.getUsername();
     * @throws GuacamoleException If a problem is encountered while updating the user.
    @AuthProviderRESTExposure
    public void updateUser(@QueryParam("token") String authToken, @PathParam("userID") String userID, APIUser user) 
            throws GuacamoleException {
        // Get the directory
        Directory<String, User> userDirectory = userContext.getUserDirectory();

        if(!user.getUsername().equals(userID))
            throw new HTTPException(Response.Status.BAD_REQUEST, "Username does not match provided userID.");

        // Get the user
        User existingUser = userDirectory.get(userID);

        if(existingUser == null)
            throw new HTTPException(Response.Status.NOT_FOUND, "User not found with the provided userID.");

        /*
         * Update the user with the permission set from the existing user
         * since the user REST endpoints do not expose permissions
         */
        userDirectory.update(new APIUserWrapper(user, existingUser.getPermissions()));
     * @throws GuacamoleException If a problem is encountered while deleting the user.
    @AuthProviderRESTExposure
    public void deleteUser(@QueryParam("token") String authToken, @PathParam("userID") String userID) 
            throws GuacamoleException {
        // Get the directory
        Directory<String, User> userDirectory = userContext.getUserDirectory();

        // Get the user
        User existingUser = userDirectory.get(userID);

        if(existingUser == null)
            throw new HTTPException(Response.Status.NOT_FOUND, "User not found with the provided userID.");

        // Delete the user
        userDirectory.remove(userID);
                Integer.toString(info.getOptimalScreenHeight()),
                Integer.toString(info.getOptimalResolution())
     * The resolution of the optimal dimensions given, in DPI.
    private int optimalResolution = 96;
    private final List<String> audioMimetypes = new ArrayList<String>();

    /**
     * The list of audio mimetypes reported by the client to be supported.
     */
    private final List<String> videoMimetypes = new ArrayList<String>();
     * Returns the resolution of the screen if the optimal width and height are
     * used, in DPI.
     * 
     * @return The optimal screen resolution.
     */
    public int getOptimalResolution() {
        return optimalResolution;
    }

    /**
     * Sets the resolution of the screen if the optimal width and height are
     * used, in DPI.
     * 
     * @param optimalResolution The optimal screen resolution in DPI.
     */
    public void setOptimalResolution(int optimalResolution) {
        this.optimalResolution = optimalResolution;
    }

    /**
        // Set resolution if provided
        String dpi = request.getParameter("dpi");
        if (dpi != null)
            info.setOptimalResolution(Integer.parseInt(dpi));

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.auth;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.connectiongroups;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.connections;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.connections;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.connections;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.connections;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.connections;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.permissions;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.protocols;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.users;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.users;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.users;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.crud.users;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.event;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.properties;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.properties;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.auth;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.auth;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.auth;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.auth;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.auth;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.auth;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.connection;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.connection;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.connection;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.connectiongroup;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.connectiongroup;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.permission;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.permission;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.rest.user;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.websocket.jetty;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.websocket.jetty;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.websocket.tomcat;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.websocket.tomcat;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.xml;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.xml;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.xml.protocol;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.xml.protocol;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.xml.protocol;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.xml.user_mapping;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.xml.user_mapping;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.xml.user_mapping;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.xml.user_mapping;

 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
package org.glyptodon.guacamole.net.basic.xml.user_mapping;

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package net.sourceforge.guacamole.net.auth.mysql;
package net.sourceforge.guacamole.net.auth.mysql.properties;
package net.sourceforge.guacamole.net.auth.mysql.service;
package net.sourceforge.guacamole.net.auth.mysql.service;
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.glyptodon.guacamole.net.auth;
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*
 * Copyright (C) 2013 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
    private static final Logger logger = LoggerFactory.getLogger(GuacamoleWebSocketTunnelServlet.class);
                            try {
                                while ((readMessage = reader.read()) != null) {
                                    // Buffer message
                                    buffer.append(readMessage);

                                    // Flush if we expect to wait or buffer is getting full
                                    if (!reader.available() || buffer.length() >= BUFFER_SIZE) {
                                        connection.sendMessage(buffer.toString());
                                        buffer.setLength(0);
                                    }


                            // Catch any thrown guacamole exception and attempt
                            // to pass within the WebSocket connection, logging
                            // each error appropriately.
                            catch (GuacamoleSecurityException e) {
                                logger.warn("Authorization failed.", e);
                                connection.close(1008, null); // Policy violation
                            }
                            catch (GuacamoleResourceNotFoundException e) {
                                logger.debug("Resource not found.", e);
                                connection.close(1002, null); // Protocol error
                            }
                            catch (GuacamoleClientException e) {
                                logger.warn("Error in client request.", e);
                                connection.close(1002, null); // Protocol error
                            }
                            catch (GuacamoleException e) {
                                logger.error("Server error in tunnel", e);
                                connection.close(1011, null); // Server error
                            }

import org.apache.catalina.websocket.Constants;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
    private final Logger logger = LoggerFactory.getLogger(GuacamoleWebSocketTunnelServlet.class);
                            // Attempt to read
                            try {
                                while ((readMessage = reader.read()) != null) {
                                    // Buffer message
                                    buffer.append(readMessage);
                                    // Flush if we expect to wait or buffer is getting full
                                    if (!reader.available() || buffer.length() >= BUFFER_SIZE) {
                                        outbound.writeTextMessage(CharBuffer.wrap(buffer));
                                        buffer.setLength(0);
                                    }

                            // Catch any thrown guacamole exception and attempt
                            // to pass within the WebSocket connection, logging
                            // each error appropriately.
                            catch (GuacamoleSecurityException e) {
                                logger.warn("Authorization failed.", e);
                                outbound.close(Constants.STATUS_POLICY_VIOLATION, null);
                            }
                            catch (GuacamoleResourceNotFoundException e) {
                                logger.debug("Resource not found.", e);
                                outbound.close(Constants.STATUS_PROTOCOL_ERROR, null);
                            }
                            catch (GuacamoleClientException e) {
                                logger.warn("Error in client request.", e);
                                outbound.close(Constants.STATUS_PROTOCOL_ERROR, null);
                            }
                            catch (GuacamoleException e) {
                                logger.error("Server error in tunnel", e);
                                outbound.close(Constants.STATUS_UNEXPECTED_CONDITION, null);
                            }

                            logger.debug("I/O error prevents further reads.", e);

                                // Attempt to read

                                // No more data
                                connection.close(1001, null); // Shutdown
                                

                                // Attempt to read

                                // No more data
                                outbound.close(Constants.STATUS_SHUTDOWN, null);
                                
     * @param parentID The ID of the parent connection group for this connection.
        this.setParentIdentifier(String.valueOf(parentID));
        this.setParentID(parentID);
     * @param connectionGroupID The ID to assign to this connection group.
     * @param parentID The ID of the parent connection group for this connection group.
        this.setParentIdentifier(String.valueOf(parentID));
     * @param name The name of this connection group.
        this.setParentID(parentID);
     * The unique identifier of the parent ConnectionGroup for
     * this Connection.
     */
    private String parentIdentifier;

    /**
    public String getParentIdentifier() {
        return parentIdentifier;
    }

    @Override
    public void setParentIdentifier(String parentIdentifier) {
        this.parentIdentifier = parentIdentifier;
    }

    @Override

    /**
     * The unique identifier of the parent connection group for
     * this connection group.
     */
    private String parentIdentifier;

    @Override
    public String getParentIdentifier() {
        return parentIdentifier;
    }

    @Override
    public void setParentIdentifier(String parentIdentifier) {
        this.parentIdentifier = parentIdentifier;
    }
     * @param name The name to assign.
     * Returns the unique identifier of the parent ConnectionGroup for
     * this Connection.
     * 
     * @return The unique identifier of the parent ConnectionGroup for
     * this Connection.
     */
    public String getParentIdentifier();

    /**
     * Sets the unique identifier of the parent ConnectionGroup for
     * this Connection.
     * 
     * @param parentIdentifier The unique identifier of the parent 
     * ConnectionGroup for this Connection.
     */
    public void setParentIdentifier(String parentIdentifier);

    /**
     * @param name The name to assign.

    /**
     * Returns the unique identifier of the parent ConnectionGroup for
     * this ConnectionGroup.
     * 
     * @return The unique identifier of the parent ConnectionGroup for
     * this ConnectionGroup.
     */
    public String getParentIdentifier();

    /**
     * Sets the unique identifier of the parent ConnectionGroup for
     * this ConnectionGroup.
     * 
     * @param parentIdentifier The unique identifier of the parent 
     * ConnectionGroup for this ConnectionGroup.
     */
    public void setParentIdentifier(String parentIdentifier);
     * The identifier of the parent connection group for this connection.
     */
    private String parentIdentifier;
    
    /**
        this.parentIdentifier = connection.getParentIdentifier();
     * @param identifier The unique identifier for this connection.
    
    /**
     * Returns the unique identifier for this connection.
     * @return The unique identifier for this connection.
     */
    public String getParentIdentifier() {
        return parentIdentifier;
    }
    /**
     * Sets the parent connection group identifier for this connection.
     * @param parentIdentifier The parent connection group identifier 
     *                         for this connection.
     */
    public void setParentIdentifier(String parentIdentifier) {
        this.parentIdentifier = parentIdentifier;
    }
    public String getParentIdentifier() {
        return apiConnection.getParentIdentifier();
    }

    @Override
    public void setParentIdentifier(String parentIdentifier) {
        apiConnection.setParentIdentifier(parentIdentifier);
    }

    @Override
     * The identifier of the parent connection group for this connection group.
     */
    private String parentIdentifier;
    
    /**
        this.parentIdentifier = connectionGroup.getParentIdentifier();
    
    /**
     * Returns the unique identifier for this connection group.
     * @return The unique identifier for this connection group.
     */
    public String getParentIdentifier() {
        return parentIdentifier;
    }
    /**
     * Sets the parent connection group identifier for this connection group.
     * @param parentIdentifier The parent connection group identifier 
     *                         for this connection group.
     */
    public void setParentIdentifier(String parentIdentifier) {
        this.parentIdentifier = parentIdentifier;
    }
    public String getParentIdentifier() {
        return apiConnectionGroup.getParentIdentifier();
    }

    @Override
    public void setParentIdentifier(String parentIdentifier) {
        apiConnectionGroup.setParentIdentifier(parentIdentifier);
    }

    @Override
import org.glyptodon.guacamole.io.GuacamoleReader;
            public GuacamoleReader acquireReader() {
                // Monitor instructions which pertain to server-side events
                return new MonitoringGuacamoleReader(listeners, super.acquireReader());
            }

            @Override
     * The session attribute holding the session-scoped clipboard storage.
     */
    public static final String CLIPBOARD_ATTRIBUTE = "GUAC_CLIP";
    
    /**
     * Returns the ClipboardState associated with the given session. If none
     * exists yet, one is created.
     *
     * @param session The session to retrieve the ClipboardState from.
     * @return The ClipboardState associated with the given session.
     */
    public static ClipboardState getClipboardState(HttpSession session) {

        ClipboardState clipboard = (ClipboardState) session.getAttribute(CLIPBOARD_ATTRIBUTE);
        if (clipboard == null) {
            clipboard = new ClipboardState();
            session.setAttribute(CLIPBOARD_ATTRIBUTE, clipboard);
        }

        return clipboard;

    }

    /**
        // Get clipboard 
        final ClipboardState clipboard = AuthenticatingHttpServlet.getClipboardState(httpSession);

                return new MonitoringGuacamoleReader(clipboard, super.acquireReader());
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/ClipboardState.java
 * Copyright (C) 2014 Glyptodon LLC.
 *
 *
 *
package org.glyptodon.guacamole.net.basic;
 * Provides central storage for a cross-connection clipboard state. This
 * clipboard state is shared only for a single HTTP session. Multiple HTTP
 * sessions will all have their own state.
 * 
public class ClipboardState {
     * The current contents.
    private String contents = "";
     * Returns the current clipboard contents.
     * @return The current clipboard contents
    public String getContents() {
        return contents;
    /**
     * Sets the current clipboard contents.
     * @param contents The contents to assign to the clipboard.
     */
    public void setContents(String contents) {
        this.contents = contents;
    
 * maintaining state based on the observed instructions.
    private final ClipboardState clipboard;
     * @param clipboard The clipboard state to maintain.
    public MonitoringGuacamoleReader(ClipboardState clipboard,
        this.clipboard = clipboard;
                clipboard.setContents(args.get(0));

            response.getWriter().print(clipboard.waitForContents(CLIPBOARD_TIMEOUT));
     * The timestamp of the last contents update.
     */
    private long last_update = 0;
    
    /**
    public synchronized void setContents(String contents) {
        last_update = System.currentTimeMillis();
        this.notifyAll();
    }

    /**
     * Wait up to the given timeout for new clipboard data. If data more recent
     * than the timeout period is available, return that.
     * 
     * @param timeout The amount of time to wait, in milliseconds.
     * @return The current clipboard contents.
     */
    public synchronized String waitForContents(int timeout) {

        // Wait for new contents if it's been a while
        if (System.currentTimeMillis() - last_update > timeout) {
            try {
                this.wait(timeout);
            }
            catch (InterruptedException e) { /* ignore */ }
        }

        return getContents();

import org.glyptodon.guacamole.properties.BooleanGuacamoleProperty;
import org.glyptodon.guacamole.properties.GuacamoleProperties;

    /**
     * Whether clipboard integration is enabled.
     */
    public static final BooleanGuacamoleProperty INTEGRATION_ENABLED = new BooleanGuacamoleProperty() {

        @Override
        public String getName() { return "enable-clipboard-integration"; }

    };


        // Only bother if actually enabled
        if (GuacamoleProperties.getProperty(INTEGRATION_ENABLED, false)) {
            // Get clipboard
            final HttpSession session = request.getSession(true);
            final ClipboardState clipboard = getClipboardState(session);

            // Send clipboard contents
            try {
                response.setContentType("text/plain");
                response.getWriter().print(clipboard.waitForContents(CLIPBOARD_TIMEOUT));
            }
            catch (IOException e) {
                throw new GuacamoleServerException("Unable to send clipboard contents", e);
            }

        }


        // Read single instruction, handle end-of-stream
        GuacamoleInstruction instruction = readInstruction();
        if (instruction == null)
            return null;

        return instruction.toString().toCharArray();

        // Read single instruction, handle end-of-stream
        if (instruction == null)
            return null;
    public synchronized String getContents() {
import org.glyptodon.guacamole.protocol.GuacamoleStatus;

    @Override
    public GuacamoleStatus getStatus() {
        return GuacamoleStatus.CLIENT_BAD_REQUEST;
    }

import org.glyptodon.guacamole.protocol.GuacamoleStatus;

    
    /**
     * Returns the Guacamole status associated with this exception. This status
     * can then be easily translated into an HTTP error code or Guacamole
     * protocol error code.
     * 
     * @return The corresponding Guacamole status.
     */
    public GuacamoleStatus getStatus() {
        return GuacamoleStatus.SERVER_ERROR;
    }
    
import org.glyptodon.guacamole.protocol.GuacamoleStatus;

    @Override
    public GuacamoleStatus getStatus() {
        return GuacamoleStatus.RESOURCE_NOT_FOUND;
    }

import org.glyptodon.guacamole.protocol.GuacamoleStatus;

    @Override
    public GuacamoleStatus getStatus() {
        return GuacamoleStatus.CLIENT_FORBIDDEN;
    }

import org.glyptodon.guacamole.protocol.GuacamoleStatus;

     * Creates a new GuacamoleServerException with the given message and cause.
     * Creates a new GuacamoleServerException with the given message.
     * Creates a new GuacamoleServerException with the given cause.
    @Override
    public GuacamoleStatus getStatus() {
        return GuacamoleStatus.SERVER_ERROR;
    }

import org.glyptodon.guacamole.protocol.GuacamoleStatus;
     * Sends an error on the given HTTP response using the information within
     * the given GuacamoleStatus.
     * @param guac_status The status to send
     * @param message A human-readable message that can be presented to the
     *                user.
    public static void sendError(HttpServletResponse response,
            GuacamoleStatus guac_status, String message)
            throws ServletException {
            // If response not committed, send error code and message
            if (!response.isCommitted()) {
                response.addHeader("Guacamole-Status-Code", Integer.toString(guac_status.getGuacamoleStatusCode()));
                response.addHeader("Guacamole-Error-Message", message);
                response.sendError(guac_status.getHttpStatusCode());
            }
            logger.warn("Client request rejected: {}", e.getMessage());
            sendError(response, e.getStatus(), e.getMessage());
            logger.error("Internal server error.", e);
            sendError(response, e.getStatus(), "Internal server error.");
import org.glyptodon.guacamole.protocol.GuacamoleStatus;
     * Sends an error on the given HTTP response using the information within
     * the given GuacamoleStatus.
     * @param guac_status The status to send
    public static void sendError(HttpServletResponse response,
            GuacamoleStatus guac_status, String message)
            throws ServletException {
            // If response not committed, send error code and message
                response.addHeader("Guacamole-Status-Code", Integer.toString(guac_status.getGuacamoleStatusCode()));
                response.sendError(guac_status.getHttpStatusCode());
            logger.warn("Client request rejected: {}", e.getMessage());
            sendError(response, e.getStatus(), e.getMessage());
            sendError(response, e.getStatus(), "Internal server error.");
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
            throw new GuacamoleResourceNotFoundException
            throw new GuacamoleResourceNotFoundException("History record not found.");
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
            throw new GuacamoleUnsupportedException("Connection not from database.");
            throw new GuacamoleResourceNotFoundException("Connection not found.");
            throw new GuacamoleUnsupportedException("Directory not from database");
            throw new GuacamoleResourceNotFoundException("Connection not found.");
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
            throw new GuacamoleUnsupportedException("Connection not from database.");
            throw new GuacamoleResourceNotFoundException("Connection group not found.");
            throw new GuacamoleUnsupportedException("The root connection group cannot be moved.");
            throw new GuacamoleUnsupportedException("Directory not from database");
            throw new GuacamoleResourceNotFoundException("Connection group not found.");
                throw new GuacamoleUnsupportedException("Connection group cycle detected.");
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
            throw new GuacamoleUnsupportedException("Removing your own administrative permissions is not allowed.");
            throw new GuacamoleUnsupportedException("User not from database.");
            throw new GuacamoleUnsupportedException("Deleting your own user is not allowed.");
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.GuacamoleServerBusyException;
                throw new GuacamoleResourceNotFoundException("Invalid connection group ID.");
            throw new GuacamoleResourceNotFoundException("No connections found in group.");
            throw new GuacamoleServerBusyException
            throw new GuacamoleClientTooManyException
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
import org.glyptodon.guacamole.GuacamoleResourceConflictException;
            throw new GuacamoleResourceConflictException("Cannot connect. This connection is in use.");
            throw new GuacamoleClientTooManyException
    SUCCESS(200, 1000, 0x0000),
    UNSUPPORTED(501, 1011, 0x0100),
    SERVER_ERROR(500, 1011, 0x0200),
    SERVER_BUSY(503, 1008, 0x0201),
    UPSTREAM_TIMEOUT(504, 1011, 0x0202),
    UPSTREAM_ERROR(502, 1011, 0x0203),
    RESOURCE_NOT_FOUND(404, 1002, 0x0204),
    RESOURCE_CONFLICT(409, 1008, 0x0205),
    CLIENT_BAD_REQUEST(400, 1002, 0x0300),
    CLIENT_UNAUTHORIZED(401, 1008, 0x0301),
    CLIENT_FORBIDDEN(403, 1008, 0x0303),
    CLIENT_TIMEOUT(408, 1002, 0x0308),
    CLIENT_OVERRUN(413, 1009, 0x030D),
    CLIENT_BAD_TYPE(415, 1003, 0x030F),
    CLIENT_TOO_MANY(429, 1008, 0x031D);
     * The most applicable WebSocket error code.
     */
    private final int websocket_code;
    
    /**
     * @param websocket_code The most applicable WebSocket error code.
    private GuacamoleStatus(int http_code, int websocket_code, int guac_code) {
        this.websocket_code = websocket_code;
     * Returns the most applicable HTTP error code.
     * 
     * @return The most applicable HTTP error code.
     */
    public int getWebSocketCode() {
        return websocket_code;
    }

    /**
import org.glyptodon.guacamole.protocol.GuacamoleStatus;
    /**
     * Sends an error on the given WebSocket connection and closes the
     * connection. The error sent is determined from using the information
     * within the given GuacamoleStatus.
     *
     * @param connection The WebSocket connection to close.
     * @param guac_status The status to send.
     */
    public static void sendError(Connection connection,
            GuacamoleStatus guac_status) {

        connection.close(guac_status.getWebSocketCode(),
                Integer.toString(guac_status.getGuacamoleStatusCode()));

    }

                                logger.warn("Client request rejected: {}", e.getMessage());
                                sendError(connection, e.getStatus());
                                logger.error("Internal server error.", e);
                                sendError(connection, e.getStatus());
import java.nio.ByteBuffer;
import org.glyptodon.guacamole.protocol.GuacamoleStatus;
    /**
     * Sends an error on the given WebSocket connection and closes the
     * connection. The error sent is determined from using the information
     * within the given GuacamoleStatus.
     *
     * @param outbound The outbound WebSocket connection to close.
     * @param guac_status The status to send.
     * @throws IOException If an error prevents proper closure of the WebSocket
     *                     connection.
     */
    public static void sendError(WsOutbound outbound,
            GuacamoleStatus guac_status) throws IOException {

        byte[] message = Integer.toString(guac_status.getGuacamoleStatusCode()).getBytes("UTF-8");
        outbound.close(guac_status.getWebSocketCode(), ByteBuffer.wrap(message));

    }


                                logger.warn("Client request rejected: {}", e.getMessage());
                                sendError(outbound, e.getStatus());
                                logger.error("Internal server error.", e);
                                sendError(outbound, e.getStatus());
     * Sends the given status on the given WebSocket connection and closes the
     * connection.
    public static void closeConnection(Connection connection,
                                closeConnection(connection, GuacamoleStatus.SUCCESS);
                                closeConnection(connection, e.getStatus());
                                closeConnection(connection, e.getStatus());
     * Sends the given status on the given WebSocket connection and closes the
     * connection.
    public static void closeConnection(WsOutbound outbound,
                                closeConnection(outbound, GuacamoleStatus.SUCCESS);
                                closeConnection(outbound, e.getStatus());
                                closeConnection(outbound, e.getStatus());
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
                throw new GuacamoleUnauthorizedException("Not authenticated");
import java.net.SocketTimeoutException;
import org.glyptodon.guacamole.GuacamoleUpstreamTimeoutException;
        catch (SocketTimeoutException e) {
            throw new GuacamoleUpstreamTimeoutException("Connection to guacd timed out.", e);
        }
import java.net.SocketTimeoutException;
import org.glyptodon.guacamole.GuacamoleUpstreamTimeoutException;
        catch (SocketTimeoutException e) {
            throw new GuacamoleUpstreamTimeoutException("Connection timed out.", e);
        }
     * authorized (not yet logged in, for example). As HTTP 401 has implications
     * for HTTP-specific authorization schemes, this status continues to map to
     * HTTP 403 ("Forbidden"). To do otherwise would risk unintended effects.
    CLIENT_UNAUTHORIZED(403, 1008, 0x0301),
    private ActiveConnectionMap activeConnectionMap;
    public void init(GuacamoleSocket socket,
        synchronized (activeConnectionMap) {
            activeConnectionMap.closeConnection(historyID, connectionGroupID);
        }

     * @param group The group to load balance across.
       
        synchronized (activeConnectionMap) {

            // Get the least used connection.
            Integer leastUsedConnectionID = 
                    activeConnectionMap.getLeastUsedConnection(connectionIDs);
            
            if(leastUsedConnectionID == null)
                throw new GuacamoleResourceNotFoundException("No connections found in group.");
            
            if(GuacamoleProperties.getProperty(
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS, false)
                    && activeConnectionMap.isActive(leastUsedConnectionID))
                throw new GuacamoleServerBusyException
                        ("Cannot connect. All connections are in use.");
            
            if(GuacamoleProperties.getProperty(
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS, true)
                    && activeConnectionMap.isConnectionGroupUserActive(group.getConnectionGroupID(), userID))
                throw new GuacamoleClientTooManyException
                        ("Cannot connect. Connection group already in use by this user.");

            // Get the connection 
            MySQLConnection connection = connectionService
                    .retrieveConnection(leastUsedConnectionID, userID);
            
            // Connect to the connection
            return connectionService.connect(connection, info, userID, group.getConnectionGroupID());

        }
            
        synchronized (activeConnectionMap) {
            // If the given connection is active, and multiple simultaneous
            // connections are not allowed, disallow connection
            if(GuacamoleProperties.getProperty(
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS, false)
                    && activeConnectionMap.isActive(connection.getConnectionID()))
                throw new GuacamoleResourceConflictException("Cannot connect. This connection is in use.");
            
            if(GuacamoleProperties.getProperty(
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS, true)
                    && activeConnectionMap.isConnectionUserActive(connection.getConnectionID(), userID))
                throw new GuacamoleClientTooManyException
                        ("Cannot connect. Connection already in use by this user.");
            // Get guacd connection information
            String host = GuacamoleProperties.getRequiredProperty(GuacamoleProperties.GUACD_HOSTNAME);
            int port = GuacamoleProperties.getRequiredProperty(GuacamoleProperties.GUACD_PORT);
            // Get socket
            GuacamoleSocket socket;
            if (GuacamoleProperties.getProperty(GuacamoleProperties.GUACD_SSL, false))
                socket = new ConfiguredGuacamoleSocket(
                    new SSLGuacamoleSocket(host, port),
                    connection.getConfiguration(), info
                );
            else
                socket = new ConfiguredGuacamoleSocket(
                    new InetGuacamoleSocket(host, port),
                    connection.getConfiguration(), info
                );
            // Mark this connection as active
            int historyID = activeConnectionMap.openConnection(connection.getConnectionID(), 
                    userID, connectionGroupID);

                // Return new MySQLGuacamoleSocket
            MySQLGuacamoleSocket mySQLGuacamoleSocket = mySQLGuacamoleSocketProvider.get();
            mySQLGuacamoleSocket.init(socket, historyID, connectionGroupID);
                
            return mySQLGuacamoleSocket;

        }

            if (isOpen())
                activeConnectionMap.closeConnection(historyID, connectionGroupID);

            // Close socket
            socket.close();

        int currentCount = getConnectionUserCount(connectionID, userID);
        int currentCount = getConnectionUserCount(connectionID, userID);
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
        // Otherwise, inform not supported
        else
            throw new GuacamoleUnsupportedException("Clipboard integration not supported");

import org.glyptodon.guacamole.properties.GuacamoleProperties;

                // Monitor instructions which pertain to server-side events, if necessary
                try {
                    if (GuacamoleProperties.getProperty(CaptureClipboard.INTEGRATION_ENABLED, false))
                        return new MonitoringGuacamoleReader(clipboard, super.acquireReader());
                }
                catch (GuacamoleException e) {
                    logger.warn("Clipboard integration disabled due to error.", e);
                }

                // Pass through by default.
                return super.acquireReader();
                
                synchronized (clipboard) {
                    clipboard.waitForContents(CLIPBOARD_TIMEOUT);
                    response.setContentType(clipboard.getMimetype());
                    response.getOutputStream().write(clipboard.getContents());
                }
     * The maximum number of bytes to track.
     */
    private static final int MAXIMUM_LENGTH = 262144;

     /**
     * The mimetype of the current contents.
     */
    private String mimetype = "text/plain";

    /**
     * The mimetype of the pending contents.
     */
    private String pending_mimetype = "text/plain";
    
    /**
    private byte[] contents = new byte[0];
     * The pending clipboard contents.
     */
    private final byte[] pending = new byte[MAXIMUM_LENGTH];

    /**
     * The length of the pending data, in bytes.
     */
    private int pending_length = 0;
    
    /**
    public synchronized byte[] getContents() {
     * Returns the mimetype of the current clipboard contents.
     * @return The mimetype of the current clipboard contents.
    public synchronized String getMimetype() {
        return mimetype;
     * Begins a new update of the clipboard contents. The actual contents will
     * not be saved until commit() is called.
     * 
     * @param mimetype The mimetype of the contents being added.
     */
    public synchronized void begin(String mimetype) {
        pending_length = 0;
        this.pending_mimetype = mimetype;
    }

    /**
     * Appends the given data to the clipboard contents.
     * 
     * @param data The raw data to append.
     */
    public synchronized void append(byte[] data) {

        // Calculate size of copy
        int length = data.length;
        int remaining = pending.length - pending_length;
        if (remaining < length)
            length = remaining;
    
        // Append data
        System.arraycopy(data, 0, pending, pending_length, length);
        pending_length = length;

    }

    /**
     * Commits the pending contents to the clipboard, notifying any threads
     * waiting for clipboard updates.
     */
    public synchronized void commit() {

        // Commit contents
        mimetype = pending_mimetype;
        contents = new byte[pending_length];
        System.arraycopy(pending, 0, contents, 0, pending_length);

        // Notify of update
        last_update = System.currentTimeMillis();
        this.notifyAll();

    }
    
    /**
     * Wait up to the given timeout for new clipboard data.
     * @return true if the contents were updated within the timeframe given,
     *         false otherwise.
    public synchronized boolean waitForContents(int timeout) {
                return true;
        return false;
import javax.xml.bind.DatatypeConverter;
     * The index of the clipboard stream, if any.
     */
    private String clipboard_stream_index = null;
    
    /**
        // If clipboard changing, reset clipboard state
            if (args.size() >= 2) {
                clipboard_stream_index = args.get(0);
                clipboard.begin(args.get(1));
            }
        }

        // Add clipboard blobs to existing streams
        else if (instruction.getOpcode().equals("blob")) {
            List<String> args = instruction.getArgs();
            if (args.size() >= 2 && args.get(0).equals(clipboard_stream_index)) {
                String base64 = args.get(1);
                clipboard.append(DatatypeConverter.parseBase64Binary(base64));
            }
        }
        
        // Terminate and update clipboard at end of stream
        else if (instruction.getOpcode().equals("end")) {
            List<String> args = instruction.getArgs();
            if (args.size() >= 1 && args.get(0).equals(clipboard_stream_index)) {
                clipboard.commit();
                clipboard_stream_index = null;
            }
        myBatisProperties.setProperty("mybatis.pooled.pingEnabled", "true");
        myBatisProperties.setProperty("mybatis.pooled.pingQuery", "SELECT 1");
     * Whether this connection is currently active.
     */
    private boolean active;
    
    /**
     * @param active Whether the connection is currently active.
            String username, boolean active) {
        this.active = active;
        return active;
        // Determine whether connection is currently active
        int user_count = activeConnectionMap.getCurrentUserCount(connectionID);



            // If there are active users, list the top N not-ended connections
            // as active (best guess)
            MySQLConnectionRecord connectionRecord;
            if (user_count > 0 && endDate == null) {
                connectionRecord = new MySQLConnectionRecord(startDate, endDate, username, true);
                user_count--;
            }

            // If no active users, or end date is recorded, connection is not
            // active.
            else
                connectionRecord = new MySQLConnectionRecord(startDate, endDate, username, false);


        "vnc", "rdp", "ssh", "telnet"};
     * The unique identifier associated with this connection, as determined
     * by the "ready" instruction received from the Guacamole proxy.
     */
    private String id;
    
    /**
     * Waits for the instruction having the given opcode, returning that
     * instruction once it has been read. If the instruction is never read,
     * an exception is thrown.
     * 
     * @param reader The reader to read instructions from.
     * @param opcode The opcode of the instruction we are expecting.
     * @return The instruction having the given opcode.
     * @throws GuacamoleException If an error occurs while reading, or if
     *                            the expected instruction is not read.
     */
    private GuacamoleInstruction expect(GuacamoleReader reader, String opcode)
        throws GuacamoleException {

        // Wait for an instruction
        GuacamoleInstruction instruction = reader.readInstruction();
        if (instruction == null)
            throw new GuacamoleServerException("End of stream while waiting for \""  opcode  "\".");

        // Ensure instruction has expected opcode
        if (!instruction.getOpcode().equals(opcode))
            throw new GuacamoleServerException("Expected \""  opcode  "\" instruction but instead received \""  instruction.getOpcode()  "\".");

        return instruction;

    }
 
    /**
        GuacamoleInstruction args = expect(reader, "args");
        List<String> arg_names = args.getArgs();
        // Wait for ready, store ID
        GuacamoleInstruction ready = expect(reader, "ready");

        List<String> ready_args = ready.getArgs();
        if (ready_args.isEmpty())
            throw new GuacamoleServerException("No connection ID received");

        id = ready.getArgs().get(0);

    /**
     * Returns the unique ID associated with the Guacamole connection
     * negotiated by this ConfiguredGuacamoleSocket. The ID is provided by
     * the "ready" instruction returned by the Guacamole proxy.
     * 
     * @return The ID of the negotiated Guacamole connection.
     */
    public String getConnectionID() {
        return id;
    }

import javax.xml.bind.DatatypeConverter;
                // If no username/password given, try Authorization header
                if (username == null && password == null) {

                    String authorization = request.getHeader("Authorization");
                    if (authorization != null && authorization.startsWith("Basic ")) {

                        // Decode base64 authorization
                        String basicBase64 = authorization.substring(6);
                        String basicCredentials = new String(DatatypeConverter.parseBase64Binary(basicBase64), "UTF-8");

                        // Pull username/password from auth data
                        int colon = basicCredentials.indexOf(':');
                        if (colon != -1) {
                            username = basicCredentials.substring(0, colon);
                            password = basicCredentials.substring(colon1);
                        }

                        else
                            logger.warn("Invalid HTTP Basic \"Authorization\" header received.");

                    }

                } // end Authorization header fallback
                
    /**
     * Whether HTTP authentication should be used (the "Authorization" header).
     */
    private boolean useHttpAuthentication;

        // Parse Guacamole configuration

            // Get auth provider instance

            // Enable HTTP auth, if requested
            useHttpAuthentication = GuacamoleProperties.getProperty(BasicGuacamoleProperties.ENABLE_HTTP_AUTH, false);

            logger.error("Error reading Guacamole configuration.", e);
                if (useHttpAuthentication && username == null && password == null) {
import org.glyptodon.guacamole.properties.BooleanGuacamoleProperty;
     * Whether HTTP "Authorization" headers should be taken into account when
     * authenticating the user. By default, "Authorization" headers are
     * ignored.
     */
    public static final BooleanGuacamoleProperty ENABLE_HTTP_AUTH = new BooleanGuacamoleProperty() {

        @Override
        public String getName() { return "enable-http-auth"; }

    };

    /**
        // Get protocol / connection ID
        String select_arg = config.getConnectionID();
        if (select_arg == null)
            select_arg = config.getProtocol();

        // Send requested protocol or connection ID
        writer.writeInstruction(new GuacamoleInstruction("select", select_arg));
     * The ID of the connection being joined. If this value is present,
     * the protocol need not be specified.
     */
    private String connectionID;
    
    /**
     * Returns the ID of the connection being joined, if any. If no connection
     * is being joined, this returns null, and the protocol must be set.
     *
     * @return The ID of the connection being joined, or null if no connection
     *         is being joined.
     */
    public String getConnectionID() {
        return connectionID;
    }

    /**
     * Sets the ID of the connection being joined, if any. If no connection
     * is being joined, this value must be omitted, and the protocol must be
     * set instead.
     *
     * @param connectionID The ID of the connection being joined.
     */
    public void setConnectionID(String connectionID) {
        this.connectionID = connectionID;
    }

    /**
     * Creates a new GuacamoleInstruction having the given Operation and
     * list of arguments values. The list given will be used to back the
     * internal list of arguments and the list returned by getArgs().
     *
     * @param opcode The opcode of the instruction to create.
     * @param args The list of argument values to provide in the new
     *             instruction if any.
     */
    public GuacamoleInstruction(String opcode, List<String> args) {
        this.opcode = opcode;
        this.args = Collections.unmodifiableList(args);
    }

    /**
        super.init();
        super.init();
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/AuthenticatingFilter.java
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
 * Filter which provides watches requests for credentials, authenticating the
 * user against the configured AuthenticationProvider if credentials are
 * present. Note that if authentication fails, the request is still allowed. To
 * restrict access based on the result of authentication, use
 * RestrictedHttpServlet or RestrictedFilter.
public class AuthenticatingFilter implements Filter {
    private final Logger logger = LoggerFactory.getLogger(AuthenticatingFilter.class);
    public void init(FilterConfig config) throws ServletException {

    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)
       
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;
                else if (!notifySuccess(listeners, context, credentials))
            chain.doFilter(request, response);
    @Override
    public void destroy() {
        // No destruction needed
    }
public class BasicGuacamoleTunnelServlet extends GuacamoleHTTPTunnelServlet {
    private static final Logger logger = LoggerFactory.getLogger(BasicGuacamoleTunnelServlet.class);
    protected GuacamoleTunnel doConnect(HttpServletRequest request) throws GuacamoleException {
        return BasicTunnelRequestUtility.createTunnel(request);
public class BasicLogin extends RestrictedHttpServlet {
    private final Logger logger = LoggerFactory.getLogger(BasicLogin.class);
    protected void restrictedService(
    private static final Logger logger = LoggerFactory.getLogger(BasicTunnelRequestUtility.class);
        final Credentials credentials = AuthenticatingFilter.getCredentials(httpSession);
        final UserContext context = AuthenticatingFilter.getUserContext(httpSession);
        final ClipboardState clipboard = AuthenticatingFilter.getClipboardState(httpSession);
public class CaptureClipboard extends RestrictedHttpServlet {
    protected void restrictedService(
            final ClipboardState clipboard = AuthenticatingFilter.getClipboardState(session);
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Create extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Delete extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class List extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Move extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Update extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Create extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Delete extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class List extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Move extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Update extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class List extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class List extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Create extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Delete extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class List extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
public class Update extends RestrictedHttpServlet {
    protected void restrictedService(
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
import org.glyptodon.guacamole.net.basic.AuthenticatingFilter;
    private final Logger logger = LoggerFactory.getLogger(AuthenticatingWebSocketServlet.class);
    private final RestrictedHttpServlet auth_servlet = new RestrictedHttpServlet() {
        protected void restrictedService(UserContext context,
        UserContext context = AuthenticatingFilter.getUserContext(session);
     * @return A connected WebSocket.
import org.glyptodon.guacamole.net.basic.RestrictedHttpServlet;
import org.glyptodon.guacamole.net.basic.AuthenticatingFilter;
    private final Logger logger = LoggerFactory.getLogger(AuthenticatingWebSocketServlet.class);
    private final RestrictedHttpServlet auth_servlet = new RestrictedHttpServlet() {
        protected void restrictedService(UserContext context,
        UserContext context = AuthenticatingFilter.getUserContext(session);
     * @return A completed WebSocket connection.
 * Tunnel servlet implementation which uses WebSocket as a tunnel backend,
 * rather than HTTP, properly parsing connection IDs included in the connection
 * request.
public class BasicGuacamoleWebSocketTunnelServlet extends GuacamoleWebSocketTunnelServlet {
    protected GuacamoleTunnel doConnect(HttpServletRequest request)
            throws GuacamoleException {
        return BasicTunnelRequestUtility.createTunnel(request);
 * Tunnel servlet implementation which uses WebSocket as a tunnel backend,
 * rather than HTTP, properly parsing connection IDs included in the connection
 * request.
public class BasicGuacamoleWebSocketTunnelServlet extends GuacamoleWebSocketTunnelServlet {
    protected GuacamoleTunnel doConnect(HttpServletRequest request)
            throws GuacamoleException {
        return BasicTunnelRequestUtility.createTunnel(request);
    };
import java.util.List;
    protected String selectSubProtocol(List<String> subProtocols) {

        // Search for expected protocol
        for (String protocol : subProtocols)
            if ("guacamole".equals(protocol))
                return "guacamole";
        
        // Otherwise, fail
        return null;

    }

    @Override
import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
    @OnOpen
        // Manually register message handler
                GuacamoleWebSocketTunnelEndpoint.this.onMessage(message);
        // Prepare read transfer thread
    @OnMessage
    public void onMessage(String message) {

        GuacamoleWriter writer = tunnel.acquireWriter();

        try {
            // Write received message
            writer.write(message.toCharArray());
        }
        catch (GuacamoleException e) {
            logger.debug("Tunnel write failed.", e);
        }

        tunnel.releaseWriter();

    }
    
    @OnClose
        return BasicTunnelRequestUtility.createTunnel(new HTTPTunnelRequest(request));
import java.util.List;
    
     * @param request The request describing the tunnel to create.
    public static GuacamoleTunnel createTunnel(TunnelRequest request)
        HttpSession httpSession = request.getSession();
        if (httpSession == null)
            throw new GuacamoleSecurityException("Cannot connect - user not logged in.");
        TunnelRequest.IdentifierType id_type = TunnelRequest.IdentifierType.getType(id);
        List<String> audio_mimetypes = request.getParameterValues("audio");
            info.getAudioMimetypes().addAll(audio_mimetypes);
        List<String> video_mimetypes = request.getParameterValues("video");
            info.getVideoMimetypes().addAll(video_mimetypes);
                logger.info("Successful connection from to \"{}\".", id);
                logger.info("Successful connection to group \"{}\".", id);
import org.glyptodon.guacamole.net.basic.HTTPTunnelRequest;
        return BasicTunnelRequestUtility.createTunnel(new HTTPTunnelRequest(request));
import org.glyptodon.guacamole.net.basic.HTTPTunnelRequest;
        return BasicTunnelRequestUtility.createTunnel(new HTTPTunnelRequest(request));
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/websocket/GuacamoleWebSocketTunnelEndpoint.java
package org.glyptodon.guacamole.websocket;
    protected abstract GuacamoleTunnel createTunnel(Session session, EndpointConfig config)
            throws GuacamoleException;
import org.glyptodon.guacamole.websocket.GuacamoleWebSocketTunnelEndpoint;
    public Class<?> findClass(String name) throws ClassNotFoundException {
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/websocket/BasicGuacamoleWebSocketTunnelEndpoint.java
package org.glyptodon.guacamole.net.basic.websocket;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/websocket/WebSocketSupportLoader.java
package org.glyptodon.guacamole.net.basic.websocket;
import org.glyptodon.guacamole.net.basic.GuacamoleClassLoader;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/websocket/WebSocketTunnelRequest.java
package org.glyptodon.guacamole.net.basic.websocket;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/websocket/package-info.java
package org.glyptodon.guacamole.net.basic.websocket;
    private final Logger logger = LoggerFactory.getLogger(WebSocketSupportLoader.class);
        // If no such servlet class, this particular WebSocket support
        // is not present
        catch (ClassNotFoundException e) {}
        catch (NoClassDefFoundError e) {}
        // Failing that, try to load websocket support for Tomcat
        loadWebSocketTunnel(sce.getServletContext(), TOMCAT_WEBSOCKET);
     * Classnames of all legacy (non-JSR) WebSocket tunnel implementations.
    private static final String[] WEBSOCKET_CLASSES = {
        "org.glyptodon.guacamole.net.basic.websocket.jetty8.BasicGuacamoleWebSocketTunnelServlet",
        "org.glyptodon.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet"
    };
        // Try to load each WebSocket tunnel in sequence
        for (String classname : WEBSOCKET_CLASSES) {
            if (loadWebSocketTunnel(sce.getServletContext(), classname)) {
                logger.info("Legacy (non-JSR) WebSocket support loaded: {}", classname);
                return;
            }
        }
        // No legacy WebSocket support found (usually good)
        logger.debug("Legacy WebSocket support NOT loaded.");
        "org.glyptodon.guacamole.net.basic.websocket.jetty9.BasicGuacamoleWebSocketTunnelServlet",
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/websocket/jetty9/BasicGuacamoleWebSocketTunnelListener.java
 * Copyright (C) 2014 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.websocket.jetty9;
import org.eclipse.jetty.websocket.api.Session;
 * WebSocket listener implementation which properly parses connection IDs
 * included in the connection request.
 * 
 * @author Michael Jumper
public class BasicGuacamoleWebSocketTunnelListener extends GuacamoleWebSocketTunnelListener {
    protected GuacamoleTunnel createTunnel(Session session) throws GuacamoleException {
        return BasicTunnelRequestUtility.createTunnel(new WebSocketTunnelRequest(session.getUpgradeRequest()));
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/websocket/jetty9/BasicGuacamoleWebSocketTunnelServlet.java
 * Copyright (C) 2014 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.websocket.jetty9;

import org.eclipse.jetty.websocket.servlet.WebSocketServlet;
import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;

 * A WebSocketServlet partial re-implementation of GuacamoleTunnelServlet.
 *
 * @author Michael Jumper
public class BasicGuacamoleWebSocketTunnelServlet extends WebSocketServlet {

    @Override
    public void configure(WebSocketServletFactory factory) {

        // Register WebSocket implementation
        factory.setCreator(new BasicGuacamoleWebSocketCreator());
        
    }
    
}
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/websocket/jetty9/package-info.java
 * Copyright (C) 2014 Glyptodon LLC
 * Jetty 9 WebSocket tunnel implementation. The classes here require at least
 * Jetty 9, prior to Jetty 9.1 (when support for JSR 356 was implemented).
package org.glyptodon.guacamole.net.basic.websocket.jetty9;

        String[] values = request.getParameterValues(name);
        if (values == null)
            return null;
        
        return Arrays.asList(values);

        String[] values = handshakeParameters.get(name);
        if (values == null)
            return null;

        return Arrays.asList(values);
                // Do not start connection if tunnel does not exist
                if (tunnel == null) {
                    closeConnection(connection, GuacamoleStatus.RESOURCE_NOT_FOUND);
                    return;
                }

                    if (tunnel != null)
                        tunnel.close();
    /**
     * Called whenever the JavaScript Guacamole client makes a connection
     * request. It it up to the implementor of this function to define what
     * conditions must be met for a tunnel to be configured and returned as a
     * result of this connection request (whether some sort of credentials must
     * be specified, for example).
     *
     * @param request The HttpServletRequest associated with the connection
     *                request received. Any parameters specified along with
     *                the connection request can be read from this object.
     * @return A newly constructed GuacamoleTunnel if successful,
     *         null otherwise.
     * @throws GuacamoleException If an error occurs while constructing the
     *                            GuacamoleTunnel, or if the conditions
     *                            required for connection are not met.
     */
                // Do not start connection if tunnel does not exist
                if (tunnel == null) {
                    try {
                        closeConnection(outbound, GuacamoleStatus.RESOURCE_NOT_FOUND);
                    }
                    catch (IOException e) {
                        logger.debug("Tunnel not found, but unable to signal closure of WebSocket.", e);
                    }
                    return;
                }

                    if (tunnel != null)
                        tunnel.close();
    /**
     * Called whenever the JavaScript Guacamole client makes a connection
     * request. It it up to the implementor of this function to define what
     * conditions must be met for a tunnel to be configured and returned as a
     * result of this connection request (whether some sort of credentials must
     * be specified, for example).
     *
     * @param request The HttpServletRequest associated with the connection
     *                request received. Any parameters specified along with
     *                the connection request can be read from this object.
     * @return A newly constructed GuacamoleTunnel if successful,
     *         null otherwise.
     * @throws GuacamoleException If an error occurs while constructing the
     *                            GuacamoleTunnel, or if the conditions
     *                            required for connection are not met.
     */

        // Warn of lack of WebSocket
        logger.warn("Using HTTP tunnel (not WebSocket). Performance may be sub-optimal.");
        
    /**
     * Checks for JSR 356 support, returning true if such support is found, and
     * false otherwise.
     *
     * @return true if support for JSR 356 is found, false otherwise.
     */
    private boolean implementsJSR_356() {

        try {

            // Attempt to find WebSocket servlet
            GuacamoleClassLoader.getInstance().findClass("javax.websocket.Endpoint");

            // JSR 356 found
            return true;

        }

        // If no such servlet class, this particular WebSocket support
        // is not present
        catch (ClassNotFoundException e) {}
        catch (NoClassDefFoundError e) {}

        // Log all GuacamoleExceptions
        catch (GuacamoleException e) {
            logger.error("Unable to load/detect WebSocket support.", e);
        }
        
        // JSR 356 not found
        return false;
        
    }
    
        // Check for JSR 356 support
        if (implementsJSR_356()) {
            logger.info("JSR-356 WebSocket support present.");
            return;
        }
        
        // Warn of lack of WebSocket
        logger.debug("WebSocket support NOT present. Only HTTP will be used.");
    private final Map<String, String> parameters = new HashMap<String, String>();

    /**
     * Creates a new, blank GuacamoleConfiguration with its protocol, connection
     * ID, and parameters unset.
     */
    public GuacamoleConfiguration() {
    }

    /**
     * Copies the given GuacamoleConfiguration, creating a new, indepedent
     * GuacamoleConfiguration containing the same protocol, connection ID,
     * and parameter values, if any.
     *
     * @param config The GuacamoleConfiguration to copy.
     */
    public GuacamoleConfiguration(GuacamoleConfiguration config) {

        // Copy protocol and connection ID
        protocol = config.getProtocol();
        connectionID = config.getConnectionID();

        // Copy parameter values
        for (String name : config.getParameterNames())
            parameters.put(name, config.getParameter(name));

    }
import java.net.SocketException;
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
        catch (SocketException e) {
            throw new GuacamoleConnectionClosedException("Connection to guacd is closed.", e);
        }
import java.net.SocketException;
import java.net.SocketTimeoutException;
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
import org.glyptodon.guacamole.GuacamoleUpstreamTimeoutException;
        catch (SocketTimeoutException e) {
            throw new GuacamoleUpstreamTimeoutException("Connection to guacd timed out.", e);
        }
        catch (SocketException e) {
            throw new GuacamoleConnectionClosedException("Connection to guacd is closed.", e);
        }
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
                    throw new GuacamoleConnectionClosedException("Tunnel reached end of stream.");
            // Send end-of-stream marker if connection is closed
            catch (GuacamoleConnectionClosedException e) {
                out.write("0.;");
                out.flush();
                response.flushBuffer();
            }

            catch (GuacamoleException e) {

                // Detach and close
                session.detachTunnel(tunnel);
                tunnel.close();

                throw e;
            }

        catch (GuacamoleConnectionClosedException e) {
            logger.debug("Connection closed.", e);
        }
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
                    catch (GuacamoleConnectionClosedException e) {
                        logger.debug("Connection closed.", e);
                        closeConnection(session, GuacamoleStatus.SUCCESS);
                    }
        catch (GuacamoleConnectionClosedException e) {
            logger.debug("Connection closed.", e);
        }
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
                catch (GuacamoleConnectionClosedException e) {
                    logger.debug("Connection closed.", e);
                }
                            catch (GuacamoleConnectionClosedException e) {
                                logger.debug("Connection closed.", e);
                                closeConnection(connection, GuacamoleStatus.SUCCESS);
                            }
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
                    catch (GuacamoleConnectionClosedException e) {
                        logger.debug("Connection closed.", e);
                        closeConnection(session, GuacamoleStatus.SUCCESS);
                    }
        catch (GuacamoleConnectionClosedException e) {
            logger.debug("Connection closed.", e);
        }
import org.glyptodon.guacamole.GuacamoleConnectionClosedException;
                catch (GuacamoleConnectionClosedException e) {
                    logger.debug("Connection closed.", e);
                }
                            catch (GuacamoleConnectionClosedException e) {
                                logger.debug("Connection closed.", e);
                                closeConnection(outbound, GuacamoleStatus.SUCCESS);
                            }
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
        catch (GuacamoleUnsupportedException e) {
            logger.debug("Unsupported operation.", e);
            sendError(response, e.getStatus(), e.getMessage());
        }
            logger.warn("HTTP tunnel request rejected: {}", e.getMessage());
            logger.error("HTTP tunnel request failed: {}", e.getMessage());
            logger.debug("Internal error in HTTP tunnel.", e);
            logger.debug("Unable to close WebSocket connection.", e);
            logger.error("Connection failed: {}", e.getMessage());
            logger.debug("Error connecting WebSocket tunnel.", e);
                        logger.error("Connection terminated abnormally: {}", e.getMessage());
                        logger.debug("Internal error during connection.", e);
            logger.error("Unable to read Guacamole configuration: {}", e.getMessage());
            logger.debug("Error reading Guacamole configuration.", e);
                logger.debug("Error notifying AuthenticationFailureListener: {}", e);
            logger.error("Authentication failed internally: {}", e.getMessage());
            logger.debug("Internal server error.", e);
            logger.error("Authentication canceled: failed to retrieve listeners: {}", e.getMessage());
            logger.debug("Error retrieving listeners.", e);
            logger.error("Request failed: {}", e.getMessage());
            logger.debug("Internal server error.", e);
                    logger.error("Unable to read \"{}\": {}", file.getAbsolutePath(), e.getMessage());
                    logger.debug("Error reading protocol XML.", e);
            logger.error("Unable to load/detect WebSocket support: {}", e.getMessage());
            logger.debug("Error loading/detecting WebSocket support.", e);
                logger.error("Unable to load WebSocket tunnel servlet: {}", e.getMessage());
                logger.debug("Error loading WebSocket tunnel servlet.", e);
                logger.error("Unable to load WebSocket tunnel servlet: {}", e.getMessage());
                logger.debug("Error loading WebSocket tunnel servlet.", e);
            logger.error("Unable to load/detect WebSocket support: {}", e.getMessage());
            logger.debug("Error loading/detecting WebSocket support.", e);
            logger.error("Connection failed: {}", e.getMessage());
            logger.debug("Error connecting WebSocket tunnel.", e);
                                logger.error("Connection terminated abnormally: {}", e.getMessage());
                                logger.debug("Internal error during connection.", e);
            logger.debug("Unable to close WebSocket connection.", e);
            logger.error("Connection failed: {}", e.getMessage());
            logger.debug("Error connecting WebSocket tunnel.", e);
                        logger.error("Connection terminated abnormally: {}", e.getMessage());
                        logger.debug("Internal error during connection.", e);
            logger.error("Connection failed: {}", e.getMessage());
            logger.debug("Error connecting WebSocket tunnel.", e);
                                logger.error("Connection terminated abnormally: {}", e.getMessage());
                                logger.debug("Internal error during connection.", e);
import org.glyptodon.guacamole.GuacamoleServerException;
        // Require username
        if (credentials.getUsername() == null) {
            logger.debug("Anonymous bind is not currently allowed by the LDAP authentication provider.");
            return null;
        }

        // Require password, and do not allow anonymous binding
        if (credentials.getPassword() == null
                || credentials.getPassword().length() == 0) {
            logger.debug("Anonymous bind is not currently allowed by the LDAP authentication provider.");
            return null;
        }

        // Connect to LDAP server
        LDAPConnection ldapConnection;
            ldapConnection = new LDAPConnection();
        }
        catch (LDAPException e) {
            throw new GuacamoleServerException("Unable to connect to LDAP server.", e);
        }
        // Get username attribute
        String username_attribute = GuacamoleProperties.getRequiredProperty(
            LDAPGuacamoleProperties.LDAP_USERNAME_ATTRIBUTE
        );
        // Get user base DN
        String user_base_dn = GuacamoleProperties.getRequiredProperty(
                LDAPGuacamoleProperties.LDAP_USER_BASE_DN
        );

        // Construct user DN
        String user_dn =
            escapeDN(username_attribute)  "="  escapeDN(credentials.getUsername())
             ","  user_base_dn;

        try {
        }
        catch (LDAPException e) {
            logger.debug("LDAP bind failed.", e);
            return null;
        }

        // Get config base DN
        String config_base_dn = GuacamoleProperties.getRequiredProperty(
                LDAPGuacamoleProperties.LDAP_CONFIG_BASE_DN
        );

        // Pull all connections
        try {
            throw new GuacamoleServerException("Error while querying for connections.", e);
                else
import java.util.regex.Pattern;
    /**
     * Regular expression which matches any IPv4 address.
     */
    private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";

    /**
     * Regular expression which matches any IPv6 address.
     */
    private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";

    /**
     * Regular expression which matches any IP address, regardless of version.
     */
    private static final String IP_ADDRESS_REGEX = "("  IPV4_ADDRESS_REGEX  "|"  IPV6_ADDRESS_REGEX  ")";
    
    /**
     * Pattern which matches valid values of the de-facto standard
     * "X-Forwarded-For" header.
     */
    private static final Pattern X_FORWARDED_FOR = Pattern.compile("^"  IP_ADDRESS_REGEX  "(, "  IP_ADDRESS_REGEX  ")*$");

    /**
     * Returns a formatted string containing an IP address, or list of IP
     * addresses, which represent the HTTP client and any involved proxies. As
     * the headers used to determine proxies can easily be forged, this data is
     * superficially validated to ensure that it at least looks like a list of
     * IPs.
     *
     * @param request The HTTP request to format.
     * @return A formatted string containing one or more IP addresses.
     */
    private String getLoggableAddress(HttpServletRequest request) {

        // Log X-Forwarded-For, if present and valid
        String header = request.getHeader("X-Forwarded-For");
        if (header != null && X_FORWARDED_FOR.matcher(header).matches())
            return "["  header  ", "  request.getRemoteAddr()  "]";

        // If header absent or invalid, just use source IP
        return request.getRemoteAddr();
        
    }
    
                    if (context != null && logger.isInfoEnabled())
                                context.self().getUsername(), getLoggableAddress(request));

                    if (logger.isWarnEnabled())
                        logger.warn("Authentication attempt from {} for user \"{}\" failed.",
                                getLoggableAddress(request), credentials.getUsername());
                logger.info("Successful connection to \"{}\".", id);
        return new SimpleUserContext(credentials.getUsername(), configs);
import java.util.UUID;
     * configurations within the given Map. The username is assigned
     * arbitrarily.
        this(UUID.randomUUID().toString(), configs);
    }

    /**
     * Creates a new SimpleUserContext for the user with the given username
     * which provides access to only those configurations within the given Map.
      * 
     * @param username The username of the user associated with this
     *                 UserContext.
     * @param configs A Map of all configurations for which the user associated
     *                with this UserContext has read access.
     */
    public SimpleUserContext(String username, Map<String, GuacamoleConfiguration> configs) {
        this.self = new SimpleUser(username,
        logger.debug("Reading configuration file: \"{}\"", configFile);
            throw new GuacamoleServerException("Error reading configuration file.", e);
            throw new GuacamoleServerException("Error parsing XML file.", e);
                    logger.debug("Configuration file \"{}\" has been modified.", configFile);
            logger.debug("Connection to guacd closed.", e);
            logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
                        logger.info("WebSocket connection terminated: {}", e.getMessage());
                        logger.debug("WebSocket connection terminated due to client error.", e);
                        logger.debug("Connection to guacd closed.", e);
                        logger.error("Connection to guacd terminated abnormally: {}", e.getMessage());
                        logger.debug("Internal error during connection to guacd.", e);
            logger.debug("Connection to guacd closed.", e);
            logger.debug("WebSocket tunnel write failed.", e);
            logger.debug("Reading user mapping file: \"{}\"", user_mapping_file);
            logger.error("Unable to read guacamole.properties: {}", e.getMessage());
            logger.debug("Error reading guacamole.properties.", e);
                            logger.info("Invalid HTTP Basic \"Authorization\" header received.");
                    if (logger.isWarnEnabled()) {

                        // Only bother logging failures involving usernames
                        if (credentials.getUsername() != null)
                            logger.info("Authentication attempt from {} for user \"{}\" failed.",
                                    getLoggableAddress(request), credentials.getUsername());
                        else
                            logger.debug("Authentication attempt from {} without username failed.",
                                    getLoggableAddress(request));
                    }
            logger.info("HTTP request rejected: {}", e.getMessage());
            logger.debug("HTTP request rejected by AuthenticatingFilter.", e);
            logger.debug("Internal server error during authentication.", e);
        // Attempt to create HTTP tunnel
        GuacamoleTunnel tunnel = BasicTunnelRequestUtility.createTunnel(new HTTPTunnelRequest(request));
        // If successful, warn of lack of WebSocket
        logger.info("Using HTTP tunnel (not WebSocket). Performance may be sub-optimal.");

        return tunnel;

        logger.debug("Login was successful for user \"{}\".", context.self().getUsername());
            logger.error("Creation of tunnel to guacd aborted: Failed to retrieve listeners: {}", e.getMessage());
                    logger.info("Connection \"{}\" does not exist for user \"{}\".", id, context.self().getUsername());
                logger.info("User \"{}\" successfully connected to \"{}\".", context.self().getUsername(), id);
                    logger.info("Connection group \"{}\" does not exist for user \"{}\".", id, context.self().getUsername());
                logger.info("User \"{}\" successfully connected to group \"{}\".", context.self().getUsername(), id);
                    logger.warn("Clipboard integration failed to initialize: {}", e.getMessage());
                    logger.debug("Error setting up clipboard integration.", e);
            logger.info("Successful connection canceled by hook.");
            logger.info("HTTP request rejected: {}", message);
            logger.debug("HTTP request rejected by RestrictedHttpServlet.", e);
            logger.error("HTTP request failed: {}", e.getMessage());
            logger.debug("Internal server error while handling HTTP request to restricted resource.", e);
        logger.debug("Keep-alive signal received from user \"{}\".", context.self().getUsername());
                    logger.error("Unable to read connection parameter information from \"{}\": {}", file.getAbsolutePath(), e.getMessage());
        context.reset();

        logger.info("WebSocket support NOT present. Only HTTP will be used.");
            logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
                    logger.debug("Connection to guacd closed.", e);
                    logger.debug("WebSocket tunnel write failed.", e);
                                logger.info("WebSocket connection terminated: {}", e.getMessage());
                                logger.debug("WebSocket connection terminated due to client error.", e);
                                logger.debug("Connection to guacd closed.", e);
                                logger.error("Connection to guacd terminated abnormally: {}", e.getMessage());
                                logger.debug("Internal error during connection to guacd.", e);
                            logger.debug("WebSocket tunnel read failed due to I/O error.", e);
                    logger.debug("Unable to close connection to guacd.", e);
            logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
                        logger.info("WebSocket connection terminated: {}", e.getMessage());
                        logger.debug("WebSocket connection terminated due to client error.", e);
                        logger.debug("Connection to guacd closed.", e);
                        logger.error("Connection to guacd terminated abnormally: {}", e.getMessage());
                        logger.debug("Internal error during connection to guacd.", e);
            logger.debug("Connection to guacd closed.", e);
            logger.debug("WebSocket tunnel write failed.", e);
            logger.debug("Unable to close connection to guacd.", e);
            logger.debug("Unable to close connection to guacd.", e);
    public void closeConnection(WsOutbound outbound, GuacamoleStatus guac_status) {
        try {
            byte[] message = Integer.toString(guac_status.getGuacamoleStatusCode()).getBytes("UTF-8");
            outbound.close(guac_status.getWebSocketCode(), ByteBuffer.wrap(message));
        }
        catch (IOException e) {
            logger.debug("Unable to close WebSocket tunnel.", e);
        }
            logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
                    logger.debug("Connection to guacd closed.", e);
                    logger.debug("WebSocket tunnel write failed.", e);
                    closeConnection(outbound, GuacamoleStatus.RESOURCE_NOT_FOUND);
                                logger.info("WebSocket connection terminated: {}", e.getMessage());
                                logger.debug("WebSocket connection terminated due to client error.", e);
                                logger.debug("Connection to guacd closed.", e);
                                logger.error("Connection to guacd terminated abnormally: {}", e.getMessage());
                                logger.debug("Internal error during connection to guacd.", e);
                    logger.debug("Unable to close connection to guacd.", e);
import com.google.inject.Inject;
import com.google.inject.Singleton;
@Singleton
     * Service for handling tunnel requests.
     */
    @Inject
    private TunnelRequestService tunnelRequestService;
    
    /**
        GuacamoleTunnel tunnel = tunnelRequestService.createTunnel(new HTTPTunnelRequest(request));

import com.google.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
 * REST service which updates the last access time of the Guacamole session,
 * preventing the session from becoming invalid.
@Path("/keep-alive")
public class SessionKeepAlive {

    /**
     * A service for authenticating users from auth tokens.
     */
    @Inject
    private AuthenticationService authenticationService;
    @GET
    @AuthProviderRESTExposure
    public void updateSession(@QueryParam("token") String authToken) throws GuacamoleException {

        // Tickle the session
        UserContext context = authenticationService.getUserContext(authToken);
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/TunnelRequestService.java
import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.glyptodon.guacamole.net.basic.rest.clipboard.ClipboardRESTService;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
@Singleton
public class TunnelRequestService {
    private final Logger logger = LoggerFactory.getLogger(TunnelRequestService.class);

    /**
     * A service for authenticating users from auth tokens.
     */
    @Inject
    private AuthenticationService authenticationService;
    private boolean notifyConnect(Collection listeners, UserContext context,
    private boolean notifyClose(Collection listeners, UserContext context,
    public GuacamoleTunnel createTunnel(TunnelRequest request)
        // Get auth token and session
        String authToken = request.getParameter("authToken");
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        
        final Credentials credentials = session.getCredentials();
        final UserContext context = session.getUserContext();
        
        final ClipboardState clipboard = session.getClipboardState();
                    if (GuacamoleProperties.getProperty(ClipboardRESTService.INTEGRATION_ENABLED, false))
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/log/LogModule.java
import com.google.inject.AbstractModule;
 * Initializes the logging subsystem.
public class LogModule extends AbstractModule {
    private final Logger logger = LoggerFactory.getLogger(LogModule.class);
    protected void configure() {
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/APIConstants.java
 * Copyright (C) 2014 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.rest;
/**
 * Useful constants for the REST API.
 * 
 * @author James Muehlner
 */
public class APIConstants  {

    /**
     * The identifier of the ROOT connection group.
     */
    public static final String ROOT_CONNECTION_GROUP_IDENTIFIER = "ROOT";
    
}
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/APIError.java
 * Copyright (C) 2014 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.rest;
/**
 * A simple object to represent an error to be sent from the REST API.
 * @author James Muehlner
 */
public class APIError {
    
    /**
     * The error message.
     */
    private final String message;

    /**
     * Get the error message.
     * @return The error message.
     */
    public String getMessage() {
        return message;
    }
    
    /**
     * Create a new APIError with the specified error message.
     * @param message The error message.
     */
    public APIError(String message) {
        this.message = message;
    }

}
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/AuthProviderRESTExposure.java
 * Copyright (C) 2014 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.rest;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Marks that a method exposes functionality from the Guacamole AuthenticationProvider
 * using a REST interface.
 * 
 * @author James Muehlner
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface AuthProviderRESTExposure {}
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/PATCH.java
 * Copyright (C) 2014 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.rest;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import javax.ws.rs.HttpMethod;

/**
 * An annotation for using the HTTP PATCH method in the REST endpoints.
 * 
 * @author James Muehlner
 */
@Target({ElementType.METHOD}) 
@Retention(RetentionPolicy.RUNTIME) 
@HttpMethod("PATCH") 
public @interface PATCH {} 
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/auth/AuthTokenGenerator.java
 * Copyright (C) 2014 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.rest.auth;
/**
 * Generates an auth token for an authenticated user.
 * 
 * @author James Muehlner
 */
public interface AuthTokenGenerator {
    
    /**
     * Get a new auth token.
     * 
     * @return A new auth token.
     */
    public String getToken();

}
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/auth/SecureRandomAuthTokenGenerator.java
 * Copyright (C) 2014 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.rest.auth;
import java.security.SecureRandom;
import org.apache.commons.codec.binary.Hex;

/**
 * An implementation of the AuthTokenGenerator based around SecureRandom.
 * 
 * @author James Muehlner
 */
public class SecureRandomAuthTokenGenerator implements AuthTokenGenerator {

    /**
     * Instance of SecureRandom for generating the auth token.
     */
    private final SecureRandom secureRandom = new SecureRandom();

    @Override
    public String getToken() {
        byte[] bytes = new byte[32];
        secureRandom.nextBytes(bytes);
        
        return Hex.encodeHexString(bytes);
    }
    
}
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/auth/package-info.java
 * Copyright (C) 2014 Glyptodon LLC
 * Classes related to the authentication aspect of the Guacamole REST API.
package org.glyptodon.guacamole.net.basic.rest.auth;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/clipboard/ClipboardRESTService.java
package org.glyptodon.guacamole.net.basic.rest.clipboard;
import com.google.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Response;
import org.glyptodon.guacamole.net.basic.ClipboardState;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
 * A REST service for reading the current contents of the clipboard.
@Path("/clipboard")
public class ClipboardRESTService {
     * A service for authenticating users from auth tokens.
     */
    @Inject
    private AuthenticationService authenticationService;
    
    /**
    @GET
    @AuthProviderRESTExposure
    public Response getClipboard(@QueryParam("token") String authToken) 
            GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
            final ClipboardState clipboard = session.getClipboardState();
            synchronized (clipboard) {
                clipboard.waitForContents(CLIPBOARD_TIMEOUT);
                return Response.ok(clipboard.getContents(),
                                   clipboard.getMimetype()).build();
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/connection/package-info.java
 * Copyright (C) 2014 Glyptodon LLC
 * Classes related to the connection manipulation aspect of the Guacamole REST API.
package org.glyptodon.guacamole.net.basic.rest.connection;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/connectiongroup/package-info.java
 * Copyright (C) 2014 Glyptodon LLC
 * Classes related to the connection group manipulation aspect
 * of the Guacamole REST API.
package org.glyptodon.guacamole.net.basic.rest.connectiongroup;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/package-info.java
 * Copyright (C) 2014 Glyptodon LLC
 * Classes related to the basic Guacamole REST API.
package org.glyptodon.guacamole.net.basic.rest;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/permission/package-info.java
 * Copyright (C) 2014 Glyptodon LLC
 * Classes related to the permission manipulation aspect of the Guacamole REST API.
package org.glyptodon.guacamole.net.basic.rest.permission;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/protocol/package-info.java
 * Copyright (C) 2014 Glyptodon LLC
 * Classes related to the protocol retrieval aspect of the Guacamole REST API.
package org.glyptodon.guacamole.net.basic.rest.protocol;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/user/package-info.java
 * Copyright (C) 2014 Glyptodon LLC
 * Classes related to the user manipulation aspect of the Guacamole REST API.
package org.glyptodon.guacamole.net.basic.rest.user;
import com.google.inject.Provider;
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
        /**
         * Provider which provides instances of a service for handling
         * tunnel requests.
         */
        private final Provider<TunnelRequestService> tunnelRequestServiceProvider;
         
        /**
         * Creates a new Configurator which uses the given tunnel request
         * service provider to retrieve the necessary service to handle new
         * connections requests.
         * 
         * @param tunnelRequestServiceProvider The tunnel request service
         *                                     provider to use for all new
         *                                     connections.
         */
        public Configurator(Provider<TunnelRequestService> tunnelRequestServiceProvider) {
            this.tunnelRequestServiceProvider = tunnelRequestServiceProvider;
        }
        
                // Get tunnel request service
                TunnelRequestService tunnelRequestService = tunnelRequestServiceProvider.get();
                
                GuacamoleTunnel tunnel = tunnelRequestService.createTunnel(new WebSocketTunnelRequest(request));
import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
@Singleton
    /**
     * Service for handling tunnel requests.
     */
    @Inject
    private TunnelRequestService tunnelRequestService;
 
        return tunnelRequestService.createTunnel(new HTTPTunnelRequest(request));
import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
@Singleton
    /**
     * Service for handling tunnel requests.
     */
    @Inject
    private TunnelRequestService tunnelRequestService;
 
        return tunnelRequestService.createTunnel(new WebSocketTunnelRequest(session.getUpgradeRequest()));
import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
@Singleton
    /**
     * Service for handling tunnel requests.
     */
    @Inject
    private TunnelRequestService tunnelRequestService;
 
        return tunnelRequestService.createTunnel(new HTTPTunnelRequest(request));
import javax.ws.rs.FormParam;
    public APIAuthToken login(@FormParam("username") String username,
            @FormParam("password") String password, 
import org.glyptodon.guacamole.net.basic.SessionKeepAlive;
import org.glyptodon.guacamole.net.basic.rest.clipboard.ClipboardRESTService;
        bind(ClipboardRESTService.class);
        bind(SessionKeepAlive.class);
     * collection.
        // Get session-specific elements
        final Collection listeners = session.getListeners();
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     * All currently-active tunnels, indexed by tunnel UUID.
     */
    private final Map<String, GuacamoleTunnel> tunnels = new ConcurrentHashMap<String, GuacamoleTunnel>();

    /**

    /**
     * Returns whether this session has any associated active tunnels.
     *
     * @return true if this session has any associated active tunnels,
     *         false otherwise.
     */
    public boolean hasTunnels() {
        return !tunnels.isEmpty();
    }

    /**
     * Returns a map of all active tunnels associated with this session, where
     * each key is the String representation of the tunnel's UUID. Changes to
     * this map immediately affect the set of tunnels associated with this
     * session. A tunnel need not be present here to be used by the user
     * associated with this session, but tunnels not in this set will not
     * be taken into account when determining whether a session is in use.
     *
     * @return A map of all active tunnels associated with this session.
     */
    public Map<String, GuacamoleTunnel> getTunnels() {
        return tunnels;
    }

    /**
     * Associates the given tunnel with this session, such that it is taken
     * into account when determining session activity.
     *
     * @param tunnel The tunnel to associate with this session.
     */
    public void addTunnel(GuacamoleTunnel tunnel) {
        tunnels.put(tunnel.getUUID().toString(), tunnel);
    }

    /**
     * Disassociates the tunnel having the given UUID from this session.
     *
     * @param uuid The UUID of the tunnel to disassociate from this session.
     * @return true if the tunnel existed and was removed, false otherwise.
     */
    public boolean removeTunnel(String uuid) {
        return tunnels.remove(uuid) != null;
    }

     * Notifies all listeners in the given session that a tunnel has been
     * @param session The session associated with the listeners to be notified.
    private boolean notifyConnect(GuacamoleSession session, GuacamoleTunnel tunnel)
        TunnelConnectEvent event = new TunnelConnectEvent(
                session.getUserContext(),
                session.getCredentials(),
                tunnel);
        for (Object listener : session.getListeners()) {
     * Notifies all listeners in the given session that a tunnel has been
     * @param session The session associated with the listeners to be notified.
    private boolean notifyClose(GuacamoleSession session, GuacamoleTunnel tunnel)
        TunnelCloseEvent event = new TunnelCloseEvent(
                session.getUserContext(),
                session.getCredentials(),
                tunnel);
        for (Object listener : session.getListeners()) {
        final GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);

                UserContext context = session.getUserContext();

                UserContext context = session.getUserContext();

            /**
             * The current clipboard state.
             */
            private final ClipboardState clipboard = session.getClipboardState();
            
                if (!notifyClose(session, this))
                session.removeTunnel(getUUID().toString());
                
        if (!notifyConnect(session, tunnel)) {
    private boolean isSessionActive(String authToken) {
        GuacamoleSession session = sessionMap.get(authToken);
        if (session == null)
            return false;

        // A session is active if it has any active tunnels
        if (session.hasTunnels())
            return true;
        
        if (isSessionActive(authToken)) {
import java.util.Date;
     * The last time this session was accessed.
     */
    private long lastAccessedTime;
    
    /**
        this.lastAccessedTime = System.currentTimeMillis();
    /**
     * Updates this session, marking it as accessed.
     */
    public void access() {
        lastAccessedTime = System.currentTimeMillis();
    }

    /**
     * Returns the time this session was last accessed, as the number of
     * milliseconds since midnight January 1, 1970 GMT. Session access must
     * be explicitly marked through calls to the access() function.
     *
     * @return The time this session was last accessed.
     */
    public long getLastAccessedTime() {
        return lastAccessedTime;
    }
    
        final String authToken = request.getParameter("authToken");
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
                    if (GuacamoleProperties.getProperty(ClipboardRESTService.INTEGRATION_ENABLED, false)) {

                        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
                        ClipboardState clipboard = session.getClipboardState();


                    }
                GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);

import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

     * Executor service which runs the period session eviction task.
    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
    private final Map<String, GuacamoleSession> sessionMap =
            Collections.synchronizedMap(new LinkedHashMap<String, GuacamoleSession>(16, 0.75f, true));


        // Read session timeout from guacamole.properties
            logger.error("Unable to read guacamole.properties: {}", e.getMessage());
            logger.debug("Error while reading session timeout value.", e);
        // Check for expired sessions every minute
        executor.scheduleAtFixedRate(new SessionEvictionTask(sessionTimeoutValue), 1, 1, TimeUnit.MINUTES);
    /**
     * Task which iterates through all active sessions, evicting those sessions
     * which are beyond the session timeout. This is a fairly easy thing to do,
     * since the session storage structure guarantees that sessions are always
     * in descending order of age.
     */
    private class SessionEvictionTask implements Runnable {
        /**
         * The maximum allowed age of any session, in milliseconds.
         */
        private final long sessionTimeout;

        /**
         * Creates a new task which automatically evicts sessions which are
         * older than the specified timeout.
         * 
         * @param sessionTimeout The maximum age of any session, in
         *                       milliseconds.
         */
        public SessionEvictionTask(long sessionTimeout) {
            this.sessionTimeout = sessionTimeout;
        }
        @Override
        public void run() {

            // Get current time
            long now = System.currentTimeMillis();

            logger.debug("Checking for expired sessions...");
            
            // For each session, remove sesions which have expired
            Iterator<Map.Entry<String, GuacamoleSession>> entries = sessionMap.entrySet().iterator();
            while (entries.hasNext()) {

                Map.Entry<String, GuacamoleSession> entry = entries.next();
                GuacamoleSession session = entry.getValue();

                // Get elapsed time since last access
                long age = now - session.getLastAccessedTime();

                // If session is too old, evict it and check the next one
                if (age >= sessionTimeout) {
                    logger.debug("Session \"{}\" has timed out.", entry.getKey());
                    entries.remove();
                }

                // Otherwise, no other sessions can possibly be old enough
                else
                    break;
                
            }

            logger.debug("Session check complete.");
            
        }
        GuacamoleSession session = sessionMap.get(authToken);
        if (session != null)
            session.access();

        return session;
    }
    @Override
    public void shutdown() {
        executor.shutdownNow();
    /**
     * Shuts down this session map, disallowing future sessions and reclaiming
     * any resources.
     */
    public void shutdown();
    
import org.glyptodon.guacamole.properties.IntegerGuacamoleProperty;
     * The session timeout for the API, in minutes.
    public static final IntegerGuacamoleProperty API_SESSION_TIMEOUT = new IntegerGuacamoleProperty() {
        int sessionTimeoutValue;
            sessionTimeoutValue = GuacamoleProperties.getProperty(BasicGuacamoleProperties.API_SESSION_TIMEOUT, 60);
            sessionTimeoutValue = 60;
        logger.info("Sessions will expire after {} minutes of inactivity.", sessionTimeoutValue);
        executor.scheduleAtFixedRate(new SessionEvictionTask(sessionTimeoutValue * 60000l), 1, 1, TimeUnit.MINUTES);
import javax.servlet.ServletContextEvent;
import org.glyptodon.guacamole.net.basic.rest.RESTAuthModule;
import org.glyptodon.guacamole.net.basic.rest.auth.BasicTokenSessionMap;
import org.glyptodon.guacamole.net.basic.rest.auth.TokenSessionMap;
    /**
     * Singleton instance of a TokenSessionMap.
     */
    private final TokenSessionMap sessionMap = new BasicTokenSessionMap();
 
            new RESTAuthModule(sessionMap),
    }

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {

        // Shutdown TokenSessionMap
        sessionMap.shutdown();

        super.contextDestroyed(servletContextEvent);
        // Bind generic low-level services
import com.google.inject.Singleton;
@Singleton
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(GuacamoleSession.class);

    /**

    /**
     * Closes all associated tunnels and prevents any further use of this
     * session.
     */
    public void invalidate() {

        // Close all associated tunnels, if possible
        for (GuacamoleTunnel tunnel : tunnels.values()) {
            try {
                tunnel.close();
            }
            catch (GuacamoleException e) {
                logger.debug("Unable to close tunnel.", e);
            }
        }

    }
import org.glyptodon.guacamole.net.basic.rest.auth.TokenRESTService;
        bind(TokenRESTService.class);
                    session.invalidate();
    public GuacamoleSession remove(String authToken) {
        return sessionMap.remove(authToken);
    }

    @Override

 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/auth/TokenRESTService.java
import javax.ws.rs.DELETE;
import javax.ws.rs.PathParam;
 * A service for managing auth tokens via the Guacamole REST API.
@Path("/token")
public class TokenRESTService {
    private static final Logger logger = LoggerFactory.getLogger(TokenRESTService.class);
    public APIAuthToken createToken(@FormParam("username") String username,

    /**
     * Invalidates a specific auth token, effectively logging out the associated
     * user.
     * 
     * @param authToken The token being invalidated.
     */
    @DELETE
    @Path("/{token}")
    @AuthProviderRESTExposure
    public void invalidateToken(@PathParam("token") String authToken) {
        
        GuacamoleSession session = tokenSessionMap.remove(authToken);
        if (session == null)
            throw new HTTPException(Status.NOT_FOUND, "No such token.");

        session.invalidate();

    }

     * Removes the GuacamoleSession associated with the given auth token.
     *
     * @param authToken The token to remove.
     * @return The GuacamoleSession for the given auth token, if the auth token
     *         represents a currently logged in user, null otherwise.
     */
    public GuacamoleSession remove(String authToken);
    
    /**
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
                // Get session - just close if session does not exist
                GuacamoleSession session;
                try {
                    session = authenticationService.getGuacamoleSession(authToken);
                }
                catch (GuacamoleUnauthorizedException e) {
                    logger.debug("Session destroyed prior to tunnel closure.", e);
                    super.close();
                    return;
                }
                // If we have a session, signal listeners
        session.addTunnel(tunnel);
                // Do not expire sessions which are active
                if (session.hasTunnels())
                    continue;

import java.lang.reflect.InvocationTargetException;
     * Classnames of all implementation-specific WebSocket tunnel modules.
    private static final String[] WEBSOCKET_MODULES = {
        "org.glyptodon.guacamole.net.basic.websocket.WebSocketTunnelModule",
        "org.glyptodon.guacamole.net.basic.websocket.jetty8.WebSocketTunnelModule",
        "org.glyptodon.guacamole.net.basic.websocket.jetty9.WebSocketTunnelModule",
        "org.glyptodon.guacamole.net.basic.websocket.tomcat.WebSocketTunnelModule"
    private boolean loadWebSocketModule(String classname) {
            // Attempt to find WebSocket module 
            Class<TunnelLoader> module = (Class<TunnelLoader>)
            // Create loader
            TunnelLoader loader = module.getConstructor().newInstance();

            // Install module, if supported
            if (loader.isSupported()) {
                install(loader);
                return true;
            }
        // If no such class or constructor, etc., then this particular
        // WebSocket support is not present
        catch (NoSuchMethodException e) {}

        // Log errors which indicate bugs
        catch (InstantiationException e) {
            logger.debug("Error instantiating WebSocket module.", e);
        }
        catch (IllegalAccessException e) {
            logger.debug("Error instantiating WebSocket module.", e);
        }
        catch (InvocationTargetException e) {
            logger.debug("Error instantiating WebSocket module.", e);
        }
        for (String classname : WEBSOCKET_MODULES) {
            if (loadWebSocketModule(classname)) {
                logger.debug("WebSocket module loaded: {}", classname);
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
    /**
     * Service for handling tunnel requests.
     */
    private final TunnelRequestService tunnelRequestService;

    /**
     * Creates a new WebSocketCreator which uses the given TunnelRequestService
     * to create new GuacamoleTunnels for inbound requests.
     *
     * @param tunnelRequestService The service to use for inbound tunnel
     *                             requests.
     */
    public BasicGuacamoleWebSocketCreator(TunnelRequestService tunnelRequestService) {
        this.tunnelRequestService = tunnelRequestService;
    }

                return new BasicGuacamoleWebSocketTunnelListener(tunnelRequestService);
    private final TunnelRequestService tunnelRequestService;

    /**
     * Creates a new WebSocketListener which uses the given TunnelRequestService
     * to create new GuacamoleTunnels for inbound requests.
     *
     * @param tunnelRequestService The service to use for inbound tunnel
     *                             requests.
     */
    public BasicGuacamoleWebSocketTunnelListener(TunnelRequestService tunnelRequestService) {
        this.tunnelRequestService = tunnelRequestService;
    }

import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
@Singleton
    /**
     * Service for handling tunnel requests.
     */
    @Inject
    private TunnelRequestService tunnelRequestService;
 
        factory.setCreator(new BasicGuacamoleWebSocketCreator(tunnelRequestService));
         * A username parameter. This parameter type generally behaves
         * identically to arbitrary text parameters, but has semantic
         * differences. If credential pass-through is in use, the value for this
         * parameter may be automatically provided using the credentials
         * originally used by the user to authenticate.
         */
        USERNAME,

        /**
         * A password parameter, whose value is sensitive and must be hidden. If
         * credential pass-through is in use, the value for this parameter may
         * be automatically provided using the credentials originally used by
         * the user to authenticate.
                // Username parameter
                case USERNAME:
                    xml.writeAttribute("type", "username");
                    break;

        // Username field
        else if ("username".equals(type))
            protocolParameter.setType(ProtocolParameter.Type.USERNAME);

         * A username parameter. This parameter type generally behaves
         * identically to arbitrary text parameters, but has semantic
         * differences. If credential pass-through is in use, the value for this
         * parameter may be automatically provided using the credentials
         * originally used by the user to authenticate.
         */
        USERNAME,

        /**
         * A password parameter, whose value is sensitive and must be hidden. If
         * credential pass-through is in use, the value for this parameter may
         * be automatically provided using the credentials originally used by
         * the user to authenticate.
        // Username field
        else if ("username".equals(type))
            protocolParameter.setType(ProtocolParameter.Type.USERNAME);

import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
        Environment env = new LocalEnvironment();
        
        String hostname = env.getProperty(Environment.GUACD_HOSTNAME);
        int port = env.getProperty(Environment.GUACD_PORT);
        if (env.getProperty(Environment.GUACD_SSL, false))
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 * @deprecated
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(GuacamoleHome.class);

    static {
        // Warn about deprecation
        logger.warn("GuacamoleHome is deprecated. Please use Environment instead.");
    }
    
    /**
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 * @deprecated
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(GuacamoleProperties.class);

    static {
        // Warn about deprecation
        logger.warn("GuacamoleProperties is deprecated. Please use Environment instead.");
    }
 
    /**
import java.util.Map;
import org.glyptodon.guacamole.protocols.ProtocolInfo;
     * Returns a map of all available protocols, where each key is the name of
     * that protocol as would be passed to guacd during connection.
     *
     * @return A map of all available protocols.
     */
    public Map<String, ProtocolInfo> getProtocols();

    /**
     * Returns the protocol having the given name. The name must be the
     * protocol name as would be passed to guacd during connection.
     *
     * @param name The name of the protocol.
     * @return The protocol having the given name, or null if no such
     *         protocol is registered.
     */
    public ProtocolInfo getProtocol(String name);

    /**
import java.io.BufferedInputStream;
import java.io.FilenameFilter;
import java.util.HashMap;
import java.util.Map;
import org.glyptodon.guacamole.protocols.ProtocolInfo;
import org.glyptodon.guacamole.xml.DocumentHandler;
import org.glyptodon.guacamole.xml.protocol.ProtocolTagHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(LocalEnvironment.class);

    /**
     * Array of all known protocol names.
     */
    private static final String[] KNOWN_PROTOCOLS = new String[]{
        "vnc", "rdp", "ssh", "telnet"};

    /**
     * The map of all available protocols.
     */
    private final Map<String, ProtocolInfo> availableProtocols;

    /**
        // Determine location of GUACAMOLE_HOME
        // Read properties
        properties = new Properties();
        // Read all protocols
        availableProtocols = readProtocols();

    /**
     * Parses the given XML file, returning the parsed ProtocolInfo.
     *
     * @param input An input stream containing XML describing the parameters
     *              associated with a protocol supported by Guacamole.
     * @return A new ProtocolInfo object which contains the parameters described
     *         by the XML file parsed.
     * @throws GuacamoleException If an error occurs while parsing the XML file.
     */
    private ProtocolInfo readProtocol(InputStream input)
            throws GuacamoleException {

        // Parse document
        try {

            // Get handler for root element
            ProtocolTagHandler protocolTagHandler =
                    new ProtocolTagHandler();

            // Set up document handler
            DocumentHandler contentHandler = new DocumentHandler(
                    "protocol", protocolTagHandler);

            // Set up XML parser
            XMLReader parser = XMLReaderFactory.createXMLReader();
            parser.setContentHandler(contentHandler);

            // Read and parse file
            InputStream xml = new BufferedInputStream(input);
            parser.parse(new InputSource(xml));
            xml.close();

            // Return parsed protocol
            return protocolTagHandler.asProtocolInfo();

        }
        catch (IOException e) {
            throw new GuacamoleException("Error reading basic user mapping file.", e);
        }
        catch (SAXException e) {
            throw new GuacamoleException("Error parsing basic user mapping XML.", e);
        }

    }

    /**
     * Reads through all pre-defined protocols and any protocols within the
     * "protocols" subdirectory of GUACAMOLE_HOME, returning a map containing
     * each of these protocols. The key of each entry will be the name of that
     * protocol, as would be passed to guacd during connection.
     *
     * @return A map of all available protocols.
     * @throws GuacamoleException If an error occurs while reading the various
     *                            protocol XML files.
     */
    private Map<String, ProtocolInfo> readProtocols() throws GuacamoleException {

        // Map of all available protocols
        Map<String, ProtocolInfo> protocols = new HashMap<String, ProtocolInfo>();

        // Get protcols directory
        File protocol_directory = new File(getGuacamoleHome(), "protocols");

        // Read protocols from directory if it exists
        if (protocol_directory.isDirectory()) {

            // Get all XML files
            File[] files = protocol_directory.listFiles(
                new FilenameFilter() {

                    @Override
                    public boolean accept(File file, String string) {
                        return string.endsWith(".xml");
                    }

                }
            );

            // Load each protocol from each file
            for (File file : files) {

                try {

                    // Parse protocol
                    FileInputStream stream = new FileInputStream(file);
                    ProtocolInfo protocol = readProtocol(stream);
                    stream.close();

                    // Store protocol
                    protocols.put(protocol.getName(), protocol);

                }
                catch (IOException e) {
                    logger.error("Unable to read connection parameter information from \"{}\": {}", file.getAbsolutePath(), e.getMessage());
                    logger.debug("Error reading protocol XML.", e);
                }

            }

        }

        // If known protocols are not already defined, read from classpath
        for (String protocol : KNOWN_PROTOCOLS) {

            // If protocol not defined yet, attempt to load from classpath
            if (!protocols.containsKey(protocol)) {

                InputStream stream = LocalEnvironment.class.getResourceAsStream(
                        "/org/glyptodon/guacamole/protocols/"
                         protocol  ".xml");

                // Parse XML if available
                if (stream != null)
                    protocols.put(protocol, readProtocol(stream));

            }

        }

        // Protocols map now fully populated
        return protocols;

    }

    @Override
    public Map<String, ProtocolInfo> getProtocols() {
        return availableProtocols;
    }

    @Override
    public ProtocolInfo getProtocol(String name) {
        return availableProtocols.get(name);
    }

 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/protocols/ProtocolInfo.java
package org.glyptodon.guacamole.protocols;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/protocols/ProtocolParameter.java
package org.glyptodon.guacamole.protocols;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/protocols/ProtocolParameterOption.java
package org.glyptodon.guacamole.protocols;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/DocumentHandler.java
package org.glyptodon.guacamole.xml;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/TagHandler.java
package org.glyptodon.guacamole.xml;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/package-info.java
package org.glyptodon.guacamole.xml;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/protocol/OptionTagHandler.java
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.protocols.ProtocolParameterOption;
import org.glyptodon.guacamole.xml.TagHandler;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/protocol/ParamTagHandler.java
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.protocols.ProtocolParameter;
import org.glyptodon.guacamole.xml.TagHandler;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/protocol/ProtocolTagHandler.java
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.protocols.ProtocolInfo;
import org.glyptodon.guacamole.xml.TagHandler;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/protocol/package-info.java
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.xml.DocumentHandler;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
import org.glyptodon.guacamole.protocols.ProtocolInfo;
import org.glyptodon.guacamole.protocols.ProtocolParameter;
import org.glyptodon.guacamole.protocols.ProtocolParameterOption;
        // Retrieve map of all available protocols
        Environment env = new LocalEnvironment();
        Map<String, ProtocolInfo> protocols = env.getProtocols();
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;

        // Translate to string identifier
        if (parentID != null)
            this.setParentIdentifier(String.valueOf(parentID));
        else
            this.setParentIdentifier(null);


        // Translate to string identifier
        if (parentID != null)
            this.setParentIdentifier(String.valueOf(parentID));
        else
            this.setParentIdentifier(null);


        // Translate to string identifier
        if (parentID != null)
            this.setParentIdentifier(String.valueOf(parentID));
        else
            this.setParentIdentifier(null);


        // Translate to string identifier
        if (parentID != null)
            this.setParentIdentifier(String.valueOf(parentID));
        else
            this.setParentIdentifier(null);


        // Translate to string identifier
        if (parentID != null)
            this.setParentIdentifier(String.valueOf(parentID));
        else
            this.setParentIdentifier(null);


        // Translate to string identifier
        if (parentID != null)
            this.setParentIdentifier(String.valueOf(parentID));
        else
            this.setParentIdentifier(null);

import java.util.ArrayList;
import org.glyptodon.guacamole.net.auth.permission.UserPermission;
     * Gets a list of users in the system, filtering the returned list by the
     * given permission, if specified.
     * 
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param permission
     *     If specified, limit the returned list to only those users for whom
     *     the current user has the given permission. Otherwise, all visible
     *     users are returned.
     * 
     * 
     * @throws GuacamoleException
     *     If an error is encountered while retrieving users.
    public List<APIUser> getUsers(@QueryParam("token") String authToken,
            @QueryParam("permission") UserPermission.Type permission)
            throws GuacamoleException {
        User self = userContext.self();
        List<APIUser> users = new ArrayList<APIUser>();

        // Add all users matching the given permission filter
        for (String username : userDirectory.getIdentifiers()) {

            if (permission == null || self.hasPermission(new UserPermission(permission, username)))
                users.add(new APIUser(userDirectory.get(username)));

        }
        
        // Return the user directory listing
        return users;
import javax.ws.rs.core.Response.Status;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.basic.rest.APIPatch;
import static org.glyptodon.guacamole.net.basic.rest.APIPatch.Operation.add;
import static org.glyptodon.guacamole.net.basic.rest.APIPatch.Operation.remove;
import org.glyptodon.guacamole.net.basic.rest.PATCH;
import org.glyptodon.guacamole.net.basic.rest.permission.APIPermissionSet;

    /**
     * The prefix of any path within an operation of a JSON patch which
     * modifies the permissions of a user regarding a specific connection.
     */
    private static final String CONNECTION_PERMISSION_PATCH_PATH_PREFIX = "/connectionPermissions/";
    
    /**
     * The prefix of any path within an operation of a JSON patch which
     * modifies the permissions of a user regarding a specific connection group.
     */
    private static final String CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX = "/connectionGroupPermissions/";

    /**
     * The prefix of any path within an operation of a JSON patch which
     * modifies the permissions of a user regarding another, specific user.
     */
    private static final String USER_PERMISSION_PATCH_PATH_PREFIX = "/userPermissions/";

    /**
     * The path of any operation within a JSON patch which modifies the
     * permissions of a user regarding the entire system.
     */
    private static final String SYSTEM_PERMISSION_PATCH_PATH = "/systemPermissions";
    /**
     * Gets a list of permissions for the user with the given userID.
     * 
     * @param authToken The authentication token that is used to authenticate
     *                  the user performing the operation.
     * @param userID The ID of the user to retrieve permissions for.
     * @return The permission list.
     * @throws GuacamoleException If a problem is encountered while listing permissions.
     */
    @GET
    @Path("/{userID}/permissions")
    @AuthProviderRESTExposure
    public APIPermissionSet getPermissions(@QueryParam("token") String authToken, @PathParam("userID") String userID) 
            throws GuacamoleException {

        UserContext userContext = authenticationService.getUserContext(authToken);

        // Get the user
        User user = userContext.getUserDirectory().get(userID);
        if (user == null)
            throw new HTTPException(Status.NOT_FOUND, "User not found with the provided userID.");

        return new APIPermissionSet(user.getPermissions());

    }
    
    /**
     * Applies a given list of permission patches. Each patch specifies either
     * an "add" or a "remove" operation for a permission type, represented by
     * a string. Valid permission types depend on the path of each patch
     * operation, as the path dictates the permission being modified, such as
     * "/connectionPermissions/42" or "/systemPermissions".
     * 
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     * 
     * @param userID
     *     The ID of the user to modify the permissions of.
     *
     * @param patches
     *     The permission patches to apply for this request.
     *
     * @throws GuacamoleException
     *     If a problem is encountered while modifying permissions.
     */
    @PATCH
    @Path("/{userID}/permissions")
    @AuthProviderRESTExposure
    public void patchPermissions(@QueryParam("token") String authToken,
            @PathParam("userID") String userID,
            List<APIPatch<String>> patches) throws GuacamoleException {

        UserContext userContext = authenticationService.getUserContext(authToken);
        
        // Get the user directory
        Directory<String, User> userDirectory = userContext.getUserDirectory();

        // Get the user
        User user = userContext.getUserDirectory().get(userID);
        if (user == null)
            throw new HTTPException(Status.NOT_FOUND, "User not found with the provided userID.");

        // Apply all patch operations individually
        for (APIPatch<String> patch : patches) {

            Permission permission;

            String path = patch.getPath();

            // Create connection permission if path has connection prefix
            if (path.startsWith(CONNECTION_PERMISSION_PATCH_PATH_PREFIX)) {

                // Get identifier and type from patch operation
                String identifier = path.substring(CONNECTION_PERMISSION_PATCH_PATH_PREFIX.length());
                ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());

                // Create corresponding permission
                permission = new ConnectionPermission(type, identifier);
                
            }

            // Create connection group permission if path has connection group prefix
            else if (path.startsWith(CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX)) {

                // Get identifier and type from patch operation
                String identifier = path.substring(CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX.length());
                ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());

                // Create corresponding permission
                permission = new ConnectionGroupPermission(type, identifier);
                
            }

            // Create user permission if path has user prefix
            else if (path.startsWith(USER_PERMISSION_PATCH_PATH_PREFIX)) {

                // Get identifier and type from patch operation
                String identifier = path.substring(USER_PERMISSION_PATCH_PATH_PREFIX.length());
                ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());

                // Create corresponding permission
                permission = new UserPermission(type, identifier);
                
            }

            // Create system permission if path is system path
            else if (path.startsWith(SYSTEM_PERMISSION_PATCH_PATH)) {

                // Get identifier and type from patch operation
                SystemPermission.Type type = SystemPermission.Type.valueOf(patch.getValue());

                // Create corresponding permission
                permission = new SystemPermission(type);
                
            }

            // Otherwise, the path is not supported
            else
                throw new HTTPException(Status.BAD_REQUEST, "Unsupported patch path: \""  path  "\"");

            // Add or remove permission based on operation
            switch (patch.getOp()) {

                // Add permission
                case add:
                    user.addPermission(permission);
                    break;

                // Remove permission
                case remove:
                    user.removePermission(permission);
                    break;

                // Unsupported patch operation
                default:
                    throw new HTTPException(Status.BAD_REQUEST, "Unsupported patch operation: \""  patch.getOp()  "\"");

            }

        } // end for each patch operation
        
        // Save the permission changes
        userDirectory.update(user);

    }


import org.glyptodon.guacamole.net.basic.rest.connectiongroup.APIConnectionGroup;
            this.parentIdentifier = APIConnectionGroup.ROOT_IDENTIFIER;
     * The identifier of the root connection group.
     */
    public static final String ROOT_IDENTIFIER = "ROOT";
 
    /**
            this.parentIdentifier = ROOT_IDENTIFIER;
import java.util.Collection;
import org.glyptodon.guacamole.net.basic.rest.connection.APIConnection;

    /**
     * All child connection groups. If children are not being queried, this may
     * be omitted.
     */
    private Collection<APIConnectionGroup> childConnectionGroups;

    /**
     * All child connections. If children are not being queried, this may be
     * omitted.
     */
    private Collection<APIConnection> childConnections;
    /**
     * Returns a collection of all child connection groups, or null if children
     * have not been queried.
     *
     * @return
     *     A collection of all child connection groups, or null if children
     *     have not been queried.
     */
    public Collection<APIConnectionGroup> getChildConnectionGroups() {
        return childConnectionGroups;
    }

    /**
     * Sets the collection of all child connection groups to the given
     * collection, which may be null if children have not been queried.
     *
     * @param childConnectionGroups
     *     The collection containing all child connection groups of this
     *     connection group, or null if children have not been queried.
     */
    public void setChildConnectionGroups(Collection<APIConnectionGroup> childConnectionGroups) {
        this.childConnectionGroups = childConnectionGroups;
    }

    /**
     * Returns a collection of all child connections, or null if children have
     * not been queried.
     *
     * @return
     *     A collection of all child connections, or null if children have not
     *     been queried.
     */
    public Collection<APIConnection> getChildConnections() {
        return childConnections;
    }

    /**
     * Sets the collection of all child connections to the given collection,
     * which may be null if children have not been queried.
     *
     * @param childConnections
     *     The collection containing all child connections of this connection
     *     group, or null if children have not been queried.
     */
    public void setChildConnections(Collection<APIConnection> childConnections) {
        this.childConnections = childConnections;
    }

import java.util.ArrayList;
import java.util.Collection;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.basic.rest.connection.APIConnection;
     * Retrieves the given connection group from the user context, including
     * all descendant connections and groups if requested.
     *
     * @param userContext
     *     The user context from which to retrieve the connection group.
     *
     * @param identifier
     *     The unique identifier of the connection group to retrieve.
     *
     * @param includeDescendants
     *     Whether the descendant connections and groups of the given
     *     connection group should also be retrieved.
     *
     * @return
     *     The requested connection group, or null if no such connection group
     *     exists.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving the requested connection group
     *     or any of its descendants.
    private APIConnectionGroup retrieveConnectionGroup(UserContext userContext,
            String identifier, boolean includeDescendants)
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        ConnectionGroup connectionGroup;
        
        // Use root group if requested
        if (identifier == null || identifier.equals(APIConnectionGroup.ROOT_IDENTIFIER))
            connectionGroup = rootGroup;
        // Otherwise, query requested group using root group directory

            Directory<String, ConnectionGroup> connectionGroupDirectory =
                    rootGroup.getConnectionGroupDirectory();

            // Get the connection group from root directory
            connectionGroup = connectionGroupDirectory.get(identifier);
            if (connectionGroup == null)
                return null;

        // Wrap queried connection group
        APIConnectionGroup apiConnectionGroup = new APIConnectionGroup(connectionGroup);
        // Recursively query all descendants if necessary
        if (includeDescendants) {
            // Query all child connections
            Collection<APIConnection> apiConnections = new ArrayList<APIConnection>();
            Directory<String, Connection> connectionDirectory = connectionGroup.getConnectionDirectory();

            for (String childIdentifier : connectionDirectory.getIdentifiers()) {

                // Pull current connection - silently ignore if connection was removed prior to read
                Connection childConnection = connectionDirectory.get(childIdentifier);
                if (childConnection == null)
                    continue;

                apiConnections.add(new APIConnection(childConnection));

            }
            
            // Associate child connections with current connection group
            apiConnectionGroup.setChildConnections(apiConnections);

            // Query all child connection groups
            Collection<APIConnectionGroup> apiConnectionGroups = new ArrayList<APIConnectionGroup>();
            Directory<String, ConnectionGroup> groupDirectory = connectionGroup.getConnectionGroupDirectory();

            for (String childIdentifier : groupDirectory.getIdentifiers()) {

                // Pull current connection group - silently ignore if connection group was removed prior to read
                APIConnectionGroup childConnectionGroup = retrieveConnectionGroup(userContext, childIdentifier, true);
                if (childConnectionGroup == null)
                    continue;

                apiConnectionGroups.add(childConnectionGroup);

            }
            
            // Associate child groups with current connection group
            apiConnectionGroup.setChildConnectionGroups(apiConnectionGroups);

        }
        
        // Return the connectiion group
        return apiConnectionGroup;


        // Retrieve requested connection group only
        APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, false);
            throw new GuacamoleResourceNotFoundException("No such connection group: \""  connectionGroupID  "\"");
        return connectionGroup;

    /**
     * Gets an individual connection group and all children.
     * 
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionGroupID
     *     The ID of the ConnectionGroup.
     *
     * @return
     *     The connection group.
     *
     * @throws GuacamoleException
     *     If a problem is encountered while retrieving the connection group or
     *     its descendants.
     */
    @GET
    @Path("/{connectionGroupID}/tree")
    @AuthProviderRESTExposure
    public APIConnectionGroup getConnectionGroupTree(@QueryParam("token") String authToken, 
            @PathParam("connectionGroupID") String connectionGroupID) throws GuacamoleException {

        UserContext userContext = authenticationService.getUserContext(authToken);

        // Retrieve requested connection group and all descendants
        APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, true);
        if (connectionGroup == null)
            throw new GuacamoleResourceNotFoundException("No such connection group: \""  connectionGroupID  "\"");

        return connectionGroup;

    }

        if (connectionGroupID != null && connectionGroupID.equals(APIConnectionGroup.ROOT_IDENTIFIER))
        if (connectionGroupID != null && connectionGroupID.equals(APIConnectionGroup.ROOT_IDENTIFIER))
        if (connectionGroupID != null && connectionGroupID.equals(APIConnectionGroup.ROOT_IDENTIFIER))
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
     * 
     * @param permission
     *     The permission the current user must have for a connection or
     *     connection group to be returned in the results, if any. If null
     *     is specified, no filtering by permission will be performed.
            String identifier, boolean includeDescendants, ObjectPermission.Type permission)
        User self = userContext.self();
                // Filter based on permission, if requested
                if (permission == null || self.hasPermission(new ConnectionPermission(permission, childIdentifier)))
                    apiConnections.add(new APIConnection(childConnection));
                APIConnectionGroup childConnectionGroup = retrieveConnectionGroup(userContext, childIdentifier, true, permission);
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     * 
     * @param connectionGroupID
     *     The ID of the connection group to retrieve.
     * 
     * @return
     *     The connection group, without any descendants.
     *
     * @throws GuacamoleException
     *     If a problem is encountered while retrieving the connection group.
        APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, false, null);
     *     The ID of the connection group to retrieve.
     * @param permission
     *     If specified, limit the returned list to only those connections and
     *     connection groups for which the current user has the given
     *     permission. Otherwise, all visible connections and connection groups
     *     are returned.
     * 
     *     The requested connection group, including all descendants.
            @PathParam("connectionGroupID") String connectionGroupID,
            @QueryParam("permission") ObjectPermission.Type permission)
            throws GuacamoleException {
        APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, true, permission);
    private Map<String, String> parameters;
     * Create an APIConnection from a Connection record. Parameters for the
     * connection will not be included.
     *
        // Set identifying information
        // Set proper parent identifier, using root identifier if needed
        this.parentIdentifier = connection.getParentIdentifier();

        // Set protocol from configuration
import java.util.Collections;
import java.util.HashMap;
        // Create the GuacamoleConfiguration with current protocol

        // Add parameters, if available
        Map<String, String> parameters = apiConnection.getParameters();
        if (parameters != null) {
            for (Map.Entry<String, String> entry : parameters.entrySet())
                configuration.setParameter(entry.getKey(), entry.getValue());
        }
        Map<String, String> parameters = new HashMap<String, String>();
        for (String key : config.getParameterNames())
        // Set protocol and parameters
        apiConnection.setParameters(parameters);

        return Collections.EMPTY_LIST;
import java.util.HashMap;
import java.util.Map;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;

    /**
     * Retrieves the parameters associated with a single connection.
     * 
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionID
     *     The ID of the connection.
     *
     * @return
     *     A map of parameter name/value pairs.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the connection parameters.
     */
    @GET
    @Path("/{connectionID}/parameters")
    @AuthProviderRESTExposure
    public Map<String, String> getConnectionParameters(@QueryParam("token") String authToken, 
            @PathParam("connectionID") String connectionID) throws GuacamoleException {

        UserContext userContext = authenticationService.getUserContext(authToken);

        // Get the connection directory
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        Directory<String, Connection> connectionDirectory =
                rootGroup.getConnectionDirectory();

        // Get the connection
        Connection connection = connectionDirectory.get(connectionID);
        if (connection == null)
            throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");

        // Retrieve connection configuration
        GuacamoleConfiguration config = connection.getConfiguration();

        // Convert parameters to map
        Map<String, String> parameters = new HashMap<String, String>();
        for (String key : config.getParameterNames())
            parameters.put(key, config.getParameter(key));
        
        return parameters;

    }

    /**
     * Retrieves the usage history of a single connection.
     * 
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionID
     *     The ID of the connection.
     *
     * @return
     *     A list of connection records, describing the start and end times of
     *     various usages of this connection.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the connection history.
     */
    @GET
    @Path("/{connectionID}/history")
    @AuthProviderRESTExposure
    public List<? extends ConnectionRecord> getConnectionHistory(@QueryParam("token") String authToken, 
            @PathParam("connectionID") String connectionID) throws GuacamoleException {

        UserContext userContext = authenticationService.getUserContext(authToken);
        
        // Get the connection directory
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        Directory<String, Connection> connectionDirectory =
                rootGroup.getConnectionDirectory();

        // Get the connection
        Connection connection = connectionDirectory.get(connectionID);
        if (connection == null)
            throw new HTTPException(Status.NOT_FOUND, "No Connection found with the provided ID.");

        return connection.getHistory();

    }

import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.basic.rest.connectiongroup.APIConnectionGroup;
@Path("/connections")
     * Retrieves an individual connection.
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionID
     *     The identifier of the connection to retrieve.
     *
     * @return
     *     The connection having the given identifier.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the connection.
            throw new GuacamoleResourceNotFoundException("No such connection: \""  connectionID  "\"");
     *     The identifier of the connection.
            throw new GuacamoleResourceNotFoundException("No such connection: \""  connectionID  "\"");
     *     The identifier of the connection.
            throw new GuacamoleResourceNotFoundException("No such connection: \""  connectionID  "\"");
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionID
     *     The identifier of the connection to delete.
     *
     * @throws GuacamoleException
     *     If an error occurs while deleting the connection.
            throw new GuacamoleResourceNotFoundException("No such connection: \""  connectionID  "\"");

     * Retrieves a single connection group from the given user context. If
     * the given identifier is null or the root identifier, the root connection
     * group will be returned.
     *
     * @param userContext
     *     The user context to retrieve the connection group from.
     *
     * @param identifier
     *     The identifier of the connection group to retrieve.
     *
     * @return
     *     The connection group having the given identifier, or the root
     *     connection group if the identifier is null or the root identifier.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving the connection group, or if the
     *     connection group does not exist.
     */
    private ConnectionGroup retrieveConnectionGroup(UserContext userContext,
            String identifier) throws GuacamoleException {

        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();

        // Use root group if identifier is null (or the standard root identifier)
        if (identifier == null || identifier.equals(APIConnectionGroup.ROOT_IDENTIFIER))
            return rootGroup;

        // Pull specified connection group otherwise
        Directory<String, ConnectionGroup> directory = rootGroup.getConnectionGroupDirectory();
        ConnectionGroup connectionGroup = directory.get(identifier);

        if (connectionGroup == null)
            throw new GuacamoleResourceNotFoundException("No such connection group: \""  identifier  "\"");

        return connectionGroup;

    }

    /**
     * Creates a new connection and returns the identifier of the new
     * connection.
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connection
     *     The connection to create.
     *
     * @return
     *     The identifier of the new connection.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the connection.
    public String createConnection(@QueryParam("token") String authToken,
            APIConnection connection) throws GuacamoleException {
        // Validate that connection data was provided
            throw new GuacamoleClientException("Connection JSON must be submitted when creating connections.");
        // Retrieve parent group
        String parentID = connection.getParentIdentifier();
        ConnectionGroup parentConnectionGroup = retrieveConnectionGroup(userContext, parentID);
        // Add the new connection
        Directory<String, Connection> connectionDirectory = parentConnectionGroup.getConnectionDirectory();
  
     * Updates an existing connection. If the parent identifier of the
     * connection is changed, the connection will also be moved to the new
     * parent group.
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionID
     *     The identifier of the connection to update.
     *
     * @param connection
     *     The connection data to update the specified connection with.
     *
     * @throws GuacamoleException
     *     If an error occurs while updating the connection.
    @PUT
        // Validate that connection data was provided
            throw new GuacamoleClientException("Connection JSON must be submitted when updating connections.");
        Connection existingConnection = connectionDirectory.get(connectionID);
        if (existingConnection == null)
            throw new GuacamoleResourceNotFoundException("No such connection: \""  connectionID  "\"");
        Connection wrappedConnection = new APIConnectionWrapper(connection);
        existingConnection.setConfiguration(wrappedConnection.getConfiguration());
        existingConnection.setName(wrappedConnection.getName());
        connectionDirectory.update(existingConnection);
@Path("/connectionGroups")
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionGroupID
     *     The identifier of the connection group to delete.
     *
     * @throws GuacamoleException
     *     If an error occurs while deleting the connection group.
            throw new GuacamoleResourceNotFoundException("No such connection group: \""  connectionGroupID  "\"");
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionGroup
     *     The connection group to create.
     * 
     * @return
     *     The identifier of the new connection group.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the connection group.
    public String createConnectionGroup(@QueryParam("token") String authToken,
            APIConnectionGroup connectionGroup) throws GuacamoleException {
        // Validate that connection group data was provided
            throw new GuacamoleClientException("Connection group JSON must be submitted when creating connections groups.");
        String parentID = connectionGroup.getParentIdentifier();
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();

        // Use root group if no parent is specified
            parentConnectionGroup = rootGroup;
        // Pull specified connection group otherwise

            if (parentConnectionGroup == null)
                throw new GuacamoleResourceNotFoundException("No such connection group: \""  parentID  "\"");
        // Add the new connection group
        Directory<String, ConnectionGroup> connectionGroupDirectory = parentConnectionGroup.getConnectionGroupDirectory();
     * Updates a connection group. If the parent identifier of the
     * connection group is changed, the connection group will also be moved to
     * the new parent group.
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionGroupID
     *     The identifier of the existing connection group to update.
     *
     * @param connectionGroup
     *     The data to update the existing connection group with.
     *
     * @throws GuacamoleException
     *     If an error occurs while updating the connection group.
    @PUT
        // Validate that connection group data was provided
            throw new GuacamoleClientException("Connection group JSON must be submitted when updating connection groups.");
            throw new GuacamoleResourceNotFoundException("No such connection group: \""  connectionGroupID  "\"");
import javax.ws.rs.QueryParam;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
@Path("/protocols")
     * A service for authenticating users from auth tokens.
     */
    @Inject
    private AuthenticationService authenticationService;
    
    /**
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @return
     *     A map of protocol information, where each key is the unique name
     *     associated with that protocol.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the available protocols.
    public Map<String, ProtocolInfo> getProtocols(@QueryParam("token") String authToken) throws GuacamoleException {
        // Verify the given auth token is valid
        authenticationService.getUserContext(authToken);


@Path("/users")
@Path("/tokens")
import javax.ws.rs.PUT;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
     * @return
     *     A list of all visible users. If a permission was specified, this
     *     list will contain only those users for whom the current user has
     *     that permission.
     * Retrieves an individual user.
     *
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param username
     *     The username of the user to retrieve.
     *
     * @return user
     *     The user having the given username.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the user.
    @Path("/{username}")
    public APIUser getUser(@QueryParam("token") String authToken, @PathParam("username") String username) 
        User user = userDirectory.get(username);
            throw new GuacamoleResourceNotFoundException("No such user: \""  username  "\"");
     *
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param username
     *     The username of the user to update.
     *
     * @param user
     *     The data to update the user with.
     *
     * @throws GuacamoleException
     *     If an error occurs while updating the user.
    @PUT
    @Path("/{username}")
    public void updateUser(@QueryParam("token") String authToken,
            @PathParam("username") String username, APIUser user) 
        // Validate data and path are sane
        if (!user.getUsername().equals(username))
            throw new HTTPException(Response.Status.BAD_REQUEST,
                    "Username in path does not match username provided JSON data.");
        User existingUser = userDirectory.get(username);
            throw new GuacamoleResourceNotFoundException("No such user: \""  username  "\"");
        if (user.getPassword() != null)

        // Update the user
        userDirectory.update(existingUser);
     *
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param username
     *     The username of the user to delete.
     *
     * @throws GuacamoleException
     *     If an error occurs while deleting the user.
    @Path("/{username}")
    public void deleteUser(@QueryParam("token") String authToken,
            @PathParam("username") String username) 
        User existingUser = userDirectory.get(username);
            throw new GuacamoleResourceNotFoundException("No such user: \""  username  "\"");
        userDirectory.remove(username);
     * Gets a list of permissions for the user with the given username.
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param username
     *     The username of the user to retrieve permissions for.
     *
     * @return
     *     A list of all permissions granted to the specified user.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving permissions.
    @Path("/{username}/permissions")
    public APIPermissionSet getPermissions(@QueryParam("token") String authToken,
            @PathParam("username") String username) 
        User user = userContext.getUserDirectory().get(username);
            throw new GuacamoleResourceNotFoundException("No such user: \""  username  "\"");
     * @param username
     *     The username of the user to modify the permissions of.
    @Path("/{username}/permissions")
            @PathParam("username") String username,
        User user = userContext.getUserDirectory().get(username);
            throw new GuacamoleResourceNotFoundException("No such user: \""  username  "\"");
                    throw new HTTPException(Status.BAD_REQUEST,
                            "Unsupported patch operation: \""  patch.getOp()  "\"");
    /**
     * Returns a map which contains parameter name/value pairs as key/value
     * pairs. Changes to this map will affect the parameters stored within
     * this configuration.
     *
     * @return
     *     A map which contains all parameter name/value pairs as key/value
     *     pairs.
     */
    public Map<String, String> getParameters() {
        return parameters;
    }

    /**
     * Replaces all current parameters with the parameters defined within the
     * given map. Key/value pairs within the map represent parameter name/value
     * pairs.
     *
     * @param parameters
     *     A map which contains all parameter name/value pairs as key/value
     *     pairs.
     */
    public void setParameters(Map<String, String> parameters) {
        this.parameters.clear();
        this.parameters.putAll(parameters);
    }

        if (parameters != null)
            configuration.setParameters(parameters);
        apiConnection.setParameters(config.getParameters());
        // Return parameter map
        return config.getParameters();
        // Retrieve connection configuration
        GuacamoleConfiguration config = new GuacamoleConfiguration();
        config.setProtocol(connection.getProtocol());
        config.setParameters(connection.getParameters());
        existingConnection.setConfiguration(config);
        existingConnection.setName(connection.getName());
     *     If specified, limit the returned list to only those connections for
     *     which the current user has the given permission. Otherwise, all
     *     visible connections are returned. Connection groups are unaffected
     *     by this parameter.
    /**
     * Returns a map which contains parameter name/value pairs as key/value
     * pairs. Changes to this map will affect the parameters stored within
     * this configuration.
     *
     * @return
     *     A map which contains all parameter name/value pairs as key/value
     *     pairs.
     */
    public Map<String, String> getParameters() {
        return parameters;
    }

    /**
     * Replaces all current parameters with the parameters defined within the
     * given map. Key/value pairs within the map represent parameter name/value
     * pairs.
     *
     * @param parameters
     *     A map which contains all parameter name/value pairs as key/value
     *     pairs.
     */
    public void setParameters(Map<String, String> parameters) {
        this.parameters.clear();
        this.parameters.putAll(parameters);
    }

@Path("/tokens")
import org.glyptodon.guacamole.net.basic.rest.connectiongroup.APIConnectionGroup;
    private Map<String, String> parameters;
     * Create an APIConnection from a Connection record. Parameters for the
     * connection will not be included.
     *
        // Set identifying information
        
        // Set proper parent identifier, using root identifier if needed
            this.parentIdentifier = APIConnectionGroup.ROOT_IDENTIFIER;

        // Set protocol from configuration
import java.util.Collections;
        // Create the GuacamoleConfiguration with current protocol

        // Add parameters, if available
        Map<String, String> parameters = apiConnection.getParameters();
        if (parameters != null)
            configuration.setParameters(parameters);
        // Set protocol and parameters
        apiConnection.setParameters(config.getParameters());

        return Collections.EMPTY_LIST;
import java.util.Map;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
import org.glyptodon.guacamole.net.basic.rest.connectiongroup.APIConnectionGroup;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
@Path("/connections")
     * Retrieves an individual connection.
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionID
     *     The identifier of the connection to retrieve.
     *
     * @return
     *     The connection having the given identifier.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the connection.
            throw new GuacamoleResourceNotFoundException("No such connection: \""  connectionID  "\"");

    /**
     * Retrieves the parameters associated with a single connection.
     * 
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionID
     *     The identifier of the connection.
     *
     * @return
     *     A map of parameter name/value pairs.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the connection parameters.
     */
    @GET
    @Path("/{connectionID}/parameters")
    @AuthProviderRESTExposure
    public Map<String, String> getConnectionParameters(@QueryParam("token") String authToken, 
            @PathParam("connectionID") String connectionID) throws GuacamoleException {

        UserContext userContext = authenticationService.getUserContext(authToken);

        // Get the connection directory
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        Directory<String, Connection> connectionDirectory =
                rootGroup.getConnectionDirectory();

        // Get the connection
        Connection connection = connectionDirectory.get(connectionID);
        if (connection == null)
            throw new GuacamoleResourceNotFoundException("No such connection: \""  connectionID  "\"");

        // Retrieve connection configuration
        GuacamoleConfiguration config = connection.getConfiguration();

        // Return parameter map
        return config.getParameters();

    }

    /**
     * Retrieves the usage history of a single connection.
     * 
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionID
     *     The identifier of the connection.
     *
     * @return
     *     A list of connection records, describing the start and end times of
     *     various usages of this connection.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the connection history.
     */
    @GET
    @Path("/{connectionID}/history")
    @AuthProviderRESTExposure
    public List<? extends ConnectionRecord> getConnectionHistory(@QueryParam("token") String authToken, 
            @PathParam("connectionID") String connectionID) throws GuacamoleException {

        UserContext userContext = authenticationService.getUserContext(authToken);
        
        // Get the connection directory
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        Directory<String, Connection> connectionDirectory =
                rootGroup.getConnectionDirectory();

        // Get the connection
        Connection connection = connectionDirectory.get(connectionID);
        if (connection == null)
            throw new GuacamoleResourceNotFoundException("No such connection: \""  connectionID  "\"");

        return connection.getHistory();

    }

     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionID
     *     The identifier of the connection to delete.
     *
     * @throws GuacamoleException
     *     If an error occurs while deleting the connection.
            throw new GuacamoleResourceNotFoundException("No such connection: \""  connectionID  "\"");

     * Retrieves a single connection group from the given user context. If
     * the given identifier is null or the root identifier, the root connection
     * group will be returned.
     *
     * @param userContext
     *     The user context to retrieve the connection group from.
     *
     * @param identifier
     *     The identifier of the connection group to retrieve.
     *
     * @return
     *     The connection group having the given identifier, or the root
     *     connection group if the identifier is null or the root identifier.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving the connection group, or if the
     *     connection group does not exist.
     */
    private ConnectionGroup retrieveConnectionGroup(UserContext userContext,
            String identifier) throws GuacamoleException {

        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();

        // Use root group if identifier is null (or the standard root identifier)
        if (identifier == null || identifier.equals(APIConnectionGroup.ROOT_IDENTIFIER))
            return rootGroup;

        // Pull specified connection group otherwise
        Directory<String, ConnectionGroup> directory = rootGroup.getConnectionGroupDirectory();
        ConnectionGroup connectionGroup = directory.get(identifier);

        if (connectionGroup == null)
            throw new GuacamoleResourceNotFoundException("No such connection group: \""  identifier  "\"");

        return connectionGroup;

    }

    /**
     * Creates a new connection and returns the identifier of the new
     * connection.
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connection
     *     The connection to create.
     *
     * @return
     *     The identifier of the new connection.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the connection.
    public String createConnection(@QueryParam("token") String authToken,
            APIConnection connection) throws GuacamoleException {
        // Validate that connection data was provided
            throw new GuacamoleClientException("Connection JSON must be submitted when creating connections.");
        // Retrieve parent group
        String parentID = connection.getParentIdentifier();
        ConnectionGroup parentConnectionGroup = retrieveConnectionGroup(userContext, parentID);
        // Add the new connection
        Directory<String, Connection> connectionDirectory = parentConnectionGroup.getConnectionDirectory();
  
     * Updates an existing connection. If the parent identifier of the
     * connection is changed, the connection will also be moved to the new
     * parent group.
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionID
     *     The identifier of the connection to update.
     *
     * @param connection
     *     The connection data to update the specified connection with.
     *
     * @throws GuacamoleException
     *     If an error occurs while updating the connection.
    @PUT
        // Validate that connection data was provided
            throw new GuacamoleClientException("Connection JSON must be submitted when updating connections.");
        Connection existingConnection = connectionDirectory.get(connectionID);
        if (existingConnection == null)
            throw new GuacamoleResourceNotFoundException("No such connection: \""  connectionID  "\"");
        // Retrieve connection configuration
        GuacamoleConfiguration config = new GuacamoleConfiguration();
        config.setProtocol(connection.getProtocol());
        config.setParameters(connection.getParameters());
        existingConnection.setConfiguration(config);
        existingConnection.setName(connection.getName());
        connectionDirectory.update(existingConnection);
import java.util.Collection;
import org.glyptodon.guacamole.net.basic.rest.connection.APIConnection;
     * The identifier of the root connection group.
     */
    public static final String ROOT_IDENTIFIER = "ROOT";
 
    /**

    /**
     * All child connection groups. If children are not being queried, this may
     * be omitted.
     */
    private Collection<APIConnectionGroup> childConnectionGroups;

    /**
     * All child connections. If children are not being queried, this may be
     * omitted.
     */
    private Collection<APIConnection> childConnections;
            this.parentIdentifier = ROOT_IDENTIFIER;
    /**
     * Returns a collection of all child connection groups, or null if children
     * have not been queried.
     *
     * @return
     *     A collection of all child connection groups, or null if children
     *     have not been queried.
     */
    public Collection<APIConnectionGroup> getChildConnectionGroups() {
        return childConnectionGroups;
    }

    /**
     * Sets the collection of all child connection groups to the given
     * collection, which may be null if children have not been queried.
     *
     * @param childConnectionGroups
     *     The collection containing all child connection groups of this
     *     connection group, or null if children have not been queried.
     */
    public void setChildConnectionGroups(Collection<APIConnectionGroup> childConnectionGroups) {
        this.childConnectionGroups = childConnectionGroups;
    }

    /**
     * Returns a collection of all child connections, or null if children have
     * not been queried.
     *
     * @return
     *     A collection of all child connections, or null if children have not
     *     been queried.
     */
    public Collection<APIConnection> getChildConnections() {
        return childConnections;
    }

    /**
     * Sets the collection of all child connections to the given collection,
     * which may be null if children have not been queried.
     *
     * @param childConnections
     *     The collection containing all child connections of this connection
     *     group, or null if children have not been queried.
     */
    public void setChildConnections(Collection<APIConnection> childConnections) {
        this.childConnections = childConnections;
    }

import java.util.ArrayList;
import java.util.Collection;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.basic.rest.connection.APIConnection;
@Path("/connectionGroups")
     * Retrieves the given connection group from the user context, including
     * all descendant connections and groups if requested.
     *
     * @param userContext
     *     The user context from which to retrieve the connection group.
     *
     * @param identifier
     *     The unique identifier of the connection group to retrieve.
     *
     * @param includeDescendants
     *     Whether the descendant connections and groups of the given
     *     connection group should also be retrieved.
     * @param permission
     *     The permission the current user must have for a connection or
     *     connection group to be returned in the results, if any. If null
     *     is specified, no filtering by permission will be performed.
     *
     * @return
     *     The requested connection group, or null if no such connection group
     *     exists.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving the requested connection group
     *     or any of its descendants.
    private APIConnectionGroup retrieveConnectionGroup(UserContext userContext,
            String identifier, boolean includeDescendants, ObjectPermission.Type permission)
        User self = userContext.self();
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();
        ConnectionGroup connectionGroup;
        
        // Use root group if requested
        if (identifier == null || identifier.equals(APIConnectionGroup.ROOT_IDENTIFIER))
            connectionGroup = rootGroup;
        // Otherwise, query requested group using root group directory

            Directory<String, ConnectionGroup> connectionGroupDirectory =
                    rootGroup.getConnectionGroupDirectory();

            // Get the connection group from root directory
            connectionGroup = connectionGroupDirectory.get(identifier);
            if (connectionGroup == null)
                return null;

        // Wrap queried connection group
        APIConnectionGroup apiConnectionGroup = new APIConnectionGroup(connectionGroup);
        // Recursively query all descendants if necessary
        if (includeDescendants) {
            // Query all child connections
            Collection<APIConnection> apiConnections = new ArrayList<APIConnection>();
            Directory<String, Connection> connectionDirectory = connectionGroup.getConnectionDirectory();

            for (String childIdentifier : connectionDirectory.getIdentifiers()) {

                // Pull current connection - silently ignore if connection was removed prior to read
                Connection childConnection = connectionDirectory.get(childIdentifier);
                if (childConnection == null)
                    continue;

                // Filter based on permission, if requested
                if (permission == null || self.hasPermission(new ConnectionPermission(permission, childIdentifier)))
                    apiConnections.add(new APIConnection(childConnection));

            }
            
            // Associate child connections with current connection group
            apiConnectionGroup.setChildConnections(apiConnections);

            // Query all child connection groups
            Collection<APIConnectionGroup> apiConnectionGroups = new ArrayList<APIConnectionGroup>();
            Directory<String, ConnectionGroup> groupDirectory = connectionGroup.getConnectionGroupDirectory();

            for (String childIdentifier : groupDirectory.getIdentifiers()) {

                // Pull current connection group - silently ignore if connection group was removed prior to read
                APIConnectionGroup childConnectionGroup = retrieveConnectionGroup(userContext, childIdentifier, true, permission);
                if (childConnectionGroup == null)
                    continue;

                apiConnectionGroups.add(childConnectionGroup);

            }
            
            // Associate child groups with current connection group
            apiConnectionGroup.setChildConnectionGroups(apiConnectionGroups);

        }
        
        // Return the connectiion group
        return apiConnectionGroup;


     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     * 
     * @param connectionGroupID
     *     The ID of the connection group to retrieve.
     * 
     * @return
     *     The connection group, without any descendants.
     *
     * @throws GuacamoleException
     *     If a problem is encountered while retrieving the connection group.
        // Retrieve requested connection group only
        APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, false, null);
            throw new GuacamoleResourceNotFoundException("No such connection group: \""  connectionGroupID  "\"");
        return connectionGroup;

    /**
     * Gets an individual connection group and all children.
     * 
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionGroupID
     *     The ID of the connection group to retrieve.
     *
     * @param permission
     *     If specified, limit the returned list to only those connections for
     *     which the current user has the given permission. Otherwise, all
     *     visible connections are returned. Connection groups are unaffected
     *     by this parameter.
     * 
     * @return
     *     The requested connection group, including all descendants.
     *
     * @throws GuacamoleException
     *     If a problem is encountered while retrieving the connection group or
     *     its descendants.
     */
    @GET
    @Path("/{connectionGroupID}/tree")
    @AuthProviderRESTExposure
    public APIConnectionGroup getConnectionGroupTree(@QueryParam("token") String authToken, 
            @PathParam("connectionGroupID") String connectionGroupID,
            @QueryParam("permission") ObjectPermission.Type permission)
            throws GuacamoleException {

        UserContext userContext = authenticationService.getUserContext(authToken);

        // Retrieve requested connection group and all descendants
        APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, true, permission);
        if (connectionGroup == null)
            throw new GuacamoleResourceNotFoundException("No such connection group: \""  connectionGroupID  "\"");

        return connectionGroup;

    }

     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionGroupID
     *     The identifier of the connection group to delete.
     *
     * @throws GuacamoleException
     *     If an error occurs while deleting the connection group.
        if (connectionGroupID != null && connectionGroupID.equals(APIConnectionGroup.ROOT_IDENTIFIER))
            throw new GuacamoleResourceNotFoundException("No such connection group: \""  connectionGroupID  "\"");
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionGroup
     *     The connection group to create.
     * 
     * @return
     *     The identifier of the new connection group.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the connection group.
    public String createConnectionGroup(@QueryParam("token") String authToken,
            APIConnectionGroup connectionGroup) throws GuacamoleException {
        // Validate that connection group data was provided
            throw new GuacamoleClientException("Connection group JSON must be submitted when creating connections groups.");
        String parentID = connectionGroup.getParentIdentifier();
        ConnectionGroup rootGroup = userContext.getRootConnectionGroup();

        // Use root group if no parent is specified
            parentConnectionGroup = rootGroup;
        // Pull specified connection group otherwise

            if (parentConnectionGroup == null)
                throw new GuacamoleResourceNotFoundException("No such connection group: \""  parentID  "\"");
        // Add the new connection group
        Directory<String, ConnectionGroup> connectionGroupDirectory = parentConnectionGroup.getConnectionGroupDirectory();
     * Updates a connection group. If the parent identifier of the
     * connection group is changed, the connection group will also be moved to
     * the new parent group.
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param connectionGroupID
     *     The identifier of the existing connection group to update.
     *
     * @param connectionGroup
     *     The data to update the existing connection group with.
     *
     * @throws GuacamoleException
     *     If an error occurs while updating the connection group.
    @PUT
        // Validate that connection group data was provided
            throw new GuacamoleClientException("Connection group JSON must be submitted when updating connection groups.");
        if (connectionGroupID != null && connectionGroupID.equals(APIConnectionGroup.ROOT_IDENTIFIER))
            throw new GuacamoleResourceNotFoundException("No such connection group: \""  connectionGroupID  "\"");
import javax.ws.rs.QueryParam;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
@Path("/protocols")
     * A service for authenticating users from auth tokens.
     */
    @Inject
    private AuthenticationService authenticationService;
    
    /**
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @return
     *     A map of protocol information, where each key is the unique name
     *     associated with that protocol.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the available protocols.
    public Map<String, ProtocolInfo> getProtocols(@QueryParam("token") String authToken) throws GuacamoleException {
        // Verify the given auth token is valid
        authenticationService.getUserContext(authToken);


import java.util.ArrayList;
import javax.ws.rs.PUT;
import javax.ws.rs.core.Response.Status;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.auth.permission.UserPermission;
import org.glyptodon.guacamole.net.basic.rest.APIPatch;
import static org.glyptodon.guacamole.net.basic.rest.APIPatch.Operation.add;
import static org.glyptodon.guacamole.net.basic.rest.APIPatch.Operation.remove;
import org.glyptodon.guacamole.net.basic.rest.PATCH;
import org.glyptodon.guacamole.net.basic.rest.permission.APIPermissionSet;
@Path("/users")

    /**
     * The prefix of any path within an operation of a JSON patch which
     * modifies the permissions of a user regarding a specific connection.
     */
    private static final String CONNECTION_PERMISSION_PATCH_PATH_PREFIX = "/connectionPermissions/";
    
    /**
     * The prefix of any path within an operation of a JSON patch which
     * modifies the permissions of a user regarding a specific connection group.
     */
    private static final String CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX = "/connectionGroupPermissions/";

    /**
     * The prefix of any path within an operation of a JSON patch which
     * modifies the permissions of a user regarding another, specific user.
     */
    private static final String USER_PERMISSION_PATCH_PATH_PREFIX = "/userPermissions/";

    /**
     * The path of any operation within a JSON patch which modifies the
     * permissions of a user regarding the entire system.
     */
    private static final String SYSTEM_PERMISSION_PATCH_PATH = "/systemPermissions";
     * Gets a list of users in the system, filtering the returned list by the
     * given permission, if specified.
     * 
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param permission
     *     If specified, limit the returned list to only those users for whom
     *     the current user has the given permission. Otherwise, all visible
     *     users are returned.
     * 
     * @return
     *     A list of all visible users. If a permission was specified, this
     *     list will contain only those users for whom the current user has
     *     that permission.
     * 
     * @throws GuacamoleException
     *     If an error is encountered while retrieving users.
    public List<APIUser> getUsers(@QueryParam("token") String authToken,
            @QueryParam("permission") UserPermission.Type permission)
            throws GuacamoleException {
        User self = userContext.self();
        List<APIUser> users = new ArrayList<APIUser>();

        // Add all users matching the given permission filter
        for (String username : userDirectory.getIdentifiers()) {

            if (permission == null || self.hasPermission(new UserPermission(permission, username)))
                users.add(new APIUser(userDirectory.get(username)));

        }
        
        // Return the user directory listing
        return users;
     * Retrieves an individual user.
     *
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param username
     *     The username of the user to retrieve.
     *
     * @return user
     *     The user having the given username.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the user.
    @Path("/{username}")
    public APIUser getUser(@QueryParam("token") String authToken, @PathParam("username") String username) 
        User user = userDirectory.get(username);
            throw new GuacamoleResourceNotFoundException("No such user: \""  username  "\"");
     *
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param username
     *     The username of the user to update.
     *
     * @param user
     *     The data to update the user with.
     *
     * @throws GuacamoleException
     *     If an error occurs while updating the user.
    @PUT
    @Path("/{username}")
    public void updateUser(@QueryParam("token") String authToken,
            @PathParam("username") String username, APIUser user) 
        // Validate data and path are sane
        if (!user.getUsername().equals(username))
            throw new HTTPException(Response.Status.BAD_REQUEST,
                    "Username in path does not match username provided JSON data.");
        User existingUser = userDirectory.get(username);
            throw new GuacamoleResourceNotFoundException("No such user: \""  username  "\"");
        if (user.getPassword() != null)

        // Update the user
        userDirectory.update(existingUser);
     *
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param username
     *     The username of the user to delete.
     *
     * @throws GuacamoleException
     *     If an error occurs while deleting the user.
    @Path("/{username}")
    public void deleteUser(@QueryParam("token") String authToken,
            @PathParam("username") String username) 
        User existingUser = userDirectory.get(username);
            throw new GuacamoleResourceNotFoundException("No such user: \""  username  "\"");
        userDirectory.remove(username);

    }

    /**
     * Gets a list of permissions for the user with the given username.
     * 
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param username
     *     The username of the user to retrieve permissions for.
     *
     * @return
     *     A list of all permissions granted to the specified user.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving permissions.
     */
    @GET
    @Path("/{username}/permissions")
    @AuthProviderRESTExposure
    public APIPermissionSet getPermissions(@QueryParam("token") String authToken,
            @PathParam("username") String username) 
            throws GuacamoleException {

        UserContext userContext = authenticationService.getUserContext(authToken);

        // Get the user
        User user = userContext.getUserDirectory().get(username);
        if (user == null)
            throw new GuacamoleResourceNotFoundException("No such user: \""  username  "\"");

        return new APIPermissionSet(user.getPermissions());

    }
    
    /**
     * Applies a given list of permission patches. Each patch specifies either
     * an "add" or a "remove" operation for a permission type, represented by
     * a string. Valid permission types depend on the path of each patch
     * operation, as the path dictates the permission being modified, such as
     * "/connectionPermissions/42" or "/systemPermissions".
     * 
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     * 
     * @param username
     *     The username of the user to modify the permissions of.
     *
     * @param patches
     *     The permission patches to apply for this request.
     *
     * @throws GuacamoleException
     *     If a problem is encountered while modifying permissions.
     */
    @PATCH
    @Path("/{username}/permissions")
    @AuthProviderRESTExposure
    public void patchPermissions(@QueryParam("token") String authToken,
            @PathParam("username") String username,
            List<APIPatch<String>> patches) throws GuacamoleException {

        UserContext userContext = authenticationService.getUserContext(authToken);
        
        // Get the user directory
        Directory<String, User> userDirectory = userContext.getUserDirectory();

        // Get the user
        User user = userContext.getUserDirectory().get(username);
        if (user == null)
            throw new GuacamoleResourceNotFoundException("No such user: \""  username  "\"");

        // Apply all patch operations individually
        for (APIPatch<String> patch : patches) {

            Permission permission;

            String path = patch.getPath();

            // Create connection permission if path has connection prefix
            if (path.startsWith(CONNECTION_PERMISSION_PATCH_PATH_PREFIX)) {

                // Get identifier and type from patch operation
                String identifier = path.substring(CONNECTION_PERMISSION_PATCH_PATH_PREFIX.length());
                ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());

                // Create corresponding permission
                permission = new ConnectionPermission(type, identifier);
                
            }

            // Create connection group permission if path has connection group prefix
            else if (path.startsWith(CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX)) {

                // Get identifier and type from patch operation
                String identifier = path.substring(CONNECTION_GROUP_PERMISSION_PATCH_PATH_PREFIX.length());
                ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());

                // Create corresponding permission
                permission = new ConnectionGroupPermission(type, identifier);
                
            }

            // Create user permission if path has user prefix
            else if (path.startsWith(USER_PERMISSION_PATCH_PATH_PREFIX)) {

                // Get identifier and type from patch operation
                String identifier = path.substring(USER_PERMISSION_PATCH_PATH_PREFIX.length());
                ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());

                // Create corresponding permission
                permission = new UserPermission(type, identifier);
                
            }

            // Create system permission if path is system path
            else if (path.startsWith(SYSTEM_PERMISSION_PATCH_PATH)) {

                // Get identifier and type from patch operation
                SystemPermission.Type type = SystemPermission.Type.valueOf(patch.getValue());

                // Create corresponding permission
                permission = new SystemPermission(type);
                
            }

            // Otherwise, the path is not supported
            else
                throw new HTTPException(Status.BAD_REQUEST, "Unsupported patch path: \""  path  "\"");

            // Add or remove permission based on operation
            switch (patch.getOp()) {

                // Add permission
                case add:
                    user.addPermission(permission);
                    break;

                // Remove permission
                case remove:
                    user.removePermission(permission);
                    break;

                // Unsupported patch operation
                default:
                    throw new HTTPException(Status.BAD_REQUEST,
                            "Unsupported patch operation: \""  patch.getOp()  "\"");

            }

        } // end for each patch operation
        
        // Save the permission changes
        userDirectory.update(user);

        if (identifier != null && identifier.equals(APIConnectionGroup.ROOT_IDENTIFIER))
        // Retrieve connection to update
        // Build updated configuration
        // Update connection parent
        ConnectionGroup updatedParentGroup = retrieveConnectionGroup(userContext, connection.getParentIdentifier());
        connectionDirectory.move(connectionID, updatedParentGroup.getConnectionDirectory());

        bind(ObjectRetrievalService.class);
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
     * Service for convenient retrieval of objects.
     */
    @Inject
    private ObjectRetrievalService retrievalService;
    
    /**
        // Retrieve the requested connection
        return new APIConnection(retrievalService.retrieveConnection(userContext, connectionID));
        // Retrieve the requested connection
        Connection connection = retrievalService.retrieveConnection(userContext, connectionID);
        // Retrieve the requested connection's history
        Connection connection = retrievalService.retrieveConnection(userContext, connectionID);
        // Delete the specified connection
        ConnectionGroup parentConnectionGroup = retrievalService.retrieveConnectionGroup(userContext, parentID);
        Connection existingConnection = retrievalService.retrieveConnection(userContext, connectionID);

        ConnectionGroup updatedParentGroup = retrievalService.retrieveConnectionGroup(userContext, connection.getParentIdentifier());
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
     * Service for convenient retrieval of objects.
     */
    @Inject
    private ObjectRetrievalService retrievalService;
    
    /**

        // Retrieve specified connection group
        try {
            connectionGroup = retrievalService.retrieveConnectionGroup(userContext, identifier);
        }
        catch (GuacamoleResourceNotFoundException e) {
            return null;
        // Retrieve parent group
        ConnectionGroup parentConnectionGroup = retrievalService.retrieveConnectionGroup(userContext, parentID);
        // Get the connection group directory
        // Retrieve connection group to update
        ConnectionGroup existingConnectionGroup = connectionGroupDirectory.get(connectionGroupID);
        
        existingConnectionGroup.setName(connectionGroup.getName());
        existingConnectionGroup.setType(connectionGroup.getType());
        connectionGroupDirectory.update(existingConnectionGroup);

        // Update connection group parent
        ConnectionGroup updatedParentGroup = retrievalService.retrieveConnectionGroup(userContext, connectionGroup.getParentIdentifier());
        connectionGroupDirectory.move(connectionGroupID, updatedParentGroup.getConnectionGroupDirectory());
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
     * Service for convenient retrieval of objects.
     */
    @Inject
    private ObjectRetrievalService retrievalService;

    /**
        // Retrieve the requested user
        User user = retrievalService.retrieveUser(userContext, username);
        User existingUser = retrievalService.retrieveUser(userContext, username);
        bind(ObjectRetrievalService.class);
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
     * Service for convenient retrieval of objects.
     */
    @Inject
    private ObjectRetrievalService retrievalService;
    
    /**
        // Retrieve the requested connection
        return new APIConnection(retrievalService.retrieveConnection(userContext, connectionID));
        // Retrieve the requested connection
        Connection connection = retrievalService.retrieveConnection(userContext, connectionID);
        // Retrieve the requested connection's history
        Connection connection = retrievalService.retrieveConnection(userContext, connectionID);
        // Delete the specified connection
        ConnectionGroup parentConnectionGroup = retrievalService.retrieveConnectionGroup(userContext, parentID);
        // Retrieve connection to update
        Connection existingConnection = retrievalService.retrieveConnection(userContext, connectionID);

        // Build updated configuration
        // Update connection parent
        ConnectionGroup updatedParentGroup = retrievalService.retrieveConnectionGroup(userContext, connection.getParentIdentifier());
        connectionDirectory.move(connectionID, updatedParentGroup.getConnectionDirectory());


import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
     * Service for convenient retrieval of objects.
     */
    @Inject
    private ObjectRetrievalService retrievalService;
    
    /**

        // Retrieve specified connection group
        try {
            connectionGroup = retrievalService.retrieveConnectionGroup(userContext, identifier);
        }
        catch (GuacamoleResourceNotFoundException e) {
            return null;
        // Retrieve parent group
        ConnectionGroup parentConnectionGroup = retrievalService.retrieveConnectionGroup(userContext, parentID);
        // Get the connection group directory
        // Retrieve connection group to update
        ConnectionGroup existingConnectionGroup = connectionGroupDirectory.get(connectionGroupID);
        
        existingConnectionGroup.setName(connectionGroup.getName());
        existingConnectionGroup.setType(connectionGroup.getType());
        connectionGroupDirectory.update(existingConnectionGroup);

        // Update connection group parent
        ConnectionGroup updatedParentGroup = retrievalService.retrieveConnectionGroup(userContext, connectionGroup.getParentIdentifier());
        connectionGroupDirectory.move(connectionGroupID, updatedParentGroup.getConnectionGroupDirectory());
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
     * Service for convenient retrieval of objects.
     */
    @Inject
    private ObjectRetrievalService retrievalService;

    /**
        // Retrieve the requested user
        User user = retrievalService.retrieveUser(userContext, username);
        User existingUser = retrievalService.retrieveUser(userContext, username);
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
        Environment env = new LocalEnvironment();
        
        String hostname = env.getProperty(Environment.GUACD_HOSTNAME);
        int port = env.getProperty(Environment.GUACD_PORT);
        if (env.getProperty(Environment.GUACD_SSL, false))
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 * @deprecated
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(GuacamoleHome.class);

    static {
        // Warn about deprecation
        logger.warn("GuacamoleHome is deprecated. Please use Environment instead.");
    }
    
    /**
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 * @deprecated
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(GuacamoleProperties.class);

    static {
        // Warn about deprecation
        logger.warn("GuacamoleProperties is deprecated. Please use Environment instead.");
    }
 
    /**
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/protocols/ProtocolInfo.java
package org.glyptodon.guacamole.protocols;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/protocols/ProtocolParameter.java
package org.glyptodon.guacamole.protocols;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/protocols/ProtocolParameterOption.java
package org.glyptodon.guacamole.protocols;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/DocumentHandler.java
package org.glyptodon.guacamole.xml;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/TagHandler.java
package org.glyptodon.guacamole.xml;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/package-info.java
package org.glyptodon.guacamole.xml;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/protocol/OptionTagHandler.java
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.protocols.ProtocolParameterOption;
import org.glyptodon.guacamole.xml.TagHandler;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/protocol/ParamTagHandler.java
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.protocols.ProtocolParameter;
import org.glyptodon.guacamole.xml.TagHandler;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/protocol/ProtocolTagHandler.java
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.protocols.ProtocolInfo;
import org.glyptodon.guacamole.xml.TagHandler;
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/xml/protocol/package-info.java
package org.glyptodon.guacamole.xml.protocol;
import org.glyptodon.guacamole.xml.DocumentHandler;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
import org.glyptodon.guacamole.protocols.ProtocolInfo;
        Environment env = new LocalEnvironment();
        return env.getProtocols();
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
import org.glyptodon.guacamole.xml.TagHandler;
        File[] files = libDirectory.listFiles(new FilenameFilter() {
        });

        // Verify directory was successfully read
        if (files == null)
            throw new GuacamoleException("Unable to read contents of directory "  libDirectory);

        // Add the URL for each .jar to the jar URL list
        for (File file : files) {
        // Get current state
        DocumentHandlerState current = getCurrentState();
        if (current == null)
            throw new SAXException("Character data not allowed outside XML document.");
        
        current.getTextContent().append(ch, start, length);
            // Warn if directory contents are not available
            if (files == null) {
                logger.error("Unable to read contents of \"{}\".", protocol_directory.getAbsolutePath());
                files = new File[0];
            }
            
            // Warn if directory contents are not available
            if (files == null) {
                logger.error("Unable to read contents of \"{}\".", protocol_directory.getAbsolutePath());
                files = new File[0];
            }
            
        // Get current state
        DocumentHandlerState current = getCurrentState();
        if (current == null)
            throw new SAXException("Character data not allowed outside XML document.");
        
        current.getTextContent().append(ch, start, length);
        File[] files = libDirectory.listFiles(new FilenameFilter() {
        });

        // Verify directory was successfully read
        if (files == null)
            throw new GuacamoleException("Unable to read contents of directory "  libDirectory);

        // Add the URL for each .jar to the jar URL list
        for (File file : files) {
        User user;

        // If username is own username, just use self - might not have query permissions
        if (userContext.self().getUsername().equals(username))
            user = userContext.self();

        // If not self, query corresponding user from directory
        else {
            user = userContext.getUserDirectory().get(username);
            if (user == null)
                throw new GuacamoleResourceNotFoundException("No such user: \""  username  "\"");
        }
        User user;

        // If username is own username, just use self - might not have query permissions
        if (userContext.self().getUsername().equals(username))
            user = userContext.self();

        // If not self, query corresponding user from directory
        else {
            user = userContext.getUserDirectory().get(username);
            if (user == null)
                throw new GuacamoleResourceNotFoundException("No such user: \""  username  "\"");
        }
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;

    /**
     * System administration permission.
     */
    private static final Permission SYSTEM_PERMISSION = 
                new SystemPermission(SystemPermission.Type.ADMINISTER);
        User self = userContext.self();

        // Deny access if adminstrative or update permission is missing
        if (!self.hasPermission(SYSTEM_PERMISSION)
         && !self.hasPermission(new ConnectionPermission(ObjectPermission.Type.UPDATE, connectionID)))
            throw new GuacamoleSecurityException("Permission to read connection parameters denied.");
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ConnectionPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.Permission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;

    /**
     * System administration permission.
     */
    private static final Permission SYSTEM_PERMISSION = 
                new SystemPermission(SystemPermission.Type.ADMINISTER);
        User self = userContext.self();

        // Deny access if adminstrative or update permission is missing
        if (!self.hasPermission(SYSTEM_PERMISSION)
         && !self.hasPermission(new ConnectionPermission(ObjectPermission.Type.UPDATE, connectionID)))
            throw new GuacamoleSecurityException("Permission to read connection parameters denied.");
        // Get old and new parents
        String oldParentIdentifier = existingConnection.getParentIdentifier();

        // Update connection parent, if changed
        if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getParentIdentifier()))
             || (oldParentIdentifier == null && updatedParentGroup.getParentIdentifier() != null))
            connectionDirectory.move(connectionID, updatedParentGroup.getConnectionDirectory());
        // Get old and new parents
        String oldParentIdentifier = existingConnectionGroup.getParentIdentifier();

        // Update connection group parent, if changed
        if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getParentIdentifier()))
             || (oldParentIdentifier == null && updatedParentGroup.getParentIdentifier() != null))
            connectionGroupDirectory.move(connectionGroupID, updatedParentGroup.getConnectionGroupDirectory());
        // Get old and new parents
        String oldParentIdentifier = existingConnection.getParentIdentifier();

        // Update connection parent, if changed
        if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getParentIdentifier()))
             || (oldParentIdentifier == null && updatedParentGroup.getParentIdentifier() != null))
            connectionDirectory.move(connectionID, updatedParentGroup.getConnectionDirectory());
        // Get old and new parents
        String oldParentIdentifier = existingConnectionGroup.getParentIdentifier();

        // Update connection group parent, if changed
        if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getParentIdentifier()))
             || (oldParentIdentifier == null && updatedParentGroup.getParentIdentifier() != null))
            connectionGroupDirectory.move(connectionGroupID, updatedParentGroup.getConnectionGroupDirectory());
        if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getIdentifier()))
             || (oldParentIdentifier == null && updatedParentGroup.getIdentifier() != null))
        if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getIdentifier()))
             || (oldParentIdentifier == null && updatedParentGroup.getIdentifier() != null))
        if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getIdentifier()))
             || (oldParentIdentifier == null && updatedParentGroup.getIdentifier() != null))
        if (    (oldParentIdentifier != null && !oldParentIdentifier.equals(updatedParentGroup.getIdentifier()))
             || (oldParentIdentifier == null && updatedParentGroup.getIdentifier() != null))
            this.setParentIdentifier(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER);
            this.setParentIdentifier(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER);
            this.setParentIdentifier(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER);
            this.setParentIdentifier(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER);
    private Credentials credentials;
    private UserContext userContext;
     * Replaces the credentials associated with this session with the given
     * credentials.
     *
     * @param credentials
     *     The credentials to associate with this session.
     */
    public void setCredentials(Credentials credentials) {
        this.credentials = credentials;
    }
    
    /**
     * Replaces the user context associated with this session with the given
     * user context.
     *
     * @param userContext
     *     The user context to associate with this session.
     */
    public void setUserContext(UserContext userContext) {
        this.userContext = userContext;
    }
    
    /**
     * with the user's UserContext for use by further requests. If an existing
     * token is provided, the authentication procedure will attempt to update
     * or reuse the provided token.
     * @param username
     *     The username of the user who is to be authenticated.
     *
     * @param password
     *     The password of the user who is to be authenticated.
     *
     * @param token
     *     An optional existing auth token for the user who is to be
     *     authenticated.
     *
     * @param request
     *     The HttpServletRequest associated with the login attempt.
     *
            @FormParam("password") String password,
            @FormParam("token") String token,

        // Pull existing session if token provided
        GuacamoleSession existingSession;
        if (token != null)
            existingSession = tokenSessionMap.get(token);
        else
            existingSession = null;

        // Build credentials

            // Update existing user context if session already exists
            if (existingSession != null)
                userContext = authProvider.updateUserContext(existingSession.getUserContext(), credentials);

            /// Otherwise, generate a new user context
            else
                userContext = authProvider.getUserContext(credentials);


        // Update existing session, if it exists
        String authToken;
        if (existingSession != null) {
            authToken = token;
            existingSession.setCredentials(credentials);
            existingSession.setUserContext(userContext);
        }

        // If no existing session, generate a new token/session pair
        else {
            authToken = authTokenGenerator.getToken();
            tokenSessionMap.put(authToken, new GuacamoleSession(credentials, userContext));
        }
import java.io.UnsupportedEncodingException;
import javax.xml.bind.DatatypeConverter;
        // If no username/password given, try Authorization header
        if (username == null && password == null) {

            String authorization = request.getHeader("Authorization");
            if (authorization != null && authorization.startsWith("Basic ")) {

                try {

                    // Decode base64 authorization
                    String basicBase64 = authorization.substring(6);
                    String basicCredentials = new String(DatatypeConverter.parseBase64Binary(basicBase64), "UTF-8");

                    // Pull username/password from auth data
                    int colon = basicCredentials.indexOf(':');
                    if (colon != -1) {
                        username = basicCredentials.substring(0, colon);
                        password = basicCredentials.substring(colon  1);
                    }
                    else
                        logger.debug("Invalid HTTP Basic \"Authorization\" header received.");

                }

                // UTF-8 support is required by the Java specification
                catch (UnsupportedEncodingException e) {
                    throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
                }

            }

        } // end Authorization header fallback
        
        return new APIAuthToken(authToken, userContext.self().getUsername());
     * The credentials provided when the user authenticated.
     * authenticated.
     * @return
     *     The credentials used when the user associated with this session
     *     authenticated.
     * The credentials provided when the user authenticated.
    private Credentials credentials;
    private UserContext userContext;
     * authenticated.
     * @return
     *     The credentials used when the user associated with this session
     *     authenticated.
     * Replaces the credentials associated with this session with the given
     * credentials.
     *
     * @param credentials
     *     The credentials to associate with this session.
     */
    public void setCredentials(Credentials credentials) {
        this.credentials = credentials;
    }
    
    /**
     * Replaces the user context associated with this session with the given
     * user context.
     *
     * @param userContext
     *     The user context to associate with this session.
     */
    public void setUserContext(UserContext userContext) {
        this.userContext = userContext;
    }
    
    /**
import java.io.UnsupportedEncodingException;
import javax.xml.bind.DatatypeConverter;
     * with the user's UserContext for use by further requests. If an existing
     * token is provided, the authentication procedure will attempt to update
     * or reuse the provided token.
     * @param username
     *     The username of the user who is to be authenticated.
     *
     * @param password
     *     The password of the user who is to be authenticated.
     *
     * @param token
     *     An optional existing auth token for the user who is to be
     *     authenticated.
     *
     * @param request
     *     The HttpServletRequest associated with the login attempt.
     *
            @FormParam("password") String password,
            @FormParam("token") String token,

        // Pull existing session if token provided
        GuacamoleSession existingSession;
        if (token != null)
            existingSession = tokenSessionMap.get(token);
        else
            existingSession = null;

        // If no username/password given, try Authorization header
        if (username == null && password == null) {

            String authorization = request.getHeader("Authorization");
            if (authorization != null && authorization.startsWith("Basic ")) {

                try {

                    // Decode base64 authorization
                    String basicBase64 = authorization.substring(6);
                    String basicCredentials = new String(DatatypeConverter.parseBase64Binary(basicBase64), "UTF-8");

                    // Pull username/password from auth data
                    int colon = basicCredentials.indexOf(':');
                    if (colon != -1) {
                        username = basicCredentials.substring(0, colon);
                        password = basicCredentials.substring(colon  1);
                    }
                    else
                        logger.debug("Invalid HTTP Basic \"Authorization\" header received.");

                }

                // UTF-8 support is required by the Java specification
                catch (UnsupportedEncodingException e) {
                    throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
                }

            }

        } // end Authorization header fallback
        // Build credentials

            // Update existing user context if session already exists
            if (existingSession != null)
                userContext = authProvider.updateUserContext(existingSession.getUserContext(), credentials);

            /// Otherwise, generate a new user context
            else
                userContext = authProvider.getUserContext(credentials);


        // Update existing session, if it exists
        String authToken;
        if (existingSession != null) {
            authToken = token;
            existingSession.setCredentials(credentials);
            existingSession.setUserContext(userContext);
        }

        // If no existing session, generate a new token/session pair
        else {
            authToken = authTokenGenerator.getToken();
            tokenSessionMap.put(authToken, new GuacamoleSession(credentials, userContext));
        }
        return new APIAuthToken(authToken, userContext.self().getUsername());

    /**
     * Given an arbitrary map containing String values, replace each non-null
     * value with the corresponding filtered value.
     *
     * @param map
     *     The map whose values should be filtered.
     */
    public void filterValues(Map<?, String> map) {

        // For each map entry
        for (Map.Entry<?, String> entry : map.entrySet()) {

            // If value is non-null, filter value through this TokenFilter
            String value = entry.getValue();
            if (value != null)
                entry.setValue(filter(value));
            
        }
        
    }

import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
        // Build credential TokenFilter
        TokenFilter tokenFilter = new TokenFilter();
        StandardTokens.addStandardTokens(tokenFilter, credentials);
        
        // Filter each configuration
        for (GuacamoleConfiguration config : configs.values())
            tokenFilter.filterValues(config.getParameters());
        
import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
        // Build credential TokenFilter
        TokenFilter tokenFilter = new TokenFilter();
        StandardTokens.addStandardTokens(tokenFilter, credentials);
        
        // Filter each configuration
        for (GuacamoleConfiguration config : configs.values())
            tokenFilter.filterValues(config.getParameters());
        
     * The user who this connection directory belongs to. Access is based on
     * his/her permission settings.
    private AuthenticatedUser currentUser;
     * @param currentUser
     *     The user owning this connection directory.
     *
     * @param parentID
     *     The ID of the parent connection group.
    public void init(AuthenticatedUser currentUser, Integer parentID) {
        this.currentUser = currentUser;
                connectionService.retrieveConnection(identifier, currentUser);
                (connection.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
                currentUser,
                (parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        return permissionCheckService.retrieveConnectionIdentifiers(currentUser, 
        permissionCheckService.verifySystemAccess(currentUser,
        permissionCheckService.verifyConnectionGroupAccess(currentUser, 
                (parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
                connectionService.retrieveConnection(name, parentID, currentUser);
                name, object.getConfiguration().getProtocol(), currentUser, parentID);
        newConnectionPermission.setUser_id(currentUser.getUserID());
        permissionCheckService.verifyConnectionAccess(currentUser,
                connectionService.retrieveConnection(identifier, currentUser);
                (mySQLConnection.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        permissionCheckService.verifyConnectionAccess(currentUser,
                connectionService.retrieveConnection(identifier, currentUser);
        permissionCheckService.verifyConnectionAccess(currentUser,
                (mySQLConnection.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
                (toConnectionGroupID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
                toConnectionGroupID, currentUser);
     * The user who this connection directory belongs to. Access is based on
     * his/her permission settings.
    private AuthenticatedUser currentUser;
     * @param currentUser
     *     The user owning this connection group directory.
     *
     * @param parentID
     *     The ID of the parent connection group.
    public void init(AuthenticatedUser currentUser, Integer parentID) {
        this.currentUser = currentUser;
                connectionGroupService.retrieveConnectionGroup(identifier, currentUser);
                (connectionGroup.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
                currentUser,
                (parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        return permissionCheckService.retrieveConnectionGroupIdentifiers(currentUser, 
        permissionCheckService.verifySystemAccess(currentUser,
        permissionCheckService.verifyConnectionGroupAccess(currentUser, 
                (parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
                connectionGroupService.retrieveConnectionGroup(name, parentID, currentUser);
                .createConnectionGroup(name, currentUser, parentID, mySQLType);
        newConnectionGroupPermission.setUser_id(currentUser.getUserID());
        permissionCheckService.verifyConnectionAccess(currentUser,
                connectionGroupService.retrieveConnectionGroup(identifier, currentUser);
                (mySQLConnectionGroup.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
                connectionGroupService.retrieveConnectionGroup(identifier, currentUser);
        permissionCheckService.verifyConnectionAccess(currentUser,
                (mySQLConnectionGroup.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
                (toConnectionGroupID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
                toConnectionGroupID, currentUser);
                    retrieveConnectionGroup(relativeParentID, currentUser);
            context.init(new AuthenticatedUser(authenticatedUser.getUserID(), credentials));
     * The user who queried or created this connection.
    private AuthenticatedUser currentUser;
     * @param connectionID
     *     The ID of the associated database record, if any.
     *
     * @param parentID
     *     The ID of the parent connection group for this connection, if any.
     *
     * @param name 
     *     The human-readable name associated with this connection.
     *
     * @param identifier
     *     The unique identifier associated with this connection.
     *
     * @param config
     *     The GuacamoleConfiguration associated with this connection.
     *
     * @param history
     *     All ConnectionRecords associated with this connection.
     *
     * @param currentUser 
     *     The user who queried this connection.
            List<? extends ConnectionRecord> history,
            AuthenticatedUser currentUser) {
        this.currentUser = currentUser;
        return connectionService.connect(this, info, currentUser, null);
     * The user who queried or created this connection group.
    private AuthenticatedUser currentUser;
     * @param connectionGroupID
     *     The ID of the associated database record, if any.
     *
     * @param parentID
     *     The ID of the parent connection group for this connection group, if
     *     any.
     *
     * @param name
     *     The name of this connection group.
     *
     * @param identifier
     *     The unique identifier associated with this connection group.
     *
     * @param type
     *     The type of this connection group.
     *
     * @param currentUser
     *     The user who queried this connection.
            String identifier, ConnectionGroup.Type type, AuthenticatedUser currentUser) {
        this.currentUser = currentUser;
        connectionDirectory.init(currentUser, connectionGroupID);
        connectionGroupDirectory.init(currentUser, connectionGroupID);
                (this.connectionGroupID, currentUser, MySQLConstants.CONNECTION_GROUP_BALANCING);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
        return connectionGroupService.connect(this, info, currentUser);
import org.glyptodon.guacamole.net.auth.Credentials;
     * The the user owning this context. The permissions of this user dictate
     * the access given via the user and connection directories.
    private AuthenticatedUser currentUser;
     * @param currentUser
     *     The user owning this context.
    public void init(AuthenticatedUser currentUser) {
        this.currentUser = currentUser;
        userDirectory.init(currentUser);
                ConnectionGroup.Type.ORGANIZATIONAL, currentUser);
        return userService.retrieveUser(currentUser.getUserID());
     * The user this user directory belongs to. Access is based on his/her
     * permission settings.
    private AuthenticatedUser currentUser;
     * @param currentUser
     *     The user whose permissions define the visibility of other users in
     *     this directory.
    public void init(AuthenticatedUser currentUser) {
        this.currentUser = currentUser;
        permissionCheckService.verifyUserAccess(currentUser,
        return permissionCheckService.retrieveUsernames(currentUser,
        permissionCheckService.verifySystemAccess(currentUser,
        newUserPermission.setUser_id(currentUser.getUserID());
            permissionCheckService.retrieveUserIDs(currentUser,
                      "User #"  currentUser.getUserID()
            newPermission.setUser_id(currentUser.getUserID());
            permissionCheckService.retrieveUserIDs(currentUser,
                      "User #"  currentUser.getUserID()
            permissionCheckService.retrieveConnectionIDs(currentUser,
                      "User #"  currentUser.getUserID()
            permissionCheckService.retrieveConnectionGroupIDs(currentUser,
                      "User #"  currentUser.getUserID()
            permissionCheckService.retrieveConnectionIDs(currentUser,
                      "User #"  currentUser.getUserID()
            permissionCheckService.retrieveConnectionGroupIDs(currentUser,
                      "User #"  currentUser.getUserID()
                currentUser, SystemPermission.Type.ADMINISTER.name());
        if (user_id == currentUser.getUserID())
        permissionCheckService.verifyUserAccess(currentUser,
        if (user.getUserID() == currentUser.getUserID())
        permissionCheckService.verifyUserAccess(currentUser,
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
     * @param name
     *     The name of the connection to return.
     *
     * @param parentID
     *     The ID of the parent connection group.
     *
     * @param currentUser
     *     The user who queried this connection group.
     *
     * @return
     *     The connection having the given name, or null if no such connection
     *     group could be found.
            AuthenticatedUser currentUser) {
        return toMySQLConnectionGroup(connectionGroups.get(0), currentUser);
     * @param uniqueIdentifier
     *     The unique identifier of the connection group to retrieve.
     *
     * @param currentUser 
     *     The user who queried this connection group.
     *
     * @return
     *     The connection group having the given unique identifier, or null if
     *     no such connection group was found.
     * 
     * @throws GuacamoleException
     *     If an error occurs while retrieving the connection group.
            AuthenticatedUser currentUser) throws GuacamoleException {
        return retrieveConnectionGroup(connectionGroupID, currentUser);
     * @param id
     *     The ID of the connection group to retrieve.
     *
     * @param currentUser
     *     The user who queried this connection.
     *
     * @return
     *     The connection group having the given ID, or null if no such
     *     connection was found.
    public MySQLConnectionGroup retrieveConnectionGroup(Integer id, AuthenticatedUser currentUser) {
                    currentUser);
        return toMySQLConnectionGroup(connectionGroup, currentUser);
     * @param group
     *     The group to load balance across.
     *
     * @param info
     *     The information to use when performing the connection handshake.
     *
     * @param currentUser
     *     The user who is connecting to the socket.
     * 
     * @return
     *     The connected socket.
     *
     * @throws GuacamoleException
     *     If an error occurs while connecting the socket.
            GuacamoleClientInformation info, AuthenticatedUser currentUser)
            throws GuacamoleException {
                    && activeConnectionMap.isConnectionGroupUserActive(group.getConnectionGroupID(), currentUser.getUserID()))
                    .retrieveConnection(leastUsedConnectionID, currentUser);
            return connectionService.connect(connection, info, currentUser, group.getConnectionGroupID());
     * @param connection
     *     The connection to convert.
     *
     * @param currentUser
     *     The user who queried this connection.
     *
     * @return
     *     A new MySQLConnection containing all data associated with the
     *     specified connection.
    private MySQLConnectionGroup toMySQLConnectionGroup(ConnectionGroup connectionGroup,
            AuthenticatedUser currentUser) {
            currentUser
     * @param name
     *     The name to assign to the new connection group.
     *
     * @param currentUser
     *     The user who created this connection group.
     *
     * @param parentID
     *     The ID of the parent of the new connection group, if any.
     *
     * @param type
     *     The type of the new connection group.
     *
    public MySQLConnectionGroup createConnectionGroup(String name, AuthenticatedUser currentUser, 
        return toMySQLConnectionGroup(connectionGroup, currentUser);
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
     * @param name
     *     The name of the connection to return.
     *
     * @param parentID
     *     The ID of the parent connection group.
     *
     * @param currentUser 
     *     The user who queried this connection.
     *
     * @return
     *     The connection having the given name, or null if no such
     *     connection could be found.
            AuthenticatedUser currentUser) {
        return toMySQLConnection(connections.get(0), currentUser);
     * @param uniqueIdentifier
     *     The unique identifier of the connection to retrieve.
     * 
     * @param currentUser
     *     The user who queried this connection.
     *
     * @return
     *     The connection having the given unique identifier, or null if no
     *     such connection was found.
    public MySQLConnection retrieveConnection(String uniqueIdentifier, AuthenticatedUser currentUser) {
        return retrieveConnection(connectionID, currentUser);
     * @param id
     *     The ID of the connection to retrieve.
     *
     * @param currentUser
     *     The user who queried this connection.
     *
     * @return
     *     The connection having the given ID, or null if no such connection
     *     was found.
    public MySQLConnection retrieveConnection(int id, AuthenticatedUser currentUser) {
        return toMySQLConnection(connection, currentUser);
     * @param connection
     *     The connection to convert.
     *
     * @param currentUser
     *     The user who queried this connection.
     *
    private MySQLConnection toMySQLConnection(Connection connection, AuthenticatedUser currentUser) {
            currentUser
     * @param connection
     *     The connection to use when connecting the socket.
     *
     * @param info
     *     The information to use when performing the connection handshake.
     *
     * @param currentUser 
     *     The user who is connecting to the socket.
     *
     * @param connectionGroupID
     *     The ID of the balancing connection group that is being connected to;
     *     null if not used.
     *
     * @return
     *     The connected socket.
     *
     * @throws GuacamoleException
     *     If an error occurs while connecting the socket.
            GuacamoleClientInformation info, AuthenticatedUser currentUser,
            Integer connectionGroupID)
                    && activeConnectionMap.isConnectionUserActive(connection.getConnectionID(), currentUser.getUserID()))
            // Build token filter containing credential tokens
            TokenFilter tokenFilter = new TokenFilter();
            StandardTokens.addStandardTokens(tokenFilter, currentUser.getCredentials());

            // Filter the configuration
            GuacamoleConfiguration config = new GuacamoleConfiguration(connection.getConfiguration());
            tokenFilter.filterValues(config.getParameters());
            
                    config, info
                    config, info
                    currentUser.getUserID(), connectionGroupID);
     * @param name
     *     The name to assign to the new connection.
     *
     * @param protocol
     *     The protocol to assign to the new connection.
     *
     * @param currentUser
     *     The user who created this connection.
     *
     * @param parentID
     *     The ID of the parent connection group.
     *
     * @return
     *     A new MySQLConnection containing the data of the newly created
     *     connection.
            AuthenticatedUser currentUser, Integer parentID) {
        return toMySQLConnection(connection, currentUser);
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
     * @param currentUser
     *     The user to check.
     *
     * @param affectedUserID
     *     The user that would be affected by the operation if permission is
     *     granted.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @throws GuacamoleSecurityException
     *     If the specified permission is not granted.
    public void verifyUserAccess(AuthenticatedUser currentUser, int affectedUserID,
        if(!checkUserAccess(currentUser, affectedUserID, permissionType))
     * @param currentUser
     *     The user to check.
     *
     * @param affectedConnectionID
     *     The connection that would be affected by the operation if permission
     *     is granted.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @throws GuacamoleSecurityException
     *     If the specified permission is not granted.
    public void verifyConnectionAccess(AuthenticatedUser currentUser,
            int affectedConnectionID, String permissionType) throws GuacamoleSecurityException {
        if(!checkConnectionAccess(currentUser, affectedConnectionID, permissionType))
     * @param currentUser
     *     The user to check.
     *
     * @param affectedConnectionGroupID
     *     The connection group that would be affected by the operation if
     *     permission is granted.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @throws GuacamoleSecurityException
     *     If the specified permission is not granted.
    public void verifyConnectionGroupAccess(AuthenticatedUser currentUser,
            Integer affectedConnectionGroupID, String permissionType) throws GuacamoleSecurityException {
        if(!checkConnectionGroupAccess(currentUser, affectedConnectionGroupID, permissionType))
     * @param currentUser
     *     The user to check.
     *
     * @param systemPermissionType
     *     The type of permission to check for.
     *
     * @throws GuacamoleSecurityException
     *     If the specified permission is not granted.
    public void verifySystemAccess(AuthenticatedUser currentUser, String systemPermissionType)
        if(!checkSystemAccess(currentUser, systemPermissionType))
     * @param currentUser
     *     The user to check.
     *
     * @param affectedUserID
     *     The user that would be affected by the operation if permission is
     *     granted.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     true if the specified permission is granted, false otherwise.
    public boolean checkUserAccess(AuthenticatedUser currentUser,
            Integer affectedUserID, String permissionType) {
        if(checkSystemAdministratorAccess(currentUser))
        example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andAffected_user_idEqualTo(affectedUserID).andPermissionEqualTo(permissionType);
     * @param currentUser
     *     The user to check.
     *
     * @param affectedConnectionID
     *     The connection that would be affected by the operation if permission
     *     is granted.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     true if the specified permission is granted, false otherwise.
    public boolean checkConnectionAccess(AuthenticatedUser currentUser,
            Integer affectedConnectionID, String permissionType) {
        if(checkSystemAdministratorAccess(currentUser))
        example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andConnection_idEqualTo(affectedConnectionID).andPermissionEqualTo(permissionType);
     * @param currentUser
     *     The user to check.
     *
     * @param affectedConnectionGroupID
     *     The connection group that would be affected by the operation if
     *     permission is granted.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     true if the specified permission is granted, false otherwise.
    public boolean checkConnectionGroupAccess(AuthenticatedUser currentUser,
            Integer affectedConnectionGroupID, String permissionType) {
        if(checkSystemAdministratorAccess(currentUser))
        example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andConnection_group_idEqualTo(affectedConnectionGroupID).andPermissionEqualTo(permissionType);
     * @param currentUser
     *     The user to check.
     *
     * @param systemPermissionType
     *     The type of permission to check for.
     *
     * @return
     *     true if the specified permission is granted, false otherwise.
    private boolean checkSystemAccess(AuthenticatedUser currentUser, String systemPermissionType) {
        if(checkSystemAdministratorAccess(currentUser))
        example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andPermissionEqualTo(systemPermissionType);
     * @param currentUser
     *     The user to check.
     *
     * @return
     *     true if the system administrator access exists, false otherwise.
    private boolean checkSystemAdministratorAccess(AuthenticatedUser currentUser) {
        example.createCriteria().andUser_idEqualTo(currentUser.getUserID())
                .andPermissionEqualTo(MySQLConstants.SYSTEM_ADMINISTER);
     * @param connectionGroupID
     *     The ID of the affected ConnectionGroup.
     *
     * @param currentUser
     *     The user to check.
     * 
     * @param type
     *     The desired usage.
     *
     * @throws GuacamoleSecurityException
     *     If the connection group cannot be used for organization.
            AuthenticatedUser currentUser, String type) throws GuacamoleSecurityException {
        if(!checkConnectionGroupUsageAccess(connectionGroupID, currentUser, type))
     *
     * @param connectionGroupID
     *     The ID of the affected connection group.
     *
     * @param currentUser
     *     The user to check.
     *
     * @param usage
     *     The desired usage.
     *
     * @return
     *     true if the user can use the connection group for the given usage.
            Integer connectionGroupID, AuthenticatedUser currentUser, String usage) {
        if(checkSystemAdministratorAccess(currentUser))
        if(checkConnectionGroupAccess(currentUser, connectionGroupID,
                retrieveConnectionGroup(connectionGroupID, currentUser);
     * @param currentUser
     *     The user to check.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     A list of all user IDs this user has the specified access to.
    public List<Integer> retrieveUserIDs(AuthenticatedUser currentUser, String permissionType) {
        if(checkSystemAdministratorAccess(currentUser))
        example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andPermissionEqualTo(permissionType);
        List<Integer> currentUsers = new ArrayList<Integer>(userPermissions.size());
            currentUsers.add(permission.getAffected_user_id());
        return currentUsers;
     * @param currentUser
     *     The user to check.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     A list of all connection IDs this user has the specified access to.
    public List<Integer> retrieveConnectionIDs(AuthenticatedUser currentUser,
        return retrieveConnectionIDs(currentUser, null, permissionType, false);
     * @param currentUser
     *     The user to check.
     *
     * @param parentID
     *     The parent connection group.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     A list of all connection IDs this user has the specified access to.
    public List<Integer> retrieveConnectionIDs(AuthenticatedUser currentUser, Integer parentID,
        return retrieveConnectionIDs(currentUser, parentID, permissionType, true);
     * @param currentUser
     *     The user to check.
     *
     * @param parentID
     *     The parent connection group.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @param checkParentID
     *     Whether the parentID should be checked or not.
     * 
     * @return
     *     A list of all connection IDs this user has the specified access to.
    private List<Integer> retrieveConnectionIDs(AuthenticatedUser currentUser, Integer parentID,
        if(checkSystemAdministratorAccess(currentUser)) {
        Criteria criteria = example.createCriteria().andUser_idEqualTo(currentUser.getUserID())
     * @param currentUser
     *     The user to check.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     A list of all connection group IDs this user has the specified
     *     access to.
    public List<Integer> retrieveConnectionGroupIDs(AuthenticatedUser currentUser,
        return retrieveConnectionGroupIDs(currentUser, null, permissionType, false);
     * @param currentUser
     *     The user to check.
     *
     * @param parentID
     *     The parent connection group.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     A list of all connection group IDs this user has the specified
     *     access to.
    public List<Integer> retrieveConnectionGroupIDs(AuthenticatedUser currentUser, Integer parentID,
        return retrieveConnectionGroupIDs(currentUser, parentID, permissionType, true);
     * @param currentUser
     *     The user to check.
     * 
     * @param parentID
     *     The parent connection group.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @param checkParentID
     *     Whether the parentID should be checked or not.
     *
     * @return
     *     A list of all connection group IDs this user has the specified
     *     access to.
    private List<Integer> retrieveConnectionGroupIDs(AuthenticatedUser currentUser, Integer parentID,
        if(checkSystemAdministratorAccess(currentUser)) {
                example.createCriteria().andUser_idEqualTo(currentUser.getUserID())
     * @param currentUser
     *     The user whose permissions should be checked.
     *
     * @param permissionType
     *     The permission to check.
     *
     * @return
     *     A set of all usernames for which the given user has the given
     *     permission.
    public Set<String> retrieveUsernames(AuthenticatedUser currentUser, String permissionType) {
        if(checkSystemAdministratorAccess(currentUser))
        List<Integer> currentUsers =
                retrieveUserIDs(currentUser, MySQLConstants.USER_READ);
        return userService.translateUsernames(currentUsers).keySet();
     * @param currentUser
     *     The user whose permissions should be checked.
     *
     * @param permissionType
     *     The permission to check.
     *
     * @param parentID
     *     The parent connection group.
     *
     * @return
     *     A set of all connection identifiers for which the given user has the
     *     given permission.
    public Set<String> retrieveConnectionIdentifiers(AuthenticatedUser currentUser, Integer parentID,
        if(checkSystemAdministratorAccess(currentUser))
                retrieveConnectionIDs(currentUser, parentID, permissionType);
     * @param currentUser
     *     The user whose permissions should be checked.
     *
     * @param permissionType
     *     The permission to check.
     *
     * @param parentID
     *     The parent connection group.
     *
     * @return
     *     A set of all connection group identifiers for which the given user
     *     has the given permission.
    public Set<String> retrieveConnectionGroupIdentifiers(AuthenticatedUser currentUser, Integer parentID,
        if(checkSystemAdministratorAccess(currentUser))
                retrieveConnectionGroupIDs(currentUser, parentID, permissionType);
     * The user who this connection directory belongs to. Access is based on
     * his/her permission settings.
    private AuthenticatedUser currentUser;
     * @param currentUser
     *     The user owning this connection directory.
     *
     * @param parentID
     *     The ID of the parent connection group.
    public void init(AuthenticatedUser currentUser, Integer parentID) {
        this.currentUser = currentUser;
                connectionService.retrieveConnection(identifier, currentUser);
                (connection.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
                currentUser,
                (parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        return permissionCheckService.retrieveConnectionIdentifiers(currentUser, 
        permissionCheckService.verifySystemAccess(currentUser,
        permissionCheckService.verifyConnectionGroupAccess(currentUser, 
                (parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
                connectionService.retrieveConnection(name, parentID, currentUser);
                name, object.getConfiguration().getProtocol(), currentUser, parentID);
        newConnectionPermission.setUser_id(currentUser.getUserID());
        permissionCheckService.verifyConnectionAccess(currentUser,
                connectionService.retrieveConnection(identifier, currentUser);
                (mySQLConnection.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        permissionCheckService.verifyConnectionAccess(currentUser,
                connectionService.retrieveConnection(identifier, currentUser);
        permissionCheckService.verifyConnectionAccess(currentUser,
                (mySQLConnection.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
                (toConnectionGroupID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
                toConnectionGroupID, currentUser);
     * The user who this connection directory belongs to. Access is based on
     * his/her permission settings.
    private AuthenticatedUser currentUser;
     * @param currentUser
     *     The user owning this connection group directory.
     *
     * @param parentID
     *     The ID of the parent connection group.
    public void init(AuthenticatedUser currentUser, Integer parentID) {
        this.currentUser = currentUser;
                connectionGroupService.retrieveConnectionGroup(identifier, currentUser);
                (connectionGroup.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
                currentUser,
                (parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        return permissionCheckService.retrieveConnectionGroupIdentifiers(currentUser, 
        permissionCheckService.verifySystemAccess(currentUser,
        permissionCheckService.verifyConnectionGroupAccess(currentUser, 
                (parentID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
                connectionGroupService.retrieveConnectionGroup(name, parentID, currentUser);
                .createConnectionGroup(name, currentUser, parentID, mySQLType);
        newConnectionGroupPermission.setUser_id(currentUser.getUserID());
        permissionCheckService.verifyConnectionAccess(currentUser,
                connectionGroupService.retrieveConnectionGroup(identifier, currentUser);
                (mySQLConnectionGroup.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
                connectionGroupService.retrieveConnectionGroup(identifier, currentUser);
        permissionCheckService.verifyConnectionAccess(currentUser,
                (mySQLConnectionGroup.getParentID(), currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
                (toConnectionGroupID, currentUser, MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
                toConnectionGroupID, currentUser);
                    retrieveConnectionGroup(relativeParentID, currentUser);
            context.init(new AuthenticatedUser(authenticatedUser.getUserID(), credentials));
     * The user who queried or created this connection.
    private AuthenticatedUser currentUser;
     * @param connectionID
     *     The ID of the associated database record, if any.
     *
     * @param parentID
     *     The ID of the parent connection group for this connection, if any.
     *
     * @param name 
     *     The human-readable name associated with this connection.
     *
     * @param identifier
     *     The unique identifier associated with this connection.
     *
     * @param config
     *     The GuacamoleConfiguration associated with this connection.
     *
     * @param history
     *     All ConnectionRecords associated with this connection.
     *
     * @param currentUser 
     *     The user who queried this connection.
            List<? extends ConnectionRecord> history,
            AuthenticatedUser currentUser) {
        this.currentUser = currentUser;
        return connectionService.connect(this, info, currentUser, null);
     * The user who queried or created this connection group.
    private AuthenticatedUser currentUser;
     * @param connectionGroupID
     *     The ID of the associated database record, if any.
     *
     * @param parentID
     *     The ID of the parent connection group for this connection group, if
     *     any.
     *
     * @param name
     *     The name of this connection group.
     *
     * @param identifier
     *     The unique identifier associated with this connection group.
     *
     * @param type
     *     The type of this connection group.
     *
     * @param currentUser
     *     The user who queried this connection.
            String identifier, ConnectionGroup.Type type, AuthenticatedUser currentUser) {
        this.currentUser = currentUser;
        connectionDirectory.init(currentUser, connectionGroupID);
        connectionGroupDirectory.init(currentUser, connectionGroupID);
                (this.connectionGroupID, currentUser, MySQLConstants.CONNECTION_GROUP_BALANCING);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
        return connectionGroupService.connect(this, info, currentUser);
import org.glyptodon.guacamole.net.auth.Credentials;
     * The the user owning this context. The permissions of this user dictate
     * the access given via the user and connection directories.
    private AuthenticatedUser currentUser;
     * @param currentUser
     *     The user owning this context.
    public void init(AuthenticatedUser currentUser) {
        this.currentUser = currentUser;
        userDirectory.init(currentUser);
                ConnectionGroup.Type.ORGANIZATIONAL, currentUser);
        return userService.retrieveUser(currentUser.getUserID());
     * The user this user directory belongs to. Access is based on his/her
     * permission settings.
    private AuthenticatedUser currentUser;
     * @param currentUser
     *     The user whose permissions define the visibility of other users in
     *     this directory.
    public void init(AuthenticatedUser currentUser) {
        this.currentUser = currentUser;
        permissionCheckService.verifyUserAccess(currentUser,
        return permissionCheckService.retrieveUsernames(currentUser,
        permissionCheckService.verifySystemAccess(currentUser,
        newUserPermission.setUser_id(currentUser.getUserID());
            permissionCheckService.retrieveUserIDs(currentUser,
                      "User #"  currentUser.getUserID()
            newPermission.setUser_id(currentUser.getUserID());
            permissionCheckService.retrieveUserIDs(currentUser,
                      "User #"  currentUser.getUserID()
            permissionCheckService.retrieveConnectionIDs(currentUser,
                      "User #"  currentUser.getUserID()
            permissionCheckService.retrieveConnectionGroupIDs(currentUser,
                      "User #"  currentUser.getUserID()
            permissionCheckService.retrieveConnectionIDs(currentUser,
                      "User #"  currentUser.getUserID()
            permissionCheckService.retrieveConnectionGroupIDs(currentUser,
                      "User #"  currentUser.getUserID()
                currentUser, SystemPermission.Type.ADMINISTER.name());
        if (user_id == currentUser.getUserID())
        permissionCheckService.verifyUserAccess(currentUser,
        if (user.getUserID() == currentUser.getUserID())
        permissionCheckService.verifyUserAccess(currentUser,
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
     * @param name
     *     The name of the connection to return.
     *
     * @param parentID
     *     The ID of the parent connection group.
     *
     * @param currentUser
     *     The user who queried this connection group.
     *
     * @return
     *     The connection having the given name, or null if no such connection
     *     group could be found.
            AuthenticatedUser currentUser) {
        return toMySQLConnectionGroup(connectionGroups.get(0), currentUser);
     * @param uniqueIdentifier
     *     The unique identifier of the connection group to retrieve.
     *
     * @param currentUser 
     *     The user who queried this connection group.
     *
     * @return
     *     The connection group having the given unique identifier, or null if
     *     no such connection group was found.
     * 
     * @throws GuacamoleException
     *     If an error occurs while retrieving the connection group.
            AuthenticatedUser currentUser) throws GuacamoleException {
        return retrieveConnectionGroup(connectionGroupID, currentUser);
     * @param id
     *     The ID of the connection group to retrieve.
     *
     * @param currentUser
     *     The user who queried this connection.
     *
     * @return
     *     The connection group having the given ID, or null if no such
     *     connection was found.
    public MySQLConnectionGroup retrieveConnectionGroup(Integer id, AuthenticatedUser currentUser) {
                    currentUser);
        return toMySQLConnectionGroup(connectionGroup, currentUser);
     * @param group
     *     The group to load balance across.
     *
     * @param info
     *     The information to use when performing the connection handshake.
     *
     * @param currentUser
     *     The user who is connecting to the socket.
     * 
     * @return
     *     The connected socket.
     *
     * @throws GuacamoleException
     *     If an error occurs while connecting the socket.
            GuacamoleClientInformation info, AuthenticatedUser currentUser)
            throws GuacamoleException {
                    && activeConnectionMap.isConnectionGroupUserActive(group.getConnectionGroupID(), currentUser.getUserID()))
                    .retrieveConnection(leastUsedConnectionID, currentUser);
            return connectionService.connect(connection, info, currentUser, group.getConnectionGroupID());
     * @param connection
     *     The connection to convert.
     *
     * @param currentUser
     *     The user who queried this connection.
     *
     * @return
     *     A new MySQLConnection containing all data associated with the
     *     specified connection.
    private MySQLConnectionGroup toMySQLConnectionGroup(ConnectionGroup connectionGroup,
            AuthenticatedUser currentUser) {
            currentUser
     * @param name
     *     The name to assign to the new connection group.
     *
     * @param currentUser
     *     The user who created this connection group.
     *
     * @param parentID
     *     The ID of the parent of the new connection group, if any.
     *
     * @param type
     *     The type of the new connection group.
     *
    public MySQLConnectionGroup createConnectionGroup(String name, AuthenticatedUser currentUser, 
        return toMySQLConnectionGroup(connectionGroup, currentUser);
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
     * @param name
     *     The name of the connection to return.
     *
     * @param parentID
     *     The ID of the parent connection group.
     *
     * @param currentUser 
     *     The user who queried this connection.
     *
     * @return
     *     The connection having the given name, or null if no such
     *     connection could be found.
            AuthenticatedUser currentUser) {
        return toMySQLConnection(connections.get(0), currentUser);
     * @param uniqueIdentifier
     *     The unique identifier of the connection to retrieve.
     * 
     * @param currentUser
     *     The user who queried this connection.
     *
     * @return
     *     The connection having the given unique identifier, or null if no
     *     such connection was found.
    public MySQLConnection retrieveConnection(String uniqueIdentifier, AuthenticatedUser currentUser) {
        return retrieveConnection(connectionID, currentUser);
     * @param id
     *     The ID of the connection to retrieve.
     *
     * @param currentUser
     *     The user who queried this connection.
     *
     * @return
     *     The connection having the given ID, or null if no such connection
     *     was found.
    public MySQLConnection retrieveConnection(int id, AuthenticatedUser currentUser) {
        return toMySQLConnection(connection, currentUser);
     * @param connection
     *     The connection to convert.
     *
     * @param currentUser
     *     The user who queried this connection.
     *
    private MySQLConnection toMySQLConnection(Connection connection, AuthenticatedUser currentUser) {
            currentUser
     * @param connection
     *     The connection to use when connecting the socket.
     *
     * @param info
     *     The information to use when performing the connection handshake.
     *
     * @param currentUser 
     *     The user who is connecting to the socket.
     *
     * @param connectionGroupID
     *     The ID of the balancing connection group that is being connected to;
     *     null if not used.
     *
     * @return
     *     The connected socket.
     *
     * @throws GuacamoleException
     *     If an error occurs while connecting the socket.
            GuacamoleClientInformation info, AuthenticatedUser currentUser,
            Integer connectionGroupID)
                    && activeConnectionMap.isConnectionUserActive(connection.getConnectionID(), currentUser.getUserID()))
            // Build token filter containing credential tokens
            TokenFilter tokenFilter = new TokenFilter();
            StandardTokens.addStandardTokens(tokenFilter, currentUser.getCredentials());

            // Filter the configuration
            GuacamoleConfiguration config = new GuacamoleConfiguration(connection.getConfiguration());
            tokenFilter.filterValues(config.getParameters());
            
                    config, info
                    config, info
                    currentUser.getUserID(), connectionGroupID);
     * @param name
     *     The name to assign to the new connection.
     *
     * @param protocol
     *     The protocol to assign to the new connection.
     *
     * @param currentUser
     *     The user who created this connection.
     *
     * @param parentID
     *     The ID of the parent connection group.
     *
     * @return
     *     A new MySQLConnection containing the data of the newly created
     *     connection.
            AuthenticatedUser currentUser, Integer parentID) {
        return toMySQLConnection(connection, currentUser);
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
     * @param currentUser
     *     The user to check.
     *
     * @param affectedUserID
     *     The user that would be affected by the operation if permission is
     *     granted.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @throws GuacamoleSecurityException
     *     If the specified permission is not granted.
    public void verifyUserAccess(AuthenticatedUser currentUser, int affectedUserID,
        if(!checkUserAccess(currentUser, affectedUserID, permissionType))
     * @param currentUser
     *     The user to check.
     *
     * @param affectedConnectionID
     *     The connection that would be affected by the operation if permission
     *     is granted.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @throws GuacamoleSecurityException
     *     If the specified permission is not granted.
    public void verifyConnectionAccess(AuthenticatedUser currentUser,
            int affectedConnectionID, String permissionType) throws GuacamoleSecurityException {
        if(!checkConnectionAccess(currentUser, affectedConnectionID, permissionType))
     * @param currentUser
     *     The user to check.
     *
     * @param affectedConnectionGroupID
     *     The connection group that would be affected by the operation if
     *     permission is granted.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @throws GuacamoleSecurityException
     *     If the specified permission is not granted.
    public void verifyConnectionGroupAccess(AuthenticatedUser currentUser,
            Integer affectedConnectionGroupID, String permissionType) throws GuacamoleSecurityException {
        if(!checkConnectionGroupAccess(currentUser, affectedConnectionGroupID, permissionType))
     * @param currentUser
     *     The user to check.
     *
     * @param systemPermissionType
     *     The type of permission to check for.
     *
     * @throws GuacamoleSecurityException
     *     If the specified permission is not granted.
    public void verifySystemAccess(AuthenticatedUser currentUser, String systemPermissionType)
        if(!checkSystemAccess(currentUser, systemPermissionType))
     * @param currentUser
     *     The user to check.
     *
     * @param affectedUserID
     *     The user that would be affected by the operation if permission is
     *     granted.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     true if the specified permission is granted, false otherwise.
    public boolean checkUserAccess(AuthenticatedUser currentUser,
            Integer affectedUserID, String permissionType) {
        if(checkSystemAdministratorAccess(currentUser))
        example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andAffected_user_idEqualTo(affectedUserID).andPermissionEqualTo(permissionType);
     * @param currentUser
     *     The user to check.
     *
     * @param affectedConnectionID
     *     The connection that would be affected by the operation if permission
     *     is granted.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     true if the specified permission is granted, false otherwise.
    public boolean checkConnectionAccess(AuthenticatedUser currentUser,
            Integer affectedConnectionID, String permissionType) {
        if(checkSystemAdministratorAccess(currentUser))
        example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andConnection_idEqualTo(affectedConnectionID).andPermissionEqualTo(permissionType);
     * @param currentUser
     *     The user to check.
     *
     * @param affectedConnectionGroupID
     *     The connection group that would be affected by the operation if
     *     permission is granted.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     true if the specified permission is granted, false otherwise.
    public boolean checkConnectionGroupAccess(AuthenticatedUser currentUser,
            Integer affectedConnectionGroupID, String permissionType) {
        if(checkSystemAdministratorAccess(currentUser))
        example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andConnection_group_idEqualTo(affectedConnectionGroupID).andPermissionEqualTo(permissionType);
     * @param currentUser
     *     The user to check.
     *
     * @param systemPermissionType
     *     The type of permission to check for.
     *
     * @return
     *     true if the specified permission is granted, false otherwise.
    private boolean checkSystemAccess(AuthenticatedUser currentUser, String systemPermissionType) {
        if(checkSystemAdministratorAccess(currentUser))
        example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andPermissionEqualTo(systemPermissionType);
     * @param currentUser
     *     The user to check.
     *
     * @return
     *     true if the system administrator access exists, false otherwise.
    private boolean checkSystemAdministratorAccess(AuthenticatedUser currentUser) {
        example.createCriteria().andUser_idEqualTo(currentUser.getUserID())
                .andPermissionEqualTo(MySQLConstants.SYSTEM_ADMINISTER);
     * @param connectionGroupID
     *     The ID of the affected ConnectionGroup.
     *
     * @param currentUser
     *     The user to check.
     * 
     * @param type
     *     The desired usage.
     *
     * @throws GuacamoleSecurityException
     *     If the connection group cannot be used for organization.
            AuthenticatedUser currentUser, String type) throws GuacamoleSecurityException {
        if(!checkConnectionGroupUsageAccess(connectionGroupID, currentUser, type))
     *
     * @param connectionGroupID
     *     The ID of the affected connection group.
     *
     * @param currentUser
     *     The user to check.
     *
     * @param usage
     *     The desired usage.
     *
     * @return
     *     true if the user can use the connection group for the given usage.
            Integer connectionGroupID, AuthenticatedUser currentUser, String usage) {
        if(checkSystemAdministratorAccess(currentUser))
        if(checkConnectionGroupAccess(currentUser, connectionGroupID,
                retrieveConnectionGroup(connectionGroupID, currentUser);
     * @param currentUser
     *     The user to check.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     A list of all user IDs this user has the specified access to.
    public List<Integer> retrieveUserIDs(AuthenticatedUser currentUser, String permissionType) {
        if(checkSystemAdministratorAccess(currentUser))
        example.createCriteria().andUser_idEqualTo(currentUser.getUserID()).andPermissionEqualTo(permissionType);
        List<Integer> currentUsers = new ArrayList<Integer>(userPermissions.size());
            currentUsers.add(permission.getAffected_user_id());
        return currentUsers;
     * @param currentUser
     *     The user to check.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     A list of all connection IDs this user has the specified access to.
    public List<Integer> retrieveConnectionIDs(AuthenticatedUser currentUser,
        return retrieveConnectionIDs(currentUser, null, permissionType, false);
     * @param currentUser
     *     The user to check.
     *
     * @param parentID
     *     The parent connection group.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     A list of all connection IDs this user has the specified access to.
    public List<Integer> retrieveConnectionIDs(AuthenticatedUser currentUser, Integer parentID,
        return retrieveConnectionIDs(currentUser, parentID, permissionType, true);
     * @param currentUser
     *     The user to check.
     *
     * @param parentID
     *     The parent connection group.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @param checkParentID
     *     Whether the parentID should be checked or not.
     * 
     * @return
     *     A list of all connection IDs this user has the specified access to.
    private List<Integer> retrieveConnectionIDs(AuthenticatedUser currentUser, Integer parentID,
        if(checkSystemAdministratorAccess(currentUser)) {
        Criteria criteria = example.createCriteria().andUser_idEqualTo(currentUser.getUserID())
     * @param currentUser
     *     The user to check.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     A list of all connection group IDs this user has the specified
     *     access to.
    public List<Integer> retrieveConnectionGroupIDs(AuthenticatedUser currentUser,
        return retrieveConnectionGroupIDs(currentUser, null, permissionType, false);
     * @param currentUser
     *     The user to check.
     *
     * @param parentID
     *     The parent connection group.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @return
     *     A list of all connection group IDs this user has the specified
     *     access to.
    public List<Integer> retrieveConnectionGroupIDs(AuthenticatedUser currentUser, Integer parentID,
        return retrieveConnectionGroupIDs(currentUser, parentID, permissionType, true);
     * @param currentUser
     *     The user to check.
     * 
     * @param parentID
     *     The parent connection group.
     *
     * @param permissionType
     *     The type of permission to check for.
     *
     * @param checkParentID
     *     Whether the parentID should be checked or not.
     *
     * @return
     *     A list of all connection group IDs this user has the specified
     *     access to.
    private List<Integer> retrieveConnectionGroupIDs(AuthenticatedUser currentUser, Integer parentID,
        if(checkSystemAdministratorAccess(currentUser)) {
                example.createCriteria().andUser_idEqualTo(currentUser.getUserID())
     * @param currentUser
     *     The user whose permissions should be checked.
     *
     * @param permissionType
     *     The permission to check.
     *
     * @return
     *     A set of all usernames for which the given user has the given
     *     permission.
    public Set<String> retrieveUsernames(AuthenticatedUser currentUser, String permissionType) {
        if(checkSystemAdministratorAccess(currentUser))
        List<Integer> currentUsers =
                retrieveUserIDs(currentUser, MySQLConstants.USER_READ);
        return userService.translateUsernames(currentUsers).keySet();
     * @param currentUser
     *     The user whose permissions should be checked.
     *
     * @param permissionType
     *     The permission to check.
     *
     * @param parentID
     *     The parent connection group.
     *
     * @return
     *     A set of all connection identifiers for which the given user has the
     *     given permission.
    public Set<String> retrieveConnectionIdentifiers(AuthenticatedUser currentUser, Integer parentID,
        if(checkSystemAdministratorAccess(currentUser))
                retrieveConnectionIDs(currentUser, parentID, permissionType);
     * @param currentUser
     *     The user whose permissions should be checked.
     *
     * @param permissionType
     *     The permission to check.
     *
     * @param parentID
     *     The parent connection group.
     *
     * @return
     *     A set of all connection group identifiers for which the given user
     *     has the given permission.
    public Set<String> retrieveConnectionGroupIdentifiers(AuthenticatedUser currentUser, Integer parentID,
        if(checkSystemAdministratorAccess(currentUser))
                retrieveConnectionGroupIDs(currentUser, parentID, permissionType);
/*
 * Copyright (C) 2015 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * Simple tunnel example with hard-coded configuration parameters.
 * @author Michael Jumper
/*
 * Copyright (C) 2015 Glyptodon LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * Simple tunnel example with hard-coded configuration parameters.
 * @author Michael Jumper
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
        
        // An admin user has access to any connection or connection group
        boolean isAdmin = self.hasPermission(new SystemPermission(SystemPermission.Type.ADMINISTER));
                if (isAdmin || permission == null || self.hasPermission(new ConnectionPermission(permission, childIdentifier)))
import java.util.List;
     * Determines whether the given user has at least one of the given
     * permissions for the connection having the given identifier.
     * 
     * @param user
     *     The user to check permissions for.
     * 
     * @param identifier 
     *     The identifier of the connection to check permissions for.
     * 
     * @param permissions
     *     The permissions to check. The given user must have one or more of
     *     these permissions for this function to return true.
     * 
     * @return
     *     true if the user has at least one of the given permissions.
     */
    private boolean hasConnectionPermission(User user, String identifier,
            List<ObjectPermission.Type> permissions) throws GuacamoleException {
        
        // Determine whether user has at least one of the given permissions
        for (ObjectPermission.Type permission : permissions) {
            
            ConnectionPermission connectionPermission = new ConnectionPermission(permission, identifier);
            if (user.hasPermission(connectionPermission))
                return true;
            
        }
        
        // None of the given permissions were present
        return false;
        
    }
    
    /**
     * @param permissions
     *     The set of permissions to filter with. A user must have one or more
     *     of these permissions for a connection to appear in the result. 
     *     If null, no filtering will be performed.
            String identifier, boolean includeDescendants, List<ObjectPermission.Type> permissions)
                if (isAdmin || permissions == null || hasConnectionPermission(self, childIdentifier, permissions))
                APIConnectionGroup childConnectionGroup = retrieveConnectionGroup(userContext, childIdentifier, true, permissions);
     * @param permissions
     *     which the current user has any of the given permissions. Otherwise, 
     *     all visible connections are returned. Connection groups are 
     *     unaffected by this parameter.
            @QueryParam("permission") List<ObjectPermission.Type> permissions)
        APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, true, permissions);
import java.util.List;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
     * Determines whether the given user has at least one of the given
     * permissions for the connection having the given identifier.
     * 
     * @param user
     *     The user to check permissions for.
     * 
     * @param identifier 
     *     The identifier of the connection to check permissions for.
     * 
     * @param permissions
     *     The permissions to check. The given user must have one or more of
     *     these permissions for this function to return true.
     * 
     * @return
     *     true if the user has at least one of the given permissions.
     */
    private boolean hasConnectionPermission(User user, String identifier,
            List<ObjectPermission.Type> permissions) throws GuacamoleException {
        
        // Determine whether user has at least one of the given permissions
        for (ObjectPermission.Type permission : permissions) {
            
            ConnectionPermission connectionPermission = new ConnectionPermission(permission, identifier);
            if (user.hasPermission(connectionPermission))
                return true;
            
        }
        
        // None of the given permissions were present
        return false;
        
    }
    
    /**
     * @param permissions
     *     The set of permissions to filter with. A user must have one or more
     *     of these permissions for a connection to appear in the result. 
     *     If null, no filtering will be performed.
            String identifier, boolean includeDescendants, List<ObjectPermission.Type> permissions)
        
        // An admin user has access to any connection or connection group
        boolean isAdmin = self.hasPermission(new SystemPermission(SystemPermission.Type.ADMINISTER));
                if (isAdmin || permissions == null || hasConnectionPermission(self, childIdentifier, permissions))
                APIConnectionGroup childConnectionGroup = retrieveConnectionGroup(userContext, childIdentifier, true, permissions);
     * @param permissions
     *     which the current user has any of the given permissions. Otherwise, 
     *     all visible connections are returned. Connection groups are 
     *     unaffected by this parameter.
            @QueryParam("permission") List<ObjectPermission.Type> permissions)
        APIConnectionGroup connectionGroup = retrieveConnectionGroup(userContext, connectionGroupID, true, permissions);
    
    /**
     * Determines whether the given user has at least one of the given
     * permissions for the user having the given username.
     * 
     * @param user
     *     The user to check permissions for.
     * 
     * @param username 
     *     The username of the user to check permissions for.
     * 
     * @param permissions
     *     The permissions to check. The given user must have one or more of
     *     these permissions for this function to return true.
     * 
     * @return
     *     true if the user has at least one of the given permissions.
     */
    private boolean hasUserPermission(User user, String username,
            List<ObjectPermission.Type> permissions) throws GuacamoleException {
        
        // Determine whether user has at least one of the given permissions
        for (ObjectPermission.Type permission : permissions) {
            
            UserPermission userPermission = new UserPermission(permission, username);
            if (user.hasPermission(userPermission))
                return true;
            
        }
        
        // None of the given permissions were present
        return false;
        
    }
     * @param permissions
     *     The set of permissions to filter with. A user must have one or more
     *     of these permissions for a user to appear in the result. 
     *     If null, no filtering will be performed.
            @QueryParam("permission") List<ObjectPermission.Type> permissions)
        
        // An admin user has access to any user
        boolean isAdmin = self.hasPermission(new SystemPermission(SystemPermission.Type.ADMINISTER));
            if (isAdmin || permissions == null || hasUserPermission(self, username, permissions))
    
    /**
     * Determines whether the given user has at least one of the given
     * permissions for the user having the given username.
     * 
     * @param user
     *     The user to check permissions for.
     * 
     * @param username 
     *     The username of the user to check permissions for.
     * 
     * @param permissions
     *     The permissions to check. The given user must have one or more of
     *     these permissions for this function to return true.
     * 
     * @return
     *     true if the user has at least one of the given permissions.
     */
    private boolean hasUserPermission(User user, String username,
            List<ObjectPermission.Type> permissions) throws GuacamoleException {
        
        // Determine whether user has at least one of the given permissions
        for (ObjectPermission.Type permission : permissions) {
            
            UserPermission userPermission = new UserPermission(permission, username);
            if (user.hasPermission(userPermission))
                return true;
            
        }
        
        // None of the given permissions were present
        return false;
        
    }
     * @param permissions
     *     The set of permissions to filter with. A user must have one or more
     *     of these permissions for a user to appear in the result. 
     *     If null, no filtering will be performed.
            @QueryParam("permission") List<ObjectPermission.Type> permissions)
        
        // An admin user has access to any user
        boolean isAdmin = self.hasPermission(new SystemPermission(SystemPermission.Type.ADMINISTER));
            if (isAdmin || permissions == null || hasUserPermission(self, username, permissions))
import java.util.Collections;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;

    /**
     * Determines whether the given user has at least one of the given
     * permissions for the connection group having the given identifier.
     *
     * @param user
     *     The user to check permissions for.
     *
     * @param identifier
     *     The identifier of the connection group to check permissions for.
     *
     * @param permissions
     *     The permissions to check. The given user must have one or more of
     *     these permissions for this function to return true.
     *
     * @return
     *     true if the user has at least one of the given permissions.
     */
    private boolean hasConnectionGroupPermission(User user, String identifier,
            List<ObjectPermission.Type> permissions) throws GuacamoleException {

        // Determine whether user has at least one of the given permissions
        for (ObjectPermission.Type permission : permissions) {

            ConnectionGroupPermission connectionGroupPermission = new ConnectionGroupPermission(permission, identifier);
            if (user.hasPermission(connectionGroupPermission))
                return true;

        }

        // None of the given permissions were present
        return false;

    }

        // Recursively query all descendants if necessary, only querying the
        // descendants of balancing groups if we have admin permission on that
        // group
        if (includeDescendants
            && (connectionGroup.getType() != ConnectionGroup.Type.BALANCING
                || isAdmin
                || hasConnectionGroupPermission(self, identifier,
                        Collections.singletonList(ObjectPermission.Type.ADMINISTER)))) {
import java.util.Collections;
import org.glyptodon.guacamole.net.auth.permission.ConnectionGroupPermission;

    /**
     * Determines whether the given user has at least one of the given
     * permissions for the connection group having the given identifier.
     *
     * @param user
     *     The user to check permissions for.
     *
     * @param identifier
     *     The identifier of the connection group to check permissions for.
     *
     * @param permissions
     *     The permissions to check. The given user must have one or more of
     *     these permissions for this function to return true.
     *
     * @return
     *     true if the user has at least one of the given permissions.
     */
    private boolean hasConnectionGroupPermission(User user, String identifier,
            List<ObjectPermission.Type> permissions) throws GuacamoleException {

        // Determine whether user has at least one of the given permissions
        for (ObjectPermission.Type permission : permissions) {

            ConnectionGroupPermission connectionGroupPermission = new ConnectionGroupPermission(permission, identifier);
            if (user.hasPermission(connectionGroupPermission))
                return true;

        }

        // None of the given permissions were present
        return false;

    }

        // Recursively query all descendants if necessary, only querying the
        // descendants of balancing groups if we have admin permission on that
        // group
        if (includeDescendants
            && (connectionGroup.getType() != ConnectionGroup.Type.BALANCING
                || isAdmin
                || hasConnectionGroupPermission(self, identifier,
                        Collections.singletonList(ObjectPermission.Type.ADMINISTER)))) {
     * Returns the unique identifier assigned to this Connection. All
     * connections must have a deterministic, unique identifier which may not
     * be null.
     *
     * @return
     *     The unique identifier assigned to this Connection, which may not be
     *     null.
     * Returns the unique identifier assigned to this ConnectionGroup. All
     * connection groups must have a deterministic, unique identifier which may
     * not be null.
     *
     * @return
     *     The unique identifier assigned to this ConnectionGroup, which may
     *     not be null.
     * All users must have a deterministic, unique username which may not be
     * null.
     * @return
     *     The unique username of this user, which may not be null.
        // Get username, if any
        String username = credentials.getUsername();

        if (username != null)
            return new SimpleUserContext(username, configs);

        // If there is no associated username, let SimpleUserContext generate one
        else
            return new SimpleUserContext(configs);
     *     If specified and non-empty, limit the returned list to only those
     *     connections for which the current user has any of the given
     *     permissions. Otherwise, all visible connections are returned.
     *     Connection groups are unaffected by this parameter.
        // Do not filter on permissions if no permissions are specified
        if (permissions != null && permissions.isEmpty())
            permissions = null;
        
        // Do not filter on permissions if no permissions are specified
        if (permissions != null && permissions.isEmpty())
            permissions = null;

        if (username != null && !username.isEmpty())
     * Returns the unique identifier assigned to this Connection. All
     * connections must have a deterministic, unique identifier which may not
     * be null.
     *
     * @return
     *     The unique identifier assigned to this Connection, which may not be
     *     null.
     * Returns the unique identifier assigned to this ConnectionGroup. All
     * connection groups must have a deterministic, unique identifier which may
     * not be null.
     *
     * @return
     *     The unique identifier assigned to this ConnectionGroup, which may
     *     not be null.
     * All users must have a deterministic, unique username which may not be
     * null.
     * @return
     *     The unique username of this user, which may not be null.
        // Get username, if any
        String username = credentials.getUsername();

        if (username != null && !username.isEmpty())
            return new SimpleUserContext(username, configs);

        // If there is no associated username, let SimpleUserContext generate one
        else
            return new SimpleUserContext(configs);
     *     If specified and non-empty, limit the returned list to only those
     *     connections for which the current user has any of the given
     *     permissions. Otherwise, all visible connections are returned.
     *     Connection groups are unaffected by this parameter.
        // Do not filter on permissions if no permissions are specified
        if (permissions != null && permissions.isEmpty())
            permissions = null;
        
        // Do not filter on permissions if no permissions are specified
        if (permissions != null && permissions.isEmpty())
            permissions = null;

import java.util.List;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
     * The count of currently active users for this connection.
     */
    private int activeUsers;
    
    /**
        
        // Set the number of currently active users
        this.activeUsers = 0;
        
        for (ConnectionRecord history : connection.getHistory()) {
            if (history.isActive())
                this.activeUsers;
        }

    /**
     * Returns the number of currently active users for this connection.
     * @return The number of currently active users for this connection.
     */
    public int getActiveUsers() {
        return activeUsers;
    }

    /**
     * Set the number of currently active users for this connection.
     * @param activeUsers The number of currently active users for this connection.
     */
    public void setActiveUsers(int activeUsers) {
        this.activeUsers = activeUsers;
    }
import java.util.List;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
     * The count of currently active users for this connection.
     */
    private int activeUsers;
    
    /**
        
        // Set the number of currently active users
        this.activeUsers = 0;
        
        for (ConnectionRecord history : connection.getHistory()) {
            if (history.isActive())
                this.activeUsers;
        }

    /**
     * Returns the number of currently active users for this connection.
     * @return The number of currently active users for this connection.
     */
    public int getActiveUsers() {
        return activeUsers;
    }

    /**
     * Set the number of currently active users for this connection.
     * @param activeUsers The number of currently active users for this connection.
     */
    public void setActiveUsers(int activeUsers) {
        this.activeUsers = activeUsers;
    }
import java.util.Collections;
    public List<ConnectionRecord> getConnectionHistory(@QueryParam("token") String authToken, 
        return Collections.<ConnectionRecord>unmodifiableList(connection.getHistory());
import java.util.Collections;
    public List<ConnectionRecord> getConnectionHistory(@QueryParam("token") String authToken, 
        return Collections.<ConnectionRecord>unmodifiableList(connection.getHistory());
     * Reads and returns client information provided by the {@code request} parameter.
     *
     * @param request The request describing tunnel to create.
     * @return GuacamoleClientInformation Object containing information about the client sending the tunnel request.
    protected GuacamoleClientInformation getClientInformation(TunnelRequest request) {
        return info;
    }

    /**
     * Creates a new socket using client information specified in the {@code info} parameter,
     * connection information from {@code request} and credentials from the {@code session} parameter.
     *
     * @param request The request describing tunnel to create.
     * @param session Current guacamole session.
     * @param info Guacamole client information.
     * @return Socket connected using the provided settings.
     * @throws GuacamoleException If an error occurs while creating the socket.
     */
    protected GuacamoleSocket createConnectedSocket(TunnelRequest request, GuacamoleSession session,
                                                    GuacamoleClientInformation info) throws GuacamoleException {
        // Get ID of connection
        String id = request.getParameter("id");
        TunnelRequest.IdentifierType id_type = TunnelRequest.IdentifierType.getType(id);

        // Do not continue if unable to determine type
        if (id_type == null)
            throw new GuacamoleClientException("Illegal identifier - unknown type.");

        // Remove prefix
        id = id.substring(id_type.PREFIX.length());

                        context.getRootConnectionGroup().getConnectionDirectory();
                        context.getRootConnectionGroup().getConnectionGroupDirectory();
        return socket;
    }

    /**
     * Creates and returns a tunnel using the specified guacd socket.
     * The tunnel is associated with a session identified
     * by the {@code authToken} parameter.
     *
     * @param socket The connected socket.
     * @param authToken Current authorization token.
     * @return The created tunnel.
     */
    protected GuacamoleTunnel createAssociatedTunnel(GuacamoleSocket socket, final String authToken) {
        return new GuacamoleTunnel(socket) {


    }

    
    /**
     * Creates a new tunnel using the parameters and credentials present in
     * the given request.
     * 
     * @param request The request describing the tunnel to create.
     * @return The created tunnel, or null if the tunnel could not be created.
     * @throws GuacamoleException If an error occurs while creating the tunnel.
     */
    public GuacamoleTunnel createTunnel(TunnelRequest request)
            throws GuacamoleException {

        // Get auth token and session
        final String authToken = request.getParameter("authToken");
        final GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);

        // Get client information
        final GuacamoleClientInformation info = getClientInformation(request);

        // Create connected socket from identifier
        final GuacamoleSocket socket = createConnectedSocket(request, session, info);

        // Associate socket with tunnel
        GuacamoleTunnel tunnel = createAssociatedTunnel(socket, authToken);
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
                MySQLConstants.CONNECTION_GROUP_UPDATE);
        // Verify permission to update the connection group
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
                MySQLConstants.CONNECTION_GROUP_UPDATE);
        // Verify permission to update the connection group
        permissionCheckService.verifyConnectionGroupAccess(currentUser,
import java.util.Collection;
     * Returns the objects having the given identifiers. Note that changes to
     * any object returned will not necessarily affect the object stored within
     * the Directory. To update an object stored within a
     * Directory such that future calls to get() will return the updated
     * object, you must call update() on the object after modification.
     *
     * @param identifiers
     *     The identifiers to use when locating the objects to return.
     *
     * @return
     *     The objects having the given identifiers. If any identifiers do not
     *     correspond to accessible objects, those identifiers will be ignored.
     *     If no objects correspond to any of the given identifiers, the
     *     returned collection will be empty.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the objects, or if permission
     *     to retrieve the requested objects is denied.
     */
    Collection<ObjectType> getAll(Collection<IdentifierType> identifiers)
            throws GuacamoleException;

    /**
public class SimpleConnectionDirectory extends SimpleDirectory<String, Connection> {
    private final Map<String, Connection> connections =
                    new SimpleConnection(entry.getKey(), entry.getKey(),
        // Use the connection map to back the underlying AbstractDirectory
        super.setObjects(connections);

     *

    extends SimpleDirectory<String, ConnectionGroup> {
    private final Map<String, ConnectionGroup> connectionGroups =
     *
        // Use the connection group map to back the underlying AbstractDirectory
        super.setObjects(connectionGroups);
     *

     *
public class SimpleUserDirectory extends SimpleDirectory<String, User> {
        super(Collections.singletonMap(user.getUsername(), user));
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
    SystemPermissionSet getSystemPermissions() throws GuacamoleException;
     * Lists all permissions given to this user.
     * @return A Set of all permissions granted to this user.
     * @throws GuacamoleException  If an error occurs while retrieving
     *                             permissions, or if reading all permissions
     *                             is not allowed.
    ObjectPermissionSet<String, Connection> getConnectionPermissions() throws GuacamoleException;
     * Lists all permissions given to this user.
     * @return A Set of all permissions granted to this user.
     * @throws GuacamoleException  If an error occurs while retrieving
     *                             permissions, or if reading all permissions
     *                             is not allowed.
    ObjectPermissionSet<String, ConnectionGroup> getConnectionGroupPermissions() throws GuacamoleException;
     * Lists all permissions given to this user.
     * @return A Set of all permissions granted to this user.
     * @throws GuacamoleException  If an error occurs while retrieving
     *                             permissions, or if reading all permissions
     *                             is not allowed.
    ObjectPermissionSet<String, User> getUserPermissions() throws GuacamoleException;
 * @param <IdentifierType>
 *     The type of identifier used by the object this permission affects.
public class ObjectPermission<IdentifierType> implements Permission<ObjectPermission.Type> {
     * The identifier of the GuacamoleConfiguration associated with the
     * operation affected by this permission.
     */
    private final IdentifierType identifier;

    /**
     * The type of operation affected by this permission.
     */
    private final Type type;

    /**
     * Creates a new ObjectPermission having the given type and identifier.
     * The identifier must be the unique identifier assigned to the object
     * associated with this permission by the AuthenticationProvider in use.
     *
     * @param type
     *     The type of operation affected by this permission.
     *
     * @param identifier
     *     The identifier of the object associated with the operation affected
     *     by this permission.
     */
    public ObjectPermission(Type type, IdentifierType identifier) {

        this.identifier = identifier;
        this.type = type;

    }

   /**
    public IdentifierType getObjectIdentifier() {
        return identifier;
    }

    @Override
    public Type getType() {
        return type;
    }

    @Override
    public int hashCode() {
        int hash = 5;
        if (identifier != null) hash = 47 * hash  identifier.hashCode();
        if (type != null)       hash = 47 * hash  type.hashCode();
        return hash;
    }

    @Override
    public boolean equals(Object obj) {

        // Not equal if null or wrong type
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;

        final ObjectPermission other = (ObjectPermission) obj;

        // Not equal if different type
        if (this.type != other.type)
            return false;

        // If null identifier, equality depends on whether other identifier
        // is null
        if (identifier == null)
            return other.identifier == null;

        // Otherwise, equality depends entirely on identifier
        return identifier.equals(other.identifier);

    }
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
     * All connection permissions granted to this user.
    private final Set<ObjectPermission<String>> connectionPermissions =
            new HashSet<ObjectPermission<String>>();
    
    /**
     * All connection group permissions granted to this user.
     */
    private final Set<ObjectPermission<String>> connectionGroupPermissions =
            new HashSet<ObjectPermission<String>>();
            ObjectPermission permission = new ObjectPermission(
            connectionPermissions.add(permission);
            ObjectPermission permission = new ObjectPermission(
            connectionGroupPermissions.add(permission);
    public SystemPermissionSet getSystemPermissions()
            throws GuacamoleException {
        return new SimpleSystemPermissionSet();
    public ObjectPermissionSet<String, Connection> getConnectionPermissions()
            throws GuacamoleException {
        return new SimpleObjectPermissionSet<String, Connection>(connectionPermissions);
    public ObjectPermissionSet<String, ConnectionGroup> getConnectionGroupPermissions()
            throws GuacamoleException {
        return new SimpleObjectPermissionSet<String, ConnectionGroup>(connectionGroupPermissions);
    public ObjectPermissionSet<String, User> getUserPermissions()
            throws GuacamoleException {
        return new SimpleObjectPermissionSet<String, User>();
     * Returns all system-level permissions given to this user.
     * @return
     *     A SystemPermissionSet of all system-level permissions granted to
     *     this user.
     * @throws GuacamoleException 
     *     If an error occurs while retrieving permissions, or if reading all
     *     permissions is not allowed.
     * Returns all connection permissions given to this user.
     * @return
     *     An ObjectPermissionSet of all connection permissions granted to this
     *     user.
     * @throws GuacamoleException 
     *     If an error occurs while retrieving permissions, or if reading all
     *     permissions is not allowed.
    ObjectPermissionSet<String> getConnectionPermissions()
            throws GuacamoleException;
     * Returns all connection group permissions given to this user.
     * @return
     *     An ObjectPermissionSet of all connection group permissions granted
     *     to this user.
     * @throws GuacamoleException
     *     If an error occurs while retrieving permissions, or if reading all
     *     permissions is not allowed.
    ObjectPermissionSet<String> getConnectionGroupPermissions()
            throws GuacamoleException;
     * Returns all user permissions given to this user.
     * @return
     *     An ObjectPermissionSet of all user permissions granted to this user.
     * @throws GuacamoleException
     *     If an error occurs while retrieving permissions, or if reading all
     *     permissions is not allowed.
    ObjectPermissionSet<String> getUserPermissions() throws GuacamoleException;
public interface ObjectPermissionSet<IdentifierType> {
public class SimpleObjectPermissionSet<IdentifierType>
    implements ObjectPermissionSet<IdentifierType> {
    public ObjectPermissionSet<String> getConnectionPermissions()
        return new SimpleObjectPermissionSet<String>(connectionPermissions);
    public ObjectPermissionSet<String> getConnectionGroupPermissions()
        return new SimpleObjectPermissionSet<String>(connectionGroupPermissions);
    public ObjectPermissionSet<String> getUserPermissions()
        return new SimpleObjectPermissionSet<String>();
import java.util.Set;
    /**
     * Returns a Set which contains all permissions granted within this
     * permission set.
     *
     * @return
     *     A Set containing all permissions granted within this permission set.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving permissions, or if permissions
     *     cannot be retrieved due to lack of permissions to do so.
     */
    Set<ObjectPermission<IdentifierType>> getPermissions()
            throws GuacamoleException;

    /**
     * Adds the specified permissions, if not already granted. If a specified
     * permission is already granted, no operation is performed regarding that
     * permission.
     *
     * @param permissions
     *     The permissions to add.
     *
     * @throws GuacamoleException
     *     If an error occurs while adding the permissions, or if permission to
     *     add permissions is denied.
     */
    void addPermissions(Set<ObjectPermission<IdentifierType>> permissions)
            throws GuacamoleException;

    /**
     * Removes each of the specified permissions, if granted. If a specified
     * permission is not granted, no operation is performed regarding that
     * permission.
     *
     * @param permissions
     *     The permissions to remove.
     *
     * @throws GuacamoleException
     *     If an error occurs while removing the permissions, or if permission
     *     to remove permissions is denied.
     */
    void removePermissions(Set<ObjectPermission<IdentifierType>> permissions)
            throws GuacamoleException;

import java.util.Set;
    /**
     * Returns a Set which contains all system-level permissions granted within
     * this permission set.
     *
     * @return
     *     A Set containing all system-level permissions granted within this
     *     permission set.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving permissions, or if permissions
     *     cannot be retrieved due to lack of permissions to do so.
     */
    Set<SystemPermission> getPermissions() throws GuacamoleException;

    /**
     * Adds the specified permissions, if not already granted. If a specified
     * permission is already granted, no operation is performed regarding that
     * permission.
     *
     * @param permissions
     *     The permissions to add.
     *
     * @throws GuacamoleException
     *     If an error occurs while adding the permissions, or if permission to
     *     add permissions is denied.
     */
    void addPermissions(Set<SystemPermission> permissions)
            throws GuacamoleException;

    /**
     * Removes each of the specified permissions, if granted. If a specified
     * permission is not granted, no operation is performed regarding that
     * permission.
     *
     * @param permissions
     *     The permissions to remove.
     *
     * @throws GuacamoleException
     *     If an error occurs while removing the permissions, or if permission
     *     to remove permissions is denied.
     */
    void removePermissions(Set<SystemPermission> permissions)
            throws GuacamoleException;


    @Override
    public Set<ObjectPermission<IdentifierType>> getPermissions() {
    @Override
    public void addPermissions(Set<ObjectPermission<IdentifierType>> permissions)
            throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied.");
    }

    @Override
    public void removePermissions(Set<ObjectPermission<IdentifierType>> permissions)
            throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied.");
    }

    @Override
    public Set<SystemPermission> getPermissions() {
    @Override
    public void addPermissions(Set<SystemPermission> permissions)
            throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied.");
    }

    @Override
    public void removePermissions(Set<SystemPermission> permissions)
            throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied.");
    }

public interface ObjectPermissionSet<IdentifierType>
    extends PermissionSet<ObjectPermission<IdentifierType>> {
    @Override
    @Override
    @Override
public interface SystemPermissionSet extends PermissionSet<SystemPermission> {
    @Override
    @Override
    @Override
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
        // Retrieve permission sets
        SystemPermissionSet systemPermissions = self.getSystemPermissions();
        ObjectPermissionSet<String> connectionPermissions = self.getConnectionPermissions();

        if (!systemPermissions.hasPermission(SystemPermission.Type.ADMINISTER)
         && !connectionPermissions.hasPermission(ObjectPermission.Type.UPDATE, connectionID))
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;

        // Retrieve connection permissions
        ObjectPermissionSet<String> connectionPermissions = user.getConnectionPermissions();
            if (connectionPermissions.hasPermission(permission, identifier))
        // Retrieve connection group permissions
        ObjectPermissionSet<String> connectionGroupPermissions = user.getConnectionGroupPermissions();
        
            if (connectionGroupPermissions.hasPermission(permission, identifier))
        SystemPermissionSet systemPermissions = self.getSystemPermissions();
        boolean isAdmin = systemPermissions.hasPermission(SystemPermission.Type.ADMINISTER);
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
    private Map<String, Set<ObjectPermission.Type>> connectionPermissions =
            new HashMap<String, Set<ObjectPermission.Type>>();
    private Map<String, Set<ObjectPermission.Type>> connectionGroupPermissions =
            new HashMap<String, Set<ObjectPermission.Type>>();
    private Map<String, Set<ObjectPermission.Type>> userPermissions =
            new HashMap<String, Set<ObjectPermission.Type>>();
    private Set<SystemPermission.Type> systemPermissions =
            EnumSet.noneOf(SystemPermission.Type.class);
     * Adds the system permissions from the given SystemPermissionSet to the
     * Set of system permissions provided.
     *     The Set to add system permissions to.
     *
     * @param permSet
     *     The SystemPermissionSet containing the system permissions to add.
     *     If an error occurs while retrieving system permissions from the
     *     SystemPermissionSet.
    private void addSystemPermissions(Set<SystemPermission.Type> permissions,
            SystemPermissionSet permSet) throws GuacamoleException {
        // Add all provided system permissions 
        for (SystemPermission permission : permSet.getPermissions())
            permissions.add(permission.getType());
    
     * Adds the object permissions from the given ObjectPermissionSet to the
     * Map of object permissions provided.
     *     The Map to add object permissions to.
     *
     * @param permSet
     *     The ObjectPermissionSet containing the object permissions to add.
     *     If an error occurs while retrieving object permissions from the
     *     ObjectPermissionSet.
    private void addObjectPermissions(Map<String, Set<ObjectPermission.Type>> permissions,
            ObjectPermissionSet<String> permSet) throws GuacamoleException {
        // Add all provided object permissions 
        for (ObjectPermission<String> permission : permSet.getPermissions()) {
            // Get associated set of permissions
            String identifier = permission.getObjectIdentifier();
            Set<ObjectPermission.Type> objectPermissions = permissions.get(identifier);

            // Create new set if none yet exists
            if (objectPermissions == null)
                permissions.put(identifier, EnumSet.of(permission.getType()));

            // Otherwise add to existing set
            else
                objectPermissions.add(permission.getType());

        }

    }
    
    /**
     * Creates a new permission set containing all permissions currently
     * granted to the given user.
     *
     * @param user
     *     The user whose permissions should be stored within this permission
     *     set.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the user's permissions.
     */
    public APIPermissionSet(User user) throws GuacamoleException {

        // Add all permissions from the provided user
        addSystemPermissions(systemPermissions,          user.getSystemPermissions());
        addObjectPermissions(connectionPermissions,      user.getConnectionPermissions());
        addObjectPermissions(connectionGroupPermissions, user.getConnectionGroupPermissions());
        addObjectPermissions(userPermissions,            user.getUserPermissions());
        
    public Map<String, Set<ObjectPermission.Type>> getConnectionPermissions() {
    public Map<String, Set<ObjectPermission.Type>> getConnectionGroupPermissions() {
    public Map<String, Set<ObjectPermission.Type>> getUserPermissions() {
    public Set<SystemPermission.Type> getSystemPermissions() {
    public void setConnectionPermissions(Map<String, Set<ObjectPermission.Type>> connectionPermissions) {
    public void setConnectionGroupPermissions(Map<String, Set<ObjectPermission.Type>> connectionGroupPermissions) {
    public void setUserPermissions(Map<String, Set<ObjectPermission.Type>> userPermissions) {
    public void setSystemPermissions(Set<SystemPermission.Type> systemPermissions) {
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
 * A wrapper to make an APIUser look like a User. Useful where an
 * org.glyptodon.guacamole.net.auth.User is required. As a simple wrapper for
 * APIUser, access to permissions is not provided. Any attempt to access or
 * manipulate permissions on an APIUserWrapper will result in an exception.
    public SystemPermissionSet getSystemPermissions()
            throws GuacamoleException {
        throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
    public ObjectPermissionSet<String> getConnectionPermissions()
            throws GuacamoleException {
        throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
    public ObjectPermissionSet<String> getConnectionGroupPermissions()
            throws GuacamoleException {
        throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
    public ObjectPermissionSet<String> getUserPermissions()
            throws GuacamoleException {
        throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
import java.util.Collections;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.PermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
        // Retrieve user permissions
        ObjectPermissionSet<String> userPermissions = user.getUserPermissions();
        
            if (userPermissions.hasPermission(permission, username))
        SystemPermissionSet systemPermissions = self.getSystemPermissions();
        boolean isAdmin = systemPermissions.hasPermission(SystemPermission.Type.ADMINISTER);
        return new APIPermissionSet(user);

    }

    /**
     * Updates the given permission set by adding or removing the given
     * permission based on the given patch operation.
     *
     * @param <PermissionType>
     *     The type of permission stored within the permission set.
     *
     * @param operation
     *     The patch operation to perform.
     *
     * @param permissionSet
     *     The permission set being modified.
     *
     * @param permission
     *     The permission being added or removed from the set.
     *
     * @throws GuacamoleException
     *     If an error occurs while modifying the permission set.
     */
    private <PermissionType extends Permission> void updatePermissionSet(
            APIPatch.Operation operation,
            PermissionSet<PermissionType> permissionSet,
            PermissionType permission) throws GuacamoleException {

        // Add or remove permission based on operation
        switch (operation) {

            // Add permission
            case add:
                permissionSet.addPermissions(Collections.singleton(permission));
                break;

            // Remove permission
            case remove:
                permissionSet.removePermissions(Collections.singleton(permission));
                break;

            // Unsupported patch operation
            default:
                throw new HTTPException(Status.BAD_REQUEST,
                        "Unsupported patch operation: \""  operation  "\"");

        }
                // Create and update corresponding permission
                ObjectPermission<String> permission = new ObjectPermission<String>(type, identifier);
                updatePermissionSet(patch.getOp(), user.getConnectionPermissions(), permission);
                // Create and update corresponding permission
                ObjectPermission<String> permission = new ObjectPermission<String>(type, identifier);
                updatePermissionSet(patch.getOp(), user.getConnectionGroupPermissions(), permission);
                // Create and update corresponding permission
                ObjectPermission<String> permission = new ObjectPermission<String>(type, identifier);
                updatePermissionSet(patch.getOp(), user.getUserPermissions(), permission);

                // Create and update corresponding permission
                SystemPermission permission = new SystemPermission(type);
                updatePermissionSet(patch.getOp(), user.getSystemPermissions(), permission);
import java.util.Collection;
        // Filter users, if requested
        Collection<String> userIdentifiers = userDirectory.getIdentifiers();
        if (!isAdmin && permissions != null) {
            ObjectPermissionSet<String> userPermissions = self.getUserPermissions();
            userIdentifiers = userPermissions.getAccessibleObjects(permissions, userIdentifiers);
            
        // Retrieve all users, converting to API users
        List<APIUser> apiUsers = new ArrayList<APIUser>();
        for (User user : userDirectory.getAll(userIdentifiers))
            apiUsers.add(new APIUser(user));

        // Return the converted user list
        return apiUsers;
     * Updates the given permission set patch by queuing an add or remove
     * operation for the given permission based on the given patch operation.
     * @param permissionSetPatch
     *     The permission set patch being modified.
            PermissionSetPatch<PermissionType> permissionSetPatch,
            PermissionType permission) {
                permissionSetPatch.addPermission(permission);
                permissionSetPatch.removePermission(permission);
        // Permission patches for all types of permissions
        PermissionSetPatch<ObjectPermission<String>> connectionPermissionPatch      = new PermissionSetPatch<ObjectPermission<String>>();
        PermissionSetPatch<ObjectPermission<String>> connectionGroupPermissionPatch = new PermissionSetPatch<ObjectPermission<String>>();
        PermissionSetPatch<ObjectPermission<String>> userPermissionPatch            = new PermissionSetPatch<ObjectPermission<String>>();
        PermissionSetPatch<SystemPermission>         systemPermissionPatch          = new PermissionSetPatch<SystemPermission>();
        
                updatePermissionSet(patch.getOp(), connectionPermissionPatch, permission);
                updatePermissionSet(patch.getOp(), connectionGroupPermissionPatch, permission);
                updatePermissionSet(patch.getOp(), userPermissionPatch, permission);
                updatePermissionSet(patch.getOp(), systemPermissionPatch, permission);
        connectionPermissionPatch.apply(user.getConnectionPermissions());
        connectionGroupPermissionPatch.apply(user.getConnectionGroupPermissions());
        userPermissionPatch.apply(user.getUserPermissions());
        systemPermissionPatch.apply(user.getSystemPermissions());
            else if (path.equals(SYSTEM_PERMISSION_PATCH_PATH)) {
    public String getIdentifier() {
    public void setIdentifier(String username) {
public interface Connection extends Identifiable {
public interface ConnectionGroup extends Identifiable {
  
    /**
     * All legal types of connection group.
     */

        /**
         * A connection group that purely organizes other connections or
         * connection groups, serving only as a container. An organizational
         * connection group is analogous to a directory or folder in a
         * filesystem.
         */
        ORGANIZATIONAL,

        /**
         * A connection group that acts as a load balancer. A balancing
         * connection group can be connected to in the same manner as a
         * connection, and will transparently route to the least-used
         * underlying connection.
         */
        BALANCING

    Directory<Connection> getConnectionDirectory()
    Directory<ConnectionGroup> getConnectionGroupDirectory()
 * @param <ObjectType>
 *     The type of objects stored within this Directory.
public interface Directory<ObjectType> {
    ObjectType get(String identifier) throws GuacamoleException;
    Collection<ObjectType> getAll(Collection<String> identifiers)
    Set<String> getIdentifiers() throws GuacamoleException;
    void remove(String identifier) throws GuacamoleException;
    void move(String identifier, Directory<ObjectType> directory) 
public interface User extends Identifiable {
    ObjectPermissionSet getConnectionPermissions()
    ObjectPermissionSet getConnectionGroupPermissions()
    ObjectPermissionSet getUserPermissions() throws GuacamoleException;
    Directory<User> getUserDirectory() throws GuacamoleException;
public class ObjectPermission implements Permission<ObjectPermission.Type> {
    private final String identifier;
    public ObjectPermission(Type type, String identifier) {
    public String getObjectIdentifier() {
public interface ObjectPermissionSet extends PermissionSet<ObjectPermission> {
            String identifier) throws GuacamoleException;
            String identifier) throws GuacamoleException;
            String identifier) throws GuacamoleException;
    Collection<String> getAccessibleObjects(
            Collection<String> identifiers) throws GuacamoleException;
    Set<ObjectPermission> getPermissions()
    void addPermissions(Set<ObjectPermission> permissions)
    void removePermissions(Set<ObjectPermission> permissions)
public class SimpleConnectionDirectory extends SimpleDirectory<Connection> {
    private final Directory<Connection> connectionDirectory;
    private final Directory<ConnectionGroup> connectionGroupDirectory;
            Directory<Connection> connectionDirectory, 
            Directory<ConnectionGroup> connectionGroupDirectory) {
    public Directory<Connection> getConnectionDirectory() 
    public Directory<ConnectionGroup> getConnectionGroupDirectory() 
    extends SimpleDirectory<ConnectionGroup> {
public class SimpleDirectory<ObjectType> implements Directory<ObjectType> {
    private Map<String, ObjectType> objects = Collections.EMPTY_MAP;
    public SimpleDirectory(Map<String, ObjectType> objects) {
    protected void setObjects(Map<String, ObjectType> objects) {
    protected Map<String, ObjectType> getObjects() {
    public ObjectType get(String identifier)
    public Collection<ObjectType> getAll(Collection<String> identifiers)
        for (String identifier : identifiers) {
    public Set<String> getIdentifiers() throws GuacamoleException {
    public void remove(String identifier) throws GuacamoleException {
    public void move(String identifier, Directory<ObjectType> directory)
public class SimpleObjectPermissionSet implements ObjectPermissionSet {
    private Set<ObjectPermission> permissions = Collections.EMPTY_SET;
    public SimpleObjectPermissionSet(Set<ObjectPermission> permissions) {
    protected void setPermissions(Set<ObjectPermission> permissions) {
    public Set<ObjectPermission> getPermissions() {
            String identifier) throws GuacamoleException {
        ObjectPermission objectPermission =
                new ObjectPermission(permission, identifier);
            String identifier) throws GuacamoleException {
            String identifier) throws GuacamoleException {
    public Collection<String> getAccessibleObjects(
            Collection<String> identifiers) throws GuacamoleException {
        Collection<String> accessibleObjects = new ArrayList<String>(permissions.size());
        for (String identifier : identifiers) {
                ObjectPermission permission = new ObjectPermission(permissionType, identifier);
    public void addPermissions(Set<ObjectPermission> permissions)
    public void removePermissions(Set<ObjectPermission> permissions)
    private final Set<ObjectPermission> connectionPermissions =
            new HashSet<ObjectPermission>();
    private final Set<ObjectPermission> connectionGroupPermissions =
            new HashSet<ObjectPermission>();
        setIdentifier(username);
    public ObjectPermissionSet getConnectionPermissions()
        return new SimpleObjectPermissionSet(connectionPermissions);
    public ObjectPermissionSet getConnectionGroupPermissions()
        return new SimpleObjectPermissionSet(connectionGroupPermissions);
    public ObjectPermissionSet getUserPermissions()
        return new SimpleObjectPermissionSet();
    private final Directory<User> userDirectory;
    public Directory<User> getUserDirectory()
public class SimpleUserDirectory extends SimpleDirectory<User> {
        super(Collections.singletonMap(user.getIdentifier(), user));
                Directory<Connection> directory =
                    logger.info("Connection \"{}\" does not exist for user \"{}\".", id, context.self().getIdentifier());
                logger.info("User \"{}\" successfully connected to \"{}\".", context.self().getIdentifier(), id);
                Directory<ConnectionGroup> directory =
                    logger.info("Connection group \"{}\" does not exist for user \"{}\".", id, context.self().getIdentifier());
                logger.info("User \"{}\" successfully connected to group \"{}\".", context.self().getIdentifier(), id);
        Directory<User> directory = userContext.getUserDirectory();
        Directory<Connection> directory = rootGroup.getConnectionDirectory();
        Directory<ConnectionGroup> directory = rootGroup.getConnectionGroupDirectory();
        logger.debug("Login was successful for user \"{}\".", userContext.self().getIdentifier());
        return new APIAuthToken(authToken, userContext.self().getIdentifier());
        ObjectPermissionSet connectionPermissions = self.getConnectionPermissions();
        Directory<Connection> connectionDirectory =
        Directory<Connection> connectionDirectory = parentConnectionGroup.getConnectionDirectory();
        Directory<Connection> connectionDirectory =
    public Directory<Connection> getConnectionDirectory() throws GuacamoleException {
    public Directory<ConnectionGroup> getConnectionGroupDirectory() throws GuacamoleException {
        ObjectPermissionSet connectionPermissions = user.getConnectionPermissions();
        ObjectPermissionSet connectionGroupPermissions = user.getConnectionGroupPermissions();
            Directory<Connection> connectionDirectory = connectionGroup.getConnectionDirectory();
            Directory<ConnectionGroup> groupDirectory = connectionGroup.getConnectionGroupDirectory();
        Directory<ConnectionGroup> connectionGroupDirectory =
        Directory<ConnectionGroup> connectionGroupDirectory = parentConnectionGroup.getConnectionGroupDirectory();
        Directory<ConnectionGroup> connectionGroupDirectory =
            ObjectPermissionSet permSet) throws GuacamoleException {
        for (ObjectPermission permission : permSet.getPermissions()) {
        this.username = user.getIdentifier();
    public String getIdentifier() {
    public void setIdentifier(String username) {
    public ObjectPermissionSet getConnectionPermissions()
    public ObjectPermissionSet getConnectionGroupPermissions()
    public ObjectPermissionSet getUserPermissions()
        Directory<User> userDirectory = userContext.getUserDirectory();
            ObjectPermissionSet userPermissions = self.getUserPermissions();
        Directory<User> userDirectory = userContext.getUserDirectory();
        Directory<User> userDirectory = userContext.getUserDirectory();
        Directory<User> userDirectory = userContext.getUserDirectory();
        if (userContext.self().getIdentifier().equals(username))
        PermissionSetPatch<ObjectPermission> connectionPermissionPatch      = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<ObjectPermission> connectionGroupPermissionPatch = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<ObjectPermission> userPermissionPatch            = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<SystemPermission> systemPermissionPatch          = new PermissionSetPatch<SystemPermission>();
                ObjectPermission permission = new ObjectPermission(type, identifier);
                ObjectPermission permission = new ObjectPermission(type, identifier);
                ObjectPermission permission = new ObjectPermission(type, identifier);
        // Retrieve the requested connection group
        return new APIConnectionGroup(retrievalService.retrieveConnectionGroup(userContext, connectionGroupID));
        // Retrieve the requested tree, filtering by the given permissions
        ConnectionGroup treeRoot = retrievalService.retrieveConnectionGroup(userContext, connectionGroupID);
        ConnectionGroupTree tree = new ConnectionGroupTree(treeRoot, permissions);
        // Return tree as a connection group
        return tree.getRootAPIConnectionGroup();
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.glyptodon.guacamole.net.auth.Connection;
import org.glyptodon.guacamole.net.basic.rest.connection.APIConnection;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(ConnectionGroupTree.class);
    
    /**
    private final ConnectionGroup root;
    
    /**
     * The root connection group as an APIConnectionGroup.
     */
    private final APIConnectionGroup rootAPIGroup;
     * All connection groups that have been retrieved, stored by their
     * identifiers.
     */
    private final Map<String, APIConnectionGroup> retrievedGroups =
            new HashMap<String, APIConnectionGroup>();

    /**
     * Adds each of the provided connections to the current tree as children
     * of their respective parents. The parent connection groups must already
     * be added.
     *
     * @param connections
     *     The connections to add to the tree.
     * 
     * @throws GuacamoleException
     *     If an error occurs while adding the connection to the tree.
     */
    private void addConnections(Collection<Connection> connections)
        throws GuacamoleException {

        // Add each connection to the tree
        for (Connection connection : connections) {

            // Retrieve the connection's parent group
            APIConnectionGroup parent = retrievedGroups.get(connection.getParentIdentifier());
            if (parent != null) {

                Collection<APIConnection> children = parent.getChildConnections();
                
                // Create child collection if it does not yet exist
                if (children == null) {
                    children = new ArrayList<APIConnection>();
                    parent.setChildConnections(children);
                }

                // Add child
                children.add(new APIConnection(connection));
                
            }

            // Warn of internal consistency issues
            else
                logger.debug("Connection \"{}\" cannot be added to the tree: parent \"{}\" does not actually exist.",
                        connection.getIdentifier(),
                        connection.getParentIdentifier());

        } // end for each connection
        
    }
    
    /**
     * Adds each of the provided connection groups to the current tree as
     * children of their respective parents. The parent connection groups must
     * already be added.
     *
     * @param connectionGroups
     *     The connection groups to add to the tree.
     */
    private void addConnectionGroups(Collection<ConnectionGroup> connectionGroups) {

        // Add each connection group to the tree
        for (ConnectionGroup connectionGroup : connectionGroups) {

            // Retrieve the connection group's parent group
            APIConnectionGroup parent = retrievedGroups.get(connectionGroup.getParentIdentifier());
            if (parent != null) {

                Collection<APIConnectionGroup> children = parent.getChildConnectionGroups();
                
                // Create child collection if it does not yet exist
                if (children == null) {
                    children = new ArrayList<APIConnectionGroup>();
                    parent.setChildConnectionGroups(children);
                }

                // Add child
                APIConnectionGroup apiConnectionGroup = new APIConnectionGroup(connectionGroup);
                retrievedGroups.put(connectionGroup.getIdentifier(), apiConnectionGroup);
                children.add(apiConnectionGroup);
                
            }

            // Warn of internal consistency issues
            else
                logger.debug("Connection group \"{}\" cannot be added to the tree: parent \"{}\" does not actually exist.",
                        connectionGroup.getIdentifier(),
                        connectionGroup.getParentIdentifier());

        } // end for each connection group
        
    }
    
    /**
     * Adds all descendants of the given parent groups to their corresponding
     * parents already stored under root.
     *
     * @param parents
     *     The parents whose descendants should be added to the tree.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the descendants.
     */
    private void addDescendants(Collection<ConnectionGroup> parents)
        throws GuacamoleException {

        // If no parents, nothing to do
        if (parents.isEmpty())
            return;

        Collection<String> childConnectionIdentifiers = new ArrayList<String>();
        Collection<String> childConnectionGroupIdentifiers = new ArrayList<String>();
        
        // Build lists of identifiers for retrieval
        for (ConnectionGroup parent : parents) {
            childConnectionIdentifiers.addAll(parent.getConnectionDirectory().getIdentifiers());
            childConnectionGroupIdentifiers.addAll(parent.getConnectionGroupDirectory().getIdentifiers());
        }

        // Retrieve child connections
        if (!childConnectionIdentifiers.isEmpty()) {
            Collection<Connection> childConnections = root.getConnectionDirectory().getAll(childConnectionIdentifiers);
            addConnections(childConnections);
        }

        // Retrieve child connection groups
        if (!childConnectionGroupIdentifiers.isEmpty()) {
            Collection<ConnectionGroup> childConnectionGroups = root.getConnectionGroupDirectory().getAll(childConnectionGroupIdentifiers);
            addConnectionGroups(childConnectionGroups);
            addDescendants(childConnectionGroups);
        }

    }
    
    /**
        this.root = root;
        this.rootAPIGroup = new APIConnectionGroup(root);
        retrievedGroups.put(root.getIdentifier(), this.rootAPIGroup);
        // Add all descendants
        addDescendants(Collections.singleton(root));
        return rootAPIGroup;
import java.util.Collection;
     * Creates a new SimpleConnectionDirectory which provides access to the
     * connections contained within the given Map.
     * @param connections
     *     A Collection of all connections that should be present in this
     *     connection directory.
    public SimpleConnectionDirectory(Collection<Connection> connections) {
        // Add all given connections
        for (Connection connection : connections)
            this.connections.put(connection.getIdentifier(), connection);
        // Use the connection map to back the underlying directory 
        super.setObjects(this.connections);
import java.util.ArrayList;
import java.util.Collection;
import org.glyptodon.guacamole.net.auth.Connection;
     * The unique identifier of the root connection group.
     */
    private static final String ROOT_IDENTIFIER = "ROOT";
    
    /**
        // Produce collection of connections from given configs
        Collection<Connection> connections = new ArrayList<Connection>(configs.size());
        for (Map.Entry<String, GuacamoleConfiguration> configEntry : configs.entrySet()) {

            // Get connection identifier and configuration
            String identifier = configEntry.getKey();
            GuacamoleConfiguration config = configEntry.getValue();

            // Add as simple connection
            Connection connection = new SimpleConnection(identifier, identifier, config);
            connection.setParentIdentifier(ROOT_IDENTIFIER);
            connections.add(connection);

        }
        
        this.connectionGroup = new SimpleConnectionGroup(
                ROOT_IDENTIFIER, ROOT_IDENTIFIER,
                new SimpleConnectionDirectory(connections),
public interface Connection extends Identifiable, Connectable {
import java.util.Set;
public interface ConnectionGroup extends Identifiable, Connectable {
     * Returns the identifiers of all readable connections that are children
     * of this connection group.
     * @return
     *     The set of identifiers of all readable connections that are children
     *     of this connection group.
    public Set<String> getConnectionIdentifiers();
     * Returns the identifiers of all readable connection groups that are
     * children of this connection group.
     * @return
     *     The set of identifiers of all readable connection groups that are
     *     children of this connection group.

    public Set<String> getConnectionGroupIdentifiers();
     * Retrieves a Directory which can be used to view and manipulate
     * connections and their configurations, but only as allowed by the
     * permissions given to the user.
     *
     * @return A Directory whose operations are bound by the permissions of 
     *         the user.
     *
     * @throws GuacamoleException If an error occurs while creating the
     *                            Directory.
     */
    Directory<Connection> getConnectionDirectory()
            throws GuacamoleException;

    /**
     * Retrieves a Directory which can be used to view and manipulate
     * connection groups and their members, but only as allowed by the
     * permissions given to the user.
     *
     * @return A Directory whose operations are bound by the permissions of
     *         the user.
     *
     * @throws GuacamoleException If an error occurs while creating the
     *                            Directory.
     */
    Directory<ConnectionGroup> getConnectionGroupDirectory()
            throws GuacamoleException;

    /**
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
 * returns the connection and connection group identifiers it was constructed
     * The identifiers of all connections in this group.
    private final Set<String> connectionIdentifiers;
     * The identifiers of all connection groups in this group.
    private final Set<String> connectionGroupIdentifiers;
     * which will expose the given contents.
     * @param name
     *     The name to associate with this connection group.
     *
     * @param identifier
     *     The identifier to associate with this connection group.
     *
     * @param connectionIdentifiers
     *     The connection identifiers to expose when requested.
     *
     * @param connectionGroupIdentifiers
     *     The connection group identifiers to expose when requested.
            Collection<String> connectionIdentifiers, 
            Collection<String> connectionGroupIdentifiers) {
        // Populate contents
        this.connectionIdentifiers = new HashSet<String>(connectionIdentifiers);
        this.connectionGroupIdentifiers = new HashSet<String>(connectionGroupIdentifiers);
    public Set<String> getConnectionIdentifiers() {
        return connectionIdentifiers;
    }

    @Override
    public Set<String> getConnectionGroupIdentifiers() {
        return connectionGroupIdentifiers;
     * Adds a new READ permission to the given set of permissions for each of
     * the given identifiers.
     * @param permissions
     *     The set of permissions to add READ permissions to.
     *
     * @param identifiers
     *     The identifiers which should each have a corresponding READ
     *     permission added to the given set.
     */
    private void addReadPermissions(Set<ObjectPermission> permissions,
            Collection<String> identifiers) {

        // Add a READ permission to the set for each identifier given
        for (String identifier : identifiers) {
            permissions.add(new ObjectPermission (
                ObjectPermission.Type.READ,
                identifier
            ));
        }

    }
    
    /**
     * Creates a new SimpleUser having the given username and READ access to
     * the connections and groups having the given identifiers.
     *
     * @param username
     *     The username to assign to this SimpleUser.
     * @param connectionIdentifiers
     *     The identifiers of all connections this user has READ access to.
     *
     * @param connectionGroupIdentifiers
     *     The identifiers of all connection groups this user has READ access
     *     to.
            Collection<String> connectionIdentifiers,
            Collection<String> connectionGroupIdentifiers) {
        // Add permissions
        addReadPermissions(connectionPermissions,      connectionIdentifiers);
        addReadPermissions(connectionGroupPermissions, connectionGroupIdentifiers);
     * The Directory with access only to the root group associated with this
     * UserContext.
    private final Directory<ConnectionGroup> connectionGroupDirectory;

    /**
     * The Directory with access to all connections within the root group
     * associated with this UserContext.
     */
    private final Directory<Connection> connectionDirectory;

    /**
     * The root connection group.
     */
    private final ConnectionGroup rootGroup;
        Collection<String> connectionIdentifiers = new ArrayList<String>(configs.size());
        Collection<String> connectionGroupIdentifiers = Collections.singleton(ROOT_IDENTIFIER);
        
            // Add identifier to overall set of identifiers
            connectionIdentifiers.add(identifier);
            
        // Add root group that contains only the given configurations
        this.rootGroup = new SimpleConnectionGroup(
            ROOT_IDENTIFIER, ROOT_IDENTIFIER,
            connectionIdentifiers, Collections.EMPTY_LIST
        );
        // Build new user from credentials
        this.self = new SimpleUser(username, connectionIdentifiers,
                connectionGroupIdentifiers);
        // Create directories for new user
        this.connectionDirectory = new SimpleConnectionDirectory(connections);
        this.connectionGroupDirectory = new SimpleConnectionGroupDirectory(Collections.singleton(this.rootGroup));
    public Directory<Connection> getConnectionDirectory()
            throws GuacamoleException {
        return connectionDirectory;
    }

    @Override
    public Directory<ConnectionGroup> getConnectionGroupDirectory()
            throws GuacamoleException {
        return connectionGroupDirectory;
    }

    @Override
        return rootGroup;
                UserContext context = session.getUserContext();
                Directory<Connection> directory = context.getConnectionDirectory();
                UserContext context = session.getUserContext();
                Directory<ConnectionGroup> directory = context.getConnectionGroupDirectory();
        // Get connection directory
        Directory<Connection> directory = userContext.getConnectionDirectory();
        // Use root group if identifier is the standard root identifier
            return userContext.getRootConnectionGroup();
        Directory<ConnectionGroup> directory = userContext.getConnectionGroupDirectory();
        Directory<Connection> connectionDirectory = userContext.getConnectionDirectory();
        Directory<Connection> connectionDirectory = userContext.getConnectionDirectory();
        Directory<Connection> connectionDirectory = userContext.getConnectionDirectory();
import java.util.Set;
    public Set<String> getConnectionIdentifiers() {
    public Set<String> getConnectionGroupIdentifiers() {
        ConnectionGroupTree tree = new ConnectionGroupTree(userContext, treeRoot, permissions);
        Directory<ConnectionGroup> connectionGroupDirectory = userContext.getConnectionGroupDirectory();
        Directory<ConnectionGroup> connectionGroupDirectory = userContext.getConnectionGroupDirectory();
        Directory<ConnectionGroup> connectionGroupDirectory = userContext.getConnectionGroupDirectory();
import org.glyptodon.guacamole.net.auth.UserContext;

     * The context of the user obtaining this tree.
    private final UserContext userContext;
            childConnectionIdentifiers.addAll(parent.getConnectionIdentifiers());
            childConnectionGroupIdentifiers.addAll(parent.getConnectionGroupIdentifiers());
            Collection<Connection> childConnections = userContext.getConnectionDirectory().getAll(childConnectionIdentifiers);
            Collection<ConnectionGroup> childConnectionGroups = userContext.getConnectionGroupDirectory().getAll(childConnectionGroupIdentifiers);
     * @param userContext
     *     The context of the user obtaining the connection group tree.
     *
    public ConnectionGroupTree(UserContext userContext, ConnectionGroup root,
        this.userContext = userContext;
        
    /**
     * Returns the number of active connections associated with this object.
     * Implementations may simply return 0 if this value is not tracked.
     *
     * @return
     *     The number of active connections associated with this object.
     */
    public int getActiveConnections();
    
    public int getActiveConnections() {
        return 0;
    }

    @Override
    public int getActiveConnections() {
        return 0;
    }

    @Override
     * The count of currently active connections using this connection.
    private int activeConnections;
        // Set connection information
        this.activeConnections = connection.getActiveConnections();
     * Returns the number of currently active connections using this
     * connection.
     *
     * @return
     *     The number of currently active usages of this connection.
    public int getActiveConnections() {
        return activeConnections;
     * Set the number of currently active connections using this connection.
     *
     * @param activeConnections
     *     The number of currently active usages of this connection.
    public void setActiveUsers(int activeConnections) {
        this.activeConnections = activeConnections;
    /**
     * The wrapped APIConnection.
     */

    /**
     * Creates a new APIConnectionWrapper which wraps the given APIConnection
     * as a Connection.
     *
     * @param apiConnection
     *     The APIConnection to wrap.
     */
    public int getActiveConnections() {
        return apiConnection.getActiveConnections();
    }

    @Override
     * The count of currently active connections using this connection group.
     */
    private int activeConnections;

    /**
        this.activeConnections = connectionGroup.getActiveConnections();
    /**
     * Returns the number of currently active connections using this
     * connection group.
     *
     * @return
     *     The number of currently active usages of this connection group.
     */
    public int getActiveConnections() {
        return activeConnections;
    }

    /**
     * Set the number of currently active connections using this connection
     * group.
     *
     * @param activeConnections
     *     The number of currently active usages of this connection group.
     */
    public void setActiveUsers(int activeConnections) {
        this.activeConnections = activeConnections;
    }
    
    public int getActiveConnections() {
        return apiConnectionGroup.getActiveConnections();
    }

    @Override
import org.glyptodon.guacamole.GuacamoleException;
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the identifiers.
    public Set<String> getConnectionIdentifiers() throws GuacamoleException;
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the identifiers.
    public Set<String> getConnectionGroupIdentifiers()
            throws GuacamoleException;
    public String getIdentifier() {
    public void setIdentifier(String username) {
public interface Connection extends Identifiable, Connectable {
import java.util.Set;
public interface ConnectionGroup extends Identifiable, Connectable {
  
    /**
     * All legal types of connection group.
     */

        /**
         * A connection group that purely organizes other connections or
         * connection groups, serving only as a container. An organizational
         * connection group is analogous to a directory or folder in a
         * filesystem.
         */
        ORGANIZATIONAL,

        /**
         * A connection group that acts as a load balancer. A balancing
         * connection group can be connected to in the same manner as a
         * connection, and will transparently route to the least-used
         * underlying connection.
         */
        BALANCING

     * Returns the identifiers of all readable connections that are children
     * of this connection group.
     * @return
     *     The set of identifiers of all readable connections that are children
     *     of this connection group.
     * @throws GuacamoleException
     *     If an error occurs while retrieving the identifiers.
    public Set<String> getConnectionIdentifiers() throws GuacamoleException;
     * Returns the identifiers of all readable connection groups that are
     * children of this connection group.
     * @return
     *     The set of identifiers of all readable connection groups that are
     *     children of this connection group.
     * @throws GuacamoleException
     *     If an error occurs while retrieving the identifiers.

    public Set<String> getConnectionGroupIdentifiers()
import java.util.Collection;
 * @param <ObjectType>
 *     The type of objects stored within this Directory.
public interface Directory<ObjectType> {
    ObjectType get(String identifier) throws GuacamoleException;

    /**
     * Returns the objects having the given identifiers. Note that changes to
     * any object returned will not necessarily affect the object stored within
     * the Directory. To update an object stored within a
     * Directory such that future calls to get() will return the updated
     * object, you must call update() on the object after modification.
     *
     * @param identifiers
     *     The identifiers to use when locating the objects to return.
     *
     * @return
     *     The objects having the given identifiers. If any identifiers do not
     *     correspond to accessible objects, those identifiers will be ignored.
     *     If no objects correspond to any of the given identifiers, the
     *     returned collection will be empty.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the objects, or if permission
     *     to retrieve the requested objects is denied.
     */
    Collection<ObjectType> getAll(Collection<String> identifiers)
            throws GuacamoleException;
    Set<String> getIdentifiers() throws GuacamoleException;
    void remove(String identifier) throws GuacamoleException;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
public interface User extends Identifiable {
     * Returns all system-level permissions given to this user.
     * @return
     *     A SystemPermissionSet of all system-level permissions granted to
     *     this user.
     * @throws GuacamoleException 
     *     If an error occurs while retrieving permissions, or if reading all
     *     permissions is not allowed.
    SystemPermissionSet getSystemPermissions() throws GuacamoleException;
     * Returns all connection permissions given to this user.
     * @return
     *     An ObjectPermissionSet of all connection permissions granted to this
     *     user.
     * @throws GuacamoleException 
     *     If an error occurs while retrieving permissions, or if reading all
     *     permissions is not allowed.
    ObjectPermissionSet getConnectionPermissions()
            throws GuacamoleException;
     * Returns all connection group permissions given to this user.
     * @return
     *     An ObjectPermissionSet of all connection group permissions granted
     *     to this user.
     * @throws GuacamoleException
     *     If an error occurs while retrieving permissions, or if reading all
     *     permissions is not allowed.
    ObjectPermissionSet getConnectionGroupPermissions()
            throws GuacamoleException;
     * Returns all user permissions given to this user.
     * @return
     *     An ObjectPermissionSet of all user permissions granted to this user.
     * @throws GuacamoleException
     *     If an error occurs while retrieving permissions, or if reading all
     *     permissions is not allowed.
    ObjectPermissionSet getUserPermissions() throws GuacamoleException;
    Directory<User> getUserDirectory() throws GuacamoleException;

    /**
     * Retrieves a Directory which can be used to view and manipulate
     * connections and their configurations, but only as allowed by the
     * permissions given to the user.
     *
     * @return A Directory whose operations are bound by the permissions of 
     *         the user.
     *
     * @throws GuacamoleException If an error occurs while creating the
     *                            Directory.
     */
    Directory<Connection> getConnectionDirectory()
            throws GuacamoleException;

    /**
     * Retrieves a Directory which can be used to view and manipulate
     * connection groups and their members, but only as allowed by the
     * permissions given to the user.
     *
     * @return A Directory whose operations are bound by the permissions of
     *         the user.
     *
     * @throws GuacamoleException If an error occurs while creating the
     *                            Directory.
     */
    Directory<ConnectionGroup> getConnectionGroupDirectory()
            throws GuacamoleException;
public class ObjectPermission implements Permission<ObjectPermission.Type> {
     * The identifier of the GuacamoleConfiguration associated with the
     * operation affected by this permission.
     */
    private final String identifier;

    /**
     * The type of operation affected by this permission.
     */
    private final Type type;

    /**
     * Creates a new ObjectPermission having the given type and identifier.
     * The identifier must be the unique identifier assigned to the object
     * associated with this permission by the AuthenticationProvider in use.
     *
     * @param type
     *     The type of operation affected by this permission.
     *
     * @param identifier
     *     The identifier of the object associated with the operation affected
     *     by this permission.
     */
    public ObjectPermission(Type type, String identifier) {

        this.identifier = identifier;
        this.type = type;

    }

   /**
    public String getObjectIdentifier() {
        return identifier;
    }

    @Override
    public Type getType() {
        return type;
    }

    @Override
    public int hashCode() {
        int hash = 5;
        if (identifier != null) hash = 47 * hash  identifier.hashCode();
        if (type != null)       hash = 47 * hash  type.hashCode();
        return hash;
    }

    @Override
    public boolean equals(Object obj) {

        // Not equal if null or wrong type
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;

        final ObjectPermission other = (ObjectPermission) obj;

        // Not equal if different type
        if (this.type != other.type)
            return false;

        // If null identifier, equality depends on whether other identifier
        // is null
        if (identifier == null)
            return other.identifier == null;

        // Otherwise, equality depends entirely on identifier
        return identifier.equals(other.identifier);

    }
    public int getActiveConnections() {
        return 0;
    }

    @Override
import java.util.Collection;
public class SimpleConnectionDirectory extends SimpleDirectory<Connection> {
    private final Map<String, Connection> connections =
     * Creates a new SimpleConnectionDirectory which provides access to the
     * connections contained within the given Map.
     * @param connections
     *     A Collection of all connections that should be present in this
     *     connection directory.
    public SimpleConnectionDirectory(Collection<Connection> connections) {
        // Add all given connections
        for (Connection connection : connections)
            this.connections.put(connection.getIdentifier(), connection);

        // Use the connection map to back the underlying directory 
        super.setObjects(this.connections);
     *

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
 * returns the connection and connection group identifiers it was constructed
     * The identifiers of all connections in this group.
    private final Set<String> connectionIdentifiers;
     * The identifiers of all connection groups in this group.
    private final Set<String> connectionGroupIdentifiers;
     * which will expose the given contents.
     * @param name
     *     The name to associate with this connection group.
     *
     * @param identifier
     *     The identifier to associate with this connection group.
     *
     * @param connectionIdentifiers
     *     The connection identifiers to expose when requested.
     *
     * @param connectionGroupIdentifiers
     *     The connection group identifiers to expose when requested.
            Collection<String> connectionIdentifiers, 
            Collection<String> connectionGroupIdentifiers) {
        // Populate contents
        this.connectionIdentifiers = new HashSet<String>(connectionIdentifiers);
        this.connectionGroupIdentifiers = new HashSet<String>(connectionGroupIdentifiers);
    public int getActiveConnections() {
        return 0;
    }

    @Override
    public Set<String> getConnectionIdentifiers() {
        return connectionIdentifiers;
    }

    @Override
    public Set<String> getConnectionGroupIdentifiers() {
        return connectionGroupIdentifiers;
    extends SimpleDirectory<ConnectionGroup> {
    private final Map<String, ConnectionGroup> connectionGroups =
     *
        // Use the connection group map to back the underlying AbstractDirectory
        super.setObjects(connectionGroups);
     *

     *
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
     * All connection permissions granted to this user.
    private final Set<ObjectPermission> connectionPermissions =
            new HashSet<ObjectPermission>();
    
    /**
     * All connection group permissions granted to this user.
     */
    private final Set<ObjectPermission> connectionGroupPermissions =
            new HashSet<ObjectPermission>();
     * Adds a new READ permission to the given set of permissions for each of
     * the given identifiers.
     * @param permissions
     *     The set of permissions to add READ permissions to.
     *
     * @param identifiers
     *     The identifiers which should each have a corresponding READ
     *     permission added to the given set.
    private void addReadPermissions(Set<ObjectPermission> permissions,
            Collection<String> identifiers) {
        // Add a READ permission to the set for each identifier given
        for (String identifier : identifiers) {
            permissions.add(new ObjectPermission (
            ));
    
    /**
     * Creates a new SimpleUser having the given username and READ access to
     * the connections and groups having the given identifiers.
     *
     * @param username
     *     The username to assign to this SimpleUser.
     * @param connectionIdentifiers
     *     The identifiers of all connections this user has READ access to.
     *
     * @param connectionGroupIdentifiers
     *     The identifiers of all connection groups this user has READ access
     *     to.
     */
    public SimpleUser(String username,
            Collection<String> connectionIdentifiers,
            Collection<String> connectionGroupIdentifiers) {
        // Set username
        setIdentifier(username);

        // Add permissions
        addReadPermissions(connectionPermissions,      connectionIdentifiers);
        addReadPermissions(connectionGroupPermissions, connectionGroupIdentifiers);

    public SystemPermissionSet getSystemPermissions()
            throws GuacamoleException {
        return new SimpleSystemPermissionSet();
    public ObjectPermissionSet getConnectionPermissions()
            throws GuacamoleException {
        return new SimpleObjectPermissionSet(connectionPermissions);
    public ObjectPermissionSet getConnectionGroupPermissions()
            throws GuacamoleException {
        return new SimpleObjectPermissionSet(connectionGroupPermissions);
    }

    @Override
    public ObjectPermissionSet getUserPermissions()
            throws GuacamoleException {
        return new SimpleObjectPermissionSet();
import java.util.ArrayList;
import java.util.Collection;
import org.glyptodon.guacamole.net.auth.Connection;
     * The unique identifier of the root connection group.
     */
    private static final String ROOT_IDENTIFIER = "ROOT";
    
    /**
    private final Directory<User> userDirectory;
     * The Directory with access only to the root group associated with this
     * UserContext.
    private final Directory<ConnectionGroup> connectionGroupDirectory;

    /**
     * The Directory with access to all connections within the root group
     * associated with this UserContext.
     */
    private final Directory<Connection> connectionDirectory;

    /**
     * The root connection group.
     */
    private final ConnectionGroup rootGroup;
        Collection<String> connectionIdentifiers = new ArrayList<String>(configs.size());
        Collection<String> connectionGroupIdentifiers = Collections.singleton(ROOT_IDENTIFIER);
        
        // Produce collection of connections from given configs
        Collection<Connection> connections = new ArrayList<Connection>(configs.size());
        for (Map.Entry<String, GuacamoleConfiguration> configEntry : configs.entrySet()) {
            // Get connection identifier and configuration
            String identifier = configEntry.getKey();
            GuacamoleConfiguration config = configEntry.getValue();
            // Add as simple connection
            Connection connection = new SimpleConnection(identifier, identifier, config);
            connection.setParentIdentifier(ROOT_IDENTIFIER);
            connections.add(connection);

            // Add identifier to overall set of identifiers
            connectionIdentifiers.add(identifier);
            
        }
        
        // Add root group that contains only the given configurations
        this.rootGroup = new SimpleConnectionGroup(
            ROOT_IDENTIFIER, ROOT_IDENTIFIER,
            connectionIdentifiers, Collections.EMPTY_LIST
        );

        // Build new user from credentials
        this.self = new SimpleUser(username, connectionIdentifiers,
                connectionGroupIdentifiers);

        // Create directories for new user
        this.connectionDirectory = new SimpleConnectionDirectory(connections);
        this.connectionGroupDirectory = new SimpleConnectionGroupDirectory(Collections.singleton(this.rootGroup));
    public Directory<User> getUserDirectory()
    public Directory<Connection> getConnectionDirectory()
            throws GuacamoleException {
        return connectionDirectory;
    }

    @Override
    public Directory<ConnectionGroup> getConnectionGroupDirectory()
            throws GuacamoleException {
        return connectionGroupDirectory;
    }

    @Override
        return rootGroup;
public class SimpleUserDirectory extends SimpleDirectory<User> {
        super(Collections.singletonMap(user.getIdentifier(), user));
                UserContext context = session.getUserContext();
                Directory<Connection> directory = context.getConnectionDirectory();
                    logger.info("Connection \"{}\" does not exist for user \"{}\".", id, context.self().getIdentifier());
                logger.info("User \"{}\" successfully connected to \"{}\".", context.self().getIdentifier(), id);
                UserContext context = session.getUserContext();
                Directory<ConnectionGroup> directory = context.getConnectionGroupDirectory();
                    logger.info("Connection group \"{}\" does not exist for user \"{}\".", id, context.self().getIdentifier());
                logger.info("User \"{}\" successfully connected to group \"{}\".", context.self().getIdentifier(), id);
        Directory<User> directory = userContext.getUserDirectory();
        // Get connection directory
        Directory<Connection> directory = userContext.getConnectionDirectory();
        // Use root group if identifier is the standard root identifier
            return userContext.getRootConnectionGroup();
        Directory<ConnectionGroup> directory = userContext.getConnectionGroupDirectory();
        logger.debug("Login was successful for user \"{}\".", userContext.self().getIdentifier());
        return new APIAuthToken(authToken, userContext.self().getIdentifier());
     * The count of currently active connections using this connection.
    private int activeConnections;
        // Set connection information
        this.activeConnections = connection.getActiveConnections();
     * Returns the number of currently active connections using this
     * connection.
     *
     * @return
     *     The number of currently active usages of this connection.
    public int getActiveConnections() {
        return activeConnections;
     * Set the number of currently active connections using this connection.
     *
     * @param activeConnections
     *     The number of currently active usages of this connection.
    public void setActiveUsers(int activeConnections) {
        this.activeConnections = activeConnections;
    /**
     * The wrapped APIConnection.
     */

    /**
     * Creates a new APIConnectionWrapper which wraps the given APIConnection
     * as a Connection.
     *
     * @param apiConnection
     *     The APIConnection to wrap.
     */
    public int getActiveConnections() {
        return apiConnection.getActiveConnections();
    }

    @Override
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
        // Retrieve permission sets
        SystemPermissionSet systemPermissions = self.getSystemPermissions();
        ObjectPermissionSet connectionPermissions = self.getConnectionPermissions();

        if (!systemPermissions.hasPermission(SystemPermission.Type.ADMINISTER)
         && !connectionPermissions.hasPermission(ObjectPermission.Type.UPDATE, connectionID))
        Directory<Connection> connectionDirectory = userContext.getConnectionDirectory();
        Directory<Connection> connectionDirectory = userContext.getConnectionDirectory();
        Directory<Connection> connectionDirectory = userContext.getConnectionDirectory();
     * The count of currently active connections using this connection group.
     */
    private int activeConnections;

    /**
        this.activeConnections = connectionGroup.getActiveConnections();
    /**
     * Returns the number of currently active connections using this
     * connection group.
     *
     * @return
     *     The number of currently active usages of this connection group.
     */
    public int getActiveConnections() {
        return activeConnections;
    }

    /**
     * Set the number of currently active connections using this connection
     * group.
     *
     * @param activeConnections
     *     The number of currently active usages of this connection group.
     */
    public void setActiveUsers(int activeConnections) {
        this.activeConnections = activeConnections;
    }
    
import java.util.Set;
    public int getActiveConnections() {
        return apiConnectionGroup.getActiveConnections();
    }

    @Override
    public Set<String> getConnectionIdentifiers() {
    public Set<String> getConnectionGroupIdentifiers() {
        // Retrieve the requested connection group
        return new APIConnectionGroup(retrievalService.retrieveConnectionGroup(userContext, connectionGroupID));
        // Retrieve the requested tree, filtering by the given permissions
        ConnectionGroup treeRoot = retrievalService.retrieveConnectionGroup(userContext, connectionGroupID);
        ConnectionGroupTree tree = new ConnectionGroupTree(userContext, treeRoot, permissions);
        // Return tree as a connection group
        return tree.getRootAPIConnectionGroup();
        Directory<ConnectionGroup> connectionGroupDirectory = userContext.getConnectionGroupDirectory();
        Directory<ConnectionGroup> connectionGroupDirectory = userContext.getConnectionGroupDirectory();
        Directory<ConnectionGroup> connectionGroupDirectory = userContext.getConnectionGroupDirectory();
import org.glyptodon.guacamole.net.auth.User;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
    private Map<String, Set<ObjectPermission.Type>> connectionPermissions =
            new HashMap<String, Set<ObjectPermission.Type>>();
    private Map<String, Set<ObjectPermission.Type>> connectionGroupPermissions =
            new HashMap<String, Set<ObjectPermission.Type>>();
    private Map<String, Set<ObjectPermission.Type>> userPermissions =
            new HashMap<String, Set<ObjectPermission.Type>>();
    private Set<SystemPermission.Type> systemPermissions =
            EnumSet.noneOf(SystemPermission.Type.class);
     * Adds the system permissions from the given SystemPermissionSet to the
     * Set of system permissions provided.
     *     The Set to add system permissions to.
     *
     * @param permSet
     *     The SystemPermissionSet containing the system permissions to add.
     *     If an error occurs while retrieving system permissions from the
     *     SystemPermissionSet.
    private void addSystemPermissions(Set<SystemPermission.Type> permissions,
            SystemPermissionSet permSet) throws GuacamoleException {
        // Add all provided system permissions 
        for (SystemPermission permission : permSet.getPermissions())
            permissions.add(permission.getType());
    
     * Adds the object permissions from the given ObjectPermissionSet to the
     * Map of object permissions provided.
     *     The Map to add object permissions to.
     *
     * @param permSet
     *     The ObjectPermissionSet containing the object permissions to add.
     *     If an error occurs while retrieving object permissions from the
     *     ObjectPermissionSet.
    private void addObjectPermissions(Map<String, Set<ObjectPermission.Type>> permissions,
            ObjectPermissionSet permSet) throws GuacamoleException {
        // Add all provided object permissions 
        for (ObjectPermission permission : permSet.getPermissions()) {
            // Get associated set of permissions
            String identifier = permission.getObjectIdentifier();
            Set<ObjectPermission.Type> objectPermissions = permissions.get(identifier);

            // Create new set if none yet exists
            if (objectPermissions == null)
                permissions.put(identifier, EnumSet.of(permission.getType()));

            // Otherwise add to existing set
            else
                objectPermissions.add(permission.getType());

        }

    }
    
    /**
     * Creates a new permission set containing all permissions currently
     * granted to the given user.
     *
     * @param user
     *     The user whose permissions should be stored within this permission
     *     set.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the user's permissions.
     */
    public APIPermissionSet(User user) throws GuacamoleException {

        // Add all permissions from the provided user
        addSystemPermissions(systemPermissions,          user.getSystemPermissions());
        addObjectPermissions(connectionPermissions,      user.getConnectionPermissions());
        addObjectPermissions(connectionGroupPermissions, user.getConnectionGroupPermissions());
        addObjectPermissions(userPermissions,            user.getUserPermissions());
        
    public Map<String, Set<ObjectPermission.Type>> getConnectionPermissions() {
    public Map<String, Set<ObjectPermission.Type>> getConnectionGroupPermissions() {
    public Map<String, Set<ObjectPermission.Type>> getUserPermissions() {
    public Set<SystemPermission.Type> getSystemPermissions() {
    public void setConnectionPermissions(Map<String, Set<ObjectPermission.Type>> connectionPermissions) {
    public void setConnectionGroupPermissions(Map<String, Set<ObjectPermission.Type>> connectionGroupPermissions) {
    public void setUserPermissions(Map<String, Set<ObjectPermission.Type>> userPermissions) {
    public void setSystemPermissions(Set<SystemPermission.Type> systemPermissions) {
        this.username = user.getIdentifier();
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
 * A wrapper to make an APIUser look like a User. Useful where an
 * org.glyptodon.guacamole.net.auth.User is required. As a simple wrapper for
 * APIUser, access to permissions is not provided. Any attempt to access or
 * manipulate permissions on an APIUserWrapper will result in an exception.
    public String getIdentifier() {
    public void setIdentifier(String username) {
    public SystemPermissionSet getSystemPermissions()
            throws GuacamoleException {
        throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
    public ObjectPermissionSet getConnectionPermissions()
            throws GuacamoleException {
        throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
    public ObjectPermissionSet getConnectionGroupPermissions()
            throws GuacamoleException {
        throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
    public ObjectPermissionSet getUserPermissions()
            throws GuacamoleException {
        throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
import java.util.Collection;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
        SystemPermissionSet systemPermissions = self.getSystemPermissions();
        boolean isAdmin = systemPermissions.hasPermission(SystemPermission.Type.ADMINISTER);
        Directory<User> userDirectory = userContext.getUserDirectory();
        // Filter users, if requested
        Collection<String> userIdentifiers = userDirectory.getIdentifiers();
        if (!isAdmin && permissions != null) {
            ObjectPermissionSet userPermissions = self.getUserPermissions();
            userIdentifiers = userPermissions.getAccessibleObjects(permissions, userIdentifiers);
            
        // Retrieve all users, converting to API users
        List<APIUser> apiUsers = new ArrayList<APIUser>();
        for (User user : userDirectory.getAll(userIdentifiers))
            apiUsers.add(new APIUser(user));

        // Return the converted user list
        return apiUsers;
        Directory<User> userDirectory = userContext.getUserDirectory();
        Directory<User> userDirectory = userContext.getUserDirectory();
        Directory<User> userDirectory = userContext.getUserDirectory();
        if (userContext.self().getIdentifier().equals(username))
        return new APIPermissionSet(user);

    }

    /**
     * Updates the given permission set patch by queuing an add or remove
     * operation for the given permission based on the given patch operation.
     *
     * @param <PermissionType>
     *     The type of permission stored within the permission set.
     *
     * @param operation
     *     The patch operation to perform.
     *
     * @param permissionSetPatch
     *     The permission set patch being modified.
     *
     * @param permission
     *     The permission being added or removed from the set.
     */
    private <PermissionType extends Permission> void updatePermissionSet(
            APIPatch.Operation operation,
            PermissionSetPatch<PermissionType> permissionSetPatch,
            PermissionType permission) {

        // Add or remove permission based on operation
        switch (operation) {

            // Add permission
            case add:
                permissionSetPatch.addPermission(permission);
                break;

            // Remove permission
            case remove:
                permissionSetPatch.removePermission(permission);
                break;

            // Unsupported patch operation
            default:
                throw new HTTPException(Status.BAD_REQUEST,
                        "Unsupported patch operation: \""  operation  "\"");

        }
        // Permission patches for all types of permissions
        PermissionSetPatch<ObjectPermission> connectionPermissionPatch      = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<ObjectPermission> connectionGroupPermissionPatch = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<ObjectPermission> userPermissionPatch            = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<SystemPermission> systemPermissionPatch          = new PermissionSetPatch<SystemPermission>();
        
                // Create and update corresponding permission
                ObjectPermission permission = new ObjectPermission(type, identifier);
                updatePermissionSet(patch.getOp(), connectionPermissionPatch, permission);
                // Create and update corresponding permission
                ObjectPermission permission = new ObjectPermission(type, identifier);
                updatePermissionSet(patch.getOp(), connectionGroupPermissionPatch, permission);
                // Create and update corresponding permission
                ObjectPermission permission = new ObjectPermission(type, identifier);
                updatePermissionSet(patch.getOp(), userPermissionPatch, permission);

            else if (path.equals(SYSTEM_PERMISSION_PATCH_PATH)) {
                // Create and update corresponding permission
                SystemPermission permission = new SystemPermission(type);
                updatePermissionSet(patch.getOp(), systemPermissionPatch, permission);
        connectionPermissionPatch.apply(user.getConnectionPermissions());
        connectionGroupPermissionPatch.apply(user.getConnectionGroupPermissions());
        userPermissionPatch.apply(user.getUserPermissions());
        systemPermissionPatch.apply(user.getSystemPermissions());
        existingConnection.setParentIdentifier(connection.getParentIdentifier());
        existingConnectionGroup.setParentIdentifier(connectionGroup.getParentIdentifier());
        existingConnection.setParentIdentifier(connection.getParentIdentifier());
        existingConnectionGroup.setParentIdentifier(connectionGroup.getParentIdentifier());
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
     * 
     * @param permissions
     *     If specified and non-empty, limit added connections to only
     *     connections for which the current user has any of the given
     *     permissions. Otherwise, all visible connections are added.
     *     Connection groups are unaffected by this parameter.
    private void addDescendants(Collection<ConnectionGroup> parents,
            List<ObjectPermission.Type> permissions)
        // Filter identifiers based on permissions, if requested
        if (permissions != null && !permissions.isEmpty()) {
            ObjectPermissionSet permissionSet = userContext.self().getConnectionPermissions();
            childConnectionIdentifiers = permissionSet.getAccessibleObjects(permissions, childConnectionIdentifiers);
        }
        
            addDescendants(childConnectionGroups, permissions);
        addDescendants(Collections.singleton(root), permissions);
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
     * 
     * @param permissions
     *     If specified and non-empty, limit added connections to only
     *     connections for which the current user has any of the given
     *     permissions. Otherwise, all visible connections are added.
     *     Connection groups are unaffected by this parameter.
    private void addDescendants(Collection<ConnectionGroup> parents,
            List<ObjectPermission.Type> permissions)
        // Filter identifiers based on permissions, if requested
        if (permissions != null && !permissions.isEmpty()) {
            ObjectPermissionSet permissionSet = userContext.self().getConnectionPermissions();
            childConnectionIdentifiers = permissionSet.getAccessibleObjects(permissions, childConnectionIdentifiers);
        }
        
            addDescendants(childConnectionGroups, permissions);
        addDescendants(Collections.singleton(root), permissions);
    private final Injector injector;
        MySQLUser user = userService.retrieveUser(credentials);
        if (user != null) {
            context.init(user);
                    bind(MySQLUserContext.class);
                    bind(SaltService.class).to(SecureRandomSaltService.class);
                    bind(UserDirectory.class);
        socket.close();
import com.google.inject.Inject;
import net.sourceforge.guacamole.net.auth.mysql.model.UserModel;
import net.sourceforge.guacamole.net.auth.mysql.service.PasswordEncryptionService;
import net.sourceforge.guacamole.net.auth.mysql.service.SaltService;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
import org.glyptodon.guacamole.net.auth.simple.SimpleObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.simple.SimpleSystemPermissionSet;
public class MySQLUser implements User, DirectoryObject<UserModel> {
     * Service for hashing passwords.
    @Inject
    private PasswordEncryptionService encryptionService;
     * Service for providing secure, random salts.
    @Inject
    private SaltService saltService;
    
    /**
     * The internal model object containing the values which represent this
     * user in the database.
     */
    private UserModel userModel;
     * The plaintext password previously set by a call to setPassword(), if
     * any. The password of a user cannot be retrieved once saved into the
     * database, so this serves to ensure getPassword() returns a reasonable
     * value if setPassword() is called. If no password has been set, or the
     * user was retrieved from the database, this will be null.
    private String password = null;
    
     * Creates a new MySQLUser backed by the given user model object. Changes
     * to this model object will affect the new MySQLUser even after creation,
     * and changes to the new MySQLUser will affect this model object.
     * 
     * @param userModel
     *     The user model object to use to back this MySQLUser.
    public MySQLUser(UserModel userModel) {
        this.userModel = userModel;
    public UserModel getModel() {
        return userModel;
    public void setModel(UserModel userModel) {
        this.userModel = userModel;
        this.password = null;
    public String getUsername() {
        return userModel.getUsername();
    public void setUsername(String username) {
        userModel.setUsername(username);
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public void setPassword(String password) {

        // Store plaintext password internally
        this.password = password;
        
        // Generate new salt and hash given password using newly-generated salt
        byte[] salt = saltService.generateSalt();
        byte[] hash = encryptionService.createPasswordHash(password, salt);

        // Set stored salt and hash
        userModel.setPasswordSalt(salt);
        userModel.setPasswordHash(hash);

    }

    @Override
    public SystemPermissionSet getSystemPermissions()
            throws GuacamoleException {
        // STUB
        return new SimpleSystemPermissionSet();
    }

    @Override
    public ObjectPermissionSet<String> getConnectionPermissions()
            throws GuacamoleException {
        // STUB
        return new SimpleObjectPermissionSet<String>();
    }

    @Override
    public ObjectPermissionSet<String> getConnectionGroupPermissions()
            throws GuacamoleException {
        // STUB
        return new SimpleObjectPermissionSet<String>();
    }

    @Override
    public ObjectPermissionSet<String> getUserPermissions()
            throws GuacamoleException {
        // STUB
        return new SimpleObjectPermissionSet<String>();
import java.util.Collections;
import org.glyptodon.guacamole.net.auth.simple.SimpleConnectionDirectory;
import org.glyptodon.guacamole.net.auth.simple.SimpleConnectionGroup;
import org.glyptodon.guacamole.net.auth.simple.SimpleConnectionGroupDirectory;
     * The the user owning this context.
    private MySQLUser currentUser;
    public void init(MySQLUser currentUser) {
        return currentUser;
        /* STUB */
        return new SimpleConnectionGroup("ROOT", "ROOT",
            new SimpleConnectionDirectory(Collections.EMPTY_MAP),
            new SimpleConnectionGroupDirectory(Collections.EMPTY_LIST)
        );
import java.util.Collections;
import net.sourceforge.guacamole.net.auth.mysql.service.UserService;
 *
 * @author Michael Jumper
     * Service for managing user objects.
    @Override
    public User get(String identifier) throws GuacamoleException {
        return userService.retrieveObject(identifier);
    }

    @Override
    @Transactional
    public Collection<User> getAll(Collection<String> identifiers) throws GuacamoleException {
        return Collections.<User>unmodifiableCollection(userService.retrieveObjects(identifiers));
    }

    @Override
    @Transactional
    public Set<String> getIdentifiers() throws GuacamoleException {
        // STUB
        return userService.getIdentifiers();
    }

    @Override
    @Transactional
    public void add(User object) throws GuacamoleException {
        // STUB
        MySQLUser user = (MySQLUser) object;
        userService.createObject(user);
    }

    @Override
    @Transactional
    public void update(User object) throws GuacamoleException {
        // STUB
        MySQLUser user = (MySQLUser) object;
        userService.updateObject(user);
    }

    @Override
    @Transactional
    public void remove(String identifier) throws GuacamoleException {
        // STUB
        userService.deleteObject(identifier);
    }



import net.sourceforge.guacamole.net.auth.mysql.dao.DirectoryObjectMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.UserModel;
public class UserService extends DirectoryObjectService<MySQLUser, UserModel> {
     * Mapper for accessing users.
    private UserMapper userMapper;
    @Override
    protected DirectoryObjectMapper<UserModel> getObjectMapper() {
        return userMapper;
    @Override
    protected MySQLUser getObjectInstance(UserModel model) {
        MySQLUser user = mySQLUserProvider.get();
        user.setModel(model);
        return user;
        // Get username and password
        String username = credentials.getUsername();
        String password = credentials.getPassword();

        // Retrieve user model, if the user exists
        UserModel userModel = userMapper.selectByCredentials(username, password);
        if (userModel == null)
        // Return corresponding user
        return getObjectInstance(userModel);
        
 * Associates a user with the credentials they used to authenticate.
     * The user that authenticated.
    private final MySQLUser user;
     * Creates a new AuthenticatedUser associating the given user with their
     * corresponding credentials.
     * @param user
     *     The user this object should represent.
    public AuthenticatedUser(MySQLUser user, Credentials credentials) {
        this.user = user;
     * Returns the user that authenticated.
     *     The user that authenticated.
    public MySQLUser getUser() {
        return user;
        // Authenticate user

            // Upon successful authentication, return new user context
            context.init(new AuthenticatedUser(user, credentials));

    private AuthenticatedUser currentUser;
    public void init(AuthenticatedUser currentUser) {
        userDirectory.init(currentUser);
        return currentUser.getUser();
     * The user this user directory belongs to. Access is based on his/her
     * permission settings.
     */
    private AuthenticatedUser currentUser;
    
    /**
    /**
     * Set the user for this directory.
     *
     * @param currentUser
     *     The user whose permissions define the visibility of other users in
     *     this directory.
     */
    public void init(AuthenticatedUser currentUser) {
        this.currentUser = currentUser;
    }
    
        return userService.retrieveObject(currentUser, identifier);
        Collection<MySQLUser> objects = userService.retrieveObjects(currentUser, identifiers);
        return Collections.<User>unmodifiableCollection(objects);
        return userService.getIdentifiers(currentUser);
        userService.createObject(currentUser, user);
        userService.updateObject(currentUser, user);
        userService.deleteObject(currentUser, identifier);
import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
import org.glyptodon.guacamole.GuacamoleException;
     * Retrieves the single object that has the given identifier, if it exists
     * and the user has permission to read it.
     *
     * @param user
     *     The user retrieving the object.
    public ObjectType retrieveObject(AuthenticatedUser user,
            String identifier) {
        Collection<ObjectType> objects = retrieveObjects(user, Collections.singleton(identifier));
     * Only objects that the user has permission to read will be returned.
     *
     * @param user
     *     The user retrieving the objects.
    public Collection<ObjectType> retrieveObjects(AuthenticatedUser user,
            Collection<String> identifiers) {
     * @param user
     *     The user creating the object.
     *
     *
     * @throws GuacamoleException
     *     If the user lacks permission to create the object, or an error
     *     occurs while creating the object.
    public void createObject(AuthenticatedUser user, ObjectType object)
        throws GuacamoleException {
     * @param user
     *     The user deleting the object.
     *
     *
     * @throws GuacamoleException
     *     If the user lacks permission to delete the object, or an error
     *     occurs while deleting the object.
    public void deleteObject(AuthenticatedUser user, String identifier)
        throws GuacamoleException {
     * @param user
     *     The user updating the object.
     *
     *
     * @throws GuacamoleException
     *     If the user lacks permission to update the object, or an error
     *     occurs while updating the object.
    public void updateObject(AuthenticatedUser user, ObjectType object)
        throws GuacamoleException {
     * Returns the set of all identifiers for all objects in the database that
     * the user has read access to.
     *
     * @param user
     *     The user retrieving the identifiers.
    public Set<String> getIdentifiers(AuthenticatedUser user) {
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
    /**
     * Returns whether this user is a system administrator, and thus is not
     * restricted by permissions.
     *
     * @return
     *    true if this user is a system administrator, false otherwise.
     *
     * @throws GuacamoleException 
     *    If an error occurs while determining the user's system administrator
     *    status.
     */
    public boolean isAdministrator() throws GuacamoleException {
        SystemPermissionSet systemPermissionSet = getSystemPermissions();
        return systemPermissionSet.hasPermission(SystemPermission.Type.ADMINISTER);
    }
    
import net.sourceforge.guacamole.net.auth.mysql.model.UserModel;
 * @param <ModelType>
public interface DirectoryObjectMapper<ModelType> {
     * Selects the identifiers of all objects, regardless of whether they
     * are readable by any particular user. This should only be called on
     * behalf of a system administrator. If identifiers are needed by a non-
     * administrative user who must have explicit read rights, use
     * selectReadableIdentifiers() instead.
     * Selects the identifiers of all objects that are explicitly readable by
     * the given user. If identifiers are needed by a system administrator
     * (who, by definition, does not need explicit read rights), use
     * selectIdentifiers() instead.
     *
     * @param user
     *    The user whose permissions should determine whether an identifier
     *    is returned.
     *
     * @return
     *     A Set containing all identifiers of all readable objects.
     */
    Set<String> selectReadableIdentifiers(@Param("user") UserModel user);
    
    /**
     * has no corresponding object, it will be ignored. This should only be
     * called on behalf of a system administrator. If objects are needed by a
     * non-administrative user who must have explicit read rights, use
     * selectReadable() instead.
    Collection<ModelType> select(@Param("identifiers") Collection<String> identifiers);

    /**
     * Selects all objects which have the given identifiers and are explicitly
     * readably by the given user. If an identifier has no corresponding
     * object, or the corresponding object is unreadable, it will be ignored.
     * If objects are needed by a system administrator (who, by definition,
     * does not need explicit read rights), use select() instead.
     *
     * @param user
     *    The user whose permissions should determine whether an object 
     *    is returned.
     *
     * @param identifiers
     *     The identifiers of the objects to return.
     *
     * @return 
     *     A Collection of all objects having the given identifiers.
     */
    Collection<ModelType> selectReadable(@Param("user") UserModel user,
            @Param("identifiers") Collection<String> identifiers);
    int insert(@Param("object") ModelType object);
    int update(@Param("object") ModelType object);
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the requested object.
            String identifier) throws GuacamoleException {
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the requested objects.
            Collection<String> identifiers) throws GuacamoleException {
        Collection<ModelType> objects;

        // Bypass permission checks if the user is a system admin
        if (user.getUser().isAdministrator())
            objects = getObjectMapper().select(identifiers);

        // Otherwise only return explicitly readable identifiers
        else
            objects = getObjectMapper().selectReadable(user.getUser().getModel(), identifiers);
        
        return getObjectInstances(objects);
     *
     * @throws GuacamoleException
     *     If an error occurs while reading identifiers.
    public Set<String> getIdentifiers(AuthenticatedUser user)
        throws GuacamoleException {

        // Bypass permission checks if the user is a system admin
        if (user.getUser().isAdministrator())
            return getObjectMapper().selectIdentifiers();

        // Otherwise only return explicitly readable identifiers
        else
            return getObjectMapper().selectReadableIdentifiers(user.getUser().getModel());

import org.glyptodon.guacamole.net.auth.Identifiable;

public interface DirectoryObject<ModelType> extends Identifiable {
    public String getIdentifier() {
    public void setIdentifier(String username) {
    public ObjectPermissionSet getConnectionPermissions()
        return new SimpleObjectPermissionSet();
    public ObjectPermissionSet getConnectionGroupPermissions()
        return new SimpleObjectPermissionSet();
    public ObjectPermissionSet getUserPermissions()
        return new SimpleObjectPermissionSet();
    public Directory<User> getUserDirectory() throws GuacamoleException {
public class UserDirectory implements Directory<User> {
    public void move(String identifier, Directory<User> groupIdentifier) 
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
     * Returns whether the given user has permission to create the type of
     * objects that this directory object service manages.
     *
     * @param user
     *     The user being checked.
     *
     * @return
     *     true if the user has object creation permission relevant to this
     *     directory object service, false otherwise.
     * 
     * @throws GuacamoleException
     *     If permission to read the user's permissions is denied.
     */
    protected abstract boolean hasCreatePermission(AuthenticatedUser user)
            throws GuacamoleException;

    /**
     * Returns the permission set associated with the given user and related
     * to the type of objects handled by this directory object service.
     *
     * @param user
     *     The user whose permissions are being retrieved.
     *
     * @return
     *     A permission set which contains the permissions associated with the
     *     given user and related to the type of objects handled by this
     *     directory object service.
     * 
     * @throws GuacamoleException
     *     If permission to read the user's permissions is denied.
     */
    protected abstract ObjectPermissionSet getPermissionSet(AuthenticatedUser user)
            throws GuacamoleException;

    /**

        // Only create object if user has permission to do so
        if (user.getUser().isAdministrator() || hasCreatePermission(user))
            getObjectMapper().insert(object.getModel());

        // User lacks permission to create 
        throw new GuacamoleSecurityException("Permission denied.");


        // Get object permissions
        ObjectPermissionSet permissionSet = getPermissionSet(user);
        
        // Only delete object if user has permission to do so
        if (user.getUser().isAdministrator()
                || permissionSet.hasPermission(ObjectPermission.Type.DELETE, identifier))
            getObjectMapper().delete(identifier);

        // User lacks permission to delete 
        throw new GuacamoleSecurityException("Permission denied.");


        // Get object permissions
        ObjectPermissionSet permissionSet = getPermissionSet(user);
        
        // Only update object if user has permission to do so
        if (user.getUser().isAdministrator()
                || permissionSet.hasPermission(ObjectPermission.Type.UPDATE, object.getIdentifier()))
            getObjectMapper().update(object.getModel());

        // User lacks permission to update
        throw new GuacamoleSecurityException("Permission denied.");

import net.sourceforge.guacamole.net.auth.mysql.AuthenticatedUser;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
import org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet;
    @Override
    protected boolean hasCreatePermission(AuthenticatedUser user)
            throws GuacamoleException {

        // Return whether user has explicit user creation permission
        SystemPermissionSet permissionSet = user.getUser().getSystemPermissions();
        return permissionSet.hasPermission(SystemPermission.Type.CREATE_USER);

    }

    @Override
    protected ObjectPermissionSet getPermissionSet(AuthenticatedUser user)
            throws GuacamoleException {

        // Return permissions related to users
        return user.getUser().getUserPermissions();

    }

     * Initializes this object, associating it with the current authenticated
     * user and populating it with data from the given model object
     *
     * @param currentUser
     *     The user that created or retrieved this object.
     *
     * @param model 
     *     The backing model object.
     */
    public void init(AuthenticatedUser currentUser, ModelType model);

    /**
     * Returns the user that created or queried this object. This user's
     * permissions dictate what operations can be performed on or through this
     * object.
     *
     * @return
     *     The user that created or queried this object.
     */
    public AuthenticatedUser getCurrentUser();

    /**
     * Sets the user that created or queried this object. This user's
     * permissions dictate what operations can be performed on or through this
     * object.
     *
     * @param currentUser 
     *     The user that created or queried this object.
     */
    public void setCurrentUser(AuthenticatedUser currentUser);

    /**
import net.sourceforge.guacamole.net.auth.mysql.dao.SystemPermissionMapper;
import net.sourceforge.guacamole.net.auth.mysql.service.SystemPermissionService;
            context.init(user.getCurrentUser());
                    addMapperClass(SystemPermissionMapper.class);
                    bind(SystemPermissionService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.SystemPermissionService;
     * The user this user belongs to. Access is based on his/her permission
     * settings.
     */
    private AuthenticatedUser currentUser;

    /**

    /**
     * Service for retrieving system permissions.
     */
    @Inject
    private SystemPermissionService systemPermissionService;
    @Override
    public void init(AuthenticatedUser currentUser, UserModel userModel) {
        this.currentUser = currentUser;
        setModel(userModel);
    }

    @Override
    public AuthenticatedUser getCurrentUser() {
        return currentUser;
    }

    @Override
    public void setCurrentUser(AuthenticatedUser currentUser) {
        this.currentUser = currentUser;
        return new SimpleSystemPermissionSet(systemPermissionService.retrievePermissions(getCurrentUser(), this));
     * @param currentUser
     *     The user for whom this object is being created.
     *
    protected abstract ObjectType getObjectInstance(AuthenticatedUser currentUser,
            ModelType model);
     * @param currentUser
     *     The user for whom these objects are being created.
     *
    protected Collection<ObjectType> getObjectInstances(AuthenticatedUser currentUser,
            Collection<ModelType> models) {
            objects.add(getObjectInstance(currentUser, model));
        return getObjectInstances(user, objects);
    protected MySQLUser getObjectInstance(AuthenticatedUser currentUser,
            UserModel model) {
        user.init(currentUser, model);
        // Return corresponding user, set up cyclic reference
        MySQLUser user = getObjectInstance(null, userModel);
        user.setCurrentUser(new AuthenticatedUser(user, credentials));
        return user;

        if (user.getUser().isAdministrator() || hasCreatePermission(user)) {
            return;
        }
                || permissionSet.hasPermission(ObjectPermission.Type.DELETE, identifier)) {
            return;
        }
                || permissionSet.hasPermission(ObjectPermission.Type.UPDATE, object.getIdentifier())) {
            return;
        }
import java.util.ArrayList;
     * Returns an instance of a permission which is based on the given model
     *     The model object to use to produce the returned permission.
     *     A permission which is based on the given model object.
     * Returns a collection of permissions which are based on the models in
     *     The model objects to use to produce the permissions within the
     *     returned set.
     *     A set of permissions which are based on the models in the given
     * Returns an instance of a model object which is based on the given
     * permission and target user.
     *
     * @param targetUser
     *     The user to whom this permission is granted.
     *
     * @param permission
     *     The permission to use to produce the returned model object.
     *
     * @return
     *     A model object which is based on the given permission and target
     *     user.
     */
    protected abstract ModelType getModelInstance(MySQLUser targetUser,
            PermissionType permission);
    
    /**
     * Returns a collection of model objects which are based on the given
     * permissions and target user.
     *
     * @param targetUser
     *     The user to whom this permission is granted.
     *
     * @param permissions
     *     The permissions to use to produce the returned model objects.
     *
     * @return
     *     A collection of model objects which are based on the given
     *     permissions and target user.
     */
    protected Collection<ModelType> getModelInstances(MySQLUser targetUser,
            Collection<PermissionType> permissions) {

        // Create new collection of models by manually converting each permission 
        Collection<ModelType> models = new ArrayList<ModelType>(permissions.size());
        for (PermissionType permission : permissions)
            models.add(getModelInstance(targetUser, permission));

        return models;

    }
    
    /**
        throw new GuacamoleSecurityException("Permission denied.");
     * @param targetUser
     *     The user associated with the permissions to be created.
     *
            MySQLUser targetUser,
     * @param targetUser
     *     The user associated with the permissions to be deleted.
     *
            MySQLUser targetUser,
import net.sourceforge.guacamole.net.auth.mysql.MySQLUser;
import org.glyptodon.guacamole.GuacamoleSecurityException;
    protected SystemPermissionModel getModelInstance(final MySQLUser targetUser,
            final SystemPermission permission) {

        // Populate and return model object
        return new SystemPermissionModel() {

            /**
             * The ID of the user to whom this permission is granted.
             */
            private Integer userID = targetUser.getModel().getUserID();

            /**
             * The username of the user to whom this permission is granted.
             */
            private String username = targetUser.getModel().getUsername();

            /**
             * The type of action granted by this permission.
             */
            private SystemPermission.Type type = permission.getType();
            
            @Override
            public Integer getUserID() {
                return userID;
            }

            @Override
            public void setUserID(Integer userID) {
                this.userID = userID;
            }

            @Override
            public String getUsername() {
                return username;
            }

            @Override
            public void setUsername(String username) {
                this.username = username;
            }

            @Override
            public SystemPermission.Type getType() {
                return type;
            }

            @Override
            public void setType(SystemPermission.Type type) {
                this.type = type;
            }

        };
        
    public void createPermissions(AuthenticatedUser user, MySQLUser targetUser,

        // Only an admin can create system permissions
        if (user.getUser().isAdministrator()) {
            Collection<SystemPermissionModel> models = getModelInstances(targetUser, permissions);
            systemPermissionMapper.insert(models);
            return;
        }

        // User lacks permission to create system permissions
        throw new GuacamoleSecurityException("Permission denied.");
        
    }

    @Override
    public void deletePermissions(AuthenticatedUser user, MySQLUser targetUser,
            Collection<SystemPermission> permissions) throws GuacamoleException {

        // Only an admin can delete system permissions
        if (user.getUser().isAdministrator()) {
            Collection<SystemPermissionModel> models = getModelInstances(targetUser, permissions);
            systemPermissionMapper.delete(models);
            return;
        }

        // User lacks permission to delete system permissions
        throw new GuacamoleSecurityException("Permission denied.");
        
 * manipulating users. This service will automatically enforce the
 * permissions of the current user.
 * deleting object permissions. This service will automatically enforce the
 * permissions of the current user.
 * deleting permissions. This service will automatically enforce the
 * permissions of the current user.
 * deleting system permissions. This service will automatically enforce
 * the permissions of the current user.
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import net.sourceforge.guacamole.net.auth.mysql.MySQLUser;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
    protected abstract ObjectPermissionSet getAffectedPermissionSet(AuthenticatedUser user)
    /**
     * Determines whether the current user has permission to update the given
     * target user, adding or removing the given permissions. Such permission
     * depends on whether the current user is a system administrator, whether
     * they have explicit UPDATE permission on the target user, and whether
     * they have explicit ADMINISTER permission on all affected objects.
     *
     * @param user
     *     The user who is changing permissions.
     *
     * @param targetUser
     *     The user whose permissions are being changed.
     *
     * @param permissions
     *     The permissions that are being added or removed from the target
     *     user.
     *
     * @return
     *     true if the user has permission to change the target users
     *     permissions as specified, false otherwise.
     *
     * @throws GuacamoleException
     *     If an error occurs while checking permission status, or if
     *     permission is denied to read the current user's permissions.
     */
    protected boolean canAlterPermissions(AuthenticatedUser user, MySQLUser targetUser,
            Collection<ObjectPermissionType> permissions)
            throws GuacamoleException {

        // A system adminstrator can do anything
        if (user.getUser().isAdministrator())
            return true;
        
        // Verify user has update permission on the target user
        ObjectPermissionSet userPermissionSet = user.getUser().getUserPermissions();
        if (!userPermissionSet.hasPermission(ObjectPermission.Type.UPDATE, targetUser.getIdentifier()))
            return false;

        // Produce collection of affected identifiers
        Collection<String> affectedIdentifiers = new HashSet(permissions.size());
        for (ObjectPermissionType permission : permissions)
            affectedIdentifiers.add(permission.getObjectIdentifier());

        // Determine subset of affected identifiers that we have admin access to
        ObjectPermissionSet affectedPermissionSet = getAffectedPermissionSet(user);
        Collection<String> allowedSubset = affectedPermissionSet.getAccessibleObjects(
            Collections.singleton(ObjectPermission.Type.ADMINISTER),
            affectedIdentifiers
        );

        // The permissions can be altered if and only if the set of objects we
        // are allowed to administer is equal to the set of objects we will be
        // affecting.

        return affectedIdentifiers.size() == allowedSubset.size();
        
    }
    
    @Override
    public void createPermissions(AuthenticatedUser user, MySQLUser targetUser,
            Collection<ObjectPermissionType> permissions)
            throws GuacamoleException {

        // Create permissions only if user has permission to do so
        if (canAlterPermissions(user, targetUser, permissions)) {
            Collection<ModelType> models = getModelInstances(targetUser, permissions);
            getPermissionMapper().insert(models);
            return;
        }
        
        // User lacks permission to create object permissions
        throw new GuacamoleSecurityException("Permission denied.");

    }

    @Override
    public void deletePermissions(AuthenticatedUser user, MySQLUser targetUser,
            Collection<ObjectPermissionType> permissions)
            throws GuacamoleException {

        // Delete permissions only if user has permission to do so
        if (canAlterPermissions(user, targetUser, permissions)) {
            Collection<ModelType> models = getModelInstances(targetUser, permissions);
            getPermissionMapper().delete(models);
            return;
        }
        
        // User lacks permission to delete object permissions
        throw new GuacamoleSecurityException("Permission denied.");

    }
                    bind(MySQLSystemPermissionSet.class);
        return systemPermissionService.getPermissionSet(getCurrentUser(), this);
import net.sourceforge.guacamole.net.auth.mysql.model.UserModel;
import org.apache.ibatis.annotations.Param;
import org.glyptodon.guacamole.net.auth.permission.SystemPermission;

    /**
     * Retrieve the permission of the given type associated with the given
     * user, if it exists. If no such permission exists, null is returned.
     *
     * @param user
     *     The user to retrieve permissions for.
     * 
     * @param type
     *     The type of permission to return.
     *
     * @return
     *     The requested permission, or null if no such permission is granted
     *     to the given user.
     */
    SystemPermissionModel selectOne(@Param("user") UserModel user,
            @Param("type") SystemPermission.Type type);

public abstract class ObjectPermissionService<ModelType>
    extends PermissionService<ObjectPermissionSet, ObjectPermission, ModelType> {
            Collection<ObjectPermission> permissions)
        for (ObjectPermission permission : permissions)
            Collection<ObjectPermission> permissions)
            Collection<ObjectPermission> permissions)
import org.glyptodon.guacamole.net.auth.permission.PermissionSet;
 * deleting permissions, and for obtaining the permission sets that contain
 * these permissions. This service will automatically enforce the permissions
 * of the current user.
 * @param <PermissionSetType>
 *     The type of permission sets this service provides access to.
 *
public abstract class PermissionService<PermissionSetType extends PermissionSet<PermissionType>,
        PermissionType extends Permission, ModelType> {

    /**
     * Returns a permission set that can be used to retrieve and manipulate the
     * permissions of the given user.
     *
     * @param user
     *     The user who will be retrieving or manipulating permissions through
     *     the returned permission set.
     *
     * @param targetUser
     *     The user to whom the permissions in the returned permission set are
     *     granted.
     *
     * @return
     *     A permission set that contains all permissions associated with the
     *     given user, and can be used to manipulate that user's permissions.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the permissions of the given
     *     user, or if permission to retrieve the permissions of the given
     *     user is denied.
     */
    public abstract PermissionSetType getPermissionSet(AuthenticatedUser user,
            MySQLUser targetUser) throws GuacamoleException;

import com.google.inject.Provider;
import net.sourceforge.guacamole.net.auth.mysql.MySQLSystemPermissionSet;
    extends PermissionService<MySQLSystemPermissionSet, SystemPermission, SystemPermissionModel> {

    /**
     * Provider for creating system permission sets.
     */
    @Inject
    private Provider<MySQLSystemPermissionSet> systemPermissionSetProvider;

    
    public MySQLSystemPermissionSet getPermissionSet(AuthenticatedUser user,
            MySQLUser targetUser) throws GuacamoleException {

        // Create permission set for requested user
        MySQLSystemPermissionSet permissionSet = systemPermissionSetProvider.get();
        permissionSet.init(user, targetUser);

        return permissionSet;
        
    }
    
    @Override
    /**
     * Retrieves the permission of the given type associated with the given
     * user, if it exists. If no such permission exists, null is returned.
     *
     * @param user
     *     The user retrieving the permission.
     *
     * @param targetUser
     *     The user associated with the permission to be retrieved.
     * 
     * @param type
     *     The type of permission to retrieve.
     *
     * @return
     *     The permission of the given type associated with the given user, or
     *     null if no such permission exists.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the requested permission.
     */
    public SystemPermission retrievePermission(AuthenticatedUser user,
            MySQLUser targetUser, SystemPermission.Type type) throws GuacamoleException {

        // Only an admin can read permissions that aren't his own
        if (user.getUser().getIdentifier().equals(targetUser.getIdentifier())
                || user.getUser().isAdministrator())
            return getPermissionInstance(getPermissionMapper().selectOne(targetUser.getModel(), type));

        // User cannot read this user's permissions
        throw new GuacamoleSecurityException("Permission denied.");
        
    }

        // If no password provided, clear password salt and hash
        if (password == null) {
            userModel.setPasswordSalt(null);
            userModel.setPasswordHash(null);
        }

        // Otherwise generate new salt and hash given password using newly-generated salt
        else {
            byte[] salt = saltService.generateSalt();
            byte[] hash = encryptionService.createPasswordHash(password, salt);

            // Set stored salt and hash
            userModel.setPasswordSalt(salt);
            userModel.setPasswordHash(hash);
        }
        userService.createObject(currentUser, object);
 * @param <InternalType>
 *     The specific internal implementation of the type of object this service
 *     provides access to.
 *
 * @param <ExternalType>
 *     The external interface or implementation of the type of object this
 *     service provides access to, as defined by the guacamole-ext API.
 *     The underlying model object used to represent InternalType in the
public abstract class DirectoryObjectService<InternalType extends DirectoryObject<ModelType>,
        ExternalType, ModelType> {
    protected abstract InternalType getObjectInstance(AuthenticatedUser currentUser,
     * Returns an instance of a model object which is based on the given
     * object.
     *
     * @param currentUser
     *     The user for whom this model object is being created.
     *
     * @param object 
     *     The object to use to produce the returned model object.
     *
     * @return
     *     A model object which is based on the given object.
     */
    protected abstract ModelType getModelInstance(AuthenticatedUser currentUser,
            ExternalType object);

    /**
    protected Collection<InternalType> getObjectInstances(AuthenticatedUser currentUser,
        Collection<InternalType> objects = new ArrayList<InternalType>(models.size());
    public InternalType retrieveObject(AuthenticatedUser user,
        Collection<InternalType> objects = retrieveObjects(user, Collections.singleton(identifier));
    public Collection<InternalType> retrieveObjects(AuthenticatedUser user,
    public void createObject(AuthenticatedUser user, ExternalType object)
            getObjectMapper().insert(getModelInstance(user, object));
    public void updateObject(AuthenticatedUser user, InternalType object)
        SystemPermissionModel model = new SystemPermissionModel();
        // Populate model object with data from user and permission
        model.setUserID(targetUser.getModel().getUserID());
        model.setUsername(targetUser.getModel().getUsername());
        model.setType(permission.getType());
        return model;
                || user.getUser().isAdministrator()) {

            // Read permission from database, return null if not found
            SystemPermissionModel model = getPermissionMapper().selectOne(targetUser.getModel(), type);
            if (model == null)
                return null;

            return getPermissionInstance(model);

        }
import org.glyptodon.guacamole.net.auth.User;
public class UserService extends DirectoryObjectService<MySQLUser, User, UserModel> {
    protected UserModel getModelInstance(AuthenticatedUser currentUser,
            final User object) {

        // Create new MySQLUser backed by blank model
        UserModel model = new UserModel();
        MySQLUser user = getObjectInstance(currentUser, model);

        // Set model contents through MySQLUser, copying the provided user
        user.setIdentifier(object.getIdentifier());
        user.setPassword(object.getPassword());

        return model;
        
    }

    @Override
            // FIXME: Insert implicit object permissions, too.
     * Returns whether the given object is valid and can be created as-is. The
     * object does not yet exist in the database, but the user desires to
     * create a new object with the given values. This function will be called
     * prior to any creation operation, and provides a means for the
     * implementation to abort prior to completion. The default implementation
     * does nothing.
     *
     * @param user
     *     The user creating the object.
     *
     * @param object
     *     The object to validate.
     *
     * @throws GuacamoleException
     *     If the object is invalid, or an error prevents validating the given
     *     object.
     */
    protected void validateNewObject(AuthenticatedUser user,
            ExternalType object) throws GuacamoleException {

        // By default, do nothing.

    }

    /**
     * Returns whether the given object is valid and can updated as-is. The
     * object already exists in the database, but the user desires to update
     * the object to the given values. This function will be called prior to
     * update operation, and provides a means for the implementation to abort
     * prior to completion. The default implementation does nothing.
     *
     * @param user
     *     The user updating the existing object.
     *
     * @param object 
     *     The object to validate.
     *
     * @throws GuacamoleException
     *     If the object is invalid, or an error prevents validating the given
     *     object.
     */
    protected void validateExistingObject(AuthenticatedUser user,
            InternalType object) throws GuacamoleException {

        // By default, do nothing.

    }

    /**

            // Validate object prior to creation
            validateNewObject(user, object);

            // Create object


            // Validate object prior to creation
            validateExistingObject(user, object);

            // Update object
import java.util.Collection;
import java.util.Collections;
import org.glyptodon.guacamole.GuacamoleClientException;
    @Override
    protected void validateNewObject(AuthenticatedUser user, User object)
            throws GuacamoleException {

        // Username must not be blank
        if (object.getIdentifier().trim().isEmpty())
            throw new GuacamoleClientException("The username must not be blank.");
        
        // Do not create duplicate users
        Collection<UserModel> existing = userMapper.select(Collections.singleton(object.getIdentifier()));
        if (!existing.isEmpty())
            throw new GuacamoleClientException("User \""  object.getIdentifier()  "\" already exists.");

    }

    @Override
    protected void validateExistingObject(AuthenticatedUser user,
            MySQLUser object) throws GuacamoleException {

        // Username must not be blank
        if (object.getIdentifier().trim().isEmpty())
            throw new GuacamoleClientException("The username must not be blank.");
        
        // Check whether such a user is already present
        MySQLUser existing = retrieveObject(user, object.getIdentifier());
        if (existing != null) {

            UserModel existingModel = existing.getModel();
            UserModel updatedModel = object.getModel();

            // Do not rename to existing user
            if (!existingModel.getUserID().equals(updatedModel.getUserID()))
                throw new GuacamoleClientException("User \""  object.getIdentifier()  "\" already exists.");
            
        }
        
    }

import org.glyptodon.guacamole.net.auth.Connection;
    public Directory<Connection> getConnectionDirectory() throws GuacamoleException {
        /* STUB */
        return new SimpleConnectionDirectory(Collections.EMPTY_LIST);
    }

    @Override
    public Directory<ConnectionGroup> getConnectionGroupDirectory() throws GuacamoleException {
        /* STUB */
        return new SimpleConnectionGroupDirectory(Collections.EMPTY_LIST);
    }

    @Override
        return new SimpleConnectionGroup(
            MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER, 
            MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER, 
            Collections.EMPTY_LIST,
            Collections.EMPTY_LIST
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionMapper;
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
                    addMapperClass(ConnectionMapper.class);
                    bind(ConnectionDirectory.class);
                    bind(ConnectionService.class);
                    bind(MySQLConnection.class);
 
    /**
     * Connection directory restricted by the permissions of the user
     * associated with this context.
     */
    @Inject
    private ConnectionDirectory connectionDirectory;


        connectionDirectory.init(currentUser);

        return connectionDirectory;
        return new SimpleConnectionGroupDirectory(Collections.singleton(getRootConnectionGroup()));
                    bind(MySQLRootConnectionGroup.class);
import com.google.inject.Provider;

    /**
     * Provider for creating the root group.
     */
    @Inject
    private Provider<MySQLRootConnectionGroup> rootGroupProvider;

        // Init directories

        // Build and return a root group for the current user
        MySQLRootConnectionGroup rootGroup = rootGroupProvider.get();
        rootGroup.init(currentUser);
        return rootGroup;

import java.util.Set;
    /**
     * Returns the set of all identifiers for all connections within the root
     * connection group that the user has read access to.
     *
     * @param user
     *     The user retrieving the identifiers.
     *
     * @return
     *     The set of all identifiers for all connections in the root
     *     connection group that the user has read access to.
     *
     * @throws GuacamoleException
     *     If an error occurs while reading identifiers.
     */
    public Set<String> getRootIdentifiers(AuthenticatedUser user) throws GuacamoleException {

        // Bypass permission checks if the user is a system admin
        if (user.getUser().isAdministrator())
            return connectionMapper.selectIdentifiersWithin(null);

        // Otherwise only return explicitly readable identifiers
        else
            return connectionMapper.selectReadableIdentifiersWithin(user.getUser().getModel(), null);

    }


        // Translate null parent to proper identifier
        String parentIdentifier = connectionModel.getParentIdentifier();
        if (parentIdentifier == null)
            return MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER;

        return parentIdentifier;
        

        // Translate root identifier back into null
        if (parentIdentifier != null
                && parentIdentifier.equals(MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER))
            parentIdentifier = null;


import com.google.inject.Inject;
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionService;
     * Service for managing connections.
     */
    @Inject
    private ConnectionService connectionService;
    
    /**
        return connectionService.connect(currentUser, this, info);
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.protocol.GuacamoleClientInformation;
    /**
     * Connects to the given connection as the given user, using the given
     * client information. If the user does not have permission to read the
     * connection, permission will be denied.
     *
     * @param user
     *     The user connecting to the connection.
     *
     * @param connection
     *     The connection being connected to.
     *
     * @param info
     *     Information associated with the connecting client.
     *
     * @return
     *     A connected GuacamoleSocket associated with a newly-established
     *     connection.
     *
     * @throws GuacamoleException
     *     If permission to connect to this connection is denied.
     */
    public GuacamoleSocket connect(AuthenticatedUser user,
            MySQLConnection connection, GuacamoleClientInformation info)
            throws GuacamoleException {

        // Connect only if READ permission is granted
        if (hasObjectPermission(user, connection.getIdentifier(), ObjectPermission.Type.READ)) {
            // STUB
            throw new GuacamoleUnsupportedException("STUB - connecting not implemented at the moment");
        }

        // The user does not have permission to connect
        throw new GuacamoleSecurityException("Permission denied.");

    }
    
     * Returns whether the given user has permission to perform a certain
     * action on a specific object managed by this directory object service.
     *
     * @param user
     *     The user being checked.
     *
     * @param identifier
     *     The identifier of the object to check.
     *
     * @param type
     *     The type of action that will be performed.
     *
     * @return
     *     true if the user has object permission relevant described, false
     *     otherwise.
     * 
     * @throws GuacamoleException
     *     If permission to read the user's permissions is denied.
     */
    protected boolean hasObjectPermission(AuthenticatedUser user,
            String identifier, ObjectPermission.Type type)
            throws GuacamoleException {

        // Get object permissions
        ObjectPermissionSet permissionSet = getPermissionSet(user);
        
        // Return whether permission is granted
        return user.getUser().isAdministrator()
            || permissionSet.hasPermission(type, identifier);

    }
 
    /**
        if (hasObjectPermission(user, identifier, ObjectPermission.Type.DELETE)) {
        if (hasObjectPermission(user, object.getIdentifier(), ObjectPermission.Type.UPDATE)) {
import net.sourceforge.guacamole.net.auth.mysql.dao.ParameterMapper;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
        // Get local environment
        final Environment environment = new LocalEnvironment();
        
        myBatisProperties.setProperty("JDBC.host", environment.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_HOSTNAME));
        myBatisProperties.setProperty("JDBC.port", String.valueOf(environment.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_PORT)));
        myBatisProperties.setProperty("JDBC.schema", environment.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_DATABASE));
        myBatisProperties.setProperty("JDBC.username", environment.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_USERNAME));
        myBatisProperties.setProperty("JDBC.password", environment.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_PASSWORD));
                    addMapperClass(ParameterMapper.class);
                    // Bind core implementations of guacamole-ext classes
                    bind(Environment.class).toInstance(environment);
                    bind(UserDirectory.class);

                    // Bind services
                    bind(ConnectionService.class);
import java.util.Collection;
import net.sourceforge.guacamole.net.auth.mysql.dao.ParameterMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ParameterModel;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.net.InetGuacamoleSocket;
import org.glyptodon.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.glyptodon.guacamole.protocol.GuacamoleConfiguration;
     * The environment of the Guacamole server.
     */
    @Inject
    private Environment environment;
    
    /**
     * Mapper for accessing connection parameters.
     */
    @Inject
    private ParameterMapper parameterMapper;

    /**
        String identifier = connection.getIdentifier();
        
        if (hasObjectPermission(user, identifier, ObjectPermission.Type.READ)) {

            // Generate configuration from available data
            GuacamoleConfiguration config = new GuacamoleConfiguration();

            // Set protocol from connection
            ConnectionModel model = connection.getModel();
            config.setProtocol(model.getProtocol());

            // Set parameters from associated data
            Collection<ParameterModel> parameters = parameterMapper.select(identifier);
            for (ParameterModel parameter : parameters)
                config.setParameter(parameter.getName(), parameter.getValue());

            // Return new socket
            return new ConfiguredGuacamoleSocket(
                new InetGuacamoleSocket(
                    environment.getRequiredProperty(Environment.GUACD_HOSTNAME),
                    environment.getRequiredProperty(Environment.GUACD_PORT)
                ),
                config
            );

                    bind(MySQLGuacamoleConfiguration.class);
import com.google.inject.Provider;

    /**
     * Provider for lazy-loaded, permission-controlled configurations.
     */
    @Inject
    private Provider<MySQLGuacamoleConfiguration> configProvider;
    
    /**
     * The manually-set GuacamoleConfiguration, if any.
     */
    private GuacamoleConfiguration config = null;
    public void setModel(ConnectionModel connectionModel) {
        this.connectionModel = connectionModel;
        this.config = null;
        // If configuration has been manually set, return that
        if (config != null)
            return config;
        // Otherwise, return permission-controlled configuration
        MySQLGuacamoleConfiguration restrictedConfig = configProvider.get();
        restrictedConfig.init(currentUser, connectionModel);
        return restrictedConfig;
        // Store manually-set configuration internally
        this.config = config;
        // Update model
import java.util.HashMap;
import java.util.Map;
     * Retrieves all parameters visible to the given user and associated with
     * the connection having the given identifier. If the given user has no
     * access to such parameters, or no such connection exists, the returned
     * map will be empty.
     *
     * @param user
     *     The user retrieving connection parameters.
     *
     * @param identifier
     *     The identifier of the connection whose parameters are being
     *     retrieved.
     *
     * @return
     *     A new map of all parameter name/value pairs that the given user has
     *     access to.
     */
    public Map<String, String> retrieveParameters(AuthenticatedUser user,
            String identifier) {

        // FIXME: Check permissions
        
        Map<String, String> parameterMap = new HashMap<String, String>();

        // Convert associated parameters to map
        Collection<ParameterModel> parameters = parameterMapper.select(identifier);
        for (ParameterModel parameter : parameters)
            parameterMap.put(parameter.getName(), parameter.getValue());

        return parameterMap;

    }
    
    /**
import java.util.Collections;
        // Determine whether we have permission to read parameters
        boolean canRetrieveParameters;
        try {
            canRetrieveParameters = hasObjectPermission(user, identifier,
                    ObjectPermission.Type.UPDATE);
        }

        // Provide empty (but mutable) map if unable to check permissions
        catch (GuacamoleException e) {
            return parameterMap;
        }

        // Populate parameter map if we have permission to do so
        if (canRetrieveParameters) {
            for (ParameterModel parameter : parameterMapper.select(identifier))
                parameterMap.put(parameter.getName(), parameter.getValue());
        }
            return MySQLRootConnectionGroup.IDENTIFIER;
                && parentIdentifier.equals(MySQLRootConnectionGroup.IDENTIFIER))
     * The identifier used to represent the root connection group. There is no
     * corresponding entry in the database, thus a reserved identifier that
     * cannot collide with database-generated identifiers is needed.
     */
    public static final String IDENTIFIER = "ROOT";

    /**
     * The human-readable name of this connection group. The name of the root
     * group is not normally visible, and may even be replaced by the web
     * interface for the sake of translation.
     */
    public static final String NAME = "ROOT";

    /**
        return NAME;
        return IDENTIFIER;
import net.sourceforge.guacamole.net.auth.mysql.service.GuacamoleSocketService;
import net.sourceforge.guacamole.net.auth.mysql.service.UnrestrictedGuacamoleSocketService;
                    // Bind appropriate socket service based on policy
                    bind(GuacamoleSocketService.class).to(UnrestrictedGuacamoleSocketService.class);
                    
import net.sourceforge.guacamole.net.auth.mysql.service.GuacamoleSocketService;
     * Service for creating and tracking sockets.
     */
    @Inject
    private GuacamoleSocketService socketService;

    /**
        return socketService.getActiveConnections(this);
    /**
     * Service for creating and tracking sockets.
     */
    @Inject
    private GuacamoleSocketService socketService;
    
        if (hasObjectPermission(user, connection.getIdentifier(), ObjectPermission.Type.READ))
            return socketService.getGuacamoleSocket(user, connection, info);
    /**
     * Inserts each of the parameter model objects in the given collection as
     * new connection parameters.
     *
     * @param parameters
     *     The connection parameters to insert.
     *
     * @return
     *     The number of rows inserted.
     */
    int insert(@Param("parameters") Collection<ParameterModel> parameters);

    /**
     * Deletes all parameters associated with the connection having the given
     * identifier.
     *
     * @param identifier
     *     The identifier of the connection whose parameters should be
     *     deleted.
     *
     * @return
     *     The number of rows deleted.
     */
    int delete(@Param("identifier") String identifier);
    
import java.util.ArrayList;
import java.util.Collection;
    @Override
    public void updateObject(AuthenticatedUser user, MySQLConnection object)
            throws GuacamoleException {

        // Update connection
        super.updateObject(user, object);

        // Get identifier and connection parameters
        String identifier = object.getIdentifier();
        Map<String, String> parameters = object.getConfiguration().getParameters();
        
        // Convert parameters to model objects
        Collection<ParameterModel> parameterModels = new ArrayList(parameters.size());
        for (Map.Entry<String, String> parameterEntry : parameters.entrySet()) {

            // Get parameter name and value
            String name = parameterEntry.getKey();
            String value = parameterEntry.getValue();

            // There is no need to insert empty parameters
            if (value.isEmpty())
                continue;
            
            // Produce model object from parameter
            ParameterModel model = new ParameterModel();
            model.setConnectionIdentifier(identifier);
            model.setName(name);
            model.setValue(value);

            // Add model to list
            parameterModels.add(model);
            
        }

        // Replace existing parameters with new parameters
        parameterMapper.delete(identifier);
        parameterMapper.insert(parameterModels);
        
    }

import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionRecordMapper;
                    addMapperClass(ConnectionRecordMapper.class);
        return connectionService.retrieveHistory(currentUser, this.getIdentifier());
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionRecordModel;
 * @author Michael Jumper
     * The model object backing this connection record.
    private ConnectionRecordModel model;
     * Creates a new MySQLConnectionRecord backed by the given model object.
     * Changes to this record will affect the backing model object, and changes
     * to the backing model object will affect this record.
     * 
     * @param model
     *     The model object to use to back this connection record.
    public MySQLConnectionRecord(ConnectionRecordModel model) {
        this.model = model;
        return model.getStartDate();
        return model.getEndDate();
        return model.getUsername();
        return false;
import java.util.List;
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnectionRecord;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionRecordMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionRecordModel;
     * Mapper for accessing connection history.
     */
    @Inject
    private ConnectionRecordMapper connectionRecordMapper;

    /**

    /**
     * Retrieves the connection history of the connection with the given
     * identifier.
     *
     * @param user
     *     The user retrieving the connection history.
     *
     * @param identifier
     *     The identifier of the connection whose history is being retrieved.
     *
     * @return
     * @throws GuacamoleException 
     */
    public List<MySQLConnectionRecord> retrieveHistory(AuthenticatedUser user,
            String identifier) throws GuacamoleException {

        // Retrieve history only if READ permission is granted
        if (hasObjectPermission(user, identifier, ObjectPermission.Type.READ)) {

            // Retrieve history
            List<ConnectionRecordModel> models = connectionRecordMapper.select(identifier);

            // Convert model objects into standard records
            List<MySQLConnectionRecord> records = new ArrayList<MySQLConnectionRecord>(models.size());
            for (ConnectionRecordModel model : models)
                records.add(new MySQLConnectionRecord(model));

            // Return converted history list
            return records;
            
        }
        
        // The user does not have permission to read the history
        throw new GuacamoleSecurityException("Permission denied.");

    }
        return connectionService.retrieveHistory(currentUser, this);
        return socketService.getActiveConnections(this).size();
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionRecordMapper;
import net.sourceforge.guacamole.net.auth.mysql.model.ConnectionRecordModel;
import net.sourceforge.guacamole.net.auth.mysql.model.UserModel;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
     * Mapper for accessing connection history.
     */
    @Inject
    private ConnectionRecordMapper connectionRecordMapper;

    /**
    private final Map<String, LinkedList<ConnectionRecord>> activeConnections =
            new HashMap<String, LinkedList<ConnectionRecord>>();
    private void addActiveConnection(Connection connection, ConnectionRecord record) {
        synchronized (activeConnections) {
            String identifier = connection.getIdentifier();
            // Get set of active connection records, creating if necessary
            LinkedList<ConnectionRecord> connections = activeConnections.get(identifier);
            if (connections == null) {
                connections = new LinkedList<ConnectionRecord>();
                activeConnections.put(identifier, connections);
            }

            // Add active connection
            connections.addFirst(record);

        }
    private void removeActiveConnection(Connection connection, ConnectionRecord record) {
        synchronized (activeConnections) {
            String identifier = connection.getIdentifier();

            // Get set of active connection records
            LinkedList<ConnectionRecord> connections = activeConnections.get(identifier);
            assert(connections != null);

            // Remove old record
            connections.remove(record);

            // If now empty, clean the tracking entry
            if (connections.isEmpty())
                activeConnections.remove(identifier);

        // Create record for active connection
        final ActiveConnectionRecord activeConnection = new ActiveConnectionRecord(user);
        
            addActiveConnection(connection, activeConnection);
                    removeActiveConnection(connection, activeConnection);
                    UserModel userModel = user.getUser().getModel();
                    ConnectionRecordModel recordModel = new ConnectionRecordModel();

                    // Copy user information and timestamps into new record
                    recordModel.setUserID(userModel.getUserID());
                    recordModel.setUsername(userModel.getUsername());
                    recordModel.setConnectionIdentifier(connection.getIdentifier());
                    recordModel.setStartDate(activeConnection.getStartDate());
                    recordModel.setEndDate(new Date());

                    // Insert connection record
                    connectionRecordMapper.insert(recordModel);
                    
            removeActiveConnection(connection, activeConnection);
    public List<ConnectionRecord> getActiveConnections(Connection connection) {
        synchronized (activeConnections) {
            String identifier = connection.getIdentifier();
            // Get set of active connection records
            LinkedList<ConnectionRecord> connections = activeConnections.get(identifier);
            if (connections != null)
                return Collections.unmodifiableList(connections);

            return Collections.EMPTY_LIST;

        }
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
     * Retrieves the connection history of the given connection, including any
     * active connections.
     * @param connection
     *     The connection whose history is being retrieved.
     *     The connection history of the given connection, including any
     *     active connections.
     *
     * @throws GuacamoleException
     *     If permission to read the connection history is denied.
    public List<ConnectionRecord> retrieveHistory(AuthenticatedUser user,
            MySQLConnection connection) throws GuacamoleException {
        String identifier = connection.getIdentifier();
        
            // Get currently-active connections
            List<ConnectionRecord> records = new ArrayList<ConnectionRecord>(socketService.getActiveConnections(connection));

            // Add past connections from model objects
import java.util.List;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
     * Returns a list containing connection records representing all currently-
     * active connections using the given connection. These records will have
     * usernames and start dates, but no end date.
     *     A list containing connection records representing all currently-
     *     active connections.
    public List<ConnectionRecord> getActiveConnections(Connection connection);

import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
        // Build token filter containing credential tokens
        TokenFilter tokenFilter = new TokenFilter();
        StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());

        // Filter the configuration
        tokenFilter.filterValues(config.getParameters());

import net.sourceforge.guacamole.net.auth.mysql.model.ObjectModel;
 * Common base class for objects that will ultimately be made available through
 *     The type of model object that corresponds to this object.
public abstract class DirectoryObject<ModelType extends ObjectModel>
    extends RestrictedObject<ModelType> implements Identifiable {
    @Override
    public String getIdentifier() {
        return getModel().getIdentifier();
    }
    @Override
    public void setIdentifier(String identifier) {
        getModel().setIdentifier(identifier);
    }
}
public class MySQLConnection extends DirectoryObject<ConnectionModel>
    implements Connection {
        return getModel().getName();
        getModel().setName(name);
        String parentIdentifier = getModel().getParentIdentifier();
        getModel().setParentIdentifier(parentIdentifier);
        restrictedConfig.init(getCurrentUser(), getModel());
        getModel().setProtocol(config.getProtocol());
        return connectionService.retrieveHistory(getCurrentUser(), this);
        return connectionService.connect(getCurrentUser(), this, info);
public class MySQLUser extends DirectoryObject<UserModel> implements User {
        UserModel userModel = getModel();
        
public class ConnectionModel extends ObjectModel {
    public void setParentIdentifier(String parentIdentifier) {
    @Override

        // If no associated ID, then no associated identifier
        Integer id = getObjectID();
        if (id == null)
            return null;

        // Otherwise, the identifier is the ID as a string
        return id.toString();

    @Override
        throw new UnsupportedOperationException("Connection identifiers are derived from IDs. They cannot be set.");
public class UserModel extends ObjectModel {
                    recordModel.setUserID(userModel.getObjectID());
                    recordModel.setUsername(userModel.getIdentifier());
        if (object.getName().trim().isEmpty())
        if (object.getName().trim().isEmpty())
import net.sourceforge.guacamole.net.auth.mysql.model.ObjectModel;
        ExternalType, ModelType extends ObjectModel> {
        model.setUserID(targetUser.getModel().getObjectID());
        model.setUsername(targetUser.getModel().getIdentifier());
            if (!existingModel.getObjectID().equals(updatedModel.getObjectID()))
    /**
     * Given an arbitrary Guacamole connection, produces a collection of
     * parameter model objects containing the name/value pairs of that
     * connection's parameters.
     *
     * @param connection
     *     The connection whose configuration should be used to produce the
     *     collection of parameter models.
     *
     * @return
     *     A collection of parameter models containing the name/value pairs
     *     of the given connection's parameters.
     */
    private Collection<ParameterModel> getParameterModels(MySQLConnection connection) {
        Map<String, String> parameters = connection.getConfiguration().getParameters();
            model.setConnectionIdentifier(connection.getIdentifier());
        return parameterModels;

    }

    @Override
    public MySQLConnection createObject(AuthenticatedUser user, Connection object)
            throws GuacamoleException {

        // Create connection
        MySQLConnection connection = super.createObject(user, object);
        connection.setConfiguration(object.getConfiguration());

        // Insert new parameters, if any
        Collection<ParameterModel> parameterModels = getParameterModels(connection);
        if (!parameterModels.isEmpty())
            parameterMapper.insert(parameterModels);

        return connection;

    }
    
    @Override
    public void updateObject(AuthenticatedUser user, MySQLConnection object)
            throws GuacamoleException {

        // Update connection
        super.updateObject(user, object);

        Collection<ParameterModel> parameterModels = getParameterModels(object);
        parameterMapper.delete(object.getIdentifier());
     * @return
     *     The newly-created object.
     *
    public InternalType createObject(AuthenticatedUser user, ExternalType object)
            ModelType model = getModelInstance(user, object);
            getObjectMapper().insert(model);
            return getObjectInstance(user, model);
import net.sourceforge.guacamole.net.auth.mysql.dao.ConnectionGroupMapper;
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionGroupService;
                    addMapperClass(ConnectionGroupMapper.class);
                    bind(ConnectionGroupDirectory.class);
                    bind(MySQLConnectionGroup.class);
                    bind(ConnectionGroupService.class);
import net.sourceforge.guacamole.net.auth.mysql.service.ConnectionGroupService;

    /**
     * Service for managing connection group objects.
     */
    @Inject
    private ConnectionGroupService connectionGroupService;
        return connectionService.getIdentifiersWithin(currentUser, null);
        return connectionGroupService.getIdentifiersWithin(currentUser, null);
     * Connection group directory restricted by the permissions of the user
     * associated with this context.
     */
    @Inject
    private ConnectionGroupDirectory connectionGroupDirectory;

    /**
        connectionGroupDirectory.init(currentUser);
        return connectionGroupDirectory;
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnectionGroup;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;

    @Override
    public GuacamoleSocket getGuacamoleSocket(AuthenticatedUser user,
            MySQLConnectionGroup connectionGroup,
            GuacamoleClientInformation info) throws GuacamoleException {
        // STUB
        throw new UnsupportedOperationException("STUB");
    }

    @Override
    public List<ConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup) {
        // STUB
        return Collections.EMPTY_LIST;
    }
     * Returns the set of all identifiers for all connections within the
     * connection group having the given identifier. Only connections that the
     * user has read access to will be returned.
     * 
     * Permission to read the connection group having the given identifier is
     * NOT checked.
     * 
     * @param identifier
     *     The identifier of the parent connection group, or null to check the
     *     root connection group.
     *     The set of all identifiers for all connections in the connection
     *     group having the given identifier that the user has read access to.
    public Set<String> getIdentifiersWithin(AuthenticatedUser user,
            String identifier)
            throws GuacamoleException {
            return connectionMapper.selectIdentifiersWithin(identifier);
            return connectionMapper.selectReadableIdentifiersWithin(user.getUser().getModel(), identifier);
import net.sourceforge.guacamole.net.auth.mysql.MySQLConnectionGroup;
import org.glyptodon.guacamole.net.auth.ConnectionGroup;
    /**
     * Creates a socket for the given user which connects to the given
     * connection group. The given client information will be passed to guacd
     * when the connection is established. This function will apply any
     * concurrent usage rules in effect, but will NOT test object- or
     * system-level permissions.
     *
     * @param user
     *     The user for whom the connection is being established.
     *
     * @param connectionGroup
     *     The connection group the user is connecting to.
     *
     * @param info
     *     Information describing the Guacamole client connecting to the given
     *     connection group.
     *
     * @return
     *     A new GuacamoleSocket which is configured and connected to the given
     *     connection group.
     *
     * @throws GuacamoleException
     *     If the connection cannot be established due to concurrent usage
     *     rules, or if the connection group is not balancing.
     */
    GuacamoleSocket getGuacamoleSocket(AuthenticatedUser user,
            MySQLConnectionGroup connectionGroup,
            GuacamoleClientInformation info)
            throws GuacamoleException;

    /**
     * Returns a list containing connection records representing all currently-
     * active connections using the given connection group. These records will
     * have usernames and start dates, but no end date.
     *
     * @param connectionGroup
     *     The connection group to check.
     *
     * @return
     *     A list containing connection records representing all currently-
     *     active connections.
     */
    public List<ConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup);

     * The user this connection directory belongs to. Access is based on
     * his/her permission settings.
        // Return whether user has explicit connection creation permission
import org.glyptodon.guacamole.auth.mysql.user.MySQLUserContext;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.MySQLRootConnectionGroup;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.MySQLConnectionGroup;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.ConnectionGroupDirectory;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionDirectory;
import org.glyptodon.guacamole.auth.mysql.connection.MySQLGuacamoleConfiguration;
import org.glyptodon.guacamole.auth.mysql.connection.MySQLConnection;
import org.glyptodon.guacamole.auth.mysql.permission.MySQLSystemPermissionSet;
import org.glyptodon.guacamole.auth.mysql.user.MySQLUser;
import org.glyptodon.guacamole.auth.mysql.user.UserDirectory;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.ConnectionGroupMapper;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionMapper;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionRecordMapper;
import org.glyptodon.guacamole.auth.mysql.connection.ParameterMapper;
import org.glyptodon.guacamole.auth.mysql.permission.SystemPermissionMapper;
import org.glyptodon.guacamole.auth.mysql.user.UserMapper;
import org.glyptodon.guacamole.auth.mysql.conf.MySQLGuacamoleProperties;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.ConnectionGroupService;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionService;
import org.glyptodon.guacamole.auth.mysql.socket.GuacamoleSocketService;
import org.glyptodon.guacamole.auth.mysql.security.PasswordEncryptionService;
import org.glyptodon.guacamole.auth.mysql.security.SHA256PasswordEncryptionService;
import org.glyptodon.guacamole.auth.mysql.security.SaltService;
import org.glyptodon.guacamole.auth.mysql.security.SecureRandomSaltService;
import org.glyptodon.guacamole.auth.mysql.permission.SystemPermissionService;
import org.glyptodon.guacamole.auth.mysql.socket.UnrestrictedGuacamoleSocketService;
import org.glyptodon.guacamole.auth.mysql.user.UserService;
 * The MySQL authentication provider. This package exists purely for backwards-
 * compatibility. All other classes have been moved to packages within
 * org.glyptodon.guacamole.auth.mysql.
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/base/DirectoryObject.java
package org.glyptodon.guacamole.auth.mysql.base;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/base/DirectoryObjectMapper.java
package org.glyptodon.guacamole.auth.mysql.base;
import org.glyptodon.guacamole.auth.mysql.user.UserModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/base/DirectoryObjectService.java
package org.glyptodon.guacamole.auth.mysql.base;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/base/ObjectModel.java
package org.glyptodon.guacamole.auth.mysql.base;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/base/RestrictedObject.java
package org.glyptodon.guacamole.auth.mysql.base;

import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/base/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Base classes supporting the MySQL authentication provider and defining the
 * relationships between the model and the implementations of guacamole-ext
 * classes.
package org.glyptodon.guacamole.auth.mysql.base;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/conf/MySQLGuacamoleProperties.java
package org.glyptodon.guacamole.auth.mysql.conf;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/conf/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to the configuration of the MySQL authentication provider.
package org.glyptodon.guacamole.auth.mysql.conf;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connection/ConnectionDirectory.java
package org.glyptodon.guacamole.auth.mysql.connection;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connection/ConnectionMapper.java
package org.glyptodon.guacamole.auth.mysql.connection;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.mysql.user.UserModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connection/ConnectionModel.java
package org.glyptodon.guacamole.auth.mysql.connection;

import org.glyptodon.guacamole.auth.mysql.base.ObjectModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connection/ConnectionRecordMapper.java
package org.glyptodon.guacamole.auth.mysql.connection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connection/ConnectionRecordModel.java
package org.glyptodon.guacamole.auth.mysql.connection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connection/ConnectionService.java
package org.glyptodon.guacamole.auth.mysql.connection;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectService;
import org.glyptodon.guacamole.auth.mysql.socket.GuacamoleSocketService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connection/MySQLConnection.java
package org.glyptodon.guacamole.auth.mysql.connection;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObject;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.MySQLRootConnectionGroup;
import org.glyptodon.guacamole.auth.mysql.socket.GuacamoleSocketService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connection/MySQLConnectionRecord.java
package org.glyptodon.guacamole.auth.mysql.connection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connection/MySQLGuacamoleConfiguration.java
package org.glyptodon.guacamole.auth.mysql.connection;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connection/ParameterMapper.java
package org.glyptodon.guacamole.auth.mysql.connection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connection/ParameterModel.java
package org.glyptodon.guacamole.auth.mysql.connection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connection/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to connections and their parameters and history.
package org.glyptodon.guacamole.auth.mysql.connection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connectiongroup/ConnectionGroupDirectory.java
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connectiongroup/ConnectionGroupMapper.java
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.mysql.user.UserModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connectiongroup/ConnectionGroupModel.java
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
import org.glyptodon.guacamole.auth.mysql.base.ObjectModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connectiongroup/ConnectionGroupService.java
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectService;
import org.glyptodon.guacamole.auth.mysql.socket.GuacamoleSocketService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connectiongroup/MySQLConnectionGroup.java
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObject;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionService;
import org.glyptodon.guacamole.auth.mysql.socket.GuacamoleSocketService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connectiongroup/MySQLRootConnectionGroup.java
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/connectiongroup/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to connection groups.
package org.glyptodon.guacamole.auth.mysql.connectiongroup;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/permission/MySQLSystemPermissionSet.java
package org.glyptodon.guacamole.auth.mysql.permission;
import org.glyptodon.guacamole.auth.mysql.user.MySQLUser;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/permission/ObjectPermissionMapper.java
package org.glyptodon.guacamole.auth.mysql.permission;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/permission/ObjectPermissionModel.java
package org.glyptodon.guacamole.auth.mysql.permission;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/permission/ObjectPermissionService.java
package org.glyptodon.guacamole.auth.mysql.permission;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.user.MySQLUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/permission/PermissionMapper.java
package org.glyptodon.guacamole.auth.mysql.permission;
import org.glyptodon.guacamole.auth.mysql.user.UserModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/permission/PermissionModel.java
package org.glyptodon.guacamole.auth.mysql.permission;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/permission/PermissionService.java
package org.glyptodon.guacamole.auth.mysql.permission;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.user.MySQLUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/permission/SystemPermissionMapper.java
package org.glyptodon.guacamole.auth.mysql.permission;
import org.glyptodon.guacamole.auth.mysql.user.UserModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/permission/SystemPermissionModel.java
package org.glyptodon.guacamole.auth.mysql.permission;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/permission/SystemPermissionService.java
package org.glyptodon.guacamole.auth.mysql.permission;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.user.MySQLUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/permission/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to object- and system-level permissions.
package org.glyptodon.guacamole.auth.mysql.permission;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/security/PasswordEncryptionService.java
package org.glyptodon.guacamole.auth.mysql.security;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/security/SHA256PasswordEncryptionService.java
package org.glyptodon.guacamole.auth.mysql.security;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/security/SaltService.java
package org.glyptodon.guacamole.auth.mysql.security;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/security/SecureRandomSaltService.java
package org.glyptodon.guacamole.auth.mysql.security;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/security/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to hashing or encryption.
package org.glyptodon.guacamole.auth.mysql.security;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/socket/AbstractGuacamoleSocketService.java
package org.glyptodon.guacamole.auth.mysql.socket;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.connection.MySQLConnection;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.MySQLConnectionGroup;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionRecordMapper;
import org.glyptodon.guacamole.auth.mysql.connection.ParameterMapper;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionModel;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionRecordModel;
import org.glyptodon.guacamole.auth.mysql.connection.ParameterModel;
import org.glyptodon.guacamole.auth.mysql.user.UserModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/socket/ActiveConnectionRecord.java
package org.glyptodon.guacamole.auth.mysql.socket;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/socket/GuacamoleSocketService.java
package org.glyptodon.guacamole.auth.mysql.socket;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.connection.MySQLConnection;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.MySQLConnectionGroup;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/socket/UnrestrictedGuacamoleSocketService.java
package org.glyptodon.guacamole.auth.mysql.socket;
import org.glyptodon.guacamole.auth.mysql.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.mysql.connection.MySQLConnection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/socket/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to obtaining/configuring Guacamole sockets, and restricting
 * access to those sockets.
package org.glyptodon.guacamole.auth.mysql.socket;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/user/AuthenticatedUser.java
package org.glyptodon.guacamole.auth.mysql.user;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/user/MySQLUser.java
package org.glyptodon.guacamole.auth.mysql.user;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObject;
import org.glyptodon.guacamole.auth.mysql.security.PasswordEncryptionService;
import org.glyptodon.guacamole.auth.mysql.security.SaltService;
import org.glyptodon.guacamole.auth.mysql.permission.SystemPermissionService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/user/MySQLUserContext.java
package org.glyptodon.guacamole.auth.mysql.user;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.MySQLRootConnectionGroup;
import org.glyptodon.guacamole.auth.mysql.connectiongroup.ConnectionGroupDirectory;
import org.glyptodon.guacamole.auth.mysql.connection.ConnectionDirectory;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/user/UserDirectory.java
package org.glyptodon.guacamole.auth.mysql.user;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/user/UserMapper.java
package org.glyptodon.guacamole.auth.mysql.user;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectMapper;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/user/UserModel.java
package org.glyptodon.guacamole.auth.mysql.user;

import org.glyptodon.guacamole.auth.mysql.base.ObjectModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/user/UserService.java
package org.glyptodon.guacamole.auth.mysql.user;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.mysql.base.DirectoryObjectService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/mysql/user/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to Guacamole users.
package org.glyptodon.guacamole.auth.mysql.user;
import org.glyptodon.guacamole.auth.jdbc.JDBCAuthenticationProvider;
public class MySQLAuthenticationProvider extends JDBCAuthenticationProvider {
     * @throws GuacamoleException
     *     If a required property is missing, or an error occurs while parsing
     *     a property.
    
 * compatibility.
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/DirectoryObject.java
package org.glyptodon.guacamole.auth.jdbc.base;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/DirectoryObjectMapper.java
package org.glyptodon.guacamole.auth.jdbc.base;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/DirectoryObjectService.java
package org.glyptodon.guacamole.auth.jdbc.base;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/ObjectModel.java
package org.glyptodon.guacamole.auth.jdbc.base;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/RestrictedObject.java
package org.glyptodon.guacamole.auth.jdbc.base;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/package-info.java
package org.glyptodon.guacamole.auth.jdbc.base;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/conf/MySQLGuacamoleProperties.java
package org.glyptodon.guacamole.auth.jdbc.conf;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/conf/package-info.java
package org.glyptodon.guacamole.auth.jdbc.conf;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/ConnectionDirectory.java
package org.glyptodon.guacamole.auth.jdbc.connection;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/ConnectionMapper.java
package org.glyptodon.guacamole.auth.jdbc.connection;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/ConnectionModel.java
package org.glyptodon.guacamole.auth.jdbc.connection;
import org.glyptodon.guacamole.auth.jdbc.base.ObjectModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/ConnectionRecordMapper.java
package org.glyptodon.guacamole.auth.jdbc.connection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/ConnectionRecordModel.java
package org.glyptodon.guacamole.auth.jdbc.connection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/ConnectionService.java
package org.glyptodon.guacamole.auth.jdbc.connection;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectService;
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/MySQLConnection.java
package org.glyptodon.guacamole.auth.jdbc.connection;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObject;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.MySQLRootConnectionGroup;
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/MySQLConnectionRecord.java
package org.glyptodon.guacamole.auth.jdbc.connection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/MySQLGuacamoleConfiguration.java
package org.glyptodon.guacamole.auth.jdbc.connection;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/ParameterMapper.java
package org.glyptodon.guacamole.auth.jdbc.connection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/ParameterModel.java
package org.glyptodon.guacamole.auth.jdbc.connection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/package-info.java
package org.glyptodon.guacamole.auth.jdbc.connection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connectiongroup/ConnectionGroupDirectory.java
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connectiongroup/ConnectionGroupMapper.java
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connectiongroup/ConnectionGroupModel.java
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
import org.glyptodon.guacamole.auth.jdbc.base.ObjectModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connectiongroup/ConnectionGroupService.java
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectService;
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connectiongroup/MySQLConnectionGroup.java
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObject;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionService;
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connectiongroup/MySQLRootConnectionGroup.java
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/connectiongroup/package-info.java
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/package-info.java
 * The base JDBC authentication provider. This authentication provider serves
 * as a basis for other JDBC authentication provider implementations which are
 * driven by relatively-common schemas. The only difference between such
 * implementations are maintained within database-specific MyBatis mappings.
package org.glyptodon.guacamole.auth.jdbc;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/MySQLSystemPermissionSet.java
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.auth.jdbc.user.MySQLUser;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/ObjectPermissionMapper.java
package org.glyptodon.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/ObjectPermissionModel.java
package org.glyptodon.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/ObjectPermissionService.java
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.user.MySQLUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/PermissionMapper.java
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/PermissionModel.java
package org.glyptodon.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/PermissionService.java
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.user.MySQLUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/SystemPermissionMapper.java
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/SystemPermissionModel.java
package org.glyptodon.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/SystemPermissionService.java
package org.glyptodon.guacamole.auth.jdbc.permission;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.user.MySQLUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/package-info.java
package org.glyptodon.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/security/PasswordEncryptionService.java
package org.glyptodon.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/security/SHA256PasswordEncryptionService.java
package org.glyptodon.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/security/SaltService.java
package org.glyptodon.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/security/SecureRandomSaltService.java
package org.glyptodon.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/security/package-info.java
package org.glyptodon.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/socket/AbstractGuacamoleSocketService.java
package org.glyptodon.guacamole.auth.jdbc.socket;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.connection.MySQLConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.MySQLConnectionGroup;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionRecordMapper;
import org.glyptodon.guacamole.auth.jdbc.connection.ParameterMapper;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionModel;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionRecordModel;
import org.glyptodon.guacamole.auth.jdbc.connection.ParameterModel;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/socket/ActiveConnectionRecord.java
package org.glyptodon.guacamole.auth.jdbc.socket;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/socket/GuacamoleSocketService.java
package org.glyptodon.guacamole.auth.jdbc.socket;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.connection.MySQLConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.MySQLConnectionGroup;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/socket/UnrestrictedGuacamoleSocketService.java
package org.glyptodon.guacamole.auth.jdbc.socket;
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.glyptodon.guacamole.auth.jdbc.connection.MySQLConnection;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/socket/package-info.java
package org.glyptodon.guacamole.auth.jdbc.socket;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/user/AuthenticatedUser.java
package org.glyptodon.guacamole.auth.jdbc.user;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/user/MySQLUser.java
package org.glyptodon.guacamole.auth.jdbc.user;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObject;
import org.glyptodon.guacamole.auth.jdbc.security.PasswordEncryptionService;
import org.glyptodon.guacamole.auth.jdbc.security.SaltService;
import org.glyptodon.guacamole.auth.jdbc.permission.SystemPermissionService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/user/MySQLUserContext.java
package org.glyptodon.guacamole.auth.jdbc.user;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.MySQLRootConnectionGroup;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ConnectionGroupDirectory;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionDirectory;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/user/UserDirectory.java
package org.glyptodon.guacamole.auth.jdbc.user;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/user/UserMapper.java
package org.glyptodon.guacamole.auth.jdbc.user;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectMapper;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/user/UserModel.java
package org.glyptodon.guacamole.auth.jdbc.user;
import org.glyptodon.guacamole.auth.jdbc.base.ObjectModel;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/user/UserService.java
package org.glyptodon.guacamole.auth.jdbc.user;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.DirectoryObjectService;
 b/extensions/guacamole-auth-mysql/src/main/java/org/glyptodon/guacamole/auth/jdbc/user/package-info.java
package org.glyptodon.guacamole.auth.jdbc.user;
import com.google.inject.Guice;
import com.google.inject.Injector;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.UserContext;
import org.glyptodon.guacamole.auth.jdbc.JDBCAuthenticationProviderModule;
import org.glyptodon.guacamole.auth.jdbc.user.UserContextService;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
 * @author Michael Jumper
public class MySQLAuthenticationProvider implements AuthenticationProvider {

    /**
     * Injector which will manage the object graph of this authentication
     * provider.
     */
    private final Injector injector;

        // Get local environment
        Environment environment = new LocalEnvironment();

        // Set up Guice injector.
        injector = Guice.createInjector(

            // Configure MySQL-specific authentication
            new MySQLAuthenticationProviderModule(environment),

            // Configure JDBC authentication core
            new JDBCAuthenticationProviderModule(environment)

        );


    @Override
    public UserContext getUserContext(Credentials credentials)
            throws GuacamoleException {

        // Create UserContext based on credentials, if valid
        UserContextService userContextService = injector.getInstance(UserContextService.class);
        return userContextService.getUserContext(credentials);

    }

    @Override
    public UserContext updateUserContext(UserContext context,
        Credentials credentials) throws GuacamoleException {

        // No need to update the context
        return context;

    }

 b/extensions/guacamole-auth-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/MySQLGuacamoleProperties.java
package net.sourceforge.guacamole.net.auth.mysql;
 * The MySQL authentication provider. This package exists outside of
 * org.glyptodon for backwards-compatibility.
import org.glyptodon.guacamole.auth.jdbc.user.UserContext;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.RootConnectionGroup;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledGuacamoleConfiguration;
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.permission.SystemPermissionSet;
import org.glyptodon.guacamole.auth.jdbc.user.ModeledUser;
        bind(ModeledConnection.class);
        bind(ModeledConnectionGroup.class);
        bind(ModeledGuacamoleConfiguration.class);
        bind(ModeledUser.class);
        bind(RootConnectionGroup.class);
        bind(SystemPermissionSet.class);
        bind(UserContext.class);
 * Base classes supporting JDBC-driven authentication providers and defining
 * the relationships between the model and the implementations of guacamole-ext
 * Implementation of the Connection Directory which is driven by an underlying,
 * arbitrary database.
        Collection<ModeledConnection> objects = connectionService.retrieveObjects(currentUser, identifiers);
        ModeledConnection connection = (ModeledConnection) object;
public class ConnectionService extends DirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
    private Provider<ModeledConnection> connectionProvider;
    protected ModeledConnection getObjectInstance(AuthenticatedUser currentUser,
        ModeledConnection connection = connectionProvider.get();
        // Create new ModeledConnection backed by blank model
        ModeledConnection connection = getObjectInstance(currentUser, model);
        // Set model contents through ModeledConnection, copying the provided connection
            ModeledConnection object) throws GuacamoleException {
    private Collection<ParameterModel> getParameterModels(ModeledConnection connection) {
    public ModeledConnection createObject(AuthenticatedUser user, Connection object)
        ModeledConnection connection = super.createObject(user, object);
    public void updateObject(AuthenticatedUser user, ModeledConnection object)
            ModeledConnection connection) throws GuacamoleException {
                records.add(new ModeledConnectionRecord(model));
            ModeledConnection connection, GuacamoleClientInformation info)
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/ModeledConnection.java
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.RootConnectionGroup;
 * An implementation of the Connection object which is backed by a database
 * model.
 *
 * @author Michael Jumper
public class ModeledConnection extends DirectoryObject<ConnectionModel>
    private Provider<ModeledGuacamoleConfiguration> configProvider;
     * Creates a new, empty ModeledConnection.
    public ModeledConnection() {
            return RootConnectionGroup.IDENTIFIER;
                && parentIdentifier.equals(RootConnectionGroup.IDENTIFIER))
        ModeledGuacamoleConfiguration restrictedConfig = configProvider.get();
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/ModeledConnectionRecord.java
 * A ConnectionRecord which is backed by a database model.
public class ModeledConnectionRecord implements ConnectionRecord {
    private final ConnectionRecordModel model;
     * Creates a new ModeledConnectionRecord backed by the given model object.
    public ModeledConnectionRecord(ConnectionRecordModel model) {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/ModeledGuacamoleConfiguration.java
public class ModeledGuacamoleConfiguration extends GuacamoleConfiguration {
     * Creates a new, empty ModelGuacamoleConfiguration.
    public ModeledGuacamoleConfiguration() {
 * Implementation of the ConnectionGroup Directory which is driven by an
 * underlying, arbitrary database.
        Collection<ModeledConnectionGroup> objects = connectionGroupService.retrieveObjects(currentUser, identifiers);
        ModeledConnectionGroup connectionGroup = (ModeledConnectionGroup) object;
public class ConnectionGroupService extends DirectoryObjectService<ModeledConnectionGroup,
    private Provider<ModeledConnectionGroup> connectionGroupProvider;
    protected ModeledConnectionGroup getObjectInstance(AuthenticatedUser currentUser,
        ModeledConnectionGroup connectionGroup = connectionGroupProvider.get();
        // Create new ModeledConnectionGroup backed by blank model
        ModeledConnectionGroup connectionGroup = getObjectInstance(currentUser, model);
        // Set model contents through ModeledConnectionGroup, copying the provided connection group
            ModeledConnectionGroup object) throws GuacamoleException {
            ModeledConnectionGroup connectionGroup, GuacamoleClientInformation info)
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/connectiongroup/ModeledConnectionGroup.java
 * An implementation of the ConnectionGroup object which is backed by a
 * database model.
public class ModeledConnectionGroup extends DirectoryObject<ConnectionGroupModel>
     * Creates a new, empty ModeledConnectionGroup.
    public ModeledConnectionGroup() {
            return RootConnectionGroup.IDENTIFIER;
                && parentIdentifier.equals(RootConnectionGroup.IDENTIFIER))
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/connectiongroup/RootConnectionGroup.java
public class RootConnectionGroup implements ConnectionGroup {
     * Creates a new, empty RootConnectionGroup.
    public RootConnectionGroup() {
import org.glyptodon.guacamole.auth.jdbc.user.ModeledUser;
    protected boolean canAlterPermissions(AuthenticatedUser user, ModeledUser targetUser,
    public void createPermissions(AuthenticatedUser user, ModeledUser targetUser,
    public void deletePermissions(AuthenticatedUser user, ModeledUser targetUser,
import org.glyptodon.guacamole.auth.jdbc.user.ModeledUser;
    protected abstract ModelType getModelInstance(ModeledUser targetUser,
    protected Collection<ModelType> getModelInstances(ModeledUser targetUser,
            ModeledUser targetUser) throws GuacamoleException;
            ModeledUser targetUser) throws GuacamoleException {
            ModeledUser targetUser,
            ModeledUser targetUser,
import org.glyptodon.guacamole.auth.jdbc.user.ModeledUser;
    extends PermissionService<SystemPermissionSet, SystemPermission, SystemPermissionModel> {
    private Provider<SystemPermissionSet> systemPermissionSetProvider;
    protected SystemPermissionModel getModelInstance(final ModeledUser targetUser,
    public SystemPermissionSet getPermissionSet(AuthenticatedUser user,
            ModeledUser targetUser) throws GuacamoleException {
        SystemPermissionSet permissionSet = systemPermissionSetProvider.get();
    public void createPermissions(AuthenticatedUser user, ModeledUser targetUser,
    public void deletePermissions(AuthenticatedUser user, ModeledUser targetUser,
            ModeledUser targetUser, SystemPermission.Type type) throws GuacamoleException {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/SystemPermissionSet.java
import org.glyptodon.guacamole.auth.jdbc.user.ModeledUser;
public class SystemPermissionSet
    implements org.glyptodon.guacamole.net.auth.permission.SystemPermissionSet {
    private ModeledUser user;
     * Creates a new SystemPermissionSet. The resulting permission set
    public SystemPermissionSet() {
    public void init(AuthenticatedUser currentUser, ModeledUser user) {
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
            ModeledConnection connection) throws GuacamoleException;
            ModeledConnection connection);
            final ModeledConnection connection, GuacamoleClientInformation info)
            ModeledConnectionGroup connectionGroup,
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
            ModeledConnection connection, GuacamoleClientInformation info)
            ModeledConnectionGroup connectionGroup,
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
    protected void acquire(AuthenticatedUser user, ModeledConnection connection)
    protected void release(AuthenticatedUser user, ModeledConnection connection) {
    private final ModeledUser user;
    public AuthenticatedUser(ModeledUser user, Credentials credentials) {
    public ModeledUser getUser() {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/user/ModeledUser.java
 * An implementation of the User object which is backed by a database model.
 *
 * @author Michael Jumper
public class ModeledUser extends DirectoryObject<UserModel> implements User {
     * Creates a new, empty ModeledUser.
    public ModeledUser() {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/user/UserContext.java
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.RootConnectionGroup;
 * UserContext implementation which is driven by an arbitrary, underlying
 * database.
 *
 * @author Michael Jumper
public class UserContext
    implements org.glyptodon.guacamole.net.auth.UserContext {
    private Provider<RootConnectionGroup> rootGroupProvider;
        RootConnectionGroup rootGroup = rootGroupProvider.get();
    private Provider<UserContext> userContextProvider;
    public org.glyptodon.guacamole.net.auth.UserContext
        getUserContext(Credentials credentials)
                throws GuacamoleException {
        ModeledUser user = userService.retrieveUser(credentials);
            UserContext context = userContextProvider.get();
 * Implementation of the User Directory which is driven by an underlying,
 * arbitrary database.
        Collection<ModeledUser> objects = userService.retrieveObjects(currentUser, identifiers);
        ModeledUser user = (ModeledUser) object;
public class UserService extends DirectoryObjectService<ModeledUser, User, UserModel> {
    private Provider<ModeledUser> userProvider;
    protected ModeledUser getObjectInstance(AuthenticatedUser currentUser,
        ModeledUser user = userProvider.get();
        // Create new ModeledUser backed by blank model
        ModeledUser user = getObjectInstance(currentUser, model);
        // Set model contents through ModeledUser, copying the provided user
            ModeledUser object) throws GuacamoleException {
        ModeledUser existing = retrieveObject(user, object.getIdentifier());
     * @param credentials
     *     The credentials to use when locating the user.
     *
     * @return
     *     The existing ModeledUser object if the credentials given are valid,
     *     null otherwise.
    public ModeledUser retrieveUser(Credentials credentials) {
        ModeledUser user = getObjectInstance(null, userModel);
import org.apache.ibatis.annotations.Param;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;


    /**
     * Retrieve the permission of the given type associated with the given
     * user and object, if it exists. If no such permission exists, null is
     * returned.
     *
     * @param user
     *     The user to retrieve permissions for.
     * 
     * @param type
     *     The type of permission to return.
     * 
     * @param identifier
     *     The identifier of the object affected by the permission to return.
     *
     * @return
     *     The requested permission, or null if no such permission is granted
     *     to the given user for the given object.
     */
    ObjectPermissionModel selectOne(@Param("user") UserModel user,
            @Param("type") ObjectPermission.Type type,
            @Param("identifier") String identifier);

}
public abstract class ObjectPermissionService
    extends PermissionService<ObjectPermissionSet, ObjectPermission, ObjectPermissionModel> {

    @Override
    protected abstract ObjectPermissionMapper getPermissionMapper();
            Collection<ObjectPermissionModel> models = getModelInstances(targetUser, permissions);
            Collection<ObjectPermissionModel> models = getModelInstances(targetUser, permissions);
    /**
     * Retrieves the permission of the given type associated with the given
     * user and object, if it exists. If no such permission exists, null is
     *
     * @param user
     *     The user retrieving the permission.
     *
     * @param targetUser
     *     The user associated with the permission to be retrieved.
     * 
     * @param type
     *     The type of permission to retrieve.
     *
     * @param identifier
     *     The identifier of the object affected by the permission to return.
     *
     * @return
     *     The permission of the given type associated with the given user and
     *     object, or null if no such permission exists.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the requested permission.
     */
    public ObjectPermission retrievePermission(AuthenticatedUser user,
            ModeledUser targetUser, ObjectPermission.Type type,
            String identifier) throws GuacamoleException {

        // Only an admin can read permissions that aren't his own
        if (user.getUser().getIdentifier().equals(targetUser.getIdentifier())
                || user.getUser().isAdministrator()) {

            // Read permission from database, return null if not found
            ObjectPermissionModel model = getPermissionMapper().selectOne(targetUser.getModel(), type, identifier);
            if (model == null)
                return null;

            return getPermissionInstance(model);

        }

        // User cannot read this user's permissions
        throw new GuacamoleSecurityException("Permission denied.");
        
    }

    extends ModeledObject<ModelType> implements Identifiable {
 * obtain them.
public abstract class RestrictedObject {
    public void init(AuthenticatedUser currentUser) {
}
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public class ConnectionDirectory extends RestrictedObject
    implements Directory<Connection> {
        return connectionService.retrieveObject(getCurrentUser(), identifier);
        Collection<ModeledConnection> objects = connectionService.retrieveObjects(getCurrentUser(), identifiers);
        return connectionService.getIdentifiers(getCurrentUser());
        connectionService.createObject(getCurrentUser(), object);
        connectionService.updateObject(getCurrentUser(), connection);
        connectionService.deleteObject(getCurrentUser(), identifier);
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public class ConnectionGroupDirectory extends RestrictedObject
    implements Directory<ConnectionGroup> {
        return connectionGroupService.retrieveObject(getCurrentUser(), identifier);
        Collection<ModeledConnectionGroup> objects = connectionGroupService.retrieveObjects(getCurrentUser(), identifiers);
        return connectionGroupService.getIdentifiers(getCurrentUser());
        connectionGroupService.createObject(getCurrentUser(), object);
        connectionGroupService.updateObject(getCurrentUser(), connectionGroup);
        connectionGroupService.deleteObject(getCurrentUser(), identifier);
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public class RootConnectionGroup extends RestrictedObject
    implements ConnectionGroup {
        return connectionService.getIdentifiersWithin(getCurrentUser(), null);
        return connectionGroupService.getIdentifiersWithin(getCurrentUser(), null);
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public abstract class ObjectPermissionSet extends RestrictedObject
        super.init(currentUser);
        return getObjectPermissionService().retrievePermissions(getCurrentUser(), user);
        return getObjectPermissionService().retrievePermission(getCurrentUser(), user, permission, identifier) != null;
        getObjectPermissionService().createPermissions(getCurrentUser(), user, permissions);
        getObjectPermissionService().deletePermissions(getCurrentUser(), user, permissions);
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public class SystemPermissionSet extends RestrictedObject
        super.init(currentUser);
        return systemPermissionService.retrievePermissions(getCurrentUser(), user);
        return systemPermissionService.retrievePermission(getCurrentUser(), user, permission) != null;
        systemPermissionService.createPermissions(getCurrentUser(), user, permissions);
        systemPermissionService.deletePermissions(getCurrentUser(), user, permissions);
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public class UserContext extends RestrictedObject
    @Override
        super.init(currentUser);
        
        return getCurrentUser().getUser();
        rootGroup.init(getCurrentUser());
import org.glyptodon.guacamole.auth.jdbc.base.RestrictedObject;
public class UserDirectory extends RestrictedObject
    implements Directory<User> {
        return userService.retrieveObject(getCurrentUser(), identifier);
        Collection<ModeledUser> objects = userService.retrieveObjects(getCurrentUser(), identifiers);
        return userService.getIdentifiers(getCurrentUser());
        userService.createObject(getCurrentUser(), object);
        userService.updateObject(getCurrentUser(), user);
        userService.deleteObject(getCurrentUser(), identifier);
import java.util.Collection;
    /**
     * Retrieves the subset of the given identifiers for which the given user
     * has at least one of the given permissions.
     *
     * @param user
     *     The user to check permissions of.
     *
     * @param permissions
     *     The permissions to check. An identifier will be included in the
     *     resulting collection if at least one of these permissions is granted
     *     for the associated object
     *
     * @param identifiers
     *     The identifiers of the objects affected by the permissions being
     *     checked.
     *
     * @return
     *     A collection containing the subset of identifiers for which at least
     *     one of the specified permissions is granted.
     */
    Collection<String> selectAccessibleIdentifiers(@Param("user") UserModel user,
            @Param("permissions") Collection<ObjectPermission.Type> permissions,
            @Param("identifiers") Collection<String> identifiers);

    /**
     * Retrieves the subset of the given identifiers for which the given user
     * has at least one of the given permissions.
     *
     * @param user
     *     The user checking the permissions.
     *
     * @param targetUser
     *     The user to check permissions of.
     *
     * @param permissions
     *     The permissions to check. An identifier will be included in the
     *     resulting collection if at least one of these permissions is granted
     *     for the associated object
     *
     * @param identifiers
     *     The identifiers of the objects affected by the permissions being
     *     checked.
     *
     * @return
     *     A collection containing the subset of identifiers for which at least
     *     one of the specified permissions is granted.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving permissions.
     */
    public Collection<String> retrieveAccessibleIdentifiers(AuthenticatedUser user,
            ModeledUser targetUser, Collection<ObjectPermission.Type> permissions,
            Collection<String> identifiers) throws GuacamoleException {

        // Determine whether the user is an admin
        boolean isAdmin = user.getUser().isAdministrator();
        
        // Only an admin can read permissions that aren't his own
        if (isAdmin || user.getUser().getIdentifier().equals(targetUser.getIdentifier())) {

            // If user is an admin, everything is accessible
            if (isAdmin)
                return identifiers;

            // Otherwise, return explicitly-retrievable identifiers
            return getPermissionMapper().selectAccessibleIdentifiers(targetUser.getModel(), permissions, identifiers);
            
        }

        // User cannot read this user's permissions
        throw new GuacamoleSecurityException("Permission denied.");

    }

        return getObjectPermissionService().retrieveAccessibleIdentifiers(getCurrentUser(), user, permissions, identifiers);
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionPermissionService;
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionPermissionSet;
        addMapperClass(ConnectionPermissionMapper.class);
        bind(ConnectionPermissionSet.class);
        bind(ConnectionPermissionService.class);
    private String objectIdentifier;
    public String getObjectIdentifier() {
        return objectIdentifier;
     * @param objectIdentifier 
    public void setObjectIdentifier(String objectIdentifier) {
        this.objectIdentifier = objectIdentifier;
    @Override
    protected ObjectPermission getPermissionInstance(ObjectPermissionModel model) {
        return new ObjectPermission(model.getType(), model.getObjectIdentifier());
    }

    @Override
    protected ObjectPermissionModel getModelInstance(ModeledUser targetUser,
            ObjectPermission permission) {

        ObjectPermissionModel model = new ObjectPermissionModel();

        // Populate model object with data from user and permission
        model.setUserID(targetUser.getModel().getObjectID());
        model.setUsername(targetUser.getModel().getIdentifier());
        model.setType(permission.getType());
        model.setObjectIdentifier(permission.getObjectIdentifier());

        return model;
        
    }
        ObjectPermissionSet affectedPermissionSet = getPermissionSet(user, user.getUser());
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionPermissionService;

    /**
     * Service for retrieving connection permissions.
     */
    @Inject
    private ConnectionPermissionService connectionPermissionService;
        return connectionPermissionService.getPermissionSet(getCurrentUser(), this);
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionGroupPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionGroupPermissionService;
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionGroupPermissionSet;
        addMapperClass(ConnectionGroupPermissionMapper.class);
        bind(ConnectionGroupPermissionSet.class);
        bind(ConnectionPermissionSet.class);
        bind(ConnectionGroupPermissionService.class);
        bind(ConnectionGroupService.class);
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionGroupPermissionService;

    /**
     * Service for retrieving connection group permissions.
     */
    @Inject
    private ConnectionGroupPermissionService connectionGroupPermissionService;

        return connectionGroupPermissionService.getPermissionSet(getCurrentUser(), this);
import org.glyptodon.guacamole.auth.jdbc.permission.UserPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.UserPermissionService;
import org.glyptodon.guacamole.auth.jdbc.permission.UserPermissionSet;
        addMapperClass(UserPermissionMapper.class);
        bind(UserPermissionSet.class);
        bind(UserPermissionService.class);
import org.glyptodon.guacamole.auth.jdbc.permission.UserPermissionService;
    
    /**
     * Service for retrieving user permissions.
     */
    @Inject
    private UserPermissionService userPermissionService;
        return userPermissionService.getPermissionSet(getCurrentUser(), this);
        // Nothing is always accessible
        if (identifiers.isEmpty())
            return identifiers;
        
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionModel;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
     * All object permissions which are implicitly granted upon creation to the
     * creator of the object.
     */
    private static final ObjectPermission.Type[] IMPLICIT_OBJECT_PERMISSIONS = {
        ObjectPermission.Type.READ,
        ObjectPermission.Type.UPDATE,
        ObjectPermission.Type.DELETE,
        ObjectPermission.Type.ADMINISTER
    };
    
    /**
     * Returns an instance of a mapper for the type of permissions that affect
     * the type of object used by this service.
     *
     * @return
     *     A mapper which provides access to the model objects associated with
     *     the permissions that affect the objects used by this service.
     */
    protected abstract ObjectPermissionMapper getPermissionMapper();

    /**
            // Build list of implicit permissions
            Collection<ObjectPermissionModel> implicitPermissions =
                    new ArrayList<ObjectPermissionModel>(IMPLICIT_OBJECT_PERMISSIONS.length);

            UserModel userModel = user.getUser().getModel();
            for (ObjectPermission.Type permission : IMPLICIT_OBJECT_PERMISSIONS) {

                // Create model which grants this permission to the current user
                ObjectPermissionModel permissionModel = new ObjectPermissionModel();
                permissionModel.setUserID(userModel.getObjectID());
                permissionModel.setUsername(userModel.getIdentifier());
                permissionModel.setType(permission);
                permissionModel.setObjectIdentifier(model.getIdentifier());

                // Add permission
                implicitPermissions.add(permissionModel);
                
            }

            // Add implicit permissions
            getPermissionMapper().insert(implicitPermissions);

import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
     * Mapper for manipulating connection permissions.
     */
    @Inject
    private ConnectionPermissionMapper connectionPermissionMapper;
    
    /**
    protected ObjectPermissionMapper getPermissionMapper() {
        return connectionPermissionMapper;
    }

    @Override
import org.glyptodon.guacamole.auth.jdbc.permission.ConnectionGroupPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
     * Mapper for manipulating connection group permissions.
     */
    @Inject
    private ConnectionGroupPermissionMapper connectionGroupPermissionMapper;
    
    /**
    protected ObjectPermissionMapper getPermissionMapper() {
        return connectionGroupPermissionMapper;
    }

    @Override
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
import org.glyptodon.guacamole.auth.jdbc.permission.UserPermissionMapper;
     * Mapper for manipulating user permissions.
     */
    @Inject
    private UserPermissionMapper userPermissionMapper;
    
    /**
    protected ObjectPermissionMapper getPermissionMapper() {
        return userPermissionMapper;
    }

    @Override
     * Returns whether the contents of the given model are valid and can be
     * used to create a new object as-is. The object does not yet exist in the
     * database, but the user desires to create a new object with the given
     * model. This function will be called prior to any creation operation, and
     * provides a means for the implementation to abort prior to completion. The
     * default implementation does nothing.
     * @param model
     *     The model to validate.
    protected void validateNewModel(AuthenticatedUser user,
            ModelType model) throws GuacamoleException {
     * Returns whether the given model is valid and can be used to update an
     * existing object as-is. The object already exists in the database, but the
     * user desires to update the object to the given model. This function will
     * be called prior to update operation, and provides a means for the
     * implementation to abort prior to completion. The default implementation
     * does nothing.
     * @param model
     *     The model to validate.
    protected void validateExistingModel(AuthenticatedUser user,
            ModelType model) throws GuacamoleException {
            ModelType model = getModelInstance(user, object);
            validateNewModel(user, model);
            ModelType model = object.getModel();
            validateExistingModel(user, model);
            getObjectMapper().update(model);

    /**
     * Selects the connection within the given parent group and having the
     * given name. If no such connection exists, null is returned.
     *
     * @param parentIdentifier
     *     The identifier of the parent group to search within.
     *
     * @param name
     *     The name of the connection to find.
     *
     * @return
     *     The connection having the given name within the given parent group,
     *     or null if no such connection exists.
     */
    ConnectionModel selectOneByName(@Param("parentIdentifier") String parentIdentifier,
            @Param("name") String name);
    protected void validateNewModel(AuthenticatedUser user,
            ConnectionModel model) throws GuacamoleException {
        if (model.getName().trim().isEmpty())

        // Do not attempt to create duplicate connections
        ConnectionModel existing = connectionMapper.selectOneByName(model.getParentIdentifier(), model.getName());
        if (existing != null)
            throw new GuacamoleClientException("The connection \""  model.getName()  "\" already exists.");
    protected void validateExistingModel(AuthenticatedUser user,
            ConnectionModel model) throws GuacamoleException {
        if (model.getName().trim().isEmpty())
        // Check whether such a connection is already present
        ConnectionModel existing = connectionMapper.selectOneByName(model.getParentIdentifier(), model.getName());
        if (existing != null) {

            // If the specified name matches a DIFFERENT existing connection, the update cannot continue
            if (!existing.getObjectID().equals(model.getObjectID()))
                throw new GuacamoleClientException("The connection \""  model.getName()  "\" already exists.");

        }
        // Replace existing parameters with new parameters, if any
        if (!parameterModels.isEmpty())
            parameterMapper.insert(parameterModels);

    /**
     * Selects the connection group within the given parent group and having
     * the given name. If no such connection group exists, null is returned.
     *
     * @param parentIdentifier
     *     The identifier of the parent group to search within.
     *
     * @param name
     *     The name of the connection group to find.
     *
     * @return
     *     The connection group having the given name within the given parent
     *     group, or null if no such connection group exists.
     */
    ConnectionGroupModel selectOneByName(@Param("parentIdentifier") String parentIdentifier,
            @Param("name") String name);
    protected void validateNewModel(AuthenticatedUser user,
            ConnectionGroupModel model) throws GuacamoleException {
        if (model.getName().trim().isEmpty())
        // Do not attempt to create duplicate connection groups
        ConnectionGroupModel existing = connectionGroupMapper.selectOneByName(model.getParentIdentifier(), model.getName());
        if (existing != null)
            throw new GuacamoleClientException("The connection group \""  model.getName()  "\" already exists.");
    protected void validateExistingModel(AuthenticatedUser user,
            ConnectionGroupModel model) throws GuacamoleException {
        if (model.getName().trim().isEmpty())
        // Check whether such a connection group is already present
        ConnectionGroupModel existing = connectionGroupMapper.selectOneByName(model.getParentIdentifier(), model.getName());
        if (existing != null) {

            // If the specified name matches a DIFFERENT existing connection group, the update cannot continue
            if (!existing.getObjectID().equals(model.getObjectID()))
                throw new GuacamoleClientException("The connection group \""  model.getName()  "\" already exists.");

        }
    UserModel selectOneByCredentials(@Param("username") String username,

    /**
     * Returns the user having the given username, if any. If no such user
     * exists, null is returned.
     *
     * @param username
     *     The username of the user to return.
     *
     * @return
     *     The user having the given username, or null if no such user exists.
     */
    UserModel selectOne(@Param("username") String username);
    protected void validateNewModel(AuthenticatedUser user, UserModel model)
        if (model.getIdentifier().trim().isEmpty())
        Collection<UserModel> existing = userMapper.select(Collections.singleton(model.getIdentifier()));
            throw new GuacamoleClientException("User \""  model.getIdentifier()  "\" already exists.");
    protected void validateExistingModel(AuthenticatedUser user,
            UserModel model) throws GuacamoleException {
        if (model.getIdentifier().trim().isEmpty())
        UserModel existing = userMapper.selectOne(model.getIdentifier());
            if (!existing.getObjectID().equals(model.getObjectID()))
                throw new GuacamoleClientException("User \""  model.getIdentifier()  "\" already exists.");
        UserModel userModel = userMapper.selectOneByCredentials(username, password);
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Base classes supporting JDBC-driven authentication providers and defining
 * the relationships between the model and the implementations of guacamole-ext
 * classes.
package org.glyptodon.guacamole.auth.jdbc.base;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/connection/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to connections and their parameters and history.
package org.glyptodon.guacamole.auth.jdbc.connection;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/connectiongroup/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to connection groups.
package org.glyptodon.guacamole.auth.jdbc.connectiongroup;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/package-info.java
 * The base JDBC authentication provider. This authentication provider serves
 * as a basis for other JDBC authentication provider implementations which are
 * driven by relatively-common schemas. The only difference between such
 * implementations are maintained within database-specific MyBatis mappings.
package org.glyptodon.guacamole.auth.jdbc;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/ConnectionGroupPermissionMapper.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.auth.jdbc.permission;
/**
 * Mapper for connection group permissions.
 *
 * @author Michael Jumper
 */
public interface ConnectionGroupPermissionMapper extends ObjectPermissionMapper {}
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/ConnectionGroupPermissionSet.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.auth.jdbc.permission;
import com.google.inject.Inject;
 * A database implementation of ObjectPermissionSet which uses an injected
 * service to query and manipulate the connection group permissions associated
 * with a particular user.
 *
 * @author Michael Jumper
public class ConnectionGroupPermissionSet extends ObjectPermissionSet {
     * Service for querying and manipulating connection group permissions.
    @Inject
    private ConnectionGroupPermissionService connectionGroupPermissionService;
    
    protected ObjectPermissionService getObjectPermissionService() {
        return connectionGroupPermissionService;
 
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/ConnectionPermissionMapper.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.auth.jdbc.permission;
/**
 * Mapper for connection permissions.
 *
 * @author Michael Jumper
 */
public interface ConnectionPermissionMapper extends ObjectPermissionMapper {}
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/ConnectionPermissionSet.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.auth.jdbc.permission;
import com.google.inject.Inject;
 * A database implementation of ObjectPermissionSet which uses an injected
 * service to query and manipulate the connection permissions associated with
 * a particular user.
 *
 * @author Michael Jumper
public class ConnectionPermissionSet extends ObjectPermissionSet {
     * Service for querying and manipulating connection permissions.
    @Inject
    private ConnectionPermissionService connectionPermissionService;
    
    protected ObjectPermissionService getObjectPermissionService() {
        return connectionPermissionService;
 
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/SystemPermissionModel.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.auth.jdbc.permission;

import org.glyptodon.guacamole.net.auth.permission.SystemPermission;
 * Object representation of an system-level Guacamole permission, as
 * represented in the database.
 *
 * @author Michael Jumper
public class SystemPermissionModel extends PermissionModel<SystemPermission.Type> {

     * Creates a new, empty System permission.
    public SystemPermissionModel() {
    }

 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/UserPermissionMapper.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.auth.jdbc.permission;
/**
 * Mapper for user permissions.
 *
 * @author Michael Jumper
 */
public interface UserPermissionMapper extends ObjectPermissionMapper {}
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/UserPermissionSet.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.auth.jdbc.permission;
import com.google.inject.Inject;
 * A database implementation of ObjectPermissionSet which uses an injected
 * service to query and manipulate the user permissions associated with a
 * particular user.
 *
 * @author Michael Jumper
public class UserPermissionSet extends ObjectPermissionSet {
     * Service for querying and manipulating user permissions.
    @Inject
    private UserPermissionService userPermissionService;
    
    protected ObjectPermissionService getObjectPermissionService() {
        return userPermissionService;
 
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/permission/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to object- and system-level permissions.
package org.glyptodon.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/security/PasswordEncryptionService.java
package org.glyptodon.guacamole.auth.jdbc.security;

 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/security/SHA256PasswordEncryptionService.java
package org.glyptodon.guacamole.auth.jdbc.security;

 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/security/SaltService.java
package org.glyptodon.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/security/SecureRandomSaltService.java
package org.glyptodon.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/security/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to hashing or encryption.
package org.glyptodon.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/socket/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to obtaining/configuring Guacamole sockets, and restricting
 * access to those sockets.
package org.glyptodon.guacamole.auth.jdbc.socket;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/user/AuthenticatedUser.java
package org.glyptodon.guacamole.auth.jdbc.user;
 * Associates a user with the credentials they used to authenticate.
     * The user that authenticated.
    private final ModeledUser user;
     * Creates a new AuthenticatedUser associating the given user with their
     * corresponding credentials.
     * @param user
     *     The user this object should represent.
    public AuthenticatedUser(ModeledUser user, Credentials credentials) {
        this.user = user;
     * Returns the user that authenticated.
     *     The user that authenticated.
    public ModeledUser getUser() {
        return user;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/user/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to Guacamole users.
package org.glyptodon.guacamole.auth.jdbc.user;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/MySQLGuacamoleProperties.java
package net.sourceforge.guacamole.net.auth.mysql;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-mysql/src/main/java/net/sourceforge/guacamole/net/auth/mysql/package-info.java
 * The MySQL authentication provider. This package exists outside of
 * org.glyptodon for backwards-compatibility.
import com.google.inject.Provider;
import java.util.ArrayList;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionMapper;
import org.mybatis.guice.transactional.Transactional;
     * Mapper for accessing connections.
     */
    @Inject
    private ConnectionMapper connectionMapper;

    /**
     * Provider for creating connections.
     */
    @Inject
    private Provider<ModeledConnection> connectionProvider;

    /**
     * Acquires possibly-exclusive access to any one of the given connections
     * on behalf of the given user. If access is denied for any reason, or if
     * no connection is available, an exception is thrown.
     * @param connections
     *     The connections being accessed.
     *
     * @return
     *     The connection that has been acquired on behalf of the given user.
    protected abstract ModeledConnection acquire(AuthenticatedUser user,
            List<ModeledConnection> connections) throws GuacamoleException;
    /**
     * Creates a socket for the given user which connects to the given
     * connection, which MUST already be acquired via acquire(). The given
     * client information will be passed to guacd when the connection is
     * established.
     * 
     * The connection will be automatically released when it closes, or if it
     * fails to establish entirely.
     *
     * @param user
     *     The user for whom the connection is being established.
     *
     * @param connection
     *     The connection the user is connecting to.
     *
     * @param info
     *     Information describing the Guacamole client connecting to the given
     *     connection.
     *
     * @return
     *     A new GuacamoleSocket which is configured and connected to the given
     *     connection.
     *
     * @throws GuacamoleException
     *     If an error occurs while the connection is being established, or
     *     while connection configuration information is being retrieved.
     */
    private GuacamoleSocket connect(final AuthenticatedUser user,
            // Record new active connection
    @Transactional
    public GuacamoleSocket getGuacamoleSocket(final AuthenticatedUser user,
            final ModeledConnection connection, GuacamoleClientInformation info)
            throws GuacamoleException {

        // Acquire and connect to single connection
        acquire(user, Collections.singletonList(connection));
        return connect(user, connection, info);

    }

    @Override
    @Transactional

        // If not a balancing group, cannot connect
        if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
            throw new GuacamoleSecurityException("Permission denied.");
        
        // If group has no children, cannot connect
        Collection<String> identifiers = connectionMapper.selectIdentifiersWithin(connectionGroup.getIdentifier());
        if (identifiers.isEmpty())
            throw new GuacamoleSecurityException("Permission denied.");

        // Otherwise, retrieve all children
        Collection<ConnectionModel> models = connectionMapper.select(identifiers);
        List<ModeledConnection> connections = new ArrayList<ModeledConnection>(models.size());

        // Convert each retrieved model to a modeled connection
        for (ConnectionModel model : models) {
            ModeledConnection connection = connectionProvider.get();
            connection.init(user, model);
            connections.add(connection);
        }

        // Acquire and connect to any child
        ModeledConnection connection = acquire(user, connections);
        return connect(user, connection, info);


import java.util.List;
    protected ModeledConnection acquire(AuthenticatedUser user,
            List<ModeledConnection> connections) throws GuacamoleException {

        ModeledConnection chosen = null;
        int lowestUsage = 0;

        // Find connection with lowest usage
        for (ModeledConnection connection : connections) {

            int usage = getActiveConnections(connection).size();
            if (chosen == null || usage < lowestUsage) {
                chosen = connection;
                lowestUsage = usage;
            }
            
        }

        return chosen;
        
     * All active connections to a connection having a given identifier.
    private final ActiveConnectionMultimap activeConnections = new ActiveConnectionMultimap();
     * All active connections to a connection group having a given identifier.
    private final ActiveConnectionMultimap activeConnectionGroups = new ActiveConnectionMultimap();

        // Get relevant identifiers
        final String identifier = connection.getIdentifier();
        final String parentIdentifier = connection.getParentIdentifier();
        Collection<ParameterModel> parameters = parameterMapper.select(identifier);
            activeConnections.put(identifier, activeConnection);
            activeConnectionGroups.put(parentIdentifier, activeConnection);
                    activeConnections.remove(identifier, activeConnection);
                    activeConnectionGroups.remove(parentIdentifier, activeConnection);
                    recordModel.setConnectionIdentifier(identifier);
            activeConnections.remove(identifier, activeConnection);
            activeConnectionGroups.remove(parentIdentifier, activeConnection);
        return activeConnections.get(connection.getIdentifier());

        // If not a balancing group, assume no connections
        if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
            return Collections.EMPTY_LIST;

        return activeConnectionGroups.get(connectionGroup.getIdentifier());

import java.util.Collections;
            Collections.reverse(records);
    public Collection<ConnectionRecord> getActiveConnections(Connection connection) {
    public Collection<ConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup) {
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Set;
    private final Map<String, Set<ConnectionRecord>> records =
            new HashMap<String, Set<ConnectionRecord>>();
            Set<ConnectionRecord> connections = records.get(identifier);
                connections = Collections.newSetFromMap(new LinkedHashMap<ConnectionRecord, Boolean>());
            connections.add(record);
            Set<ConnectionRecord> connections = records.get(identifier);
     * Returns a collection of active connection records associated with the
     * object having the given identifier. The collection will be sorted in
     * insertion order. If there are no such connections, an empty collection is
     * returned.
     *     An immutable collection of records associated with the object having
     *     the given identifier, or an empty collection if there are no such
     *     records.
    public Collection<ConnectionRecord> get(String identifier) {
            Collection<ConnectionRecord> connections = records.get(identifier);
                return Collections.unmodifiableCollection(connections);
import java.util.Collection;
     * Returns a connection containing connection records representing all
     * currently-active connections using the given connection. These records
     * will have usernames and start dates, but no end date, and will be
     * sorted in ascending order by start date.
     *     A connection containing connection records representing all
     *     currently-active connections.
    public Collection<ConnectionRecord> getActiveConnections(Connection connection);
     * Returns a collection containing connection records representing all
     * currently-active connections using the given connection group. These
     * records will have usernames and start dates, but no end date, and will
     * be sorted in ascending order by start date.
     *     A collection containing connection records representing all
     *     currently-active connections.
    public Collection<ConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup);
import java.util.Collections;
            Collections.reverse(records);
import com.google.inject.Provider;
import java.util.ArrayList;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionMapper;
import org.mybatis.guice.transactional.Transactional;
     * Mapper for accessing connections.
     */
    @Inject
    private ConnectionMapper connectionMapper;

    /**
     * Provider for creating connections.
     */
    @Inject
    private Provider<ModeledConnection> connectionProvider;

    /**
     * All active connections to a connection having a given identifier.
    private final ActiveConnectionMultimap activeConnections = new ActiveConnectionMultimap();
     * All active connections to a connection group having a given identifier.
    private final ActiveConnectionMultimap activeConnectionGroups = new ActiveConnectionMultimap();
     * Acquires possibly-exclusive access to any one of the given connections
     * on behalf of the given user. If access is denied for any reason, or if
     * no connection is available, an exception is thrown.
     * @param connections
     *     The connections being accessed.
     *
     * @return
     *     The connection that has been acquired on behalf of the given user.
    protected abstract ModeledConnection acquire(AuthenticatedUser user,
            List<ModeledConnection> connections) throws GuacamoleException;
    /**
     * Creates a socket for the given user which connects to the given
     * connection, which MUST already be acquired via acquire(). The given
     * client information will be passed to guacd when the connection is
     * established.
     * 
     * The connection will be automatically released when it closes, or if it
     * fails to establish entirely.
     *
     * @param user
     *     The user for whom the connection is being established.
     *
     * @param connection
     *     The connection the user is connecting to.
     *
     * @param info
     *     Information describing the Guacamole client connecting to the given
     *     connection.
     *
     * @return
     *     A new GuacamoleSocket which is configured and connected to the given
     *     connection.
     *
     * @throws GuacamoleException
     *     If an error occurs while the connection is being established, or
     *     while connection configuration information is being retrieved.
     */
    private GuacamoleSocket connect(final AuthenticatedUser user,

        // Get relevant identifiers
        final String identifier = connection.getIdentifier();
        final String parentIdentifier = connection.getParentIdentifier();
        Collection<ParameterModel> parameters = parameterMapper.select(identifier);
            // Record new active connection
            activeConnections.put(identifier, activeConnection);
            activeConnectionGroups.put(parentIdentifier, activeConnection);
                    activeConnections.remove(identifier, activeConnection);
                    activeConnectionGroups.remove(parentIdentifier, activeConnection);
                    recordModel.setConnectionIdentifier(identifier);
            activeConnections.remove(identifier, activeConnection);
            activeConnectionGroups.remove(parentIdentifier, activeConnection);
    @Transactional
    public GuacamoleSocket getGuacamoleSocket(final AuthenticatedUser user,
            final ModeledConnection connection, GuacamoleClientInformation info)
            throws GuacamoleException {
        // Acquire and connect to single connection
        acquire(user, Collections.singletonList(connection));
        return connect(user, connection, info);
    public Collection<ConnectionRecord> getActiveConnections(Connection connection) {
        return activeConnections.get(connection.getIdentifier());
    }

    @Override
    @Transactional

        // If not a balancing group, cannot connect
        if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
            throw new GuacamoleSecurityException("Permission denied.");
        
        // If group has no children, cannot connect
        Collection<String> identifiers = connectionMapper.selectIdentifiersWithin(connectionGroup.getIdentifier());
        if (identifiers.isEmpty())
            throw new GuacamoleSecurityException("Permission denied.");

        // Otherwise, retrieve all children
        Collection<ConnectionModel> models = connectionMapper.select(identifiers);
        List<ModeledConnection> connections = new ArrayList<ModeledConnection>(models.size());

        // Convert each retrieved model to a modeled connection
        for (ConnectionModel model : models) {
            ModeledConnection connection = connectionProvider.get();
            connection.init(user, model);
            connections.add(connection);
        }

        // Acquire and connect to any child
        ModeledConnection connection = acquire(user, connections);
        return connect(user, connection, info);

    public Collection<ConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup) {

        // If not a balancing group, assume no connections
        if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
            return Collections.EMPTY_LIST;

        return activeConnectionGroups.get(connectionGroup.getIdentifier());


import java.util.Collection;
     * Returns a connection containing connection records representing all
     * currently-active connections using the given connection. These records
     * will have usernames and start dates, but no end date, and will be
     * sorted in ascending order by start date.
     *     A connection containing connection records representing all
     *     currently-active connections.
    public Collection<ConnectionRecord> getActiveConnections(Connection connection);
     * Returns a collection containing connection records representing all
     * currently-active connections using the given connection group. These
     * records will have usernames and start dates, but no end date, and will
     * be sorted in ascending order by start date.
     *     A collection containing connection records representing all
     *     currently-active connections.
    public Collection<ConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup);
import java.util.List;
    protected ModeledConnection acquire(AuthenticatedUser user,
            List<ModeledConnection> connections) throws GuacamoleException {

        ModeledConnection chosen = null;
        int lowestUsage = 0;

        // Find connection with lowest usage
        for (ModeledConnection connection : connections) {

            int usage = getActiveConnections(connection).size();
            if (chosen == null || usage < lowestUsage) {
                chosen = connection;
                lowestUsage = usage;
            }
            
        }

        return chosen;
        
     * The service class to use to provide GuacamoleSockets for each
     * connection.
     */
    private final Class<? extends GuacamoleSocketService> socketServiceClass;

    /**
     * various injected base classes using the given environment, and provides
     * connections using the given socket service.
     * 
     * @param socketServiceClass
     *     The socket service to use to provide sockets for connections.
    public JDBCAuthenticationProviderModule(Environment environment,
            Class<? extends GuacamoleSocketService> socketServiceClass) {
        this.socketServiceClass = socketServiceClass;
        // Bind provided socket service
        bind(GuacamoleSocketService.class).to(socketServiceClass);
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.MultiseatGuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.ReservedGuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.SingleSeatGuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.UnrestrictedGuacamoleSocketService;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
     * Returns the appropriate socket service class given the Guacamole
     * environment. The class is chosen based on configuration options that
     * dictate concurrent usage policy.
     *
     * @param environment
     *     The environment of the Guacamole server.
     *
     * @return
     *     The socket service class that matches the concurrent usage policy
     *     options set in the Guacamole environment.
     *
     * @throws GuacamoleException
     *     If an error occurs while reading the configuration options.
     */
    private Class<? extends GuacamoleSocketService>
        getSocketServiceClass(Environment environment)
                throws GuacamoleException {

        // Read concurrency-related properties
        boolean disallowSimultaneous = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS, false);
        boolean disallowDuplicate    = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS, true);

        if (disallowSimultaneous) {

            // Connections may not be used concurrently
            if (disallowDuplicate)
                return SingleSeatGuacamoleSocketService.class;

            // Connections are reserved for a single user when in use
            else
                return ReservedGuacamoleSocketService.class;

        }

        else {

            // Connections may be used concurrently, but only once per user
            if (disallowDuplicate)
                return MultiseatGuacamoleSocketService.class;

            // Connection use is not restricted
            else
                return UnrestrictedGuacamoleSocketService.class;

        }
         
    }
    
    /**
            new JDBCAuthenticationProviderModule(environment, getSocketServiceClass(environment))
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import org.glyptodon.guacamole.GuacamoleResourceConflictException;
    /**
     * An arbitrary number of reservations associated with a specific user.
     * Initially, each Reservation instance represents exactly one reservation,
     * but future calls to acquire() may increase this value. Once the
     * reservation count is reduced to zero by calls to release(), a
     * Reservation instance is empty and cannot be reused. It must be discarded
     * and replaced with a fresh Reservation.
     * 
     * This is necessary as each Reservation will be stored within a Map, and
     * the effect of acquire() must be deterministic. If Reservations could be
     * reused, the internal count could potentially increase after being
     * removed from the map, resulting in a successful acquire() that really
     * should have failed.
     */
    private static class Reservation {

        /**
         * The username of the user associated with this reservation.
         */
        private final String username;

        /**
         * The number of reservations effectively present under the associated
         * username.
         */
        private int count = 1;

        /**
         * Creates a new reservation which tracks the overall number of
         * reservations for a given user.
         * @param username 
         */
        public Reservation(String username) {
            this.username = username;
        }

        /**
         * Attempts to acquire a new reservation under the given username. If
         * this reservation is for a different user, or the reservation has
         * expired, this will fail.
         *
         * @param username
         *     The username of the user to acquire the reservation for.
         *
         * @return
         *     true if the reservation was successful, false otherwise.
         */
        public boolean acquire(String username) {

            // Acquire always fails if for the wrong user
            if (!this.username.equals(username))
                return false;

            // Determine success/failure based on count
            synchronized (this) {

                // If already expired, no further reservations are allowed
                if (count == 0)
                    return false;

                // Otherwise, add another reservation, report success
                count;
                return true;
                
            }
            
        }

        /**
         * Releases a previous reservation. The result of calling this function
         * without a previous matching call to acquire is undefined.
         *
         * @return
         *     true if the last reservation has been released and this
         *     reservation is now empty, false otherwise.
         */
        public boolean release() {
            synchronized (this) {

                // Reduce reservation count
                count--;

                // Empty if no reservations remain
                return count == 0;
                
            }
        }
        
    }

    /**
     * Map of connection identifier to associated reservations.
     */
    private final ConcurrentMap<String, Reservation> reservations =
            new ConcurrentHashMap<String, Reservation>();
    

        String username = user.getUser().getIdentifier();
        
        // Return the first successfully-reserved connection
        for (ModeledConnection connection : connections) {

            String identifier = connection.getIdentifier();

            // Attempt to reserve connection, return if successful
            Reservation reservation = reservations.putIfAbsent(identifier, new Reservation(username));
            if (reservation == null || reservation.acquire(username))
                return connection;

        }

        // Already in use
        throw new GuacamoleResourceConflictException("Cannot connect. This connection is in use.");


        String identifier = connection.getIdentifier();
        
        // Retrieve active reservation (which must exist)
        Reservation reservation = reservations.get(identifier);
        assert(reservation != null);

        // Release reservation, remove from map if empty
        if (reservation.release())
            reservations.remove(identifier);
        
import java.util.concurrent.atomic.AtomicBoolean;
        final AtomicBoolean released = new AtomicBoolean(false);
                    // Release connection upon close, if not already released
                    if (released.compareAndSet(false, true)) {
                        // Release connection
                        activeConnections.remove(identifier, activeConnection);
                        activeConnectionGroups.remove(parentIdentifier, activeConnection);
                        release(user, connection);
                        UserModel userModel = user.getUser().getModel();
                        ConnectionRecordModel recordModel = new ConnectionRecordModel();
                        // Copy user information and timestamps into new record
                        recordModel.setUserID(userModel.getObjectID());
                        recordModel.setUsername(userModel.getIdentifier());
                        recordModel.setConnectionIdentifier(identifier);
                        recordModel.setStartDate(activeConnection.getStartDate());
                        recordModel.setEndDate(new Date());

                        // Insert connection record
                        connectionRecordMapper.insert(recordModel);

                    }
                } // end close()
            // Release connection if not already released
            if (released.compareAndSet(false, true)) {
                activeConnections.remove(identifier, activeConnection);
                activeConnectionGroups.remove(parentIdentifier, activeConnection);
                release(user, connection);
            }
     * Returns a guacamole configuration containing the protocol and parameters
     * from the given connection. If tokens are used in the connection
     * parameter values, credentials from the given user will be substituted
     * appropriately.
     *
     * @param user
     *     The user whose credentials should be used if necessary.
     *
     * @param connection
     *     The connection whose protocol and parameters should be added to the
     *     returned configuration.
     *
     * @return
     *     A GuacamoleConfiguration containing the protocol and parameters from
     *     the given connection.
     */
    private GuacamoleConfiguration getGuacamoleConfiguration(AuthenticatedUser user,
            ModeledConnection connection) {

        // Generate configuration from available data
        GuacamoleConfiguration config = new GuacamoleConfiguration();

        // Set protocol from connection
        ConnectionModel model = connection.getModel();
        config.setProtocol(model.getProtocol());

        // Set parameters from associated data
        Collection<ParameterModel> parameters = parameterMapper.select(connection.getIdentifier());
        for (ParameterModel parameter : parameters)
            config.setParameter(parameter.getName(), parameter.getValue());

        // Build token filter containing credential tokens
        TokenFilter tokenFilter = new TokenFilter();
        StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());

        // Filter the configuration
        tokenFilter.filterValues(config.getParameters());

        return config;
        
    }

    /**
     * Saves the given ActiveConnectionRecord to the database, associating it
     * with the connection having the given identifier. The end date of the
     * saved record will be populated with the current time.
     *
     * @param identifier
     *     The connection to associate the new record with.
     *
     * @param record
     *     The record to save.
     */
    private void saveConnectionRecord(String identifier,
            ActiveConnectionRecord record) {

        // Get associated models
        AuthenticatedUser user = record.getUser();
        UserModel userModel = user.getUser().getModel();
        ConnectionRecordModel recordModel = new ConnectionRecordModel();

        // Copy user information and timestamps into new record
        recordModel.setUserID(userModel.getObjectID());
        recordModel.setUsername(userModel.getIdentifier());
        recordModel.setConnectionIdentifier(identifier);
        recordModel.setStartDate(record.getStartDate());
        recordModel.setEndDate(new Date());

        // Insert connection record
        connectionRecordMapper.insert(recordModel);

    }
    
    /**
                getGuacamoleConfiguration(user, connection)
                        // Save record to database
                        saveConnectionRecord(identifier, activeConnection);
    /**
     * Returns the user that connected to the connection associated with this
     * connection record.
     *
     * @return
     *     The user that connected to the connection associated with this
     *     connection record.
     */
    public AuthenticatedUser getUser() {
        return user;
    }


    /**
     * Returns an unconfigured GuacamoleSocket that is already connected to
     * guacd as specified in guacamole.properties, using SSL if necessary.
     *
     * @return
     *     An unconfigured GuacamoleSocket, already connected to guacd.
     *
     * @throws GuacamoleException 
     *     If an error occurs while connecting to guacd, or while parsing
     *     guacd-related properties.
     */
    private GuacamoleSocket getUnconfiguredGuacamoleSocket()
        throws GuacamoleException {

        // Use SSL if requested
        if (environment.getProperty(Environment.GUACD_SSL, true))
            return new InetGuacamoleSocket(
                environment.getRequiredProperty(Environment.GUACD_HOSTNAME),
                environment.getRequiredProperty(Environment.GUACD_PORT)
            );

        // Otherwise, just use straight TCP
        return new InetGuacamoleSocket(
            environment.getRequiredProperty(Environment.GUACD_HOSTNAME),
            environment.getRequiredProperty(Environment.GUACD_PORT)
        );

    }
    
                getUnconfiguredGuacamoleSocket(),
                getGuacamoleConfiguration(user, connection),
                info
     * The service class to use to provide GuacamoleSockets for each
     * connection.
     */
    private final Class<? extends GuacamoleSocketService> socketServiceClass;

    /**
     * various injected base classes using the given environment, and provides
     * connections using the given socket service.
     * 
     * @param socketServiceClass
     *     The socket service to use to provide sockets for connections.
    public JDBCAuthenticationProviderModule(Environment environment,
            Class<? extends GuacamoleSocketService> socketServiceClass) {
        this.socketServiceClass = socketServiceClass;
        // Bind provided socket service
        bind(GuacamoleSocketService.class).to(socketServiceClass);
import java.util.concurrent.atomic.AtomicBoolean;
     * Returns a guacamole configuration containing the protocol and parameters
     * from the given connection. If tokens are used in the connection
     * parameter values, credentials from the given user will be substituted
     * appropriately.
     *
     * @param user
     *     The user whose credentials should be used if necessary.
     *
     * @param connection
     *     The connection whose protocol and parameters should be added to the
     *     returned configuration.
     *
     * @return
     *     A GuacamoleConfiguration containing the protocol and parameters from
     *     the given connection.
     */
    private GuacamoleConfiguration getGuacamoleConfiguration(AuthenticatedUser user,
            ModeledConnection connection) {

        // Generate configuration from available data
        GuacamoleConfiguration config = new GuacamoleConfiguration();

        // Set protocol from connection
        ConnectionModel model = connection.getModel();
        config.setProtocol(model.getProtocol());

        // Set parameters from associated data
        Collection<ParameterModel> parameters = parameterMapper.select(connection.getIdentifier());
        for (ParameterModel parameter : parameters)
            config.setParameter(parameter.getName(), parameter.getValue());

        // Build token filter containing credential tokens
        TokenFilter tokenFilter = new TokenFilter();
        StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());

        // Filter the configuration
        tokenFilter.filterValues(config.getParameters());

        return config;
        
    }

    /**
     * Saves the given ActiveConnectionRecord to the database, associating it
     * with the connection having the given identifier. The end date of the
     * saved record will be populated with the current time.
     *
     * @param identifier
     *     The connection to associate the new record with.
     *
     * @param record
     *     The record to save.
     */
    private void saveConnectionRecord(String identifier,
            ActiveConnectionRecord record) {

        // Get associated models
        AuthenticatedUser user = record.getUser();
        UserModel userModel = user.getUser().getModel();
        ConnectionRecordModel recordModel = new ConnectionRecordModel();

        // Copy user information and timestamps into new record
        recordModel.setUserID(userModel.getObjectID());
        recordModel.setUsername(userModel.getIdentifier());
        recordModel.setConnectionIdentifier(identifier);
        recordModel.setStartDate(record.getStartDate());
        recordModel.setEndDate(new Date());

        // Insert connection record
        connectionRecordMapper.insert(recordModel);

    }

    /**
     * Returns an unconfigured GuacamoleSocket that is already connected to
     * guacd as specified in guacamole.properties, using SSL if necessary.
     *
     * @return
     *     An unconfigured GuacamoleSocket, already connected to guacd.
     *
     * @throws GuacamoleException 
     *     If an error occurs while connecting to guacd, or while parsing
     *     guacd-related properties.
     */
    private GuacamoleSocket getUnconfiguredGuacamoleSocket()
        throws GuacamoleException {

        // Use SSL if requested
        if (environment.getProperty(Environment.GUACD_SSL, true))
            return new InetGuacamoleSocket(
                environment.getRequiredProperty(Environment.GUACD_HOSTNAME),
                environment.getRequiredProperty(Environment.GUACD_PORT)
            );

        // Otherwise, just use straight TCP
        return new InetGuacamoleSocket(
            environment.getRequiredProperty(Environment.GUACD_HOSTNAME),
            environment.getRequiredProperty(Environment.GUACD_PORT)
        );

    }
    
    /**
        final AtomicBoolean released = new AtomicBoolean(false);
    
                getUnconfiguredGuacamoleSocket(),
                getGuacamoleConfiguration(user, connection),
                info
                    // Release connection upon close, if not already released
                    if (released.compareAndSet(false, true)) {
                        // Release connection
                        activeConnections.remove(identifier, activeConnection);
                        activeConnectionGroups.remove(parentIdentifier, activeConnection);
                        release(user, connection);
                        // Save record to database
                        saveConnectionRecord(identifier, activeConnection);
                    }
                } // end close()
            // Release connection if not already released
            if (released.compareAndSet(false, true)) {
                activeConnections.remove(identifier, activeConnection);
                activeConnectionGroups.remove(parentIdentifier, activeConnection);
                release(user, connection);
            }
    /**
     * Returns the user that connected to the connection associated with this
     * connection record.
     *
     * @return
     *     The user that connected to the connection associated with this
     *     connection record.
     */
    public AuthenticatedUser getUser() {
        return user;
    }

import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.MultiseatGuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.ReservedGuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.SingleSeatGuacamoleSocketService;
import org.glyptodon.guacamole.auth.jdbc.socket.UnrestrictedGuacamoleSocketService;
import org.glyptodon.guacamole.properties.GuacamoleProperties;
     * Returns the appropriate socket service class given the Guacamole
     * environment. The class is chosen based on configuration options that
     * dictate concurrent usage policy.
     *
     * @param environment
     *     The environment of the Guacamole server.
     *
     * @return
     *     The socket service class that matches the concurrent usage policy
     *     options set in the Guacamole environment.
     *
     * @throws GuacamoleException
     *     If an error occurs while reading the configuration options.
     */
    private Class<? extends GuacamoleSocketService>
        getSocketServiceClass(Environment environment)
                throws GuacamoleException {

        // Read concurrency-related properties
        boolean disallowSimultaneous = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS, false);
        boolean disallowDuplicate    = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS, true);

        if (disallowSimultaneous) {

            // Connections may not be used concurrently
            if (disallowDuplicate)
                return SingleSeatGuacamoleSocketService.class;

            // Connections are reserved for a single user when in use
            else
                return ReservedGuacamoleSocketService.class;

        }

        else {

            // Connections may be used concurrently, but only once per user
            if (disallowDuplicate)
                return MultiseatGuacamoleSocketService.class;

            // Connection use is not restricted
            else
                return UnrestrictedGuacamoleSocketService.class;

        }
         
    }
    
    /**
            new JDBCAuthenticationProviderModule(environment, getSocketServiceClass(environment))
import java.util.Arrays;
import org.glyptodon.guacamole.auth.jdbc.security.PasswordEncryptionService;
    /**
     * Service for hashing passwords.
     */
    @Inject
    private PasswordEncryptionService encryptionService;

        // Retrieve corresponding user model, if such a user exists
        UserModel userModel = userMapper.selectOne(username);
        // If password hash matches, return the retrieved user
        byte[] hash = encryptionService.createPasswordHash(password, userModel.getPasswordSalt());
        if (Arrays.equals(hash, userModel.getPasswordHash())) {

            // Return corresponding user, set up cyclic reference
            ModeledUser user = getObjectInstance(null, userModel);
            user.setCurrentUser(new AuthenticatedUser(user, credentials));
            return user;

        }

        // Otherwise, the credentials do not match
        return null;
        ConnectionGroup existingConnectionGroup = retrievalService.retrieveConnectionGroup(userContext, connectionGroupID);
        ConnectionGroup existingConnectionGroup = retrievalService.retrieveConnectionGroup(userContext, connectionGroupID);
import java.util.Arrays;
import org.glyptodon.guacamole.auth.jdbc.security.PasswordEncryptionService;
    /**
     * Service for hashing passwords.
     */
    @Inject
    private PasswordEncryptionService encryptionService;

        // Retrieve corresponding user model, if such a user exists
        UserModel userModel = userMapper.selectOne(username);
        // If password hash matches, return the retrieved user
        byte[] hash = encryptionService.createPasswordHash(password, userModel.getPasswordSalt());
        if (Arrays.equals(hash, userModel.getPasswordHash())) {

            // Return corresponding user, set up cyclic reference
            ModeledUser user = getObjectInstance(null, userModel);
            user.setCurrentUser(new AuthenticatedUser(user, credentials));
            return user;

        }

        // Otherwise, the credentials do not match
        return null;
     * Returns a collection of permissions that should be granted due to the
     * creation of the given object. These permissions need not be granted
     * solely to the user creating the object.
     * 
     * @param user
     *     The user creating the object.
     * 
     * @param model
     *     The object being created.
     * 
     * @return
     *     The collection of implicit permissions that should be granted due to
     *     the creation of the given object.
     */
    protected Collection<ObjectPermissionModel> getImplicitPermissions(AuthenticatedUser user,
            ModelType model) {
        
        // Build list of implicit permissions
        Collection<ObjectPermissionModel> implicitPermissions =
                new ArrayList<ObjectPermissionModel>(IMPLICIT_OBJECT_PERMISSIONS.length);

        UserModel userModel = user.getUser().getModel();
        for (ObjectPermission.Type permission : IMPLICIT_OBJECT_PERMISSIONS) {

            // Create model which grants this permission to the current user
            ObjectPermissionModel permissionModel = new ObjectPermissionModel();
            permissionModel.setUserID(userModel.getObjectID());
            permissionModel.setUsername(userModel.getIdentifier());
            permissionModel.setType(permission);
            permissionModel.setObjectIdentifier(model.getIdentifier());

            // Add permission
            implicitPermissions.add(permissionModel);

        }
        
        return implicitPermissions;

    }
    
    /**
            getPermissionMapper().insert(getImplicitPermissions(user, model));
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionModel;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
    
    /**
     * All user permissions which are implicitly granted to the new user upon
     * creation.
     */
    private static final ObjectPermission.Type[] IMPLICIT_USER_PERMISSIONS = {
        ObjectPermission.Type.READ,
        ObjectPermission.Type.UPDATE
    };
    
    @Override
    protected Collection<ObjectPermissionModel>
        getImplicitPermissions(AuthenticatedUser user, UserModel model) {
            
        // Get original set of implicit permissions
        Collection<ObjectPermissionModel> implicitPermissions = super.getImplicitPermissions(user, model);
        
        // Grant implicit permissions to the new user
        for (ObjectPermission.Type permissionType : IMPLICIT_USER_PERMISSIONS) {
            
            ObjectPermissionModel permissionModel = new ObjectPermissionModel();
            permissionModel.setUserID(model.getObjectID());
            permissionModel.setUsername(model.getIdentifier());
            permissionModel.setType(permissionType);
            permissionModel.setObjectIdentifier(model.getIdentifier());

            // Add new permission to implicit permission set 
            implicitPermissions.add(permissionModel);
            
        }
        
        return implicitPermissions;
        
    }

     * Acquires possibly-exclusive access to the given connection group on
     * behalf of the given user. If access is denied for any reason, an
     * exception is thrown.
     *
     * @param user
     *     The user acquiring access.
     *
     * @param connectionGroup
     *     The connection group being accessed.
     *
     * @throws GuacamoleException
     *     If access is denied to the given user for any reason.
     */
    protected abstract void acquire(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) throws GuacamoleException;

    /**
     * Releases possibly-exclusive access to the given connection group on
     * behalf of the given user. If the given user did not already have access,
     * the behavior of this function is undefined.
     *
     * @param user
     *     The user releasing access.
     *
     * @param connectionGroup
     *     The connection group being released.
     */
    protected abstract void release(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup);

    /**
     * @param balancingGroup,
     *     The associated balancing group, if any. If the connection is not
     *     associated with a balancing group, or the connection is being used
     *     manually, this will be null.
     *
            final ModeledConnectionGroup balancingGroup,
                        // Release any associated group
                        if (balancingGroup != null)
                            release(user, balancingGroup);
                        

                // Release connection

                // Release any associated group
                if (balancingGroup != null)
                    release(user, balancingGroup);
                
        return connect(user, null, connection, info);
        // Acquire group
        acquire(user, connectionGroup);

        // Retrieve all children
        return connect(user, connectionGroup, connection, info);
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
 * per-user basis. Each connection or group may be used concurrently any number
 * of times, but each concurrent use must be associated with a different user.

    /**
     * The set of all active user/connection group pairs.
     */
    private final Set<Seat> activeGroupSeats =
            Collections.newSetFromMap(new ConcurrentHashMap<Seat, Boolean>());
    @Override
    protected void acquire(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) throws GuacamoleException {

        // Do not allow duplicate use of connection groups
        Seat seat = new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier());
        if (!activeGroupSeats.add(seat))
            throw new GuacamoleResourceConflictException("Cannot connect. This connection is in use.");

    }

    @Override
    protected void release(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) {
        activeGroupSeats.remove(new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier()));
    }

import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
 * of any connection at any time. Concurrent usage of connections is not
 * allowed, and concurrent usage of connection groups is allowed only between
 * different users.

    /**
     * The set of all active user/connection group pairs.
     */
    private final Set<Seat> activeGroupSeats =
            Collections.newSetFromMap(new ConcurrentHashMap<Seat, Boolean>());
   
    @Override
    protected void acquire(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) throws GuacamoleException {

        // Do not allow duplicate use of connection groups
        Seat seat = new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier());
        if (!activeGroupSeats.add(seat))
            throw new GuacamoleResourceConflictException("Cannot connect. This connection is in use.");

    }

    @Override
    protected void release(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) {
        activeGroupSeats.remove(new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier()));
    }

import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
    @Override
    protected void acquire(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) throws GuacamoleException {
        // Do nothing
    }

    @Override
    protected void release(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) {
        // Do nothing
    }

import org.glyptodon.guacamole.auth.jdbc.socket.BalancedGuacamoleSocketService;
                return BalancedGuacamoleSocketService.class;
import java.util.Arrays;
import java.util.Comparator;

        // Sort connections in ascending order of usage
        ModeledConnection[] sortedConnections = connections.toArray(new ModeledConnection[connections.size()]);
        Arrays.sort(sortedConnections, new Comparator<ModeledConnection>() {

            @Override
            public int compare(ModeledConnection a, ModeledConnection b) {

                return getActiveConnections(a).size()
                     - getActiveConnections(b).size();

            }

        });
        for (ModeledConnection connection : sortedConnections) {
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
            throw new GuacamoleClientTooManyException("Cannot connect. Connection group already in use by this user.");
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
            throw new GuacamoleClientTooManyException("Cannot connect. Connection group already in use by this user.");
     * Saves the given ActiveConnectionRecord to the database. The end date of
     * the saved record will be populated with the current time.
    private void saveConnectionRecord(ActiveConnectionRecord record) {
        // Get associated connection
        ModeledConnection connection = record.getConnection();
        
        recordModel.setConnectionIdentifier(connection.getIdentifier());
    private GuacamoleSocket getUnconfiguredGuacamoleSocket(Runnable socketClosedCallback)
            return new ManagedInetGuacamoleSocket(
                environment.getRequiredProperty(Environment.GUACD_PORT),
                socketClosedCallback
        return new ManagedInetGuacamoleSocket(
            environment.getRequiredProperty(Environment.GUACD_PORT),
            socketClosedCallback

    /**
     * Task which handles cleanup of a connection associated with some given
     * ActiveConnectionRecord.
     */
    private class ConnectionCleanupTask implements Runnable {

        /**
         * Whether this task has run.
         */
        private final AtomicBoolean hasRun = new AtomicBoolean(false);

        /**
         * The ActiveConnectionRecord whose connection will be cleaned up once
         * this task runs.
         */
        private final ActiveConnectionRecord activeConnection;

        /**
         * Creates a new task which automatically cleans up after the
         * connection associated with the given ActiveConnectionRecord. The
         * connection and parent group will be removed from the maps of active
         * connections and groups, and exclusive access will be released.
         *
         * @param activeConnection
         *     The ActiveConnectionRecord whose associated connection should be
         *     cleaned up once this task runs.
         */
        public ConnectionCleanupTask(ActiveConnectionRecord activeConnection) {
            this.activeConnection = activeConnection;
        }
        
        @Override
        public void run() {

            // Only run once
            if (!hasRun.compareAndSet(false, true))
                return;

            // Get original user and connection
            AuthenticatedUser user = activeConnection.getUser();
            ModeledConnection connection = activeConnection.getConnection();

            // Get associated identifiers
            String identifier = connection.getIdentifier();
            String parentIdentifier = connection.getParentIdentifier();

            // Release connection
            activeConnections.remove(identifier, activeConnection);
            activeConnectionGroups.remove(parentIdentifier, activeConnection);
            release(user, connection);

            // Release any associated group
            if (activeConnection.hasBalancingGroup())
                release(user, activeConnection.getBalancingGroup());
            
            // Save history record to database
            saveConnectionRecord(activeConnection);

        }

    }

    private GuacamoleSocket getGuacamoleSocket(ActiveConnectionRecord activeConnection,
            GuacamoleClientInformation info)
        ModeledConnection connection = activeConnection.getConnection();
        
        // Record new active connection
        Runnable cleanupTask = new ConnectionCleanupTask(activeConnection);
        activeConnections.put(connection.getIdentifier(), activeConnection);
        activeConnectionGroups.put(connection.getParentIdentifier(), activeConnection);
                getUnconfiguredGuacamoleSocket(cleanupTask),
                getGuacamoleConfiguration(activeConnection.getUser(), connection),
            );
        // Execute cleanup if socket could not be created
            cleanupTask.run();
    /**
     * Returns a list of all balanced connections within a given connection
     * group. If the connection group is not balancing, or it contains no
     * connections, an empty list is returned.
     *
     * @param user
     *     The user on whose behalf the balanced connections within the given
     *     connection group are being retrieved.
     *
     * @param connectionGroup
     *     The connection group to retrieve the balanced connections of.
     *
     * @return
     *     A list containing all balanced connections within the given group,
     *     or an empty list if there are no such connections.
     */
    private List<ModeledConnection> getBalancedConnections(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) {

        // If not a balancing group, there are no balanced connections
        if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
            return Collections.EMPTY_LIST;

        // If group has no children, there are no balanced connections
        Collection<String> identifiers = connectionMapper.selectIdentifiersWithin(connectionGroup.getIdentifier());
        if (identifiers.isEmpty())
            return Collections.EMPTY_LIST;

        // Retrieve all children
        Collection<ConnectionModel> models = connectionMapper.select(identifiers);
        List<ModeledConnection> connections = new ArrayList<ModeledConnection>(models.size());

        // Convert each retrieved model to a modeled connection
        for (ConnectionModel model : models) {
            ModeledConnection connection = connectionProvider.get();
            connection.init(user, model);
            connections.add(connection);
        }

        return connections;
        
    }

        return getGuacamoleSocket(new ActiveConnectionRecord(user, connection), info);
        // If group has no associated balanced connections, cannot connect
        List<ModeledConnection> connections = getBalancedConnections(user, connectionGroup);
        if (connections.isEmpty())
        return getGuacamoleSocket(new ActiveConnectionRecord(user, connectionGroup, connection), info);
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
     * The balancing group from which the associated connection was chosen, if
     * any. If no balancing group was used, this will be null.
     */
    private final ModeledConnectionGroup balancingGroup;

    /**
     * The connection associated with this connection record.
     */
    private final ModeledConnection connection;

    /**
     * Creates a new connection record associated with the given user,
     * connection, and balancing connection group. The given balancing
     * connection group MUST be the connection group from which the given
     * connection was chosen. The start date of this connection record will be
     * the time of its creation.
     *
     * @param balancingGroup
     *     The balancing group from which the given connection was chosen.
     *
     * @param connection
     *     The connection to associate with this connection record.
    public ActiveConnectionRecord(AuthenticatedUser user,
            ModeledConnectionGroup balancingGroup,
            ModeledConnection connection) {
        this.balancingGroup = balancingGroup;
        this.connection = connection;
    }

    /**
     * Creates a new connection record associated with the given user and
     * connection. The start date of this connection record will be the time of
     * its creation.
     *
     * @param user
     *     The user that connected to the connection associated with this
     *     connection record.
     *
     * @param connection
     *     The connection to associate with this connection record.
     */
    public ActiveConnectionRecord(AuthenticatedUser user,
            ModeledConnection connection) {
        this(user, null, connection);
    /**
     * Returns the balancing group from which the connection associated with
     * this connection record was chosen.
     *
     * @return
     *     The balancing group from which the connection associated with this
     *     connection record was chosen.
     */
    public ModeledConnectionGroup getBalancingGroup() {
        return balancingGroup;
    }

    /**
     * Returns the connection associated with this connection record.
     *
     * @return
     *     The connection associated with this connection record.
     */
    public ModeledConnection getConnection() {
        return connection;
    }

    /**
     * Returns whether the connection associated with this connection record
     * was chosen from a balancing group.
     *
     * @return
     *     true if the connection associated with this connection record was
     *     chosen from a balancing group, false otherwise.
     */
    public boolean hasBalancingGroup() {
        return balancingGroup != null;
    }
    
        // Retrieve permissions only if allowed
        if (canReadPermissions(user, targetUser)) {
        // Retrieve permissions only if allowed
        if (canReadPermissions(user, targetUser)) {
            if (user.getUser().isAdministrator())
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
     * Determines whether the given user can read the permissions currently
     * granted to the given target user. If the reading user and the target
     * user are not the same, then explicit READ or SYSTEM_ADMINISTER access is
     * required.
     *
     * @param user
     *     The user attempting to read permissions.
     *
     * @param targetUser
     *     The user whose permissions are being read.
     *
     * @return
     *     true if permission is granted, false otherwise.
     *
     * @throws GuacamoleException 
     *     If an error occurs while checking permission status, or if
     *     permission is denied to read the current user's permissions.
     */
    protected boolean canReadPermissions(AuthenticatedUser user,
            ModeledUser targetUser) throws GuacamoleException {

        // A user can always read their own permissions
        if (user.getUser().getIdentifier().equals(targetUser.getIdentifier()))
            return true;
        
        // A system adminstrator can do anything
        if (user.getUser().isAdministrator())
            return true;

        // Can read permissions on target user if explicit READ is granted
        ObjectPermissionSet userPermissionSet = user.getUser().getUserPermissions();
        return userPermissionSet.hasPermission(ObjectPermission.Type.READ, targetUser.getIdentifier());

    }

    /**
        // Retrieve permissions only if allowed
        if (canReadPermissions(user, targetUser))
        // Retrieve permissions only if allowed
        if (canReadPermissions(user, targetUser)) {
        // Retrieve permissions only if allowed
        if (canReadPermissions(user, targetUser)) {
            if (user.getUser().isAdministrator())
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
     * Determines whether the given user can read the permissions currently
     * granted to the given target user. If the reading user and the target
     * user are not the same, then explicit READ or SYSTEM_ADMINISTER access is
     * required.
     *
     * @param user
     *     The user attempting to read permissions.
     *
     * @param targetUser
     *     The user whose permissions are being read.
     *
     * @return
     *     true if permission is granted, false otherwise.
     *
     * @throws GuacamoleException 
     *     If an error occurs while checking permission status, or if
     *     permission is denied to read the current user's permissions.
     */
    protected boolean canReadPermissions(AuthenticatedUser user,
            ModeledUser targetUser) throws GuacamoleException {

        // A user can always read their own permissions
        if (user.getUser().getIdentifier().equals(targetUser.getIdentifier()))
            return true;
        
        // A system adminstrator can do anything
        if (user.getUser().isAdministrator())
            return true;

        // Can read permissions on target user if explicit READ is granted
        ObjectPermissionSet userPermissionSet = user.getUser().getUserPermissions();
        return userPermissionSet.hasPermission(ObjectPermission.Type.READ, targetUser.getIdentifier());

    }

    /**
        // Retrieve permissions only if allowed
        if (canReadPermissions(user, targetUser))
     * Acquires possibly-exclusive access to the given connection group on
     * behalf of the given user. If access is denied for any reason, an
     * exception is thrown.
     *
     * @param user
     *     The user acquiring access.
     *
     * @param connectionGroup
     *     The connection group being accessed.
     *
     * @throws GuacamoleException
     *     If access is denied to the given user for any reason.
     */
    protected abstract void acquire(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) throws GuacamoleException;

    /**
     * Releases possibly-exclusive access to the given connection group on
     * behalf of the given user. If the given user did not already have access,
     * the behavior of this function is undefined.
     *
     * @param user
     *     The user releasing access.
     *
     * @param connectionGroup
     *     The connection group being released.
     */
    protected abstract void release(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup);

    /**
     * Saves the given ActiveConnectionRecord to the database. The end date of
     * the saved record will be populated with the current time.
    private void saveConnectionRecord(ActiveConnectionRecord record) {
        // Get associated connection
        ModeledConnection connection = record.getConnection();
        
        recordModel.setConnectionIdentifier(connection.getIdentifier());
    private GuacamoleSocket getUnconfiguredGuacamoleSocket(Runnable socketClosedCallback)
            return new ManagedInetGuacamoleSocket(
                environment.getRequiredProperty(Environment.GUACD_PORT),
                socketClosedCallback
        return new ManagedInetGuacamoleSocket(
            environment.getRequiredProperty(Environment.GUACD_PORT),
            socketClosedCallback

    /**
     * Task which handles cleanup of a connection associated with some given
     * ActiveConnectionRecord.
     */
    private class ConnectionCleanupTask implements Runnable {

        /**
         * Whether this task has run.
         */
        private final AtomicBoolean hasRun = new AtomicBoolean(false);

        /**
         * The ActiveConnectionRecord whose connection will be cleaned up once
         * this task runs.
         */
        private final ActiveConnectionRecord activeConnection;

        /**
         * Creates a new task which automatically cleans up after the
         * connection associated with the given ActiveConnectionRecord. The
         * connection and parent group will be removed from the maps of active
         * connections and groups, and exclusive access will be released.
         *
         * @param activeConnection
         *     The ActiveConnectionRecord whose associated connection should be
         *     cleaned up once this task runs.
         */
        public ConnectionCleanupTask(ActiveConnectionRecord activeConnection) {
            this.activeConnection = activeConnection;
        }
        
        @Override
        public void run() {

            // Only run once
            if (!hasRun.compareAndSet(false, true))
                return;

            // Get original user and connection
            AuthenticatedUser user = activeConnection.getUser();
            ModeledConnection connection = activeConnection.getConnection();

            // Get associated identifiers
            String identifier = connection.getIdentifier();
            String parentIdentifier = connection.getParentIdentifier();

            // Release connection
            activeConnections.remove(identifier, activeConnection);
            activeConnectionGroups.remove(parentIdentifier, activeConnection);
            release(user, connection);

            // Release any associated group
            if (activeConnection.hasBalancingGroup())
                release(user, activeConnection.getBalancingGroup());
            
            // Save history record to database
            saveConnectionRecord(activeConnection);

        }

    }

    private GuacamoleSocket getGuacamoleSocket(ActiveConnectionRecord activeConnection,
            GuacamoleClientInformation info)
        ModeledConnection connection = activeConnection.getConnection();
        
        // Record new active connection
        Runnable cleanupTask = new ConnectionCleanupTask(activeConnection);
        activeConnections.put(connection.getIdentifier(), activeConnection);
        activeConnectionGroups.put(connection.getParentIdentifier(), activeConnection);
                getUnconfiguredGuacamoleSocket(cleanupTask),
                getGuacamoleConfiguration(activeConnection.getUser(), connection),
            );
        // Execute cleanup if socket could not be created
            cleanupTask.run();
    /**
     * Returns a list of all balanced connections within a given connection
     * group. If the connection group is not balancing, or it contains no
     * connections, an empty list is returned.
     *
     * @param user
     *     The user on whose behalf the balanced connections within the given
     *     connection group are being retrieved.
     *
     * @param connectionGroup
     *     The connection group to retrieve the balanced connections of.
     *
     * @return
     *     A list containing all balanced connections within the given group,
     *     or an empty list if there are no such connections.
     */
    private List<ModeledConnection> getBalancedConnections(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) {

        // If not a balancing group, there are no balanced connections
        if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
            return Collections.EMPTY_LIST;

        // If group has no children, there are no balanced connections
        Collection<String> identifiers = connectionMapper.selectIdentifiersWithin(connectionGroup.getIdentifier());
        if (identifiers.isEmpty())
            return Collections.EMPTY_LIST;

        // Retrieve all children
        Collection<ConnectionModel> models = connectionMapper.select(identifiers);
        List<ModeledConnection> connections = new ArrayList<ModeledConnection>(models.size());

        // Convert each retrieved model to a modeled connection
        for (ConnectionModel model : models) {
            ModeledConnection connection = connectionProvider.get();
            connection.init(user, model);
            connections.add(connection);
        }

        return connections;
        
    }

        return getGuacamoleSocket(new ActiveConnectionRecord(user, connection), info);
        // If group has no associated balanced connections, cannot connect
        List<ModeledConnection> connections = getBalancedConnections(user, connectionGroup);
        if (connections.isEmpty())
        // Acquire group
        acquire(user, connectionGroup);
        return getGuacamoleSocket(new ActiveConnectionRecord(user, connectionGroup, connection), info);
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
     * The balancing group from which the associated connection was chosen, if
     * any. If no balancing group was used, this will be null.
     */
    private final ModeledConnectionGroup balancingGroup;

    /**
     * The connection associated with this connection record.
     */
    private final ModeledConnection connection;

    /**
     * Creates a new connection record associated with the given user,
     * connection, and balancing connection group. The given balancing
     * connection group MUST be the connection group from which the given
     * connection was chosen. The start date of this connection record will be
     * the time of its creation.
     *
     * @param balancingGroup
     *     The balancing group from which the given connection was chosen.
     *
     * @param connection
     *     The connection to associate with this connection record.
    public ActiveConnectionRecord(AuthenticatedUser user,
            ModeledConnectionGroup balancingGroup,
            ModeledConnection connection) {
        this.balancingGroup = balancingGroup;
        this.connection = connection;
    }

    /**
     * Creates a new connection record associated with the given user and
     * connection. The start date of this connection record will be the time of
     * its creation.
     *
     * @param user
     *     The user that connected to the connection associated with this
     *     connection record.
     *
     * @param connection
     *     The connection to associate with this connection record.
     */
    public ActiveConnectionRecord(AuthenticatedUser user,
            ModeledConnection connection) {
        this(user, null, connection);
    /**
     * Returns the balancing group from which the connection associated with
     * this connection record was chosen.
     *
     * @return
     *     The balancing group from which the connection associated with this
     *     connection record was chosen.
     */
    public ModeledConnectionGroup getBalancingGroup() {
        return balancingGroup;
    }

    /**
     * Returns the connection associated with this connection record.
     *
     * @return
     *     The connection associated with this connection record.
     */
    public ModeledConnection getConnection() {
        return connection;
    }

    /**
     * Returns whether the connection associated with this connection record
     * was chosen from a balancing group.
     *
     * @return
     *     true if the connection associated with this connection record was
     *     chosen from a balancing group, false otherwise.
     */
    public boolean hasBalancingGroup() {
        return balancingGroup != null;
    }
    
import java.util.Arrays;
import java.util.Comparator;
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
 * per-user basis. Each connection or group may be used concurrently any number
 * of times, but each concurrent use must be associated with a different user.

    /**
     * The set of all active user/connection group pairs.
     */
    private final Set<Seat> activeGroupSeats =
            Collections.newSetFromMap(new ConcurrentHashMap<Seat, Boolean>());

        // Sort connections in ascending order of usage
        ModeledConnection[] sortedConnections = connections.toArray(new ModeledConnection[connections.size()]);
        Arrays.sort(sortedConnections, new Comparator<ModeledConnection>() {

            @Override
            public int compare(ModeledConnection a, ModeledConnection b) {

                return getActiveConnections(a).size()
                     - getActiveConnections(b).size();

            }

        });
        for (ModeledConnection connection : sortedConnections) {
    @Override
    protected void acquire(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) throws GuacamoleException {

        // Do not allow duplicate use of connection groups
        Seat seat = new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier());
        if (!activeGroupSeats.add(seat))
            throw new GuacamoleClientTooManyException("Cannot connect. Connection group already in use by this user.");

    }

    @Override
    protected void release(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) {
        activeGroupSeats.remove(new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier()));
    }

import org.glyptodon.guacamole.GuacamoleClientTooManyException;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
 * of any connection at any time. Concurrent usage of connections is not
 * allowed, and concurrent usage of connection groups is allowed only between
 * different users.

    /**
     * The set of all active user/connection group pairs.
     */
    private final Set<Seat> activeGroupSeats =
            Collections.newSetFromMap(new ConcurrentHashMap<Seat, Boolean>());
   
    @Override
    protected void acquire(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) throws GuacamoleException {

        // Do not allow duplicate use of connection groups
        Seat seat = new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier());
        if (!activeGroupSeats.add(seat))
            throw new GuacamoleClientTooManyException("Cannot connect. Connection group already in use by this user.");

    }

    @Override
    protected void release(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) {
        activeGroupSeats.remove(new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier()));
    }

import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
    @Override
    protected void acquire(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) throws GuacamoleException {
        // Do nothing
    }

    @Override
    protected void release(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) {
        // Do nothing
    }

import org.glyptodon.guacamole.auth.jdbc.socket.BalancedGuacamoleSocketService;
                return BalancedGuacamoleSocketService.class;
     * salt. If the provided salt is null, only the password itself is hashed.
     * @param password
     *     The password to hash.
     *
     * @param salt
     *     The salt to use when hashing the password, if any.
     *
     * @return
     *     The generated password hash.
            // Build salted password, if a salt was provided
            if (salt != null)
                builder.append(DatatypeConverter.printHexBinary(salt));

            // Hash UTF-8 bytes of possibly-salted password
        // Throw hard errors if standard pieces of Java are missing
        catch (UnsupportedEncodingException e) {
            throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
        catch (NoSuchAlgorithmException e) {
            throw new UnsupportedOperationException("Unexpected lack of SHA-256 support.", e);
     * salt. If the provided salt is null, only the password itself is hashed.
     * @param password
     *     The password to hash.
     *
     * @param salt
     *     The salt to use when hashing the password, if any.
     *
     * @return
     *     The generated password hash.
            // Build salted password, if a salt was provided
            if (salt != null)
                builder.append(DatatypeConverter.printHexBinary(salt));

            // Hash UTF-8 bytes of possibly-salted password
        // Throw hard errors if standard pieces of Java are missing
        catch (UnsupportedEncodingException e) {
            throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
        catch (NoSuchAlgorithmException e) {
            throw new UnsupportedOperationException("Unexpected lack of SHA-256 support.", e);
import org.glyptodon.guacamole.auth.jdbc.base.GroupedObjectModel;
public class ConnectionModel extends GroupedObjectModel {
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObject;
public class ModeledConnection extends GroupedDirectoryObject<ConnectionModel>

import org.glyptodon.guacamole.auth.jdbc.base.GroupedObjectModel;
public class ConnectionGroupModel extends GroupedObjectModel {
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObject;
public class ModeledConnectionGroup extends GroupedDirectoryObject<ConnectionGroupModel>
 * manipulating objects within directories. This service will automatically
 * enforce the permissions of the current user.
     * Called before any object is created through this directory object
     * service. This function serves as a final point of validation before
     * the create operation occurs. In its default implementation,
     * beforeCreate() performs basic permissions checks.
     *     The model of the object being created.
    protected void beforeCreate(AuthenticatedUser user,
            ModelType model ) throws GuacamoleException {
        // Verify permission to create objects
        if (!user.getUser().isAdministrator() && !hasCreatePermission(user))
            throw new GuacamoleSecurityException("Permission denied.");
     * Called before any object is updated through this directory object
     * service. This function serves as a final point of validation before
     * the update operation occurs. In its default implementation,
     * beforeUpdate() performs basic permissions checks.
     *     The model of the object being updated.
    protected void beforeUpdate(AuthenticatedUser user,
        if (!hasObjectPermission(user, model.getIdentifier(), ObjectPermission.Type.UPDATE))
            throw new GuacamoleSecurityException("Permission denied.");

    }

    /**
     * Called before any object is deleted through this directory object
     * service. This function serves as a final point of validation before
     * the delete operation occurs. In its default implementation,
     * beforeDelete() performs basic permissions checks.
     *
     * @param user
     *     The user deleting the existing object.
     *
     * @param identifier
     *     The identifier of the object being deleted.
     *
     * @throws GuacamoleException
     *     If the object is invalid, or an error prevents validating the given
     *     object.
     */
    protected void beforeDelete(AuthenticatedUser user,
            String identifier) throws GuacamoleException {

        // Verify permission to delete objects
        if (!hasObjectPermission(user, identifier, ObjectPermission.Type.DELETE))
            throw new GuacamoleSecurityException("Permission denied.");
        ModelType model = getModelInstance(user, object);
        beforeCreate(user, model);
        
        // Create object
        getObjectMapper().insert(model);
        // Build list of implicit permissions
        Collection<ObjectPermissionModel> implicitPermissions =
                new ArrayList<ObjectPermissionModel>(IMPLICIT_OBJECT_PERMISSIONS.length);
        UserModel userModel = user.getUser().getModel();
        for (ObjectPermission.Type permission : IMPLICIT_OBJECT_PERMISSIONS) {
            // Create model which grants this permission to the current user
            ObjectPermissionModel permissionModel = new ObjectPermissionModel();
            permissionModel.setUserID(userModel.getObjectID());
            permissionModel.setUsername(userModel.getIdentifier());
            permissionModel.setType(permission);
            permissionModel.setObjectIdentifier(model.getIdentifier());
            // Add permission
            implicitPermissions.add(permissionModel);
            
        // Add implicit permissions
        getPermissionMapper().insert(implicitPermissions);

        return getObjectInstance(user, model);
        beforeDelete(user, identifier);
        
        // Delete object
        getObjectMapper().delete(identifier);
        ModelType model = object.getModel();
        beforeUpdate(user, model);
        
        // Update object
        getObjectMapper().update(model);
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObjectService;
public class ConnectionService extends GroupedDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
    protected void beforeCreate(AuthenticatedUser user,
        super.beforeCreate(user, model);
        
    protected void beforeUpdate(AuthenticatedUser user,
        super.beforeUpdate(user, model);
        

import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObjectService;
public class ConnectionGroupService extends GroupedDirectoryObjectService<ModeledConnectionGroup,
    protected void beforeCreate(AuthenticatedUser user,
        super.beforeCreate(user, model);
        
    protected void beforeUpdate(AuthenticatedUser user,
        super.beforeUpdate(user, model);
        
    protected void beforeCreate(AuthenticatedUser user, UserModel model)
        super.beforeCreate(user, model);
        
    protected void beforeUpdate(AuthenticatedUser user,
        super.beforeUpdate(user, model);
        
 * manipulating objects within directories. This service will automatically
 * enforce the permissions of the current user.
     * Called before any object is created through this directory object
     * service. This function serves as a final point of validation before
     * the create operation occurs. In its default implementation,
     * beforeCreate() performs basic permissions checks.
     *     The model of the object being created.
    protected void beforeCreate(AuthenticatedUser user,
            ModelType model ) throws GuacamoleException {
        // Verify permission to create objects
        if (!user.getUser().isAdministrator() && !hasCreatePermission(user))
            throw new GuacamoleSecurityException("Permission denied.");
     * Called before any object is updated through this directory object
     * service. This function serves as a final point of validation before
     * the update operation occurs. In its default implementation,
     * beforeUpdate() performs basic permissions checks.
     *     The model of the object being updated.
    protected void beforeUpdate(AuthenticatedUser user,
        if (!hasObjectPermission(user, model.getIdentifier(), ObjectPermission.Type.UPDATE))
            throw new GuacamoleSecurityException("Permission denied.");

    }

    /**
     * Called before any object is deleted through this directory object
     * service. This function serves as a final point of validation before
     * the delete operation occurs. In its default implementation,
     * beforeDelete() performs basic permissions checks.
     *
     * @param user
     *     The user deleting the existing object.
     *
     * @param identifier
     *     The identifier of the object being deleted.
     *
     * @throws GuacamoleException
     *     If the object is invalid, or an error prevents validating the given
     *     object.
     */
    protected void beforeDelete(AuthenticatedUser user,
            String identifier) throws GuacamoleException {

        // Verify permission to delete objects
        if (!hasObjectPermission(user, identifier, ObjectPermission.Type.DELETE))
            throw new GuacamoleSecurityException("Permission denied.");
        ModelType model = getModelInstance(user, object);
        beforeCreate(user, model);
        
        // Create object
        getObjectMapper().insert(model);
        // Build list of implicit permissions
        Collection<ObjectPermissionModel> implicitPermissions =
                new ArrayList<ObjectPermissionModel>(IMPLICIT_OBJECT_PERMISSIONS.length);
        UserModel userModel = user.getUser().getModel();
        for (ObjectPermission.Type permission : IMPLICIT_OBJECT_PERMISSIONS) {
            // Create model which grants this permission to the current user
            ObjectPermissionModel permissionModel = new ObjectPermissionModel();
            permissionModel.setUserID(userModel.getObjectID());
            permissionModel.setUsername(userModel.getIdentifier());
            permissionModel.setType(permission);
            permissionModel.setObjectIdentifier(model.getIdentifier());
            // Add permission
            implicitPermissions.add(permissionModel);
            
        // Add implicit permissions
        getPermissionMapper().insert(implicitPermissions);

        return getObjectInstance(user, model);
        beforeDelete(user, identifier);
        
        // Delete object
        getObjectMapper().delete(identifier);
        ModelType model = object.getModel();
        beforeUpdate(user, model);
        
        // Update object
        getObjectMapper().update(model);
import org.glyptodon.guacamole.auth.jdbc.base.GroupedObjectModel;
public class ConnectionModel extends GroupedObjectModel {
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObjectService;
public class ConnectionService extends GroupedDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
    protected void beforeCreate(AuthenticatedUser user,
        super.beforeCreate(user, model);
        
    protected void beforeUpdate(AuthenticatedUser user,
        super.beforeUpdate(user, model);
        

import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObject;
public class ModeledConnection extends GroupedDirectoryObject<ConnectionModel>

import org.glyptodon.guacamole.auth.jdbc.base.GroupedObjectModel;
public class ConnectionGroupModel extends GroupedObjectModel {
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObjectService;
public class ConnectionGroupService extends GroupedDirectoryObjectService<ModeledConnectionGroup,
    protected void beforeCreate(AuthenticatedUser user,
        super.beforeCreate(user, model);
        
    protected void beforeUpdate(AuthenticatedUser user,
        super.beforeUpdate(user, model);
        
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObject;
public class ModeledConnectionGroup extends GroupedDirectoryObject<ConnectionGroupModel>
    protected void beforeCreate(AuthenticatedUser user, UserModel model)
        super.beforeCreate(user, model);
        
    protected void beforeUpdate(AuthenticatedUser user,
        super.beforeUpdate(user, model);
        
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
    @Override
    protected void beforeDelete(AuthenticatedUser user, String identifier) throws GuacamoleException {

        super.beforeDelete(user, identifier);

        // Do not allow users to delete themselves
        if (identifier.equals(user.getUser().getIdentifier()))
            throw new GuacamoleUnsupportedException("Deleting your own user is not allowed.");

    }

import org.glyptodon.guacamole.GuacamoleUnsupportedException;

            // Do not allow users to remove their own admin powers
            if (user.getUser().getIdentifier().equals(targetUser.getIdentifier()))
                throw new GuacamoleUnsupportedException("Removing your own administrative permissions is not allowed.");
            
import org.glyptodon.guacamole.GuacamoleUnsupportedException;

            // Do not allow users to remove their own admin powers
            if (user.getUser().getIdentifier().equals(targetUser.getIdentifier()))
                throw new GuacamoleUnsupportedException("Removing your own administrative permissions is not allowed.");
            
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
    @Override
    protected void beforeDelete(AuthenticatedUser user, String identifier) throws GuacamoleException {

        super.beforeDelete(user, identifier);

        // Do not allow users to delete themselves
        if (identifier.equals(user.getUser().getIdentifier()))
            throw new GuacamoleUnsupportedException("Deleting your own user is not allowed.");

    }

import org.glyptodon.guacamole.GuacamoleUnsupportedException;

        // Verify that this connection group's location does not create a cycle
        String relativeParentIdentifier = model.getParentIdentifier();
        while (relativeParentIdentifier != null) {

            // Abort if cycle is detected
            if (relativeParentIdentifier.equals(model.getIdentifier()))
                throw new GuacamoleUnsupportedException("A connection group may not contain itself.");

            // Advance to next parent
            ModeledConnectionGroup relativeParentGroup = retrieveObject(user, relativeParentIdentifier);
            relativeParentIdentifier = relativeParentGroup.getModel().getParentIdentifier();

        } 

import org.glyptodon.guacamole.GuacamoleUnsupportedException;

        // Verify that this connection group's location does not create a cycle
        String relativeParentIdentifier = model.getParentIdentifier();
        while (relativeParentIdentifier != null) {

            // Abort if cycle is detected
            if (relativeParentIdentifier.equals(model.getIdentifier()))
                throw new GuacamoleUnsupportedException("A connection group may not contain itself.");

            // Advance to next parent
            ModeledConnectionGroup relativeParentGroup = retrieveObject(user, relativeParentIdentifier);
            relativeParentIdentifier = relativeParentGroup.getModel().getParentIdentifier();

        } 

 * manipulating objects within directories. This service will automatically
 * enforce the permissions of the current user.
     * Called before any object is created through this directory object
     * service. This function serves as a final point of validation before
     * the create operation occurs. In its default implementation,
     * beforeCreate() performs basic permissions checks.
     *     The model of the object being created.
    protected void beforeCreate(AuthenticatedUser user,
            ModelType model ) throws GuacamoleException {
        // Verify permission to create objects
        if (!user.getUser().isAdministrator() && !hasCreatePermission(user))
            throw new GuacamoleSecurityException("Permission denied.");
     * Called before any object is updated through this directory object
     * service. This function serves as a final point of validation before
     * the update operation occurs. In its default implementation,
     * beforeUpdate() performs basic permissions checks.
     *     The model of the object being updated.
    protected void beforeUpdate(AuthenticatedUser user,
        if (!hasObjectPermission(user, model.getIdentifier(), ObjectPermission.Type.UPDATE))
            throw new GuacamoleSecurityException("Permission denied.");

    }

    /**
     * Called before any object is deleted through this directory object
     * service. This function serves as a final point of validation before
     * the delete operation occurs. In its default implementation,
     * beforeDelete() performs basic permissions checks.
     *
     * @param user
     *     The user deleting the existing object.
     *
     * @param identifier
     *     The identifier of the object being deleted.
     *
     * @throws GuacamoleException
     *     If the object is invalid, or an error prevents validating the given
     *     object.
     */
    protected void beforeDelete(AuthenticatedUser user,
            String identifier) throws GuacamoleException {

        // Verify permission to delete objects
        if (!hasObjectPermission(user, identifier, ObjectPermission.Type.DELETE))
            throw new GuacamoleSecurityException("Permission denied.");
        ModelType model = getModelInstance(user, object);
        beforeCreate(user, model);
        
        // Create object
        getObjectMapper().insert(model);
        // Add implicit permissions
        getPermissionMapper().insert(getImplicitPermissions(user, model));
        return getObjectInstance(user, model);
        beforeDelete(user, identifier);
        
        // Delete object
        getObjectMapper().delete(identifier);
        ModelType model = object.getModel();
        beforeUpdate(user, model);
        
        // Update object
        getObjectMapper().update(model);
import org.glyptodon.guacamole.auth.jdbc.base.GroupedObjectModel;
public class ConnectionModel extends GroupedObjectModel {
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObjectService;
public class ConnectionService extends GroupedDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
    protected void beforeCreate(AuthenticatedUser user,
        super.beforeCreate(user, model);
        
    protected void beforeUpdate(AuthenticatedUser user,
        super.beforeUpdate(user, model);
        

import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObject;
public class ModeledConnection extends GroupedDirectoryObject<ConnectionModel>

import org.glyptodon.guacamole.auth.jdbc.base.GroupedObjectModel;
public class ConnectionGroupModel extends GroupedObjectModel {
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObjectService;
public class ConnectionGroupService extends GroupedDirectoryObjectService<ModeledConnectionGroup,
    protected void beforeCreate(AuthenticatedUser user,
        super.beforeCreate(user, model);
        
    protected void beforeUpdate(AuthenticatedUser user,
        super.beforeUpdate(user, model);
        

        // Verify that this connection group's location does not create a cycle
        String relativeParentIdentifier = model.getParentIdentifier();
        while (relativeParentIdentifier != null) {

            // Abort if cycle is detected
            if (relativeParentIdentifier.equals(model.getIdentifier()))
                throw new GuacamoleUnsupportedException("A connection group may not contain itself.");

            // Advance to next parent
            ModeledConnectionGroup relativeParentGroup = retrieveObject(user, relativeParentIdentifier);
            relativeParentIdentifier = relativeParentGroup.getModel().getParentIdentifier();

        } 

import org.glyptodon.guacamole.auth.jdbc.base.GroupedDirectoryObject;
public class ModeledConnectionGroup extends GroupedDirectoryObject<ConnectionGroupModel>
        // Retrieve permissions only if allowed
        if (canReadPermissions(user, targetUser)) {
        // Retrieve permissions only if allowed
        if (canReadPermissions(user, targetUser)) {
            if (user.getUser().isAdministrator())
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermissionSet;
     * Determines whether the given user can read the permissions currently
     * granted to the given target user. If the reading user and the target
     * user are not the same, then explicit READ or SYSTEM_ADMINISTER access is
     * required.
     *
     * @param user
     *     The user attempting to read permissions.
     *
     * @param targetUser
     *     The user whose permissions are being read.
     *
     * @return
     *     true if permission is granted, false otherwise.
     *
     * @throws GuacamoleException 
     *     If an error occurs while checking permission status, or if
     *     permission is denied to read the current user's permissions.
     */
    protected boolean canReadPermissions(AuthenticatedUser user,
            ModeledUser targetUser) throws GuacamoleException {

        // A user can always read their own permissions
        if (user.getUser().getIdentifier().equals(targetUser.getIdentifier()))
            return true;
        
        // A system adminstrator can do anything
        if (user.getUser().isAdministrator())
            return true;

        // Can read permissions on target user if explicit READ is granted
        ObjectPermissionSet userPermissionSet = user.getUser().getUserPermissions();
        return userPermissionSet.hasPermission(ObjectPermission.Type.READ, targetUser.getIdentifier());

    }

    /**
        // Retrieve permissions only if allowed
        if (canReadPermissions(user, targetUser))
import org.glyptodon.guacamole.GuacamoleUnsupportedException;

            // Do not allow users to remove their own admin powers
            if (user.getUser().getIdentifier().equals(targetUser.getIdentifier()))
                throw new GuacamoleUnsupportedException("Removing your own administrative permissions is not allowed.");
            
     * salt. If the provided salt is null, only the password itself is hashed.
     * @param password
     *     The password to hash.
     *
     * @param salt
     *     The salt to use when hashing the password, if any.
     *
     * @return
     *     The generated password hash.
            // Build salted password, if a salt was provided
            if (salt != null)
                builder.append(DatatypeConverter.printHexBinary(salt));

            // Hash UTF-8 bytes of possibly-salted password
        // Throw hard errors if standard pieces of Java are missing
        catch (UnsupportedEncodingException e) {
            throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
        catch (NoSuchAlgorithmException e) {
            throw new UnsupportedOperationException("Unexpected lack of SHA-256 support.", e);
     * Acquires possibly-exclusive access to the given connection group on
     * behalf of the given user. If access is denied for any reason, an
     * exception is thrown.
     *
     * @param user
     *     The user acquiring access.
     *
     * @param connectionGroup
     *     The connection group being accessed.
     *
     * @throws GuacamoleException
     *     If access is denied to the given user for any reason.
     */
    protected abstract void acquire(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) throws GuacamoleException;

    /**
     * Releases possibly-exclusive access to the given connection group on
     * behalf of the given user. If the given user did not already have access,
     * the behavior of this function is undefined.
     *
     * @param user
     *     The user releasing access.
     *
     * @param connectionGroup
     *     The connection group being released.
     */
    protected abstract void release(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup);

    /**
     * Saves the given ActiveConnectionRecord to the database. The end date of
     * the saved record will be populated with the current time.
    private void saveConnectionRecord(ActiveConnectionRecord record) {
        // Get associated connection
        ModeledConnection connection = record.getConnection();
        
        recordModel.setConnectionIdentifier(connection.getIdentifier());
    private GuacamoleSocket getUnconfiguredGuacamoleSocket(Runnable socketClosedCallback)
            return new ManagedInetGuacamoleSocket(
                environment.getRequiredProperty(Environment.GUACD_PORT),
                socketClosedCallback
        return new ManagedInetGuacamoleSocket(
            environment.getRequiredProperty(Environment.GUACD_PORT),
            socketClosedCallback

    /**
     * Task which handles cleanup of a connection associated with some given
     * ActiveConnectionRecord.
     */
    private class ConnectionCleanupTask implements Runnable {

        /**
         * Whether this task has run.
         */
        private final AtomicBoolean hasRun = new AtomicBoolean(false);

        /**
         * The ActiveConnectionRecord whose connection will be cleaned up once
         * this task runs.
         */
        private final ActiveConnectionRecord activeConnection;

        /**
         * Creates a new task which automatically cleans up after the
         * connection associated with the given ActiveConnectionRecord. The
         * connection and parent group will be removed from the maps of active
         * connections and groups, and exclusive access will be released.
         *
         * @param activeConnection
         *     The ActiveConnectionRecord whose associated connection should be
         *     cleaned up once this task runs.
         */
        public ConnectionCleanupTask(ActiveConnectionRecord activeConnection) {
            this.activeConnection = activeConnection;
        }
        
        @Override
        public void run() {

            // Only run once
            if (!hasRun.compareAndSet(false, true))
                return;

            // Get original user and connection
            AuthenticatedUser user = activeConnection.getUser();
            ModeledConnection connection = activeConnection.getConnection();

            // Get associated identifiers
            String identifier = connection.getIdentifier();
            String parentIdentifier = connection.getParentIdentifier();

            // Release connection
            activeConnections.remove(identifier, activeConnection);
            activeConnectionGroups.remove(parentIdentifier, activeConnection);
            release(user, connection);

            // Release any associated group
            if (activeConnection.hasBalancingGroup())
                release(user, activeConnection.getBalancingGroup());
            
            // Save history record to database
            saveConnectionRecord(activeConnection);

        }

    }

    private GuacamoleSocket getGuacamoleSocket(ActiveConnectionRecord activeConnection,
            GuacamoleClientInformation info)
        ModeledConnection connection = activeConnection.getConnection();
        
        // Record new active connection
        Runnable cleanupTask = new ConnectionCleanupTask(activeConnection);
        activeConnections.put(connection.getIdentifier(), activeConnection);
        activeConnectionGroups.put(connection.getParentIdentifier(), activeConnection);
                getUnconfiguredGuacamoleSocket(cleanupTask),
                getGuacamoleConfiguration(activeConnection.getUser(), connection),
            );
        // Execute cleanup if socket could not be created
            cleanupTask.run();
    /**
     * Returns a list of all balanced connections within a given connection
     * group. If the connection group is not balancing, or it contains no
     * connections, an empty list is returned.
     *
     * @param user
     *     The user on whose behalf the balanced connections within the given
     *     connection group are being retrieved.
     *
     * @param connectionGroup
     *     The connection group to retrieve the balanced connections of.
     *
     * @return
     *     A list containing all balanced connections within the given group,
     *     or an empty list if there are no such connections.
     */
    private List<ModeledConnection> getBalancedConnections(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) {

        // If not a balancing group, there are no balanced connections
        if (connectionGroup.getType() != ConnectionGroup.Type.BALANCING)
            return Collections.EMPTY_LIST;

        // If group has no children, there are no balanced connections
        Collection<String> identifiers = connectionMapper.selectIdentifiersWithin(connectionGroup.getIdentifier());
        if (identifiers.isEmpty())
            return Collections.EMPTY_LIST;

        // Retrieve all children
        Collection<ConnectionModel> models = connectionMapper.select(identifiers);
        List<ModeledConnection> connections = new ArrayList<ModeledConnection>(models.size());

        // Convert each retrieved model to a modeled connection
        for (ConnectionModel model : models) {
            ModeledConnection connection = connectionProvider.get();
            connection.init(user, model);
            connections.add(connection);
        }

        return connections;
        
    }

        return getGuacamoleSocket(new ActiveConnectionRecord(user, connection), info);
        // If group has no associated balanced connections, cannot connect
        List<ModeledConnection> connections = getBalancedConnections(user, connectionGroup);
        if (connections.isEmpty())
        // Acquire group
        acquire(user, connectionGroup);
        return getGuacamoleSocket(new ActiveConnectionRecord(user, connectionGroup, connection), info);
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
     * The balancing group from which the associated connection was chosen, if
     * any. If no balancing group was used, this will be null.
     */
    private final ModeledConnectionGroup balancingGroup;

    /**
     * The connection associated with this connection record.
     */
    private final ModeledConnection connection;

    /**
     * Creates a new connection record associated with the given user,
     * connection, and balancing connection group. The given balancing
     * connection group MUST be the connection group from which the given
     * connection was chosen. The start date of this connection record will be
     * the time of its creation.
     *
     * @param balancingGroup
     *     The balancing group from which the given connection was chosen.
     *
     * @param connection
     *     The connection to associate with this connection record.
    public ActiveConnectionRecord(AuthenticatedUser user,
            ModeledConnectionGroup balancingGroup,
            ModeledConnection connection) {
        this.balancingGroup = balancingGroup;
        this.connection = connection;
    }

    /**
     * Creates a new connection record associated with the given user and
     * connection. The start date of this connection record will be the time of
     * its creation.
     *
     * @param user
     *     The user that connected to the connection associated with this
     *     connection record.
     *
     * @param connection
     *     The connection to associate with this connection record.
     */
    public ActiveConnectionRecord(AuthenticatedUser user,
            ModeledConnection connection) {
        this(user, null, connection);
    /**
     * Returns the balancing group from which the connection associated with
     * this connection record was chosen.
     *
     * @return
     *     The balancing group from which the connection associated with this
     *     connection record was chosen.
     */
    public ModeledConnectionGroup getBalancingGroup() {
        return balancingGroup;
    }

    /**
     * Returns the connection associated with this connection record.
     *
     * @return
     *     The connection associated with this connection record.
     */
    public ModeledConnection getConnection() {
        return connection;
    }

    /**
     * Returns whether the connection associated with this connection record
     * was chosen from a balancing group.
     *
     * @return
     *     true if the connection associated with this connection record was
     *     chosen from a balancing group, false otherwise.
     */
    public boolean hasBalancingGroup() {
        return balancingGroup != null;
    }
    
import java.util.Arrays;
import java.util.Comparator;
import org.glyptodon.guacamole.GuacamoleClientTooManyException;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
 * per-user basis. Each connection or group may be used concurrently any number
 * of times, but each concurrent use must be associated with a different user.

    /**
     * The set of all active user/connection group pairs.
     */
    private final Set<Seat> activeGroupSeats =
            Collections.newSetFromMap(new ConcurrentHashMap<Seat, Boolean>());

        // Sort connections in ascending order of usage
        ModeledConnection[] sortedConnections = connections.toArray(new ModeledConnection[connections.size()]);
        Arrays.sort(sortedConnections, new Comparator<ModeledConnection>() {

            @Override
            public int compare(ModeledConnection a, ModeledConnection b) {

                return getActiveConnections(a).size()
                     - getActiveConnections(b).size();

            }

        });
        for (ModeledConnection connection : sortedConnections) {
    @Override
    protected void acquire(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) throws GuacamoleException {

        // Do not allow duplicate use of connection groups
        Seat seat = new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier());
        if (!activeGroupSeats.add(seat))
            throw new GuacamoleClientTooManyException("Cannot connect. Connection group already in use by this user.");

    }

    @Override
    protected void release(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) {
        activeGroupSeats.remove(new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier()));
    }

import org.glyptodon.guacamole.GuacamoleClientTooManyException;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
 * of any connection at any time. Concurrent usage of connections is not
 * allowed, and concurrent usage of connection groups is allowed only between
 * different users.

    /**
     * The set of all active user/connection group pairs.
     */
    private final Set<Seat> activeGroupSeats =
            Collections.newSetFromMap(new ConcurrentHashMap<Seat, Boolean>());
   
    @Override
    protected void acquire(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) throws GuacamoleException {

        // Do not allow duplicate use of connection groups
        Seat seat = new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier());
        if (!activeGroupSeats.add(seat))
            throw new GuacamoleClientTooManyException("Cannot connect. Connection group already in use by this user.");

    }

    @Override
    protected void release(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) {
        activeGroupSeats.remove(new Seat(user.getUser().getIdentifier(), connectionGroup.getIdentifier()));
    }

import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
    @Override
    protected void acquire(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) throws GuacamoleException {
        // Do nothing
    }

    @Override
    protected void release(AuthenticatedUser user,
            ModeledConnectionGroup connectionGroup) {
        // Do nothing
    }

import org.glyptodon.guacamole.GuacamoleUnsupportedException;
    protected void beforeCreate(AuthenticatedUser user, UserModel model)
        super.beforeCreate(user, model);
        
    protected void beforeUpdate(AuthenticatedUser user,
        super.beforeUpdate(user, model);
        
    }
    @Override
    protected void beforeDelete(AuthenticatedUser user, String identifier) throws GuacamoleException {

        super.beforeDelete(user, identifier);

        // Do not allow users to delete themselves
        if (identifier.equals(user.getUser().getIdentifier()))
            throw new GuacamoleUnsupportedException("Deleting your own user is not allowed.");

import org.glyptodon.guacamole.auth.jdbc.socket.BalancedGuacamoleSocketService;
                return BalancedGuacamoleSocketService.class;
 * Copyright (C) 2015 Glyptodon LLC
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.core.Context;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
     * The authentication provider used to authenticating a user.
     */
    @Inject
    private AuthenticationProvider authProvider;
    
    /**
        
        // A user may not use this endpoint to modify himself
        if (userContext.self().getIdentifier().equals(user.getUsername())) {
            throw new HTTPException(Response.Status.FORBIDDEN,
                    "Permission denied.");
        }
     * Updates the password for an individual existing user.
     *
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param username
     *     The username of the user to update.
     *
     * @param userPasswordUpdate
     *     The object containing the old password for the user, as well as the
     *     new password to set for that user.
     *
     * @param request
     *     The HttpServletRequest associated with the password update attempt.
     *
     * @throws GuacamoleException
     *     If an error occurs while updating the user's password.
     */
    @PUT
    @Path("/{username}/password")
    @AuthProviderRESTExposure
    public void updatePassword(@QueryParam("token") String authToken,
            @PathParam("username") String username, 
            APIUserPasswordUpdate userPasswordUpdate,
            @Context HttpServletRequest request) throws GuacamoleException {

        UserContext userContext = authenticationService.getUserContext(authToken);
        
        // Build credentials
        Credentials credentials = new Credentials();
        credentials.setUsername(username);
        credentials.setPassword(userPasswordUpdate.getOldPassword());
        credentials.setRequest(request);
        credentials.setSession(request.getSession(true));
        
        // Verify that the old password was correct 
        if (authProvider.getUserContext(credentials) == null) {
            throw new HTTPException(Response.Status.FORBIDDEN,
                    "Permission denied.");
        }
        
        // Get the user directory
        Directory<User> userDirectory = userContext.getUserDirectory();
        
        // Get the user that we want to updates
        User user = retrievalService.retrieveUser(userContext, username);
        
        // Set password to the newly provided one
        user.setPassword(userPasswordUpdate.getNewPassword());
        
        // Update the user
        userDirectory.update(user);
        
    }
    
    /**
     * Returns a collection of permissions that should be granted due to the
     * creation of the given object. These permissions need not be granted
     * solely to the user creating the object.
     * 
     * @param user
     *     The user creating the object.
     * 
     * @param model
     *     The object being created.
     * 
     * @return
     *     The collection of implicit permissions that should be granted due to
     *     the creation of the given object.
     */
    protected Collection<ObjectPermissionModel> getImplicitPermissions(AuthenticatedUser user,
            ModelType model) {
        
        // Build list of implicit permissions
        Collection<ObjectPermissionModel> implicitPermissions =
                new ArrayList<ObjectPermissionModel>(IMPLICIT_OBJECT_PERMISSIONS.length);

        UserModel userModel = user.getUser().getModel();
        for (ObjectPermission.Type permission : IMPLICIT_OBJECT_PERMISSIONS) {

            // Create model which grants this permission to the current user
            ObjectPermissionModel permissionModel = new ObjectPermissionModel();
            permissionModel.setUserID(userModel.getObjectID());
            permissionModel.setUsername(userModel.getIdentifier());
            permissionModel.setType(permission);
            permissionModel.setObjectIdentifier(model.getIdentifier());

            // Add permission
            implicitPermissions.add(permissionModel);

        }
        
        return implicitPermissions;

    }
    
    /**
        getPermissionMapper().insert(getImplicitPermissions(user, model));
import org.glyptodon.guacamole.auth.jdbc.permission.ObjectPermissionModel;
import org.glyptodon.guacamole.net.auth.permission.ObjectPermission;
    
    /**
     * All user permissions which are implicitly granted to the new user upon
     * creation.
     */
    private static final ObjectPermission.Type[] IMPLICIT_USER_PERMISSIONS = {
        ObjectPermission.Type.READ,
        ObjectPermission.Type.UPDATE
    };
    
    protected Collection<ObjectPermissionModel>
        getImplicitPermissions(AuthenticatedUser user, UserModel model) {
            
        // Get original set of implicit permissions
        Collection<ObjectPermissionModel> implicitPermissions = super.getImplicitPermissions(user, model);
        
        // Grant implicit permissions to the new user
        for (ObjectPermission.Type permissionType : IMPLICIT_USER_PERMISSIONS) {
            
            ObjectPermissionModel permissionModel = new ObjectPermissionModel();
            permissionModel.setUserID(model.getObjectID());
            permissionModel.setUsername(model.getIdentifier());
            permissionModel.setType(permissionType);
            permissionModel.setObjectIdentifier(model.getIdentifier());

            // Add new permission to implicit permission set 
            implicitPermissions.add(permissionModel);
            
        }
        
        return implicitPermissions;
    }
        
    @Override
 * Copyright (C) 2015 Glyptodon LLC
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.core.Context;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
     * The authentication provider used to authenticating a user.
     */
    @Inject
    private AuthenticationProvider authProvider;
    
    /**
        
        // A user may not use this endpoint to modify himself
        if (userContext.self().getIdentifier().equals(user.getUsername())) {
            throw new HTTPException(Response.Status.FORBIDDEN,
                    "Permission denied.");
        }
     * Updates the password for an individual existing user.
     *
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param username
     *     The username of the user to update.
     *
     * @param userPasswordUpdate
     *     The object containing the old password for the user, as well as the
     *     new password to set for that user.
     *
     * @param request
     *     The HttpServletRequest associated with the password update attempt.
     *
     * @throws GuacamoleException
     *     If an error occurs while updating the user's password.
     */
    @PUT
    @Path("/{username}/password")
    @AuthProviderRESTExposure
    public void updatePassword(@QueryParam("token") String authToken,
            @PathParam("username") String username, 
            APIUserPasswordUpdate userPasswordUpdate,
            @Context HttpServletRequest request) throws GuacamoleException {

        UserContext userContext = authenticationService.getUserContext(authToken);
        
        // Build credentials
        Credentials credentials = new Credentials();
        credentials.setUsername(username);
        credentials.setPassword(userPasswordUpdate.getOldPassword());
        credentials.setRequest(request);
        credentials.setSession(request.getSession(true));
        
        // Verify that the old password was correct 
        if (authProvider.getUserContext(credentials) == null) {
            throw new HTTPException(Response.Status.FORBIDDEN,
                    "Permission denied.");
        }
        
        // Get the user directory
        Directory<User> userDirectory = userContext.getUserDirectory();
        
        // Get the user that we want to updates
        User user = retrievalService.retrieveUser(userContext, username);
        
        // Set password to the newly provided one
        user.setPassword(userPasswordUpdate.getNewPassword());
        
        // Update the user
        userDirectory.update(user);
        
    }
    
    /**
import java.util.ArrayList;
    public List<APIConnectionRecord> getConnectionHistory(@QueryParam("token") String authToken, 
        // Retrieve the requested connection

        // Retrieve the requested connection's history
        List<APIConnectionRecord> apiRecords = new ArrayList<APIConnectionRecord>();
        for (ConnectionRecord record : connection.getHistory())
            apiRecords.add(new APIConnectionRecord(record));

        // Return the converted history
        return apiRecords;
import java.util.ArrayList;
    public List<APIConnectionRecord> getConnectionHistory(@QueryParam("token") String authToken, 
        // Retrieve the requested connection

        // Retrieve the requested connection's history
        List<APIConnectionRecord> apiRecords = new ArrayList<APIConnectionRecord>();
        for (ConnectionRecord record : connection.getHistory())
            apiRecords.add(new APIConnectionRecord(record));

        // Return the converted history
        return apiRecords;
import org.glyptodon.guacamole.net.GuacamoleSocket;
    public String getRemoteHost() {
        // STUB
        return "STUB";
    }

    @Override
    @Override
    public GuacamoleSocket getActiveSocket() {
        return null;
    }

import org.glyptodon.guacamole.net.GuacamoleSocket;
    public String getRemoteHost() {
        // STUB
        return "STUB";
    }

    @Override
    @Override
    public GuacamoleSocket getActiveSocket() {
        // STUB
        return null;
    }

import java.util.Collection;
import java.util.Collections;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
    @Override
    public Collection<ConnectionRecord> getActiveConnections() throws GuacamoleException {
        // STUB
        return Collections.EMPTY_LIST;
    }

import org.glyptodon.guacamole.net.GuacamoleSocket;
     * Returns the hostname or IP address of the remote host that used the
     * connection associated with this record, if known. If the hostname or IP
     * address is not known, null is returned.
     *
     * @return
     *     The hostname or IP address of the remote host, or null if this
     *     information is not available.
     */
    public String getRemoteHost();

    /**
    /**
     * Returns the connected GuacamoleSocket of the connection associated with
     * this record, if any. If the connection is not active, or access to
     * the socket is denied, null is returned.
     *
     * @return
     *     The connected GuacamoleSocket, if any, or null if the connection is
     *     not active or permission is denied.
     */
    public GuacamoleSocket getActiveSocket();

import java.util.Collection;
    /**
     * Returns a collection of connection records associated with all active
     * connections to which the current user has access. For an administrative
     * user, this may include connections associated with other users.
     *
     * @return
     *     A collection of all connection records associated with active
     *     connections to which the current user has access.
     *
     * @throws GuacamoleException
     *     If an error occurs while reading active connection records, or if
     *     permission is denied.
     */
    Collection<ConnectionRecord> getActiveConnections()
            throws GuacamoleException;

import org.glyptodon.guacamole.net.auth.ConnectionRecord;
    @Override
    public Collection<ConnectionRecord> getActiveConnections()
            throws GuacamoleException {
        return Collections.EMPTY_LIST;
    }

     * The host from which the connection originated, if known.
     */
    private final String remoteHost;
    
    /**
        this.startDate  = record.getStartDate();
        this.endDate    = record.getEndDate();
        this.remoteHost = record.getRemoteHost();
        this.username   = record.getUsername();
        this.active     = record.isActive();
     * Returns the remote host from which this connection originated.
     *
     * @return
     *     The remote host from which this connection originated.
     */
    public String getRemoteHost() {
        return remoteHost;
    }

    /**
import org.glyptodon.guacamole.net.basic.rest.tunnel.TunnelRESTService;
        bind(TunnelRESTService.class);
    public String getIdentifier() {
        return model.getConnectionIdentifier();
    }

    @Override

    @Override
    public String getIdentifier() {
        return connection.getIdentifier();
    }
     * Returns the identifier of the connection associated with this connection
     * record.
     *
     * @return
     *     The identifier of the connection associated with this connection
     *     record.
     */
    public String getIdentifier();
    
    /**
     * The identifier of the connection associated with this tunnel.
     */
    private final String identifier;
    
    /**
        this.identifier = record.getIdentifier();
     * Returns the identifier of the connection associated with this tunnel.
     *
     * @return
     *     The identifier of the connection associated with this tunnel.
     */
    public String getIdentifier() {
        return identifier;
    }
    
    /**
                connections = Collections.synchronizedSet(Collections.newSetFromMap(new LinkedHashMap<ConnectionRecord, Boolean>()));
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
     * All records associated with active connections.
     */
    private final Set<ConnectionRecord> activeConnectionRecords =
            Collections.newSetFromMap(new ConcurrentHashMap<ConnectionRecord, Boolean>());
    
    /**
            activeConnectionRecords.remove(activeConnection);
        activeConnectionRecords.add(activeConnection);
    public Collection<ConnectionRecord> getActiveConnections(AuthenticatedUser user)
        throws GuacamoleException {

        // Only administrators may see all active connections
        if (!user.getUser().isAdministrator())
            return Collections.EMPTY_LIST;

        return Collections.unmodifiableCollection(activeConnectionRecords);

    }

    @Override
     * Returns a connection containing connection records representing all
     * currently-active connections visible by the given user.
     *
     * @param user
     *     The user retrieving active connections.
     *
     * @return
     *     A collection containing connection records representing all
     *     currently-active connections.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving all active connections, or if
     *     permission is denied.
     */
    public Collection<ConnectionRecord> getActiveConnections(AuthenticatedUser user)
            throws GuacamoleException;

    /**
     *     A collection containing connection records representing all
import org.glyptodon.guacamole.auth.jdbc.socket.GuacamoleSocketService;
     * Service for creating and tracking sockets.
     */
    @Inject
    private GuacamoleSocketService socketService;

    /**
        return socketService.getActiveConnections(getCurrentUser());
     * @param activeConnection
     *     The active connection record of the connection in use.
    private GuacamoleSocket assignGuacamoleSocket(ActiveConnectionRecord activeConnection,

            // Obtain socket which will automatically run the cleanup task
            GuacamoleSocket socket = new ConfiguredGuacamoleSocket(

            // Assign and return new socket
            activeConnection.setActiveSocket(socket);
            return socket;
            
        return assignGuacamoleSocket(new ActiveConnectionRecord(user, connection), info);
        return assignGuacamoleSocket(new ActiveConnectionRecord(user, connectionGroup, connection), info);
     * The GuacamoleSocket used by the connection associated with this
     * connection record.
     */
    private GuacamoleSocket socket;
    
    /**
        return socket;
    }

    /**
     * Associates the given GuacamoleSocket with this connection record.
     *
     * @param socket
     *     The GuacamoleSocket to associate with this connection record.
     */
    public void setActiveSocket(GuacamoleSocket socket) {
        this.socket = socket;
    public GuacamoleSocket getSocket() {
            activeConnection.setSocket(socket);
    public GuacamoleSocket getSocket() {
    public void setSocket(GuacamoleSocket socket) {
    public GuacamoleSocket getSocket();
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     *     A connected GuacamoleTunnel associated with a newly-established
    public GuacamoleTunnel connect(AuthenticatedUser user,
            return socketService.getGuacamoleTunnel(user, connection, info);
import org.glyptodon.guacamole.net.GuacamoleTunnel;
    public GuacamoleTunnel connect(GuacamoleClientInformation info) throws GuacamoleException {
import org.glyptodon.guacamole.net.GuacamoleTunnel;
    public GuacamoleTunnel getTunnel() {
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     *     A connected GuacamoleTunnel associated with a newly-established
    public GuacamoleTunnel connect(AuthenticatedUser user,
            return socketService.getGuacamoleTunnel(user, connectionGroup, info);
import org.glyptodon.guacamole.net.GuacamoleTunnel;
    public GuacamoleTunnel connect(GuacamoleClientInformation info)
import org.glyptodon.guacamole.net.GuacamoleTunnel;
    public GuacamoleTunnel connect(GuacamoleClientInformation info)
import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.SynchronizedGuacamoleTunnel;
     * Creates a tunnel for the given user which connects to the given
     *     A new GuacamoleTunnel which is configured and connected to the given
    private GuacamoleTunnel assignGuacamoleTunnel(ActiveConnectionRecord activeConnection,
            // Assign and return new tunnel 
            GuacamoleTunnel tunnel = new SynchronizedGuacamoleTunnel(socket);
            activeConnection.setTunnel(tunnel);
            return tunnel;
    public GuacamoleTunnel getGuacamoleTunnel(final AuthenticatedUser user,
        return assignGuacamoleTunnel(new ActiveConnectionRecord(user, connection), info);
    public GuacamoleTunnel getGuacamoleTunnel(AuthenticatedUser user,
        return assignGuacamoleTunnel(new ActiveConnectionRecord(user, connectionGroup, connection), info);
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     * The GuacamoleTunnel used by the connection associated with this
    private GuacamoleTunnel tunnel;
    public GuacamoleTunnel getTunnel() {
        return tunnel;
     * Associates the given GuacamoleTunnel with this connection record.
     * @param tunnel
     *     The GuacamoleTunnel to associate with this connection record.
    public void setTunnel(GuacamoleTunnel tunnel) {
        this.tunnel = tunnel;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     *     A new GuacamoleTunnel which is configured and connected to the given
    GuacamoleTunnel getGuacamoleTunnel(AuthenticatedUser user,
     *     A new GuacamoleTunnel which is configured and connected to the given
    GuacamoleTunnel getGuacamoleTunnel(AuthenticatedUser user,
    public Collection<ConnectionRecord> getActiveConnections()
            throws GuacamoleException {
    @Override
    public ConnectionRecord getActiveConnection(String tunnelUUID)
            throws GuacamoleException {
        // STUB
        return null;
    }

 * Copyright (C) 2015 Glyptodon LLC
public interface GuacamoleTunnel {
    GuacamoleReader acquireReader();
    void releaseReader();
    public boolean hasQueuedReaderThreads();
    public GuacamoleWriter acquireWriter();
    public void releaseWriter();
    public boolean hasQueuedWriterThreads();
    public UUID getUUID();
    public GuacamoleSocket getSocket();
    public void close() throws GuacamoleException;
    public boolean isOpen();
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     *     A fully-established GuacamoleTunnel.
    public GuacamoleTunnel connect(GuacamoleClientInformation info)
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     * Returns the connected GuacamoleTunnel of the connection associated with
     *     The connected GuacamoleTunnel, if any, or null if the connection is
    public GuacamoleTunnel getTunnel();
    /**
     * Returns the connection record associated with the active connection
     * having the tunnel with the given UUID. The active connection will only
     * be returned if the current user has access.
     *
     * @param tunnelUUID
     *     The UUID of the tunnel whose associated connection record should be
     *     returned.
     *
     * @return
     *     The connection record associated with the active connection having
     *     the tunnel with the given UUID, if any, or null if no such
     *     connection exists.
     *
     * @throws GuacamoleException
     *     If an error occurs while reading active connection records, or if
     *     permission is denied.
     */
    ConnectionRecord getActiveConnection(String tunnelUUID)
            throws GuacamoleException;

import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.SynchronizedGuacamoleTunnel;
    public GuacamoleTunnel connect(GuacamoleClientInformation info)
        GuacamoleSocket socket;
        
            socket = new ConfiguredGuacamoleSocket(
        // Otherwise, just connect directly via TCP
        else
            socket = new ConfiguredGuacamoleSocket(
                new InetGuacamoleSocket(hostname, port),
                config, info
            );
        return new SynchronizedGuacamoleTunnel(socket);
        
import org.glyptodon.guacamole.net.GuacamoleTunnel;
    public GuacamoleTunnel connect(GuacamoleClientInformation info) 
    @Override
    public ConnectionRecord getActiveConnection(String tunnelUUID)
            throws GuacamoleException {
        return null;
    }

import org.glyptodon.guacamole.net.DelegatingGuacamoleTunnel;
        GuacamoleTunnel tunnel;
                // Connect tunnel
                tunnel = connection.connect(info);
                // Connect tunnel
                tunnel = group.connect(info);
        // Track tunnel open/close
        GuacamoleTunnel monitoredTunnel = new DelegatingGuacamoleTunnel(tunnel) {
        if (!notifyConnect(session, monitoredTunnel)) {
        session.addTunnel(monitoredTunnel);
        return monitoredTunnel;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
    public GuacamoleTunnel connect(GuacamoleClientInformation info) throws GuacamoleException {
import org.glyptodon.guacamole.net.GuacamoleTunnel;
    public GuacamoleTunnel connect(GuacamoleClientInformation info) throws GuacamoleException {
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
    private final Class<? extends GuacamoleTunnelService> tunnelServiceClass;
     * @param tunnelServiceClass
            Class<? extends GuacamoleTunnelService> tunnelServiceClass) {
        this.tunnelServiceClass = tunnelServiceClass;
        bind(GuacamoleTunnelService.class).to(tunnelServiceClass);
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
    private GuacamoleTunnelService tunnelService;
            List<ConnectionRecord> records = new ArrayList<ConnectionRecord>(tunnelService.getActiveConnections(connection));
            return tunnelService.getGuacamoleTunnel(user, connection, info);
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
    private GuacamoleTunnelService tunnelService;
        return tunnelService.getActiveConnections(this).size();
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
    private GuacamoleTunnelService tunnelService;
            return tunnelService.getGuacamoleTunnel(user, connectionGroup, info);
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
    private GuacamoleTunnelService tunnelService;
        return tunnelService.getActiveConnections(this).size();
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/AbstractGuacamoleTunnelService.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 * Base implementation of the GuacamoleTunnelService, handling retrieval of
public abstract class AbstractGuacamoleTunnelService implements GuacamoleTunnelService {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/ActiveConnectionMultimap.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/ActiveConnectionRecord.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/BalancedGuacamoleTunnelService.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 * GuacamoleTunnelService implementation which allows only one user per
public class BalancedGuacamoleTunnelService
    extends AbstractGuacamoleTunnelService {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/GuacamoleTunnelService.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
public interface GuacamoleTunnelService {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/ManagedInetGuacamoleSocket.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/MultiseatGuacamoleTunnelService.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 * GuacamoleTunnelService implementation which restricts concurrency only on a
public class MultiseatGuacamoleTunnelService
    extends AbstractGuacamoleTunnelService {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/Seat.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/SingleSeatGuacamoleTunnelService.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 * GuacamoleTunnelService implementation which allows exactly one use
public class SingleSeatGuacamoleTunnelService
    extends AbstractGuacamoleTunnelService {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/UnrestrictedGuacamoleTunnelService.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 * GuacamoleTunnelService implementation which imposes no restrictions
public class UnrestrictedGuacamoleTunnelService
    extends AbstractGuacamoleTunnelService {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/package-info.java
 * Classes related to obtaining/configuring Guacamole tunnels, and restricting
 * access to those tunnels.
package org.glyptodon.guacamole.auth.jdbc.tunnel;
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
    private GuacamoleTunnelService tunnelService;
        return tunnelService.getActiveConnections(getCurrentUser());
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.MultiseatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.BalancedGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.SingleSeatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.UnrestrictedGuacamoleTunnelService;
    private Class<? extends GuacamoleTunnelService>
                return SingleSeatGuacamoleTunnelService.class;
                return BalancedGuacamoleTunnelService.class;
                return MultiseatGuacamoleTunnelService.class;
                return UnrestrictedGuacamoleTunnelService.class;
import org.glyptodon.guacamole.auth.jdbc.tunnel.BalancedGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.MultiseatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.SingleSeatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.UnrestrictedGuacamoleTunnelService;
    private Class<? extends GuacamoleTunnelService>
                return SingleSeatGuacamoleTunnelService.class;
                return BalancedGuacamoleTunnelService.class;
                return MultiseatGuacamoleTunnelService.class;
                return UnrestrictedGuacamoleTunnelService.class;
     * 
     * @param uuid
     *     The UUID of the associated GuacamoleTunnel.
    public APITunnel(ConnectionRecord record, String uuid) {
        this.uuid       = uuid;
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.GuacamoleTunnel;

        for (ConnectionRecord record : userContext.getActiveConnections()) {

            // Locate associated tunnel and UUID
            GuacamoleTunnel tunnel = record.getTunnel();
            if (tunnel != null)
                apiTunnels.add(new APITunnel(record, tunnel.getUUID().toString()));

        }
        // Retrieve specified tunnel
        ConnectionRecord record = userContext.getActiveConnection(tunnelUUID);
        if (record == null)
            throw new GuacamoleResourceNotFoundException("No such tunnel: \""  tunnelUUID  "\"");

        // Close tunnel, if not already closed
        GuacamoleTunnel tunnel = record.getTunnel();
        if (tunnel != null && tunnel.isOpen())
            tunnel.close();

        return null;
        return user.getRemoteHost();
import javax.servlet.http.HttpServletRequest;
     * The host from which this user authenticated.
     */
    private final String remoteHost;

    /**
     * Derives the remote host of the authenticating user from the given
     * credentials object.
     *
     * @param credentials
     *     The credentials to derive the remote host from.
     *
     * @return
     *     The remote host from which the user with the given credentials is
     *     authenticating.
     */
    private static String getRemoteHost(Credentials credentials) {
        HttpServletRequest request = credentials.getRequest();
        return request.getRemoteAddr();
    }
    
    /**
        this.remoteHost = getRemoteHost(credentials);
    /**
     * Returns the host from which this user authenticated.
     *
     * @return
     *     The host from which this user authenticated.
     */
    public String getRemoteHost() {
        return remoteHost;
    }

    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
    @Override
 b/guacamole-common/src/main/java/org/glyptodon/guacamole/net/AbstractGuacamoleTunnel.java
 * Base GuacamoleTunnel implementation which synchronizes access to the
 * underlying reader and writer with reentrant locks. Implementations need only
 * provide the tunnel's UUID and socket.
public abstract class AbstractGuacamoleTunnel implements GuacamoleTunnel {
     * Guacamole instruction stream associated with the underlying
     * GuacamoleSocket.
    public AbstractGuacamoleTunnel() {
    /**
     * Acquires exclusive read access to the Guacamole instruction stream
     * and returns a GuacamoleReader for reading from that stream.
     *
     * @return A GuacamoleReader for reading from the Guacamole instruction
     *         stream.
     */
        return getSocket().getReader();
    /**
     * Relinquishes exclusive read access to the Guacamole instruction
     * stream. This function should be called whenever a thread finishes using
     * a GuacamoleTunnel's GuacamoleReader.
     */
    /**
     * Returns whether there are threads waiting for read access to the
     * Guacamole instruction stream.
     *
     * @return true if threads are waiting for read access the Guacamole
     *         instruction stream, false otherwise.
     */
    /**
     * Acquires exclusive write access to the Guacamole instruction stream
     * and returns a GuacamoleWriter for writing to that stream.
     *
     * @return A GuacamoleWriter for writing to the Guacamole instruction
     *         stream.
     */
        return getSocket().getWriter();
    /**
     * Relinquishes exclusive write access to the Guacamole instruction
     * stream. This function should be called whenever a thread finishes using
     * a GuacamoleTunnel's GuacamoleWriter.
     */
        getSocket().close();
        return getSocket().isOpen();
import org.glyptodon.guacamole.net.SimpleGuacamoleTunnel;
        return new SimpleGuacamoleTunnel(socket);
import java.util.Map;
     * All active connections through the tunnel having a given UUID.
    private final Map<String, ConnectionRecord> activeTunnels =
            new ConcurrentHashMap<String, ConnectionRecord>();
            activeTunnels.remove(activeConnection.getUUID().toString());
        activeTunnels.put(activeConnection.getUUID().toString(), activeConnection);
            return activeConnection.assignGuacamoleTunnel(socket);
        return Collections.unmodifiableCollection(activeTunnels.values());
    public ConnectionRecord getActiveConnection(AuthenticatedUser user,
            String tunnelUUID) throws GuacamoleException {

        // Only administrators may see all active connections
        if (!user.getUser().isAdministrator())
            return null;

        return activeTunnels.get(tunnelUUID);
        
    }

    @Override
import java.util.UUID;
import org.glyptodon.guacamole.net.AbstractGuacamoleTunnel;
import org.glyptodon.guacamole.net.GuacamoleSocket;
     * The UUID that will be assigned to the underlying tunnel.
     */
    private final UUID uuid = UUID.randomUUID();
    
    /**
     * Associates a new GuacamoleTunnel with this connection record using the
     * given socket.
     * @param socket
     *     The GuacamoleSocket to use to create the tunnel associated with this
     *     connection record.
     * 
     * @return
     *     The newly-created tunnel associated with this connection record.
    public GuacamoleTunnel assignGuacamoleTunnel(final GuacamoleSocket socket) {

        // Create tunnel with given socket
        this.tunnel = new AbstractGuacamoleTunnel() {

            @Override
            public GuacamoleSocket getSocket() {
                return socket;
            }
            
            @Override
            public UUID getUUID() {
                return uuid;
            }

        };

        // Return newly-created tunnel
        return this.tunnel;
        
    /**
     * Returns the UUID of the underlying tunnel. If there is no underlying
     * tunnel, this will be the UUID assigned to the underlying tunnel when the
     * tunnel is set.
     *
     * @return
     *     The current or future UUID of the underlying tunnel.
     */
    public UUID getUUID() {
        return uuid;
    }
    
     * Returns a collection containing connection records representing all
     * Returns the connection records representing the connection associated
     * with the tunnel having the given UUID, if that connection is visible to
     * the given user.
     *
     * @param user
     *     The user retrieving the active connection.
     * 
     * @param tunnelUUID
     *     The UUID of the tunnel associated with the active connection being
     *     retrieved.
     *
     * @return
     *     The active connection associated with the tunnel having the given
     *     UUID, or null if no such connection exists.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving all active connections, or if
     *     permission is denied.
     */
    public ConnectionRecord getActiveConnection(AuthenticatedUser user,
            String tunnelUUID)
            throws GuacamoleException;

    /**
        return tunnelService.getActiveConnection(getCurrentUser(), tunnelUUID);
     * Service for creating and tracking tunnels.
     * Service for creating and tracking tunnels.
     * Service for creating and tracking tunnels.
     * Service for creating and tracking tunnels.
     * Service for creating and tracking tunnels.
    boolean hasQueuedReaderThreads();
    GuacamoleWriter acquireWriter();
    void releaseWriter();
    boolean hasQueuedWriterThreads();
    UUID getUUID();
    GuacamoleSocket getSocket();
    void close() throws GuacamoleException;
    boolean isOpen();
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
    private final Class<? extends GuacamoleTunnelService> tunnelServiceClass;
     * @param tunnelServiceClass
            Class<? extends GuacamoleTunnelService> tunnelServiceClass) {
        this.tunnelServiceClass = tunnelServiceClass;
        bind(GuacamoleTunnelService.class).to(tunnelServiceClass);
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     * Service for creating and tracking tunnels.
    private GuacamoleTunnelService tunnelService;
            List<ConnectionRecord> records = new ArrayList<ConnectionRecord>(tunnelService.getActiveConnections(connection));
     *     A connected GuacamoleTunnel associated with a newly-established
    public GuacamoleTunnel connect(AuthenticatedUser user,
            return tunnelService.getGuacamoleTunnel(user, connection, info);
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     * Service for creating and tracking tunnels.
    private GuacamoleTunnelService tunnelService;
    public GuacamoleTunnel connect(GuacamoleClientInformation info) throws GuacamoleException {
        return tunnelService.getActiveConnections(this).size();
import org.glyptodon.guacamole.net.GuacamoleTunnel;
    public String getIdentifier() {
        return model.getConnectionIdentifier();
    }

    @Override
    public String getRemoteHost() {
        return null;
    }

    @Override
    @Override
    public GuacamoleTunnel getTunnel() {
        return null;
    }

import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     * Service for creating and tracking tunnels.
    private GuacamoleTunnelService tunnelService;
     *     A connected GuacamoleTunnel associated with a newly-established
    public GuacamoleTunnel connect(AuthenticatedUser user,
            return tunnelService.getGuacamoleTunnel(user, connectionGroup, info);
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     * Service for creating and tracking tunnels.
    private GuacamoleTunnelService tunnelService;
    public GuacamoleTunnel connect(GuacamoleClientInformation info)
        return tunnelService.getActiveConnections(this).size();
import org.glyptodon.guacamole.net.GuacamoleTunnel;
    public GuacamoleTunnel connect(GuacamoleClientInformation info)
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/AbstractGuacamoleTunnelService.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
 * Base implementation of the GuacamoleTunnelService, handling retrieval of
public abstract class AbstractGuacamoleTunnelService implements GuacamoleTunnelService {
     * All active connections through the tunnel having a given UUID.
     */
    private final Map<String, ConnectionRecord> activeTunnels =
            new ConcurrentHashMap<String, ConnectionRecord>();
    
    /**
            activeTunnels.remove(activeConnection.getUUID().toString());
     * Creates a tunnel for the given user which connects to the given
     * @param activeConnection
     *     The active connection record of the connection in use.
     *     A new GuacamoleTunnel which is configured and connected to the given
    private GuacamoleTunnel assignGuacamoleTunnel(ActiveConnectionRecord activeConnection,
        activeTunnels.put(activeConnection.getUUID().toString(), activeConnection);

            // Obtain socket which will automatically run the cleanup task
            GuacamoleSocket socket = new ConfiguredGuacamoleSocket(

            // Assign and return new tunnel 
            return activeConnection.assignGuacamoleTunnel(socket);
            
    public Collection<ConnectionRecord> getActiveConnections(AuthenticatedUser user)
        throws GuacamoleException {

        // Only administrators may see all active connections
        if (!user.getUser().isAdministrator())
            return Collections.EMPTY_LIST;

        return Collections.unmodifiableCollection(activeTunnels.values());

    }

    @Override
    public ConnectionRecord getActiveConnection(AuthenticatedUser user,
            String tunnelUUID) throws GuacamoleException {

        // Only administrators may see all active connections
        if (!user.getUser().isAdministrator())
            return null;

        return activeTunnels.get(tunnelUUID);
        
    }

    @Override
    public GuacamoleTunnel getGuacamoleTunnel(final AuthenticatedUser user,
        return assignGuacamoleTunnel(new ActiveConnectionRecord(user, connection), info);
    public GuacamoleTunnel getGuacamoleTunnel(AuthenticatedUser user,
        return assignGuacamoleTunnel(new ActiveConnectionRecord(user, connectionGroup, connection), info);
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/ActiveConnectionMultimap.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
                connections = Collections.synchronizedSet(Collections.newSetFromMap(new LinkedHashMap<ConnectionRecord, Boolean>()));
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/ActiveConnectionRecord.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
import java.util.UUID;
import org.glyptodon.guacamole.net.AbstractGuacamoleTunnel;
import org.glyptodon.guacamole.net.GuacamoleSocket;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     * The UUID that will be assigned to the underlying tunnel.
     */
    private final UUID uuid = UUID.randomUUID();
    
    /**
     * The GuacamoleTunnel used by the connection associated with this
     * connection record.
     */
    private GuacamoleTunnel tunnel;
    
    /**

    @Override
    public String getIdentifier() {
        return connection.getIdentifier();
    }
    public String getRemoteHost() {
        return user.getRemoteHost();
    }

    @Override
    @Override
    public GuacamoleTunnel getTunnel() {
        return tunnel;
    }

    /**
     * Associates a new GuacamoleTunnel with this connection record using the
     * given socket.
     *
     * @param socket
     *     The GuacamoleSocket to use to create the tunnel associated with this
     *     connection record.
     * 
     * @return
     *     The newly-created tunnel associated with this connection record.
     */
    public GuacamoleTunnel assignGuacamoleTunnel(final GuacamoleSocket socket) {

        // Create tunnel with given socket
        this.tunnel = new AbstractGuacamoleTunnel() {

            @Override
            public GuacamoleSocket getSocket() {
                return socket;
            }
            
            @Override
            public UUID getUUID() {
                return uuid;
            }

        };

        // Return newly-created tunnel
        return this.tunnel;
        
    }

    /**
     * Returns the UUID of the underlying tunnel. If there is no underlying
     * tunnel, this will be the UUID assigned to the underlying tunnel when the
     * tunnel is set.
     *
     * @return
     *     The current or future UUID of the underlying tunnel.
     */
    public UUID getUUID() {
        return uuid;
    }
    
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/BalancedGuacamoleTunnelService.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 * GuacamoleTunnelService implementation which allows only one user per
public class BalancedGuacamoleTunnelService
    extends AbstractGuacamoleTunnelService {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/GuacamoleTunnelService.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
import org.glyptodon.guacamole.net.GuacamoleTunnel;
public interface GuacamoleTunnelService {

    /**
     * Returns a collection containing connection records representing all
     * currently-active connections visible by the given user.
     *
     * @param user
     *     The user retrieving active connections.
     *
     * @return
     *     A collection containing connection records representing all
     *     currently-active connections.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving all active connections, or if
     *     permission is denied.
     */
    public Collection<ConnectionRecord> getActiveConnections(AuthenticatedUser user)
            throws GuacamoleException;

    /**
     * Returns the connection records representing the connection associated
     * with the tunnel having the given UUID, if that connection is visible to
     * the given user.
     *
     * @param user
     *     The user retrieving the active connection.
     * 
     * @param tunnelUUID
     *     The UUID of the tunnel associated with the active connection being
     *     retrieved.
     *
     * @return
     *     The active connection associated with the tunnel having the given
     *     UUID, or null if no such connection exists.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving all active connections, or if
     *     permission is denied.
     */
    public ConnectionRecord getActiveConnection(AuthenticatedUser user,
            String tunnelUUID)
            throws GuacamoleException;
     *     A new GuacamoleTunnel which is configured and connected to the given
    GuacamoleTunnel getGuacamoleTunnel(AuthenticatedUser user,
     *     A collection containing connection records representing all
     *     A new GuacamoleTunnel which is configured and connected to the given
    GuacamoleTunnel getGuacamoleTunnel(AuthenticatedUser user,
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/ManagedInetGuacamoleSocket.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/MultiseatGuacamoleTunnelService.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 * GuacamoleTunnelService implementation which restricts concurrency only on a
public class MultiseatGuacamoleTunnelService
    extends AbstractGuacamoleTunnelService {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/Seat.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/SingleSeatGuacamoleTunnelService.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 * GuacamoleTunnelService implementation which allows exactly one use
public class SingleSeatGuacamoleTunnelService
    extends AbstractGuacamoleTunnelService {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/UnrestrictedGuacamoleTunnelService.java
package org.glyptodon.guacamole.auth.jdbc.tunnel;
 * GuacamoleTunnelService implementation which imposes no restrictions
public class UnrestrictedGuacamoleTunnelService
    extends AbstractGuacamoleTunnelService {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/package-info.java
 * Classes related to obtaining/configuring Guacamole tunnels, and restricting
 * access to those tunnels.
package org.glyptodon.guacamole.auth.jdbc.tunnel;
import javax.servlet.http.HttpServletRequest;
     * The host from which this user authenticated.
     */
    private final String remoteHost;

    /**
     * Derives the remote host of the authenticating user from the given
     * credentials object.
     *
     * @param credentials
     *     The credentials to derive the remote host from.
     *
     * @return
     *     The remote host from which the user with the given credentials is
     *     authenticating.
     */
    private static String getRemoteHost(Credentials credentials) {
        HttpServletRequest request = credentials.getRequest();
        return request.getRemoteAddr();
    }
    
    /**
        this.remoteHost = getRemoteHost(credentials);
    /**
     * Returns the host from which this user authenticated.
     *
     * @return
     *     The host from which this user authenticated.
     */
    public String getRemoteHost() {
        return remoteHost;
    }

import java.util.Collection;
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
     * Service for creating and tracking tunnels.
     */
    @Inject
    private GuacamoleTunnelService tunnelService;

    /**
    @Override
    public Collection<ConnectionRecord> getActiveConnections()
            throws GuacamoleException {
        return tunnelService.getActiveConnections(getCurrentUser());
    }

    @Override
    public ConnectionRecord getActiveConnection(String tunnelUUID)
            throws GuacamoleException {
        return tunnelService.getActiveConnection(getCurrentUser(), tunnelUUID);
    }

import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.MultiseatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.BalancedGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.SingleSeatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.UnrestrictedGuacamoleTunnelService;
    private Class<? extends GuacamoleTunnelService>
                return SingleSeatGuacamoleTunnelService.class;
                return BalancedGuacamoleTunnelService.class;
                return MultiseatGuacamoleTunnelService.class;
                return UnrestrictedGuacamoleTunnelService.class;
import org.glyptodon.guacamole.auth.jdbc.tunnel.BalancedGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.MultiseatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.SingleSeatGuacamoleTunnelService;
import org.glyptodon.guacamole.auth.jdbc.tunnel.UnrestrictedGuacamoleTunnelService;
    private Class<? extends GuacamoleTunnelService>
                return SingleSeatGuacamoleTunnelService.class;
                return BalancedGuacamoleTunnelService.class;
                return MultiseatGuacamoleTunnelService.class;
                return UnrestrictedGuacamoleTunnelService.class;
 * Copyright (C) 2015 Glyptodon LLC
public interface GuacamoleTunnel {
    GuacamoleReader acquireReader();
    void releaseReader();
    boolean hasQueuedReaderThreads();
    GuacamoleWriter acquireWriter();
    void releaseWriter();
    boolean hasQueuedWriterThreads();
    UUID getUUID();
    GuacamoleSocket getSocket();
    void close() throws GuacamoleException;
    boolean isOpen();
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     *     A fully-established GuacamoleTunnel.
    public GuacamoleTunnel connect(GuacamoleClientInformation info)
import org.glyptodon.guacamole.net.GuacamoleTunnel;
     * Returns the identifier of the connection associated with this connection
     * record.
     *
     * @return
     *     The identifier of the connection associated with this connection
     *     record.
     */
    public String getIdentifier();
    
    /**
     * Returns the hostname or IP address of the remote host that used the
     * connection associated with this record, if known. If the hostname or IP
     * address is not known, null is returned.
     *
     * @return
     *     The hostname or IP address of the remote host, or null if this
     *     information is not available.
     */
    public String getRemoteHost();

    /**
    /**
     * Returns the connected GuacamoleTunnel of the connection associated with
     * this record, if any. If the connection is not active, or access to
     * the socket is denied, null is returned.
     *
     * @return
     *     The connected GuacamoleTunnel, if any, or null if the connection is
     *     not active or permission is denied.
     */
    public GuacamoleTunnel getTunnel();

import java.util.Collection;
    /**
     * Returns a collection of connection records associated with all active
     * connections to which the current user has access. For an administrative
     * user, this may include connections associated with other users.
     *
     * @return
     *     A collection of all connection records associated with active
     *     connections to which the current user has access.
     *
     * @throws GuacamoleException
     *     If an error occurs while reading active connection records, or if
     *     permission is denied.
     */
    Collection<ConnectionRecord> getActiveConnections()
            throws GuacamoleException;

    /**
     * Returns the connection record associated with the active connection
     * having the tunnel with the given UUID. The active connection will only
     * be returned if the current user has access.
     *
     * @param tunnelUUID
     *     The UUID of the tunnel whose associated connection record should be
     *     returned.
     *
     * @return
     *     The connection record associated with the active connection having
     *     the tunnel with the given UUID, if any, or null if no such
     *     connection exists.
     *
     * @throws GuacamoleException
     *     If an error occurs while reading active connection records, or if
     *     permission is denied.
     */
    ConnectionRecord getActiveConnection(String tunnelUUID)
            throws GuacamoleException;

import org.glyptodon.guacamole.net.GuacamoleTunnel;
import org.glyptodon.guacamole.net.SimpleGuacamoleTunnel;
    public GuacamoleTunnel connect(GuacamoleClientInformation info)
        GuacamoleSocket socket;
        
            socket = new ConfiguredGuacamoleSocket(
        // Otherwise, just connect directly via TCP
        else
            socket = new ConfiguredGuacamoleSocket(
                new InetGuacamoleSocket(hostname, port),
                config, info
            );
        return new SimpleGuacamoleTunnel(socket);
        
import org.glyptodon.guacamole.net.GuacamoleTunnel;
    public GuacamoleTunnel connect(GuacamoleClientInformation info) 
import org.glyptodon.guacamole.net.auth.ConnectionRecord;
    @Override
    public Collection<ConnectionRecord> getActiveConnections()
            throws GuacamoleException {
        return Collections.EMPTY_LIST;
    }

    @Override
    public ConnectionRecord getActiveConnection(String tunnelUUID)
            throws GuacamoleException {
        return null;
    }

import org.glyptodon.guacamole.net.DelegatingGuacamoleTunnel;
        GuacamoleTunnel tunnel;
                // Connect tunnel
                tunnel = connection.connect(info);
                // Connect tunnel
                tunnel = group.connect(info);
        // Track tunnel open/close
        GuacamoleTunnel monitoredTunnel = new DelegatingGuacamoleTunnel(tunnel) {
        if (!notifyConnect(session, monitoredTunnel)) {
        session.addTunnel(monitoredTunnel);
        return monitoredTunnel;
import org.glyptodon.guacamole.net.basic.rest.tunnel.TunnelRESTService;
        bind(TunnelRESTService.class);
     * The host from which the connection originated, if known.
     */
    private final String remoteHost;
    
    /**
        this.startDate  = record.getStartDate();
        this.endDate    = record.getEndDate();
        this.remoteHost = record.getRemoteHost();
        this.username   = record.getUsername();
        this.active     = record.isActive();
     * Returns the remote host from which this connection originated.
     *
     * @return
     *     The remote host from which this connection originated.
     */
    public String getRemoteHost() {
        return remoteHost;
    }

    /**
import org.glyptodon.guacamole.net.GuacamoleTunnel;
    public GuacamoleTunnel connect(GuacamoleClientInformation info) throws GuacamoleException {
import org.glyptodon.guacamole.net.GuacamoleTunnel;
    public GuacamoleTunnel connect(GuacamoleClientInformation info) throws GuacamoleException {
import java.util.ArrayList;
    public Collection<ConnectionRecord> getActiveConnections(Collection<String> tunnelUUIDs)

        // Look up active connections for each given tunnel UUID
        Collection<ConnectionRecord> records = new ArrayList<ConnectionRecord>(tunnelUUIDs.size());
        for (String tunnelUUID : tunnelUUIDs) {

            // Add corresponding record only if it exists
            ConnectionRecord record = tunnelService.getActiveConnection(getCurrentUser(), tunnelUUID);
            if (record != null)
                records.add(record);

        }

        return records;
        
     * Returns the connection records associated with the active connections
     * having the tunnels with the given UUIDs. An active connection will only
     * @param tunnelUUIDs
     *     The UUIDs of the tunnels whose associated connection records should
     *     be returned.
     *     A collection of all connection records associated with the active
     *     connections having the tunnels with the given UUIDs, if any, or an
     *     empty collection if no such connections exist.
    Collection<ConnectionRecord> getActiveConnections(Collection<String> tunnelUUIDs)
    public Collection<ConnectionRecord> getActiveConnections(Collection<String> tunnelUUID)
        return Collections.EMPTY_LIST;
import java.util.Collection;
     * Deletes the tunnels having the given UUIDs, effectively closing the
     * tunnels and killing the associated connections.
     * @param tunnelUUIDs
     *     The UUIDs associated with the tunnels being deleted.
     *     If an error occurs while deleting the tunnels.
    @Path("/")
    public void deleteTunnels(@QueryParam("token") String authToken,
            @QueryParam("tunnelUUID") Collection<String> tunnelUUIDs) 
        // Attempt to get all requested tunnels
        Collection<ConnectionRecord> records = userContext.getActiveConnections(tunnelUUIDs);
        // Close each tunnel, if not already closed
        for (ConnectionRecord record : records) {
            GuacamoleTunnel tunnel = record.getTunnel();
            if (tunnel != null && tunnel.isOpen())
                tunnel.close();

        }
import java.util.HashMap;
import java.util.Map;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
import org.glyptodon.guacamole.net.basic.rest.APIPatch;
import org.glyptodon.guacamole.net.basic.rest.PATCH;
     *     A map of the tunnels of all active connections visible to the
     *     current user, where the key of each entry is the tunnel's UUID.
    public Map<String, APITunnel> getTunnels(@QueryParam("token") String authToken)
        Map<String, APITunnel> apiTunnels = new HashMap<String, APITunnel>();
            if (tunnel != null) {
                APITunnel apiTunnel = new APITunnel(record, tunnel.getUUID().toString());
                apiTunnels.put(apiTunnel.getUUID(), apiTunnel);
            }
     * @param patches
     *     The tunnel patches to apply for this request.
    @PATCH
    public void patchTunnels(@QueryParam("token") String authToken,
            List<APIPatch<String>> patches) throws GuacamoleException {
        // Build list of tunnels to delete
        Collection<String> tunnelUUIDs = new ArrayList<String>(patches.size());
        for (APIPatch<String> patch : patches) {

            // Only remove is supported
            if (patch.getOp() != APIPatch.Operation.remove)
                throw new GuacamoleUnsupportedException("Only the \"remove\" operation is supported when patching tunnels.");

            // Retrieve and validate path
            String path = patch.getPath();
            if (!path.startsWith("/"))
                throw new GuacamoleClientException("Patch paths must start with \"/\".");
            
            // Add UUID
            tunnelUUIDs.add(path.substring(1));
            
        }
        
        Collection<ConnectionRecord> records = userContext.getActiveConnections(tunnelUUIDs);
     * Applies the given tunnel patches. This operation currently only supports
     * deletion of tunnels through the "remove" patch operation. Deleting a
     * tunnel effectively closing the tunnel and kills the associated
     * connection. The path of each patch operation is of the form "/UUID"
     * where UUID is the UUID of the tunnel being modified.
import java.util.ArrayList;
    public Collection<ConnectionRecord> getActiveConnections(Collection<String> tunnelUUIDs)

        // Look up active connections for each given tunnel UUID
        Collection<ConnectionRecord> records = new ArrayList<ConnectionRecord>(tunnelUUIDs.size());
        for (String tunnelUUID : tunnelUUIDs) {

            // Add corresponding record only if it exists
            ConnectionRecord record = tunnelService.getActiveConnection(getCurrentUser(), tunnelUUID);
            if (record != null)
                records.add(record);

        }

        return records;
        
     * Returns the connection records associated with the active connections
     * having the tunnels with the given UUIDs. An active connection will only
     * @param tunnelUUIDs
     *     The UUIDs of the tunnels whose associated connection records should
     *     be returned.
     *     A collection of all connection records associated with the active
     *     connections having the tunnels with the given UUIDs, if any, or an
     *     empty collection if no such connections exist.
    Collection<ConnectionRecord> getActiveConnections(Collection<String> tunnelUUIDs)
    public Collection<ConnectionRecord> getActiveConnections(Collection<String> tunnelUUID)
        return Collections.EMPTY_LIST;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.net.basic.rest.APIPatch;
import org.glyptodon.guacamole.net.basic.rest.PATCH;
     *     A map of the tunnels of all active connections visible to the
     *     current user, where the key of each entry is the tunnel's UUID.
    public Map<String, APITunnel> getTunnels(@QueryParam("token") String authToken)
        Map<String, APITunnel> apiTunnels = new HashMap<String, APITunnel>();
            if (tunnel != null) {
                APITunnel apiTunnel = new APITunnel(record, tunnel.getUUID().toString());
                apiTunnels.put(apiTunnel.getUUID(), apiTunnel);
            }
     * Applies the given tunnel patches. This operation currently only supports
     * deletion of tunnels through the "remove" patch operation. Deleting a
     * tunnel effectively closing the tunnel and kills the associated
     * connection. The path of each patch operation is of the form "/UUID"
     * where UUID is the UUID of the tunnel being modified.
     * @param patches
     *     The tunnel patches to apply for this request.
     *     If an error occurs while deleting the tunnels.
    @PATCH
    @Path("/")
    public void patchTunnels(@QueryParam("token") String authToken,
            List<APIPatch<String>> patches) throws GuacamoleException {
        // Attempt to get all requested tunnels
        // Build list of tunnels to delete
        Collection<String> tunnelUUIDs = new ArrayList<String>(patches.size());
        for (APIPatch<String> patch : patches) {
            // Only remove is supported
            if (patch.getOp() != APIPatch.Operation.remove)
                throw new GuacamoleUnsupportedException("Only the \"remove\" operation is supported when patching tunnels.");

            // Retrieve and validate path
            String path = patch.getPath();
            if (!path.startsWith("/"))
                throw new GuacamoleClientException("Patch paths must start with \"/\".");
            
            // Add UUID
            tunnelUUIDs.add(path.substring(1));
            
        }
        
        // Close each tunnel, if not already closed
        Collection<ConnectionRecord> records = userContext.getActiveConnections(tunnelUUIDs);
        for (ConnectionRecord record : records) {

            GuacamoleTunnel tunnel = record.getTunnel();
            if (tunnel != null && tunnel.isOpen())
                tunnel.close();

        }
import java.util.regex.Pattern;

    /**
     * Regular expression which matches any IPv4 address.
     */
    private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";

    /**
     * Regular expression which matches any IPv6 address.
     */
    private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";

    /**
     * Regular expression which matches any IP address, regardless of version.
     */
    private static final String IP_ADDRESS_REGEX = "("  IPV4_ADDRESS_REGEX  "|"  IPV6_ADDRESS_REGEX  ")";

    /**
     * Pattern which matches valid values of the de-facto standard
     * "X-Forwarded-For" header.
     */
    private static final Pattern X_FORWARDED_FOR = Pattern.compile("^"  IP_ADDRESS_REGEX  "(, "  IP_ADDRESS_REGEX  ")*$");

    /**
     * Returns a formatted string containing an IP address, or list of IP
     * addresses, which represent the HTTP client and any involved proxies. As
     * the headers used to determine proxies can easily be forged, this data is
     * superficially validated to ensure that it at least looks like a list of
     * IPs.
     *
     * @param request
     *     The HTTP request to format.
     *
     * @return
     *     A formatted string containing one or more IP addresses.
     */
    private String getLoggableAddress(HttpServletRequest request) {

        // Log X-Forwarded-For, if present and valid
        String header = request.getHeader("X-Forwarded-For");
        if (header != null && X_FORWARDED_FOR.matcher(header).matches())
            return "["  header  ", "  request.getRemoteAddr()  "]";

        // If header absent or invalid, just use source IP
        return request.getRemoteAddr();

    }

            else {

                // Log successful authentication
                if (userContext != null && logger.isInfoEnabled())
                    logger.info("User \"{}\" successfully authenticated from {}.",
                            userContext.self().getIdentifier(), getLoggableAddress(request));

            }

        if (userContext == null) {

            // Log authentication failures with associated usernames
            if (username != null) {
                if (logger.isWarnEnabled())
                    logger.warn("Authentication attempt from {} for user \"{}\" failed.",
                            getLoggableAddress(request), username);
            }

            // Log anonymous authentication failures
            else if (logger.isDebugEnabled())
                logger.debug("Anonymous authentication attempt from {} failed.",
                        getLoggableAddress(request), username);

        }

import java.util.regex.Matcher;
import java.util.regex.Pattern;
     * Regular expression which matches any IPv4 address.
     */
    private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";

    /**
     * Regular expression which matches any IPv6 address.
     */
    private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";

    /**
     * Regular expression which matches any IP address, regardless of version.
     */
    private static final String IP_ADDRESS_REGEX = "("  IPV4_ADDRESS_REGEX  "|"  IPV6_ADDRESS_REGEX  ")";

    /**
     * Pattern which matches valid values of the de-facto standard
     * "X-Forwarded-For" header.
     */
    private static final Pattern X_FORWARDED_FOR = Pattern.compile("^"  IP_ADDRESS_REGEX  "(, "  IP_ADDRESS_REGEX  ")*$");

    /**
     * credentials object. The remote host is derived from X-Forwarded-For
     * in addition to the actual source IP of the request, and thus is not
     * trusted. The derived remote host is really only useful for logging,
     * unless the server is configured such that X-Forwarded-For is guaranteed
     * to be trustworthy.


        // Use X-Forwarded-For, if present and valid
        String header = request.getHeader("X-Forwarded-For");
        if (header != null) {
            Matcher matcher = X_FORWARDED_FOR.matcher(header);
            if (matcher.matches())
                return matcher.group(1);
        }

        // If header absent or invalid, just use source IP

import java.util.regex.Matcher;
import java.util.regex.Pattern;
     * Regular expression which matches any IPv4 address.
     */
    private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";

    /**
     * Regular expression which matches any IPv6 address.
     */
    private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";

    /**
     * Regular expression which matches any IP address, regardless of version.
     */
    private static final String IP_ADDRESS_REGEX = "("  IPV4_ADDRESS_REGEX  "|"  IPV6_ADDRESS_REGEX  ")";

    /**
     * Pattern which matches valid values of the de-facto standard
     * "X-Forwarded-For" header.
     */
    private static final Pattern X_FORWARDED_FOR = Pattern.compile("^"  IP_ADDRESS_REGEX  "(, "  IP_ADDRESS_REGEX  ")*$");

    /**
     * credentials object. The remote host is derived from X-Forwarded-For
     * in addition to the actual source IP of the request, and thus is not
     * trusted. The derived remote host is really only useful for logging,
     * unless the server is configured such that X-Forwarded-For is guaranteed
     * to be trustworthy.


        // Use X-Forwarded-For, if present and valid
        String header = request.getHeader("X-Forwarded-For");
        if (header != null) {
            Matcher matcher = X_FORWARDED_FOR.matcher(header);
            if (matcher.matches())
                return matcher.group(1);
        }

        // If header absent or invalid, just use source IP

import java.util.regex.Pattern;

    /**
     * Regular expression which matches any IPv4 address.
     */
    private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";

    /**
     * Regular expression which matches any IPv6 address.
     */
    private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";

    /**
     * Regular expression which matches any IP address, regardless of version.
     */
    private static final String IP_ADDRESS_REGEX = "("  IPV4_ADDRESS_REGEX  "|"  IPV6_ADDRESS_REGEX  ")";

    /**
     * Pattern which matches valid values of the de-facto standard
     * "X-Forwarded-For" header.
     */
    private static final Pattern X_FORWARDED_FOR = Pattern.compile("^"  IP_ADDRESS_REGEX  "(, "  IP_ADDRESS_REGEX  ")*$");

    /**
     * Returns a formatted string containing an IP address, or list of IP
     * addresses, which represent the HTTP client and any involved proxies. As
     * the headers used to determine proxies can easily be forged, this data is
     * superficially validated to ensure that it at least looks like a list of
     * IPs.
     *
     * @param request
     *     The HTTP request to format.
     *
     * @return
     *     A formatted string containing one or more IP addresses.
     */
    private String getLoggableAddress(HttpServletRequest request) {

        // Log X-Forwarded-For, if present and valid
        String header = request.getHeader("X-Forwarded-For");
        if (header != null && X_FORWARDED_FOR.matcher(header).matches())
            return "["  header  ", "  request.getRemoteAddr()  "]";

        // If header absent or invalid, just use source IP
        return request.getRemoteAddr();

    }

            else {

                // Log successful authentication
                if (userContext != null && logger.isInfoEnabled())
                    logger.info("User \"{}\" successfully authenticated from {}.",
                            userContext.self().getIdentifier(), getLoggableAddress(request));

            }

        if (userContext == null) {

            // Log authentication failures with associated usernames
            if (username != null) {
                if (logger.isWarnEnabled())
                    logger.warn("Authentication attempt from {} for user \"{}\" failed.",
                            getLoggableAddress(request), username);
            }

            // Log anonymous authentication failures
            else if (logger.isDebugEnabled())
                logger.debug("Anonymous authentication attempt from {} failed.",
                        getLoggableAddress(request), username);

        }

        ExternalType, ModelType extends ObjectModel>
    implements IdentifiableObjectService<InternalType, ExternalType> {
    @Override

    @Override

    @Override
    @Override
    @Override
    @Override
 * manipulating objects that have unique identifiers, such as the objects
 * within directories. This service will automatically enforce the permissions
 * of the current user.
public interface DirectoryObjectService<InternalType, ExternalType> {
     * Retrieves the single object that has the given identifier, if it exists
     * and the user has permission to read it.
     *
     * @param user
     *     The user retrieving the object.
     *
     * @param identifier
     *     The identifier of the object to retrieve.
     *
     * @return
     *     The object having the given identifier, or null if no such object
     *     exists.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the requested object.
    InternalType retrieveObject(AuthenticatedUser user, String identifier)
            throws GuacamoleException;
     * Retrieves all objects that have the identifiers in the given collection.
     * Only objects that the user has permission to read will be returned.
     *     The user retrieving the objects.
     *
     * @param identifiers
     *     The identifiers of the objects to retrieve.
     *     The objects having the given identifiers.
     *
     *     If an error occurs while retrieving the requested objects.
    Collection<InternalType> retrieveObjects(AuthenticatedUser user,
            Collection<String> identifiers) throws GuacamoleException;
     * Creates the given object. If the object already exists, an error will be
     * thrown.
     * @param object
     *     The object to create.
     *
     * @return
     *     The newly-created object.
     *     If the user lacks permission to create the object, or an error
     *     occurs while creating the object.
    InternalType createObject(AuthenticatedUser user, ExternalType object)
            throws GuacamoleException;
     * Deletes the object having the given identifier. If no such object
     * exists, this function has no effect.
     *     The user deleting the object.
     *     The identifier of the object to delete.
     *     If the user lacks permission to delete the object, or an error
     *     occurs while deleting the object.
    void deleteObject(AuthenticatedUser user, String identifier)
        throws GuacamoleException;
     * Updates the given object, applying any changes that have been made. If
     * no such object exists, this function has no effect.
     *
     *     The user updating the object.
     *
     * @param object
     *     The object to update.
     *
     * @throws GuacamoleException
     *     If the user lacks permission to update the object, or an error
     *     occurs while updating the object.
    void updateObject(AuthenticatedUser user, InternalType object)
            throws GuacamoleException;
    /**
     * Returns the set of all identifiers for all objects that the user has
     * read access to.
     *
     * @param user
     *     The user retrieving the identifiers.
     *
     * @return
     *     The set of all identifiers for all objects.
     *
     * @throws GuacamoleException
     *     If an error occurs while reading identifiers.
     */
    Set<String> getIdentifiers(AuthenticatedUser user) throws GuacamoleException;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/ModeledDirectoryObject.java
 * the Directory class and are persisted to an underlying database model. All
 * such objects will need the same base set of queries to fulfill the needs of
 * the Directory class.
public abstract class ModeledDirectoryObject<ModelType extends ObjectModel>
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/ModeledDirectoryObjectMapper.java
public interface ModeledDirectoryObjectMapper<ModelType> {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/ModeledGroupedDirectoryObject.java
public abstract class ModeledGroupedDirectoryObject<ModelType extends GroupedObjectModel>
    extends ModeledDirectoryObject<ModelType> {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/ModeledGroupedDirectoryObjectService.java
public abstract class ModeledGroupedDirectoryObjectService<InternalType extends ModeledGroupedDirectoryObject<ModelType>,
        extends ModeledDirectoryObjectService<InternalType, ExternalType, ModelType> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
public interface ConnectionMapper extends ModeledDirectoryObjectMapper<ConnectionModel> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObjectService;
public class ConnectionService extends ModeledGroupedDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
    protected ModeledDirectoryObjectMapper<ConnectionModel> getObjectMapper() {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObject;
public class ModeledConnection extends ModeledGroupedDirectoryObject<ConnectionModel>
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
public interface ConnectionGroupMapper extends ModeledDirectoryObjectMapper<ConnectionGroupModel> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObjectService;
public class ConnectionGroupService extends ModeledGroupedDirectoryObjectService<ModeledConnectionGroup,
    protected ModeledDirectoryObjectMapper<ConnectionGroupModel> getObjectMapper() {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObject;
public class ModeledConnectionGroup extends ModeledGroupedDirectoryObject<ConnectionGroupModel>
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObject;
public class ModeledUser extends ModeledDirectoryObject<UserModel> implements User {

import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
public interface UserMapper extends ModeledDirectoryObjectMapper<UserModel> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectService;
public class UserService extends ModeledDirectoryObjectService<ModeledUser, User, UserModel> {
    protected ModeledDirectoryObjectMapper<UserModel> getObjectMapper() {
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionDirectory;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionService;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
        bind(ActiveConnectionDirectory.class);
        bind(TrackedActiveConnection.class);
        bind(ActiveConnectionService.class);
    private final Map<String, ActiveConnectionRecord> activeTunnels =
            new ConcurrentHashMap<String, ActiveConnectionRecord>();
    public Collection<ActiveConnectionRecord> getActiveConnections(AuthenticatedUser user)
    public ActiveConnectionRecord getActiveConnection(AuthenticatedUser user,
    public Collection<ActiveConnectionRecord> getActiveConnections(Connection connection) {
    public Collection<ActiveConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup) {
    private final Map<String, Set<ActiveConnectionRecord>> records =
            new HashMap<String, Set<ActiveConnectionRecord>>();
    public void put(String identifier, ActiveConnectionRecord record) {
            Set<ActiveConnectionRecord> connections = records.get(identifier);
                connections = Collections.synchronizedSet(Collections.newSetFromMap(new LinkedHashMap<ActiveConnectionRecord, Boolean>()));
    public void remove(String identifier, ActiveConnectionRecord record) {
            Set<ActiveConnectionRecord> connections = records.get(identifier);
    public Collection<ActiveConnectionRecord> get(String identifier) {
            Collection<ActiveConnectionRecord> connections = records.get(identifier);
    /**
     * Returns the GuacamoleTunnel currently associated with the active
     * connection represented by this connection record.
     *
     * @return
     *     The GuacamoleTunnel currently associated with the active connection
     *     represented by this connection record.
     */
    public Collection<ActiveConnectionRecord> getActiveConnections(AuthenticatedUser user)
    public ActiveConnectionRecord getActiveConnection(AuthenticatedUser user,
     * Returns a collection containing connection records representing all
    public Collection<ActiveConnectionRecord> getActiveConnections(Connection connection);
    public Collection<ActiveConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup);
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
    public ObjectPermissionSet getActiveConnectionPermissions()
            throws GuacamoleException {
        throw new GuacamoleUnsupportedException("STUB");
    }

    @Override
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionDirectory;
import org.glyptodon.guacamole.net.auth.ActiveConnection;
     * ActiveConnection directory restricted by the permissions of the user
     * associated with this context.
     */
    @Inject
    private ActiveConnectionDirectory activeConnectionDirectory;

    /**
        activeConnectionDirectory.init(currentUser);
    public Directory<ActiveConnection> getActiveConnectionDirectory()
            throws GuacamoleException {
        return activeConnectionDirectory;
    }

    @Override
     * Returns all permissions given to this user regarding currently-active
     * connections.
     *
     * @return
     *     An ObjectPermissionSet of all active connection permissions granted
     *     to this user.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving permissions, or if reading all
     *     permissions is not allowed.
     */
    ObjectPermissionSet getActiveConnectionPermissions()
            throws GuacamoleException;

    /**
     * Retrieves a Directory which can be used to view and manipulate
     * active connections, but only as allowed by the permissions given to the
     * user.
     *
     * @return
     *     A Directory whose operations are bound by the permissions of the
     *     user.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the Directory.
     */
    Directory<ActiveConnection> getActiveConnectionDirectory()
            throws GuacamoleException;

    /**
    @Override
    public ObjectPermissionSet getActiveConnectionPermissions()
            throws GuacamoleException {
        return new SimpleObjectPermissionSet();
    }

import org.glyptodon.guacamole.net.auth.ActiveConnection;
    public Directory<ActiveConnection> getActiveConnectionDirectory()
        return new SimpleDirectory<ActiveConnection>();
import org.glyptodon.guacamole.net.basic.rest.activeconnection.ActiveConnectionRESTService;
        bind(ActiveConnectionRESTService.class);
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/activeconnection/APIActiveConnection.java
package org.glyptodon.guacamole.net.basic.rest.activeconnection;
import org.glyptodon.guacamole.net.auth.ActiveConnection;
 * Information related to active connections which may be exposed through the
 * REST endpoints.
public class APIActiveConnection {
     * The identifier of the active connection itself.

    /**
     * The identifier of the connection associated with this
     * active connection.
     */
    private final String connectionIdentifier;
     * Creates a new APIActiveConnection, copying the information from the given
     * active connection.
     * @param connection
     *     The active connection to copy data from.
    public APIActiveConnection(ActiveConnection connection) {
        this.identifier           = connection.getIdentifier();
        this.connectionIdentifier = connection.getConnectionIdentifier();
        this.startDate            = connection.getStartDate();
        this.remoteHost           = connection.getRemoteHost();
        this.username             = connection.getUsername();
    public String getConnectionIdentifier() {
        return connectionIdentifier;
     * Returns the identifier of the active connection itself. This is
     * distinct from the connection identifier, and uniquely identifies a
     * specific use of a connection.
     *     The identifier of the active connection.
    public String getIdentifier() {
        return identifier;
     * Map of active connection ID to the set of granted permissions.
     */
    private Map<String, Set<ObjectPermission.Type>> activeConnectionPermissions =
            new HashMap<String, Set<ObjectPermission.Type>>();

    /**
        addSystemPermissions(systemPermissions,           user.getSystemPermissions());
        addObjectPermissions(connectionPermissions,       user.getConnectionPermissions());
        addObjectPermissions(connectionGroupPermissions,  user.getConnectionGroupPermissions());
        addObjectPermissions(activeConnectionPermissions, user.getActiveConnectionPermissions());
        addObjectPermissions(userPermissions,             user.getUserPermissions());
     * Returns a map of active connection IDs to the set of permissions granted
     * for that active connection. If no permissions are granted to a particular
     * active connection, its ID will not be present as a key in the map. This
     * map is mutable, and changes to this map will affect the permission set
     * directly.
     *
     * @return
     *     A map of active connection IDs to the set of permissions granted for
     *     that active connection.
     */
    public Map<String, Set<ObjectPermission.Type>> getActiveConnectionPermissions() {
        return activeConnectionPermissions;
    }

    /**
     * Replaces the current map of active connection permissions with the give
     * map, which must map active connection ID to its corresponding set of
     * granted permissions. If an active connection has no permissions, its ID
     * must not be present as a key in the map.
     *
     * @param activeConnectionPermissions
     *     The map which must replace the currently-stored map of permissions.
     */
    public void setActiveConnectionPermissions(Map<String, Set<ObjectPermission.Type>> activeConnectionPermissions) {
        this.activeConnectionPermissions = activeConnectionPermissions;
    }

    /**
    @Override
    public ObjectPermissionSet getActiveConnectionPermissions()
            throws GuacamoleException {
        throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
    }

     * modifies the permissions of a user regarding a specific active connection.
     */
    private static final String ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX = "/activeConnectionPermissions/";

    /**
     * The prefix of any path within an operation of a JSON patch which
        PermissionSetPatch<ObjectPermission> connectionPermissionPatch       = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<ObjectPermission> connectionGroupPermissionPatch  = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<ObjectPermission> activeConnectionPermissionPatch = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<ObjectPermission> userPermissionPatch             = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<SystemPermission> systemPermissionPatch           = new PermissionSetPatch<SystemPermission>();
            // Create active connection permission if path has active connection prefix
            else if (path.startsWith(ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX)) {

                // Get identifier and type from patch operation
                String identifier = path.substring(ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX.length());
                ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());

                // Create and update corresponding permission
                ObjectPermission permission = new ObjectPermission(type, identifier);
                updatePermissionSet(patch.getOp(), activeConnectionPermissionPatch, permission);
                
            }

        activeConnectionPermissionPatch.apply(user.getActiveConnectionPermissions());
public class ConnectionGroupPermissionService extends ModeledObjectPermissionService {
public class ConnectionPermissionService extends ModeledObjectPermissionService {
public interface ObjectPermissionService
    extends PermissionService<ObjectPermissionSet, ObjectPermission> {
    ObjectPermission retrievePermission(AuthenticatedUser user,
            String identifier) throws GuacamoleException;
    Collection<String> retrieveAccessibleIdentifiers(AuthenticatedUser user,
            Collection<String> identifiers) throws GuacamoleException;
public interface PermissionService<PermissionSetType extends PermissionSet<PermissionType>,
        PermissionType extends Permission> {
    PermissionSetType getPermissionSet(AuthenticatedUser user,
    Set<PermissionType> retrievePermissions(AuthenticatedUser user,
            ModeledUser targetUser) throws GuacamoleException;
    void createPermissions(AuthenticatedUser user, ModeledUser targetUser,
    void deletePermissions(AuthenticatedUser user, ModeledUser targetUser,
    extends ModeledPermissionService<SystemPermissionSet, SystemPermission, SystemPermissionModel> {
public class UserPermissionService extends ModeledObjectPermissionService {
    extends AbstractPermissionService<PermissionSetType, PermissionType> {
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionService;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionSet;
        bind(ActiveConnectionPermissionSet.class);
        bind(ActiveConnectionPermissionService.class);
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionService;
     * Service for retrieving active connection permissions.
     */
    @Inject
    private ActiveConnectionPermissionService activeConnectionPermissionService;

    /**
        return activeConnectionPermissionService.getPermissionSet(getCurrentUser(), this);
            ObjectPermissionSet activeConnectionPermissions = self.getActiveConnectionPermissions();
            activeConnectionIdentifiers = activeConnectionPermissions.getAccessibleObjects(permissions, activeConnectionIdentifiers);
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionDirectory;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionService;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionSet;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionService;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
        bind(ActiveConnectionDirectory.class);
        bind(ActiveConnectionPermissionSet.class);
        bind(TrackedActiveConnection.class);
        bind(ActiveConnectionService.class);
        bind(ActiveConnectionPermissionService.class);
 * manipulating objects that have unique identifiers, such as the objects
 * within directories. This service will automatically enforce the permissions
 * of the current user.
public interface DirectoryObjectService<InternalType, ExternalType> {
    InternalType retrieveObject(AuthenticatedUser user, String identifier)
            throws GuacamoleException;
    Collection<InternalType> retrieveObjects(AuthenticatedUser user,
            Collection<String> identifiers) throws GuacamoleException;
     * Creates the given object. If the object already exists, an error will be
     * thrown.
    InternalType createObject(AuthenticatedUser user, ExternalType object)
            throws GuacamoleException;
    void deleteObject(AuthenticatedUser user, String identifier)
        throws GuacamoleException;
     * Updates the given object, applying any changes that have been made. If
     * no such object exists, this function has no effect.
    void updateObject(AuthenticatedUser user, InternalType object)
            throws GuacamoleException;
     * Returns the set of all identifiers for all objects that the user has
     * read access to.
     *     The set of all identifiers for all objects.
    Set<String> getIdentifiers(AuthenticatedUser user) throws GuacamoleException;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/ModeledDirectoryObject.java
 * the Directory class and are persisted to an underlying database model. All
 * such objects will need the same base set of queries to fulfill the needs of
 * the Directory class.
public abstract class ModeledDirectoryObject<ModelType extends ObjectModel>
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/ModeledDirectoryObjectMapper.java
public interface ModeledDirectoryObjectMapper<ModelType> {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/ModeledGroupedDirectoryObject.java
public abstract class ModeledGroupedDirectoryObject<ModelType extends GroupedObjectModel>
    extends ModeledDirectoryObject<ModelType> {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/base/ModeledGroupedDirectoryObjectService.java
public abstract class ModeledGroupedDirectoryObjectService<InternalType extends ModeledGroupedDirectoryObject<ModelType>,
        extends ModeledDirectoryObjectService<InternalType, ExternalType, ModelType> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
public interface ConnectionMapper extends ModeledDirectoryObjectMapper<ConnectionModel> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObjectService;
public class ConnectionService extends ModeledGroupedDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
    protected ModeledDirectoryObjectMapper<ConnectionModel> getObjectMapper() {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObject;
public class ModeledConnection extends ModeledGroupedDirectoryObject<ConnectionModel>
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
public interface ConnectionGroupMapper extends ModeledDirectoryObjectMapper<ConnectionGroupModel> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObjectService;
public class ConnectionGroupService extends ModeledGroupedDirectoryObjectService<ModeledConnectionGroup,
    protected ModeledDirectoryObjectMapper<ConnectionGroupModel> getObjectMapper() {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObject;
public class ModeledConnectionGroup extends ModeledGroupedDirectoryObject<ConnectionGroupModel>
public class ConnectionGroupPermissionService extends ModeledObjectPermissionService {
public class ConnectionPermissionService extends ModeledObjectPermissionService {
public interface ObjectPermissionService
    extends PermissionService<ObjectPermissionSet, ObjectPermission> {
    ObjectPermission retrievePermission(AuthenticatedUser user,
            String identifier) throws GuacamoleException;
    Collection<String> retrieveAccessibleIdentifiers(AuthenticatedUser user,
            Collection<String> identifiers) throws GuacamoleException;
public interface PermissionService<PermissionSetType extends PermissionSet<PermissionType>,
        PermissionType extends Permission> {
    PermissionSetType getPermissionSet(AuthenticatedUser user,
    Set<PermissionType> retrievePermissions(AuthenticatedUser user,
            ModeledUser targetUser) throws GuacamoleException;
    void createPermissions(AuthenticatedUser user, ModeledUser targetUser,
    void deletePermissions(AuthenticatedUser user, ModeledUser targetUser,
    extends ModeledPermissionService<SystemPermissionSet, SystemPermission, SystemPermissionModel> {
public class UserPermissionService extends ModeledObjectPermissionService {
    private final Map<String, ActiveConnectionRecord> activeTunnels =
            new ConcurrentHashMap<String, ActiveConnectionRecord>();
    public Collection<ActiveConnectionRecord> getActiveConnections(AuthenticatedUser user)
    public ActiveConnectionRecord getActiveConnection(AuthenticatedUser user,
    public Collection<ActiveConnectionRecord> getActiveConnections(Connection connection) {
    public Collection<ActiveConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup) {
    private final Map<String, Set<ActiveConnectionRecord>> records =
            new HashMap<String, Set<ActiveConnectionRecord>>();
    public void put(String identifier, ActiveConnectionRecord record) {
            Set<ActiveConnectionRecord> connections = records.get(identifier);
                connections = Collections.synchronizedSet(Collections.newSetFromMap(new LinkedHashMap<ActiveConnectionRecord, Boolean>()));
    public void remove(String identifier, ActiveConnectionRecord record) {
            Set<ActiveConnectionRecord> connections = records.get(identifier);
    public Collection<ActiveConnectionRecord> get(String identifier) {
            Collection<ActiveConnectionRecord> connections = records.get(identifier);
    /**
     * Returns the GuacamoleTunnel currently associated with the active
     * connection represented by this connection record.
     *
     * @return
     *     The GuacamoleTunnel currently associated with the active connection
     *     represented by this connection record.
     */
    public Collection<ActiveConnectionRecord> getActiveConnections(AuthenticatedUser user)
    public ActiveConnectionRecord getActiveConnection(AuthenticatedUser user,
     * Returns a collection containing connection records representing all
    public Collection<ActiveConnectionRecord> getActiveConnections(Connection connection);
    public Collection<ActiveConnectionRecord> getActiveConnections(ConnectionGroup connectionGroup);
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObject;
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionService;
public class ModeledUser extends ModeledDirectoryObject<UserModel> implements User {

    /**
     * Service for retrieving active connection permissions.
     */
    @Inject
    private ActiveConnectionPermissionService activeConnectionPermissionService;

    public ObjectPermissionSet getActiveConnectionPermissions()
            throws GuacamoleException {
        return activeConnectionPermissionService.getPermissionSet(getCurrentUser(), this);
    }

    @Override
import org.glyptodon.guacamole.auth.jdbc.activeconnection.ActiveConnectionDirectory;
import org.glyptodon.guacamole.net.auth.ActiveConnection;
     * ActiveConnection directory restricted by the permissions of the user
     * associated with this context.
     */
    @Inject
    private ActiveConnectionDirectory activeConnectionDirectory;

    /**
        activeConnectionDirectory.init(currentUser);
    public Directory<ActiveConnection> getActiveConnectionDirectory()
            throws GuacamoleException {
        return activeConnectionDirectory;
    }

    @Override
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
public interface UserMapper extends ModeledDirectoryObjectMapper<UserModel> {
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.glyptodon.guacamole.auth.jdbc.base.ModeledDirectoryObjectService;
public class UserService extends ModeledDirectoryObjectService<ModeledUser, User, UserModel> {
    protected ModeledDirectoryObjectMapper<UserModel> getObjectMapper() {
     * Returns all permissions given to this user regarding currently-active
     * connections.
     *
     * @return
     *     An ObjectPermissionSet of all active connection permissions granted
     *     to this user.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving permissions, or if reading all
     *     permissions is not allowed.
     */
    ObjectPermissionSet getActiveConnectionPermissions()
            throws GuacamoleException;

    /**
     * Retrieves a Directory which can be used to view and manipulate
     * active connections, but only as allowed by the permissions given to the
     * user.
     *
     * @return
     *     A Directory whose operations are bound by the permissions of the
     *     user.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the Directory.
     */
    Directory<ActiveConnection> getActiveConnectionDirectory()
            throws GuacamoleException;

    /**
    @Override
    public ObjectPermissionSet getActiveConnectionPermissions()
            throws GuacamoleException {
        return new SimpleObjectPermissionSet();
    }

import org.glyptodon.guacamole.net.auth.ActiveConnection;
    public Directory<ActiveConnection> getActiveConnectionDirectory()
        return new SimpleDirectory<ActiveConnection>();
import org.glyptodon.guacamole.net.basic.rest.activeconnection.ActiveConnectionRESTService;
        bind(ActiveConnectionRESTService.class);
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/activeconnection/APIActiveConnection.java
package org.glyptodon.guacamole.net.basic.rest.activeconnection;
import org.glyptodon.guacamole.net.auth.ActiveConnection;
 * Information related to active connections which may be exposed through the
 * REST endpoints.
public class APIActiveConnection {
     * The identifier of the active connection itself.

    /**
     * The identifier of the connection associated with this
     * active connection.
     */
    private final String connectionIdentifier;
     * Creates a new APIActiveConnection, copying the information from the given
     * active connection.
     * @param connection
     *     The active connection to copy data from.
    public APIActiveConnection(ActiveConnection connection) {
        this.identifier           = connection.getIdentifier();
        this.connectionIdentifier = connection.getConnectionIdentifier();
        this.startDate            = connection.getStartDate();
        this.remoteHost           = connection.getRemoteHost();
        this.username             = connection.getUsername();
    public String getConnectionIdentifier() {
        return connectionIdentifier;
     * Returns the identifier of the active connection itself. This is
     * distinct from the connection identifier, and uniquely identifies a
     * specific use of a connection.
     *     The identifier of the active connection.
    public String getIdentifier() {
        return identifier;
     * Map of active connection ID to the set of granted permissions.
     */
    private Map<String, Set<ObjectPermission.Type>> activeConnectionPermissions =
            new HashMap<String, Set<ObjectPermission.Type>>();

    /**
        addSystemPermissions(systemPermissions,           user.getSystemPermissions());
        addObjectPermissions(connectionPermissions,       user.getConnectionPermissions());
        addObjectPermissions(connectionGroupPermissions,  user.getConnectionGroupPermissions());
        addObjectPermissions(activeConnectionPermissions, user.getActiveConnectionPermissions());
        addObjectPermissions(userPermissions,             user.getUserPermissions());
     * Returns a map of active connection IDs to the set of permissions granted
     * for that active connection. If no permissions are granted to a particular
     * active connection, its ID will not be present as a key in the map. This
     * map is mutable, and changes to this map will affect the permission set
     * directly.
     *
     * @return
     *     A map of active connection IDs to the set of permissions granted for
     *     that active connection.
     */
    public Map<String, Set<ObjectPermission.Type>> getActiveConnectionPermissions() {
        return activeConnectionPermissions;
    }

    /**
     * Replaces the current map of active connection permissions with the give
     * map, which must map active connection ID to its corresponding set of
     * granted permissions. If an active connection has no permissions, its ID
     * must not be present as a key in the map.
     *
     * @param activeConnectionPermissions
     *     The map which must replace the currently-stored map of permissions.
     */
    public void setActiveConnectionPermissions(Map<String, Set<ObjectPermission.Type>> activeConnectionPermissions) {
        this.activeConnectionPermissions = activeConnectionPermissions;
    }

    /**
    @Override
    public ObjectPermissionSet getActiveConnectionPermissions()
            throws GuacamoleException {
        throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
    }

     * modifies the permissions of a user regarding a specific active connection.
     */
    private static final String ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX = "/activeConnectionPermissions/";

    /**
     * The prefix of any path within an operation of a JSON patch which
        PermissionSetPatch<ObjectPermission> connectionPermissionPatch       = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<ObjectPermission> connectionGroupPermissionPatch  = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<ObjectPermission> activeConnectionPermissionPatch = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<ObjectPermission> userPermissionPatch             = new PermissionSetPatch<ObjectPermission>();
        PermissionSetPatch<SystemPermission> systemPermissionPatch           = new PermissionSetPatch<SystemPermission>();
            // Create active connection permission if path has active connection prefix
            else if (path.startsWith(ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX)) {

                // Get identifier and type from patch operation
                String identifier = path.substring(ACTIVE_CONNECTION_PERMISSION_PATCH_PATH_PREFIX.length());
                ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());

                // Create and update corresponding permission
                ObjectPermission permission = new ObjectPermission(type, identifier);
                updatePermissionSet(patch.getOp(), activeConnectionPermissionPatch, permission);
                
            }

        activeConnectionPermissionPatch.apply(user.getActiveConnectionPermissions());
     * Reads and returns client information provided by the {@code request} parameter.
     *
     * @param request The request describing tunnel to create.
     * @return GuacamoleClientInformation Object containing information about the client sending the tunnel request.
    protected GuacamoleClientInformation getClientInformation(TunnelRequest request) {
        return info;
    }

    /**
     * Creates a new socket using client information specified in the {@code info} parameter,
     * connection information from {@code request} and credentials from the {@code session} parameter.
     *
     * @param request The request describing tunnel to create.
     * @param session Current guacamole session.
     * @param info Guacamole client information.
     * @return Socket connected using the provided settings.
     * @throws GuacamoleException If an error occurs while creating the socket.
     */
    protected GuacamoleTunnel createConnectedTunnel(TunnelRequest request, GuacamoleSession session,
                                                    GuacamoleClientInformation info) throws GuacamoleException {
        // Get ID of connection
        String id = request.getParameter("id");
        TunnelRequest.IdentifierType id_type = TunnelRequest.IdentifierType.getType(id);

        // Do not continue if unable to determine type
        if (id_type == null)
            throw new GuacamoleClientException("Illegal identifier - unknown type.");

        // Remove prefix
        id = id.substring(id_type.PREFIX.length());

        return tunnel;

    }

    /**
     * Creates and returns a tunnel using the specified guacd socket.
     * The tunnel is associated with a session identified
     * by the {@code authToken} parameter.
     *
     * @param tunnel The connected tunnel.
     * @param authToken Current authorization token.
     * @return The created tunnel.
     */
    protected GuacamoleTunnel createAssociatedTunnel(GuacamoleTunnel tunnel, final String authToken) {

        // Associate socket with tunnel
        return new DelegatingGuacamoleTunnel(tunnel) {


    }

    
    /**
     * Creates a new tunnel using the parameters and credentials present in
     * the given request.
     * 
     * @param request The request describing the tunnel to create.
     * @return The created tunnel, or null if the tunnel could not be created.
     * @throws GuacamoleException If an error occurs while creating the tunnel.
     */
    public GuacamoleTunnel createTunnel(TunnelRequest request)
            throws GuacamoleException {

        // Get auth token and session
        final String authToken = request.getParameter("authToken");
        final GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);

        // Get client information
        final GuacamoleClientInformation info = getClientInformation(request);

        // Create connected tunnel from request 
        final GuacamoleTunnel tunnel = createConnectedTunnel(request, session, info);

        // Associate tunnel with session
        final GuacamoleTunnel monitoredTunnel = createAssociatedTunnel(tunnel, authToken);

     * Creates a new tunnel using client information specified in the
     * {@code info} parameter, connection information from {@code request} and
     * credentials from the {@code session} parameter.
     * @param request
     *     The request describing tunnel to create.
     *
     * @param session
     *     The Guacamole session for which the tunnel is being created.
     *
     * @param info
     *     Information describing the connected Guacamole client.
     *
     * @return
     *     A new tunnel, connected as required by the request.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the tunnel.
        // Create connected tunnel from identifier
     * Creates and returns a tunnel which wraps the given tunnel, monitoring it
     * for closure and, if enabled, clipboard changes. The tunnel is associated
     * with a session identified by the {@code authToken} parameter.
     * @param tunnel
     *     The connected tunnel to wrap and monitor.
     *
     * @param authToken
     *     The authorization token associated with the session for which this
     *     tunnel is being created.
     *
     * @return
     *     A new tunnel which monitors the given tunnel.
        // Monitor tunnel closure and data
     *
     * @param request
     *     The request describing the tunnel to create.
     *
     * @return
     *     The created tunnel, or null if the tunnel could not be created.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the tunnel.
     * Creates a new tunnel using which is connected to the connection or
     * connection group identifier by the given ID. Client information
     * is specified in the {@code info} parameter.
     * @param context
     *     The UserContext associated with the user for whom the tunnel is
     *     being created.
     * @param id
     *     The ID of the connection or connection group being connected to. For
     *     connections, this will be of the form "c/IDENTIFIER", where
     *     IDENTIFIER is the connection identifier. For connection groups, this
     *     will be of the form "g/IDENTIFIER", where IDENTIFIER is the
     *     connection group identifier.
    protected GuacamoleTunnel createConnectedTunnel(UserContext context, String id,
        // Determine ID type
        TunnelRequest.IdentifierType id_type = TunnelRequest.IdentifierType.getType(id);
     * Associates the given tunnel with the given session, returning a wrapped
     * version of the same tunnel which automatically handles closure and
     * removal from the session.
     * @param session
     *     The Guacamole session to associate the tunnel with.
     *     A new tunnel, associated with the given session, which delegates all
     *     functionality to the given tunnel while monitoring and automatically
     *     handling closure.
     *
     * @throws GuacamoleException
     *     If an error occurs while obtaining the tunnel.
    protected GuacamoleTunnel createAssociatedTunnel(final GuacamoleSession session,
            GuacamoleTunnel tunnel) throws GuacamoleException {
        GuacamoleTunnel monitoredTunnel = new DelegatingGuacamoleTunnel(tunnel) {
                // Signal listeners
        // Notify listeners about connection
        if (!notifyConnect(session, monitoredTunnel)) {
            logger.info("Successful connection canceled by hook.");
            return null;
        }

        // Associate tunnel with session
        session.addTunnel(monitoredTunnel);
        return monitoredTunnel;
        
        // Get client information and connection ID from request
        final String id = request.getParameter("id");
        // Create connected tunnel using provided connection ID and client information
        final GuacamoleTunnel tunnel = createConnectedTunnel(session.getUserContext(), id, info);
        return createAssociatedTunnel(session, tunnel);
     * Reads and returns the client information provided within the given
     * request.
     * @param request
     *     The request describing tunnel to create.
     *
     * @return GuacamoleClientInformation
     *     An object containing information about the client sending the tunnel
     *     request.
 * @author Vasily Loginov
 * @author Vasily Loginov
     * Reads and returns the client information provided within the given
     * request.
     *
     * @param request
     *     The request describing tunnel to create.
     *
     * @return GuacamoleClientInformation
     *     An object containing information about the client sending the tunnel
     *     request.
    protected GuacamoleClientInformation getClientInformation(TunnelRequest request) {
        return info;
    }

    /**
     * Creates a new tunnel using which is connected to the connection or
     * connection group identifier by the given ID. Client information
     * is specified in the {@code info} parameter.
     *
     * @param context
     *     The UserContext associated with the user for whom the tunnel is
     *     being created.
     *
     * @param id
     *     The ID of the connection or connection group being connected to. For
     *     connections, this will be of the form "c/IDENTIFIER", where
     *     IDENTIFIER is the connection identifier. For connection groups, this
     *     will be of the form "g/IDENTIFIER", where IDENTIFIER is the
     *     connection group identifier.
     *
     * @param info
     *     Information describing the connected Guacamole client.
     *
     * @return
     *     A new tunnel, connected as required by the request.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the tunnel.
     */
    protected GuacamoleTunnel createConnectedTunnel(UserContext context, String id,
                                                    GuacamoleClientInformation info) throws GuacamoleException {

        // Determine ID type
        TunnelRequest.IdentifierType id_type = TunnelRequest.IdentifierType.getType(id);
        if (id_type == null)
            throw new GuacamoleClientException("Illegal identifier - unknown type.");

        // Remove prefix
        id = id.substring(id_type.PREFIX.length());

        // Create connected tunnel from identifier
        return tunnel;

    }

    /**
     * Associates the given tunnel with the given session, returning a wrapped
     * version of the same tunnel which automatically handles closure and
     * removal from the session.
     *
     * @param tunnel
     *     The connected tunnel to wrap and monitor.
     *
     * @param session
     *     The Guacamole session to associate the tunnel with.
     *
     * @return
     *     A new tunnel, associated with the given session, which delegates all
     *     functionality to the given tunnel while monitoring and automatically
     *     handling closure.
     *
     * @throws GuacamoleException
     *     If an error occurs while obtaining the tunnel.
     */
    protected GuacamoleTunnel createAssociatedTunnel(final GuacamoleSession session,
            GuacamoleTunnel tunnel) throws GuacamoleException {

        // Monitor tunnel closure and data

                // Signal listeners

        // Associate tunnel with session
        
    }

    /**
     * Creates a new tunnel using the parameters and credentials present in
     * the given request.
     *
     * @param request
     *     The request describing the tunnel to create.
     *
     * @return
     *     The created tunnel, or null if the tunnel could not be created.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the tunnel.
     */
    public GuacamoleTunnel createTunnel(TunnelRequest request)
            throws GuacamoleException {

        // Get auth token and session
        final String authToken = request.getParameter("authToken");
        final GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);

        // Get client information and connection ID from request
        final String id = request.getParameter("id");
        final GuacamoleClientInformation info = getClientInformation(request);

        // Create connected tunnel using provided connection ID and client information
        final GuacamoleTunnel tunnel = createConnectedTunnel(session.getUserContext(), id, info);

        // Associate tunnel with session
        return createAssociatedTunnel(session, tunnel);
 * @author Vasily Loginov
     * Reads and returns the client information provided within the given
     * request.
     *
     * @param request
     *     The request describing tunnel to create.
     *
     * @return GuacamoleClientInformation
     *     An object containing information about the client sending the tunnel
     *     request.
    protected GuacamoleClientInformation getClientInformation(TunnelRequest request) {
        return info;
    }

    /**
     * Creates a new tunnel using which is connected to the connection or
     * connection group identifier by the given ID. Client information
     * is specified in the {@code info} parameter.
     *
     * @param context
     *     The UserContext associated with the user for whom the tunnel is
     *     being created.
     *
     * @param id
     *     The ID of the connection or connection group being connected to. For
     *     connections, this will be of the form "c/IDENTIFIER", where
     *     IDENTIFIER is the connection identifier. For connection groups, this
     *     will be of the form "g/IDENTIFIER", where IDENTIFIER is the
     *     connection group identifier.
     *
     * @param info
     *     Information describing the connected Guacamole client.
     *
     * @return
     *     A new tunnel, connected as required by the request.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the tunnel.
     */
    protected GuacamoleTunnel createConnectedTunnel(UserContext context, String id,
                                                    GuacamoleClientInformation info) throws GuacamoleException {

        // Determine ID type
        TunnelRequest.IdentifierType id_type = TunnelRequest.IdentifierType.getType(id);
        if (id_type == null)
            throw new GuacamoleClientException("Illegal identifier - unknown type.");

        // Remove prefix
        id = id.substring(id_type.PREFIX.length());

        // Create connected tunnel from identifier
        return tunnel;

    }

    /**
     * Associates the given tunnel with the given session, returning a wrapped
     * version of the same tunnel which automatically handles closure and
     * removal from the session.
     *
     * @param tunnel
     *     The connected tunnel to wrap and monitor.
     *
     * @param session
     *     The Guacamole session to associate the tunnel with.
     *
     * @return
     *     A new tunnel, associated with the given session, which delegates all
     *     functionality to the given tunnel while monitoring and automatically
     *     handling closure.
     *
     * @throws GuacamoleException
     *     If an error occurs while obtaining the tunnel.
     */
    protected GuacamoleTunnel createAssociatedTunnel(final GuacamoleSession session,
            GuacamoleTunnel tunnel) throws GuacamoleException {

        // Monitor tunnel closure and data

                // Signal listeners

        // Associate tunnel with session
        
    }

    /**
     * Creates a new tunnel using the parameters and credentials present in
     * the given request.
     *
     * @param request
     *     The request describing the tunnel to create.
     *
     * @return
     *     The created tunnel, or null if the tunnel could not be created.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the tunnel.
     */
    public GuacamoleTunnel createTunnel(TunnelRequest request)
            throws GuacamoleException {

        // Get auth token and session
        final String authToken = request.getParameter("authToken");
        final GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);

        // Get client information and connection ID from request
        final String id = request.getParameter("id");
        final GuacamoleClientInformation info = getClientInformation(request);

        // Create connected tunnel using provided connection ID and client information
        final GuacamoleTunnel tunnel = createConnectedTunnel(session.getUserContext(), id, info);

        // Associate tunnel with session
        return createAssociatedTunnel(session, tunnel);
            boolean isAdmin = targetUser.isAdministrator();
            // We have READ, and possibly DELETE, on all active connections
                // Add implicit READ
                permissions.add(new ObjectPermission(ObjectPermission.Type.READ, identifier));

                // If we're and admin, then we also have DELETE
                if (isAdmin)
                    permissions.add(new ObjectPermission(ObjectPermission.Type.DELETE, identifier));
import java.util.Collections;
        // Pull objects having given identifier
        Collection<TrackedActiveConnection> objects = retrieveObjects(user, Collections.singleton(identifier));
        // If no such object, return null
        if (objects.isEmpty())
        // The object collection will have exactly one element unless the
        // database has seriously lost integrity
        assert(objects.size() == 1);

        // Return first and only object
        return objects.iterator().next();

        Set<String> identifierSet = new HashSet<String>(identifiers);
        // Retrieve all visible connections (permissions enforced by tunnel service)
        Collection<ActiveConnectionRecord> records = tunnelService.getActiveConnections(user);

        // Restrict to subset of records which match given identifiers
        Collection<TrackedActiveConnection> activeConnections = new ArrayList<TrackedActiveConnection>(identifiers.size());
        for (ActiveConnectionRecord record : records) {

            // Add connection if within requested identifiers
            if (identifierSet.contains(record.getUUID().toString())) {
                TrackedActiveConnection activeConnection = trackedActiveConnectionProvider.get();
                activeConnection.init(user, record);
            }

        // Only administrators may delete active connections
        if (!user.getUser().isAdministrator())
            throw new GuacamoleSecurityException("Permission denied.");

import java.util.HashSet;
import java.util.Set;
        // Simply return empty list if there are no active tunnels
        Collection<ActiveConnectionRecord> records = activeTunnels.values();
        if (records.isEmpty())
        // Build set of all connection identifiers associated with active tunnels
        Set<String> identifiers = new HashSet<String>(records.size());
        for (ActiveConnectionRecord record : records)
            identifiers.add(record.getConnection().getIdentifier());
        // Produce collection of readable connection identifiers
        Collection<ConnectionModel> connections = connectionMapper.selectReadable(user.getUser().getModel(), identifiers);
        // Ensure set contains only identifiers of readable connections
        identifiers.clear();
        for (ConnectionModel connection : connections)
            identifiers.add(connection.getIdentifier());
        // Produce readable subset of records
        Collection<ActiveConnectionRecord> visibleRecords = new ArrayList<ActiveConnectionRecord>(records.size());
        for (ActiveConnectionRecord record : records) {
            if (identifiers.contains(record.getConnection().getIdentifier()))
                visibleRecords.add(record);
        }
        return visibleRecords;

        // An admin user has access to any connection
        // Filter connections, if requested
        boolean isAdmin = user.getUser().isAdministrator();
                activeConnection.init(user, record, isAdmin);
     * with the given active connection record. At a minimum, the identifier
     * of this active connection will be set, the start date, and the
     * identifier of the associated connection will be copied. If requested,
     * sensitive information like the associated username will be copied, as
     * well.
     *
     * @param includeSensitiveInformation
     *     Whether sensitive data should be copied from the connection record
     *     as well. This includes the remote host, associated tunnel, and
     *     username.
            ActiveConnectionRecord activeConnectionRecord,
            boolean includeSensitiveInformation) {
        // Copy all non-sensitive data from given record

        // Include sensitive data, too, if requested
        if (includeSensitiveInformation) {
            this.remoteHost = activeConnectionRecord.getRemoteHost();
            this.tunnel     = activeConnectionRecord.getTunnel();
            this.username   = activeConnectionRecord.getUsername();
        }
     * Returns the identifier of the connection being actively used. Unlike the
     * other information stored in this object, the connection identifier must
     * be present and MAY NOT be null.
     *     The date and time the connection began, or null if this
     *     information is not available.
     *     The date and time the connection began, or null if this
     *     information is not available.
     *     The name of the user who is using this connection, or null if this
     *     information is not available.
     *     The name of the user who is using this connection, or null if this
     *     information is not available.
            boolean isAdmin = targetUser.isAdministrator();
            // We have READ, and possibly DELETE, on all active connections
                // Add implicit READ
                permissions.add(new ObjectPermission(ObjectPermission.Type.READ, identifier));

                // If we're and admin, then we also have DELETE
                if (isAdmin)
                    permissions.add(new ObjectPermission(ObjectPermission.Type.DELETE, identifier));
import java.util.Collections;
        // Pull objects having given identifier
        Collection<TrackedActiveConnection> objects = retrieveObjects(user, Collections.singleton(identifier));
        // If no such object, return null
        if (objects.isEmpty())
        // The object collection will have exactly one element unless the
        // database has seriously lost integrity
        assert(objects.size() == 1);

        // Return first and only object
        return objects.iterator().next();

        boolean isAdmin = user.getUser().isAdministrator();
        Set<String> identifierSet = new HashSet<String>(identifiers);
        // Retrieve all visible connections (permissions enforced by tunnel service)
        Collection<ActiveConnectionRecord> records = tunnelService.getActiveConnections(user);

        // Restrict to subset of records which match given identifiers
        Collection<TrackedActiveConnection> activeConnections = new ArrayList<TrackedActiveConnection>(identifiers.size());
        for (ActiveConnectionRecord record : records) {

            // Add connection if within requested identifiers
            if (identifierSet.contains(record.getUUID().toString())) {
                TrackedActiveConnection activeConnection = trackedActiveConnectionProvider.get();
                activeConnection.init(user, record, isAdmin);
            }

        // Only administrators may delete active connections
        if (!user.getUser().isAdministrator())
            throw new GuacamoleSecurityException("Permission denied.");

     * with the given active connection record. At a minimum, the identifier
     * of this active connection will be set, the start date, and the
     * identifier of the associated connection will be copied. If requested,
     * sensitive information like the associated username will be copied, as
     * well.
     *
     * @param includeSensitiveInformation
     *     Whether sensitive data should be copied from the connection record
     *     as well. This includes the remote host, associated tunnel, and
     *     username.
            ActiveConnectionRecord activeConnectionRecord,
            boolean includeSensitiveInformation) {
        // Copy all non-sensitive data from given record

        // Include sensitive data, too, if requested
        if (includeSensitiveInformation) {
            this.remoteHost = activeConnectionRecord.getRemoteHost();
            this.tunnel     = activeConnectionRecord.getTunnel();
            this.username   = activeConnectionRecord.getUsername();
        }
import java.util.HashSet;
import java.util.Set;
        // Simply return empty list if there are no active tunnels
        Collection<ActiveConnectionRecord> records = activeTunnels.values();
        if (records.isEmpty())
        // Build set of all connection identifiers associated with active tunnels
        Set<String> identifiers = new HashSet<String>(records.size());
        for (ActiveConnectionRecord record : records)
            identifiers.add(record.getConnection().getIdentifier());
        // Produce collection of readable connection identifiers
        Collection<ConnectionModel> connections = connectionMapper.selectReadable(user.getUser().getModel(), identifiers);
        // Ensure set contains only identifiers of readable connections
        identifiers.clear();
        for (ConnectionModel connection : connections)
            identifiers.add(connection.getIdentifier());
        // Produce readable subset of records
        Collection<ActiveConnectionRecord> visibleRecords = new ArrayList<ActiveConnectionRecord>(records.size());
        for (ActiveConnectionRecord record : records) {
            if (identifiers.contains(record.getConnection().getIdentifier()))
                visibleRecords.add(record);
        }
        return visibleRecords;

     * Returns the identifier of the connection being actively used. Unlike the
     * other information stored in this object, the connection identifier must
     * be present and MAY NOT be null.
     *     The date and time the connection began, or null if this
     *     information is not available.
     *     The date and time the connection began, or null if this
     *     information is not available.
     *     The name of the user who is using this connection, or null if this
     *     information is not available.
     *     The name of the user who is using this connection, or null if this
     *     information is not available.
        // An admin user has access to any connection
        // Filter connections, if requested
import javax.ws.rs.core.MultivaluedMap;
import org.glyptodon.guacamole.net.basic.rest.APIRequest;
     * @param consumedRequest
     *     The HttpServletRequest associated with the login attempt. The
     *     parameters of this request may not be accessible, as the request may
     *     have been fully consumed by JAX-RS.
     *
     * @param parameters
     *     A MultivaluedMap containing all parameters from the given HTTP
     *     request. All request parameters must be made available through this
     *     map, even if those parameters are no longer accessible within the
     *     now-fully-consumed HTTP request.
            @Context HttpServletRequest consumedRequest,
            MultivaluedMap<String, String> parameters)
            throws GuacamoleException {
        // Reconstitute the HTTP request with the map of parameters
        HttpServletRequest request = new APIRequest(consumedRequest, parameters);
        
import javax.ws.rs.core.MultivaluedMap;
import org.glyptodon.guacamole.net.basic.rest.APIRequest;
     * @param consumedRequest
     *     The HttpServletRequest associated with the login attempt. The
     *     parameters of this request may not be accessible, as the request may
     *     have been fully consumed by JAX-RS.
     *
     * @param parameters
     *     A MultivaluedMap containing all parameters from the given HTTP
     *     request. All request parameters must be made available through this
     *     map, even if those parameters are no longer accessible within the
     *     now-fully-consumed HTTP request.
            @Context HttpServletRequest consumedRequest,
            MultivaluedMap<String, String> parameters)
            throws GuacamoleException {
        // Reconstitute the HTTP request with the map of parameters
        HttpServletRequest request = new APIRequest(consumedRequest, parameters);
        
                if (message == null) {
                    session.detachTunnel(tunnel);
                }
            // Send end-of-stream marker and close tunnel if connection is closed

                // Detach and close
                session.detachTunnel(tunnel);
                tunnel.close();

                // End-of-instructions marker

                if (message == null) {
                    session.detachTunnel(tunnel);
                }
            // Send end-of-stream marker and close tunnel if connection is closed

                // Detach and close
                session.detachTunnel(tunnel);
                tunnel.close();

                // End-of-instructions marker

 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/form/ParameterOption.java
package org.glyptodon.guacamole.form;
 * Describes an available legal value for an enumerated parameter.
public class ParameterOption {
     * The value that will be assigned if this option is chosen.
     * Creates a new ParameterOption with no associated value or title.
     */
    public ParameterOption() {
    }

    /**
     * Creates a new ParameterOption having the given value and title.
     * @param value
     *     The value to assign if this option is chosen.
     *
     * @param title
     *     The human-readable title to associate with this option.
     */
    public ParameterOption(String value, String title) {
        this.value = value;
        this.title = title;
    }
    
    /**
     * Returns the value that will be assigned if this option is chosen.
     *
     * @return
     *     The value that will be assigned if this option is chosen.
     * Sets the value that will be assigned if this option is chosen.
     * @param value
     *     The value to assign if this option is chosen.
     *
     * @return
     *     The human-readable title describing the effect of this option.
     *
     * @param title
     *     A human-readable title describing the effect of this option.
import org.glyptodon.guacamole.form.Parameter;
    private Collection<Parameter> parameters;

    /**
     * Creates a new ProtocolInfo with no associated name, title, or
     * parameters.
     */
    public ProtocolInfo() {
        this.parameters = new ArrayList<Parameter>();
    }

    /**
     * Creates a new ProtocolInfo having the given name and title, but without
     * any parameters.
     *
     * @param name
     *     The unique name associated with the protocol.
     *
     * @param title
     *     The human-readable title to associate with the protocol.
     */
    public ProtocolInfo(String name, String title) {
        this.name       = name;
        this.title      = title;
        this.parameters = new ArrayList<Parameter>();
    }

    /**
     * Creates a new ProtocolInfo having the given name, title, and parameters.
     *
     * @param name
     *     The unique name associated with the protocol.
     *
     * @param title
     *     The human-readable title to associate with the protocol.
     * 
     * @param parameters
     *     The parameters to associate with the protocol.
     */
    public ProtocolInfo(String name, String title, Collection<Parameter> parameters) {
        this.name       = name;
        this.title      = title;
        this.parameters = parameters;
    }
    public Collection<Parameter> getParameters() {
    /**
     * Sets the collection of protocol parameters associated with this
     * protocol.
     *
     * @param parameters
     *     The collection of parameters to associate with this protocol.
     */
    public void setParameters(Collection<Parameter> parameters) {
        this.parameters = parameters;
    }
    
import org.glyptodon.guacamole.form.ParameterOption;
    private ParameterOption option = new ParameterOption();
     * Returns the ParameterOption backing this tag.
     * @return The ParameterOption backing this tag.
    public ParameterOption asParameterOption() {
import org.glyptodon.guacamole.form.Parameter;
     * The Parameter backing this tag handler.
    private Parameter protocolParameter = new Parameter();
            protocolParameter.setType(Parameter.Type.TEXT);
            protocolParameter.setType(Parameter.Type.NUMERIC);
            protocolParameter.setType(Parameter.Type.USERNAME);
            protocolParameter.setType(Parameter.Type.PASSWORD);
            protocolParameter.setType(Parameter.Type.ENUM);
            protocolParameter.setType(Parameter.Type.MULTILINE);
            protocolParameter.setType(Parameter.Type.BOOLEAN);
                tagHandler.asParameterOption());
     * Returns the Parameter backing this tag.
     * @return The Parameter backing this tag.
    public Parameter asParameter() {
            info.getParameters().add(tagHandler.asParameter());
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
            // Request standard username/password if no user context was produced
            if (userContext == null)
                throw new GuacamoleInvalidCredentialsException("Permission Denied.",
                        CredentialsInfo.USERNAME_PASSWORD);

        catch (GuacamoleException e) {
            throw e;
        
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;

        // Additional credentials are needed
        catch (GuacamoleInsufficientCredentialsException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Permission denied.";

            throw new HTTPException(Response.Status.FORBIDDEN, new APICredentialError(
                    APICredentialError.Type.INSUFFICIENT,
                    message,
                    e.getCredentialsInfo()
            ));

        // The provided credentials are wrong
        catch (GuacamoleInvalidCredentialsException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Permission denied.";

            throw new HTTPException(Response.Status.FORBIDDEN, new APICredentialError(
                    APICredentialError.Type.INVALID,
                    message,
                    e.getCredentialsInfo()
            ));

        // Generic permission denied
        catch (GuacamoleSecurityException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Permission denied.";

            throw new HTTPException(Response.Status.FORBIDDEN, message);

        }

        // Arbitrary bad requests
        catch (GuacamoleClientException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Invalid request.";

            throw new HTTPException(Response.Status.BAD_REQUEST, message);

        }

        // All other errors
        catch (GuacamoleException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Unexpected server error.";

            logger.debug("Unexpected exception in REST endpoint.", e);
            throw new HTTPException(Response.Status.INTERNAL_SERVER_ERROR, message);

 * Copyright (C) 2015 Glyptodon LLC
import java.util.Collection;
import javax.ws.rs.core.Response;
import org.glyptodon.guacamole.form.Parameter;

 * Describes an error that occurred within a REST endpoint.
 *
 * @author Michael Jumper

     * All expected request parameters, if any.
     */
    private final Collection<Parameter> expected;

    /**
     * The type of error that occurred.
     */
    private final Type type;

    /**
     * All possible types of REST API errors.
     */
    public enum Type {

        /**
         * The requested operation could not be performed because the request
         * itself was malformed.
         */
        BAD_REQUEST(Response.Status.BAD_REQUEST),

        /**
         * The credentials provided were invalid.
         */
        INVALID_CREDENTIALS(Response.Status.FORBIDDEN),

        /**
         * The credentials provided were not necessarily invalid, but were not
         * sufficient to determine validity.
         */
        INSUFFICIENT_CREDENTIALS(Response.Status.FORBIDDEN),

        /**
         * An internal server error has occurred.
         */
        INTERNAL_ERROR(Response.Status.INTERNAL_SERVER_ERROR),

        /**
         * An object related to the request does not exist.
         */
        NOT_FOUND(Response.Status.NOT_FOUND),

        /**
         * Permission was denied to perform the requested operation.
         */
        PERMISSION_DENIED(Response.Status.FORBIDDEN);

        /**
         * The HTTP status associated with this error type.
         */
        private final Response.Status status;

        /**
         * Defines a new error type associated with the given HTTP status.
         *
         * @param status
         *     The HTTP status to associate with the error type.
         */
        Type(Response.Status status) {
            this.status = status;
        }

        /**
         * Returns the HTTP status associated with this error type.
         *
         * @return
         *     The HTTP status associated with this error type.
         */
        public Response.Status getStatus() {
            return status;
        }

    }

    /**
     * Create a new APIError with the specified error message.
     *
     * @param type
     *     The type of error that occurred.
     *
     * @param message
     *     The error message.
     */
    public APIError(Type type, String message) {
        this.type     = type;
        this.message  = message;
        this.expected = null;
    }

    /**
     * Create a new APIError with the specified error message and parameter
     * information.
     *
     * @param type
     *     The type of error that occurred.
     *
     * @param message
     *     The error message.
     *
     * @param expected
     *     All parameters expected in the original request, or now required as
     *     a result of the original request.
     */
    public APIError(Type type, String message, Collection<Parameter> expected) {
        this.type     = type;
        this.message  = message;
        this.expected = expected;
    }

    /**
     * Returns the type of error that occurred.
     *
     * @return
     *     The type of error that occurred.
     */
    public Type getType() {
        return type;
    }

    /**
     * Returns an object which describes the required credentials.
     *
     * @return
     *     An object which describes the required credentials.
     */
    public Collection<Parameter> getExpected() {
        return expected;
    }

    /**
     * Returns a human-readable error message describing the error that
     * occurred.
     *
     * @return
     *     A human-readable error message.
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
            throw new HTTPException(
                APIError.Type.INSUFFICIENT_CREDENTIALS,
                message,
                e.getCredentialsInfo().getParameters()
            );
            throw new HTTPException(
                APIError.Type.INVALID_CREDENTIALS,
                message,
                e.getCredentialsInfo().getParameters()
            );
            throw new HTTPException(
                APIError.Type.PERMISSION_DENIED,
                message
            );
        // Arbitrary resource not found
        catch (GuacamoleResourceNotFoundException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Not found.";

            throw new HTTPException(
                APIError.Type.NOT_FOUND,
                message
            );

        }
        
            throw new HTTPException(
                APIError.Type.BAD_REQUEST,
                message
            );
            throw new HTTPException(
                APIError.Type.INTERNAL_ERROR,
                message
            );
import java.util.Collection;
import org.glyptodon.guacamole.form.Parameter;
 * An exception that will result in the given HTTP Status and error being
 * returned from the API layer. All error messages have the same format which
 * is defined by APIError.
 *
 * @author Michael Jumper

     * Construct a new HTTPException with the given error. All information
     * associated with this new exception will be extracted from the given
     * APIError.
     *
     * @param error
     *     The error that occurred.
    public HTTPException(APIError error) {
        super(Response.status(error.getType().getStatus()).entity(error).build());

     * Creates a new HTTPException with the given type and message. The
     * corresponding APIError will be created from the provided information.
     *
     * @param type
     *     The type of error that occurred.
     *
     * @param message
     *     A human-readable message describing the error.
    public HTTPException(APIError.Type type, String message) {
        this(new APIError(type, message));

    /**
     * Creates a new HTTPException with the given type, message, and
     * parameter information. The corresponding APIError will be created from
     * the provided information.
     *
     * @param type
     *     The type of error that occurred.
     *
     * @param message
     *     A human-readable message describing the error.
     *
     * @param expected
     *     All parameters expected in the original request, or now required as
     *     a result of the original request.
     */
    public HTTPException(APIError.Type type, String message, Collection<Parameter> expected) {
        this(new APIError(type, message, expected));
    }

import org.glyptodon.guacamole.net.basic.rest.APIError;
            throw new HTTPException(APIError.Type.NOT_FOUND, "No such token.");
import org.glyptodon.guacamole.net.basic.rest.APIError;
            throw new HTTPException(APIError.Type.BAD_REQUEST,
            throw new HTTPException(APIError.Type.PERMISSION_DENIED,
            throw new HTTPException(APIError.Type.PERMISSION_DENIED,
                throw new HTTPException(APIError.Type.BAD_REQUEST,
                throw new HTTPException(APIError.Type.BAD_REQUEST, "Unsupported patch path: \""  path  "\"");
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/APIException.java
 * An exception that will result in the given error error information being
public class APIException extends WebApplicationException {
     * Construct a new APIException with the given error. All information
    public APIException(APIError error) {
     * Creates a new APIException with the given type and message. The
    public APIException(APIError.Type type, String message) {
     * Creates a new APIException with the given type, message, and parameter
     * information. The corresponding APIError will be created from the
     * provided information.
    public APIException(APIError.Type type, String message, Collection<Parameter> expected) {
            throw new APIException(
            throw new APIException(
            throw new APIException(
            throw new APIException(
            throw new APIException(
            throw new APIException(
import org.glyptodon.guacamole.net.basic.rest.APIException;
            throw new APIException(APIError.Type.NOT_FOUND, "No such token.");
import org.glyptodon.guacamole.net.basic.rest.APIException;
            throw new APIException(APIError.Type.BAD_REQUEST,
            throw new APIException(APIError.Type.PERMISSION_DENIED,
            throw new APIException(APIError.Type.PERMISSION_DENIED,
                throw new APIException(APIError.Type.BAD_REQUEST,
                throw new APIException(APIError.Type.BAD_REQUEST, "Unsupported patch path: \""  path  "\"");
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/form/ParameterOption.java
package org.glyptodon.guacamole.form;
 * Describes an available legal value for an enumerated parameter.
public class ParameterOption {
     * The value that will be assigned if this option is chosen.
     * Creates a new ParameterOption with no associated value or title.
     */
    public ParameterOption() {
    }

    /**
     * Creates a new ParameterOption having the given value and title.
     * @param value
     *     The value to assign if this option is chosen.
     *
     * @param title
     *     The human-readable title to associate with this option.
     */
    public ParameterOption(String value, String title) {
        this.value = value;
        this.title = title;
    }
    
    /**
     * Returns the value that will be assigned if this option is chosen.
     *
     * @return
     *     The value that will be assigned if this option is chosen.
     * Sets the value that will be assigned if this option is chosen.
     * @param value
     *     The value to assign if this option is chosen.
     *
     * @return
     *     The human-readable title describing the effect of this option.
     *
     * @param title
     *     A human-readable title describing the effect of this option.
import org.glyptodon.guacamole.form.Parameter;
    private Collection<Parameter> parameters;

    /**
     * Creates a new ProtocolInfo with no associated name, title, or
     * parameters.
     */
    public ProtocolInfo() {
        this.parameters = new ArrayList<Parameter>();
    }

    /**
     * Creates a new ProtocolInfo having the given name and title, but without
     * any parameters.
     *
     * @param name
     *     The unique name associated with the protocol.
     *
     * @param title
     *     The human-readable title to associate with the protocol.
     */
    public ProtocolInfo(String name, String title) {
        this.name       = name;
        this.title      = title;
        this.parameters = new ArrayList<Parameter>();
    }

    /**
     * Creates a new ProtocolInfo having the given name, title, and parameters.
     *
     * @param name
     *     The unique name associated with the protocol.
     *
     * @param title
     *     The human-readable title to associate with the protocol.
     * 
     * @param parameters
     *     The parameters to associate with the protocol.
     */
    public ProtocolInfo(String name, String title, Collection<Parameter> parameters) {
        this.name       = name;
        this.title      = title;
        this.parameters = parameters;
    }
    public Collection<Parameter> getParameters() {
    /**
     * Sets the collection of protocol parameters associated with this
     * protocol.
     *
     * @param parameters
     *     The collection of parameters to associate with this protocol.
     */
    public void setParameters(Collection<Parameter> parameters) {
        this.parameters = parameters;
    }
    
import org.glyptodon.guacamole.form.ParameterOption;
    private ParameterOption option = new ParameterOption();
     * Returns the ParameterOption backing this tag.
     * @return The ParameterOption backing this tag.
    public ParameterOption asParameterOption() {
import org.glyptodon.guacamole.form.Parameter;
     * The Parameter backing this tag handler.
    private Parameter protocolParameter = new Parameter();
            protocolParameter.setType(Parameter.Type.TEXT);
            protocolParameter.setType(Parameter.Type.NUMERIC);
            protocolParameter.setType(Parameter.Type.USERNAME);
            protocolParameter.setType(Parameter.Type.PASSWORD);
            protocolParameter.setType(Parameter.Type.ENUM);
            protocolParameter.setType(Parameter.Type.MULTILINE);
            protocolParameter.setType(Parameter.Type.BOOLEAN);
                tagHandler.asParameterOption());
     * Returns the Parameter backing this tag.
     * @return The Parameter backing this tag.
    public Parameter asParameter() {
            info.getParameters().add(tagHandler.asParameter());
 * Copyright (C) 2015 Glyptodon LLC
import java.util.Collection;
import javax.ws.rs.core.Response;
import org.glyptodon.guacamole.form.Parameter;

 * Describes an error that occurred within a REST endpoint.
 *
 * @author Michael Jumper

     * All expected request parameters, if any.
     */
    private final Collection<Parameter> expected;

    /**
     * The type of error that occurred.
     */
    private final Type type;

    /**
     * All possible types of REST API errors.
     */
    public enum Type {

        /**
         * The requested operation could not be performed because the request
         * itself was malformed.
         */
        BAD_REQUEST(Response.Status.BAD_REQUEST),

        /**
         * The credentials provided were invalid.
         */
        INVALID_CREDENTIALS(Response.Status.FORBIDDEN),

        /**
         * The credentials provided were not necessarily invalid, but were not
         * sufficient to determine validity.
         */
        INSUFFICIENT_CREDENTIALS(Response.Status.FORBIDDEN),

        /**
         * An internal server error has occurred.
         */
        INTERNAL_ERROR(Response.Status.INTERNAL_SERVER_ERROR),

        /**
         * An object related to the request does not exist.
         */
        NOT_FOUND(Response.Status.NOT_FOUND),

        /**
         * Permission was denied to perform the requested operation.
         */
        PERMISSION_DENIED(Response.Status.FORBIDDEN);

        /**
         * The HTTP status associated with this error type.
         */
        private final Response.Status status;

        /**
         * Defines a new error type associated with the given HTTP status.
         *
         * @param status
         *     The HTTP status to associate with the error type.
         */
        Type(Response.Status status) {
            this.status = status;
        }

        /**
         * Returns the HTTP status associated with this error type.
         *
         * @return
         *     The HTTP status associated with this error type.
         */
        public Response.Status getStatus() {
            return status;
        }

    }

    /**
     * Create a new APIError with the specified error message.
     *
     * @param type
     *     The type of error that occurred.
     *
     * @param message
     *     The error message.
     */
    public APIError(Type type, String message) {
        this.type     = type;
        this.message  = message;
        this.expected = null;
    }

    /**
     * Create a new APIError with the specified error message and parameter
     * information.
     *
     * @param type
     *     The type of error that occurred.
     *
     * @param message
     *     The error message.
     *
     * @param expected
     *     All parameters expected in the original request, or now required as
     *     a result of the original request.
     */
    public APIError(Type type, String message, Collection<Parameter> expected) {
        this.type     = type;
        this.message  = message;
        this.expected = expected;
    }

    /**
     * Returns the type of error that occurred.
     *
     * @return
     *     The type of error that occurred.
     */
    public Type getType() {
        return type;
    }

    /**
     * Returns an object which describes the required credentials.
     *
     * @return
     *     An object which describes the required credentials.
     */
    public Collection<Parameter> getExpected() {
        return expected;
    }

    /**
     * Returns a human-readable error message describing the error that
     * occurred.
     *
     * @return
     *     A human-readable error message.
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;

        // Additional credentials are needed
        catch (GuacamoleInsufficientCredentialsException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Permission denied.";

            throw new APIException(
                APIError.Type.INSUFFICIENT_CREDENTIALS,
                message,
                e.getCredentialsInfo().getParameters()
            );

        // The provided credentials are wrong
        catch (GuacamoleInvalidCredentialsException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Permission denied.";

            throw new APIException(
                APIError.Type.INVALID_CREDENTIALS,
                message,
                e.getCredentialsInfo().getParameters()
            );

        // Generic permission denied
        catch (GuacamoleSecurityException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Permission denied.";

            throw new APIException(
                APIError.Type.PERMISSION_DENIED,
                message
            );

        }

        // Arbitrary resource not found
        catch (GuacamoleResourceNotFoundException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Not found.";

            throw new APIException(
                APIError.Type.NOT_FOUND,
                message
            );

        }
        
        // Arbitrary bad requests
        catch (GuacamoleClientException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Invalid request.";

            throw new APIException(
                APIError.Type.BAD_REQUEST,
                message
            );

        }

        // All other errors
        catch (GuacamoleException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Unexpected server error.";

            logger.debug("Unexpected exception in REST endpoint.", e);
            throw new APIException(
                APIError.Type.INTERNAL_ERROR,
                message
            );

import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.glyptodon.guacamole.net.basic.rest.APIError;
import org.glyptodon.guacamole.net.basic.rest.APIException;
            // Request standard username/password if no user context was produced
            if (userContext == null)
                throw new GuacamoleInvalidCredentialsException("Permission Denied.",
                        CredentialsInfo.USERNAME_PASSWORD);

        catch (GuacamoleException e) {
            throw e;
        
            throw new APIException(APIError.Type.NOT_FOUND, "No such token.");
import org.glyptodon.guacamole.net.basic.rest.APIError;
import org.glyptodon.guacamole.net.basic.rest.APIException;
            throw new APIException(APIError.Type.BAD_REQUEST,
            throw new APIException(APIError.Type.PERMISSION_DENIED,
            throw new APIException(APIError.Type.PERMISSION_DENIED,
                throw new APIException(APIError.Type.BAD_REQUEST,
                throw new APIException(APIError.Type.BAD_REQUEST, "Unsupported patch path: \""  path  "\"");
import org.glyptodon.guacamole.net.basic.rest.language.LanguageRESTService;
        bind(ClipboardRESTService.class);
        bind(ConnectionGroupRESTService.class);
        bind(ConnectionRESTService.class);
        bind(LanguageRESTService.class);
        bind(ProtocolRESTService.class);
        bind(TokenRESTService.class);
        bind(UserRESTService.class);
    private static final String TRANSLATION_PATH = "/translations";
     *     A map of languages defined in the system, of language key to 
     *     display name.
        Set<String> resourcePaths = servletContext.getResourcePaths(TRANSLATION_PATH);
        for (String resourcePath : resourcePaths) {
import org.glyptodon.guacamole.net.basic.rest.language.LanguageRESTService;
        bind(ClipboardRESTService.class);
        bind(ConnectionGroupRESTService.class);
        bind(ConnectionRESTService.class);
        bind(LanguageRESTService.class);
        bind(ProtocolRESTService.class);
        bind(TokenRESTService.class);
        bind(UserRESTService.class);
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/language/package-info.java
 * Copyright (C) 2014 Glyptodon LLC
/**
 * Classes related to the language retrieval aspect of the Guacamole REST API.
 */
package org.glyptodon.guacamole.net.basic.rest.language;

        if (model.getName() == null || model.getName().trim().isEmpty())
        if (model.getName() == null || model.getName().trim().isEmpty())
            if (value == null || value.isEmpty())
        if (model.getName() == null || model.getName().trim().isEmpty())
        if (model.getName() == null || model.getName().trim().isEmpty())
        if (model.getIdentifier() == null || model.getIdentifier().trim().isEmpty())
        if (model.getIdentifier() == null || model.getIdentifier().trim().isEmpty())
        if (model.getName() == null || model.getName().trim().isEmpty())
        if (model.getName() == null || model.getName().trim().isEmpty())
            if (value == null || value.isEmpty())
        if (model.getName() == null || model.getName().trim().isEmpty())
        if (model.getName() == null || model.getName().trim().isEmpty())
        if (model.getIdentifier() == null || model.getIdentifier().trim().isEmpty())
        if (model.getIdentifier() == null || model.getIdentifier().trim().isEmpty())
import org.glyptodon.guacamole.net.SimpleGuacamoleTunnel;
        GuacamoleTunnel tunnel = new SimpleGuacamoleTunnel(socket);
            return Collections.<InternalType>emptyList();
                return Collections.<String>emptyList();
            return Collections.<ModeledConnection>emptyList();
            return Collections.<ModeledConnection>emptyList();
            return Collections.<ActiveConnectionRecord>emptyList();
            return Collections.<ActiveConnectionRecord>emptyList();
            return Collections.<ActiveConnectionRecord>emptyList();
    public static final CredentialsInfo EMPTY = new CredentialsInfo(Collections.<Parameter>emptyList());
        return Collections.<ConnectionRecord>emptyList();
    private Map<String, ObjectType> objects = Collections.<String, ObjectType>emptyMap();
    private Set<ObjectPermission> permissions = Collections.<ObjectPermission>emptySet();
    private Set<SystemPermission> permissions = Collections.<SystemPermission>emptySet();
            connectionIdentifiers, Collections.<String>emptyList()
        return Collections.<ConnectionRecord>emptyList();
            return Collections.<String, String>emptyMap();
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
    /**
     * Guacamole server environment.
     */
    private final Environment environment;

    /**
     * Creates a new LDAPAuthenticationProvider that authenticates users
     * against an LDAP directory.
     *
     * @throws GuacamoleException
     *     If a required property is missing, or an error occurs while parsing
     *     a property.
     */
    public LDAPAuthenticationProvider() throws GuacamoleException {
        environment = new LocalEnvironment();
    }

                    environment.getRequiredProperty(LDAPGuacamoleProperties.LDAP_HOSTNAME),
                    environment.getRequiredProperty(LDAPGuacamoleProperties.LDAP_PORT)
        String username_attribute = environment.getRequiredProperty(
        String user_base_dn = environment.getRequiredProperty(
        String config_base_dn = environment.getRequiredProperty(
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
     * Guacamole server environment.
     */
    private final Environment environment;
    
    /**
     * Creates a new NoAuthenticationProvider that does not perform any
     * authentication at all. All attempts to access the Guacamole system are
     * presumed to be authorized.
     *
     * @throws GuacamoleException
     *     If a required property is missing, or an error occurs while parsing
     *     a property.
     */
    public NoAuthenticationProvider() throws GuacamoleException {
        environment = new LocalEnvironment();
    }

    /**
        return environment.getRequiredProperty(NOAUTH_CONFIG);
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
     * Guacamole server environment.
     */
    private final Environment environment;

    /**
     * Creates a new BasicFileAuthenticationProvider that authenticates users
     * against simple, monolithic XML file.
     *
     * @throws GuacamoleException
     *     If a required property is missing, or an error occurs while parsing
     *     a property.
     */
    public BasicFileAuthenticationProvider() throws GuacamoleException {
        environment = new LocalEnvironment();
    }

    /**
                environment.getRequiredProperty(BASIC_USER_MAPPING);
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;

                    // TODONT: This should be injected, but GuacamoleClassLoader will be removed soon.
                    Environment environment = new LocalEnvironment();
                    
                        environment.getProperty(BasicGuacamoleProperties.LIB_DIRECTORY)

import org.glyptodon.guacamole.environment.Environment;
     * @param environment
     *     The environment of the Guacamole server associated with this new
     *     session.
     *
     * @param credentials
     *     The credentials provided by the user during login.
     *
     * @param userContext
     *     The user context to associate this session with.
     *
     * @throws GuacamoleException
     *     If an error prevents the session from being created.
    public GuacamoleSession(Environment environment, Credentials credentials,
            UserContext userContext) throws GuacamoleException {
                    environment.getProperty(BasicGuacamoleProperties.EVENT_LISTENERS);
import org.glyptodon.guacamole.environment.Environment;
     * The Guacamole server environment.
     */
    @Inject
    private Environment environment;
    
    /**
                    if (environment.getProperty(ClipboardRESTService.INTEGRATION_ENABLED, false)) {
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
     * The Guacamole server environment.
     */
    private Environment environment;
    
    /**

            // Bind environment
            environment = new LocalEnvironment();
            bind(Environment.class).toInstance(environment);

            // Get and bind auth provider instance
            authProvider = environment.getRequiredProperty(BasicGuacamoleProperties.AUTH_PROVIDER);


import com.google.inject.Inject;
import org.glyptodon.guacamole.environment.Environment;
     * The Guacamole server environment.
     */
    @Inject
    private Environment environment;
    
    /**
            sessionTimeoutValue = environment.getProperty(BasicGuacamoleProperties.API_SESSION_TIMEOUT, 60);
import org.glyptodon.guacamole.environment.Environment;

    /**
     * The Guacamole server environment.
     */
    @Inject
    private Environment environment;
            tokenSessionMap.put(authToken, new GuacamoleSession(environment, credentials, userContext));
import org.glyptodon.guacamole.environment.Environment;
     * The Guacamole server environment.
     */
    @Inject
    private Environment environment;
    
    /**
        if (environment.getProperty(INTEGRATION_ENABLED, false)) {
                for (Class<?> listenerClass : listenerClasses) {
            Class<?> module = (Class<?>) GuacamoleClassLoader.getInstance().findClass(classname);
            TunnelLoader loader = (TunnelLoader) module.getConstructor().newInstance();

        Set<?> resourcePaths = servletContext.getResourcePaths(TRANSLATION_PATH);
        for (Object resourcePathObject : resourcePaths) {

            // Each resource path is guaranteed to be a string
            String resourcePath = (String) resourcePathObject;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/inject/AuthenticationModule.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.inject;
import com.google.inject.Inject;
 *
public class AuthenticationModule extends AbstractModule {
    private final Logger logger = LoggerFactory.getLogger(AuthenticationModule.class);
    private final Environment environment;
     * Singleton instance of TokenSessionMap.
    private final TokenSessionMap tokenSessionMap;
     *
     * @param environment
     *     The environment to use when configuring authentication.
     *
     * @param tokenSessionMap
     *     An instance of TokenSessionMap to inject as a singleton wherever
     *     needed.
    public AuthenticationModule(Environment environment,
            TokenSessionMap tokenSessionMap) {
        this.environment = environment;
        this.tokenSessionMap = tokenSessionMap;

        // Bind session map
        bind(TokenSessionMap.class).toInstance(tokenSessionMap);

        // Bind low-level services
        bind(AuthenticationService.class);
        bind(AuthTokenGenerator.class).to(SecureRandomAuthTokenGenerator.class);

        // Get and bind auth provider instance
            AuthenticationProvider authProvider = environment.getRequiredProperty(BasicGuacamoleProperties.AUTH_PROVIDER);

 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/inject/EnvironmentModule.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.inject;
import org.glyptodon.guacamole.environment.Environment;
 * Guice module which binds the base Guacamole server environment.
 *
 * @author Michael Jumper
public class EnvironmentModule extends AbstractModule {

    /**
     * The Guacamole server environment.
     */
    private final Environment environment;

    /**
     * Creates a new EnvironmentModule which will bind the given environment
     * for future injection.
     *
     * @param environment
     *     The environment to bind.
     */
    public EnvironmentModule(Environment environment) {
        this.environment = environment;
    }
        // Bind environment
        bind(Environment.class).toInstance(environment);


 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/inject/LogModule.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.inject;
import org.glyptodon.guacamole.environment.Environment;
    /**
     * The Guacamole server environment.
     */
    private final Environment environment;

    /**
     * Creates a new LogModule which uses the given environment to determine
     * the logging configuration.
     *
     * @param environment
     *     The environment to use when configuring logging.
     */
    public LogModule(Environment environment) {
        this.environment = environment;
    }
    
        File guacamoleHome = environment.getGuacamoleHome();


 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/inject/RESTModule.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.inject;
import com.google.inject.matcher.Matchers;
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExceptionWrapper;
import org.glyptodon.guacamole.net.basic.rest.AuthProviderRESTExposure;
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
 *
public class RESTModule extends ServletModule {


        // Bind @AuthProviderRESTExposure annotation
        bindInterceptor(
            Matchers.any(),
            Matchers.annotatedWith(AuthProviderRESTExposure.class),
            new AuthProviderRESTExceptionWrapper()
        );

        // Bind convenience services used by the REST API
        bind(ObjectRetrievalService.class);



 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/inject/TunnelModule.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.net.basic.inject;
import org.glyptodon.guacamole.net.basic.BasicGuacamoleTunnelServlet;
import org.glyptodon.guacamole.net.basic.GuacamoleClassLoader;
import org.glyptodon.guacamole.net.basic.TunnelLoader;
import org.glyptodon.guacamole.net.basic.TunnelRequestService;
 *
            // Attempt to find WebSocket module
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/inject/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Dependency injection classes specific to the Guacamole web application.
package org.glyptodon.guacamole.net.basic.inject;
     * Create a new BasicTokenGuacamoleSessionMap configured using the given
     * environment.
     *
     * @param environment
     *     The environment to use when configuring the token session map.
    public BasicTokenSessionMap(Environment environment) {
        Collection<ParameterModel> parameterModels = new ArrayList<ParameterModel>(parameters.size());
        Collection<String> affectedIdentifiers = new HashSet<String>(permissions.size());
                    Enumeration<?> parameters = parameterAttribute.getStringValues();
                        String parameter = (String) parameters.nextElement();
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/BasicServletContextListener.java
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.net.basic.log.LogModule;
import org.glyptodon.guacamole.net.basic.rest.RESTAuthModule;
import org.glyptodon.guacamole.net.basic.rest.RESTServletModule;
        return Guice.createInjector(Stage.PRODUCTION,
            new RESTAuthModule(environment, sessionMap),
            new RESTServletModule(),
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/EnvironmentModule.java
package org.glyptodon.guacamole.net.basic;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/TunnelModule.java
package org.glyptodon.guacamole.net.basic;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/log/LogModule.java
package org.glyptodon.guacamole.net.basic.log;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/RESTAuthModule.java
package org.glyptodon.guacamole.net.basic.rest;
public class RESTAuthModule extends AbstractModule {
    private final Logger logger = LoggerFactory.getLogger(RESTAuthModule.class);
    public RESTAuthModule(Environment environment,
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/RESTServletModule.java
package org.glyptodon.guacamole.net.basic.rest;
public class RESTServletModule extends ServletModule {
import org.glyptodon.guacamole.net.SimpleGuacamoleTunnel;
        GuacamoleTunnel tunnel = new SimpleGuacamoleTunnel(socket);
            return Collections.<InternalType>emptyList();
                return Collections.<String>emptyList();
        Collection<ParameterModel> parameterModels = new ArrayList<ParameterModel>(parameters.size());
        Collection<String> affectedIdentifiers = new HashSet<String>(permissions.size());
            return Collections.<ModeledConnection>emptyList();
            return Collections.<ModeledConnection>emptyList();
            return Collections.<ActiveConnectionRecord>emptyList();
            return Collections.<ActiveConnectionRecord>emptyList();
            return Collections.<ActiveConnectionRecord>emptyList();
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
    /**
     * Guacamole server environment.
     */
    private final Environment environment;

    /**
     * Creates a new LDAPAuthenticationProvider that authenticates users
     * against an LDAP directory.
     *
     * @throws GuacamoleException
     *     If a required property is missing, or an error occurs while parsing
     *     a property.
     */
    public LDAPAuthenticationProvider() throws GuacamoleException {
        environment = new LocalEnvironment();
    }

                    environment.getRequiredProperty(LDAPGuacamoleProperties.LDAP_HOSTNAME),
                    environment.getRequiredProperty(LDAPGuacamoleProperties.LDAP_PORT)
        String username_attribute = environment.getRequiredProperty(
        String user_base_dn = environment.getRequiredProperty(
        String config_base_dn = environment.getRequiredProperty(
                    Enumeration<?> parameters = parameterAttribute.getStringValues();
                        String parameter = (String) parameters.nextElement();
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
     * Guacamole server environment.
     */
    private final Environment environment;
    
    /**
     * Creates a new NoAuthenticationProvider that does not perform any
     * authentication at all. All attempts to access the Guacamole system are
     * presumed to be authorized.
     *
     * @throws GuacamoleException
     *     If a required property is missing, or an error occurs while parsing
     *     a property.
     */
    public NoAuthenticationProvider() throws GuacamoleException {
        environment = new LocalEnvironment();
    }

    /**
        return environment.getRequiredProperty(NOAUTH_CONFIG);
    public static final CredentialsInfo EMPTY = new CredentialsInfo(Collections.<Parameter>emptyList());
        return Collections.<ConnectionRecord>emptyList();
    private Map<String, ObjectType> objects = Collections.<String, ObjectType>emptyMap();
    private Set<ObjectPermission> permissions = Collections.<ObjectPermission>emptySet();
    private Set<SystemPermission> permissions = Collections.<SystemPermission>emptySet();
            connectionIdentifiers, Collections.<String>emptyList()
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
     * Guacamole server environment.
     */
    private final Environment environment;

    /**
     * Creates a new BasicFileAuthenticationProvider that authenticates users
     * against simple, monolithic XML file.
     *
     * @throws GuacamoleException
     *     If a required property is missing, or an error occurs while parsing
     *     a property.
     */
    public BasicFileAuthenticationProvider() throws GuacamoleException {
        environment = new LocalEnvironment();
    }

    /**
                environment.getRequiredProperty(BASIC_USER_MAPPING);
 * Copyright (C) 2015 Glyptodon LLC
import com.google.inject.Stage;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 *
     * Logger for this class.
     */
    private final Logger logger = LoggerFactory.getLogger(BasicServletContextListener.class);

    /**
     * The Guacamole server environment.
     */
    private Environment environment;

    /**
    private TokenSessionMap sessionMap;

    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {

        try {
            environment = new LocalEnvironment();
            sessionMap = new BasicTokenSessionMap(environment);
        }
        catch (GuacamoleException e) {
            logger.error("Unable to read guacamole.properties: {}", e.getMessage());
            logger.debug("Error reading guacamole.properties.", e);
            throw new RuntimeException(e);
        }

        super.contextInitialized(servletContextEvent);

    }

        return Guice.createInjector(Stage.PRODUCTION,
            new EnvironmentModule(environment),
            new LogModule(environment),
            new RESTAuthModule(environment, sessionMap),
            new RESTServletModule(),

        // Shutdown TokenSessionMap
        if (sessionMap != null)
            sessionMap.shutdown();


 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/EnvironmentModule.java
 * Copyright (C) 2015 Glyptodon LLC
package org.glyptodon.guacamole.net.basic;
import org.glyptodon.guacamole.environment.Environment;
 * Guice module which binds the base Guacamole server environment.
 *
 * @author Michael Jumper
public class EnvironmentModule extends AbstractModule {

    /**
     * The Guacamole server environment.
     */
    private final Environment environment;

    /**
     * Creates a new EnvironmentModule which will bind the given environment
     * for future injection.
     *
     * @param environment
     *     The environment to bind.
     */
    public EnvironmentModule(Environment environment) {
        this.environment = environment;
    }
        // Bind environment
        bind(Environment.class).toInstance(environment);



import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.environment.LocalEnvironment;

                    // TODONT: This should be injected, but GuacamoleClassLoader will be removed soon.
                    Environment environment = new LocalEnvironment();
                    
                        environment.getProperty(BasicGuacamoleProperties.LIB_DIRECTORY)

import org.glyptodon.guacamole.environment.Environment;
     * @param environment
     *     The environment of the Guacamole server associated with this new
     *     session.
     *
     * @param credentials
     *     The credentials provided by the user during login.
     *
     * @param userContext
     *     The user context to associate this session with.
     *
     * @throws GuacamoleException
     *     If an error prevents the session from being created.
    public GuacamoleSession(Environment environment, Credentials credentials,
            UserContext userContext) throws GuacamoleException {
                    environment.getProperty(BasicGuacamoleProperties.EVENT_LISTENERS);
                for (Class<?> listenerClass : listenerClasses) {
 * Copyright (C) 2015 Glyptodon LLC
 *
            // Attempt to find WebSocket module
            Class<?> module = (Class<?>) GuacamoleClassLoader.getInstance().findClass(classname);
            TunnelLoader loader = (TunnelLoader) module.getConstructor().newInstance();
import org.glyptodon.guacamole.environment.Environment;
     * The Guacamole server environment.
     */
    @Inject
    private Environment environment;
    
    /**
                    if (environment.getProperty(ClipboardRESTService.INTEGRATION_ENABLED, false)) {
 * Copyright (C) 2015 Glyptodon LLC
import org.glyptodon.guacamole.environment.Environment;
    /**
     * The Guacamole server environment.
     */
    private final Environment environment;

    /**
     * Creates a new LogModule which uses the given environment to determine
     * the logging configuration.
     *
     * @param environment
     *     The environment to use when configuring logging.
     */
    public LogModule(Environment environment) {
        this.environment = environment;
    }
    
        File guacamoleHome = environment.getGuacamoleHome();


 * Copyright (C) 2015 Glyptodon LLC
import org.glyptodon.guacamole.environment.Environment;
 *
    private final Logger logger = LoggerFactory.getLogger(RESTAuthModule.class);
     * The Guacamole server environment.
    private final Environment environment;
     * Singleton instance of TokenSessionMap.
    private final TokenSessionMap tokenSessionMap;
     *
     * @param environment
     *     The environment to use when configuring authentication.
     *
     * @param tokenSessionMap
     *     An instance of TokenSessionMap to inject as a singleton wherever
     *     needed.
    public RESTAuthModule(Environment environment,
            TokenSessionMap tokenSessionMap) {
        this.environment = environment;
        this.tokenSessionMap = tokenSessionMap;

        // Bind session map
        bind(TokenSessionMap.class).toInstance(tokenSessionMap);

        // Bind low-level services
        bind(AuthenticationService.class);
        bind(AuthTokenGenerator.class).to(SecureRandomAuthTokenGenerator.class);

            AuthenticationProvider authProvider = environment.getRequiredProperty(BasicGuacamoleProperties.AUTH_PROVIDER);

 * Copyright (C) 2015 Glyptodon LLC
import com.google.inject.matcher.Matchers;
 *


        // Bind @AuthProviderRESTExposure annotation
        bindInterceptor(
            Matchers.any(),
            Matchers.annotatedWith(AuthProviderRESTExposure.class),
            new AuthProviderRESTExceptionWrapper()
        );

        // Bind convenience services used by the REST API
        bind(ObjectRetrievalService.class);



import org.glyptodon.guacamole.environment.Environment;
     * Create a new BasicTokenGuacamoleSessionMap configured using the given
     * environment.
     *
     * @param environment
     *     The environment to use when configuring the token session map.
    public BasicTokenSessionMap(Environment environment) {
            sessionTimeoutValue = environment.getProperty(BasicGuacamoleProperties.API_SESSION_TIMEOUT, 60);
import org.glyptodon.guacamole.environment.Environment;

    /**
     * The Guacamole server environment.
     */
    @Inject
    private Environment environment;
            tokenSessionMap.put(authToken, new GuacamoleSession(environment, credentials, userContext));
import org.glyptodon.guacamole.environment.Environment;
     * The Guacamole server environment.
     */
    @Inject
    private Environment environment;
    
    /**
        if (environment.getProperty(INTEGRATION_ENABLED, false)) {
        return Collections.<ConnectionRecord>emptyList();

        Set<?> resourcePaths = servletContext.getResourcePaths(TRANSLATION_PATH);
            return Collections.<String, String>emptyMap();
        for (Object resourcePathObject : resourcePaths) {

            // Each resource path is guaranteed to be a string
            String resourcePath = (String) resourcePathObject;
import org.glyptodon.guacamole.net.basic.resource.ResourceServlet;
import org.glyptodon.guacamole.net.basic.resource.WebApplicationResource;
        // TODO: Pull these from extensions, dynamically concatenated
        serve("/app.js").with(new ResourceServlet(new WebApplicationResource(getServletContext(), "/guacamole.min.js")));
        serve("/app.css").with(new ResourceServlet(new WebApplicationResource(getServletContext(), "/guacamole.min.css")));

import org.glyptodon.guacamole.net.basic.extension.ExtensionModule;
            new ExtensionModule(environment),
import java.util.ArrayList;
import java.util.Collection;
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.net.basic.resource.Resource;
import org.glyptodon.guacamole.net.basic.resource.SequenceResource;

        File[] extensionFiles = extensionsDir.listFiles(new FileFilter() {
        // Init JavaScript resources with base guacamole.min.js
        Collection<Resource> javaScriptResources = new ArrayList<Resource>();
        javaScriptResources.add(new WebApplicationResource(getServletContext(), "/guacamole.min.js"));

        // Init CSS resources with base guacamole.min.css
        Collection<Resource> cssResources = new ArrayList<Resource>();
        cssResources.add(new WebApplicationResource(getServletContext(), "/guacamole.min.css"));

        // Load each extension within the extension directory
        for (File extensionFile : extensionFiles) {

            logger.debug("Loading extension: \"{}\"", extensionFile.getName());

            try {

                // FIXME: Use class loader which reads from the lib directory
                // Load extension from file
                Extension extension = new Extension(ExtensionModule.class.getClassLoader(), extensionFile);

                // Add any JavaScript / CSS resources
                javaScriptResources.addAll(extension.getJavaScriptResources());
                cssResources.addAll(extension.getCSSResources());

                // Log successful loading of extension by name
                logger.info("Extension \"{}\" loaded.", extension.getName());

            }
            catch (GuacamoleException e) {
                logger.error("Extension \"{}\" could not be loaded: {}", extensionFile.getName(), e.getMessage());
                logger.debug("Unable to load extension.", e);
            }


        // Dynamically generate app.js and app.css from extensions
        serve("/app.js").with(new ResourceServlet(new SequenceResource(javaScriptResources)));
        serve("/app.css").with(new ResourceServlet(new SequenceResource(cssResources)));
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
     * The collection of all JavaScript resources defined within the extension.
     */
    private final Collection<Resource> javaScriptResources;

    /**
     * The collection of all CSS resources defined within the extension.
     */
    private final Collection<Resource> cssResources;

    /**
     * The collection of all AuthenticationProvider classes defined within the
     * extension.
     */
    private final Collection<Class<AuthenticationProvider>> authenticationProviderClasses;

    /**
     * Returns a new collection of resources corresponding to the collection of
     * paths provided. Each resource will be associated with the given
     * mimetype.
     *
     * @param mimetype
     *     The mimetype to associate with each resource.
     *
     * @param paths
     *     The paths corresponding to the resources desired.
     *
     * @return
     *     A new, unmodifiable collection of resources corresponding to the
     *     collection of paths provided.
     */
    private Collection<Resource> getClassPathResources(String mimetype, Collection<String> paths) {

        // If no paths are provided, just return an empty list
        if (paths == null)
            return Collections.<Resource>emptyList();

        // Add classpath resource for each path provided
        Collection<Resource> resources = new ArrayList<Resource>(paths.size());
        for (String path : paths)
            resources.add(new ClassPathResource(classLoader, mimetype, path));

        // Callers should not rely on modifying the result
        return Collections.unmodifiableCollection(resources);

    }

    /**
     * Retrieve the AuthenticationProvider subclass having the given name. If
     * the class having the given name does not exist or isn't actually a
     * subclass of AuthenticationProvider, an exception will be thrown.
     *
     * @param name
     *     The name of the AuthenticationProvider class to retrieve.
     *
     * @return
     *     The subclass of AuthenticationProvider having the given name.
     *
     * @throws GuacamoleException
     *     If no such class exists, or if the class with the given name is not
     *     a subclass of AuthenticationProvider.
     */
    @SuppressWarnings("unchecked") // We check this ourselves with isAssignableFrom()
    private Class<AuthenticationProvider> getAuthenticationProviderClass(String name)
            throws GuacamoleException {

        try {

            // Get authentication provider class
            Class<?> authenticationProviderClass = classLoader.loadClass(name);

            // Verify the located class is actually a subclass of AuthenticationProvider
            if (!AuthenticationProvider.class.isAssignableFrom(authenticationProviderClass))
                throw new GuacamoleServerException("Authentication providers MUST extend the AuthenticationProvider class.");

            // Return located class
            return (Class<AuthenticationProvider>) authenticationProviderClass;

        }
        catch (ClassNotFoundException e) {
            throw new GuacamoleException("Authentication provider class not found.", e);
        }

    }

    /**
     * Returns a new collection of all AuthenticationProvider subclasses having
     * the given names. If any class does not exist or isn't actually a
     * subclass of AuthenticationProvider, an exception will be thrown, and
     * no further AuthenticationProvider classes will be loaded.
     *
     * @param names
     *     The names of the AuthenticationProvider classes to retrieve.
     *
     * @return
     *     A new collection of all AuthenticationProvider subclasses having the
     *     given names.
     *
     * @throws GuacamoleException
     *     If any given class does not exist, or if any given class is not a
     *     subclass of AuthenticationProvider.
     */
    private Collection<Class<AuthenticationProvider>> getAuthenticationProviderClasses(Collection<String> names)
            throws GuacamoleException {

        // If no classnames are provided, just return an empty list
        if (names == null)
            return Collections.<Class<AuthenticationProvider>>emptyList();

        // Define all auth provider classes
        Collection<Class<AuthenticationProvider>> classes = new ArrayList<Class<AuthenticationProvider>>(names.size());
        for (String name : names)
            classes.add(getAuthenticationProviderClass(name));

        // Callers should not rely on modifying the result
        return Collections.unmodifiableCollection(classes);

    }

    /**
        // Define static resources
        cssResources = getClassPathResources("text/css", manifest.getCSSPaths());
        javaScriptResources = getClassPathResources("text/javascript", manifest.getJavaScriptPaths());

        // Define authentication providers
        authenticationProviderClasses = getAuthenticationProviderClasses(manifest.getAuthProviders());

        return javaScriptResources;
        return cssResources;
    }

    /**
     * Returns all declared authentication providers classes associated with
     * this extension. Authentication providers are declared within the
     * extension manifest.
     *
     * @return
     *     All declared authentication provider classes with this extension.
     */
    public Collection<Class<AuthenticationProvider>> getAuthenticationProviderClasses() {
        return authenticationProviderClasses;
     * The names of all authentication provider classes within this extension,
     * if any.
     */
    private Collection<String> authProviders;

    /**
    /**
     * Returns the classnames of all authentication provider classes within the
     * extension. These classnames are defined within the manifest by the
     * "authProviders" property as an array of strings, where each string is an
     * authentication provider classname.
     *
     * @return
     *     A collection of classnames of all authentication providers within
     *     the extension.
     */
    public Collection<String> getAuthProviders() {
        return authProviders;
    }

    /**
     * Sets the classnames of all authentication provider classes within the
     * extension. These classnames are defined within the manifest by the
     * "authProviders" property as an array of strings, where each string is an
     * authentication provider classname.
     *
     * @param authProviders
     *     A collection of classnames of all authentication providers within
     *     the extension.
     */
    public void setAuthProviders(Collection<String> authProviders) {
        this.authProviders = authProviders;
    }

import com.google.inject.Singleton;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
                // Load all authentication providers as singletons
                Collection<Class<AuthenticationProvider>> authenticationProviders = extension.getAuthenticationProviderClasses();
                for (Class<AuthenticationProvider> authenticationProvider : authenticationProviders) {
                    logger.debug("Binding AuthenticationProvider \"{}\".", authenticationProvider);
                    bind(AuthenticationProvider.class).to(authenticationProvider).in(Singleton.class);
                }

        // Get and bind auth provider instance, if defined via property

            // Use "auth-provider" property if present, but warn about deprecation
            AuthenticationProvider authProvider = environment.getProperty(BasicGuacamoleProperties.AUTH_PROVIDER);
            if (authProvider != null) {
                logger.warn("The \"auth-provider\" is now deprecated. Please use the \"extensions\" directory within GUACAMOLE_HOME instead.");
                bind(AuthenticationProvider.class).toInstance(authProvider);
            }

            logger.warn("Value of deprecated \"auth-provider\" property within guacamole.properties is not valid: {}", e.getMessage());
            Class<?> module = Class.forName(classname);
            Class.forName("javax.websocket.Endpoint");
            Class.forName("org.glyptodon.guacamole.net.basic.websocket.jetty8.BasicGuacamoleWebSocketTunnelServlet");
            Class.forName("org.glyptodon.guacamole.net.basic.websocket.jetty9.BasicGuacamoleWebSocketTunnelServlet");
            Class.forName("org.glyptodon.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet");
     * The name of the directory within GUACAMOLE_HOME containing any .jars
     * which should be included in the classpath of all extensions.
     */
    private static final String LIB_DIRECTORY = "lib";

    /**
     * Returns the classloader that should be used as the parent classloader
     * for all extensions. If the GUACAMOLE_HOME/lib directory exists, this
     * will be a classloader that loads classes from within the .jar files in
     * that directory. Lacking the GUACAMOLE_HOME/lib directory, this will
     * simply be the classloader associated with the ExtensionModule class.
     *
     * @return
     *     The classloader that should be used as the parent classloader for
     *     all extensions.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the classloader.
     */
    private ClassLoader getParentClassLoader() throws GuacamoleException {

        // Retrieve lib directory
        File libDir = new File(environment.getGuacamoleHome(), LIB_DIRECTORY);

        // If lib directory does not exist, use default class loader
        if (!libDir.isDirectory())
            return ExtensionModule.class.getClassLoader();

        // Return classloader which loads classes from all .jars within the lib directory
        return DirectoryClassLoader.getInstance(libDir);

    }

    /**
                Extension extension = new Extension(getParentClassLoader(), extensionFile);
                logger.warn("The \"auth-provider\" and \"lib-directory\" properties are now deprecated. Please use the \"extensions\" and \"lib\" directories within GUACAMOLE_HOME instead.");
            new RESTAuthModule(sessionMap),
 * directory. This directory is set within guacamole.properties. This class
 * is deprecated in favor of DirectoryClassLoader, which is automatically
 * configured based on the presence/absence of GUACAMOLE_HOME/lib.
@Deprecated
import net.sourceforge.guacamole.net.basic.BasicFileAuthenticationProvider;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
     * The currently-bound authentication provider, if any. At the moment, we
     * only support one authentication provider loaded at any one time.
     */
    private Class<? extends AuthenticationProvider> boundAuthenticationProvider = null;

    /**
    /**
     * Reads the value of the now-deprecated "auth-provider" property from
     * guacamole.properties, returning the corresponding AuthenticationProvider
     * class. If no authentication provider could be read, or the property is
     * not present, null is returned.
     *
     * As this property is deprecated, this function will also log warning
     * messages if the property is actually specified.
     *
     * @return
     *     The value of the deprecated "auth-provider" property, or null if the
     *     property is not present.
     */
    @SuppressWarnings("deprecation") // We must continue to use this property until it is truly no longer supported
    private Class<AuthenticationProvider> getAuthProviderProperty() {

        // Get and bind auth provider instance, if defined via property
        try {

            // Use "auth-provider" property if present, but warn about deprecation
            Class<AuthenticationProvider> authenticationProvider = environment.getProperty(BasicGuacamoleProperties.AUTH_PROVIDER);
            if (authenticationProvider != null)
                logger.warn("The \"auth-provider\" and \"lib-directory\" properties are now deprecated. Please use the \"extensions\" and \"lib\" directories within GUACAMOLE_HOME instead.");

            return authenticationProvider;

        }
        catch (GuacamoleException e) {
            logger.warn("Value of deprecated \"auth-provider\" property within guacamole.properties is not valid: {}", e.getMessage());
            logger.debug("Error reading authentication provider from guacamole.properties.", e);
        }

        return null;

    }

    /**
     * Binds the given AuthenticationProvider class such that any service
     * requiring access to the AuthenticationProvider can obtain it via
     * injection.
     *
     * @param authenticationProvider
     *     The AuthenticationProvider class to bind.
     */
    private void bindAuthenticationProvider(Class<? extends AuthenticationProvider> authenticationProvider) {

        // Choose auth provider for binding if not already chosen
        if (boundAuthenticationProvider != null)
            boundAuthenticationProvider = authenticationProvider;

        // If an auth provider is already chosen, skip and warn
        else {
            logger.debug("Ignoring AuthenticationProvider \"{}\".", authenticationProvider);
            logger.warn("Only one authentication extension may be used at a time. Please "
                       "make sure that only one authentication extension is present "
                       "within the GUACAMOLE_HOME/"  EXTENSIONS_DIRECTORY  " "
                       "directory, and that you are not also specifying the deprecated "
                       "\"auth-provider\" property within guacamole.properties.");
            return;
        }

        // Bind authentication provider
        logger.debug("Binding AuthenticationProvider \"{}\".", authenticationProvider);
        bind(AuthenticationProvider.class).to(authenticationProvider).in(Singleton.class);

    }

        // Load authentication provider from guacamole.properties for sake of backwards compatibility
        Class<AuthenticationProvider> authProviderProperty = getAuthProviderProperty();
        if (authProviderProperty != null)
            bindAuthenticationProvider(authProviderProperty);

                // Attempt to load all authentication providers
                for (Class<AuthenticationProvider> authenticationProvider : authenticationProviders)
                    bindAuthenticationProvider(authenticationProvider);
        // Default to basic auth if nothing else chosen/provided
        if (boundAuthenticationProvider == null) {
            logger.info("Using default, \"basic\", XML-driven authentication.");
            bindAuthenticationProvider(BasicFileAuthenticationProvider.class);
        }

 * Copyright (C) 2015 Glyptodon LLC
 * authenticate users. This class must implement AuthenticationProvider. Use
 * of this property type is deprecated in favor of the
 * GUACAMOLE_HOME/extensions directory.
@Deprecated
public abstract class AuthenticationProviderProperty implements GuacamoleProperty<Class<AuthenticationProvider>> {
    @SuppressWarnings("unchecked") // Explicitly checked within by isAssignableFrom()
    public Class<AuthenticationProvider> parseValue(String authProviderClassName) throws GuacamoleException {
            // Get authentication provider class
            Class<?> authProviderClass = GuacamoleClassLoader.getInstance().loadClass(authProviderClassName);
            // Verify the located class is actually a subclass of AuthenticationProvider
            if (!AuthenticationProvider.class.isAssignableFrom(authProviderClass))
            // Return located class
            return (Class<AuthenticationProvider>) authProviderClass;
     * configurations of a user. This property is currently supported, but
     * deprecated in favor of the GUACAMOLE_HOME/extensions directory.
    @Deprecated
     * The directory to search for authentication provider classes. This
     * property is currently supported, but deprecated in favor of the
     * GUACAMOLE_HOME/lib directory.
    @Deprecated
     * The comma-separated list of all classes to use as event listeners. This
     * property is currently supported, but deprecated in favor of declared
     * event listeners within extension manifests.
 * where each class will be used as a listener for events. This type of
 * property is deprecated in favor of declaring event listeners within
 * extension manifests.
@SuppressWarnings("deprecation")
    public RESTAuthModule(TokenSessionMap tokenSessionMap) {
            Class<?> authProviderClass = org.glyptodon.guacamole.net.basic.GuacamoleClassLoader.getInstance().loadClass(authProviderClassName);
        if (boundAuthenticationProvider == null)
     * Returns the version of the Guacamole web application for which this
     * extension was built.
     *
     * @return
     *     The version of the Guacamole web application for which this
     *     extension was built.
     */
    public String getGuacamoleVersion() {
        return manifest.getGuacamoleVersion();
    }

    /**
     * The version of Guacamole for which this extension was built.
     * Compatibility rules built into the web application will guard against
     * incompatible extensions being loaded.
     */
    private String guacamoleVersion;

    /**
     * Returns the version of the Guacamole web application for which the
     * extension was built, such as "0.9.6".
     *
     * @return
     *     The version of the Guacamole web application for which the extension
     *     was built.
     */
    public String getGuacamoleVersion() {
        return guacamoleVersion;
    }

    /**
     * Sets the version of the Guacamole web application for which the
     * extension was built, such as "0.9.6".
     *
     * @param guacamoleVersion
     *     The version of the Guacamole web application for which the extension
     *     was built.
     */
    public void setGuacamoleVersion(String guacamoleVersion) {
        this.guacamoleVersion = guacamoleVersion;
    }

    /**
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import org.glyptodon.guacamole.GuacamoleServerException;
     * The version strings of all Guacamole versions whose extensions are
     * compatible with this release.
     */
    private static final List<String> ALLOWED_GUACAMOLE_VERSIONS =
        Collections.unmodifiableList(Arrays.asList(
            "0.9.6"
        ));

    /**
    /**
     * Returns whether the given version of Guacamole is compatible with this
     * version of Guacamole as far as extensions are concerned.
     *
     * @param guacamoleVersion
     *     The version of Guacamole the extension was built for.
     *
     * @return
     *     true if the given version of Guacamole is compatible with this
     *     version of Guacamole, false otherwise.
     */
    private boolean isCompatible(String guacamoleVersion) {
        return ALLOWED_GUACAMOLE_VERSIONS.contains(guacamoleVersion);
    }

                // Validate Guacamole version of extension
                if (!isCompatible(extension.getGuacamoleVersion())) {
                    logger.debug("Declared Guacamole version \"{}\" of extension \"{}\" is not compatible with this version of Guacamole.",
                            extension.getGuacamoleVersion(), extensionFile.getName());
                    throw new GuacamoleServerException("Extension \""  extension.getName()  "\" is not "
                             "compatible with this version of Guacamole.");
                }

     * The XML file to read the user mapping from.
     * The default filename to use for the user mapping, if not defined within
     * guacamole.properties.
     */
    public static final String DEFAULT_USER_MAPPING = "user-mapping.xml";
    
    /**
        // Get user mapping file, defaulting to GUACAMOLE_HOME/user-mapping.xml
        File user_mapping_file = environment.getProperty(BASIC_USER_MAPPING);
        if (user_mapping_file == null)
            user_mapping_file = new File(environment.getGuacamoleHome(), DEFAULT_USER_MAPPING);
     * The XML file to read the configuration from.
     * The default filename to use for the configuration, if not defined within
     * guacamole.properties.
     */
    public static final String DEFAULT_NOAUTH_CONFIG = "noauth-config.xml";

    /**

        // Get config file, defaulting to GUACAMOLE_HOME/noauth-config.xml
        File configFile = environment.getProperty(NOAUTH_CONFIG);
        if (configFile == null)
            configFile = new File(environment.getGuacamoleHome(), DEFAULT_NOAUTH_CONFIG);

        return configFile;

     * The hostname to use when connecting to guacd if no hostname is provided
     * within guacamole.properties.
     */
    private static final String DEFAULT_GUACD_HOSTNAME = "localhost";

    /**
     * The port to use when connecting to guacd if no port is provided within
     * guacamole.properties.
     */
    private static final int DEFAULT_GUACD_PORT = 4822;

    /**
        if (environment.getProperty(Environment.GUACD_SSL, false))
            return new ManagedSSLGuacamoleSocket(
                environment.getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME),
                environment.getProperty(Environment.GUACD_PORT,     DEFAULT_GUACD_PORT),
            environment.getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME),
            environment.getProperty(Environment.GUACD_PORT,     DEFAULT_GUACD_PORT),
import org.glyptodon.guacamole.net.SSLGuacamoleSocket;
 * Implementation of GuacamoleSocket which connects via SSL to a given hostname
public class ManagedSSLGuacamoleSocket extends SSLGuacamoleSocket {
     * Creates a new socket which connects via SSL to a given hostname and
    public ManagedSSLGuacamoleSocket(String hostname, int port,
     * The hostname to use when connecting to guacd if no hostname is provided
     * within guacamole.properties.
     */
    private static final String DEFAULT_GUACD_HOSTNAME = "localhost";

    /**
     * The port to use when connecting to guacd if no port is provided within
     * guacamole.properties.
     */
    private static final int DEFAULT_GUACD_PORT = 4822;

    /**
        String hostname = env.getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME);
        int port = env.getProperty(Environment.GUACD_PORT, DEFAULT_GUACD_PORT);
            InputStream stream = null;
            if (!guacHome.isDirectory())
            else {
                File propertiesFile = new File(guacHome, "guacamole.properties");
                if (propertiesFile.exists())
                    stream = new FileInputStream(propertiesFile);
            }
            // Load properties from stream, if any, always closing stream when done
            if (stream != null) {
                try { properties.load(stream); }
                finally { stream.close(); }
            }

            // Notify if we're proceeding without guacamole.properties
            else
                logger.info("No guacamole.properties file found within GUACAMOLE_HOME or the classpath. Using defaults.");
     *     The directory to retrieve all .jar files from.
        // Set delegate classloader to new URLClassLoader which loads from the .jars found above.
     * The hostname to use when connecting to guacd if no hostname is provided
     * within guacamole.properties.
     */
    private static final String DEFAULT_GUACD_HOSTNAME = "localhost";

    /**
     * The port to use when connecting to guacd if no port is provided within
     * guacamole.properties.
     */
    private static final int DEFAULT_GUACD_PORT = 4822;

    /**
        if (environment.getProperty(Environment.GUACD_SSL, false))
            return new ManagedSSLGuacamoleSocket(
                environment.getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME),
                environment.getProperty(Environment.GUACD_PORT,     DEFAULT_GUACD_PORT),
            environment.getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME),
            environment.getProperty(Environment.GUACD_PORT,     DEFAULT_GUACD_PORT),
     * The XML file to read the configuration from.
     * The default filename to use for the configuration, if not defined within
     * guacamole.properties.
     */
    public static final String DEFAULT_NOAUTH_CONFIG = "noauth-config.xml";

    /**

        // Get config file, defaulting to GUACAMOLE_HOME/noauth-config.xml
        File configFile = environment.getProperty(NOAUTH_CONFIG);
        if (configFile == null)
            configFile = new File(environment.getGuacamoleHome(), DEFAULT_NOAUTH_CONFIG);

        return configFile;

            InputStream stream = null;
            if (!guacHome.isDirectory())
            else {
                File propertiesFile = new File(guacHome, "guacamole.properties");
                if (propertiesFile.exists())
                    stream = new FileInputStream(propertiesFile);
            }
            // Load properties from stream, if any, always closing stream when done
            if (stream != null) {
                try { properties.load(stream); }
                finally { stream.close(); }
            }

            // Notify if we're proceeding without guacamole.properties
            else
                logger.info("No guacamole.properties file found within GUACAMOLE_HOME or the classpath. Using defaults.");
     * The hostname to use when connecting to guacd if no hostname is provided
     * within guacamole.properties.
     */
    private static final String DEFAULT_GUACD_HOSTNAME = "localhost";

    /**
     * The port to use when connecting to guacd if no port is provided within
     * guacamole.properties.
     */
    private static final int DEFAULT_GUACD_PORT = 4822;

    /**
        String hostname = env.getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME);
        int port = env.getProperty(Environment.GUACD_PORT, DEFAULT_GUACD_PORT);
     * The XML file to read the user mapping from.
     * The default filename to use for the user mapping, if not defined within
     * guacamole.properties.
     */
    public static final String DEFAULT_USER_MAPPING = "user-mapping.xml";
    
    /**
        // Get user mapping file, defaulting to GUACAMOLE_HOME/user-mapping.xml
        File user_mapping_file = environment.getProperty(BASIC_USER_MAPPING);
        if (user_mapping_file == null)
            user_mapping_file = new File(environment.getGuacamoleHome(), DEFAULT_USER_MAPPING);
import org.glyptodon.guacamole.net.basic.extension.ExtensionModule;
            new ExtensionModule(environment),
            new RESTAuthModule(sessionMap),
 * directory. This directory is set within guacamole.properties. This class
 * is deprecated in favor of DirectoryClassLoader, which is automatically
 * configured based on the presence/absence of GUACAMOLE_HOME/lib.
@Deprecated
            Class<?> module = Class.forName(classname);
 * Copyright (C) 2015 Glyptodon LLC
 * authenticate users. This class must implement AuthenticationProvider. Use
 * of this property type is deprecated in favor of the
 * GUACAMOLE_HOME/extensions directory.
@Deprecated
public abstract class AuthenticationProviderProperty implements GuacamoleProperty<Class<AuthenticationProvider>> {
    @SuppressWarnings("unchecked") // Explicitly checked within by isAssignableFrom()
    public Class<AuthenticationProvider> parseValue(String authProviderClassName) throws GuacamoleException {
            // Get authentication provider class
            Class<?> authProviderClass = org.glyptodon.guacamole.net.basic.GuacamoleClassLoader.getInstance().loadClass(authProviderClassName);
            // Verify the located class is actually a subclass of AuthenticationProvider
            if (!AuthenticationProvider.class.isAssignableFrom(authProviderClass))
            // Return located class
            return (Class<AuthenticationProvider>) authProviderClass;
     * configurations of a user. This property is currently supported, but
     * deprecated in favor of the GUACAMOLE_HOME/extensions directory.
    @Deprecated
     * The directory to search for authentication provider classes. This
     * property is currently supported, but deprecated in favor of the
     * GUACAMOLE_HOME/lib directory.
    @Deprecated
    public RESTAuthModule(TokenSessionMap tokenSessionMap) {
            Class.forName("javax.websocket.Endpoint");
            Class.forName("org.glyptodon.guacamole.net.basic.websocket.jetty8.BasicGuacamoleWebSocketTunnelServlet");
            Class.forName("org.glyptodon.guacamole.net.basic.websocket.jetty9.BasicGuacamoleWebSocketTunnelServlet");
            Class.forName("org.glyptodon.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet");
        // Retrieve permissions only if allowed
        if (canReadPermissions(user, targetUser)) {
        // Retrieve permissions only if allowed
        if (canReadPermissions(user, targetUser)) {
    /**
     * Loads all extensions within the GUACAMOLE_HOME/extensions directory, if
     * any, adding their static resource to the given resoure collections.
     *
     * @param javaScriptResources
     *     A modifiable collection of static JavaScript resources which may
     *     receive new JavaScript resources from extensions.
     *
     * @param cssResources 
     *     A modifiable collection of static CSS resources which may receive
     *     new CSS resources from extensions.
     */
    private void loadExtensions(Collection<Resource> javaScriptResources,
            Collection<Resource> cssResources) {
        // Verify contents are accessible
        if (extensionFiles == null)
            logger.warn("Although GUACAMOLE_HOME/"  EXTENSIONS_DIRECTORY  " exists, its contents cannot be read.");
        
    }
    
    @Override
    protected void configureServlets() {

        // Load authentication provider from guacamole.properties for sake of backwards compatibility
        Class<AuthenticationProvider> authProviderProperty = getAuthProviderProperty();
        if (authProviderProperty != null)
            bindAuthenticationProvider(authProviderProperty);

        // Init JavaScript resources with base guacamole.min.js
        Collection<Resource> javaScriptResources = new ArrayList<Resource>();
        javaScriptResources.add(new WebApplicationResource(getServletContext(), "/guacamole.min.js"));

        // Init CSS resources with base guacamole.min.css
        Collection<Resource> cssResources = new ArrayList<Resource>();
        cssResources.add(new WebApplicationResource(getServletContext(), "/guacamole.min.css"));

        // Load all extensions
        loadExtensions(javaScriptResources, cssResources);

        // Bind basic auth if nothing else chosen/provided
                if (manifest == null)
                    throw new GuacamoleServerException("Contents of "  MANIFEST_NAME  " must be a valid JSON object.");
        bind(AuthenticationProvider.class).toInstance(new AuthenticationProviderFacade(authenticationProvider));
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
            throw new GuacamoleInvalidCredentialsException("Permission denied.", CredentialsInfo.USERNAME_PASSWORD);
            throw new GuacamoleInvalidCredentialsException("Permission denied.", CredentialsInfo.USERNAME_PASSWORD);
                if (manifest == null)
                    throw new GuacamoleServerException("Contents of "  MANIFEST_NAME  " must be a valid JSON object.");
        bind(AuthenticationProvider.class).toInstance(new AuthenticationProviderFacade(authenticationProvider));
    /**
     * Loads all extensions within the GUACAMOLE_HOME/extensions directory, if
     * any, adding their static resource to the given resoure collections.
     *
     * @param javaScriptResources
     *     A modifiable collection of static JavaScript resources which may
     *     receive new JavaScript resources from extensions.
     *
     * @param cssResources 
     *     A modifiable collection of static CSS resources which may receive
     *     new CSS resources from extensions.
     */
    private void loadExtensions(Collection<Resource> javaScriptResources,
            Collection<Resource> cssResources) {
        // Verify contents are accessible
        if (extensionFiles == null)
            logger.warn("Although GUACAMOLE_HOME/"  EXTENSIONS_DIRECTORY  " exists, its contents cannot be read.");
        
    }
    
    @Override
    protected void configureServlets() {

        // Load authentication provider from guacamole.properties for sake of backwards compatibility
        Class<AuthenticationProvider> authProviderProperty = getAuthProviderProperty();
        if (authProviderProperty != null)
            bindAuthenticationProvider(authProviderProperty);

        // Init JavaScript resources with base guacamole.min.js
        Collection<Resource> javaScriptResources = new ArrayList<Resource>();
        javaScriptResources.add(new WebApplicationResource(getServletContext(), "/guacamole.min.js"));

        // Init CSS resources with base guacamole.min.css
        Collection<Resource> cssResources = new ArrayList<Resource>();
        cssResources.add(new WebApplicationResource(getServletContext(), "/guacamole.min.css"));

        // Load all extensions
        loadExtensions(javaScriptResources, cssResources);

        // Bind basic auth if nothing else chosen/provided
        if (extensionFiles == null) {
            return;
        }
        if (extensionFiles == null) {
            return;
        }
import java.util.HashMap;
import java.util.Map;
     * Map of all JavaScript resources defined within the extension, where each
     * key is the path to that resource within the extension.
    private final Map<String, Resource> javaScriptResources;
     * Map of all CSS resources defined within the extension, where each key is
     * the path to that resource within the extension.
    private final Map<String, Resource> cssResources;
     * Returns a new map of all resources corresponding to the collection of
     * mimetype, and stored in the map using its path as the key.
     *     A new, unmodifiable map of resources corresponding to the
     *     collection of paths provided, where the key of each entry in the
     *     map is the path for the resource stored in that entry.
    private Map<String, Resource> getClassPathResources(String mimetype, Collection<String> paths) {
        // If no paths are provided, just return an empty map 
            return Collections.<String, Resource>emptyMap();
        Map<String, Resource> resources = new HashMap<String, Resource>(paths.size());
            resources.put(path, new ClassPathResource(classLoader, mimetype, path));
        return Collections.unmodifiableMap(resources);
     * Returns a map of all declared JavaScript resources associated with this
     * extension, where the key of each entry in the map is the path to that
     * resource within the extension .jar. JavaScript resources are declared
     * within the extension manifest.
    public Map<String, Resource> getJavaScriptResources() {
     * Returns a map of all declared CSS resources associated with this
     * extension, where the key of each entry in the map is the path to that
     * resource within the extension .jar. CSS resources are declared within
     * the extension manifest.
    public Map<String, Resource> getCSSResources() {
                javaScriptResources.addAll(extension.getJavaScriptResources().values());
                cssResources.addAll(extension.getCSSResources().values());
            logger.warn("Authentication attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs.");
            logger.warn("Reauthentication attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs.");
     * Map of all translation resources defined within the extension, where
     * each key is the path to that resource within the extension.
     */
    private final Map<String, Resource> translationResources;

    /**
     * Map of all resources defined within the extension which are not already
     * associated as JavaScript, CSS, or translation resources, where each key
     * is the path to that resource within the extension.
     */
    private final Map<String, Resource> staticResources;

    /**
     * Returns a new map of all resources corresponding to the map of resource
     * paths provided. Each resource will be associated with the mimetype 
     * stored in the given map using its path as the key.
     *
     * @param resourceTypes 
     *     A map of all paths to their corresponding mimetypes.
     *
     * @return
     *     A new, unmodifiable map of resources corresponding to the
     *     collection of paths provided, where the key of each entry in the
     *     map is the path for the resource stored in that entry.
     */
    private Map<String, Resource> getClassPathResources(Map<String, String> resourceTypes) {

        // If no paths are provided, just return an empty map 
        if (resourceTypes == null)
            return Collections.<String, Resource>emptyMap();

        // Add classpath resource for each path/mimetype pair provided
        Map<String, Resource> resources = new HashMap<String, Resource>(resourceTypes.size());
        for (Map.Entry<String, String> resource : resourceTypes.entrySet()) {

            // Get path and mimetype from entry
            String path = resource.getKey();
            String mimetype = resource.getValue();

            // Store as path/resource pair
            resources.put(path, new ClassPathResource(classLoader, mimetype, path));

        }

        // Callers should not rely on modifying the result
        return Collections.unmodifiableMap(resources);

    }

    /**
        translationResources = getClassPathResources("application/json", manifest.getTranslationPaths());
        staticResources = getClassPathResources(manifest.getResourceTypes());
     * Returns a map of all declared translation resources associated with this
     * extension, where the key of each entry in the map is the path to that
     * resource within the extension .jar. Translation resources are declared
     * within the extension manifest.
     *
     * @return
     *     All declared translation resources associated with this extension.
     */
    public Map<String, Resource> getTranslationResources() {
        return translationResources;
    }

    /**
     * Returns a map of all declared resources associated with this extension,
     * where these resources are not already associated as JavaScript, CSS, or
     * translation resources. The key of each entry in the map is the path to
     * that resource within the extension .jar. Static resources are declared
     * within the extension manifest.
     *
     * @return
     *     All declared static resources associated with this extension.
     */
    public Map<String, Resource> getStaticResources() {
        return staticResources;
    }

    /**
import java.util.Map;
     * The paths of all translation JSON files within this extension, if any.
     */
    private Collection<String> translationPaths;

    /**
     * The mimetypes of all resources within this extension which are not
     * already declared as JavaScript, CSS, or translation resources, if any.
     * The key of each entry is the resource path, while the value is the
     * corresponding mimetype.
     */
    private Map<String, String> resourceTypes;

    /**
     * Returns the paths to all translation resources within the extension.
     * These paths are defined within the manifest by the "translations"
     * property as an array of strings, where each string is a path relative to
     * the root of the extension .jar.
     *
     * @return
     *     A collection of paths to all translation resources within the
     *     extension.
     */
    @JsonProperty("translations")
    public Collection<String> getTranslationPaths() {
        return translationPaths;
    }

    /**
     * Sets the paths to all translation resources within the extension. These
     * paths are defined within the manifest by the "translations" property as
     * an array of strings, where each string is a path relative to the root of
     * the extension .jar.
     *
     * @param translationPaths
     *     A collection of paths to all translation resources within the
     *     extension.
     */
    @JsonProperty("translations")
    public void setTranslationPaths(Collection<String> translationPaths) {
        this.translationPaths = translationPaths;
    }

    /**
     * Returns a map of all resources to their corresponding mimetypes, for all
     * resources not already declared as JavaScript, CSS, or translation
     * resources. These paths and corresponding types are defined within the
     * manifest by the "resources" property as an object, where each property
     * name is a path relative to the root of the extension .jar, and each
     * value is a mimetype.
     *
     * @return
     *     A map of all resources within the extension to their corresponding
     *     mimetypes.
     */
    @JsonProperty("resources")
    public Map<String, String> getResourceTypes() {
        return resourceTypes;
    }

    /**
     * Sets the map of all resources to their corresponding mimetypes, for all
     * resources not already declared as JavaScript, CSS, or translation
     * resources. These paths and corresponding types are defined within the
     * manifest by the "resources" property as an object, where each property
     * name is a path relative to the root of the extension .jar, and each
     * value is a mimetype.
     *
     * @param resourceTypes
     *     A map of all resources within the extension to their corresponding
     *     mimetypes.
     */
    @JsonProperty("resources")
    public void setResourceTypes(Map<String, String> resourceTypes) {
        this.resourceTypes = resourceTypes;
    }

    /**
import java.util.Map;
                // Add all static resources under namespace-derived prefix
                String staticResourcePrefix = "/app/ext/"  extension.getNamespace()  "/";
                for (Map.Entry<String, Resource> staticResource : extension.getStaticResources().entrySet()) {

                    // Get path and resource from path/resource pair
                    String path = staticResource.getKey();
                    Resource resource = staticResource.getValue();

                    // Serve within namespace-derived path
                    serve(staticResourcePrefix  path).with(new ResourceServlet(resource));

                }

     * Service for adding and retrieving language resources.
     */
    private final LanguageResourceService languageResourceService = new LanguageResourceService();
    
    /**
        // Bind language resource service
        bind(LanguageResourceService.class).toInstance(languageResourceService);

        // Load initial language resources from servlet context
        languageResourceService.addLanguageResources(getServletContext());
        
import com.google.inject.Inject;
import org.glyptodon.guacamole.net.basic.extension.LanguageResourceService;
     * Service for retrieving information regarding available language
     * resources.
    @Inject
    private LanguageResourceService languageResourceService;
    public Map<String, String> getLanguages() {
        return languageResourceService.getLanguageNames();

}
                // Add any translation resources
                for (Map.Entry<String, Resource> translationResource :
                        extension.getTranslationResources().entrySet()) {

                    // Get path and resource from path/resource pair
                    String path = translationResource.getKey();
                    Resource resource = translationResource.getValue();

                    // Derive key from path
                    String languageKey = languageResourceService.getLanguageKey(path);
                    if (languageKey == null) {
                        logger.warn("Invalid language file name: \"{}\"", path);
                        continue;
                    }
                    
                    // Add language resource
                    languageResourceService.addLanguageResource(languageKey, resource);
                    
                }
                
        // Dynamically serve all language resources
        for (Map.Entry<String, Resource> entry : languageResourceService.getLanguageResources().entrySet()) {

            // Get language key/resource pair
            String languageKey = entry.getKey();
            Resource resource = entry.getValue();

            // Serve resource within /translations
            serve("/translations/"  languageKey  ".json").with(new ResourceServlet(resource));
            
        }
        
     * Binds each of the the given AuthenticationProvider classes such that any
     * service requiring access to the AuthenticationProvider can obtain it via
     * injection. Note that, as multiple simultaneous authentication providers
     * are not currently supported, attempting to bind more than one
     * authentication provider will result in warnings being logged.
     *
     * @param authProviders
     *     The AuthenticationProvider classes to bind.
     */
    private void bindAuthenticationProviders(Collection<Class<AuthenticationProvider>> authProviders) {

        // Bind each authentication provider within extension
        for (Class<AuthenticationProvider> authenticationProvider : authProviders)
            bindAuthenticationProvider(authenticationProvider);

    }

    /**
     * Serves each of the given resources as a language resource. Language
     * resources are served from within the "/translations" directory as JSON
     * files, where the name of each JSON file is the language key.
     *
     * @param resources
     *     A map of all language resources to serve, where the key of each
     *     entry in the language key from which the name of the JSON file will
     *     be derived.
     */
    private void serveLanguageResources(Map<String, Resource> resources) {

        // Add all resources to language resource service
        for (Map.Entry<String, Resource> translationResource : resources.entrySet()) {

            // Get path and resource from path/resource pair
            String path = translationResource.getKey();
            Resource resource = translationResource.getValue();

            // Derive key from path
            String languageKey = languageResourceService.getLanguageKey(path);
            if (languageKey == null) {
                logger.warn("Invalid language file name: \"{}\"", path);
                continue;
            }

            // Add language resource
            languageResourceService.addLanguageResource(languageKey, resource);

        }

    }

    /**
     * Serves each of the given resources under the given prefix. The path of
     * each resource relative to the prefix is the key of its entry within the
     * map.
     *
     * @param prefix
     *     The prefix under which each resource should be served.
     *
     * @param resources
     *     A map of all resources to serve, where the key of each entry in the
     *     map is the desired path of that resource relative to the prefix.
     */
    private void serveStaticResources(String prefix, Map<String, Resource> resources) {

        // Add all resources under given prefix
        for (Map.Entry<String, Resource> staticResource : resources.entrySet()) {

            // Get path and resource from path/resource pair
            String path = staticResource.getKey();
            Resource resource = staticResource.getValue();

            // Serve within namespace-derived path
            serve(prefix  path).with(new ResourceServlet(resource));

        }

    }

    /**
                bindAuthenticationProviders(extension.getAuthenticationProviderClasses());
                serveLanguageResources(extension.getTranslationResources());
                serveStaticResources(staticResourcePrefix, extension.getStaticResources());

        // Merge language resources if already defined
        Resource existing = resources.get(key);
        if (existing != null) {
            // TODO: Merge
            logger.debug("Merged strings with existing language: \"{}\"", key);
        }

        // Otherwise, add new language resource
        else {
            resources.put(key, resource);
            logger.debug("Added language: \"{}\"", key);
        }

import java.math.BigDecimal;
import java.util.Iterator;
import java.util.logging.Level;
import org.codehaus.jackson.node.JsonNodeFactory;
import org.codehaus.jackson.node.ObjectNode;
import org.codehaus.jackson.type.TypeReference;
import org.glyptodon.guacamole.net.basic.resource.ByteArrayResource;
     * Merges the given JSON objects. Any leaf node in overlay will overwrite
     * the corresponding path in original.
     *
     * @param original
     *     The original JSON object to which changes should be applied.
     *
     * @param overlay
     *     The JSON object containing changes that should be applied.
     *
     * @return
     *     The newly constructed JSON object that is the result of merging
     *     original and overlay.
     */
    private JsonNode mergeTranslations(JsonNode original, JsonNode overlay) {

        // If we are at a leaf node, the result of merging is simply the overlay
        if (!overlay.isObject() || original == null)
            return overlay;

        // Create mutable copy of original
        ObjectNode newNode = JsonNodeFactory.instance.objectNode();
        Iterator<String> fieldNames = original.getFieldNames();
        while (fieldNames.hasNext()) {
            String fieldName = fieldNames.next();
            newNode.put(fieldName, original.get(fieldName));
        }

        // Merge each field
        fieldNames = overlay.getFieldNames();
        while (fieldNames.hasNext()) {
            String fieldName = fieldNames.next();
            newNode.put(fieldName, mergeTranslations(original.get(fieldName), overlay.get(fieldName)));
        }

        return newNode;

    }

    /**

            try {

                // Get resource stream
                InputStream existingStream = existing.asStream();
                InputStream resourceStream = resource.asStream();
                if (existingStream == null || resourceStream == null) {
                    logger.warn("Language resource \"{}\" does not exist.", key);
                    return;
                }

                // Read the original and new language resources
                JsonNode existingTree = mapper.readTree(existingStream);
                JsonNode resourceTree = mapper.readTree(resourceStream);

                // Merge the language resources
                JsonNode mergedTree = mergeTranslations(existingTree, resourceTree);
                resources.put(key, new ByteArrayResource("application/json", mapper.writeValueAsBytes(mergedTree)));

                logger.debug("Merged strings with existing language: \"{}\"", key);

            }
            catch (IOException e) {
                logger.error("Unable to merge language resource \"{}\": {}", key, e.getMessage());
                logger.debug("Error merging language resource.", e);
            }

import java.util.Iterator;
import org.codehaus.jackson.node.JsonNodeFactory;
import org.codehaus.jackson.node.ObjectNode;
import org.glyptodon.guacamole.net.basic.resource.ByteArrayResource;
     * Merges the given JSON objects. Any leaf node in overlay will overwrite
     * the corresponding path in original.
     *
     * @param original
     *     The original JSON object to which changes should be applied.
     *
     * @param overlay
     *     The JSON object containing changes that should be applied.
     *
     * @return
     *     The newly constructed JSON object that is the result of merging
     *     original and overlay.
     */
    private JsonNode mergeTranslations(JsonNode original, JsonNode overlay) {

        // If we are at a leaf node, the result of merging is simply the overlay
        if (!overlay.isObject() || original == null)
            return overlay;

        // Create mutable copy of original
        ObjectNode newNode = JsonNodeFactory.instance.objectNode();
        Iterator<String> fieldNames = original.getFieldNames();
        while (fieldNames.hasNext()) {
            String fieldName = fieldNames.next();
            newNode.put(fieldName, original.get(fieldName));
        }

        // Merge each field
        fieldNames = overlay.getFieldNames();
        while (fieldNames.hasNext()) {
            String fieldName = fieldNames.next();
            newNode.put(fieldName, mergeTranslations(original.get(fieldName), overlay.get(fieldName)));
        }

        return newNode;

    }

    /**

            try {

                // Get resource stream
                InputStream existingStream = existing.asStream();
                InputStream resourceStream = resource.asStream();
                if (existingStream == null || resourceStream == null) {
                    logger.warn("Language resource \"{}\" does not exist.", key);
                    return;
                }

                // Read the original and new language resources
                JsonNode existingTree = mapper.readTree(existingStream);
                JsonNode resourceTree = mapper.readTree(resourceStream);

                // Merge the language resources
                JsonNode mergedTree = mergeTranslations(existingTree, resourceTree);
                resources.put(key, new ByteArrayResource("application/json", mapper.writeValueAsBytes(mergedTree)));

                logger.debug("Merged strings with existing language: \"{}\"", key);

            }
            catch (IOException e) {
                logger.error("Unable to merge language resource \"{}\": {}", key, e.getMessage());
                logger.debug("Error merging language resource.", e);
            }

            "*",
            "*",
     * Parses the given language resource, returning the resulting JsonNode.
     * If the resource cannot be read because it does not exist, null is
     * returned.
     *
     * @param resource
     *     The language resource to parse. Language resources must have the
     *     mimetype "application/json".
     *
     * @return
     *     A JsonNode representing the root of the parsed JSON tree, or null if
     *     the given resource does not exist.
     *
     * @throws IOException
     *     If an error occurs while parsing the resource as JSON.
     */
    private JsonNode parseLanguageResource(Resource resource) throws IOException {

        // Get resource stream
        InputStream stream = resource.asStream();
        if (stream == null)
            return null;

        // Parse JSON tree
        try {
            JsonNode tree = mapper.readTree(stream);
            return tree;
        }

        // Ensure stream is always closed
        finally {
            stream.close();
        }

    }

    /**
                // Read the original language resource
                JsonNode existingTree = parseLanguageResource(existing);
                if (existingTree == null) {
                    logger.warn("Base language resource \"{}\" does not exist.", key);
                // Read new language resource
                JsonNode resourceTree = parseLanguageResource(resource);
                if (resourceTree == null) {
                    logger.warn("Overlay language resource \"{}\" does not exist.", key);
                    return;
                }
     * Parses the given language resource, returning the resulting JsonNode.
     * If the resource cannot be read because it does not exist, null is
     * returned.
     *
     * @param resource
     *     The language resource to parse. Language resources must have the
     *     mimetype "application/json".
     *
     * @return
     *     A JsonNode representing the root of the parsed JSON tree, or null if
     *     the given resource does not exist.
     *
     * @throws IOException
     *     If an error occurs while parsing the resource as JSON.
     */
    private JsonNode parseLanguageResource(Resource resource) throws IOException {

        // Get resource stream
        InputStream stream = resource.asStream();
        if (stream == null)
            return null;

        // Parse JSON tree
        try {
            JsonNode tree = mapper.readTree(stream);
            return tree;
        }

        // Ensure stream is always closed
        finally {
            stream.close();
        }

    }

    /**
                // Read the original language resource
                JsonNode existingTree = parseLanguageResource(existing);
                if (existingTree == null) {
                    logger.warn("Base language resource \"{}\" does not exist.", key);
                // Read new language resource
                JsonNode resourceTree = parseLanguageResource(resource);
                if (resourceTree == null) {
                    logger.warn("Overlay language resource \"{}\" does not exist.", key);
                    return;
                }
import org.glyptodon.guacamole.net.auth.attribute.ObjectAttributeSet;
    /**
     * Returns all attributes associated with this connection.
     *
     * @return
     *     An ObjectAttributeSet of all attributes associated with this
     *     connection
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the attributes, or if reading
     *     attributes is not allowed.
     */
    ObjectAttributeSet getAttributes() throws GuacamoleException;

import org.glyptodon.guacamole.net.auth.attribute.ObjectAttributeSet;
    /**
     * Returns all attributes associated with this user.
     *
     * @return
     *     An ObjectAttributeSet of all attributes associated with this user.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the attributes, or if reading
     *     attributes is not allowed.
     */
    ObjectAttributeSet getAttributes() throws GuacamoleException;

import org.glyptodon.guacamole.net.auth.attribute.ObjectAttributeSet;
    @Override
    public ObjectAttributeSet getAttributes() throws GuacamoleException {
        return new SimpleObjectAttributeSet();
    }

import org.glyptodon.guacamole.net.auth.attribute.ObjectAttributeSet;
    @Override
    public ObjectAttributeSet getAttributes() throws GuacamoleException {
        return new SimpleObjectAttributeSet();
    }

import java.util.Map;
     * Returns all attributes associated with this connection.
     *
     * @return
     *     A map of all attribute identifiers to their corresponding values,
     *     for all attributes associated with this connection.
     */
    Map<String, String> getAttributes();

    /**
     * Replaces all attributes associated with this connection with the
     * attributes in the given map.
     *
     * @param attributes
     *     A map of all attribute identifiers to their corresponding values,
     *     for all attributes associated with this connection.
     */
    void setAttributes(Map<String, String> attributes);

    /**
import java.util.Map;

    /**
     * Returns all attributes associated with this connection group.
     *
     * @return
     *     A map of all attribute identifiers to their corresponding values,
     *     for all attributes associated with this connection group.
     */
    Map<String, String> getAttributes();

    /**
     * Replaces all attributes associated with this connection group with the
     * attributes in the given map.
     *
     * @param attributes
     *     A map of all attribute identifiers to their corresponding values,
     *     for all attributes associated with this connection group.
     */
    void setAttributes(Map<String, String> attributes);

import java.util.Map;
     * Returns all attributes associated with this user.
     *
     * @return
     *     A map of all attribute identifiers to their corresponding values,
     *     for all attributes associated with this user.
     */
    Map<String, String> getAttributes();

    /**
     * Replaces all attributes associated with this user with the attributes in
     * the given map.
     *
     * @param attributes
     *     A map of all attribute identifiers to their corresponding values,
     *     for all attributes associated with this user.
     */
    void setAttributes(Map<String, String> attributes);

    /**
import java.util.Collection;
import org.glyptodon.guacamole.net.auth.attribute.Attribute;
    /**
     * Retrieves a collection of all attributes applicable to users. This
     * collection will contain only those attributes which the current user has
     * general permission to view or modify. If there are no such attributes,
     * this collection will be empty.
     *
     * @return
     *     A collection of all attributes applicable to users.
     */
    Collection<Attribute> getUserAttributes();

    /**
     * Retrieves a collection of all attributes applicable to connections. This
     * collection will contain only those attributes which the current user has
     * general permission to view or modify. If there are no such attributes,
     * this collection will be empty.
     *
     * @return
     *     A collection of all attributes applicable to connections.
     */
    Collection<Attribute> getConnectionAttributes();

    /**
     * Retrieves a collection of all attributes applicable to connection
     * groups. This collection will contain only those attributes which the
     * current user has general permission to view or modify. If there are no
     * such attributes, this collection will be empty.
     *
     * @return
     *     A collection of all attributes applicable to connection groups.
     */
    Collection<Attribute> getConnectionGroupAttributes();

 * type, where the type dictates the semantics and legal values of the
 * attribute.
public class Attribute implements Identifiable {

    /**
     * The string which uniquely identifies this attribute.
     */
    private String identifier;

    /**
     * The type of this attribute.
     */
    private Type type;
    @Override
    public String getIdentifier() {
        return identifier;
    }

    @Override
    public void setIdentifier(String identifier) {
        this.identifier = identifier;
    }

    public Type getType() {
        return type;
    }
    void setType(Type type) {
        this.type = type;
    }
import java.util.Map;
    public Map<String, String> getAttributes() {
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        // Do nothing - there are no attributes
    }

    @Override
import java.util.Collections;
import java.util.Map;
    public Map<String, String> getAttributes() {
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        // Do nothing - there are no attributes
    }

    @Override
import java.util.Collections;
import java.util.Map;
import org.glyptodon.guacamole.GuacamoleSecurityException;
    public Map<String, String> getAttributes() {
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        // Do nothing - there are no attributes
    }

    @Override
import org.glyptodon.guacamole.net.auth.attribute.Attribute;
    @Override
    public Collection<Attribute> getUserAttributes() {
        return Collections.<Attribute>emptyList();
    }

    @Override
    public Collection<Attribute> getConnectionAttributes() {
        return Collections.<Attribute>emptyList();
    }

    @Override
    public Collection<Attribute> getConnectionGroupAttributes() {
        return Collections.<Attribute>emptyList();
    }

import java.util.Collections;
import java.util.Map;
    @Override
    public Map<String, String> getAttributes() {
        // FIXME: STUB
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        // FIXME: STUB
        throw new UnsupportedOperationException("STUB");
    }

import java.util.Collections;
import java.util.Map;
    @Override
    public Map<String, String> getAttributes() {
        // FIXME: STUB
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        // FIXME: STUB
        throw new UnsupportedOperationException("STUB");
    }

import java.util.Collections;
import java.util.Map;
    @Override
    public Map<String, String> getAttributes() {
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        throw new UnsupportedOperationException("The root connection group cannot be modified.");
    }

import java.util.Collections;
import java.util.Map;
    @Override
    public Map<String, String> getAttributes() {
        // FIXME: STUB
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        // FIXME: STUB
        throw new UnsupportedOperationException("STUB");
    }

import java.util.Collection;
import java.util.Collections;
import org.glyptodon.guacamole.net.auth.attribute.Attribute;
    @Override
    public Collection<Attribute> getUserAttributes() {
        return Collections.<Attribute>emptyList();
    }

    @Override
    public Collection<Attribute> getConnectionAttributes() {
        return Collections.<Attribute>emptyList();
    }

    @Override
    public Collection<Attribute> getConnectionGroupAttributes() {
        return Collections.<Attribute>emptyList();
    }

import org.codehaus.jackson.map.annotate.JsonSerialize;
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
     * Map of all associated attributes by attribute identifier.
     */
    private Map<String, String> attributes;

    /**
        // Associate any attributes
        this.attributes = connection.getAttributes();


    /**
     * Returns a map of all attributes associated with this connection. Each
     * entry key is the attribute identifier, while each value is the attribute
     * value itself.
     *
     * @return
     *     The attribute map for this connection.
     */
    public Map<String, String> getAttributes() {
        return attributes;
    }

    /**
     * Sets the map of all attributes associated with this connection. Each
     * entry key is the attribute identifier, while each value is the attribute
     * value itself.
     *
     * @param attributes
     *     The attribute map for this connection.
     */
    public void setAttributes(Map<String, String> attributes) {
        this.attributes = attributes;
    }

    public Map<String, String> getAttributes() {
        return apiConnection.getAttributes();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        apiConnection.setAttributes(attributes);
    }

    @Override
        existingConnection.setAttributes(connection.getAttributes());
import java.util.Map;
import org.codehaus.jackson.map.annotate.JsonSerialize;
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
     * Map of all associated attributes by attribute identifier.
     */
    private Map<String, String> attributes;

    /**
        // Set connection group information
        // Associate any attributes
        this.attributes = connectionGroup.getAttributes();


    /**
     * Returns a map of all attributes associated with this connection group.
     * Each entry key is the attribute identifier, while each value is the
     * attribute value itself.
     *
     * @return
     *     The attribute map for this connection group.
     */
    public Map<String, String> getAttributes() {
        return attributes;
    }

    /**
     * Sets the map of all attributes associated with this connection group.
     * Each entry key is the attribute identifier, while each value is the
     * attribute value itself.
     *
     * @param attributes
     *     The attribute map for this connection group.
     */
    public void setAttributes(Map<String, String> attributes) {
        this.attributes = attributes;
    }

import java.util.Map;
    public Map<String, String> getAttributes() {
        return apiConnectionGroup.getAttributes();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        apiConnectionGroup.setAttributes(attributes);
    }

    @Override
        existingConnectionGroup.setAttributes(connectionGroup.getAttributes());
import java.util.Map;
     * Map of all associated attributes by attribute identifier.
     */
    private Map<String, String> attributes;

    /**

        // Set user information

        // Associate any attributes
        this.attributes = user.getAttributes();

    /**
     * Returns a map of all attributes associated with this user. Each entry
     * key is the attribute identifier, while each value is the attribute
     * value itself.
     *
     * @return
     *     The attribute map for this user.
     */
    public Map<String, String> getAttributes() {
        return attributes;
    }

    /**
     * Sets the map of all attributes associated with this user. Each entry key
     * is the attribute identifier, while each value is the attribute value
     * itself.
     *
     * @param attributes
     *     The attribute map for this user.
     */
    public void setAttributes(Map<String, String> attributes) {
        this.attributes = attributes;
    }

import java.util.Map;
    public Map<String, String> getAttributes() {
        return apiUser.getAttributes();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        apiUser.setAttributes(attributes);
    }

    @Override
        // Update user attributes
        existingUser.setAttributes(user.getAttributes());

        // Drop all attributes - none currently supported
        // Drop all attributes - none currently supported
        // Drop all attributes - none currently supported
import org.glyptodon.guacamole.form.Parameter;
    public Collection<Parameter> getUserAttributes() {
        return Collections.<Parameter>emptyList();
    public Collection<Parameter> getConnectionAttributes() {
        return Collections.<Parameter>emptyList();
    public Collection<Parameter> getConnectionGroupAttributes() {
        return Collections.<Parameter>emptyList();
import org.glyptodon.guacamole.form.Parameter;
    Collection<Parameter> getUserAttributes();
    Collection<Parameter> getConnectionAttributes();
    Collection<Parameter> getConnectionGroupAttributes();
import org.glyptodon.guacamole.form.Parameter;
    public Collection<Parameter> getUserAttributes() {
        return Collections.<Parameter>emptyList();
    public Collection<Parameter> getConnectionAttributes() {
        return Collections.<Parameter>emptyList();
    public Collection<Parameter> getConnectionGroupAttributes() {
        return Collections.<Parameter>emptyList();
import org.glyptodon.guacamole.net.basic.rest.schema.SchemaRESTService;
        bind(SchemaRESTService.class);
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/schema/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to the self-description of the Guacamole REST API, such as
 * the attributes or parameters applicable to specific objects.
package org.glyptodon.guacamole.net.basic.rest.schema;
import java.util.Collections;
import java.util.Map;
    @Override
    public Map<String, String> getAttributes() {
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        // Drop all attributes - none currently supported
    }

import java.util.Collections;
import java.util.Map;
    @Override
    public Map<String, String> getAttributes() {
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        // Drop all attributes - none currently supported
    }

import java.util.Collections;
import java.util.Map;
    @Override
    public Map<String, String> getAttributes() {
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        throw new UnsupportedOperationException("The root connection group cannot be modified.");
    }

import java.util.Collections;
import java.util.Map;
    @Override
    public Map<String, String> getAttributes() {
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        // Drop all attributes - none currently supported
    }

import java.util.Collection;
import java.util.Collections;
import org.glyptodon.guacamole.form.Parameter;
    @Override
    public Collection<Parameter> getUserAttributes() {
        return Collections.<Parameter>emptyList();
    }

    @Override
    public Collection<Parameter> getConnectionAttributes() {
        return Collections.<Parameter>emptyList();
    }

    @Override
    public Collection<Parameter> getConnectionGroupAttributes() {
        return Collections.<Parameter>emptyList();
    }

import java.util.Map;
     * Returns all attributes associated with this connection.
     *
     * @return
     *     A map of all attribute identifiers to their corresponding values,
     *     for all attributes associated with this connection.
     */
    Map<String, String> getAttributes();

    /**
     * Replaces all attributes associated with this connection with the
     * attributes in the given map.
     *
     * @param attributes
     *     A map of all attribute identifiers to their corresponding values,
     *     for all attributes associated with this connection.
     */
    void setAttributes(Map<String, String> attributes);

    /**
import java.util.Map;

    /**
     * Returns all attributes associated with this connection group.
     *
     * @return
     *     A map of all attribute identifiers to their corresponding values,
     *     for all attributes associated with this connection group.
     */
    Map<String, String> getAttributes();

    /**
     * Replaces all attributes associated with this connection group with the
     * attributes in the given map.
     *
     * @param attributes
     *     A map of all attribute identifiers to their corresponding values,
     *     for all attributes associated with this connection group.
     */
    void setAttributes(Map<String, String> attributes);

import java.util.Map;
     * Returns all attributes associated with this user.
     *
     * @return
     *     A map of all attribute identifiers to their corresponding values,
     *     for all attributes associated with this user.
     */
    Map<String, String> getAttributes();

    /**
     * Replaces all attributes associated with this user with the attributes in
     * the given map.
     *
     * @param attributes
     *     A map of all attribute identifiers to their corresponding values,
     *     for all attributes associated with this user.
     */
    void setAttributes(Map<String, String> attributes);

    /**
import java.util.Collection;
import org.glyptodon.guacamole.form.Parameter;
    /**
     * Retrieves a collection of all attributes applicable to users. This
     * collection will contain only those attributes which the current user has
     * general permission to view or modify. If there are no such attributes,
     * this collection will be empty.
     *
     * @return
     *     A collection of all attributes applicable to users.
     */
    Collection<Parameter> getUserAttributes();

    /**
     * Retrieves a collection of all attributes applicable to connections. This
     * collection will contain only those attributes which the current user has
     * general permission to view or modify. If there are no such attributes,
     * this collection will be empty.
     *
     * @return
     *     A collection of all attributes applicable to connections.
     */
    Collection<Parameter> getConnectionAttributes();

    /**
     * Retrieves a collection of all attributes applicable to connection
     * groups. This collection will contain only those attributes which the
     * current user has general permission to view or modify. If there are no
     * such attributes, this collection will be empty.
     *
     * @return
     *     A collection of all attributes applicable to connection groups.
     */
    Collection<Parameter> getConnectionGroupAttributes();

import java.util.Map;
    public Map<String, String> getAttributes() {
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        // Do nothing - there are no attributes
    }

    @Override
import java.util.Collections;
import java.util.Map;
    public Map<String, String> getAttributes() {
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        // Do nothing - there are no attributes
    }

    @Override
import java.util.Collections;
import java.util.Map;
import org.glyptodon.guacamole.GuacamoleSecurityException;
    public Map<String, String> getAttributes() {
        return Collections.<String, String>emptyMap();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        // Do nothing - there are no attributes
    }

    @Override
import org.glyptodon.guacamole.form.Parameter;
    @Override
    public Collection<Parameter> getUserAttributes() {
        return Collections.<Parameter>emptyList();
    }

    @Override
    public Collection<Parameter> getConnectionAttributes() {
        return Collections.<Parameter>emptyList();
    }

    @Override
    public Collection<Parameter> getConnectionGroupAttributes() {
        return Collections.<Parameter>emptyList();
    }

import org.glyptodon.guacamole.net.basic.rest.schema.SchemaRESTService;
        bind(SchemaRESTService.class);
import org.codehaus.jackson.map.annotate.JsonSerialize;
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
     * Map of all associated attributes by attribute identifier.
     */
    private Map<String, String> attributes;

    /**
        // Associate any attributes
        this.attributes = connection.getAttributes();


    /**
     * Returns a map of all attributes associated with this connection. Each
     * entry key is the attribute identifier, while each value is the attribute
     * value itself.
     *
     * @return
     *     The attribute map for this connection.
     */
    public Map<String, String> getAttributes() {
        return attributes;
    }

    /**
     * Sets the map of all attributes associated with this connection. Each
     * entry key is the attribute identifier, while each value is the attribute
     * value itself.
     *
     * @param attributes
     *     The attribute map for this connection.
     */
    public void setAttributes(Map<String, String> attributes) {
        this.attributes = attributes;
    }

    public Map<String, String> getAttributes() {
        return apiConnection.getAttributes();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        apiConnection.setAttributes(attributes);
    }

    @Override
        existingConnection.setAttributes(connection.getAttributes());
import java.util.Map;
import org.codehaus.jackson.map.annotate.JsonSerialize;
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
     * Map of all associated attributes by attribute identifier.
     */
    private Map<String, String> attributes;

    /**
        // Set connection group information
        // Associate any attributes
        this.attributes = connectionGroup.getAttributes();


    /**
     * Returns a map of all attributes associated with this connection group.
     * Each entry key is the attribute identifier, while each value is the
     * attribute value itself.
     *
     * @return
     *     The attribute map for this connection group.
     */
    public Map<String, String> getAttributes() {
        return attributes;
    }

    /**
     * Sets the map of all attributes associated with this connection group.
     * Each entry key is the attribute identifier, while each value is the
     * attribute value itself.
     *
     * @param attributes
     *     The attribute map for this connection group.
     */
    public void setAttributes(Map<String, String> attributes) {
        this.attributes = attributes;
    }

import java.util.Map;
    public Map<String, String> getAttributes() {
        return apiConnectionGroup.getAttributes();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        apiConnectionGroup.setAttributes(attributes);
    }

    @Override
        existingConnectionGroup.setAttributes(connectionGroup.getAttributes());
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/schema/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Classes related to the self-description of the Guacamole REST API, such as
 * the attributes or parameters applicable to specific objects.
package org.glyptodon.guacamole.net.basic.rest.schema;
import java.util.Map;
     * Map of all associated attributes by attribute identifier.
     */
    private Map<String, String> attributes;

    /**

        // Set user information

        // Associate any attributes
        this.attributes = user.getAttributes();

    /**
     * Returns a map of all attributes associated with this user. Each entry
     * key is the attribute identifier, while each value is the attribute
     * value itself.
     *
     * @return
     *     The attribute map for this user.
     */
    public Map<String, String> getAttributes() {
        return attributes;
    }

    /**
     * Sets the map of all attributes associated with this user. Each entry key
     * is the attribute identifier, while each value is the attribute value
     * itself.
     *
     * @param attributes
     *     The attribute map for this user.
     */
    public void setAttributes(Map<String, String> attributes) {
        this.attributes = attributes;
    }

import java.util.Map;
    public Map<String, String> getAttributes() {
        return apiUser.getAttributes();
    }

    @Override
    public void setAttributes(Map<String, String> attributes) {
        apiUser.setAttributes(attributes);
    }

    @Override
        // Update user attributes
        existingUser.setAttributes(user.getAttributes());

import org.glyptodon.guacamole.form.Field;
    public Collection<Field> getUserAttributes() {
        return Collections.<Field>emptyList();
    public Collection<Field> getConnectionAttributes() {
        return Collections.<Field>emptyList();
    public Collection<Field> getConnectionGroupAttributes() {
        return Collections.<Field>emptyList();
import org.codehaus.jackson.map.ObjectMapper;
     * The Jackson parser for parsing JSON files.
     */
    private static final ObjectMapper mapper = new ObjectMapper();

    /**
     * Parses the given JSON file, returning the parsed ProtocolInfo. The JSON
     * format is conveniently and intentionally identical to a serialized
     * ProtocolInfo object, which is identical to the JSON format used by the
     * protocol REST service built into the Guacamole web application.
     * @param input
     *     An input stream containing JSON describing the forms and parameters
     *     associated with a protocol supported by Guacamole.
     *
     * @return
     *     A new ProtocolInfo object which contains the forms and parameters
     *     described by the JSON file parsed.
     *
     * @throws IOException
     *     If an error occurs while parsing the JSON file.
            throws IOException {
        return mapper.readValue(input, ProtocolInfo.class);
     * @return
     *     A map of all available protocols.
     *
     * @throws GuacamoleException
     *     If an error occurs while reading the various protocol JSON files.
            // Get all JSON files
                        return string.endsWith(".json");
                    logger.debug("Error reading protocol JSON.", e);
                         protocol  ".json");
                // Parse JSON if available
                if (stream != null) {
                    try {
                        protocols.put(protocol, readProtocol(stream));
                    }
                    catch (IOException e) {
                        logger.error("Unable to read pre-defined connection parameter information for protocol \"{}\": {}", protocol, e.getMessage());
                        logger.debug("Error reading pre-defined protocol JSON.", e);
                    }
                }
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/form/FieldOption.java
import org.codehaus.jackson.map.annotate.JsonSerialize;

 * Describes an available legal value for an enumerated field.
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
public class FieldOption {
     * Creates a new FieldOption with no associated value or title.
    public FieldOption() {
     * Creates a new FieldOption having the given value and title.
    public FieldOption(String value, String title) {

 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/form/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Provides classes which describe the contents and semantics of forms which
 * may be presented to the user.
package org.glyptodon.guacamole.form;
import org.glyptodon.guacamole.form.Field;
    Collection<Field> getUserAttributes();
    Collection<Field> getConnectionAttributes();
    Collection<Field> getConnectionGroupAttributes();
import org.glyptodon.guacamole.form.Field;
     * All fields required for valid credentials.
    private final Collection<Field> fields;
     * Creates a new CredentialsInfo object which requires the given fields for
     * any conforming credentials.
     * @param fields
     *     The fields to require.
    public CredentialsInfo(Collection<Field> fields) {
        this.fields = fields;
     * Returns all fields required for valid credentials as described by this
     * object.
     *     All fields required for valid credentials.
    public Collection<Field> getFields() {
        return Collections.unmodifiableCollection(fields);
     * CredentialsInfo object which describes empty credentials. No fields are
     * required.
    public static final CredentialsInfo EMPTY = new CredentialsInfo(Collections.<Field>emptyList());
        new Field("username", "username", Field.Type.USERNAME),
        new Field("password", "password", Field.Type.PASSWORD)
import org.glyptodon.guacamole.form.Field;
    public Collection<Field> getUserAttributes() {
        return Collections.<Field>emptyList();
    public Collection<Field> getConnectionAttributes() {
        return Collections.<Field>emptyList();
    public Collection<Field> getConnectionGroupAttributes() {
        return Collections.<Field>emptyList();
import org.glyptodon.guacamole.form.Form;
 * Describes a protocol and all forms associated with it, as required by
 * a protocol plugin for guacd. This class allows known forms for a
     * A collection of all associated protocol forms.
    private Collection<Form> forms;
     * forms.
        this.forms = new ArrayList<Form>();
     * any forms.
        this.name  = name;
        this.title = title;
        this.forms = new ArrayList<Form>();
     * Creates a new ProtocolInfo having the given name, title, and forms.
     * @param forms
     *     The forms to associate with the protocol.
    public ProtocolInfo(String name, String title, Collection<Form> forms) {
        this.name  = name;
        this.title = title;
        this.forms = forms;
     * Returns a mutable collection of the protocol forms associated with
     * this protocol. Changes to this collection affect the forms exposed
     * @return A mutable collection of protocol forms.
    public Collection<Form> getForms() {
        return forms;
     * Sets the collection of protocol forms associated with this
     * @param forms
     *     The collection of forms to associate with this protocol.
    public void setForms(Collection<Form> forms) {
        this.forms = forms;
import org.glyptodon.guacamole.form.Field;
     * All expected request parameters, if any, as a collection of fields.
    private final Collection<Field> expected;
     *     a result of the original request, as a collection of fields.
    public APIError(Type type, String message, Collection<Field> expected) {
     * Returns a collection of all required parameters, where each parameter is
     * represented by a field.
     *     A collection of all required parameters.
    public Collection<Field> getExpected() {
import org.glyptodon.guacamole.form.Field;
     *     a result of the original request, as a collection of fields.
    public APIException(APIError.Type type, String message, Collection<Field> expected) {
                e.getCredentialsInfo().getFields()
                e.getCredentialsInfo().getFields()
import org.glyptodon.guacamole.form.Field;
     *     A collection of form fields which describe the possible attributes
     *     of a user object.
    public Collection<Field> getUserAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
     *     A collection of form fields which describe the possible attributes
     *     of a connection object.
    public Collection<Field> getConnectionAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
     *     A collection of form fields which describe the possible attributes
     *     of a connection group object.
    public Collection<Field> getConnectionGroupAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
import org.glyptodon.guacamole.form.Field;
    public Collection<Field> getUserAttributes() {
        return Collections.<Field>emptyList();
    public Collection<Field> getConnectionAttributes() {
        return Collections.<Field>emptyList();
    public Collection<Field> getConnectionGroupAttributes() {
        return Collections.<Field>emptyList();
import org.codehaus.jackson.map.ObjectMapper;
     * The Jackson parser for parsing JSON files.
     */
    private static final ObjectMapper mapper = new ObjectMapper();

    /**
     * Parses the given JSON file, returning the parsed ProtocolInfo. The JSON
     * format is conveniently and intentionally identical to a serialized
     * ProtocolInfo object, which is identical to the JSON format used by the
     * protocol REST service built into the Guacamole web application.
     * @param input
     *     An input stream containing JSON describing the forms and parameters
     *     associated with a protocol supported by Guacamole.
     *
     * @return
     *     A new ProtocolInfo object which contains the forms and parameters
     *     described by the JSON file parsed.
     *
     * @throws IOException
     *     If an error occurs while parsing the JSON file.
            throws IOException {
        return mapper.readValue(input, ProtocolInfo.class);
     * @return
     *     A map of all available protocols.
     *
     * @throws GuacamoleException
     *     If an error occurs while reading the various protocol JSON files.
            // Get all JSON files
                        return string.endsWith(".json");
                    logger.debug("Error reading protocol JSON.", e);
                         protocol  ".json");
                // Parse JSON if available
                if (stream != null) {
                    try {
                        protocols.put(protocol, readProtocol(stream));
                    }
                    catch (IOException e) {
                        logger.error("Unable to read pre-defined connection parameter information for protocol \"{}\": {}", protocol, e.getMessage());
                        logger.debug("Error reading pre-defined protocol JSON.", e);
                    }
                }
 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/form/FieldOption.java
import org.codehaus.jackson.map.annotate.JsonSerialize;

 * Describes an available legal value for an enumerated field.
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
public class FieldOption {
     * Creates a new FieldOption with no associated value or title.
    public FieldOption() {
     * Creates a new FieldOption having the given value and title.
    public FieldOption(String value, String title) {

 b/guacamole-ext/src/main/java/org/glyptodon/guacamole/form/package-info.java
 * Copyright (C) 2015 Glyptodon LLC
 * Provides classes which describe the contents and semantics of forms which
 * may be presented to the user.
package org.glyptodon.guacamole.form;
import org.glyptodon.guacamole.form.Field;
    Collection<Field> getUserAttributes();
    Collection<Field> getConnectionAttributes();
    Collection<Field> getConnectionGroupAttributes();
import org.glyptodon.guacamole.form.Field;
     * All fields required for valid credentials.
    private final Collection<Field> fields;
     * Creates a new CredentialsInfo object which requires the given fields for
     * any conforming credentials.
     * @param fields
     *     The fields to require.
    public CredentialsInfo(Collection<Field> fields) {
        this.fields = fields;
     * Returns all fields required for valid credentials as described by this
     * object.
     *     All fields required for valid credentials.
    public Collection<Field> getFields() {
        return Collections.unmodifiableCollection(fields);
     * CredentialsInfo object which describes empty credentials. No fields are
     * required.
    public static final CredentialsInfo EMPTY = new CredentialsInfo(Collections.<Field>emptyList());
        new Field("username", "username", Field.Type.USERNAME),
        new Field("password", "password", Field.Type.PASSWORD)
import org.glyptodon.guacamole.form.Field;
    public Collection<Field> getUserAttributes() {
        return Collections.<Field>emptyList();
    public Collection<Field> getConnectionAttributes() {
        return Collections.<Field>emptyList();
    public Collection<Field> getConnectionGroupAttributes() {
        return Collections.<Field>emptyList();
import org.glyptodon.guacamole.form.Form;
 * Describes a protocol and all forms associated with it, as required by
 * a protocol plugin for guacd. This class allows known forms for a
     * A collection of all associated protocol forms.
    private Collection<Form> forms;
     * forms.
        this.forms = new ArrayList<Form>();
     * any forms.
        this.name  = name;
        this.title = title;
        this.forms = new ArrayList<Form>();
     * Creates a new ProtocolInfo having the given name, title, and forms.
     * @param forms
     *     The forms to associate with the protocol.
    public ProtocolInfo(String name, String title, Collection<Form> forms) {
        this.name  = name;
        this.title = title;
        this.forms = forms;
     * Returns a mutable collection of the protocol forms associated with
     * this protocol. Changes to this collection affect the forms exposed
     * @return A mutable collection of protocol forms.
    public Collection<Form> getForms() {
        return forms;
     * Sets the collection of protocol forms associated with this
     * @param forms
     *     The collection of forms to associate with this protocol.
    public void setForms(Collection<Form> forms) {
        this.forms = forms;
import org.glyptodon.guacamole.form.Field;
     * All expected request parameters, if any, as a collection of fields.
    private final Collection<Field> expected;
     *     a result of the original request, as a collection of fields.
    public APIError(Type type, String message, Collection<Field> expected) {
     * Returns a collection of all required parameters, where each parameter is
     * represented by a field.
     *     A collection of all required parameters.
    public Collection<Field> getExpected() {
import org.glyptodon.guacamole.form.Field;
     *     a result of the original request, as a collection of fields.
    public APIException(APIError.Type type, String message, Collection<Field> expected) {
                e.getCredentialsInfo().getFields()
                e.getCredentialsInfo().getFields()
import org.glyptodon.guacamole.form.Field;
     *     A collection of form fields which describe the possible attributes
     *     of a user object.
    public Collection<Field> getUserAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
     *     A collection of form fields which describe the possible attributes
     *     of a connection object.
    public Collection<Field> getConnectionAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
     *     A collection of form fields which describe the possible attributes
     *     of a connection group object.
    public Collection<Field> getConnectionGroupAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
     * Returns all attributes associated with this connection. The returned map
     * may not be modifiable.
     *     for all attributes associated with this connection, which may not be
     *     modifiable.
     * Sets the given attributes. If an attribute within the map is not
     * supported, it will simply be dropped. Any attributes not within the
     * given map will be left untouched.
     *     A map of all attribute identifiers to their corresponding values.
     * Returns all attributes associated with this connection group. The
     * returned map may not be modifiable.
     *     for all attributes associated with this connection group, which may
     *     not be modifiable.
     * Sets the given attributes. If an attribute within the map is not
     * supported, it will simply be dropped. Any attributes not within the
     * given map will be left untouched.
     *     A map of all attribute identifiers to their corresponding values.
     * Returns all attributes associated with this user. The returned map may
     * not be modifiable.
     *     for all attributes associated with this user, which may not be
     *     modifiable.
     * Sets the given attributes. If an attribute within the map is not
     * supported, it will simply be dropped. Any attributes not within the
     * given map will be left untouched.
     *     A map of all attribute identifiers to their corresponding values.
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.glyptodon.guacamole.form.Field;
     * The name of the attribute which controls whether a user account is
     * disabled.
     */
    public static final String DISABLED_ATTRIBUTE_NAME = "disabled";

    /**
     * A typed field corresponding to the disabled attribute of a user.
     */
    public static final Field DISABLED_ATTRIBUTE = new Field(DISABLED_ATTRIBUTE_NAME, "Disabled", "true");

    /**
     * All possible attributes of user objects.
     */
    public static final Collection<Field> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
        DISABLED_ATTRIBUTE
    ));

    /**

        Map<String, String> attributes = new HashMap<String, String>();

        // Set disabled attribute
        attributes.put("disabled", getModel().isDisabled() ? "true" : null);

        return attributes;

        // Translate disabled attribute
        getModel().setDisabled("true".equals(attributes.get("disabled")));

        return ModeledUser.ATTRIBUTES;
        if (user != null && !user.getModel().isDisabled()) {
     * Whether the user account is disabled. Disabled accounts exist and can
     * be modified, but cannot be used.
     */
    private boolean disabled;

    /**
    /**
     * Returns whether the user has been disabled. Disabled users are not
     * allowed to login. Although their account data exists, all login attempts
     * will fail as if the account does not exist.
     *
     * @return
     *     true if the account is disabled, false otherwise.
     */
    public boolean isDisabled() {
        return disabled;
    }

    /**
     * Sets whether the user is disabled. Disabled users are not allowed to
     * login. Although their account data exists, all login attempts will fail
     * as if the account does not exist.
     *
     * @param disabled
     *     true if the account should be disabled, false otherwise.
     */
    public void setDisabled(boolean disabled) {
        this.disabled = disabled;
    }

        this.name = name;
        this.title = title;
import org.glyptodon.guacamole.form.Form;
     * All attributes related to restricting user accounts, within a logical
     * form.
    public static final Form ACCOUNT_RESTRICTIONS = new Form("restrictions", "Account Restrictions", Arrays.asList(
        new Field(DISABLED_ATTRIBUTE_NAME, "Disabled", "true")
    ));
     * All possible attributes of user objects organized as individual,
     * logical forms.
    public static final Collection<Form> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
        ACCOUNT_RESTRICTIONS
import org.glyptodon.guacamole.form.Form;
    public Collection<Form> getUserAttributes() {
    public Collection<Form> getConnectionAttributes() {
        return Collections.<Form>emptyList();
    public Collection<Form> getConnectionGroupAttributes() {
        return Collections.<Form>emptyList();
import org.glyptodon.guacamole.form.Form;
    Collection<Form> getUserAttributes();
    Collection<Form> getConnectionAttributes();
    Collection<Form> getConnectionGroupAttributes();
import org.glyptodon.guacamole.form.Form;
    public Collection<Form> getUserAttributes() {
        return Collections.<Form>emptyList();
    public Collection<Form> getConnectionAttributes() {
        return Collections.<Form>emptyList();
    public Collection<Form> getConnectionGroupAttributes() {
        return Collections.<Form>emptyList();
import org.glyptodon.guacamole.form.Form;
     *     A collection of forms which describe the possible attributes of a
     *     user object.
    public Collection<Form> getUserAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
     *     A collection of forms which describe the possible attributes of a
     *     connection object.
    public Collection<Form> getConnectionAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
     *     A collection of forms which describe the possible attributes of a
     *     connection group object.
    public Collection<Form> getConnectionGroupAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.form.Form;
     * The name of the attribute which controls whether a user account is
     * disabled.
     */
    public static final String DISABLED_ATTRIBUTE_NAME = "disabled";

    /**
     * All attributes related to restricting user accounts, within a logical
     * form.
     */
    public static final Form ACCOUNT_RESTRICTIONS = new Form("restrictions", "Account Restrictions", Arrays.asList(
        new Field(DISABLED_ATTRIBUTE_NAME, "Disabled", "true")
    ));

    /**
     * All possible attributes of user objects organized as individual,
     * logical forms.
     */
    public static final Collection<Form> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
        ACCOUNT_RESTRICTIONS
    ));

    /**

        Map<String, String> attributes = new HashMap<String, String>();

        // Set disabled attribute
        attributes.put("disabled", getModel().isDisabled() ? "true" : null);

        return attributes;

        // Translate disabled attribute
        getModel().setDisabled("true".equals(attributes.get("disabled")));

import org.glyptodon.guacamole.form.Form;
    public Collection<Form> getUserAttributes() {
        return ModeledUser.ATTRIBUTES;
    public Collection<Form> getConnectionAttributes() {
        return Collections.<Form>emptyList();
    public Collection<Form> getConnectionGroupAttributes() {
        return Collections.<Form>emptyList();
        if (user != null && !user.getModel().isDisabled()) {
     * Whether the user account is disabled. Disabled accounts exist and can
     * be modified, but cannot be used.
     */
    private boolean disabled;

    /**
    /**
     * Returns whether the user has been disabled. Disabled users are not
     * allowed to login. Although their account data exists, all login attempts
     * will fail as if the account does not exist.
     *
     * @return
     *     true if the account is disabled, false otherwise.
     */
    public boolean isDisabled() {
        return disabled;
    }

    /**
     * Sets whether the user is disabled. Disabled users are not allowed to
     * login. Although their account data exists, all login attempts will fail
     * as if the account does not exist.
     *
     * @param disabled
     *     true if the account should be disabled, false otherwise.
     */
    public void setDisabled(boolean disabled) {
        this.disabled = disabled;
    }

        this.name = name;
        this.title = title;
     * Returns all attributes associated with this connection. The returned map
     * may not be modifiable.
     *     for all attributes associated with this connection, which may not be
     *     modifiable.
     * Sets the given attributes. If an attribute within the map is not
     * supported, it will simply be dropped. Any attributes not within the
     * given map will be left untouched.
     *     A map of all attribute identifiers to their corresponding values.
     * Returns all attributes associated with this connection group. The
     * returned map may not be modifiable.
     *     for all attributes associated with this connection group, which may
     *     not be modifiable.
     * Sets the given attributes. If an attribute within the map is not
     * supported, it will simply be dropped. Any attributes not within the
     * given map will be left untouched.
     *     A map of all attribute identifiers to their corresponding values.
     * Returns all attributes associated with this user. The returned map may
     * not be modifiable.
     *     for all attributes associated with this user, which may not be
     *     modifiable.
     * Sets the given attributes. If an attribute within the map is not
     * supported, it will simply be dropped. Any attributes not within the
     * given map will be left untouched.
     *     A map of all attribute identifiers to their corresponding values.
import org.glyptodon.guacamole.form.Form;
    Collection<Form> getUserAttributes();
    Collection<Form> getConnectionAttributes();
    Collection<Form> getConnectionGroupAttributes();
import org.glyptodon.guacamole.form.Form;
    public Collection<Form> getUserAttributes() {
        return Collections.<Form>emptyList();
    public Collection<Form> getConnectionAttributes() {
        return Collections.<Form>emptyList();
    public Collection<Form> getConnectionGroupAttributes() {
        return Collections.<Form>emptyList();
import org.glyptodon.guacamole.form.Form;
     *     A collection of forms which describe the possible attributes of a
     *     user object.
    public Collection<Form> getUserAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
     *     A collection of forms which describe the possible attributes of a
     *     connection object.
    public Collection<Form> getConnectionAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
     *     A collection of forms which describe the possible attributes of a
     *     connection group object.
    public Collection<Form> getConnectionGroupAttributes(@QueryParam("token") String authToken) throws GuacamoleException {
    public static class Type {
        public static String TEXT = "TEXT";
        public static String USERNAME = "USERNAME";
        public static String PASSWORD = "PASSWORD";
        public static String NUMERIC = "NUMERIC";
        public static String BOOLEAN = "BOOLEAN";
        public static String ENUM = "ENUM";
        public static String MULTILINE = "MULTILINE";
    private String type;
    public Field(String name, String title, String type) {
    public String getType() {
    public void setType(String type) {
    private static final Pattern LANGUAGE_KEY_PATTERN = Pattern.compile(".*/([a-z](_[A-Z])?)\\.json");
     * "en_US". The country code and underscore SHOULD be omitted in the case
     * that only one dialect of that language is defined, or in the case of the
     * most universal or well-supported of all supported dialects of that
     * language.
    private static final Pattern LANGUAGE_KEY_PATTERN = Pattern.compile(".*/([a-z](_[A-Z])?)\\.json");
     * "en_US". The country code and underscore SHOULD be omitted in the case
     * that only one dialect of that language is defined, or in the case of the
     * most universal or well-supported of all supported dialects of that
     * language.
    public static class Type {
        public static String TEXT = "TEXT";
        public static String USERNAME = "USERNAME";
        public static String PASSWORD = "PASSWORD";
        public static String NUMERIC = "NUMERIC";
        public static String BOOLEAN = "BOOLEAN";
        public static String ENUM = "ENUM";
        public static String MULTILINE = "MULTILINE";
    private String type;
    public Field(String name, String title, String type) {
    public String getType() {
    public void setType(String type) {
     * The name of the attribute which controls whether a user's password is
     * expired and must be reset upon login.
     */
    public static final String EXPIRED_ATTRIBUTE_NAME = "expired";

    /**
        new Field(DISABLED_ATTRIBUTE_NAME, "Disabled", "true"),
        new Field(EXPIRED_ATTRIBUTE_NAME, "Password expired", "true")
        attributes.put(DISABLED_ATTRIBUTE_NAME, getModel().isDisabled() ? "true" : null);

        // Set password expired attribute
        attributes.put(EXPIRED_ATTRIBUTE_NAME, getModel().isExpired() ? "true" : null);
        getModel().setDisabled("true".equals(attributes.get(DISABLED_ATTRIBUTE_NAME)));

        // Translate password expired attribute
        getModel().setExpired("true".equals(attributes.get(EXPIRED_ATTRIBUTE_NAME)));
     * Whether the user's password is expired. If a user's password is expired,
     * it must be changed immediately upon login, and the account cannot be
     * used until this occurs.
     */
    private boolean expired;

    /**
    /**
     * Returns whether the user's password has expired. If a user's password is
     * expired, it must be immediately changed upon login. A user account with
     * an expired password cannot be used until the password has been changed.
     *
     * @return
     *     true if the user's password has expired, false otherwise.
     */
    public boolean isExpired() {
        return expired;
    }

    /**
     * Sets whether the user's password is expired. If a user's password is
     * expired, it must be immediately changed upon login. A user account with
     * an expired password cannot be used until the password has been changed.
     *
     * @param expired
     *     true to expire the user's password, false otherwise.
     */
    public void setExpired(boolean expired) {
        this.expired = expired;
    }

     * A field describing the username HTTP parameter expected by Guacamole
     * during login, if usernames are being used.
     */
    public static final Field USERNAME = new Field("username", "username", Field.Type.USERNAME);

    /**
     * A field describing the password HTTP parameter expected by Guacamole
     * during login, if passwords are being used.
     */
    public static final Field PASSWORD = new Field("password", "password", Field.Type.PASSWORD);

    /**
        USERNAME,
        PASSWORD
import java.util.Arrays;
import javax.servlet.http.HttpServletRequest;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    /**
     * The name of the HTTP parameter to expect if the user is changing their
     * expired password upon login.
     */
    private static final String NEW_PASSWORD_PARAMETER = "new-password";

    /**
     * The field to provide the user when their password is expired and must
     * be changed.
     */
    private static final Field NEW_PASSWORD = new Field(NEW_PASSWORD_PARAMETER, "New password", Field.Type.PASSWORD);

    /**
     * Information describing the expected credentials if a user's password is
     * expired. If a user's password is expired, it must be changed during the
     * login process.
     */
    private static final CredentialsInfo EXPIRED_PASSWORD = new CredentialsInfo(Arrays.asList(
        CredentialsInfo.USERNAME,
        CredentialsInfo.PASSWORD,
        NEW_PASSWORD
    ));

    /**
     * UserContext instance only if the credentials are valid. If the
     * credentials are invalid or expired, an appropriate GuacamoleException
     * will be thrown.
     *     credentials.
     *     If an error occurs during authentication, or if the given
     *     credentials are invalid or expired.
            // Update password if password is expired
            if (user.getModel().isExpired()) {

                // Pull new password from HTTP request
                HttpServletRequest request = credentials.getRequest();
                String newPassword = request.getParameter(NEW_PASSWORD_PARAMETER);

                // Require new password if account is expired
                if (newPassword == null) {
                    logger.info("The password of user \"{}\" has expired and must be reset.", user.getIdentifier());
                    throw new GuacamoleInsufficientCredentialsException("Password expired", EXPIRED_PASSWORD);
                }

                // STUB: Change password if new password given
                logger.info("Resetting expired password of user \"{}\".", user.getIdentifier());

            }

        throw new GuacamoleInvalidCredentialsException("Invalid login", CredentialsInfo.USERNAME_PASSWORD);
import org.glyptodon.guacamole.GuacamoleClientException;
                // New password must be different from old password
                if (newPassword.equals(credentials.getPassword()))
                    throw new GuacamoleClientException("The new password must be different from the expired password.");

                // New password must not be blank
                if (newPassword.isEmpty())
                    throw new GuacamoleClientException("The new password may not be blank.");

                    throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_SAME");
                    throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_BLANK");
     * The name of the HTTP password parameter to expect if the user is
     * changing their expired password upon login.
     * The password field to provide the user when their password is expired
     * and must be changed.
     * The name of the HTTP password confirmation parameter to expect if the
     * user is changing their expired password upon login.
     */
    private static final String CONFIRM_NEW_PASSWORD_PARAMETER = "confirm-new-password";

    /**
     * The password confirmation field to provide the user when their password
     * is expired and must be changed.
     */
    private static final Field CONFIRM_NEW_PASSWORD = new Field(CONFIRM_NEW_PASSWORD_PARAMETER, "Confirm new password", Field.Type.PASSWORD);

    /**
        NEW_PASSWORD,
        CONFIRM_NEW_PASSWORD
                String confirmNewPassword = request.getParameter(CONFIRM_NEW_PASSWORD_PARAMETER);
                if (newPassword == null || confirmNewPassword == null) {
                // Confirm that the password was entered correctly twice
                if (!newPassword.equals(confirmNewPassword))
                    throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_MISMATCH");

        if (user != null) {
import javax.servlet.http.HttpServletRequest;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    /**

    /**
     * The name of the HTTP password parameter to expect if the user is
     * changing their expired password upon login.
     */
    private static final String NEW_PASSWORD_PARAMETER = "new-password";

    /**
     * The password field to provide the user when their password is expired
     * and must be changed.
     */
    private static final Field NEW_PASSWORD = new Field(NEW_PASSWORD_PARAMETER, "New password", Field.Type.PASSWORD);

    /**
     * The name of the HTTP password confirmation parameter to expect if the
     * user is changing their expired password upon login.
     */
    private static final String CONFIRM_NEW_PASSWORD_PARAMETER = "confirm-new-password";

    /**
     * The password confirmation field to provide the user when their password
     * is expired and must be changed.
     */
    private static final Field CONFIRM_NEW_PASSWORD = new Field(CONFIRM_NEW_PASSWORD_PARAMETER, "Confirm new password", Field.Type.PASSWORD);

    /**
     * Information describing the expected credentials if a user's password is
     * expired. If a user's password is expired, it must be changed during the
     * login process.
     */
    private static final CredentialsInfo EXPIRED_PASSWORD = new CredentialsInfo(Arrays.asList(
        CredentialsInfo.USERNAME,
        CredentialsInfo.PASSWORD,
        NEW_PASSWORD,
        CONFIRM_NEW_PASSWORD
    ));

     * database. If the user account is expired, and the credentials contain
     * the necessary additional parameters to reset the user's password, the
     * password is reset.
     *
     * @throws GuacamoleException
     *     If the provided credentials to not conform to expectations.
    public ModeledUser retrieveUser(Credentials credentials)
            throws GuacamoleException {
        // If user is disabled, pretend user does not exist
        if (userModel.isDisabled())
            return null;
        // Verify provided password is correct
        byte[] hash = encryptionService.createPasswordHash(password, userModel.getPasswordSalt());
        if (!Arrays.equals(hash, userModel.getPasswordHash()))
            return null;

        // Create corresponding user object, set up cyclic reference
        ModeledUser user = getObjectInstance(null, userModel);
        user.setCurrentUser(new AuthenticatedUser(user, credentials));

        // Update password if password is expired
        if (userModel.isExpired()) {

            // Pull new password from HTTP request
            HttpServletRequest request = credentials.getRequest();
            String newPassword = request.getParameter(NEW_PASSWORD_PARAMETER);
            String confirmNewPassword = request.getParameter(CONFIRM_NEW_PASSWORD_PARAMETER);

            // Require new password if account is expired
            if (newPassword == null || confirmNewPassword == null) {
                logger.info("The password of user \"{}\" has expired and must be reset.", username);
                throw new GuacamoleInsufficientCredentialsException("LOGIN.INFO_PASSWORD_EXPIRED", EXPIRED_PASSWORD);
            }

            // New password must be different from old password
            if (newPassword.equals(credentials.getPassword()))
                throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_SAME");

            // New password must not be blank
            if (newPassword.isEmpty())
                throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_BLANK");

            // Confirm that the password was entered correctly twice
            if (!newPassword.equals(confirmNewPassword))
                throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_MISMATCH");

            // Change password and reset expiration flag
            userModel.setExpired(false);
            user.setPassword(newPassword);
            userMapper.update(userModel);
            logger.info("Expired password of user \"{}\" has been reset.", username);
        // Return now-authenticated user
        return user;
import org.glyptodon.guacamole.form.BooleanField;
    public static final Form ACCOUNT_RESTRICTIONS = new Form("restrictions", "Account Restrictions", Arrays.<Field>asList(
        new BooleanField(DISABLED_ATTRIBUTE_NAME, "Disabled", "true"),
        new BooleanField(EXPIRED_ATTRIBUTE_NAME, "Password expired", "true")
import org.glyptodon.guacamole.form.PasswordField;
    private static final Field NEW_PASSWORD = new PasswordField(NEW_PASSWORD_PARAMETER, "New password");
    private static final Field CONFIRM_NEW_PASSWORD = new PasswordField(CONFIRM_NEW_PASSWORD_PARAMETER, "Confirm new password");
 * Copyright (C) 2015 Glyptodon LLC
 * remote desktop protocol, or an input field within a form. Fields are generic
 * and typed dynamically through a type string, with the semantics of the field
 * defined by the type string. The behavior of each field type is defined
 * either through the web application itself (see FormService.js) or through
 * extensions.
     * A collection of all legal values of this field.
     * Creates a new Field with the given name, title, and type.
        this.name  = name;
        this.title = title;
        this.type  = type;
     * Creates a new Field with the given name, title, type, and possible
     * values.
     * @param type
     *     The type of this field.
     *
    public Field(String name, String title, String type,
            Collection<FieldOption> options) {
        this.type    = type;
     * collection directly affect the available options.
     * Sets the options available as possible values of this field.
import org.glyptodon.guacamole.form.PasswordField;
import org.glyptodon.guacamole.form.UsernameField;
    public static final Field USERNAME = new UsernameField("username", "username");
    public static final Field PASSWORD = new PasswordField("password", "password");
     * All types of fields which are available by default. Additional field
     * types may be defined by extensions by using a unique field type name and
     * registering that name with the form service within JavaScript.
     *
     * See FormService.js.
    public static final Form ACCOUNT_RESTRICTIONS = new Form("restrictions", Arrays.<Field>asList(
        new BooleanField(DISABLED_ATTRIBUTE_NAME, "true"),
        new BooleanField(EXPIRED_ATTRIBUTE_NAME, "true")
    private static final Field NEW_PASSWORD = new PasswordField(NEW_PASSWORD_PARAMETER);
    private static final Field CONFIRM_NEW_PASSWORD = new PasswordField(CONFIRM_NEW_PASSWORD_PARAMETER);
     * Creates a new BooleanField with the given name and truth value. The
     * truth value is the value that, when assigned to this field, means that
     * this field is "true".
    public BooleanField(String name, String truthValue) {
        super(name, Field.Type.BOOLEAN, Collections.singletonList(truthValue));
     * Creates a new EnumField with the given name and possible values.
    public EnumField(String name, Collection<String> options) {
        super(name, Field.Type.ENUM, options);
    private Collection<String> options;
     * Creates a new Parameter with no associated name or type.
     * Creates a new Field with the given name  and type.
    public Field(String name, String type) {
     * Creates a new Field with the given name, type, and possible values.
    public Field(String name, String type, Collection<String> options) {
    public Collection<String> getOptions() {
    public void setOptions(Collection<String> options) {
     * Creates a new Form object with no associated fields. The name is left
     * unset as null. If no form name is provided, this form must not be used
     * in the same context as another unnamed form.
     * Creates a new Form object having the given name and containing the given
     * fields.
    public Form(String name, Collection<Field> fields) {
     * Creates a new MultilineField with the given name.
    public MultilineField(String name) {
        super(name, Field.Type.MULTILINE);
     * Creates a new NumericField with the given name.
    public NumericField(String name) {
        super(name, Field.Type.NUMERIC);
     * Creates a new PasswordField with the given name.
    public PasswordField(String name) {
        super(name, Field.Type.PASSWORD);
     * Creates a new TextField with the given name.
    public TextField(String name) {
        super(name, Field.Type.TEXT);
     * Creates a new UsernameField with the given name.
    public UsernameField(String name) {
        super(name, Field.Type.USERNAME);
    public static final Field USERNAME = new UsernameField("username");
    public static final Field PASSWORD = new PasswordField("password");
     * Creates a new ProtocolInfo with no associated name or forms.
     * Creates a new ProtocolInfo having the given name, but without any forms.
    public ProtocolInfo(String name) {
     * Creates a new ProtocolInfo having the given name and forms.
    public ProtocolInfo(String name, Collection<Form> forms) {
import org.glyptodon.guacamole.form.BooleanField;
     * The name of the attribute which controls whether a user's password is
     * expired and must be reset upon login.
     */
    public static final String EXPIRED_ATTRIBUTE_NAME = "expired";

    /**
    public static final Form ACCOUNT_RESTRICTIONS = new Form("restrictions", Arrays.<Field>asList(
        new BooleanField(DISABLED_ATTRIBUTE_NAME, "true"),
        new BooleanField(EXPIRED_ATTRIBUTE_NAME, "true")
        attributes.put(DISABLED_ATTRIBUTE_NAME, getModel().isDisabled() ? "true" : null);

        // Set password expired attribute
        attributes.put(EXPIRED_ATTRIBUTE_NAME, getModel().isExpired() ? "true" : null);
        getModel().setDisabled("true".equals(attributes.get(DISABLED_ATTRIBUTE_NAME)));

        // Translate password expired attribute
        getModel().setExpired("true".equals(attributes.get(EXPIRED_ATTRIBUTE_NAME)));
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
     * UserContext instance only if the credentials are valid. If the
     * credentials are invalid or expired, an appropriate GuacamoleException
     * will be thrown.
     *     credentials.
     *     If an error occurs during authentication, or if the given
     *     credentials are invalid or expired.
        if (user != null) {
        throw new GuacamoleInvalidCredentialsException("Invalid login", CredentialsInfo.USERNAME_PASSWORD);
     * Whether the user's password is expired. If a user's password is expired,
     * it must be changed immediately upon login, and the account cannot be
     * used until this occurs.
     */
    private boolean expired;

    /**
    /**
     * Returns whether the user's password has expired. If a user's password is
     * expired, it must be immediately changed upon login. A user account with
     * an expired password cannot be used until the password has been changed.
     *
     * @return
     *     true if the user's password has expired, false otherwise.
     */
    public boolean isExpired() {
        return expired;
    }

    /**
     * Sets whether the user's password is expired. If a user's password is
     * expired, it must be immediately changed upon login. A user account with
     * an expired password cannot be used until the password has been changed.
     *
     * @param expired
     *     true to expire the user's password, false otherwise.
     */
    public void setExpired(boolean expired) {
        this.expired = expired;
    }

import javax.servlet.http.HttpServletRequest;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.form.PasswordField;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    /**

    /**
     * The name of the HTTP password parameter to expect if the user is
     * changing their expired password upon login.
     */
    private static final String NEW_PASSWORD_PARAMETER = "new-password";

    /**
     * The password field to provide the user when their password is expired
     * and must be changed.
     */
    private static final Field NEW_PASSWORD = new PasswordField(NEW_PASSWORD_PARAMETER);

    /**
     * The name of the HTTP password confirmation parameter to expect if the
     * user is changing their expired password upon login.
     */
    private static final String CONFIRM_NEW_PASSWORD_PARAMETER = "confirm-new-password";

    /**
     * The password confirmation field to provide the user when their password
     * is expired and must be changed.
     */
    private static final Field CONFIRM_NEW_PASSWORD = new PasswordField(CONFIRM_NEW_PASSWORD_PARAMETER);

    /**
     * Information describing the expected credentials if a user's password is
     * expired. If a user's password is expired, it must be changed during the
     * login process.
     */
    private static final CredentialsInfo EXPIRED_PASSWORD = new CredentialsInfo(Arrays.asList(
        CredentialsInfo.USERNAME,
        CredentialsInfo.PASSWORD,
        NEW_PASSWORD,
        CONFIRM_NEW_PASSWORD
    ));

     * database. If the user account is expired, and the credentials contain
     * the necessary additional parameters to reset the user's password, the
     * password is reset.
     *
     * @throws GuacamoleException
     *     If the provided credentials to not conform to expectations.
    public ModeledUser retrieveUser(Credentials credentials)
            throws GuacamoleException {
        // If user is disabled, pretend user does not exist
        if (userModel.isDisabled())
            return null;
        // Verify provided password is correct
        byte[] hash = encryptionService.createPasswordHash(password, userModel.getPasswordSalt());
        if (!Arrays.equals(hash, userModel.getPasswordHash()))
            return null;

        // Create corresponding user object, set up cyclic reference
        ModeledUser user = getObjectInstance(null, userModel);
        user.setCurrentUser(new AuthenticatedUser(user, credentials));

        // Update password if password is expired
        if (userModel.isExpired()) {

            // Pull new password from HTTP request
            HttpServletRequest request = credentials.getRequest();
            String newPassword = request.getParameter(NEW_PASSWORD_PARAMETER);
            String confirmNewPassword = request.getParameter(CONFIRM_NEW_PASSWORD_PARAMETER);

            // Require new password if account is expired
            if (newPassword == null || confirmNewPassword == null) {
                logger.info("The password of user \"{}\" has expired and must be reset.", username);
                throw new GuacamoleInsufficientCredentialsException("LOGIN.INFO_PASSWORD_EXPIRED", EXPIRED_PASSWORD);
            }

            // New password must be different from old password
            if (newPassword.equals(credentials.getPassword()))
                throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_SAME");

            // New password must not be blank
            if (newPassword.isEmpty())
                throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_BLANK");

            // Confirm that the password was entered correctly twice
            if (!newPassword.equals(confirmNewPassword))
                throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_MISMATCH");

            // Change password and reset expiration flag
            userModel.setExpired(false);
            user.setPassword(newPassword);
            userMapper.update(userModel);
            logger.info("Expired password of user \"{}\" has been reset.", username);
        // Return now-authenticated user
        return user;
 * Copyright (C) 2015 Glyptodon LLC
 * remote desktop protocol, or an input field within a form. Fields are generic
 * and typed dynamically through a type string, with the semantics of the field
 * defined by the type string. The behavior of each field type is defined
 * either through the web application itself (see FormService.js) or through
 * extensions.
     * All types of fields which are available by default. Additional field
     * types may be defined by extensions by using a unique field type name and
     * registering that name with the form service within JavaScript.
     *
     * See FormService.js.
     * A collection of all legal values of this field.
    private Collection<String> options;
     * Creates a new Parameter with no associated name or type.
     * Creates a new Field with the given name  and type.
    public Field(String name, String type) {
        this.name  = name;
        this.type  = type;
     * Creates a new Field with the given name, type, and possible values.
     * @param type
     *     The type of this field.
    public Field(String name, String type, Collection<String> options) {
        this.type    = type;
     * collection directly affect the available options.
    public Collection<String> getOptions() {
     * Sets the options available as possible values of this field.
    public void setOptions(Collection<String> options) {
     * Creates a new Form object with no associated fields. The name is left
     * unset as null. If no form name is provided, this form must not be used
     * in the same context as another unnamed form.
     * Creates a new Form object having the given name and containing the given
     * fields.
    public Form(String name, Collection<Field> fields) {
import org.glyptodon.guacamole.form.PasswordField;
import org.glyptodon.guacamole.form.UsernameField;
     * A field describing the username HTTP parameter expected by Guacamole
     * during login, if usernames are being used.
     */
    public static final Field USERNAME = new UsernameField("username");

    /**
     * A field describing the password HTTP parameter expected by Guacamole
     * during login, if passwords are being used.
     */
    public static final Field PASSWORD = new PasswordField("password");

    /**
        USERNAME,
        PASSWORD
     * Creates a new ProtocolInfo with no associated name or forms.
     * Creates a new ProtocolInfo having the given name, but without any forms.
    public ProtocolInfo(String name) {
     * Creates a new ProtocolInfo having the given name and forms.
    public ProtocolInfo(String name, Collection<Form> forms) {
     * extension was built, such as "0.9.7".
     * extension was built, such as "0.9.7".
            "0.9.7"
     * extension was built, such as "0.9.7".
     * extension was built, such as "0.9.7".
            "0.9.7"
     * The resource for the small favicon for the extension. If provided, this
     * will replace the default guacamole icon.
     */
    private final Resource smallIcon;

    /**
     * The resource foe the large favicon for the extension. If provided, this 
     * will replace the default guacamole icon.
     */
    private final Resource largeIcon;

    /**
        // Get small icon resource if provided
        if (manifest.getSmallIcon() != null)
            smallIcon = new ClassPathResource(classLoader, "image/png", manifest.getSmallIcon());
        else
            smallIcon = null;

        // Get large icon resource if provided
        if (manifest.getLargeIcon() != null)
            largeIcon = new ClassPathResource(classLoader, "image/png", manifest.getLargeIcon());
        else
            largeIcon = null;
    /**
     * Returns the resource for the small favicon for the extension. If
     * provided, this will replace the default guacamole icon.
     * 
     * @return 
     *     The resource for the large favicon.
     */
    public Resource getSmallIcon() {
        return smallIcon;
    }

    /**
     * Returns the resource for the large favicon for the extension. If
     * provided, this will replace the default guacamole icon.
     * 
     * @return 
     *     The resource for the large favicon.
     */
    public Resource getLargeIcon() {
        return largeIcon;
    }

     * The path to the small favicon. If provided, this will replace the default
     * guacamole icon.
     */
    private String smallIcon;

    /**
     * The path to the large favicon. If provided, this will replace the default
     * guacamole icon.
     */
    private String largeIcon;

    /**
    /**
     * Returns the path to the small favicon, relative to the root of the
     * extension.
     *
     * @return The path to the small favicon.
     */
    public String getSmallIcon() {
        return smallIcon;
    }

    /**
     * Sets the path to the small favicon. This will replace the default
     * guacamole icon.
     *
     * @param smallIcon The path to the small favicon.
     */
    public void setSmallIcon(String smallIcon) {
        this.smallIcon = smallIcon;
    }

    /**
     * Returns the path to the large favicon, relative to the root of the
     * extension.
     *
     * @return
     *     The path to the large favicon.
     */
    public String getLargeIcon() {
        return largeIcon;
    }

    /**
     * Sets the path to the large favicon. This will replace the default
     * guacamole icon.
     *
     * @param largeIcon
     *     The path to the large favicon.
     */
    public void setLargeIcon(String largeIcon) {
        this.largeIcon = largeIcon;
    }

                // Serve up the small favicon if provided
                if(extension.getSmallIcon() != null)
                    serve("/images/logo-64.png").with(new ResourceServlet(extension.getSmallIcon()));

                // Serve up the large favicon if provided
                if(extension.getLargeIcon()!= null)
                    serve("/images/logo-144.png").with(new ResourceServlet(extension.getLargeIcon()));

     * will replace the default Guacamole icon.
     * will replace the default Guacamole icon.
     * provided, this will replace the default Guacamole icon.
     * provided, this will replace the default Guacamole icon.
     * @return 
     *     The path to the small favicon.
     * @param smallIcon 
     *     The path to the small favicon.
     *     The resource for the small favicon.
     * Guacamole icon.
     * Guacamole icon.
     * Guacamole icon.
     * Guacamole icon.
     * The resource for the small favicon for the extension. If provided, this
     * will replace the default Guacamole icon.
     */
    private final Resource smallIcon;

    /**
     * The resource foe the large favicon for the extension. If provided, this 
     * will replace the default Guacamole icon.
     */
    private final Resource largeIcon;

    /**
        // Get small icon resource if provided
        if (manifest.getSmallIcon() != null)
            smallIcon = new ClassPathResource(classLoader, "image/png", manifest.getSmallIcon());
        else
            smallIcon = null;

        // Get large icon resource if provided
        if (manifest.getLargeIcon() != null)
            largeIcon = new ClassPathResource(classLoader, "image/png", manifest.getLargeIcon());
        else
            largeIcon = null;
    /**
     * Returns the resource for the small favicon for the extension. If
     * provided, this will replace the default Guacamole icon.
     * 
     * @return 
     *     The resource for the small favicon.
     */
    public Resource getSmallIcon() {
        return smallIcon;
    }

    /**
     * Returns the resource for the large favicon for the extension. If
     * provided, this will replace the default Guacamole icon.
     * 
     * @return 
     *     The resource for the large favicon.
     */
    public Resource getLargeIcon() {
        return largeIcon;
    }

     * The path to the small favicon. If provided, this will replace the default
     * Guacamole icon.
     */
    private String smallIcon;

    /**
     * The path to the large favicon. If provided, this will replace the default
     * Guacamole icon.
     */
    private String largeIcon;

    /**
    /**
     * Returns the path to the small favicon, relative to the root of the
     * extension.
     *
     * @return 
     *     The path to the small favicon.
     */
    public String getSmallIcon() {
        return smallIcon;
    }

    /**
     * Sets the path to the small favicon. This will replace the default
     * Guacamole icon.
     *
     * @param smallIcon 
     *     The path to the small favicon.
     */
    public void setSmallIcon(String smallIcon) {
        this.smallIcon = smallIcon;
    }

    /**
     * Returns the path to the large favicon, relative to the root of the
     * extension.
     *
     * @return
     *     The path to the large favicon.
     */
    public String getLargeIcon() {
        return largeIcon;
    }

    /**
     * Sets the path to the large favicon. This will replace the default
     * Guacamole icon.
     *
     * @param largeIcon
     *     The path to the large favicon.
     */
    public void setLargeIcon(String largeIcon) {
        this.largeIcon = largeIcon;
    }

                // Serve up the small favicon if provided
                if(extension.getSmallIcon() != null)
                    serve("/images/logo-64.png").with(new ResourceServlet(extension.getSmallIcon()));

                // Serve up the large favicon if provided
                if(extension.getLargeIcon()!= null)
                    serve("/images/logo-144.png").with(new ResourceServlet(extension.getLargeIcon()));

     * @param idType
     *     The type of object being connected to (connection or group).
     *
     *     The id of the connection or group being connected to.
    protected GuacamoleTunnel createConnectedTunnel(UserContext context,
            final TunnelRequest.IdentifierType idType, String id,
            GuacamoleClientInformation info)
            throws GuacamoleException {
        GuacamoleTunnel tunnel = null;
        switch (idType) {
                logger.info("User \"{}\" connected to connection \"{}\".", context.self().getIdentifier(), id);
                logger.info("User \"{}\" connected to group \"{}\".", context.self().getIdentifier(), id);
            // Type is guaranteed to be one of the above
                assert(false);
     * @param idType
     *     The type of object being connected to (connection or group).
     *
     * @param id
     *     The id of the connection or group being connected to.
     *
            GuacamoleTunnel tunnel, final TunnelRequest.IdentifierType idType,
            final String id) throws GuacamoleException {
            /**
             * The time the connection began, measured in milliseconds since
             * midnight, January 1, 1970 UTC.
             */
            private final long connectionStartTime = System.currentTimeMillis();

                long connectionEndTime = System.currentTimeMillis();
                long duration = connectionEndTime - connectionStartTime;
                // Log closure
                switch (idType) {

                    // Connection identifiers
                    case CONNECTION:
                        logger.info("User \"{}\" disconnected from connection \"{}\". Duration: {} milliseconds",
                                session.getUserContext().self().getIdentifier(), id, duration);
                        break;

                    // Connection group identifiers
                    case CONNECTION_GROUP:
                        logger.info("User \"{}\" disconnected from connection group \"{}\". Duration: {} milliseconds",
                                session.getUserContext().self().getIdentifier(), id, duration);
                        break;

                    // Type is guaranteed to be one of the above
                    default:
                        assert(false);

                }

                // Close and clean up tunnel
                session.removeTunnel(getUUID().toString());
        String id = request.getParameter("id");
        // Determine ID type
        TunnelRequest.IdentifierType idType = TunnelRequest.IdentifierType.getType(id);
        if (idType == null)
            throw new GuacamoleClientException("Illegal identifier - unknown type.");

        // Remove prefix
        id = id.substring(idType.PREFIX.length());

        final GuacamoleTunnel tunnel = createConnectedTunnel(session.getUserContext(), idType, id, info);
        return createAssociatedTunnel(session, tunnel, idType, id);
     * @param idType
     *     The type of object being connected to (connection or group).
     *
     *     The id of the connection or group being connected to.
    protected GuacamoleTunnel createConnectedTunnel(UserContext context,
            final TunnelRequest.IdentifierType idType, String id,
            GuacamoleClientInformation info)
            throws GuacamoleException {
        GuacamoleTunnel tunnel = null;
        switch (idType) {
                logger.info("User \"{}\" connected to connection \"{}\".", context.self().getIdentifier(), id);
                logger.info("User \"{}\" connected to group \"{}\".", context.self().getIdentifier(), id);
            // Type is guaranteed to be one of the above
                assert(false);
     * @param idType
     *     The type of object being connected to (connection or group).
     *
     * @param id
     *     The id of the connection or group being connected to.
     *
            GuacamoleTunnel tunnel, final TunnelRequest.IdentifierType idType,
            final String id) throws GuacamoleException {
            /**
             * The time the connection began, measured in milliseconds since
             * midnight, January 1, 1970 UTC.
             */
            private final long connectionStartTime = System.currentTimeMillis();

                long connectionEndTime = System.currentTimeMillis();
                long duration = connectionEndTime - connectionStartTime;
                // Log closure
                switch (idType) {

                    // Connection identifiers
                    case CONNECTION:
                        logger.info("User \"{}\" disconnected from connection \"{}\". Duration: {} milliseconds",
                                session.getUserContext().self().getIdentifier(), id, duration);
                        break;

                    // Connection group identifiers
                    case CONNECTION_GROUP:
                        logger.info("User \"{}\" disconnected from connection group \"{}\". Duration: {} milliseconds",
                                session.getUserContext().self().getIdentifier(), id, duration);
                        break;

                    // Type is guaranteed to be one of the above
                    default:
                        assert(false);

                }

                // Close and clean up tunnel
                session.removeTunnel(getUUID().toString());
        String id = request.getParameter("id");
        // Determine ID type
        TunnelRequest.IdentifierType idType = TunnelRequest.IdentifierType.getType(id);
        if (idType == null)
            throw new GuacamoleClientException("Illegal identifier - unknown type.");

        // Remove prefix
        id = id.substring(idType.PREFIX.length());

        final GuacamoleTunnel tunnel = createConnectedTunnel(session.getUserContext(), idType, id, info);
        return createAssociatedTunnel(session, tunnel, idType, id);
import java.sql.Date;
import java.sql.Time;
     * The time each day after which this user account may be used, stored in
     * local time according to the value of timeZone.
     */
    private Time accessWindowStart;

    /**
     * The time each day after which this user account may NOT be used, stored
     * in local time according to the value of timeZone.
     */
    private Time accessWindowEnd;

    /**
     * The day after which this account becomes valid and usable. Account
     * validity begins at midnight of this day. Time information within the
     * Date object is ignored.
     */
    private Date validFrom;

    /**
     * The day after which this account can no longer be used. Account validity
     * ends at midnight of the day following this day. Time information within
     * the Date object is ignored.
     */
    private Date validUntil;

    /**
     * The ID of the time zone used for all time comparisons for this user.
     * Both accessWindowStart and accessWindowEnd values will use this time
     * zone, as will checks for whether account validity dates have passed. If
     * unset, the server's local time zone is used.
     */
    private String timeZone;

    /**
    /**
     * Returns the time each day after which this user account may be used. The
     * time returned will be local time according to the time zone set with
     * setTimeZone().
     *
     * @return
     *     The time each day after which this user account may be used, or null
     *     if this restriction does not apply.
     */
    public Time getAccessWindowStart() {
        return accessWindowStart;
    }

    /**
     * Sets the time each day after which this user account may be used. The
     * time given must be in local time according to the time zone set with
     * setTimeZone().
     *
     * @param accessWindowStart
     *     The time each day after which this user account may be used, or null
     *     if this restriction does not apply.
     */
    public void setAccessWindowStart(Time accessWindowStart) {
        this.accessWindowStart = accessWindowStart;
    }

    /**
     * Returns the time each day after which this user account may NOT be used.
     * The time returned will be local time according to the time zone set with
     * setTimeZone().
     *
     * @return
     *     The time each day after which this user account may NOT be used, or
     *     null if this restriction does not apply.
     */
    public Time getAccessWindowEnd() {
        return accessWindowEnd;
    }

    /**
     * Sets the time each day after which this user account may NOT be used.
     * The time given must be in local time according to the time zone set with
     * setTimeZone().
     *
     * @param accessWindowEnd
     *     The time each day after which this user account may NOT be used, or
     *     null if this restriction does not apply.
     */
    public void setAccessWindowEnd(Time accessWindowEnd) {
        this.accessWindowEnd = accessWindowEnd;
    }

    /**
     * Returns the day after which this account becomes valid and usable.
     * Account validity begins at midnight of this day. Any time information
     * within the returned Date object must be ignored.
     *
     * @return
     *     The day after which this account becomes valid and usable, or null
     *     if this restriction does not apply.
     */
    public Date getValidFrom() {
        return validFrom;
    }

    /**
     * Sets the day after which this account becomes valid and usable. Account
     * validity begins at midnight of this day. Any time information within
     * the provided Date object will be ignored.
     *
     * @param validFrom
     *     The day after which this account becomes valid and usable, or null
     *     if this restriction does not apply.
     */
    public void setValidFrom(Date validFrom) {
        this.validFrom = validFrom;
    }

    /**
     * Returns the day after which this account can no longer be used. Account
     * validity ends at midnight of the day following this day. Any time
     * information within the returned Date object must be ignored.
     *
     * @return
     *     The day after which this account can no longer be used, or null if
     *     this restriction does not apply.
     */
    public Date getValidUntil() {
        return validUntil;
    }

    /**
     * Sets the day after which this account can no longer be used. Account
     * validity ends at midnight of the day following this day. Any time
     * information within the provided Date object will be ignored.
     *
     * @param validUntil
     *     The day after which this account can no longer be used, or null if
     *     this restriction does not apply.
     */
    public void setValidUntil(Date validUntil) {
        this.validUntil = validUntil;
    }

    /**
     * Returns the Java ID of the time zone to be used for all time comparisons
     * for this user. This ID should correspond to a value returned by
     * TimeZone.getAvailableIDs(). If unset or invalid, the server's local time
     * zone must be used.
     *
     * @return
     *     The ID of the time zone to be used for all time comparisons, which
     *     should correspond to a value returned by TimeZone.getAvailableIDs().
     */
    public String getTimeZone() {
        return timeZone;
    }

    /**
     * Sets the Java ID of the time zone to be used for all time comparisons
     * for this user. This ID should correspond to a value returned by
     * TimeZone.getAvailableIDs(). If unset or invalid, the server's local time
     * zone will be used.
     *
     * @param timeZone
     *     The ID of the time zone to be used for all time comparisons, which
     *     should correspond to a value returned by TimeZone.getAvailableIDs().
     */
    public void setTimeZone(String timeZone) {
        this.timeZone = timeZone;
    }

 * Copyright (C) 2015 Glyptodon LLC
import java.sql.Date;
import java.sql.Time;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import org.glyptodon.guacamole.form.TextField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(ModeledUser.class);

    /**
     * The format to use for all date attributes associated with users.
     */
    private static final String DATE_FORMAT = "yyyy-MM-dd";

    /**
     * The format to use for all time attributes associated with users.
     */
    private static final String TIME_FORMAT = "HH:mm:ss";

    /**
     * The name of the attribute which controls the time of day after which a
     * user may login.
     */
    public static final String ACCESS_WINDOW_START_ATTRIBUTE_NAME = "access-window-start";

    /**
     * The name of the attribute which controls the time of day after which a
     * user may NOT login.
     */
    public static final String ACCESS_WINDOW_END_ATTRIBUTE_NAME = "access-window-end";

    /**
     * The name of the attribute which controls the date after which a user's
     * account is valid.
     */
    public static final String VALID_FROM_ATTRIBUTE_NAME = "valid-from";

    /**
     * The name of the attribute which controls the date after which a user's
     * account is no longer valid.
     */
    public static final String VALID_UNTIL_ATTRIBUTE_NAME = "valid-until";

    /**
     * The name of the attribute which defines the time zone used for all
     * time and date attributes related to this user.
     */
    public static final String TIMEZONE_ATTRIBUTE_NAME = "timezone";

    /**
        new BooleanField(EXPIRED_ATTRIBUTE_NAME, "true"),
        new TextField(ACCESS_WINDOW_START_ATTRIBUTE_NAME),
        new TextField(ACCESS_WINDOW_END_ATTRIBUTE_NAME),
        new TextField(VALID_FROM_ATTRIBUTE_NAME),
        new TextField(VALID_UNTIL_ATTRIBUTE_NAME),
        new TextField(TIMEZONE_ATTRIBUTE_NAME)
    /**
     * Converts the given date into a string which follows the format used by
     * date attributes.
     *
     * @param date
     *     The date value to format, which may be null.
     *
     * @return
     *     The formatted date, or null if the provided time was null.
     */
    private String formatDate(Date date) {
        DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
        return date == null ? null : dateFormat.format(date);
    }

    /**
     * Converts the given time into a string which follows the format used by
     * time attributes.
     *
     * @param time
     *     The time value to format, which may be null.
     *
     * @return
     *     The formatted time, or null if the provided time was null.
     */
    private String formatTime(Time time) {
        DateFormat timeFormat = new SimpleDateFormat(TIME_FORMAT);
        return time == null ? null : timeFormat.format(time);
    }

    /**
     * Parses the given string into a corresponding date. The string must
     * follow the standard format used by date attributes, as defined by
     * DATE_FORMAT and as would be produced by formatDate().
     *
     * @param dateString
     *     The date string to parse, which may be null.
     *
     * @return
     *     The date corresponding to the given date string, or null if the
     *     provided date string was null or blank.
     *
     * @throws ParseException
     *     If the given date string does not conform to the standard format
     *     used by date attributes.
     */
    private Date parseDate(String dateString)
    throws ParseException {

        // Return null if no date provided
        if (dateString == null || dateString.isEmpty())
            return null;

        // Parse date according to format
        DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
        return new Date(dateFormat.parse(dateString).getTime());

    }

    /**
     * Parses the given string into a corresponding time. The string must
     * follow the standard format used by time attributes, as defined by
     * TIME_FORMAT and as would be produced by formatTime().
     *
     * @param timeString
     *     The time string to parse, which may be null.
     *
     * @return
     *     The time corresponding to the given time string, or null if the
     *     provided time string was null or blank.
     *
     * @throws ParseException
     *     If the given time string does not conform to the standard format
     *     used by time attributes.
     */
    private Time parseTime(String timeString)
    throws ParseException {

        // Return null if no time provided
        if (timeString == null || timeString.isEmpty())
            return null;

        // Parse time according to format
        DateFormat timeFormat = new SimpleDateFormat(TIME_FORMAT);
        return new Time(timeFormat.parse(timeString).getTime());

    }

    /**
     * Parses the given string into a time zone ID string. As these strings are
     * equivalent, the only transformation currently performed by this function
     * is to ensure that a blank time zone string is parsed into null.
     *
     * @param timeZone
     *     The time zone string to parse, which may be null.
     *
     * @return
     *     The ID of the time zone corresponding to the given string, or null
     *     if the given time zone string was null or blank.
     */
    private String parseTimeZone(String timeZone) {

        // Return null if no time zone provided
        if (timeZone == null || timeZone.isEmpty())
            return null;

        // Otherwise, assume time zone is valid
        return timeZone;

    }

        // Set access window start time
        attributes.put(ACCESS_WINDOW_START_ATTRIBUTE_NAME, formatTime(getModel().getAccessWindowStart()));

        // Set access window end time
        attributes.put(ACCESS_WINDOW_END_ATTRIBUTE_NAME, formatTime(getModel().getAccessWindowEnd()));

        // Set account validity start date
        attributes.put(VALID_FROM_ATTRIBUTE_NAME, formatDate(getModel().getValidFrom()));

        // Set account validity end date
        attributes.put(VALID_UNTIL_ATTRIBUTE_NAME, formatDate(getModel().getValidUntil()));

        // Set timezone attribute
        attributes.put(TIMEZONE_ATTRIBUTE_NAME, getModel().getTimeZone());

        // Translate access window start time
        try { getModel().setAccessWindowStart(parseTime(attributes.get(ACCESS_WINDOW_START_ATTRIBUTE_NAME))); }
        catch (ParseException e) {
            logger.warn("Not setting start time of user access window - invalid time format.");
            logger.debug("Unable to parse time attribute.", e);
        }

        // Translate access window end time
        try { getModel().setAccessWindowEnd(parseTime(attributes.get(ACCESS_WINDOW_END_ATTRIBUTE_NAME))); }
        catch (ParseException e) {
            logger.warn("Not setting end time of user access window - invalid time format.");
            logger.debug("Unable to parse time attribute.", e);
        }

        // Translate account validity start date
        try { getModel().setValidFrom(parseDate(attributes.get(VALID_FROM_ATTRIBUTE_NAME))); }
        catch (ParseException e) {
            logger.warn("Not setting user validity start date - invalid date format.");
            logger.debug("Unable to parse date attribute.", e);
        }

        // Translate account validity end date
        try { getModel().setValidUntil(parseDate(attributes.get(VALID_UNTIL_ATTRIBUTE_NAME))); }
        catch (ParseException e) {
            logger.warn("Not setting user validity end date - invalid date format.");
            logger.debug("Unable to parse date attribute.", e);
        }

        // Translate timezone attribute
        getModel().setTimeZone(parseTimeZone(attributes.get(TIMEZONE_ATTRIBUTE_NAME)));

            logger.warn("Not setting start time of user access window: {}", e.getMessage());
            logger.warn("Not setting end time of user access window: {}", e.getMessage());
            logger.warn("Not setting user validity start date: {}", e.getMessage());
            logger.warn("Not setting user validity end date: {}", e.getMessage());
import java.util.Calendar;
import java.util.TimeZone;
    /**
     * Returns the time zone associated with this user. This time zone must be
     * used when interpreting all date/time restrictions related to this user.
     *
     * @return
     *     The time zone associated with this user.
     */
    private TimeZone getTimeZone() {

        // If no time zone is set, use the default
        String timeZone = getModel().getTimeZone();
        if (timeZone == null)
            return TimeZone.getDefault();

        // Otherwise parse and return time zone
        return TimeZone.getTimeZone(timeZone);

    }

    /**
     * Converts a SQL Time to a Calendar, independently of time zone, using the
     * given Calendar as a base. The time components will be copied to the
     * given Calendar verbatim, leaving the date and time zone components of
     * the given Calendar otherwise intact.
     *
     * @param base
     *     The Calendar object to use as a base for the conversion.
     *
     * @param time
     *     The SQL Time object containing the time components to be applied to
     *     the given Calendar.
     *
     * @return
     *     The given Calendar, now modified to represent the given time.
     */
    private Calendar asCalendar(Calendar base, Time time) {

        // Get calendar from given SQL time
        Calendar timeCalendar = Calendar.getInstance();
        timeCalendar.setTime(time);

        // Apply given time to base calendar
        base.set(Calendar.HOUR_OF_DAY, timeCalendar.get(Calendar.HOUR_OF_DAY));
        base.set(Calendar.MINUTE,      timeCalendar.get(Calendar.MINUTE));
        base.set(Calendar.SECOND,      timeCalendar.get(Calendar.SECOND));
        base.set(Calendar.MILLISECOND, timeCalendar.get(Calendar.MILLISECOND));

        return base;
        
    }

    /**
     * Returns the time during the current day when this user account can start
     * being used.
     *
     * @return
     *     The time during the current day when this user account can start
     *     being used.
     */
    private Calendar getAccessWindowStart() {

        // Get window start time
        Time start = getModel().getAccessWindowStart();
        if (start == null)
            return null;

        // Return within defined time zone, current day
        return asCalendar(Calendar.getInstance(getTimeZone()), start);

    }

    /**
     * Returns the time during the current day when this user account can no
     * longer be used.
     *
     * @return
     *     The time during the current day when this user account can no longer
     *     be used.
     */
    private Calendar getAccessWindowEnd() {

        // Get window end time
        Time end = getModel().getAccessWindowEnd();
        if (end == null)
            return null;

        // Return within defined time zone, current day
        return asCalendar(Calendar.getInstance(getTimeZone()), end);

    }

    /**
     * Returns the date after which this account becomes valid. The time
     * components of the resulting Calendar object will be set to midnight of
     * the date in question.
     *
     * @return
     *     The date after which this account becomes valid.
     */
    private Calendar getValidFrom() {

        // Get valid from date
        Date validFrom = getModel().getValidFrom();
        if (validFrom == null)
            return null;

        // Convert to midnight within defined time zone
        Calendar validFromCalendar = Calendar.getInstance(getTimeZone());
        validFromCalendar.setTime(validFrom);
        validFromCalendar.set(Calendar.HOUR_OF_DAY, 0);
        validFromCalendar.set(Calendar.MINUTE,      0);
        validFromCalendar.set(Calendar.SECOND,      0);
        validFromCalendar.set(Calendar.MILLISECOND, 0);
        return validFromCalendar;

    }

    /**
     * Returns the date after which this account becomes invalid. The time
     * components of the resulting Calendar object will be set to the last
     * millisecond of the day in question (23:59:59.999).
     *
     * @return
     *     The date after which this account becomes invalid.
     */
    private Calendar getValidUntil() {

        // Get valid until date
        Date validUntil = getModel().getValidUntil();
        if (validUntil == null)
            return null;

        // Convert to end-of-day within defined time zone
        Calendar validUntilCalendar = Calendar.getInstance(getTimeZone());
        validUntilCalendar.setTime(validUntil);
        validUntilCalendar.set(Calendar.HOUR_OF_DAY,  23);
        validUntilCalendar.set(Calendar.MINUTE,       59);
        validUntilCalendar.set(Calendar.SECOND,       59);
        validUntilCalendar.set(Calendar.MILLISECOND, 999);
        return validUntilCalendar;

    }

    /**
     * Given a time when a particular state changes from inactive to active,
     * and a time when a particular state changes from active to inactive,
     * determines whether that state is currently active.
     *
     * @param activeStart
     *     The time at which the state changes from inactive to active.
     *
     * @param inactiveStart
     *     The time at which the state changes from active to inactive.
     *
     * @return
     *     true if the state is currently active, false otherwise.
     */
    private boolean isActive(Calendar activeStart, Calendar inactiveStart) {

        // If end occurs before start, convert to equivalent case where start
        // start is before end
        if (inactiveStart != null && activeStart != null && inactiveStart.before(activeStart))
            return !isActive(inactiveStart, activeStart);

        // Get current time
        Calendar current = Calendar.getInstance();

        // State is active iff the current time is between the start and end
        return !(activeStart != null && current.before(activeStart))
            && !(inactiveStart != null && current.after(inactiveStart));

    }

    /**
     * Returns whether this user account is currently valid as of today.
     * Account validity depends on optional date-driven restrictions which
     * define when an account becomes valid, and when an account ceases being
     * valid.
     *
     * @return
     *     true if the account is valid as of today, false otherwise.
     */
    public boolean isAccountValid() {
        return isActive(getValidFrom(), getValidUntil());
    }

    /**
     * Returns whether the current time is within this user's allowed access
     * window. If the login times for this user are not limited, this will
     * return true.
     *
     * @return
     *     true if the current time is within this user's allowed access
     *     window, or if this user has no restrictions on login time, false
     *     otherwise.
     */
    public boolean isAccountAccessible() {
        return isActive(getAccessWindowStart(), getAccessWindowEnd());
    }

        // Verify user account is still valid as of today
        if (!user.isAccountValid())
            throw new GuacamoleClientException("LOGIN.ERROR_NO_LONGER_VALID");

        // Verify user account is allowed to be used at the current time
        if (!user.isAccountAccessible())
            throw new GuacamoleClientException("LOGIN.ERROR_NOT_WITHIN_ACCESS_WINDOW");

            throw new GuacamoleClientException("LOGIN.ERROR_NOT_VALID");
            throw new GuacamoleClientException("LOGIN.ERROR_NOT_ACCESSIBLE");
 * Copyright (C) 2015 Glyptodon LLC
import java.sql.Date;
import java.sql.Time;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.TimeZone;
import org.glyptodon.guacamole.form.TextField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(ModeledUser.class);

    /**
     * The format to use for all date attributes associated with users.
     */
    private static final String DATE_FORMAT = "yyyy-MM-dd";

    /**
     * The format to use for all time attributes associated with users.
     */
    private static final String TIME_FORMAT = "HH:mm:ss";

    /**
     * The name of the attribute which controls the time of day after which a
     * user may login.
     */
    public static final String ACCESS_WINDOW_START_ATTRIBUTE_NAME = "access-window-start";

    /**
     * The name of the attribute which controls the time of day after which a
     * user may NOT login.
     */
    public static final String ACCESS_WINDOW_END_ATTRIBUTE_NAME = "access-window-end";

    /**
     * The name of the attribute which controls the date after which a user's
     * account is valid.
     */
    public static final String VALID_FROM_ATTRIBUTE_NAME = "valid-from";

    /**
     * The name of the attribute which controls the date after which a user's
     * account is no longer valid.
     */
    public static final String VALID_UNTIL_ATTRIBUTE_NAME = "valid-until";

    /**
     * The name of the attribute which defines the time zone used for all
     * time and date attributes related to this user.
     */
    public static final String TIMEZONE_ATTRIBUTE_NAME = "timezone";

    /**
        new BooleanField(EXPIRED_ATTRIBUTE_NAME, "true"),
        new TextField(ACCESS_WINDOW_START_ATTRIBUTE_NAME),
        new TextField(ACCESS_WINDOW_END_ATTRIBUTE_NAME),
        new TextField(VALID_FROM_ATTRIBUTE_NAME),
        new TextField(VALID_UNTIL_ATTRIBUTE_NAME),
        new TextField(TIMEZONE_ATTRIBUTE_NAME)
    /**
     * Converts the given date into a string which follows the format used by
     * date attributes.
     *
     * @param date
     *     The date value to format, which may be null.
     *
     * @return
     *     The formatted date, or null if the provided time was null.
     */
    private String formatDate(Date date) {
        DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
        return date == null ? null : dateFormat.format(date);
    }

    /**
     * Converts the given time into a string which follows the format used by
     * time attributes.
     *
     * @param time
     *     The time value to format, which may be null.
     *
     * @return
     *     The formatted time, or null if the provided time was null.
     */
    private String formatTime(Time time) {
        DateFormat timeFormat = new SimpleDateFormat(TIME_FORMAT);
        return time == null ? null : timeFormat.format(time);
    }

    /**
     * Parses the given string into a corresponding date. The string must
     * follow the standard format used by date attributes, as defined by
     * DATE_FORMAT and as would be produced by formatDate().
     *
     * @param dateString
     *     The date string to parse, which may be null.
     *
     * @return
     *     The date corresponding to the given date string, or null if the
     *     provided date string was null or blank.
     *
     * @throws ParseException
     *     If the given date string does not conform to the standard format
     *     used by date attributes.
     */
    private Date parseDate(String dateString)
    throws ParseException {

        // Return null if no date provided
        if (dateString == null || dateString.isEmpty())
            return null;

        // Parse date according to format
        DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
        return new Date(dateFormat.parse(dateString).getTime());

    }

    /**
     * Parses the given string into a corresponding time. The string must
     * follow the standard format used by time attributes, as defined by
     * TIME_FORMAT and as would be produced by formatTime().
     *
     * @param timeString
     *     The time string to parse, which may be null.
     *
     * @return
     *     The time corresponding to the given time string, or null if the
     *     provided time string was null or blank.
     *
     * @throws ParseException
     *     If the given time string does not conform to the standard format
     *     used by time attributes.
     */
    private Time parseTime(String timeString)
    throws ParseException {

        // Return null if no time provided
        if (timeString == null || timeString.isEmpty())
            return null;

        // Parse time according to format
        DateFormat timeFormat = new SimpleDateFormat(TIME_FORMAT);
        return new Time(timeFormat.parse(timeString).getTime());

    }

    /**
     * Parses the given string into a time zone ID string. As these strings are
     * equivalent, the only transformation currently performed by this function
     * is to ensure that a blank time zone string is parsed into null.
     *
     * @param timeZone
     *     The time zone string to parse, which may be null.
     *
     * @return
     *     The ID of the time zone corresponding to the given string, or null
     *     if the given time zone string was null or blank.
     */
    private String parseTimeZone(String timeZone) {

        // Return null if no time zone provided
        if (timeZone == null || timeZone.isEmpty())
            return null;

        // Otherwise, assume time zone is valid
        return timeZone;

    }

        // Set access window start time
        attributes.put(ACCESS_WINDOW_START_ATTRIBUTE_NAME, formatTime(getModel().getAccessWindowStart()));

        // Set access window end time
        attributes.put(ACCESS_WINDOW_END_ATTRIBUTE_NAME, formatTime(getModel().getAccessWindowEnd()));

        // Set account validity start date
        attributes.put(VALID_FROM_ATTRIBUTE_NAME, formatDate(getModel().getValidFrom()));

        // Set account validity end date
        attributes.put(VALID_UNTIL_ATTRIBUTE_NAME, formatDate(getModel().getValidUntil()));

        // Set timezone attribute
        attributes.put(TIMEZONE_ATTRIBUTE_NAME, getModel().getTimeZone());

        // Translate access window start time
        try { getModel().setAccessWindowStart(parseTime(attributes.get(ACCESS_WINDOW_START_ATTRIBUTE_NAME))); }
        catch (ParseException e) {
            logger.warn("Not setting start time of user access window: {}", e.getMessage());
            logger.debug("Unable to parse time attribute.", e);
        }

        // Translate access window end time
        try { getModel().setAccessWindowEnd(parseTime(attributes.get(ACCESS_WINDOW_END_ATTRIBUTE_NAME))); }
        catch (ParseException e) {
            logger.warn("Not setting end time of user access window: {}", e.getMessage());
            logger.debug("Unable to parse time attribute.", e);
        }

        // Translate account validity start date
        try { getModel().setValidFrom(parseDate(attributes.get(VALID_FROM_ATTRIBUTE_NAME))); }
        catch (ParseException e) {
            logger.warn("Not setting user validity start date: {}", e.getMessage());
            logger.debug("Unable to parse date attribute.", e);
        }

        // Translate account validity end date
        try { getModel().setValidUntil(parseDate(attributes.get(VALID_UNTIL_ATTRIBUTE_NAME))); }
        catch (ParseException e) {
            logger.warn("Not setting user validity end date: {}", e.getMessage());
            logger.debug("Unable to parse date attribute.", e);
        }

        // Translate timezone attribute
        getModel().setTimeZone(parseTimeZone(attributes.get(TIMEZONE_ATTRIBUTE_NAME)));

    }

    /**
     * Returns the time zone associated with this user. This time zone must be
     * used when interpreting all date/time restrictions related to this user.
     *
     * @return
     *     The time zone associated with this user.
     */
    private TimeZone getTimeZone() {

        // If no time zone is set, use the default
        String timeZone = getModel().getTimeZone();
        if (timeZone == null)
            return TimeZone.getDefault();

        // Otherwise parse and return time zone
        return TimeZone.getTimeZone(timeZone);

    }

    /**
     * Converts a SQL Time to a Calendar, independently of time zone, using the
     * given Calendar as a base. The time components will be copied to the
     * given Calendar verbatim, leaving the date and time zone components of
     * the given Calendar otherwise intact.
     *
     * @param base
     *     The Calendar object to use as a base for the conversion.
     *
     * @param time
     *     The SQL Time object containing the time components to be applied to
     *     the given Calendar.
     *
     * @return
     *     The given Calendar, now modified to represent the given time.
     */
    private Calendar asCalendar(Calendar base, Time time) {

        // Get calendar from given SQL time
        Calendar timeCalendar = Calendar.getInstance();
        timeCalendar.setTime(time);

        // Apply given time to base calendar
        base.set(Calendar.HOUR_OF_DAY, timeCalendar.get(Calendar.HOUR_OF_DAY));
        base.set(Calendar.MINUTE,      timeCalendar.get(Calendar.MINUTE));
        base.set(Calendar.SECOND,      timeCalendar.get(Calendar.SECOND));
        base.set(Calendar.MILLISECOND, timeCalendar.get(Calendar.MILLISECOND));

        return base;
        
    }

    /**
     * Returns the time during the current day when this user account can start
     * being used.
     *
     * @return
     *     The time during the current day when this user account can start
     *     being used.
     */
    private Calendar getAccessWindowStart() {

        // Get window start time
        Time start = getModel().getAccessWindowStart();
        if (start == null)
            return null;

        // Return within defined time zone, current day
        return asCalendar(Calendar.getInstance(getTimeZone()), start);

    }

    /**
     * Returns the time during the current day when this user account can no
     * longer be used.
     *
     * @return
     *     The time during the current day when this user account can no longer
     *     be used.
     */
    private Calendar getAccessWindowEnd() {

        // Get window end time
        Time end = getModel().getAccessWindowEnd();
        if (end == null)
            return null;

        // Return within defined time zone, current day
        return asCalendar(Calendar.getInstance(getTimeZone()), end);

    }

    /**
     * Returns the date after which this account becomes valid. The time
     * components of the resulting Calendar object will be set to midnight of
     * the date in question.
     *
     * @return
     *     The date after which this account becomes valid.
     */
    private Calendar getValidFrom() {

        // Get valid from date
        Date validFrom = getModel().getValidFrom();
        if (validFrom == null)
            return null;

        // Convert to midnight within defined time zone
        Calendar validFromCalendar = Calendar.getInstance(getTimeZone());
        validFromCalendar.setTime(validFrom);
        validFromCalendar.set(Calendar.HOUR_OF_DAY, 0);
        validFromCalendar.set(Calendar.MINUTE,      0);
        validFromCalendar.set(Calendar.SECOND,      0);
        validFromCalendar.set(Calendar.MILLISECOND, 0);
        return validFromCalendar;

    }

    /**
     * Returns the date after which this account becomes invalid. The time
     * components of the resulting Calendar object will be set to the last
     * millisecond of the day in question (23:59:59.999).
     *
     * @return
     *     The date after which this account becomes invalid.
     */
    private Calendar getValidUntil() {

        // Get valid until date
        Date validUntil = getModel().getValidUntil();
        if (validUntil == null)
            return null;

        // Convert to end-of-day within defined time zone
        Calendar validUntilCalendar = Calendar.getInstance(getTimeZone());
        validUntilCalendar.setTime(validUntil);
        validUntilCalendar.set(Calendar.HOUR_OF_DAY,  23);
        validUntilCalendar.set(Calendar.MINUTE,       59);
        validUntilCalendar.set(Calendar.SECOND,       59);
        validUntilCalendar.set(Calendar.MILLISECOND, 999);
        return validUntilCalendar;

    }

    /**
     * Given a time when a particular state changes from inactive to active,
     * and a time when a particular state changes from active to inactive,
     * determines whether that state is currently active.
     *
     * @param activeStart
     *     The time at which the state changes from inactive to active.
     *
     * @param inactiveStart
     *     The time at which the state changes from active to inactive.
     *
     * @return
     *     true if the state is currently active, false otherwise.
     */
    private boolean isActive(Calendar activeStart, Calendar inactiveStart) {

        // If end occurs before start, convert to equivalent case where start
        // start is before end
        if (inactiveStart != null && activeStart != null && inactiveStart.before(activeStart))
            return !isActive(inactiveStart, activeStart);

        // Get current time
        Calendar current = Calendar.getInstance();

        // State is active iff the current time is between the start and end
        return !(activeStart != null && current.before(activeStart))
            && !(inactiveStart != null && current.after(inactiveStart));

    }

    /**
     * Returns whether this user account is currently valid as of today.
     * Account validity depends on optional date-driven restrictions which
     * define when an account becomes valid, and when an account ceases being
     * valid.
     *
     * @return
     *     true if the account is valid as of today, false otherwise.
     */
    public boolean isAccountValid() {
        return isActive(getValidFrom(), getValidUntil());
    }

    /**
     * Returns whether the current time is within this user's allowed access
     * window. If the login times for this user are not limited, this will
     * return true.
     *
     * @return
     *     true if the current time is within this user's allowed access
     *     window, or if this user has no restrictions on login time, false
     *     otherwise.
     */
    public boolean isAccountAccessible() {
        return isActive(getAccessWindowStart(), getAccessWindowEnd());
import java.sql.Date;
import java.sql.Time;
     * The time each day after which this user account may be used, stored in
     * local time according to the value of timeZone.
     */
    private Time accessWindowStart;

    /**
     * The time each day after which this user account may NOT be used, stored
     * in local time according to the value of timeZone.
     */
    private Time accessWindowEnd;

    /**
     * The day after which this account becomes valid and usable. Account
     * validity begins at midnight of this day. Time information within the
     * Date object is ignored.
     */
    private Date validFrom;

    /**
     * The day after which this account can no longer be used. Account validity
     * ends at midnight of the day following this day. Time information within
     * the Date object is ignored.
     */
    private Date validUntil;

    /**
     * The ID of the time zone used for all time comparisons for this user.
     * Both accessWindowStart and accessWindowEnd values will use this time
     * zone, as will checks for whether account validity dates have passed. If
     * unset, the server's local time zone is used.
     */
    private String timeZone;

    /**
    /**
     * Returns the time each day after which this user account may be used. The
     * time returned will be local time according to the time zone set with
     * setTimeZone().
     *
     * @return
     *     The time each day after which this user account may be used, or null
     *     if this restriction does not apply.
     */
    public Time getAccessWindowStart() {
        return accessWindowStart;
    }

    /**
     * Sets the time each day after which this user account may be used. The
     * time given must be in local time according to the time zone set with
     * setTimeZone().
     *
     * @param accessWindowStart
     *     The time each day after which this user account may be used, or null
     *     if this restriction does not apply.
     */
    public void setAccessWindowStart(Time accessWindowStart) {
        this.accessWindowStart = accessWindowStart;
    }

    /**
     * Returns the time each day after which this user account may NOT be used.
     * The time returned will be local time according to the time zone set with
     * setTimeZone().
     *
     * @return
     *     The time each day after which this user account may NOT be used, or
     *     null if this restriction does not apply.
     */
    public Time getAccessWindowEnd() {
        return accessWindowEnd;
    }

    /**
     * Sets the time each day after which this user account may NOT be used.
     * The time given must be in local time according to the time zone set with
     * setTimeZone().
     *
     * @param accessWindowEnd
     *     The time each day after which this user account may NOT be used, or
     *     null if this restriction does not apply.
     */
    public void setAccessWindowEnd(Time accessWindowEnd) {
        this.accessWindowEnd = accessWindowEnd;
    }

    /**
     * Returns the day after which this account becomes valid and usable.
     * Account validity begins at midnight of this day. Any time information
     * within the returned Date object must be ignored.
     *
     * @return
     *     The day after which this account becomes valid and usable, or null
     *     if this restriction does not apply.
     */
    public Date getValidFrom() {
        return validFrom;
    }

    /**
     * Sets the day after which this account becomes valid and usable. Account
     * validity begins at midnight of this day. Any time information within
     * the provided Date object will be ignored.
     *
     * @param validFrom
     *     The day after which this account becomes valid and usable, or null
     *     if this restriction does not apply.
     */
    public void setValidFrom(Date validFrom) {
        this.validFrom = validFrom;
    }

    /**
     * Returns the day after which this account can no longer be used. Account
     * validity ends at midnight of the day following this day. Any time
     * information within the returned Date object must be ignored.
     *
     * @return
     *     The day after which this account can no longer be used, or null if
     *     this restriction does not apply.
     */
    public Date getValidUntil() {
        return validUntil;
    }

    /**
     * Sets the day after which this account can no longer be used. Account
     * validity ends at midnight of the day following this day. Any time
     * information within the provided Date object will be ignored.
     *
     * @param validUntil
     *     The day after which this account can no longer be used, or null if
     *     this restriction does not apply.
     */
    public void setValidUntil(Date validUntil) {
        this.validUntil = validUntil;
    }

    /**
     * Returns the Java ID of the time zone to be used for all time comparisons
     * for this user. This ID should correspond to a value returned by
     * TimeZone.getAvailableIDs(). If unset or invalid, the server's local time
     * zone must be used.
     *
     * @return
     *     The ID of the time zone to be used for all time comparisons, which
     *     should correspond to a value returned by TimeZone.getAvailableIDs().
     */
    public String getTimeZone() {
        return timeZone;
    }

    /**
     * Sets the Java ID of the time zone to be used for all time comparisons
     * for this user. This ID should correspond to a value returned by
     * TimeZone.getAvailableIDs(). If unset or invalid, the server's local time
     * zone will be used.
     *
     * @param timeZone
     *     The ID of the time zone to be used for all time comparisons, which
     *     should correspond to a value returned by TimeZone.getAvailableIDs().
     */
    public void setTimeZone(String timeZone) {
        this.timeZone = timeZone;
    }

        // Verify user account is still valid as of today
        if (!user.isAccountValid())
            throw new GuacamoleClientException("LOGIN.ERROR_NOT_VALID");

        // Verify user account is allowed to be used at the current time
        if (!user.isAccountAccessible())
            throw new GuacamoleClientException("LOGIN.ERROR_NOT_ACCESSIBLE");

import org.glyptodon.guacamole.form.TimeZoneField;
        new TimeZoneField(TIMEZONE_ATTRIBUTE_NAME)
        /**
         * A time zone field whose legal values are only valid time zone IDs,
         * as dictated by Java within TimeZone.getAvailableIDs().
         */
        public static String TIMEZONE = "TIMEZONE";

import org.glyptodon.guacamole.form.TimeZoneField;
        new TimeZoneField(TIMEZONE_ATTRIBUTE_NAME)
        /**
         * A time zone field whose legal values are only valid time zone IDs,
         * as dictated by Java within TimeZone.getAvailableIDs().
         */
        public static String TIMEZONE = "TIMEZONE";

import org.glyptodon.guacamole.form.DateField;
import org.glyptodon.guacamole.form.TimeField;
        new TimeField(ACCESS_WINDOW_START_ATTRIBUTE_NAME),
        new TimeField(ACCESS_WINDOW_END_ATTRIBUTE_NAME),
        new DateField(VALID_FROM_ATTRIBUTE_NAME),
        new DateField(VALID_UNTIL_ATTRIBUTE_NAME),
        DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
        DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
        DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
        DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
        /**
         * A date field whose legal values conform to the pattern "YYYY-MM-DD",
         * zero-padded.
         */
        public static String DATE = "DATE";

        /**
         * A time field whose legal values conform to the pattern "HH:MM:SS",
         * zero-padded, 24-hour.
         */
        public static String TIME = "TIME";

import org.glyptodon.guacamole.form.DateField;
import org.glyptodon.guacamole.form.TimeField;
        new TimeField(ACCESS_WINDOW_START_ATTRIBUTE_NAME),
        new TimeField(ACCESS_WINDOW_END_ATTRIBUTE_NAME),
        new DateField(VALID_FROM_ATTRIBUTE_NAME),
        new DateField(VALID_UNTIL_ATTRIBUTE_NAME),
        DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
        DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
        DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
        DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
        /**
         * A date field whose legal values conform to the pattern "YYYY-MM-DD",
         * zero-padded.
         */
        public static String DATE = "DATE";

        /**
         * A time field whose legal values conform to the pattern "HH:MM:SS",
         * zero-padded, 24-hour.
         */
        public static String TIME = "TIME";

    @Produces(MediaType.TEXT_PLAIN)
    @Produces(MediaType.TEXT_PLAIN)
    @Produces(MediaType.TEXT_PLAIN)
    @Produces(MediaType.TEXT_PLAIN)
    @Produces(MediaType.TEXT_PLAIN)
    @Produces(MediaType.TEXT_PLAIN)
        // Send supported image formats
        writer.writeInstruction(
                new GuacamoleInstruction(
                    "image",
                    info.getImageMimetypes().toArray(new String[0])
                ));

     * The list of video mimetypes reported by the client to be supported.
     * The list of image mimetypes reported by the client to be supported.
     */
    private final List<String> imageMimetypes = new ArrayList<String>();

    /**
    /**
     * Returns the list of image mimetypes supported by the client. To add or
     * removed supported mimetypes, the list returned by this function can be
     * modified.
     *
     * @return The set of video mimetypes supported by the client.
     */
    public List<String> getImageMimetypes() {
        return imageMimetypes;
    }

        // Add image mimetypes
        List<String> image_mimetypes = request.getParameterValues("image");
        if (image_mimetypes != null)
            info.getImageMimetypes().addAll(image_mimetypes);

     * The service to use to provide GuacamoleTunnels for each connection.
    private final GuacamoleTunnelService tunnelService;
     * @param tunnelService
     *     The tunnel service to use to provide tunnels sockets for connections.
            GuacamoleTunnelService tunnelService) {
        this.tunnelService = tunnelService;
        // Bind provided tunnel service
        bind(GuacamoleTunnelService.class).toInstance(tunnelService);
import org.glyptodon.guacamole.auth.jdbc.tunnel.ConfigurableGuacamoleTunnelService;
     * Returns the appropriate tunnel service given the Guacamole environment.
     * The service is configured based on configuration options that dictate
     * the default concurrent usage policy.
     *     A tunnel service implementation configured according to the
     *     concurrent usage policy options set in the Guacamole environment.
    private GuacamoleTunnelService getTunnelService(Environment environment)
        // Tunnel service default configuration
        int connectionDefaultMaxConnections;
        int connectionDefaultMaxConnectionsPerUser;
        int connectionGroupDefaultMaxConnections;
        int connectionGroupDefaultMaxConnectionsPerUser;

        // Read legacy concurrency-related properties
        // Legacy properties to not affect max connections per group
        connectionGroupDefaultMaxConnections = 0;
        // Legacy "simultaneous" property dictates only the maximum number of
        // connections per connection
        if (disallowSimultaneous)
            connectionDefaultMaxConnections = 1;
        else
            connectionDefaultMaxConnections = 0;
        // Legacy "duplicate" property dictates whether connections and groups
        // may be used concurrently only by different users
        if (disallowDuplicate) {
            connectionDefaultMaxConnectionsPerUser      = 1;
            connectionGroupDefaultMaxConnectionsPerUser = 1;
            connectionDefaultMaxConnectionsPerUser      = 0;
            connectionGroupDefaultMaxConnectionsPerUser = 0;

        // Return service configured for specified default limits
        return new ConfigurableGuacamoleTunnelService(
            connectionDefaultMaxConnections,
            connectionDefaultMaxConnectionsPerUser,
            connectionGroupDefaultMaxConnections,
            connectionGroupDefaultMaxConnectionsPerUser
        );

            new JDBCAuthenticationProviderModule(environment, getTunnelService(environment))
import org.glyptodon.guacamole.auth.jdbc.tunnel.ConfigurableGuacamoleTunnelService;
     * Returns the appropriate tunnel service given the Guacamole environment.
     * The service is configured based on configuration options that dictate
     * the default concurrent usage policy.
     *     A tunnel service implementation configured according to the
     *     concurrent usage policy options set in the Guacamole environment.
    private GuacamoleTunnelService getTunnelService(Environment environment)
        // Tunnel service default configuration
        int connectionDefaultMaxConnections;
        int connectionDefaultMaxConnectionsPerUser;
        int connectionGroupDefaultMaxConnections;
        int connectionGroupDefaultMaxConnectionsPerUser;

        // Read legacy concurrency-related properties
        // Legacy properties to not affect max connections per group
        connectionGroupDefaultMaxConnections = 0;
        // Legacy "simultaneous" property dictates only the maximum number of
        // connections per connection
        if (disallowSimultaneous)
            connectionDefaultMaxConnections = 1;
        else
            connectionDefaultMaxConnections = 0;
        // Legacy "duplicate" property dictates whether connections and groups
        // may be used concurrently only by different users
        if (disallowDuplicate) {
            connectionDefaultMaxConnectionsPerUser      = 1;
            connectionGroupDefaultMaxConnectionsPerUser = 1;
            connectionDefaultMaxConnectionsPerUser      = 0;
            connectionGroupDefaultMaxConnectionsPerUser = 0;

        // Return service configured for specified default limits
        return new ConfigurableGuacamoleTunnelService(
            connectionDefaultMaxConnections,
            connectionDefaultMaxConnectionsPerUser,
            connectionGroupDefaultMaxConnections,
            connectionGroupDefaultMaxConnectionsPerUser
        );

            new JDBCAuthenticationProviderModule(environment, getTunnelService(environment))
     * The service to use to provide GuacamoleTunnels for each connection.
    private final GuacamoleTunnelService tunnelService;
     * @param tunnelService
     *     The tunnel service to use to provide tunnels sockets for connections.
            GuacamoleTunnelService tunnelService) {
        this.tunnelService = tunnelService;
        // Bind provided tunnel service
        bind(GuacamoleTunnelService.class).toInstance(tunnelService);
import org.glyptodon.guacamole.auth.jdbc.tunnel.ConfigurableGuacamoleTunnelService;
     * Returns the appropriate tunnel service given the Guacamole environment.
     * The service is configured based on configuration options that dictate
     * the default concurrent usage policy.
     *     A tunnel service implementation configured according to the
     *     concurrent usage policy options set in the Guacamole environment.
    private GuacamoleTunnelService getTunnelService(Environment environment)
        // Tunnel service default configuration
        int connectionDefaultMaxConnections;
        int connectionDefaultMaxConnectionsPerUser;
        int connectionGroupDefaultMaxConnections;
        int connectionGroupDefaultMaxConnectionsPerUser;

        // Read legacy concurrency-related properties
        // Legacy properties to not affect max connections per group
        connectionGroupDefaultMaxConnections = 0;
        // Legacy "simultaneous" property dictates only the maximum number of
        // connections per connection
        if (disallowSimultaneous)
            connectionDefaultMaxConnections = 1;
        else
            connectionDefaultMaxConnections = 0;
        // Legacy "duplicate" property dictates whether connections and groups
        // may be used concurrently only by different users
        if (disallowDuplicate) {
            connectionDefaultMaxConnectionsPerUser      = 1;
            connectionGroupDefaultMaxConnectionsPerUser = 1;
            connectionDefaultMaxConnectionsPerUser      = 0;
            connectionGroupDefaultMaxConnectionsPerUser = 0;

        // Return service configured for specified default limits
        return new ConfigurableGuacamoleTunnelService(
            connectionDefaultMaxConnections,
            connectionDefaultMaxConnectionsPerUser,
            connectionGroupDefaultMaxConnections,
            connectionGroupDefaultMaxConnectionsPerUser
        );

            new JDBCAuthenticationProviderModule(environment, getTunnelService(environment))
import org.glyptodon.guacamole.auth.jdbc.tunnel.ConfigurableGuacamoleTunnelService;
     * Returns the appropriate tunnel service given the Guacamole environment.
     * The service is configured based on configuration options that dictate
     * the default concurrent usage policy.
     *     A tunnel service implementation configured according to the
     *     concurrent usage policy options set in the Guacamole environment.
    private GuacamoleTunnelService getTunnelService(Environment environment)
        // Tunnel service default configuration
        int connectionDefaultMaxConnections;
        int connectionDefaultMaxConnectionsPerUser;
        int connectionGroupDefaultMaxConnections;
        int connectionGroupDefaultMaxConnectionsPerUser;

        // Read legacy concurrency-related properties
        // Legacy properties to not affect max connections per group
        connectionGroupDefaultMaxConnections = 0;
        // Legacy "simultaneous" property dictates only the maximum number of
        // connections per connection
        if (disallowSimultaneous)
            connectionDefaultMaxConnections = 1;
        else
            connectionDefaultMaxConnections = 0;
        // Legacy "duplicate" property dictates whether connections and groups
        // may be used concurrently only by different users
        if (disallowDuplicate) {
            connectionDefaultMaxConnectionsPerUser      = 1;
            connectionGroupDefaultMaxConnectionsPerUser = 1;
            connectionDefaultMaxConnectionsPerUser      = 0;
            connectionGroupDefaultMaxConnectionsPerUser = 0;

        // Return service configured for specified default limits
        return new ConfigurableGuacamoleTunnelService(
            connectionDefaultMaxConnections,
            connectionDefaultMaxConnectionsPerUser,
            connectionGroupDefaultMaxConnections,
            connectionGroupDefaultMaxConnectionsPerUser
        );

            new JDBCAuthenticationProviderModule(environment, getTunnelService(environment))

    /**
     * The maximum number of connections that can be established to this
     * connection concurrently, zero if no restriction applies, or null if the
     * default restrictions should be applied.
     */
    private Integer maxConnections;

    /**
     * The maximum number of connections that can be established to this
     * connection concurrently by any one user, zero if no restriction applies,
     * or null if the default restrictions should be applied.
     */
    private Integer maxConnectionsPerUser;

    /**
     * Returns the maximum number of connections that can be established to
     * this connection concurrently.
     *
     * @return
     *     The maximum number of connections that can be established to this
     *     connection concurrently, zero if no restriction applies, or null if
     *     the default restrictions should be applied.
     */
    public Integer getMaxConnections() {
        return maxConnections;
    }

    /**
     * Sets the maximum number of connections that can be established to this
     * connection concurrently.
     *
     * @param maxConnections
     *     The maximum number of connections that can be established to this
     *     connection concurrently, zero if no restriction applies, or null if
     *     the default restrictions should be applied.
     */
    public void setMaxConnections(Integer maxConnections) {
        this.maxConnections = maxConnections;
    }

    /**
     * Returns the maximum number of connections that can be established to
     * this connection concurrently by any one user.
     *
     * @return
     *     The maximum number of connections that can be established to this
     *     connection concurrently by any one user, zero if no restriction
     *     applies, or null if the default restrictions should be applied.
     */
    public Integer getMaxConnectionsPerUser() {
        return maxConnectionsPerUser;
    }

    /**
     * Sets the maximum number of connections that can be established to this
     * connection concurrently by any one user.
     *
     * @param maxConnectionsPerUser
     *     The maximum number of connections that can be established to this
     *     connection concurrently by any one user, zero if no restriction
     *     applies, or null if the default restrictions should be applied.
     */
    public void setMaxConnectionsPerUser(Integer maxConnectionsPerUser) {
        this.maxConnectionsPerUser = maxConnectionsPerUser;
    }


    /**
     * The maximum number of connections that can be established to this
     * connection group concurrently, zero if no restriction applies, or
     * null if the default restrictions should be applied.
     */
    private Integer maxConnections;

    /**
     * The maximum number of connections that can be established to this
     * connection group concurrently by any one user, zero if no restriction
     * applies, or null if the default restrictions should be applied.
     */
    private Integer maxConnectionsPerUser;

    /**
     * Returns the maximum number of connections that can be established to
     * this connection group concurrently.
     *
     * @return
     *     The maximum number of connections that can be established to this
     *     connection group concurrently, zero if no restriction applies, or
     *     null if the default restrictions should be applied.
     */
    public Integer getMaxConnections() {
        return maxConnections;
    }

    /**
     * Sets the maximum number of connections that can be established to this
     * connection group concurrently.
     *
     * @param maxConnections
     *     The maximum number of connections that can be established to this
     *     connection group concurrently, zero if no restriction applies, or
     *     null if the default restrictions should be applied.
     */
    public void setMaxConnections(Integer maxConnections) {
        this.maxConnections = maxConnections;
    }

    /**
     * Returns the maximum number of connections that can be established to
     * this connection group concurrently by any one user.
     *
     * @return
     *     The maximum number of connections that can be established to this
     *     connection group concurrently by any one user, zero if no
     *     restriction applies, or null if the default restrictions should be
     *     applied.
     */
    public Integer getMaxConnectionsPerUser() {
        return maxConnectionsPerUser;
    }

    /**
     * Sets the maximum number of connections that can be established to this
     * connection group concurrently by any one user.
     *
     * @param maxConnectionsPerUser
     *     The maximum number of connections that can be established to this
     *     connection group concurrently by any one user, zero if no
     *     restriction applies, or null if the default restrictions should be
     *     applied.
     */
    public void setMaxConnectionsPerUser(Integer maxConnectionsPerUser) {
        this.maxConnectionsPerUser = maxConnectionsPerUser;
    }

            // Determine per-user limits on this connection
            Integer connectionMaxConnectionsPerUser = connection.getModel().getMaxConnectionsPerUser();
            if (connectionMaxConnectionsPerUser == null)
                connectionMaxConnectionsPerUser = connectionDefaultMaxConnectionsPerUser;

            // Determine overall limits on this connection
            Integer connectionMaxConnections = connection.getModel().getMaxConnections();
            if (connectionMaxConnections == null)
                connectionMaxConnections = connectionDefaultMaxConnections;

            if (tryAdd(activeSeats, seat, connectionMaxConnectionsPerUser)) {
                        connectionMaxConnections))
        // Determine per-user limits on this connection group
        Integer connectionGroupMaxConnectionsPerUser = connectionGroup.getModel().getMaxConnectionsPerUser();
        if (connectionGroupMaxConnectionsPerUser == null)
            connectionGroupMaxConnectionsPerUser = connectionGroupDefaultMaxConnectionsPerUser;

        // Determine overall limits on this connection group
        Integer connectionGroupMaxConnections = connectionGroup.getModel().getMaxConnections();
        if (connectionGroupMaxConnections == null)
            connectionGroupMaxConnections = connectionGroupDefaultMaxConnections;

                connectionGroupMaxConnectionsPerUser)) {
                    connectionGroupMaxConnections))
    @Override
    public Map<String, String> getAttributes() {
        Map<String, String> attributes = new HashMap<String, String>();

        // Set disabled attribute
        attributes.put(DISABLED_ATTRIBUTE_NAME, getModel().isDisabled() ? "true" : null);

        // Set password expired attribute
        attributes.put(EXPIRED_ATTRIBUTE_NAME, getModel().isExpired() ? "true" : null);

        // Set access window start time
        attributes.put(ACCESS_WINDOW_START_ATTRIBUTE_NAME, TimeField.format(getModel().getAccessWindowStart()));

        // Set access window end time
        attributes.put(ACCESS_WINDOW_END_ATTRIBUTE_NAME, TimeField.format(getModel().getAccessWindowEnd()));

        // Set account validity start date
        attributes.put(VALID_FROM_ATTRIBUTE_NAME, DateField.format(getModel().getValidFrom()));

        // Set account validity end date
        attributes.put(VALID_UNTIL_ATTRIBUTE_NAME, DateField.format(getModel().getValidUntil()));

        // Set timezone attribute
        attributes.put(TIMEZONE_ATTRIBUTE_NAME, getModel().getTimeZone());

        return attributes;
     * DateField.FORMAT and as would be produced by DateField.format().
        java.util.Date parsedDate = DateField.parse(dateString);
        if (parsedDate == null)
        // Convert to SQL Date
        return new Date(parsedDate.getTime());
     * TimeField.FORMAT and as would be produced by TimeField.format().
        java.util.Date parsedDate = TimeField.parse(timeString);
        if (parsedDate == null)
        // Convert to SQL Time 
        return new Time(parsedDate.getTime());
        getModel().setTimeZone(TimeZoneField.parse(attributes.get(TIMEZONE_ATTRIBUTE_NAME)));
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

    /**
     * Converts the given date into a string which follows the format used by
     * date fields.
     *
     * @param date
     *     The date value to format, which may be null.
     *
     * @return
     *     The formatted date, or null if the provided time was null.
     */
    public static String format(Date date) {
        DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
        return date == null ? null : dateFormat.format(date);
    }

    /**
     * Parses the given string into a corresponding date. The string must
     * follow the standard format used by date fields, as defined by FORMAT
     * and as would be produced by format().
     *
     * @param dateString
     *     The date string to parse, which may be null.
     *
     * @return
     *     The date corresponding to the given date string, or null if the
     *     provided date string was null or blank.
     *
     * @throws ParseException
     *     If the given date string does not conform to the standard format
     *     used by date fields.
     */
    public static Date parse(String dateString)
            throws ParseException {

        // Return null if no date provided
        if (dateString == null || dateString.isEmpty())
            return null;

        // Parse date according to format
        DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
        return dateFormat.parse(dateString);

    }

    /**
     * Formats the given integer in the format required by a numeric field.
     *
     * @param i
     *     The integer to format, which may be null.
     *
     * @return
     *     A string representation of the given integer, or null if the given
     *     integer was null.
     */
    public static String format(Integer i) {

        if (i == null)
            return null;

        return i.toString();

    }

    /**
     * Parses the given string as an integer, where the given string is in the
     * format required by a numeric field.
     *
     * @param str
     *     The string to parse as an integer, which may be null.
     *
     * @return
     *     The integer representation of the given string, or null if the given
     *     string was null.
     *
     * @throws NumberFormatException
     *     If the given string is not in a parseable format.
     */
    public static Integer parse(String str) throws NumberFormatException {

        if (str == null || str.isEmpty())
            return null;

        return new Integer(str);

    }

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

    /**
     * Parses the given string into a corresponding time. The string must
     * follow the standard format used by time fields, as defined by
     * FORMAT and as would be produced by format().
     *
     * @param timeString
     *     The time string to parse, which may be null.
     *
     * @return
     *     The time corresponding to the given time string, or null if the
     *     provided time string was null or blank.
     *
     * @throws ParseException
     *     If the given time string does not conform to the standard format
     *     used by time fields.
     */
    public static Date parse(String timeString)
            throws ParseException {

        // Return null if no time provided
        if (timeString == null || timeString.isEmpty())
            return null;

        // Parse time according to format
        DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
        return timeFormat.parse(timeString);

    }

    /**
     * Converts the given time into a string which follows the format used by
     * time fields.
     *
     * @param time
     *     The time value to format, which may be null.
     *
     * @return
     *     The formatted time, or null if the provided time was null.
     */
    public static String format(Date time) {
        DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
        return time == null ? null : timeFormat.format(time);
    }

    /**
     * Parses the given string into a time zone ID string. As these strings are
     * equivalent, the only transformation currently performed by this function
     * is to ensure that a blank time zone string is parsed into null.
     *
     * @param timeZone
     *     The time zone string to parse, which may be null.
     *
     * @return
     *     The ID of the time zone corresponding to the given string, or null
     *     if the given time zone string was null or blank.
     */
    public static String parse(String timeZone) {

        // Return null if no time zone provided
        if (timeZone == null || timeZone.isEmpty())
            return null;

        // Otherwise, assume time zone is valid
        return timeZone;

    }

            throw new GuacamoleClientTooManyException("Cannot connect. Connection already in use by this user.");
            if (count >= max && max != 0)
 * Copyright (C) 2015 Glyptodon LLC
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.form.Form;
import org.glyptodon.guacamole.form.NumericField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(ModeledConnection.class);

    /**
     * The name of the attribute which controls the maximum number of
     * concurrent connections.
     */
    public static final String MAX_CONNECTIONS_NAME = "max-connections";

    /**
     * The name of the attribute which controls the maximum number of
     * concurrent connections per user.
     */
    public static final String MAX_CONNECTIONS_PER_USER_NAME = "max-connections-per-user";

    /**
     * All attributes related to restricting user accounts, within a logical
     * form.
     */
    public static final Form CONCURRENCY_LIMITS = new Form("concurrency", Arrays.<Field>asList(
        new NumericField(MAX_CONNECTIONS_NAME),
        new NumericField(MAX_CONNECTIONS_PER_USER_NAME)
    ));

    /**
     * All possible attributes of connection objects organized as individual,
     * logical forms.
     */
    public static final Collection<Form> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
        CONCURRENCY_LIMITS
    ));

    /**

        Map<String, String> attributes = new HashMap<String, String>();

        // Set connection limit attribute
        attributes.put(MAX_CONNECTIONS_NAME, NumericField.format(getModel().getMaxConnections()));

        // Set per-user connection limit attribute
        attributes.put(MAX_CONNECTIONS_PER_USER_NAME, NumericField.format(getModel().getMaxConnectionsPerUser()));

        return attributes;

        // Translate connection limit attribute
        try { getModel().setMaxConnections(NumericField.parse(attributes.get(MAX_CONNECTIONS_NAME))); }
        catch (NumberFormatException e) {
            logger.warn("Not setting maximum connections: {}", e.getMessage());
            logger.debug("Unable to parse numeric attribute.", e);
        }

        // Translate per-user connection limit attribute
        try { getModel().setMaxConnectionsPerUser(NumericField.parse(attributes.get(MAX_CONNECTIONS_PER_USER_NAME))); }
        catch (NumberFormatException e) {
            logger.warn("Not setting maximum connections per user: {}", e.getMessage());
            logger.debug("Unable to parse numeric attribute.", e);
        }

 * Copyright (C) 2015 Glyptodon LLC
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.form.Form;
import org.glyptodon.guacamole.form.NumericField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 * @author Michael Jumper
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(ModeledConnectionGroup.class);

    /**
     * The name of the attribute which controls the maximum number of
     * concurrent connections.
     */
    public static final String MAX_CONNECTIONS_NAME = "max-connections";

    /**
     * The name of the attribute which controls the maximum number of
     * concurrent connections per user.
     */
    public static final String MAX_CONNECTIONS_PER_USER_NAME = "max-connections-per-user";

    /**
     * All attributes related to restricting user accounts, within a logical
     * form.
     */
    public static final Form CONCURRENCY_LIMITS = new Form("concurrency", Arrays.<Field>asList(
        new NumericField(MAX_CONNECTIONS_NAME),
        new NumericField(MAX_CONNECTIONS_PER_USER_NAME)
    ));

    /**
     * All possible attributes of connection group objects organized as
     * individual, logical forms.
     */
    public static final Collection<Form> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
        CONCURRENCY_LIMITS
    ));

    /**

        Map<String, String> attributes = new HashMap<String, String>();

        // Set connection limit attribute
        attributes.put(MAX_CONNECTIONS_NAME, NumericField.format(getModel().getMaxConnections()));

        // Set per-user connection limit attribute
        attributes.put(MAX_CONNECTIONS_PER_USER_NAME, NumericField.format(getModel().getMaxConnectionsPerUser()));

        return attributes;

        // Translate connection limit attribute
        try { getModel().setMaxConnections(NumericField.parse(attributes.get(MAX_CONNECTIONS_NAME))); }
        catch (NumberFormatException e) {
            logger.warn("Not setting maximum connections: {}", e.getMessage());
            logger.debug("Unable to parse numeric attribute.", e);
        }

        // Translate per-user connection limit attribute
        try { getModel().setMaxConnectionsPerUser(NumericField.parse(attributes.get(MAX_CONNECTIONS_PER_USER_NAME))); }
        catch (NumberFormatException e) {
            logger.warn("Not setting maximum connections per user: {}", e.getMessage());
            logger.debug("Unable to parse numeric attribute.", e);
        }

import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
        return ModeledConnection.ATTRIBUTES;
        return ModeledConnectionGroup.ATTRIBUTES;
        // Return null if no value provided
        // Convert to string
        // Return null if no value provided
        // Parse as integer

    /**
     * The maximum number of connections that can be established to this
     * connection concurrently, zero if no restriction applies, or null if the
     * default restrictions should be applied.
     */
    private Integer maxConnections;

    /**
     * The maximum number of connections that can be established to this
     * connection concurrently by any one user, zero if no restriction applies,
     * or null if the default restrictions should be applied.
     */
    private Integer maxConnectionsPerUser;

    /**
     * Returns the maximum number of connections that can be established to
     * this connection concurrently.
     *
     * @return
     *     The maximum number of connections that can be established to this
     *     connection concurrently, zero if no restriction applies, or null if
     *     the default restrictions should be applied.
     */
    public Integer getMaxConnections() {
        return maxConnections;
    }

    /**
     * Sets the maximum number of connections that can be established to this
     * connection concurrently.
     *
     * @param maxConnections
     *     The maximum number of connections that can be established to this
     *     connection concurrently, zero if no restriction applies, or null if
     *     the default restrictions should be applied.
     */
    public void setMaxConnections(Integer maxConnections) {
        this.maxConnections = maxConnections;
    }

    /**
     * Returns the maximum number of connections that can be established to
     * this connection concurrently by any one user.
     *
     * @return
     *     The maximum number of connections that can be established to this
     *     connection concurrently by any one user, zero if no restriction
     *     applies, or null if the default restrictions should be applied.
     */
    public Integer getMaxConnectionsPerUser() {
        return maxConnectionsPerUser;
    }

    /**
     * Sets the maximum number of connections that can be established to this
     * connection concurrently by any one user.
     *
     * @param maxConnectionsPerUser
     *     The maximum number of connections that can be established to this
     *     connection concurrently by any one user, zero if no restriction
     *     applies, or null if the default restrictions should be applied.
     */
    public void setMaxConnectionsPerUser(Integer maxConnectionsPerUser) {
        this.maxConnectionsPerUser = maxConnectionsPerUser;
    }

 * Copyright (C) 2015 Glyptodon LLC
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.form.Form;
import org.glyptodon.guacamole.form.NumericField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(ModeledConnection.class);

    /**
     * The name of the attribute which controls the maximum number of
     * concurrent connections.
     */
    public static final String MAX_CONNECTIONS_NAME = "max-connections";

    /**
     * The name of the attribute which controls the maximum number of
     * concurrent connections per user.
     */
    public static final String MAX_CONNECTIONS_PER_USER_NAME = "max-connections-per-user";

    /**
     * All attributes related to restricting user accounts, within a logical
     * form.
     */
    public static final Form CONCURRENCY_LIMITS = new Form("concurrency", Arrays.<Field>asList(
        new NumericField(MAX_CONNECTIONS_NAME),
        new NumericField(MAX_CONNECTIONS_PER_USER_NAME)
    ));

    /**
     * All possible attributes of connection objects organized as individual,
     * logical forms.
     */
    public static final Collection<Form> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
        CONCURRENCY_LIMITS
    ));

    /**

        Map<String, String> attributes = new HashMap<String, String>();

        // Set connection limit attribute
        attributes.put(MAX_CONNECTIONS_NAME, NumericField.format(getModel().getMaxConnections()));

        // Set per-user connection limit attribute
        attributes.put(MAX_CONNECTIONS_PER_USER_NAME, NumericField.format(getModel().getMaxConnectionsPerUser()));

        return attributes;

        // Translate connection limit attribute
        try { getModel().setMaxConnections(NumericField.parse(attributes.get(MAX_CONNECTIONS_NAME))); }
        catch (NumberFormatException e) {
            logger.warn("Not setting maximum connections: {}", e.getMessage());
            logger.debug("Unable to parse numeric attribute.", e);
        }

        // Translate per-user connection limit attribute
        try { getModel().setMaxConnectionsPerUser(NumericField.parse(attributes.get(MAX_CONNECTIONS_PER_USER_NAME))); }
        catch (NumberFormatException e) {
            logger.warn("Not setting maximum connections per user: {}", e.getMessage());
            logger.debug("Unable to parse numeric attribute.", e);
        }


    /**
     * The maximum number of connections that can be established to this
     * connection group concurrently, zero if no restriction applies, or
     * null if the default restrictions should be applied.
     */
    private Integer maxConnections;

    /**
     * The maximum number of connections that can be established to this
     * connection group concurrently by any one user, zero if no restriction
     * applies, or null if the default restrictions should be applied.
     */
    private Integer maxConnectionsPerUser;

    /**
     * Returns the maximum number of connections that can be established to
     * this connection group concurrently.
     *
     * @return
     *     The maximum number of connections that can be established to this
     *     connection group concurrently, zero if no restriction applies, or
     *     null if the default restrictions should be applied.
     */
    public Integer getMaxConnections() {
        return maxConnections;
    }

    /**
     * Sets the maximum number of connections that can be established to this
     * connection group concurrently.
     *
     * @param maxConnections
     *     The maximum number of connections that can be established to this
     *     connection group concurrently, zero if no restriction applies, or
     *     null if the default restrictions should be applied.
     */
    public void setMaxConnections(Integer maxConnections) {
        this.maxConnections = maxConnections;
    }

    /**
     * Returns the maximum number of connections that can be established to
     * this connection group concurrently by any one user.
     *
     * @return
     *     The maximum number of connections that can be established to this
     *     connection group concurrently by any one user, zero if no
     *     restriction applies, or null if the default restrictions should be
     *     applied.
     */
    public Integer getMaxConnectionsPerUser() {
        return maxConnectionsPerUser;
    }

    /**
     * Sets the maximum number of connections that can be established to this
     * connection group concurrently by any one user.
     *
     * @param maxConnectionsPerUser
     *     The maximum number of connections that can be established to this
     *     connection group concurrently by any one user, zero if no
     *     restriction applies, or null if the default restrictions should be
     *     applied.
     */
    public void setMaxConnectionsPerUser(Integer maxConnectionsPerUser) {
        this.maxConnectionsPerUser = maxConnectionsPerUser;
    }

 * Copyright (C) 2015 Glyptodon LLC
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import org.glyptodon.guacamole.form.Field;
import org.glyptodon.guacamole.form.Form;
import org.glyptodon.guacamole.form.NumericField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 * @author Michael Jumper
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(ModeledConnectionGroup.class);

    /**
     * The name of the attribute which controls the maximum number of
     * concurrent connections.
     */
    public static final String MAX_CONNECTIONS_NAME = "max-connections";

    /**
     * The name of the attribute which controls the maximum number of
     * concurrent connections per user.
     */
    public static final String MAX_CONNECTIONS_PER_USER_NAME = "max-connections-per-user";

    /**
     * All attributes related to restricting user accounts, within a logical
     * form.
     */
    public static final Form CONCURRENCY_LIMITS = new Form("concurrency", Arrays.<Field>asList(
        new NumericField(MAX_CONNECTIONS_NAME),
        new NumericField(MAX_CONNECTIONS_PER_USER_NAME)
    ));

    /**
     * All possible attributes of connection group objects organized as
     * individual, logical forms.
     */
    public static final Collection<Form> ATTRIBUTES = Collections.unmodifiableCollection(Arrays.asList(
        CONCURRENCY_LIMITS
    ));

    /**

        Map<String, String> attributes = new HashMap<String, String>();

        // Set connection limit attribute
        attributes.put(MAX_CONNECTIONS_NAME, NumericField.format(getModel().getMaxConnections()));

        // Set per-user connection limit attribute
        attributes.put(MAX_CONNECTIONS_PER_USER_NAME, NumericField.format(getModel().getMaxConnectionsPerUser()));

        return attributes;

        // Translate connection limit attribute
        try { getModel().setMaxConnections(NumericField.parse(attributes.get(MAX_CONNECTIONS_NAME))); }
        catch (NumberFormatException e) {
            logger.warn("Not setting maximum connections: {}", e.getMessage());
            logger.debug("Unable to parse numeric attribute.", e);
        }

        // Translate per-user connection limit attribute
        try { getModel().setMaxConnectionsPerUser(NumericField.parse(attributes.get(MAX_CONNECTIONS_PER_USER_NAME))); }
        catch (NumberFormatException e) {
            logger.warn("Not setting maximum connections per user: {}", e.getMessage());
            logger.debug("Unable to parse numeric attribute.", e);
        }

            if (count >= max && max != 0)
            // Determine per-user limits on this connection
            Integer connectionMaxConnectionsPerUser = connection.getModel().getMaxConnectionsPerUser();
            if (connectionMaxConnectionsPerUser == null)
                connectionMaxConnectionsPerUser = connectionDefaultMaxConnectionsPerUser;

            // Determine overall limits on this connection
            Integer connectionMaxConnections = connection.getModel().getMaxConnections();
            if (connectionMaxConnections == null)
                connectionMaxConnections = connectionDefaultMaxConnections;

            if (tryAdd(activeSeats, seat, connectionMaxConnectionsPerUser)) {
                        connectionMaxConnections))
            throw new GuacamoleClientTooManyException("Cannot connect. Connection already in use by this user.");
        // Determine per-user limits on this connection group
        Integer connectionGroupMaxConnectionsPerUser = connectionGroup.getModel().getMaxConnectionsPerUser();
        if (connectionGroupMaxConnectionsPerUser == null)
            connectionGroupMaxConnectionsPerUser = connectionGroupDefaultMaxConnectionsPerUser;

        // Determine overall limits on this connection group
        Integer connectionGroupMaxConnections = connectionGroup.getModel().getMaxConnections();
        if (connectionGroupMaxConnections == null)
            connectionGroupMaxConnections = connectionGroupDefaultMaxConnections;

                connectionGroupMaxConnectionsPerUser)) {
                    connectionGroupMaxConnections))
    @Override
    public Map<String, String> getAttributes() {
        Map<String, String> attributes = new HashMap<String, String>();

        // Set disabled attribute
        attributes.put(DISABLED_ATTRIBUTE_NAME, getModel().isDisabled() ? "true" : null);

        // Set password expired attribute
        attributes.put(EXPIRED_ATTRIBUTE_NAME, getModel().isExpired() ? "true" : null);

        // Set access window start time
        attributes.put(ACCESS_WINDOW_START_ATTRIBUTE_NAME, TimeField.format(getModel().getAccessWindowStart()));

        // Set access window end time
        attributes.put(ACCESS_WINDOW_END_ATTRIBUTE_NAME, TimeField.format(getModel().getAccessWindowEnd()));

        // Set account validity start date
        attributes.put(VALID_FROM_ATTRIBUTE_NAME, DateField.format(getModel().getValidFrom()));

        // Set account validity end date
        attributes.put(VALID_UNTIL_ATTRIBUTE_NAME, DateField.format(getModel().getValidUntil()));

        // Set timezone attribute
        attributes.put(TIMEZONE_ATTRIBUTE_NAME, getModel().getTimeZone());

        return attributes;
     * DateField.FORMAT and as would be produced by DateField.format().
        java.util.Date parsedDate = DateField.parse(dateString);
        if (parsedDate == null)
        // Convert to SQL Date
        return new Date(parsedDate.getTime());
     * TimeField.FORMAT and as would be produced by TimeField.format().
        java.util.Date parsedDate = TimeField.parse(timeString);
        if (parsedDate == null)
        // Convert to SQL Time 
        return new Time(parsedDate.getTime());
        getModel().setTimeZone(TimeZoneField.parse(attributes.get(TIMEZONE_ATTRIBUTE_NAME)));
import org.glyptodon.guacamole.auth.jdbc.connection.ModeledConnection;
import org.glyptodon.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
        return ModeledConnection.ATTRIBUTES;
        return ModeledConnectionGroup.ATTRIBUTES;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

    /**
     * Converts the given date into a string which follows the format used by
     * date fields.
     *
     * @param date
     *     The date value to format, which may be null.
     *
     * @return
     *     The formatted date, or null if the provided time was null.
     */
    public static String format(Date date) {
        DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
        return date == null ? null : dateFormat.format(date);
    }

    /**
     * Parses the given string into a corresponding date. The string must
     * follow the standard format used by date fields, as defined by FORMAT
     * and as would be produced by format().
     *
     * @param dateString
     *     The date string to parse, which may be null.
     *
     * @return
     *     The date corresponding to the given date string, or null if the
     *     provided date string was null or blank.
     *
     * @throws ParseException
     *     If the given date string does not conform to the standard format
     *     used by date fields.
     */
    public static Date parse(String dateString)
            throws ParseException {

        // Return null if no date provided
        if (dateString == null || dateString.isEmpty())
            return null;

        // Parse date according to format
        DateFormat dateFormat = new SimpleDateFormat(DateField.FORMAT);
        return dateFormat.parse(dateString);

    }

    /**
     * Formats the given integer in the format required by a numeric field.
     *
     * @param i
     *     The integer to format, which may be null.
     *
     * @return
     *     A string representation of the given integer, or null if the given
     *     integer was null.
     */
    public static String format(Integer i) {

        // Return null if no value provided
        if (i == null)
            return null;

        // Convert to string
        return i.toString();

    }

    /**
     * Parses the given string as an integer, where the given string is in the
     * format required by a numeric field.
     *
     * @param str
     *     The string to parse as an integer, which may be null.
     *
     * @return
     *     The integer representation of the given string, or null if the given
     *     string was null.
     *
     * @throws NumberFormatException
     *     If the given string is not in a parseable format.
     */
    public static Integer parse(String str) throws NumberFormatException {

        // Return null if no value provided
        if (str == null || str.isEmpty())
            return null;

        // Parse as integer
        return new Integer(str);

    }

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

    /**
     * Parses the given string into a corresponding time. The string must
     * follow the standard format used by time fields, as defined by
     * FORMAT and as would be produced by format().
     *
     * @param timeString
     *     The time string to parse, which may be null.
     *
     * @return
     *     The time corresponding to the given time string, or null if the
     *     provided time string was null or blank.
     *
     * @throws ParseException
     *     If the given time string does not conform to the standard format
     *     used by time fields.
     */
    public static Date parse(String timeString)
            throws ParseException {

        // Return null if no time provided
        if (timeString == null || timeString.isEmpty())
            return null;

        // Parse time according to format
        DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
        return timeFormat.parse(timeString);

    }

    /**
     * Converts the given time into a string which follows the format used by
     * time fields.
     *
     * @param time
     *     The time value to format, which may be null.
     *
     * @return
     *     The formatted time, or null if the provided time was null.
     */
    public static String format(Date time) {
        DateFormat timeFormat = new SimpleDateFormat(TimeField.FORMAT);
        return time == null ? null : timeFormat.format(time);
    }

    /**
     * Parses the given string into a time zone ID string. As these strings are
     * equivalent, the only transformation currently performed by this function
     * is to ensure that a blank time zone string is parsed into null.
     *
     * @param timeZone
     *     The time zone string to parse, which may be null.
     *
     * @return
     *     The ID of the time zone corresponding to the given string, or null
     *     if the given time zone string was null or blank.
     */
    public static String parse(String timeZone) {

        // Return null if no time zone provided
        if (timeZone == null || timeZone.isEmpty())
            return null;

        // Otherwise, assume time zone is valid
        return timeZone;

    }

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(MySQLAuthenticationProvider.class);

    /**
        Boolean disallowSimultaneous = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS);
        Boolean disallowDuplicate    = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS);
        if (disallowSimultaneous != null) {

            // Translate legacy property
            if (disallowSimultaneous) {
                connectionDefaultMaxConnections = 1;
                connectionGroupDefaultMaxConnections = 0;
            }
            else {
                connectionDefaultMaxConnections = 0;
                connectionGroupDefaultMaxConnections = 0;
            }

            // Warn of deprecation
            logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(),
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS.getName(),
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());

            // Inform of new equivalent
            logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(), disallowSimultaneous,
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS.getName(),           connectionDefaultMaxConnections,
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName(),     connectionGroupDefaultMaxConnections);

        }

        // If legacy property is not specified, use new property
        else {
            connectionDefaultMaxConnections      = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS, 0);
            connectionGroupDefaultMaxConnections = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS, 0);
        }
        if (disallowDuplicate != null) {

            // Translate legacy property
            if (disallowDuplicate) {
                connectionDefaultMaxConnectionsPerUser      = 1;
                connectionGroupDefaultMaxConnectionsPerUser = 1;
            }
            else {
                connectionDefaultMaxConnectionsPerUser      = 0;
                connectionGroupDefaultMaxConnectionsPerUser = 0;
            }

            // Warn of deprecation
            logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());

            // Inform of new equivalent
            logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),         disallowDuplicate,
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),       connectionDefaultMaxConnectionsPerUser,
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER.getName(), connectionGroupDefaultMaxConnectionsPerUser);


        // If legacy property is not specified, use new property
            connectionDefaultMaxConnectionsPerUser      = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER, 1);
            connectionGroupDefaultMaxConnectionsPerUser = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER, 1);

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection. Zero denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            MYSQL_DEFAULT_MAX_CONNECTIONS =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-default-max-connections"; }

    };

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection group. Zero denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-default-max-group-connections"; }

    };

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection by an individual user. Zero denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-default-max-connections-per-user"; }

    };

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection group by an individual user. Zero denotes
     * unlimited.
     */
    public static final IntegerGuacamoleProperty
            MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-default-max-group-connections-per-user"; }

    };

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(PostgreSQLAuthenticationProvider.class);

    /**
        Boolean disallowSimultaneous = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS);
        Boolean disallowDuplicate    = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS);
        if (disallowSimultaneous != null) {

            // Translate legacy property
            if (disallowSimultaneous) {
                connectionDefaultMaxConnections = 1;
                connectionGroupDefaultMaxConnections = 0;
            }
            else {
                connectionDefaultMaxConnections = 0;
                connectionGroupDefaultMaxConnections = 0;
            }

            // Warn of deprecation
            logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(),
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS.getName(),
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());

            // Inform of new equivalent
            logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(), disallowSimultaneous,
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS.getName(),           connectionDefaultMaxConnections,
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName(),     connectionGroupDefaultMaxConnections);

        }

        // If legacy property is not specified, use new property
        else {
            connectionDefaultMaxConnections      = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS, 0);
            connectionGroupDefaultMaxConnections = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS, 0);
        }
        if (disallowDuplicate != null) {

            // Translate legacy property
            if (disallowDuplicate) {
                connectionDefaultMaxConnectionsPerUser      = 1;
                connectionGroupDefaultMaxConnectionsPerUser = 1;
            }
            else {
                connectionDefaultMaxConnectionsPerUser      = 0;
                connectionGroupDefaultMaxConnectionsPerUser = 0;
            }

            // Warn of deprecation
            logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());

            // Inform of new equivalent
            logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),         disallowDuplicate,
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),       connectionDefaultMaxConnectionsPerUser,
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER.getName(), connectionGroupDefaultMaxConnectionsPerUser);


        // If legacy property is not specified, use new property
            connectionDefaultMaxConnectionsPerUser      = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER, 1);
            connectionGroupDefaultMaxConnectionsPerUser = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER, 1);

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection. Zero denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            POSTGRESQL_DEFAULT_MAX_CONNECTIONS =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-default-max-connections"; }

    };

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection group. Zero denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-default-max-group-connections"; }

    };

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection by an individual user. Zero denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-default-max-connections-per-user"; }

    };

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection group by an individual user. Zero denotes
     * unlimited.
     */
    public static final IntegerGuacamoleProperty
            POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-default-max-group-connections-per-user"; }

    };

                connectionDefaultMaxConnections      = 1;
                connectionDefaultMaxConnections      = 0;
                connectionDefaultMaxConnections      = 1;
                connectionDefaultMaxConnections      = 0;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(MySQLAuthenticationProvider.class);

    /**
        Boolean disallowSimultaneous = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS);
        Boolean disallowDuplicate    = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS);
        if (disallowSimultaneous != null) {

            // Translate legacy property
            if (disallowSimultaneous) {
                connectionDefaultMaxConnections      = 1;
                connectionGroupDefaultMaxConnections = 0;
            }
            else {
                connectionDefaultMaxConnections      = 0;
                connectionGroupDefaultMaxConnections = 0;
            }

            // Warn of deprecation
            logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(),
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS.getName(),
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());

            // Inform of new equivalent
            logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(), disallowSimultaneous,
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS.getName(),           connectionDefaultMaxConnections,
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName(),     connectionGroupDefaultMaxConnections);

        }

        // If legacy property is not specified, use new property
        else {
            connectionDefaultMaxConnections      = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS, 0);
            connectionGroupDefaultMaxConnections = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS, 0);
        }
        if (disallowDuplicate != null) {

            // Translate legacy property
            if (disallowDuplicate) {
                connectionDefaultMaxConnectionsPerUser      = 1;
                connectionGroupDefaultMaxConnectionsPerUser = 1;
            }
            else {
                connectionDefaultMaxConnectionsPerUser      = 0;
                connectionGroupDefaultMaxConnectionsPerUser = 0;
            }

            // Warn of deprecation
            logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());

            // Inform of new equivalent
            logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),         disallowDuplicate,
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),       connectionDefaultMaxConnectionsPerUser,
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER.getName(), connectionGroupDefaultMaxConnectionsPerUser);


        // If legacy property is not specified, use new property
            connectionDefaultMaxConnectionsPerUser      = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER, 1);
            connectionGroupDefaultMaxConnectionsPerUser = environment.getProperty(MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER, 1);

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection. Zero denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            MYSQL_DEFAULT_MAX_CONNECTIONS =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-default-max-connections"; }

    };

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection group. Zero denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-default-max-group-connections"; }

    };

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection by an individual user. Zero denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-default-max-connections-per-user"; }

    };

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection group by an individual user. Zero denotes
     * unlimited.
     */
    public static final IntegerGuacamoleProperty
            MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-default-max-group-connections-per-user"; }

    };

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(PostgreSQLAuthenticationProvider.class);

    /**
        Boolean disallowSimultaneous = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS);
        Boolean disallowDuplicate    = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS);
        if (disallowSimultaneous != null) {

            // Translate legacy property
            if (disallowSimultaneous) {
                connectionDefaultMaxConnections      = 1;
                connectionGroupDefaultMaxConnections = 0;
            }
            else {
                connectionDefaultMaxConnections      = 0;
                connectionGroupDefaultMaxConnections = 0;
            }

            // Warn of deprecation
            logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(),
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS.getName(),
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());

            // Inform of new equivalent
            logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(), disallowSimultaneous,
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS.getName(),           connectionDefaultMaxConnections,
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName(),     connectionGroupDefaultMaxConnections);

        }

        // If legacy property is not specified, use new property
        else {
            connectionDefaultMaxConnections      = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS, 0);
            connectionGroupDefaultMaxConnections = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS, 0);
        }
        if (disallowDuplicate != null) {

            // Translate legacy property
            if (disallowDuplicate) {
                connectionDefaultMaxConnectionsPerUser      = 1;
                connectionGroupDefaultMaxConnectionsPerUser = 1;
            }
            else {
                connectionDefaultMaxConnectionsPerUser      = 0;
                connectionGroupDefaultMaxConnectionsPerUser = 0;
            }

            // Warn of deprecation
            logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());

            // Inform of new equivalent
            logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),         disallowDuplicate,
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),       connectionDefaultMaxConnectionsPerUser,
                    PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER.getName(), connectionGroupDefaultMaxConnectionsPerUser);


        // If legacy property is not specified, use new property
            connectionDefaultMaxConnectionsPerUser      = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER, 1);
            connectionGroupDefaultMaxConnectionsPerUser = environment.getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER, 1);

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection. Zero denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            POSTGRESQL_DEFAULT_MAX_CONNECTIONS =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-default-max-connections"; }

    };

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection group. Zero denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-default-max-group-connections"; }

    };

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection by an individual user. Zero denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            POSTGRESQL_DEFAULT_MAX_CONNECTIONS_PER_USER =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-default-max-connections-per-user"; }

    };

    /**
     * The maximum number of concurrent connections to allow to any one
     * connection group by an individual user. Zero denotes
     * unlimited.
     */
    public static final IntegerGuacamoleProperty
            POSTGRESQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-default-max-group-connections-per-user"; }

    };

 * Copyright (C) 2015 Glyptodon LLC
 * Provides means of authorizing users and for accessing and managing data
 * associated with those users. Access to such data is limited according to the
 * AuthenticationProvider implementation.
     * Returns an AuthenticatedUser representing the user authenticated by the
     * given credentials, if any.
     * @param credentials
     *     The credentials to use for authentication.
     * @return
     *     An AuthenticatedUser representing the user authenticated by the
     *     given credentials, if any, or null if the credentials are invalid.
     *
     * @throws GuacamoleException
     *     If an error occurs while authenticating the user, or if access is
     *     temporarily, permanently, or conditionally denied, such as if the
     *     supplied credentials are insufficient or invalid.
    AuthenticatedUser authenticateUser(Credentials credentials)
     * Returns a new or updated AuthenticatedUser for the given credentials
     * already having produced the given AuthenticatedUser. Note that because
     * this function will be called for all future requests after initial
     * authentication, including tunnel requests, care must be taken to avoid
     * using functions of HttpServletRequest which invalidate the entire request
     * body, such as getParameter(). Doing otherwise may cause the
     * GuacamoleHTTPTunnelServlet to fail.
      *
     * @param credentials
     *     The credentials to use for authentication.
     *
     * @param authenticatedUser
     *     An AuthenticatedUser object representing the user authenticated by
     *     an arbitrary set of credentials. The AuthenticatedUser may come from
     *     this AuthenticationProvider or any other installed
     *     AuthenticationProvider.
     *
     * @return
     *     An updated AuthenticatedUser representing the user authenticated by
     *     the given credentials, if any, or null if the credentials are
     *     invalid.
     *
     * @throws GuacamoleException
     *     If an error occurs while updating the AuthenticatedUser.
    AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException;

    /**
     * Returns the UserContext of the user authenticated by the given
     * credentials.
     *
     * @param authenticatedUser
     *     An AuthenticatedUser object representing the user authenticated by
     *     an arbitrary set of credentials. The AuthenticatedUser may come from
     *     this AuthenticationProvider or any other installed
     *     AuthenticationProvider.
     *
     * @return
     *     A UserContext describing the permissions, connection, connection
     *     groups, etc. accessible or associated with the given authenticated
     *     user, or null if this AuthenticationProvider refuses to provide any
     *     such data.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the UserContext.
     */
    UserContext getUserContext(AuthenticatedUser authenticatedUser)

    /**
     * Returns a new or updated UserContext for the given AuthenticatedUser
     * already having the given UserContext. Note that because this function
     * will be called for all future requests after initial authentication,
     * including tunnel requests, care must be taken to avoid using functions
     * of HttpServletRequest which invalidate the entire request body, such as
     * getParameter(). Doing otherwise may cause the GuacamoleHTTPTunnelServlet
     * to fail.
      *
     * @param context
     *     The existing UserContext belonging to the user in question.
     *
     * @param authenticatedUser
     *     An AuthenticatedUser object representing the user authenticated by
     *     an arbitrary set of credentials. The AuthenticatedUser may come from
     *     this AuthenticationProvider or any other installed
     *     AuthenticationProvider.
     *
     * @return
     *     An updated UserContext describing the permissions, connection,
     *     connection groups, etc. accessible or associated with the given
     *     authenticated user, or null if this AuthenticationProvider refuses
     *     to provide any such data.
     *
     * @throws GuacamoleException
     *     If an error occurs while updating the UserContext.
     */
    UserContext updateUserContext(UserContext context,
            AuthenticatedUser authenticatedUser) throws GuacamoleException;
import java.util.UUID;
import org.glyptodon.guacamole.net.auth.AbstractAuthenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
    /**
     * AuthenticatedUser which contains its own predefined set of authorized
     * configurations.
     *
     * @author Michael Jumper
     */
    private class SimpleAuthenticatedUser extends AbstractAuthenticatedUser {
        /**
         * The credentials provided when this AuthenticatedUser was
         * authenticated.
         */
        private final Credentials credentials;

        /**
         * The GuacamoleConfigurations that this AuthenticatedUser is
         * authorized to use.
         */
        private final Map<String, GuacamoleConfiguration> configs;

        /**
         * Creates a new SimpleAuthenticatedUser associated with the given
         * credentials and having access to the given Map of
         * GuacamoleConfigurations.
         *
         * @param credentials
         *     The credentials provided by the user when they authenticated.
         *
         * @param configs
         *     A Map of all GuacamoleConfigurations for which this user has
         *     access. The keys of this Map are Strings which uniquely identify
         *     each configuration.
         */
        public SimpleAuthenticatedUser(Credentials credentials, Map<String, GuacamoleConfiguration> configs) {

            // Store credentials and configurations
            this.credentials = credentials;
            this.configs = configs;

            // Pull username from credentials if it exists
            String username = credentials.getUsername();
            if (username != null && !username.isEmpty())
                setIdentifier(username);

            // Otherwise generate a random username
            else
                setIdentifier(UUID.randomUUID().toString());

        }

        /**
         * Returns a Map containing all GuacamoleConfigurations that this user
         * is authorized to use. The keys of this Map are Strings which
         * uniquely identify each configuration.
         *
         * @return
         *     A Map of all configurations for which this user is authorized.
         */
        public Map<String, GuacamoleConfiguration> getAuthorizedConfigurations() {
            return configs;
        }

        @Override
        public AuthenticationProvider getAuthenticationProvider() {
            return SimpleAuthenticationProvider.this;
        }

        @Override
        public Credentials getCredentials() {
            return credentials;
        }

    }

    /**
     * Given an arbitrary credentials object, returns a Map containing all
     * configurations authorized by those credentials, filtering those
     * configurations using a TokenFilter and the standard credential tokens
     * (like ${GUAC_USERNAME} and ${GUAC_PASSWORD}). The keys of this Map
     * are Strings which uniquely identify each configuration.
     *
     * @param credentials
     *     The credentials to use to retrieve authorized configurations.
     *
     * @return
     *     A Map of all configurations authorized by the given credentials, or
     *     null if the credentials given are not authorized.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving configurations.
     */
    private Map<String, GuacamoleConfiguration>
            getFilteredAuthorizedConfigurations(Credentials credentials)
            throws GuacamoleException {

        return configs;

    }

    /**
     * Given a user who has already been authenticated, returns a Map
     * containing all configurations for which that user is authorized,
     * filtering those configurations using a TokenFilter and the standard
     * credential tokens (like ${GUAC_USERNAME} and ${GUAC_PASSWORD}). The keys
     * of this Map are Strings which uniquely identify each configuration.
     *
     * @param authenticatedUser
     *     The user whose authorized configurations are to be retrieved.
     *
     * @return
     *     A Map of all configurations authorized for use by the given user, or
     *     null if the user is not authorized to use any configurations.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving configurations.
     */
    private Map<String, GuacamoleConfiguration>
            getFilteredAuthorizedConfigurations(AuthenticatedUser authenticatedUser)
            throws GuacamoleException {

        // Pull cached configurations, if any
        if (authenticatedUser instanceof SimpleAuthenticatedUser)
            return ((SimpleAuthenticatedUser) authenticatedUser).getAuthorizedConfigurations();

        // Otherwise, pull using credentials
        return getFilteredAuthorizedConfigurations(authenticatedUser.getCredentials());

    }

    @Override
    public AuthenticatedUser authenticateUser(final Credentials credentials)
            throws GuacamoleException {

        // Get configurations
        Map<String, GuacamoleConfiguration> configs =
                getFilteredAuthorizedConfigurations(credentials);

        // Return as unauthorized if not authorized to retrieve configs
        if (configs == null)
            return null;

        return new SimpleAuthenticatedUser(credentials, configs);

    }

    @Override
    public UserContext getUserContext(AuthenticatedUser authenticatedUser)
            throws GuacamoleException {

        // Get configurations
        Map<String, GuacamoleConfiguration> configs =
                getFilteredAuthorizedConfigurations(authenticatedUser);

        // Return as unauthorized if not authorized to retrieve configs
        if (configs == null)
            return null;

        // Return user context restricted to authorized configs
        return new SimpleUserContext(authenticatedUser.getIdentifier(), configs);

    }

    @Override
    public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // Simply return the given user, updating nothing
        return authenticatedUser;
        AuthenticatedUser authorizedUser) throws GuacamoleException {
 * Copyright (C) 2015 Glyptodon LLC
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
     * The user associated with this session.
    private AuthenticatedUser authenticatedUser;
     * @param authenticatedUser
     *     The authenticated user to associate this session with.
    public GuacamoleSession(Environment environment,
            AuthenticatedUser authenticatedUser, UserContext userContext)
            throws GuacamoleException {
        this.authenticatedUser = authenticatedUser;
     * Returns the authenticated user associated with this session.
     *     The authenticated user associated with this session.
    public AuthenticatedUser getAuthenticatedUser() {
        return authenticatedUser;
     * Replaces the authenticated user associated with this session with the
     * given authenticated user.
     * @param authenticatedUser
     *     The authenticated user to associated with this session.
    public void setAuthenticatedUser(AuthenticatedUser authenticatedUser) {
        this.authenticatedUser = authenticatedUser;

import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
    public AuthenticatedUser authenticateUser(Credentials credentials)
        return authProvider.authenticateUser(credentials);

    public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {
        return authProvider.updateAuthenticatedUser(authenticatedUser, credentials);

    }

    @Override
    public UserContext getUserContext(AuthenticatedUser authenticatedUser)
            throws GuacamoleException {

        // Ignore auth attempts if no auth provider could be loaded
        if (authProvider == null) {
            logger.warn("User data retrieval attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs.");
            return null;
        }

        // Delegate to underlying auth provider
        return authProvider.getUserContext(authenticatedUser);
        
    }

    @Override
    public UserContext updateUserContext(UserContext context,
            AuthenticatedUser authenticatedUser)
            throws GuacamoleException {

        // Ignore auth attempts if no auth provider could be loaded
        if (authProvider == null) {
            logger.warn("User data refresh attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs.");
            return null;
        }

        // Delegate to underlying auth provider
        return authProvider.updateUserContext(context, authenticatedUser);
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;

        AuthenticatedUser authenticatedUser;
            // Re-authenticate user if session exists
                authenticatedUser = authProvider.updateAuthenticatedUser(existingSession.getAuthenticatedUser(), credentials);
            /// Otherwise, authenticate as a new user
                authenticatedUser = authProvider.authenticateUser(credentials);
                if (authenticatedUser != null && logger.isInfoEnabled())
                            authenticatedUser.getIdentifier(), getLoggableAddress(request));
            // Request standard username/password if no user was produced
            if (authenticatedUser == null)

        // Generate or update user context
        UserContext userContext;
        if (existingSession != null)
            userContext = authProvider.updateUserContext(existingSession.getUserContext(), authenticatedUser);
        else
            userContext = authProvider.getUserContext(authenticatedUser);

        // STUB: Request standard username/password if no user context was produced
        if (userContext == null)
            throw new GuacamoleInvalidCredentialsException("Permission Denied.",
                    CredentialsInfo.USERNAME_PASSWORD);

            existingSession.setAuthenticatedUser(authenticatedUser);
            tokenSessionMap.put(authToken, new GuacamoleSession(environment, authenticatedUser, userContext));
        logger.debug("Login was successful for user \"{}\".", authenticatedUser.getIdentifier());
        return new APIAuthToken(authToken, authenticatedUser.getIdentifier());
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleCredentialsException;
        // Verify that the old password was correct
        try {
            if (authProvider.authenticateUser(credentials) == null) {
                throw new APIException(APIError.Type.PERMISSION_DENIED,
                        "Permission denied.");
            }
        }

        // Pass through any credentials exceptions as simple permission denied
        catch (GuacamoleCredentialsException e) {
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
public class AuthenticatedUser implements org.glyptodon.guacamole.net.auth.AuthenticatedUser {
     * The AuthenticationProvider that authenticated this user.
     */
    private final AuthenticationProvider authenticationProvider;

    /**
     * @param authenticationProvider
     *     The AuthenticationProvider that has authenticated the given user.
     *
    public AuthenticatedUser(AuthenticationProvider authenticationProvider,
            ModeledUser user, Credentials credentials) {
        this.authenticationProvider = authenticationProvider;
    @Override
    @Override
    public AuthenticationProvider getAuthenticationProvider() {
        return authenticationProvider;
    }

    @Override
    public String getIdentifier() {
        return user.getIdentifier();
    }

    @Override
    public void setIdentifier(String identifier) {
        user.setIdentifier(identifier);
    }

import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
     * @param authenticationProvider
     *     The AuthenticationProvider on behalf of which the user is being
     *     retrieved.
     *
     *     An AuthenticatedUser containing the existing ModeledUser object if
     *     the credentials given are valid, null otherwise.
    public AuthenticatedUser retrieveAuthenticatedUser(AuthenticationProvider authenticationProvider,
            Credentials credentials) throws GuacamoleException {
        user.setCurrentUser(new AuthenticatedUser(authenticationProvider, user, credentials));
        return user.getCurrentUser();

    }

    /**
     * Retrieves the user corresponding to the given AuthenticatedUser from the
     * database. If no such user exists, a placeholder entry will be created
     * first.
     *
     * @param authenticatedUser
     *     The AuthenticatedUser to retrieve the corresponding ModeledUser of.
     *
     * @return
     *     The ModeledUser which corresponds to the given AuthenticatedUser,
     *     created first if necessary.
     */
    public ModeledUser retrieveUser(org.glyptodon.guacamole.net.auth.AuthenticatedUser authenticatedUser) {

        // If we already queried this user, return that rather than querying again
        if (authenticatedUser instanceof AuthenticatedUser)
            return ((AuthenticatedUser) authenticatedUser).getUser();

        // Get username
        String username = authenticatedUser.getIdentifier();

        // Retrieve corresponding user model, if such a user exists
        UserModel userModel = userMapper.selectOne(username);
        if (userModel == null)
            return null;

        // Create corresponding user object, set up cyclic reference
        ModeledUser user = getObjectInstance(null, userModel);
        user.setCurrentUser(new AuthenticatedUser(authenticatedUser.getAuthenticationProvider(), user, authenticatedUser.getCredentials()));

        // Return already-authenticated user
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticationProviderService;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
    public AuthenticatedUser authenticateUser(Credentials credentials)
            throws GuacamoleException {

        // Create AuthenticatedUser based on credentials, if valid
        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.authenticateUser(this, credentials);

    }

    @Override
    public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // No need to update authenticated users
        return authenticatedUser;

    }

    @Override
    public UserContext getUserContext(AuthenticatedUser authenticatedUser)
        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.getUserContext(authenticatedUser);
            AuthenticatedUser authenticatedUser) throws GuacamoleException {
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticationProviderService;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
    public AuthenticatedUser authenticateUser(Credentials credentials)
            throws GuacamoleException {

        // Create AuthenticatedUser based on credentials, if valid
        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.authenticateUser(this, credentials);

    }

    @Override
    public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // No need to update authenticated users
        return authenticatedUser;

    }

    @Override
    public UserContext getUserContext(AuthenticatedUser authenticatedUser)
        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.getUserContext(authenticatedUser);
            AuthenticatedUser authenticatedUser) throws GuacamoleException {
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
     * The AuthenticationProvider which is using this module to configure
     * injection.
     */
    private final AuthenticationProvider authProvider;

    /**
     * @param authProvider
     *     The AuthenticationProvider which is using this module to configure
     *     injection.
     *
    public JDBCAuthenticationProviderModule(AuthenticationProvider authProvider,
            Environment environment,
        this.authProvider = authProvider;
        bind(AuthenticationProvider.class).toInstance(authProvider);
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
     * The AuthenticationProvider that created this UserContext.
     */
    @Inject
    private AuthenticationProvider authProvider;

    /**
    public AuthenticationProvider getAuthenticationProvider() {
        return authProvider;
    }

    @Override
            new JDBCAuthenticationProviderModule(this, environment,
                    getTunnelService(environment))
            new JDBCAuthenticationProviderModule(this, environment,
                    getTunnelService(environment))
     * Returns the AuthenticationProvider which created this UserContext, which
     * may not be the same AuthenticationProvider that authenticated the user
     * associated with this UserContext.
     *
     * @return
     *     The AuthenticationProvider that created this UserContext.
     */
    AuthenticationProvider getAuthenticationProvider();

    /**
        return new SimpleUserContext(this, authenticatedUser.getIdentifier(), configs);
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;

    /**
     * The AuthenticationProvider that created this UserContext.
     */
    private final AuthenticationProvider authProvider;

     *
     * @param authProvider
     *     The AuthenticationProvider creating this UserContext.
     *
     * @param configs
     *     A Map of all configurations for which the user associated with this
     *     UserContext has read access.
    public SimpleUserContext(AuthenticationProvider authProvider,
            Map<String, GuacamoleConfiguration> configs) {
        this(authProvider, UUID.randomUUID().toString(), configs);
     *
     * @param authProvider
     *     The AuthenticationProvider creating this UserContext.
     *
     * @param username
     *     The username of the user associated with this UserContext.
     *
     * @param configs
     *     A Map of all configurations for which the user associated with
     *     this UserContext has read access.
    public SimpleUserContext(AuthenticationProvider authProvider,
            String username, Map<String, GuacamoleConfiguration> configs) {

        // Associate provided AuthenticationProvider
        this.authProvider = authProvider;

    public AuthenticationProvider getAuthenticationProvider() {
        return authProvider;
    }

    @Override
import java.util.Collections;
import java.util.List;
     * All UserContexts associated with this session. Each
     * AuthenticationProvider may provide its own UserContext.
    private List<UserContext> userContexts;
     * Creates a new Guacamole session associated with the given
     * AuthenticatedUser and UserContexts.
     * @param userContexts
     *     The List of UserContexts to associate with this session.
            AuthenticatedUser authenticatedUser,
            List<UserContext> userContexts)
        this.userContexts = userContexts;

        // Warn of deprecation
        logger.debug(
            "\n****************************************************************"
           "\n"
           "\n       !!!!  PLEASE DO NOT USE getUserContext() !!!!"
           "\n"
           "\n getUserContext() has been replaced by getUserContexts(), which"
           "\n properly handles multiple authentication providers. All use of"
           "\n the old getUserContext() must be removed before GUAC-586 can"
           "\n be considered complete."
           "\n"
           "\n****************************************************************"
        );

        // Return the UserContext associated with the AuthenticationProvider
        // that authenticated the current user.
        String authProviderIdentifier = authenticatedUser.getAuthenticationProvider().getIdentifier();
        for (UserContext userContext : userContexts) {
            if (userContext.getAuthenticationProvider().getIdentifier().equals(authProviderIdentifier))
                return userContext;
        }

        // If not found, return null
        return null;

     * Returns a list of all UserContexts associated with this session. Each
     * AuthenticationProvider currently loaded by Guacamole may provide its own
     * UserContext for any successfully-authenticated user.
     * @return
     *     An unmodifiable list of all UserContexts associated with this
     *     session.
    public List<UserContext> getUserContexts() {
        return Collections.unmodifiableList(userContexts);
    }

    /**
     * Replaces all UserContexts associated with this session with the given
     * List of UserContexts.
     *
     * @param userContexts
     *     The List of UserContexts to associate with this session.
     */
    public void setUserContexts(List<UserContext> userContexts) {
        this.userContexts = userContexts;
                                session.getAuthenticatedUser().getIdentifier(), id, duration);
                                session.getAuthenticatedUser().getIdentifier(), id, duration);
import com.google.inject.Provides;
     * All currently-bound authentication providers, if any.
    private final List<AuthenticationProvider> boundAuthenticationProviders =
            new ArrayList<AuthenticationProvider>();
     * injection, along with any other bound AuthenticationProviders.
        logger.debug("[{}] Binding AuthenticationProvider \"{}\".",
                boundAuthenticationProviders.size(), authenticationProvider.getName());
        boundAuthenticationProviders.add(new AuthenticationProviderFacade(authenticationProvider));
     * injection.
     * Returns a list of all currently-bound AuthenticationProvider instances.
     *
     * @return
     *     A List of all currently-bound AuthenticationProvider. The List is
     *     not modifiable.
     */
    @Provides
    public List<AuthenticationProvider> getAuthenticationProviders() {
        return Collections.unmodifiableList(boundAuthenticationProviders);
    }

    /**
        // Always bind basic auth last
        bindAuthenticationProvider(BasicFileAuthenticationProvider.class);
import java.util.List;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
     * Retrieves a single UserContext from the given GuacamoleSession, which
     * may contain multiple UserContexts.
     *
     * @param session
     *     The GuacamoleSession to retrieve the UserContext from.
     *
     * @param id
     *     The numeric ID of the UserContext to retrieve. This ID is the index
     *     of the UserContext within the overall list of UserContexts
     *     associated with the user's session.
     *
     * @return
     *     The user having the given identifier.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the user, or if the
     *     user does not exist.
     */
    public UserContext retrieveUserContext(GuacamoleSession session,
            int id) throws GuacamoleException {

        // Get list of UserContexts
        List<UserContext> userContexts = session.getUserContexts();

        // Verify context exists
        if (id < 0 || id >= userContexts.size())
            throw new GuacamoleResourceNotFoundException("No such user context: \""  id  "\"");

        return userContexts.get(id);

    }

    /**
import java.util.List;

    /**
     * Returns all UserContexts associated with a given auth token, if the auth
     * token represents a currently logged in user. Throws an unauthorized
     * error otherwise.
     *
     * @param authToken
     *     The auth token to check against the map of logged in users.
     *
     * @return
     *     A List of all UserContexts associated with the provided auth token.
     *
     * @throws GuacamoleException
     *     If the auth token does not correspond to any logged in user.
     */
    public List<UserContext> getUserContexts(String authToken)
            throws GuacamoleException {
        return getGuacamoleSession(authToken).getUserContexts();
    }

import java.util.ArrayList;
import java.util.List;
     * All configured authentication providers which can be used to
     * authenticate users or retrieve data associated with authenticated users.
    private List<AuthenticationProvider> authProviders;
        AuthenticatedUser authenticatedUser = null;
            if (existingSession != null) {
                authenticatedUser = existingSession.getAuthenticatedUser();
                authenticatedUser = authenticatedUser.getAuthenticationProvider().updateAuthenticatedUser(authenticatedUser, credentials);
            }
            // Otherwise, attempt authentication as a new user against each
            // AuthenticationProvider, in deterministic order
                for (AuthenticationProvider authProvider : authProviders) {
                    // Attempt authentication
                    authenticatedUser = authProvider.authenticateUser(credentials);
                    // Stop after successful authentication
                    if (authenticatedUser != null && logger.isInfoEnabled()) {
                        logger.info("User \"{}\" successfully authenticated from {}.",
                                authenticatedUser.getIdentifier(), getLoggableAddress(request));
                        break;
                    }
                }
        // Get UserContexts from each available AuthenticationProvider
        List<UserContext> userContexts = new ArrayList<UserContext>(authProviders.size());
        for (AuthenticationProvider authProvider : authProviders) {
            // Generate or update user context
            UserContext userContext;
            if (existingSession != null)
                userContext = authProvider.updateUserContext(existingSession.getUserContext(), authenticatedUser);
            else
                userContext = authProvider.getUserContext(authenticatedUser);

            // Add to available data, if successful
            if (userContext != null)
                userContexts.add(userContext);

        }
            existingSession.setUserContexts(userContexts);
            tokenSessionMap.put(authToken, new GuacamoleSession(environment, authenticatedUser, userContexts));
            if (userContext.getAuthenticationProvider().authenticateUser(credentials) == null) {
 * Copyright (C) 2015 Glyptodon LLC
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleCredentialsException;
 * @author Michael Jumper
     * Returns the credentials associated with the given request, using the
     * provided username and password.
     *
     * @param request
     *     The request to use to derive the credentials.
     *
     * @param username
     *     The username to associate with the credentials, or null if the
     *     username should be derived from the request.
     *
     * @param password
     *     The password to associate with the credentials, or null if the
     *     password should be derived from the request.
     *
     * @return
     *     A new Credentials object whose contents have been derived from the
     *     given request, along with the provided username and password.
     */
    private Credentials getCredentials(HttpServletRequest request,
            String username, String password) {

        // If no username/password given, try Authorization header
        if (username == null && password == null) {

            String authorization = request.getHeader("Authorization");
            if (authorization != null && authorization.startsWith("Basic ")) {

                try {

                    // Decode base64 authorization
                    String basicBase64 = authorization.substring(6);
                    String basicCredentials = new String(DatatypeConverter.parseBase64Binary(basicBase64), "UTF-8");

                    // Pull username/password from auth data
                    int colon = basicCredentials.indexOf(':');
                    if (colon != -1) {
                        username = basicCredentials.substring(0, colon);
                        password = basicCredentials.substring(colon  1);
                    }
                    else
                        logger.debug("Invalid HTTP Basic \"Authorization\" header received.");

                }

                // UTF-8 support is required by the Java specification
                catch (UnsupportedEncodingException e) {
                    throw new UnsupportedOperationException("Unexpected lack of UTF-8 support.", e);
                }

            }

        } // end Authorization header fallback

        // Build credentials
        Credentials credentials = new Credentials();
        credentials.setUsername(username);
        credentials.setPassword(password);
        credentials.setRequest(request);
        credentials.setSession(request.getSession(true));

        return credentials;

    }

    /**
     * Attempts authentication against all AuthenticationProviders, in order,
     * using the provided credentials. The first authentication failure takes
     * priority, but remaining AuthenticationProviders are attempted. If any
     * AuthenticationProvider succeeds, the resulting AuthenticatedUser is
     * returned, and no further AuthenticationProviders are tried.
     *
     * @param credentials
     *     The credentials to use for authentication.
     *
     * @return
     *     The AuthenticatedUser given by the highest-priority
     *     AuthenticationProvider for which the given credentials are valid.
     *
     * @throws GuacamoleException
     *     If the given credentials are not valid for any
     *     AuthenticationProvider, or if an error occurs while authenticating
     *     the user.
     */
    private AuthenticatedUser authenticateUser(Credentials credentials)
        throws GuacamoleException {

        GuacamoleCredentialsException authFailure = null;

        // Attempt authentication against each AuthenticationProvider
        for (AuthenticationProvider authProvider : authProviders) {

            // Attempt authentication
            try {
                AuthenticatedUser authenticatedUser = authProvider.authenticateUser(credentials);
                if (authenticatedUser != null)
                    return authenticatedUser;
            }

            // First failure takes priority for now
            catch (GuacamoleCredentialsException e) {
                if (authFailure == null)
                    authFailure = e;
            }

        }

        // If a specific failure occured, rethrow that
        if (authFailure != null)
            throw authFailure;

        // Otherwise, request standard username/password
        throw new GuacamoleInvalidCredentialsException(
            "Permission Denied.",
            CredentialsInfo.USERNAME_PASSWORD
        );

    }

    /**
     * Re-authenticates the given AuthenticatedUser against the
     * AuthenticationProvider that originally created it, using the given
     * Credentials.
     *
     * @param authenticatedUser
     *     The AuthenticatedUser to re-authenticate.
     *
     * @param credentials
     *     The Credentials to use to re-authenticate the user.
     *
     * @return
     *     A AuthenticatedUser which may have been updated due to re-
     *     authentication.
     *
     * @throws GuacamoleException
     *     If an error prevents the user from being re-authenticated.
     */
    private AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // Get original AuthenticationProvider
        AuthenticationProvider authProvider = authenticatedUser.getAuthenticationProvider();

        // Re-authenticate the AuthenticatedUser against the original AuthenticationProvider only
        authenticatedUser = authProvider.updateAuthenticatedUser(authenticatedUser, credentials);
        if (authenticatedUser == null)
            throw new GuacamoleSecurityException("User re-authentication failed.");

        return authenticatedUser;

    }

    /**
     * Returns the AuthenticatedUser associated with the given session and
     * credentials, performing a fresh authentication and creating a new
     * AuthenticatedUser if necessary.
     *
     * @param existingSession
     *     The current GuacamoleSession, or null if no session exists yet.
     *
     * @param credentials
     *     The Credentials to use to authenticate the user.
     *
     * @return
     *     The AuthenticatedUser associated with the given session and
     *     credentials.
     *
     * @throws GuacamoleException
     *     If an error occurs while authenticating or re-authenticating the
     *     user.
     */
    private AuthenticatedUser getAuthenticatedUser(GuacamoleSession existingSession,
            Credentials credentials) throws GuacamoleException {

        try {

            // Re-authenticate user if session exists
            if (existingSession != null)
                return updateAuthenticatedUser(existingSession.getAuthenticatedUser(), credentials);

            // Otherwise, attempt authentication as a new user
            AuthenticatedUser authenticatedUser = authenticateUser(credentials);
            if (logger.isInfoEnabled())
                logger.info("User \"{}\" successfully authenticated from {}.",
                        authenticatedUser.getIdentifier(),
                        getLoggableAddress(credentials.getRequest()));

            return authenticatedUser;

        }

        // Log and rethrow any authentication errors
        catch (GuacamoleException e) {

            // Get request and username for sake of logging
            HttpServletRequest request = credentials.getRequest();
            String username = credentials.getUsername();

            // Log authentication failures with associated usernames
            if (username != null) {
                if (logger.isWarnEnabled())
                    logger.warn("Authentication attempt from {} for user \"{}\" failed.",
                            getLoggableAddress(request), username);
            }

            // Log anonymous authentication failures
            else if (logger.isDebugEnabled())
                logger.debug("Anonymous authentication attempt from {} failed.",
                        getLoggableAddress(request));

            // Rethrow exception
            throw e;

        }

    }

    /**
     * Returns all UserContexts associated with the given AuthenticatedUser,
     * updating existing UserContexts, if any. If no UserContexts are yet
     * associated with the given AuthenticatedUser, new UserContexts are
     * generated by polling each available AuthenticationProvider.
     *
     * @param existingSession
     *     The current GuacamoleSession, or null if no session exists yet.
     *
     * @param authenticatedUser
     *     The AuthenticatedUser that has successfully authenticated or re-
     *     authenticated.
     *
     * @return
     *     A List of all UserContexts associated with the given
     *     AuthenticatedUser.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating or updating any UserContext.
     */
    private List<UserContext> getUserContexts(GuacamoleSession existingSession,
            AuthenticatedUser authenticatedUser) throws GuacamoleException {

        List<UserContext> userContexts = new ArrayList<UserContext>(authProviders.size());

        // If UserContexts already exist, update them and add to the list
        if (existingSession != null) {

            // Update all old user contexts
            List<UserContext> oldUserContexts = existingSession.getUserContexts();
            for (UserContext oldUserContext : oldUserContexts) {

                // Update existing UserContext
                AuthenticationProvider authProvider = oldUserContext.getAuthenticationProvider();
                UserContext userContext = authProvider.updateUserContext(oldUserContext, authenticatedUser);

                // Add to available data, if successful
                if (userContext != null)
                    userContexts.add(userContext);

                // If unsuccessful, log that this happened, as it may be a bug
                else
                    logger.debug("AuthenticationProvider \"{}\" retroactively destroyed its UserContext.",
                            authProvider.getClass().getName());

            }

        }

        // Otherwise, create new UserContexts from available AuthenticationProviders
        else {

            // Get UserContexts from each available AuthenticationProvider
            for (AuthenticationProvider authProvider : authProviders) {

                // Generate new UserContext
                UserContext userContext = authProvider.getUserContext(authenticatedUser);

                // Add to available data, if successful
                if (userContext != null)
                    userContexts.add(userContext);

            }

        }

        return userContexts;

    }

    /**
     *

        // Build credentials from request
        Credentials credentials = getCredentials(request, username, password);
        // Get up-to-date AuthenticatedUser and associated UserContexts
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(existingSession, credentials);
        List<UserContext> userContexts = getUserContexts(existingSession, authenticatedUser);
            logger.debug("Login was successful for user \"{}\".", authenticatedUser.getIdentifier());

        // Return possibly-new auth token
import org.glyptodon.guacamole.net.basic.xml.usermapping.UserMappingTagHandler;
    private final Logger logger = LoggerFactory.getLogger(BasicFileAuthenticationProvider.class);
     * The time the user mapping file was last modified. If the file has never
     * been read, and thus no modification time exists, this will be
     * Long.MIN_VALUE.
    private long lastModified = Long.MIN_VALUE;
    private UserMapping cachedUserMapping;
     * @return
     *     A UserMapping containing all authorization data within the user
     *     mapping XML file, or null if the file cannot be found/parsed.
    private UserMapping getUserMapping() {
        File userMappingFile;
        try {
            userMappingFile = environment.getProperty(BASIC_USER_MAPPING);
            if (userMappingFile == null)
                userMappingFile = new File(environment.getGuacamoleHome(), DEFAULT_USER_MAPPING);
        }
        // Abort if property cannot be parsed
        catch (GuacamoleException e) {
            logger.warn("Unable to read user mapping filename from properties: {}", e.getMessage());
            logger.debug("Error parsing user mapping property.", e);
            return null;
        }
        // Abort if user mapping does not exist
        if (!userMappingFile.exists()) {
            logger.debug("User mapping file \"{}\" does not exist and will not be read.", userMappingFile);
            return null;
        }

        // Refresh user mapping if file has changed
        if (lastModified < userMappingFile.lastModified()) {

            logger.debug("Reading user mapping file: \"{}\"", userMappingFile);
                InputStream input = new BufferedInputStream(new FileInputStream(userMappingFile));
                lastModified = userMappingFile.lastModified();
                cachedUserMapping = userMappingHandler.asUserMapping();

            // If the file is unreadable, return no mapping
                logger.warn("Unable to read user mapping file \"{}\": {}", userMappingFile, e.getMessage());
                logger.debug("Error reading user mapping file.", e);
                return null;

            // If the file cannot be parsed, return no mapping
                logger.warn("User mapping file \"{}\" is not valid: {}", userMappingFile, e.getMessage());
                logger.debug("Error parsing user mapping file.", e);
                return null;
        return cachedUserMapping;
        // Abort authorization if no user mapping exists
        UserMapping userMapping = getUserMapping();
        if (userMapping == null)
            return null;

 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/usermapping/AuthorizeTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.usermapping;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/usermapping/ConnectionTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.usermapping;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/usermapping/ParamTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.usermapping;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/usermapping/ProtocolTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.usermapping;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/usermapping/UserMappingTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.usermapping;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/usermapping/package-info.java
package org.glyptodon.guacamole.net.basic.xml.usermapping;
    public String getIdentifier() {
        return "mysql";
    }

    @Override
    public String getIdentifier() {
        return "postgresql";
    }

    @Override
    @Override
    public String getIdentifier() {
        return "ldap";
    }

    @Override
    public String getIdentifier() {
        return "noauth";
    }

     * Returns the identifier which uniquely and consistently identifies this
     * AuthenticationProvider implementation. This identifier may not be null
     * and must be unique across all AuthenticationProviders loaded by the
     * Guacamole web application.
     *
     * @return
     *     The unique identifier assigned to this AuthenticationProvider, which
     *     may not be null.
     */
    String getIdentifier();

    /**
    @Override
    public String getIdentifier() {
        return "default";
    }

import java.util.UUID;
     * The identifier to provide for the underlying authentication provider if
     * the authentication provider could not be loaded.
     */
    private final String facadeIdentifier = UUID.randomUUID().toString();

    /**
    public String getIdentifier() {

        // Ignore auth attempts if no auth provider could be loaded
        if (authProvider == null) {
            logger.warn("The authentication system could not be loaded. Please check for errors earlier in the logs.");
            return facadeIdentifier;
        }

        // Delegate to underlying auth provider
        return authProvider.getIdentifier();

    }

    @Override
 * Copyright (C) 2015 Glyptodon LLC
     * @param identifier
     *     The unique identifier of the AuthenticationProvider that created the
     *     UserContext being retrieved. Only one UserContext per
     *     AuthenticationProvider can exist.
     *     The UserContext that was created by the AuthenticationProvider
     *     having the given identifier.
     *     If an error occurs while retrieving the UserContext, or if the
     *     UserContext does not exist.
            String identifier) throws GuacamoleException {
        // Locate and return the UserContext associated with the
        // AuthenticationProvider having the given identifier, if any
        for (UserContext userContext : userContexts) {
            if (userContext.getAuthenticationProvider().getIdentifier().equals(identifier))
                return userContext;
        }
        throw new GuacamoleResourceNotFoundException("Session not associated with authentication provider \""  identifier  "\".");
     * @return
     *     An authentication response object containing the possible-new auth
     *     token, as well as other related data.
     *
     * @throws GuacamoleException
     *     If an error prevents successful authentication.
    public APIAuthenticationResult createToken(@FormParam("username") String username,
        // Build list of all available auth providers
        List<String> authProviderIdentifiers = new ArrayList<String>(userContexts.size());
        for (UserContext userContext : userContexts)
            authProviderIdentifiers.add(userContext.getAuthenticationProvider().getIdentifier());

        return new APIAuthenticationResult(
            authToken,
            authenticatedUser.getIdentifier(),
            authenticatedUser.getAuthenticationProvider().getIdentifier(),
            authProviderIdentifiers
        );
            logger.warn("The guacamole.properties file within GUACAMOLE_HOME cannot be read: {}", e.getMessage());
            logger.debug("Error reading guacamole.properties.", e);
    private Map<String, ProtocolInfo> readProtocols() {
     * database.
     *     The ModeledUser which corresponds to the given AuthenticatedUser, or
     *     null if no such user exists.
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
     * The AuthenticationProvider which is using this module to configure
     * injection.
     */
    private final AuthenticationProvider authProvider;

    /**
     * @param authProvider
     *     The AuthenticationProvider which is using this module to configure
     *     injection.
     *
    public JDBCAuthenticationProviderModule(AuthenticationProvider authProvider,
            Environment environment,
        this.authProvider = authProvider;
        bind(AuthenticationProvider.class).toInstance(authProvider);
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
public class AuthenticatedUser implements org.glyptodon.guacamole.net.auth.AuthenticatedUser {
     * The AuthenticationProvider that authenticated this user.
     */
    private final AuthenticationProvider authenticationProvider;

    /**
     * @param authenticationProvider
     *     The AuthenticationProvider that has authenticated the given user.
     *
    public AuthenticatedUser(AuthenticationProvider authenticationProvider,
            ModeledUser user, Credentials credentials) {
        this.authenticationProvider = authenticationProvider;
    @Override
    @Override
    public AuthenticationProvider getAuthenticationProvider() {
        return authenticationProvider;
    }

    @Override
    public String getIdentifier() {
        return user.getIdentifier();
    }

    @Override
    public void setIdentifier(String identifier) {
        user.setIdentifier(identifier);
    }

import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
     * The AuthenticationProvider that created this UserContext.
     */
    @Inject
    private AuthenticationProvider authProvider;

    /**
    public AuthenticationProvider getAuthenticationProvider() {
        return authProvider;
    }

    @Override
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
     * @param authenticationProvider
     *     The AuthenticationProvider on behalf of which the user is being
     *     retrieved.
     *
     *     An AuthenticatedUser containing the existing ModeledUser object if
     *     the credentials given are valid, null otherwise.
    public AuthenticatedUser retrieveAuthenticatedUser(AuthenticationProvider authenticationProvider,
            Credentials credentials) throws GuacamoleException {
        user.setCurrentUser(new AuthenticatedUser(authenticationProvider, user, credentials));
        return user.getCurrentUser();

    }

    /**
     * Retrieves the user corresponding to the given AuthenticatedUser from the
     * database.
     *
     * @param authenticatedUser
     *     The AuthenticatedUser to retrieve the corresponding ModeledUser of.
     *
     * @return
     *     The ModeledUser which corresponds to the given AuthenticatedUser, or
     *     null if no such user exists.
     */
    public ModeledUser retrieveUser(org.glyptodon.guacamole.net.auth.AuthenticatedUser authenticatedUser) {

        // If we already queried this user, return that rather than querying again
        if (authenticatedUser instanceof AuthenticatedUser)
            return ((AuthenticatedUser) authenticatedUser).getUser();

        // Get username
        String username = authenticatedUser.getIdentifier();

        // Retrieve corresponding user model, if such a user exists
        UserModel userModel = userMapper.selectOne(username);
        if (userModel == null)
            return null;

        // Create corresponding user object, set up cyclic reference
        ModeledUser user = getObjectInstance(null, userModel);
        user.setCurrentUser(new AuthenticatedUser(authenticatedUser.getAuthenticationProvider(), user, authenticatedUser.getCredentials()));

        // Return already-authenticated user
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticationProviderService;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
            new JDBCAuthenticationProviderModule(this, environment,
                    getTunnelService(environment))
    public String getIdentifier() {
        return "mysql";
    }

    @Override
    public AuthenticatedUser authenticateUser(Credentials credentials)
            throws GuacamoleException {

        // Create AuthenticatedUser based on credentials, if valid
        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.authenticateUser(this, credentials);

    }

    @Override
    public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // No need to update authenticated users
        return authenticatedUser;

    }

    @Override
    public UserContext getUserContext(AuthenticatedUser authenticatedUser)
        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.getUserContext(authenticatedUser);
            AuthenticatedUser authenticatedUser) throws GuacamoleException {
import org.glyptodon.guacamole.auth.jdbc.user.AuthenticationProviderService;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
            new JDBCAuthenticationProviderModule(this, environment,
                    getTunnelService(environment))
    public String getIdentifier() {
        return "postgresql";
    }

    @Override
    public AuthenticatedUser authenticateUser(Credentials credentials)
            throws GuacamoleException {

        // Create AuthenticatedUser based on credentials, if valid
        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.authenticateUser(this, credentials);

    }

    @Override
    public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // No need to update authenticated users
        return authenticatedUser;

    }

    @Override
    public UserContext getUserContext(AuthenticatedUser authenticatedUser)
        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.getUserContext(authenticatedUser);
            AuthenticatedUser authenticatedUser) throws GuacamoleException {
    @Override
    public String getIdentifier() {
        return "ldap";
    }

    @Override
    public String getIdentifier() {
        return "noauth";
    }

            logger.warn("The guacamole.properties file within GUACAMOLE_HOME cannot be read: {}", e.getMessage());
            logger.debug("Error reading guacamole.properties.", e);
    private Map<String, ProtocolInfo> readProtocols() {
 * Copyright (C) 2015 Glyptodon LLC
 * Provides means of authorizing users and for accessing and managing data
 * associated with those users. Access to such data is limited according to the
 * AuthenticationProvider implementation.
     * Returns the identifier which uniquely and consistently identifies this
     * AuthenticationProvider implementation. This identifier may not be null
     * and must be unique across all AuthenticationProviders loaded by the
     * Guacamole web application.
     * @return
     *     The unique identifier assigned to this AuthenticationProvider, which
     *     may not be null.
    String getIdentifier();

    /**
     * Returns an AuthenticatedUser representing the user authenticated by the
     * given credentials, if any.
     *
     * @param credentials
     *     The credentials to use for authentication.
     *
     * @return
     *     An AuthenticatedUser representing the user authenticated by the
     *     given credentials, if any, or null if the credentials are invalid.
     *
     * @throws GuacamoleException
     *     If an error occurs while authenticating the user, or if access is
     *     temporarily, permanently, or conditionally denied, such as if the
     *     supplied credentials are insufficient or invalid.
     */
    AuthenticatedUser authenticateUser(Credentials credentials)
     * Returns a new or updated AuthenticatedUser for the given credentials
     * already having produced the given AuthenticatedUser. Note that because
     * this function will be called for all future requests after initial
     * authentication, including tunnel requests, care must be taken to avoid
     * using functions of HttpServletRequest which invalidate the entire request
     * body, such as getParameter(). Doing otherwise may cause the
     * GuacamoleHTTPTunnelServlet to fail.
      *
     * @param credentials
     *     The credentials to use for authentication.
     *
     * @param authenticatedUser
     *     An AuthenticatedUser object representing the user authenticated by
     *     an arbitrary set of credentials. The AuthenticatedUser may come from
     *     this AuthenticationProvider or any other installed
     *     AuthenticationProvider.
     *
     * @return
     *     An updated AuthenticatedUser representing the user authenticated by
     *     the given credentials, if any, or null if the credentials are
     *     invalid.
     *
     * @throws GuacamoleException
     *     If an error occurs while updating the AuthenticatedUser.
    AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException;

    /**
     * Returns the UserContext of the user authenticated by the given
     * credentials.
     *
     * @param authenticatedUser
     *     An AuthenticatedUser object representing the user authenticated by
     *     an arbitrary set of credentials. The AuthenticatedUser may come from
     *     this AuthenticationProvider or any other installed
     *     AuthenticationProvider.
     *
     * @return
     *     A UserContext describing the permissions, connection, connection
     *     groups, etc. accessible or associated with the given authenticated
     *     user, or null if this AuthenticationProvider refuses to provide any
     *     such data.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the UserContext.
     */
    UserContext getUserContext(AuthenticatedUser authenticatedUser)

    /**
     * Returns a new or updated UserContext for the given AuthenticatedUser
     * already having the given UserContext. Note that because this function
     * will be called for all future requests after initial authentication,
     * including tunnel requests, care must be taken to avoid using functions
     * of HttpServletRequest which invalidate the entire request body, such as
     * getParameter(). Doing otherwise may cause the GuacamoleHTTPTunnelServlet
     * to fail.
      *
     * @param context
     *     The existing UserContext belonging to the user in question.
     *
     * @param authenticatedUser
     *     An AuthenticatedUser object representing the user authenticated by
     *     an arbitrary set of credentials. The AuthenticatedUser may come from
     *     this AuthenticationProvider or any other installed
     *     AuthenticationProvider.
     *
     * @return
     *     An updated UserContext describing the permissions, connection,
     *     connection groups, etc. accessible or associated with the given
     *     authenticated user, or null if this AuthenticationProvider refuses
     *     to provide any such data.
     *
     * @throws GuacamoleException
     *     If an error occurs while updating the UserContext.
     */
    UserContext updateUserContext(UserContext context,
            AuthenticatedUser authenticatedUser) throws GuacamoleException;
     * Returns the AuthenticationProvider which created this UserContext, which
     * may not be the same AuthenticationProvider that authenticated the user
     * associated with this UserContext.
     *
     * @return
     *     The AuthenticationProvider that created this UserContext.
     */
    AuthenticationProvider getAuthenticationProvider();

    /**
import java.util.UUID;
import org.glyptodon.guacamole.net.auth.AbstractAuthenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
    /**
     * AuthenticatedUser which contains its own predefined set of authorized
     * configurations.
     *
     * @author Michael Jumper
     */
    private class SimpleAuthenticatedUser extends AbstractAuthenticatedUser {
        /**
         * The credentials provided when this AuthenticatedUser was
         * authenticated.
         */
        private final Credentials credentials;

        /**
         * The GuacamoleConfigurations that this AuthenticatedUser is
         * authorized to use.
         */
        private final Map<String, GuacamoleConfiguration> configs;

        /**
         * Creates a new SimpleAuthenticatedUser associated with the given
         * credentials and having access to the given Map of
         * GuacamoleConfigurations.
         *
         * @param credentials
         *     The credentials provided by the user when they authenticated.
         *
         * @param configs
         *     A Map of all GuacamoleConfigurations for which this user has
         *     access. The keys of this Map are Strings which uniquely identify
         *     each configuration.
         */
        public SimpleAuthenticatedUser(Credentials credentials, Map<String, GuacamoleConfiguration> configs) {

            // Store credentials and configurations
            this.credentials = credentials;
            this.configs = configs;

            // Pull username from credentials if it exists
            String username = credentials.getUsername();
            if (username != null && !username.isEmpty())
                setIdentifier(username);

            // Otherwise generate a random username
            else
                setIdentifier(UUID.randomUUID().toString());

        }

        /**
         * Returns a Map containing all GuacamoleConfigurations that this user
         * is authorized to use. The keys of this Map are Strings which
         * uniquely identify each configuration.
         *
         * @return
         *     A Map of all configurations for which this user is authorized.
         */
        public Map<String, GuacamoleConfiguration> getAuthorizedConfigurations() {
            return configs;
        }

        @Override
        public AuthenticationProvider getAuthenticationProvider() {
            return SimpleAuthenticationProvider.this;
        }

        @Override
        public Credentials getCredentials() {
            return credentials;
        }

    }

    /**
     * Given an arbitrary credentials object, returns a Map containing all
     * configurations authorized by those credentials, filtering those
     * configurations using a TokenFilter and the standard credential tokens
     * (like ${GUAC_USERNAME} and ${GUAC_PASSWORD}). The keys of this Map
     * are Strings which uniquely identify each configuration.
     *
     * @param credentials
     *     The credentials to use to retrieve authorized configurations.
     *
     * @return
     *     A Map of all configurations authorized by the given credentials, or
     *     null if the credentials given are not authorized.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving configurations.
     */
    private Map<String, GuacamoleConfiguration>
            getFilteredAuthorizedConfigurations(Credentials credentials)
            throws GuacamoleException {

        return configs;

    }

    /**
     * Given a user who has already been authenticated, returns a Map
     * containing all configurations for which that user is authorized,
     * filtering those configurations using a TokenFilter and the standard
     * credential tokens (like ${GUAC_USERNAME} and ${GUAC_PASSWORD}). The keys
     * of this Map are Strings which uniquely identify each configuration.
     *
     * @param authenticatedUser
     *     The user whose authorized configurations are to be retrieved.
     *
     * @return
     *     A Map of all configurations authorized for use by the given user, or
     *     null if the user is not authorized to use any configurations.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving configurations.
     */
    private Map<String, GuacamoleConfiguration>
            getFilteredAuthorizedConfigurations(AuthenticatedUser authenticatedUser)
            throws GuacamoleException {

        // Pull cached configurations, if any
        if (authenticatedUser instanceof SimpleAuthenticatedUser)
            return ((SimpleAuthenticatedUser) authenticatedUser).getAuthorizedConfigurations();

        // Otherwise, pull using credentials
        return getFilteredAuthorizedConfigurations(authenticatedUser.getCredentials());

    }

    @Override
    public AuthenticatedUser authenticateUser(final Credentials credentials)
            throws GuacamoleException {

        // Get configurations
        Map<String, GuacamoleConfiguration> configs =
                getFilteredAuthorizedConfigurations(credentials);

        // Return as unauthorized if not authorized to retrieve configs
        if (configs == null)
            return null;

        return new SimpleAuthenticatedUser(credentials, configs);

    }

    @Override
    public UserContext getUserContext(AuthenticatedUser authenticatedUser)
            throws GuacamoleException {

        // Get configurations
        Map<String, GuacamoleConfiguration> configs =
                getFilteredAuthorizedConfigurations(authenticatedUser);

        // Return as unauthorized if not authorized to retrieve configs
        if (configs == null)
            return null;

        // Return user context restricted to authorized configs
        return new SimpleUserContext(this, authenticatedUser.getIdentifier(), configs);

    }

    @Override
    public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // Simply return the given user, updating nothing
        return authenticatedUser;
        AuthenticatedUser authorizedUser) throws GuacamoleException {
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;

    /**
     * The AuthenticationProvider that created this UserContext.
     */
    private final AuthenticationProvider authProvider;

     *
     * @param authProvider
     *     The AuthenticationProvider creating this UserContext.
     *
     * @param configs
     *     A Map of all configurations for which the user associated with this
     *     UserContext has read access.
    public SimpleUserContext(AuthenticationProvider authProvider,
            Map<String, GuacamoleConfiguration> configs) {
        this(authProvider, UUID.randomUUID().toString(), configs);
     *
     * @param authProvider
     *     The AuthenticationProvider creating this UserContext.
     *
     * @param username
     *     The username of the user associated with this UserContext.
     *
     * @param configs
     *     A Map of all configurations for which the user associated with
     *     this UserContext has read access.
    public SimpleUserContext(AuthenticationProvider authProvider,
            String username, Map<String, GuacamoleConfiguration> configs) {

        // Associate provided AuthenticationProvider
        this.authProvider = authProvider;

    public AuthenticationProvider getAuthenticationProvider() {
        return authProvider;
    }

    @Override
import org.glyptodon.guacamole.net.basic.xml.usermapping.UserMappingTagHandler;
    private final Logger logger = LoggerFactory.getLogger(BasicFileAuthenticationProvider.class);
     * The time the user mapping file was last modified. If the file has never
     * been read, and thus no modification time exists, this will be
     * Long.MIN_VALUE.
    private long lastModified = Long.MIN_VALUE;
    private UserMapping cachedUserMapping;
    @Override
    public String getIdentifier() {
        return "default";
    }

     * @return
     *     A UserMapping containing all authorization data within the user
     *     mapping XML file, or null if the file cannot be found/parsed.
    private UserMapping getUserMapping() {
        File userMappingFile;
        try {
            userMappingFile = environment.getProperty(BASIC_USER_MAPPING);
            if (userMappingFile == null)
                userMappingFile = new File(environment.getGuacamoleHome(), DEFAULT_USER_MAPPING);
        }
        // Abort if property cannot be parsed
        catch (GuacamoleException e) {
            logger.warn("Unable to read user mapping filename from properties: {}", e.getMessage());
            logger.debug("Error parsing user mapping property.", e);
            return null;
        }
        // Abort if user mapping does not exist
        if (!userMappingFile.exists()) {
            logger.debug("User mapping file \"{}\" does not exist and will not be read.", userMappingFile);
            return null;
        }

        // Refresh user mapping if file has changed
        if (lastModified < userMappingFile.lastModified()) {

            logger.debug("Reading user mapping file: \"{}\"", userMappingFile);
                InputStream input = new BufferedInputStream(new FileInputStream(userMappingFile));
                lastModified = userMappingFile.lastModified();
                cachedUserMapping = userMappingHandler.asUserMapping();

            // If the file is unreadable, return no mapping
                logger.warn("Unable to read user mapping file \"{}\": {}", userMappingFile, e.getMessage());
                logger.debug("Error reading user mapping file.", e);
                return null;

            // If the file cannot be parsed, return no mapping
                logger.warn("User mapping file \"{}\" is not valid: {}", userMappingFile, e.getMessage());
                logger.debug("Error parsing user mapping file.", e);
                return null;
        return cachedUserMapping;
        // Abort authorization if no user mapping exists
        UserMapping userMapping = getUserMapping();
        if (userMapping == null)
            return null;

 * Copyright (C) 2015 Glyptodon LLC
import java.util.List;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
     * The user associated with this session.
    private AuthenticatedUser authenticatedUser;
     * All UserContexts associated with this session. Each
     * AuthenticationProvider may provide its own UserContext.
    private List<UserContext> userContexts;
     * Creates a new Guacamole session associated with the given
     * AuthenticatedUser and UserContexts.
     * @param authenticatedUser
     *     The authenticated user to associate this session with.
     * @param userContexts
     *     The List of UserContexts to associate with this session.
    public GuacamoleSession(Environment environment,
            AuthenticatedUser authenticatedUser,
            List<UserContext> userContexts)
            throws GuacamoleException {
        this.authenticatedUser = authenticatedUser;
        this.userContexts = userContexts;
     * Returns the authenticated user associated with this session.
     *     The authenticated user associated with this session.
    public AuthenticatedUser getAuthenticatedUser() {
        return authenticatedUser;
     * Replaces the authenticated user associated with this session with the
     * given authenticated user.
     * @param authenticatedUser
     *     The authenticated user to associated with this session.
    public void setAuthenticatedUser(AuthenticatedUser authenticatedUser) {
        this.authenticatedUser = authenticatedUser;


        // Warn of deprecation
        logger.debug(
            "\n****************************************************************"
           "\n"
           "\n       !!!!  PLEASE DO NOT USE getUserContext() !!!!"
           "\n"
           "\n getUserContext() has been replaced by getUserContexts(), which"
           "\n properly handles multiple authentication providers. All use of"
           "\n the old getUserContext() must be removed before GUAC-586 can"
           "\n be considered complete."
           "\n"
           "\n****************************************************************"
        );

        // Return the UserContext associated with the AuthenticationProvider
        // that authenticated the current user.
        String authProviderIdentifier = authenticatedUser.getAuthenticationProvider().getIdentifier();
        for (UserContext userContext : userContexts) {
            if (userContext.getAuthenticationProvider().getIdentifier().equals(authProviderIdentifier))
                return userContext;
        }

        // If not found, return null
        return null;

     * Returns a list of all UserContexts associated with this session. Each
     * AuthenticationProvider currently loaded by Guacamole may provide its own
     * UserContext for any successfully-authenticated user.
     * @return
     *     An unmodifiable list of all UserContexts associated with this
     *     session.
    public List<UserContext> getUserContexts() {
        return Collections.unmodifiableList(userContexts);
    }

    /**
     * Replaces all UserContexts associated with this session with the given
     * List of UserContexts.
     *
     * @param userContexts
     *     The List of UserContexts to associate with this session.
     */
    public void setUserContexts(List<UserContext> userContexts) {
        this.userContexts = userContexts;
                                session.getAuthenticatedUser().getIdentifier(), id, duration);
                                session.getAuthenticatedUser().getIdentifier(), id, duration);
import java.util.UUID;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
     * The identifier to provide for the underlying authentication provider if
     * the authentication provider could not be loaded.
     */
    private final String facadeIdentifier = UUID.randomUUID().toString();

    /**
    public String getIdentifier() {

        // Ignore auth attempts if no auth provider could be loaded
        if (authProvider == null) {
            logger.warn("The authentication system could not be loaded. Please check for errors earlier in the logs.");
            return facadeIdentifier;
        }

        // Delegate to underlying auth provider
        return authProvider.getIdentifier();

    }

    @Override
    public AuthenticatedUser authenticateUser(Credentials credentials)
        return authProvider.authenticateUser(credentials);

    public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {
        return authProvider.updateAuthenticatedUser(authenticatedUser, credentials);

    }

    @Override
    public UserContext getUserContext(AuthenticatedUser authenticatedUser)
            throws GuacamoleException {

        // Ignore auth attempts if no auth provider could be loaded
        if (authProvider == null) {
            logger.warn("User data retrieval attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs.");
            return null;
        }

        // Delegate to underlying auth provider
        return authProvider.getUserContext(authenticatedUser);
        
    }

    @Override
    public UserContext updateUserContext(UserContext context,
            AuthenticatedUser authenticatedUser)
            throws GuacamoleException {

        // Ignore auth attempts if no auth provider could be loaded
        if (authProvider == null) {
            logger.warn("User data refresh attempt denied because the authentication system could not be loaded. Please check for errors earlier in the logs.");
            return null;
        }

        // Delegate to underlying auth provider
        return authProvider.updateUserContext(context, authenticatedUser);
import com.google.inject.Provides;
     * All currently-bound authentication providers, if any.
    private final List<AuthenticationProvider> boundAuthenticationProviders =
            new ArrayList<AuthenticationProvider>();
     * injection, along with any other bound AuthenticationProviders.
        logger.debug("[{}] Binding AuthenticationProvider \"{}\".",
                boundAuthenticationProviders.size(), authenticationProvider.getName());
        boundAuthenticationProviders.add(new AuthenticationProviderFacade(authenticationProvider));
     * injection.
     * Returns a list of all currently-bound AuthenticationProvider instances.
     *
     * @return
     *     A List of all currently-bound AuthenticationProvider. The List is
     *     not modifiable.
     */
    @Provides
    public List<AuthenticationProvider> getAuthenticationProviders() {
        return Collections.unmodifiableList(boundAuthenticationProviders);
    }

    /**
        // Always bind basic auth last
        bindAuthenticationProvider(BasicFileAuthenticationProvider.class);
 * Copyright (C) 2015 Glyptodon LLC
import java.util.List;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
     * Retrieves a single UserContext from the given GuacamoleSession, which
     * may contain multiple UserContexts.
     *
     * @param session
     *     The GuacamoleSession to retrieve the UserContext from.
     *
     * @param identifier
     *     The unique identifier of the AuthenticationProvider that created the
     *     UserContext being retrieved. Only one UserContext per
     *     AuthenticationProvider can exist.
     *
     * @return
     *     The UserContext that was created by the AuthenticationProvider
     *     having the given identifier.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the UserContext, or if the
     *     UserContext does not exist.
     */
    public UserContext retrieveUserContext(GuacamoleSession session,
            String identifier) throws GuacamoleException {

        // Get list of UserContexts
        List<UserContext> userContexts = session.getUserContexts();

        // Locate and return the UserContext associated with the
        // AuthenticationProvider having the given identifier, if any
        for (UserContext userContext : userContexts) {
            if (userContext.getAuthenticationProvider().getIdentifier().equals(identifier))
                return userContext;
        }

        throw new GuacamoleResourceNotFoundException("Session not associated with authentication provider \""  identifier  "\".");

    }

    /**
import java.util.List;

    /**
     * Returns all UserContexts associated with a given auth token, if the auth
     * token represents a currently logged in user. Throws an unauthorized
     * error otherwise.
     *
     * @param authToken
     *     The auth token to check against the map of logged in users.
     *
     * @return
     *     A List of all UserContexts associated with the provided auth token.
     *
     * @throws GuacamoleException
     *     If the auth token does not correspond to any logged in user.
     */
    public List<UserContext> getUserContexts(String authToken)
            throws GuacamoleException {
        return getGuacamoleSession(authToken).getUserContexts();
    }

 * Copyright (C) 2015 Glyptodon LLC
import java.util.ArrayList;
import java.util.List;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleCredentialsException;
 * @author Michael Jumper
     * All configured authentication providers which can be used to
     * authenticate users or retrieve data associated with authenticated users.
    private List<AuthenticationProvider> authProviders;
     * Returns the credentials associated with the given request, using the
     * provided username and password.
     *
     * @param request
     *     The request to use to derive the credentials.
     *
     *     The username to associate with the credentials, or null if the
     *     username should be derived from the request.
     *     The password to associate with the credentials, or null if the
     *     password should be derived from the request.
     * @return
     *     A new Credentials object whose contents have been derived from the
     *     given request, along with the provided username and password.
    private Credentials getCredentials(HttpServletRequest request,
            String username, String password) {

        return credentials;
    }
    /**
     * Attempts authentication against all AuthenticationProviders, in order,
     * using the provided credentials. The first authentication failure takes
     * priority, but remaining AuthenticationProviders are attempted. If any
     * AuthenticationProvider succeeds, the resulting AuthenticatedUser is
     * returned, and no further AuthenticationProviders are tried.
     *
     * @param credentials
     *     The credentials to use for authentication.
     *
     * @return
     *     The AuthenticatedUser given by the highest-priority
     *     AuthenticationProvider for which the given credentials are valid.
     *
     * @throws GuacamoleException
     *     If the given credentials are not valid for any
     *     AuthenticationProvider, or if an error occurs while authenticating
     *     the user.
     */
    private AuthenticatedUser authenticateUser(Credentials credentials)
        throws GuacamoleException {
        GuacamoleCredentialsException authFailure = null;
        // Attempt authentication against each AuthenticationProvider
        for (AuthenticationProvider authProvider : authProviders) {

            // Attempt authentication
            try {
                AuthenticatedUser authenticatedUser = authProvider.authenticateUser(credentials);
                if (authenticatedUser != null)
                    return authenticatedUser;
            // First failure takes priority for now
            catch (GuacamoleCredentialsException e) {
                if (authFailure == null)
                    authFailure = e;
            }

        // If a specific failure occured, rethrow that
        if (authFailure != null)
            throw authFailure;

        // Otherwise, request standard username/password
        throw new GuacamoleInvalidCredentialsException(
            "Permission Denied.",
            CredentialsInfo.USERNAME_PASSWORD
        );

    }

    /**
     * Re-authenticates the given AuthenticatedUser against the
     * AuthenticationProvider that originally created it, using the given
     * Credentials.
     *
     * @param authenticatedUser
     *     The AuthenticatedUser to re-authenticate.
     *
     * @param credentials
     *     The Credentials to use to re-authenticate the user.
     *
     * @return
     *     A AuthenticatedUser which may have been updated due to re-
     *     authentication.
     *
     * @throws GuacamoleException
     *     If an error prevents the user from being re-authenticated.
     */
    private AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // Get original AuthenticationProvider
        AuthenticationProvider authProvider = authenticatedUser.getAuthenticationProvider();

        // Re-authenticate the AuthenticatedUser against the original AuthenticationProvider only
        authenticatedUser = authProvider.updateAuthenticatedUser(authenticatedUser, credentials);
        if (authenticatedUser == null)
            throw new GuacamoleSecurityException("User re-authentication failed.");

        return authenticatedUser;

    }

    /**
     * Returns the AuthenticatedUser associated with the given session and
     * credentials, performing a fresh authentication and creating a new
     * AuthenticatedUser if necessary.
     *
     * @param existingSession
     *     The current GuacamoleSession, or null if no session exists yet.
     *
     * @param credentials
     *     The Credentials to use to authenticate the user.
     *
     * @return
     *     The AuthenticatedUser associated with the given session and
     *     credentials.
     *
     * @throws GuacamoleException
     *     If an error occurs while authenticating or re-authenticating the
     *     user.
     */
    private AuthenticatedUser getAuthenticatedUser(GuacamoleSession existingSession,
            Credentials credentials) throws GuacamoleException {

        try {

            // Re-authenticate user if session exists
            if (existingSession != null)
                return updateAuthenticatedUser(existingSession.getAuthenticatedUser(), credentials);

            // Otherwise, attempt authentication as a new user
            AuthenticatedUser authenticatedUser = authenticateUser(credentials);
            if (logger.isInfoEnabled())
                logger.info("User \"{}\" successfully authenticated from {}.",
                        authenticatedUser.getIdentifier(),
                        getLoggableAddress(credentials.getRequest()));

            return authenticatedUser;

        }

        // Log and rethrow any authentication errors
            // Get request and username for sake of logging
            HttpServletRequest request = credentials.getRequest();
            String username = credentials.getUsername();

                        getLoggableAddress(request));
            // Rethrow exception


    }

    /**
     * Returns all UserContexts associated with the given AuthenticatedUser,
     * updating existing UserContexts, if any. If no UserContexts are yet
     * associated with the given AuthenticatedUser, new UserContexts are
     * generated by polling each available AuthenticationProvider.
     *
     * @param existingSession
     *     The current GuacamoleSession, or null if no session exists yet.
     *
     * @param authenticatedUser
     *     The AuthenticatedUser that has successfully authenticated or re-
     *     authenticated.
     *
     * @return
     *     A List of all UserContexts associated with the given
     *     AuthenticatedUser.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating or updating any UserContext.
     */
    private List<UserContext> getUserContexts(GuacamoleSession existingSession,
            AuthenticatedUser authenticatedUser) throws GuacamoleException {

        List<UserContext> userContexts = new ArrayList<UserContext>(authProviders.size());

        // If UserContexts already exist, update them and add to the list
        if (existingSession != null) {

            // Update all old user contexts
            List<UserContext> oldUserContexts = existingSession.getUserContexts();
            for (UserContext oldUserContext : oldUserContexts) {

                // Update existing UserContext
                AuthenticationProvider authProvider = oldUserContext.getAuthenticationProvider();
                UserContext userContext = authProvider.updateUserContext(oldUserContext, authenticatedUser);

                // Add to available data, if successful
                if (userContext != null)
                    userContexts.add(userContext);

                // If unsuccessful, log that this happened, as it may be a bug
                else
                    logger.debug("AuthenticationProvider \"{}\" retroactively destroyed its UserContext.",
                            authProvider.getClass().getName());

            }

        }

        // Otherwise, create new UserContexts from available AuthenticationProviders
        else {

            // Get UserContexts from each available AuthenticationProvider
            for (AuthenticationProvider authProvider : authProviders) {

                // Generate new UserContext
                UserContext userContext = authProvider.getUserContext(authenticatedUser);

                // Add to available data, if successful
                if (userContext != null)
                    userContexts.add(userContext);

            }

        }

        return userContexts;

    }

    /**
     * Authenticates a user, generates an auth token, associates that auth token
     * with the user's UserContext for use by further requests. If an existing
     * token is provided, the authentication procedure will attempt to update
     * or reuse the provided token.
     *
     * @param username
     *     The username of the user who is to be authenticated.
     *
     * @param password
     *     The password of the user who is to be authenticated.
     *
     * @param token
     *     An optional existing auth token for the user who is to be
     *     authenticated.
     *
     * @param consumedRequest
     *     The HttpServletRequest associated with the login attempt. The
     *     parameters of this request may not be accessible, as the request may
     *     have been fully consumed by JAX-RS.
     *
     * @param parameters
     *     A MultivaluedMap containing all parameters from the given HTTP
     *     request. All request parameters must be made available through this
     *     map, even if those parameters are no longer accessible within the
     *     now-fully-consumed HTTP request.
     *
     * @return
     *     An authentication response object containing the possible-new auth
     *     token, as well as other related data.
     *
     * @throws GuacamoleException
     *     If an error prevents successful authentication.
     */
    @POST
    @AuthProviderRESTExposure
    public APIAuthenticationResult createToken(@FormParam("username") String username,
            @FormParam("password") String password,
            @FormParam("token") String token,
            @Context HttpServletRequest consumedRequest,
            MultivaluedMap<String, String> parameters)
            throws GuacamoleException {

        // Reconstitute the HTTP request with the map of parameters
        HttpServletRequest request = new APIRequest(consumedRequest, parameters);

        // Pull existing session if token provided
        GuacamoleSession existingSession;
        if (token != null)
            existingSession = tokenSessionMap.get(token);
        else
            existingSession = null;

        // Build credentials from request
        Credentials credentials = getCredentials(request, username, password);

        // Get up-to-date AuthenticatedUser and associated UserContexts
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(existingSession, credentials);
        List<UserContext> userContexts = getUserContexts(existingSession, authenticatedUser);

            existingSession.setAuthenticatedUser(authenticatedUser);
            existingSession.setUserContexts(userContexts);
            tokenSessionMap.put(authToken, new GuacamoleSession(environment, authenticatedUser, userContexts));
            logger.debug("Login was successful for user \"{}\".", authenticatedUser.getIdentifier());

        // Build list of all available auth providers
        List<String> authProviderIdentifiers = new ArrayList<String>(userContexts.size());
        for (UserContext userContext : userContexts)
            authProviderIdentifiers.add(userContext.getAuthenticationProvider().getIdentifier());

        // Return possibly-new auth token
        return new APIAuthenticationResult(
            authToken,
            authenticatedUser.getIdentifier(),
            authenticatedUser.getAuthenticationProvider().getIdentifier(),
            authProviderIdentifiers
        );
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleCredentialsException;
        // Verify that the old password was correct
        try {
            if (userContext.getAuthenticationProvider().authenticateUser(credentials) == null) {
                throw new APIException(APIError.Type.PERMISSION_DENIED,
                        "Permission denied.");
            }
        }

        // Pass through any credentials exceptions as simple permission denied
        catch (GuacamoleCredentialsException e) {
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/usermapping/AuthorizeTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.usermapping;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/usermapping/ConnectionTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.usermapping;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/usermapping/ParamTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.usermapping;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/usermapping/ProtocolTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.usermapping;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/usermapping/UserMappingTagHandler.java
package org.glyptodon.guacamole.net.basic.xml.usermapping;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/xml/usermapping/package-info.java
package org.glyptodon.guacamole.net.basic.xml.usermapping;
 * Copyright (C) 2015 Glyptodon LLC
import org.glyptodon.guacamole.auth.ldap.AuthenticationProviderService;
import org.glyptodon.guacamole.auth.ldap.LDAPAuthenticationProviderModule;
import com.google.inject.Guice;
import com.google.inject.Injector;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.UserContext;
public class LDAPAuthenticationProvider implements AuthenticationProvider {
     * Injector which will manage the object graph of this authentication
     * provider.
    private final Injector injector;

        // Set up Guice injector.
        injector = Guice.createInjector(
            new LDAPAuthenticationProviderModule(this)
        );

    @Override
    public AuthenticatedUser authenticateUser(Credentials credentials) throws GuacamoleException {

        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.authenticateUser(credentials);

    @Override
    public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {
        return authenticatedUser;
    }
    public UserContext getUserContext(AuthenticatedUser authenticatedUser)
            throws GuacamoleException {
        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.getUserContext(authenticatedUser);
    }
    @Override
    public UserContext updateUserContext(UserContext context,
            AuthenticatedUser authenticatedUser) throws GuacamoleException {
        return context;
 b/extensions/guacamole-auth-ldap/src/main/java/org/glyptodon/guacamole/auth/ldap/LDAPGuacamoleProperties.java
package org.glyptodon.guacamole.auth.ldap;
 * Copyright (C) 2015 Glyptodon LLC
    private final Set<ObjectPermission> userPermissions =
            new HashSet<ObjectPermission>();

    /**
     * All connection permissions granted to this user.
     */
     * Creates a new SimpleUser having the given username and no permissions.
     *
     * @param username
     *     The username to assign to this SimpleUser.
     */
    public SimpleUser(String username) {

        // Set username
        setIdentifier(username);

    }

    /**
     *
        this(username);
    /**
     * Creates a new SimpleUser having the given username and READ access to
     * the users, connections, and groups having the given identifiers.
     *
     * @param username
     *     The username to assign to this SimpleUser.
     *
     * @param userIdentifiers
     *     The identifiers of all users this user has READ access to.
     *
     * @param connectionIdentifiers
     *     The identifiers of all connections this user has READ access to.
     *
     * @param connectionGroupIdentifiers
     *     The identifiers of all connection groups this user has READ access
     *     to.
     */
    public SimpleUser(String username,
            Collection<String> userIdentifiers,
            Collection<String> connectionIdentifiers,
            Collection<String> connectionGroupIdentifiers) {

        this(username);

        // Add permissions
        addReadPermissions(userPermissions,            userIdentifiers);
        addReadPermissions(connectionPermissions,      connectionIdentifiers);
        addReadPermissions(connectionGroupPermissions, connectionGroupIdentifiers);

    }

        return new SimpleObjectPermissionSet(userPermissions);
     * The identifier reserved for the root connection group.
     */
    public static final String ROOT_CONNECTION_GROUP = "ROOT";

    /**
import net.sourceforge.guacamole.net.auth.ldap.LDAPAuthenticationProvider;
                Connection connection = new SimpleConnection(name, name, config);
                connection.setParentIdentifier(LDAPAuthenticationProvider.ROOT_CONNECTION_GROUP);
                connections.put(name, connection);
import net.sourceforge.guacamole.net.auth.ldap.LDAPAuthenticationProvider;
            LDAPAuthenticationProvider.ROOT_CONNECTION_GROUP,
            LDAPAuthenticationProvider.ROOT_CONNECTION_GROUP,
 * Copyright (C) 2015 Glyptodon LLC
import org.glyptodon.guacamole.auth.ldap.AuthenticationProviderService;
import org.glyptodon.guacamole.auth.ldap.LDAPAuthenticationProviderModule;
import com.google.inject.Guice;
import com.google.inject.Injector;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.UserContext;
public class LDAPAuthenticationProvider implements AuthenticationProvider {
     * The identifier reserved for the root connection group.
    public static final String ROOT_CONNECTION_GROUP = "ROOT";
     * Injector which will manage the object graph of this authentication
     * provider.
    private final Injector injector;

        // Set up Guice injector.
        injector = Guice.createInjector(
            new LDAPAuthenticationProviderModule(this)
        );

    @Override
    public AuthenticatedUser authenticateUser(Credentials credentials) throws GuacamoleException {

        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.authenticateUser(credentials);

    @Override
    public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {
        return authenticatedUser;
    }
    public UserContext getUserContext(AuthenticatedUser authenticatedUser)
            throws GuacamoleException {
        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.getUserContext(authenticatedUser);
    }
    @Override
    public UserContext updateUserContext(UserContext context,
            AuthenticatedUser authenticatedUser) throws GuacamoleException {
        return context;
 b/extensions/guacamole-auth-ldap/src/main/java/org/glyptodon/guacamole/auth/ldap/LDAPGuacamoleProperties.java
package org.glyptodon.guacamole.auth.ldap;
 * Copyright (C) 2015 Glyptodon LLC
    private final Set<ObjectPermission> userPermissions =
            new HashSet<ObjectPermission>();

    /**
     * All connection permissions granted to this user.
     */
     * Creates a new SimpleUser having the given username and no permissions.
     *
     * @param username
     *     The username to assign to this SimpleUser.
     */
    public SimpleUser(String username) {

        // Set username
        setIdentifier(username);

    }

    /**
     *
        this(username);
    /**
     * Creates a new SimpleUser having the given username and READ access to
     * the users, connections, and groups having the given identifiers.
     *
     * @param username
     *     The username to assign to this SimpleUser.
     *
     * @param userIdentifiers
     *     The identifiers of all users this user has READ access to.
     *
     * @param connectionIdentifiers
     *     The identifiers of all connections this user has READ access to.
     *
     * @param connectionGroupIdentifiers
     *     The identifiers of all connection groups this user has READ access
     *     to.
     */
    public SimpleUser(String username,
            Collection<String> userIdentifiers,
            Collection<String> connectionIdentifiers,
            Collection<String> connectionGroupIdentifiers) {

        this(username);

        // Add permissions
        addReadPermissions(userPermissions,            userIdentifiers);
        addReadPermissions(connectionPermissions,      connectionIdentifiers);
        addReadPermissions(connectionGroupPermissions, connectionGroupIdentifiers);

    }

        return new SimpleObjectPermissionSet(userPermissions);
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
     * @param authProviderIdentifier
            String authProviderIdentifier) throws GuacamoleException {

            // Get AuthenticationProvider associated with current UserContext
            AuthenticationProvider authProvider = userContext.getAuthenticationProvider();

            // If AuthenticationProvider identifier matches, done
            if (authProvider.getIdentifier().equals(authProviderIdentifier))

        throw new GuacamoleResourceNotFoundException("Session not associated with authentication provider \""  authProviderIdentifier  "\".");
     * Retrieves a single user from the given GuacamoleSession.
     *
     * @param session
     *     The GuacamoleSession to retrieve the user from.
     *
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider that created the
     *     UserContext from which the user should be retrieved. Only one
     *     UserContext per AuthenticationProvider can exist.
     *
     * @param identifier
     *     The identifier of the user to retrieve.
     *
     * @return
     *     The user having the given identifier.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving the user, or if the
     *     user does not exist.
     */
    public User retrieveUser(GuacamoleSession session, String authProviderIdentifier,
            String identifier) throws GuacamoleException {

        UserContext userContext = retrieveUserContext(session, authProviderIdentifier);
        return retrieveUser(userContext, identifier);

    }

    /**
     * Retrieves a single connection from the given GuacamoleSession.
     *
     * @param session
     *     The GuacamoleSession to retrieve the connection from.
     *
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider that created the
     *     UserContext from which the connection should be retrieved. Only one
     *     UserContext per AuthenticationProvider can exist.
     *
     * @param identifier
     *     The identifier of the connection to retrieve.
     *
     * @return
     *     The connection having the given identifier.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving the connection, or if the
     *     connection does not exist.
     */
    public Connection retrieveConnection(GuacamoleSession session,
            String authProviderIdentifier, String identifier)
            throws GuacamoleException {

        UserContext userContext = retrieveUserContext(session, authProviderIdentifier);
        return retrieveConnection(userContext, identifier);

    }

    /**
    /**
     * Retrieves a single connection group from the given GuacamoleSession. If
     * the given identifier the REST API root identifier, the root connection
     * group will be returned. The underlying authentication provider may
     * additionally use a different identifier for root.
     *
     * @param session
     *     The GuacamoleSession to retrieve the connection group from.
     *
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider that created the
     *     UserContext from which the connection group should be retrieved.
     *     Only one UserContext per AuthenticationProvider can exist.
     *
     * @param identifier
     *     The identifier of the connection group to retrieve.
     *
     * @return
     *     The connection group having the given identifier, or the root
     *     connection group if the identifier the root identifier.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving the connection group, or if the
     *     connection group does not exist.
     */
    public ConnectionGroup retrieveConnectionGroup(GuacamoleSession session,
            String authProviderIdentifier, String identifier) throws GuacamoleException {

        UserContext userContext = retrieveUserContext(session, authProviderIdentifier);
        return retrieveConnectionGroup(userContext, identifier);

    }

import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
 * @author Michael Jumper
@Path("/data/{dataSource}/users")

     * Gets a list of users in the given data source (UserContext), filtering
     * the returned list by the given permission, if specified.
     *
     * @param authProviderIdentifier
     *     The index of the UserContext within the overall List of available
     *     UserContexts in which the requested user is to be created.
     *
     *     of these permissions for a user to appear in the result.
     *
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
        User self = userContext.self();
     * @param authProviderIdentifier
     *     The index of the UserContext within the overall List of available
     *     UserContexts in which the requested user is to be created.
     *
    public APIUser getUser(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("username") String username)
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        User user = retrievalService.retrieveUser(session, authProviderIdentifier, username);
     *
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param authProviderIdentifier
     *     The index of the UserContext within the overall List of available
     *     UserContexts in which the requested user is to be created.
     *
     * @param user
     *     The new user to create.
     *
     * @throws GuacamoleException
     *     If a problem is encountered while creating the user.
     *
     * @return
     *     The username of the newly created user.
    public String createUser(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier, APIUser user)
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);

     * @param authProviderIdentifier
     *     The index of the UserContext within the overall List of available
     *     UserContexts in which the requested user is to be found.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);

     * @param authProviderIdentifier
     *     The index of the UserContext within the overall List of available
     *     UserContexts in which the requested user is to be found.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("username") String username,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);

            AuthenticationProvider authProvider = userContext.getAuthenticationProvider();
            if (authProvider.authenticateUser(credentials) == null) {
     * @param authProviderIdentifier
     *     The index of the UserContext within the overall List of available
     *     UserContexts in which the requested user is to be found.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);

     * @param authProviderIdentifier
     *     The index of the UserContext within the overall List of available
     *     UserContexts in which the requested user is to be found.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     *
     * @param authProviderIdentifier
     *     The index of the UserContext within the overall List of available
     *     UserContexts in which the requested user is to be found.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);

        connection.setAttributes(object.getAttributes());
        connectionGroup.setAttributes(object.getAttributes());
        user.setAttributes(object.getAttributes());
        if (authenticatedUser instanceof SimpleAuthenticatedUser && authenticatedUser.getAuthenticationProvider() == this)

        // Sort files lexicographically
        Arrays.sort(extensionFiles);

     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext from which the users are to be retrieved.
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext from which the requested user is to be retrieved.
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the requested user is to be created.
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the requested user is to be updated.
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the requested user is to be updated.
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext from which the requested user is to be deleted.
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the requested user is to be found.
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the requested user is to be found.
import javax.ws.rs.PathParam;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Path("/schema/{dataSource}")
     * Service for convenient retrieval of objects.
     */
    @Inject
    private ObjectRetrievalService retrievalService;

    /**
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext dictating the available user attributes.
     *
    public Collection<Form> getUserAttributes(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext dictating the available connection attributes.
     *
    public Collection<Form> getConnectionAttributes(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext dictating the available connection group
     *     attributes.
     *
    public Collection<Form> getConnectionGroupAttributes(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext dictating the protocols available. Currently, the
     *     UserContext actually does not dictate this, the the same set of
     *     protocols will be retrieved for all users, though the identifier
     *     given here will be validated.
     *
    public Map<String, ProtocolInfo> getProtocols(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier)
            throws GuacamoleException {
        // Verify the given auth token and auth provider identifier are valid
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        retrievalService.retrieveUserContext(session, authProviderIdentifier);
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
@Path("/data/{dataSource}/connections")
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection to be retrieved.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionID") String connectionID)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        return new APIConnection(retrievalService.retrieveConnection(session, authProviderIdentifier, connectionID));
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection whose parameters are to be
     *     retrieved.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionID") String connectionID)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection whose history is to be
     *     retrieved.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionID") String connectionID)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);

        Connection connection = retrievalService.retrieveConnection(session, authProviderIdentifier, connectionID);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection to be deleted.
     *
    public void deleteConnection(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionID") String connectionID)
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the connection is to be created.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection to be updated.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionID") String connectionID,
            APIConnection connection) throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
@Path("/data/{dataSource}/connectionGroups")
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection group to be retrieved.
     *
    public APIConnectionGroup getConnectionGroup(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionGroupID") String connectionGroupID)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        return new APIConnectionGroup(retrievalService.retrieveConnectionGroup(session, authProviderIdentifier, connectionGroupID));
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection group to be retrieved.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection group to be deleted.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionGroupID") String connectionGroupID)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the connection group is to be created.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection group to be updated.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionGroupID") String connectionGroupID,
            APIConnectionGroup connectionGroup)
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
import javax.ws.rs.PathParam;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Path("/data/{dataSource}/activeConnections")
     * Service for convenient retrieval of objects.
     */
    @Inject
    private ObjectRetrievalService retrievalService;

    /**
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the active connections to be retrieved.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the active connections to be deleted.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
        if (!isAdmin && permissions != null && !permissions.isEmpty()) {
public class HTTPTunnelRequest extends TunnelRequest {
 * Copyright (C) 2015 Glyptodon LLC
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
 * A request object which provides only the functions absolutely required to
 * retrieve and connect to a tunnel.
public abstract class TunnelRequest {
     * The name of the request parameter containing the user's authentication
     * token.
    public static final String AUTH_TOKEN_PARAMETER = "token";

    /**
     * The name of the parameter containing the identifier of the
     * AuthenticationProvider associated with the UserContext containing the
     * object to which a tunnel is being requested.
     */
    public static final String AUTH_PROVIDER_IDENTIFIER_PARAMETER = "GUAC_DATA_SOURCE";

    /**
     * The name of the parameter specifying the type of object to which a
     * tunnel is being requested. Currently, this may be "c" for a Guacamole
     * connection, or "g" for a Guacamole connection group.
     */
    public static final String TYPE_PARAMETER = "GUAC_TYPE";

    /**
     * The name of the parameter containing the unique identifier of the object
     * to which a tunnel is being requested.
     */
    public static final String IDENTIFIER_PARAMETER = "GUAC_ID";

    /**
     * The name of the parameter containing the desired display width, in
     * pixels.
     */
    public static final String WIDTH_PARAMETER = "GUAC_WIDTH";

    /**
     * The name of the parameter containing the desired display height, in
     * pixels.
     */
    public static final String HEIGHT_PARAMETER = "GUAC_HEIGHT";

    /**
     * The name of the parameter containing the desired display resolution, in
     * DPI.
     */
    public static final String DPI_PARAMETER = "GUAC_DPI";

    /**
     * The name of the parameter specifying one supported audio mimetype. This
     * will normally appear multiple times within a single tunnel request -
     * once for each mimetype.
     */
    public static final String AUDIO_PARAMETER = "GUAC_AUDIO";

    /**
     * The name of the parameter specifying one supported video mimetype. This
     * will normally appear multiple times within a single tunnel request -
     * once for each mimetype.
     */
    public static final String VIDEO_PARAMETER = "GUAC_VIDEO";

    /**
     * All supported object types that can be used as the destination of a
     * tunnel.
     */
    public static enum Type {
         * A Guacamole connection.
        CONNECTION("c"),
         * A Guacamole connection group.
        CONNECTION_GROUP("g");

        /**
         * The parameter value which denotes a destination object of this type.
         */
        final String PARAMETER_VALUE;
         * Defines a Type having the given corresponding parameter value.
         *
         * @param value
         *     The parameter value which denotes a destination object of this
         *     type.
        Type(String value) {
            PARAMETER_VALUE = value;
     * @param name
     *     The name of the parameter to return.
     *
     * @return
     *     The value of the parameter having the given name, or null if no such
     *     parameter was specified.
    public abstract String getParameter(String name);
     * @param name
     *     The name of the parameter to return.
     *
     * @return
     *     All values of the parameter having the given name , or null if no
     *     such parameter was specified.
    public abstract List<String> getParameterValues(String name);

    /**
     * Returns the value of the parameter having the given name, throwing an
     * exception if the parameter is missing.
     *
     * @param name
     *     The name of the parameter to return.
     *
     * @return
     *     The value of the parameter having the given name.
     *
     * @throws GuacamoleException
     *     If the parameter is not present in the request.
     */
    public String getRequiredParameter(String name) throws GuacamoleException {

        // Pull requested parameter, aborting if absent
        String value = getParameter(name);
        if (value == null)
            throw new GuacamoleClientException("Parameter \""  name  "\" is required.");

        return value;

    }

    /**
     * Returns the integer value of the parameter having the given name,
     * throwing an exception if the parameter cannot be parsed.
     *
     * @param name
     *     The name of the parameter to return.
     *
     * @return
     *     The integer value of the parameter having the given name, or null if
     *     the parameter is missing.
     *
     * @throws GuacamoleException
     *     If the parameter is not a valid integer.
     */
    public Integer getIntegerParameter(String name) throws GuacamoleException {

        // Pull requested parameter
        String value = getParameter(name);
        if (value == null)
            return null;

        // Attempt to parse as an integer
        try {
            return Integer.parseInt(value);
        }

        // Rethrow any parsing error as a GuacamoleClientException
        catch (NumberFormatException e) {
            throw new GuacamoleClientException("Parameter \""  name  "\" must be a valid integer.", e);
        }

    }

    /**
     * Returns the authentication token associated with this tunnel request.
     *
     * @return
     *     The authentication token associated with this tunnel request, or
     *     null if no authentication token is present.
     */
    public String getAuthenticationToken() {
        return getParameter(AUTH_TOKEN_PARAMETER);
    }

    /**
     * Returns the identifier of the AuthenticationProvider associated with the
     * UserContext from which the connection or connection group is to be
     * retrieved when the tunnel is created. In the context of the REST API and
     * the JavaScript side of the web application, this is referred to as the
     * data source identifier.
     *
     * @return
     *     The identifier of the AuthenticationProvider associated with the
     *     UserContext from which the connection or connection group is to be
     *     retrieved when the tunnel is created.
     *
     * @throws GuacamoleException
     *     If the identifier was not present in the request.
     */
    public String getAuthenticationProviderIdentifier()
            throws GuacamoleException {
        return getRequiredParameter(AUTH_PROVIDER_IDENTIFIER_PARAMETER);
    }

    /**
     * Returns the type of object for which the tunnel is being requested.
     *
     * @return
     *     The type of object for which the tunnel is being requested.
     *
     * @throws GuacamoleException
     *     If the type was not present in the request, or if the type requested
     *     is in the wrong format.
     */
    public Type getType() throws GuacamoleException {

        String type = getRequiredParameter(TYPE_PARAMETER);

        // For each possible object type
        for (Type possibleType : Type.values()) {

            // Match against defined parameter value
            if (type.equals(possibleType.PARAMETER_VALUE))
                return possibleType;

        }

        throw new GuacamoleClientException("Illegal identifier - unknown type.");

    }

    /**
     * Returns the identifier of the destination of the tunnel being requested.
     * As there are multiple types of destination objects available, and within
     * multiple data sources, the associated object type and data source are
     * also necessary to determine what this identifier refers to.
     *
     * @return
     *     The identifier of the destination of the tunnel being requested.
     *
     * @throws GuacamoleException
     *     If the identifier was not present in the request.
     */
    public String getIdentifier() throws GuacamoleException {
        return getRequiredParameter(IDENTIFIER_PARAMETER);
    }

    /**
     * Returns the display width desired for the Guacamole session over the
     * tunnel being requested.
     *
     * @return
     *     The display width desired for the Guacamole session over the tunnel
     *     being requested, or null if no width was given.
     *
     * @throws GuacamoleException
     *     If the width specified was not a valid integer.
     */
    public Integer getWidth() throws GuacamoleException {
        return getIntegerParameter(WIDTH_PARAMETER);
    }

    /**
     * Returns the display height desired for the Guacamole session over the
     * tunnel being requested.
     *
     * @return
     *     The display height desired for the Guacamole session over the tunnel
     *     being requested, or null if no width was given.
     *
     * @throws GuacamoleException
     *     If the height specified was not a valid integer.
     */
    public Integer getHeight() throws GuacamoleException {
        return getIntegerParameter(HEIGHT_PARAMETER);
    }

    /**
     * Returns the display resolution desired for the Guacamole session over
     * the tunnel being requested, in DPI.
     *
     * @return
     *     The display resolution desired for the Guacamole session over the
     *     tunnel being requested, or null if no resolution was given.
     *
     * @throws GuacamoleException
     *     If the resolution specified was not a valid integer.
     */
    public Integer getDPI() throws GuacamoleException {
        return getIntegerParameter(DPI_PARAMETER);
    }

    /**
     * Returns a list of all audio mimetypes declared as supported within the
     * tunnel request.
     *
     * @return
     *     A list of all audio mimetypes declared as supported within the
     *     tunnel request, or null if no mimetypes were specified.
     */
    public List<String> getAudioMimetypes() {
        return getParameterValues(AUDIO_PARAMETER);
    }

    /**
     * Returns a list of all video mimetypes declared as supported within the
     * tunnel request.
     *
     * @return
     *     A list of all video mimetypes declared as supported within the
     *     tunnel request, or null if no mimetypes were specified.
     */
    public List<String> getVideoMimetypes() {
        return getParameterValues(VIDEO_PARAMETER);
    }

import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
     * Service for convenient retrieval of objects.
     */
    @Inject
    private ObjectRetrievalService retrievalService;

    /**
     *
     * @throws GuacamoleException
     *     If the parameters of the tunnel request are invalid.
    protected GuacamoleClientInformation getClientInformation(TunnelRequest request)
        throws GuacamoleException {

        Integer width = request.getWidth();
            info.setOptimalScreenWidth(width);
        Integer height = request.getHeight();
            info.setOptimalScreenHeight(height);
        Integer dpi = request.getDPI();
            info.setOptimalResolution(dpi);
        List<String> audioMimetypes = request.getAudioMimetypes();
        if (audioMimetypes != null)
            info.getAudioMimetypes().addAll(audioMimetypes);
        List<String> videoMimetypes = request.getVideoMimetypes();
        if (videoMimetypes != null)
            info.getVideoMimetypes().addAll(videoMimetypes);
     * @param type
            final TunnelRequest.Type type, String id,
        switch (type) {
     * @param type
            GuacamoleTunnel tunnel, final TunnelRequest.Type type,
                switch (type) {
        // Parse request parameters
        String authToken                = request.getAuthenticationToken();
        String id                       = request.getIdentifier();
        TunnelRequest.Type type         = request.getType();
        String authProviderIdentifier   = request.getAuthenticationProviderIdentifier();
        GuacamoleClientInformation info = getClientInformation(request);
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
        GuacamoleTunnel tunnel = createConnectedTunnel(userContext, type, id, info);
        return createAssociatedTunnel(session, tunnel, type, id);
public class WebSocketTunnelRequest extends TunnelRequest {
public class WebSocketTunnelRequest extends TunnelRequest {
     *     UserContext being retrieved. Only one UserContext per User per
     *     UserContext per User per AuthenticationProvider can exist.
     *     UserContext per User per AuthenticationProvider can exist.
     *     Only one UserContext per User per AuthenticationProvider can exist.
     * the given identifier is the REST API root identifier, the root
     * connection group will be returned. The underlying authentication
     * provider may additionally use a different identifier for root.
     *     connection group if the identifier is the root identifier.
 * Copyright (C) 2015 Glyptodon LLC
        connection.setAttributes(object.getAttributes());
        connectionGroup.setAttributes(object.getAttributes());
        user.setAttributes(object.getAttributes());
        if (authenticatedUser instanceof SimpleAuthenticatedUser && authenticatedUser.getAuthenticationProvider() == this)
public class HTTPTunnelRequest extends TunnelRequest {
 * Copyright (C) 2015 Glyptodon LLC
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleException;
 * A request object which provides only the functions absolutely required to
 * retrieve and connect to a tunnel.
public abstract class TunnelRequest {
     * The name of the request parameter containing the user's authentication
     * token.
    public static final String AUTH_TOKEN_PARAMETER = "token";

    /**
     * The name of the parameter containing the identifier of the
     * AuthenticationProvider associated with the UserContext containing the
     * object to which a tunnel is being requested.
     */
    public static final String AUTH_PROVIDER_IDENTIFIER_PARAMETER = "GUAC_DATA_SOURCE";

    /**
     * The name of the parameter specifying the type of object to which a
     * tunnel is being requested. Currently, this may be "c" for a Guacamole
     * connection, or "g" for a Guacamole connection group.
     */
    public static final String TYPE_PARAMETER = "GUAC_TYPE";

    /**
     * The name of the parameter containing the unique identifier of the object
     * to which a tunnel is being requested.
     */
    public static final String IDENTIFIER_PARAMETER = "GUAC_ID";

    /**
     * The name of the parameter containing the desired display width, in
     * pixels.
     */
    public static final String WIDTH_PARAMETER = "GUAC_WIDTH";

    /**
     * The name of the parameter containing the desired display height, in
     * pixels.
     */
    public static final String HEIGHT_PARAMETER = "GUAC_HEIGHT";

    /**
     * The name of the parameter containing the desired display resolution, in
     * DPI.
     */
    public static final String DPI_PARAMETER = "GUAC_DPI";

    /**
     * The name of the parameter specifying one supported audio mimetype. This
     * will normally appear multiple times within a single tunnel request -
     * once for each mimetype.
     */
    public static final String AUDIO_PARAMETER = "GUAC_AUDIO";

    /**
     * The name of the parameter specifying one supported video mimetype. This
     * will normally appear multiple times within a single tunnel request -
     * once for each mimetype.
     */
    public static final String VIDEO_PARAMETER = "GUAC_VIDEO";

    /**
     * All supported object types that can be used as the destination of a
     * tunnel.
     */
    public static enum Type {
         * A Guacamole connection.
        CONNECTION("c"),
         * A Guacamole connection group.
        CONNECTION_GROUP("g");

        /**
         * The parameter value which denotes a destination object of this type.
         */
        final String PARAMETER_VALUE;
         * Defines a Type having the given corresponding parameter value.
         *
         * @param value
         *     The parameter value which denotes a destination object of this
         *     type.
        Type(String value) {
            PARAMETER_VALUE = value;
     * @param name
     *     The name of the parameter to return.
     *
     * @return
     *     The value of the parameter having the given name, or null if no such
     *     parameter was specified.
    public abstract String getParameter(String name);
     * @param name
     *     The name of the parameter to return.
     *
     * @return
     *     All values of the parameter having the given name , or null if no
     *     such parameter was specified.
    public abstract List<String> getParameterValues(String name);

    /**
     * Returns the value of the parameter having the given name, throwing an
     * exception if the parameter is missing.
     *
     * @param name
     *     The name of the parameter to return.
     *
     * @return
     *     The value of the parameter having the given name.
     *
     * @throws GuacamoleException
     *     If the parameter is not present in the request.
     */
    public String getRequiredParameter(String name) throws GuacamoleException {

        // Pull requested parameter, aborting if absent
        String value = getParameter(name);
        if (value == null)
            throw new GuacamoleClientException("Parameter \""  name  "\" is required.");

        return value;

    }

    /**
     * Returns the integer value of the parameter having the given name,
     * throwing an exception if the parameter cannot be parsed.
     *
     * @param name
     *     The name of the parameter to return.
     *
     * @return
     *     The integer value of the parameter having the given name, or null if
     *     the parameter is missing.
     *
     * @throws GuacamoleException
     *     If the parameter is not a valid integer.
     */
    public Integer getIntegerParameter(String name) throws GuacamoleException {

        // Pull requested parameter
        String value = getParameter(name);
        if (value == null)
            return null;

        // Attempt to parse as an integer
        try {
            return Integer.parseInt(value);
        }

        // Rethrow any parsing error as a GuacamoleClientException
        catch (NumberFormatException e) {
            throw new GuacamoleClientException("Parameter \""  name  "\" must be a valid integer.", e);
        }

    }

    /**
     * Returns the authentication token associated with this tunnel request.
     *
     * @return
     *     The authentication token associated with this tunnel request, or
     *     null if no authentication token is present.
     */
    public String getAuthenticationToken() {
        return getParameter(AUTH_TOKEN_PARAMETER);
    }

    /**
     * Returns the identifier of the AuthenticationProvider associated with the
     * UserContext from which the connection or connection group is to be
     * retrieved when the tunnel is created. In the context of the REST API and
     * the JavaScript side of the web application, this is referred to as the
     * data source identifier.
     *
     * @return
     *     The identifier of the AuthenticationProvider associated with the
     *     UserContext from which the connection or connection group is to be
     *     retrieved when the tunnel is created.
     *
     * @throws GuacamoleException
     *     If the identifier was not present in the request.
     */
    public String getAuthenticationProviderIdentifier()
            throws GuacamoleException {
        return getRequiredParameter(AUTH_PROVIDER_IDENTIFIER_PARAMETER);
    }

    /**
     * Returns the type of object for which the tunnel is being requested.
     *
     * @return
     *     The type of object for which the tunnel is being requested.
     *
     * @throws GuacamoleException
     *     If the type was not present in the request, or if the type requested
     *     is in the wrong format.
     */
    public Type getType() throws GuacamoleException {

        String type = getRequiredParameter(TYPE_PARAMETER);

        // For each possible object type
        for (Type possibleType : Type.values()) {

            // Match against defined parameter value
            if (type.equals(possibleType.PARAMETER_VALUE))
                return possibleType;

        }

        throw new GuacamoleClientException("Illegal identifier - unknown type.");

    }

    /**
     * Returns the identifier of the destination of the tunnel being requested.
     * As there are multiple types of destination objects available, and within
     * multiple data sources, the associated object type and data source are
     * also necessary to determine what this identifier refers to.
     *
     * @return
     *     The identifier of the destination of the tunnel being requested.
     *
     * @throws GuacamoleException
     *     If the identifier was not present in the request.
     */
    public String getIdentifier() throws GuacamoleException {
        return getRequiredParameter(IDENTIFIER_PARAMETER);
    }

    /**
     * Returns the display width desired for the Guacamole session over the
     * tunnel being requested.
     *
     * @return
     *     The display width desired for the Guacamole session over the tunnel
     *     being requested, or null if no width was given.
     *
     * @throws GuacamoleException
     *     If the width specified was not a valid integer.
     */
    public Integer getWidth() throws GuacamoleException {
        return getIntegerParameter(WIDTH_PARAMETER);
    }

    /**
     * Returns the display height desired for the Guacamole session over the
     * tunnel being requested.
     *
     * @return
     *     The display height desired for the Guacamole session over the tunnel
     *     being requested, or null if no width was given.
     *
     * @throws GuacamoleException
     *     If the height specified was not a valid integer.
     */
    public Integer getHeight() throws GuacamoleException {
        return getIntegerParameter(HEIGHT_PARAMETER);
    }

    /**
     * Returns the display resolution desired for the Guacamole session over
     * the tunnel being requested, in DPI.
     *
     * @return
     *     The display resolution desired for the Guacamole session over the
     *     tunnel being requested, or null if no resolution was given.
     *
     * @throws GuacamoleException
     *     If the resolution specified was not a valid integer.
     */
    public Integer getDPI() throws GuacamoleException {
        return getIntegerParameter(DPI_PARAMETER);
    }

    /**
     * Returns a list of all audio mimetypes declared as supported within the
     * tunnel request.
     *
     * @return
     *     A list of all audio mimetypes declared as supported within the
     *     tunnel request, or null if no mimetypes were specified.
     */
    public List<String> getAudioMimetypes() {
        return getParameterValues(AUDIO_PARAMETER);
    }

    /**
     * Returns a list of all video mimetypes declared as supported within the
     * tunnel request.
     *
     * @return
     *     A list of all video mimetypes declared as supported within the
     *     tunnel request, or null if no mimetypes were specified.
     */
    public List<String> getVideoMimetypes() {
        return getParameterValues(VIDEO_PARAMETER);
    }

import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
     * Service for convenient retrieval of objects.
     */
    @Inject
    private ObjectRetrievalService retrievalService;

    /**
     *
     * @throws GuacamoleException
     *     If the parameters of the tunnel request are invalid.
    protected GuacamoleClientInformation getClientInformation(TunnelRequest request)
        throws GuacamoleException {

        Integer width = request.getWidth();
            info.setOptimalScreenWidth(width);
        Integer height = request.getHeight();
            info.setOptimalScreenHeight(height);
        Integer dpi = request.getDPI();
            info.setOptimalResolution(dpi);
        List<String> audioMimetypes = request.getAudioMimetypes();
        if (audioMimetypes != null)
            info.getAudioMimetypes().addAll(audioMimetypes);
        List<String> videoMimetypes = request.getVideoMimetypes();
        if (videoMimetypes != null)
            info.getVideoMimetypes().addAll(videoMimetypes);
     * @param type
            final TunnelRequest.Type type, String id,
        switch (type) {
     * @param type
            GuacamoleTunnel tunnel, final TunnelRequest.Type type,
                switch (type) {
        // Parse request parameters
        String authToken                = request.getAuthenticationToken();
        String id                       = request.getIdentifier();
        TunnelRequest.Type type         = request.getType();
        String authProviderIdentifier   = request.getAuthenticationProviderIdentifier();
        GuacamoleClientInformation info = getClientInformation(request);
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
        GuacamoleTunnel tunnel = createConnectedTunnel(userContext, type, id, info);
        return createAssociatedTunnel(session, tunnel, type, id);

        // Sort files lexicographically
        Arrays.sort(extensionFiles);

import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
     * @param authProviderIdentifier
     *     UserContext being retrieved. Only one UserContext per User per
            String authProviderIdentifier) throws GuacamoleException {

            // Get AuthenticationProvider associated with current UserContext
            AuthenticationProvider authProvider = userContext.getAuthenticationProvider();

            // If AuthenticationProvider identifier matches, done
            if (authProvider.getIdentifier().equals(authProviderIdentifier))

        throw new GuacamoleResourceNotFoundException("Session not associated with authentication provider \""  authProviderIdentifier  "\".");
     * Retrieves a single user from the given GuacamoleSession.
     *
     * @param session
     *     The GuacamoleSession to retrieve the user from.
     *
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider that created the
     *     UserContext from which the user should be retrieved. Only one
     *     UserContext per User per AuthenticationProvider can exist.
     *
     * @param identifier
     *     The identifier of the user to retrieve.
     *
     * @return
     *     The user having the given identifier.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving the user, or if the
     *     user does not exist.
     */
    public User retrieveUser(GuacamoleSession session, String authProviderIdentifier,
            String identifier) throws GuacamoleException {

        UserContext userContext = retrieveUserContext(session, authProviderIdentifier);
        return retrieveUser(userContext, identifier);

    }

    /**
     * Retrieves a single connection from the given GuacamoleSession.
     *
     * @param session
     *     The GuacamoleSession to retrieve the connection from.
     *
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider that created the
     *     UserContext from which the connection should be retrieved. Only one
     *     UserContext per User per AuthenticationProvider can exist.
     *
     * @param identifier
     *     The identifier of the connection to retrieve.
     *
     * @return
     *     The connection having the given identifier.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving the connection, or if the
     *     connection does not exist.
     */
    public Connection retrieveConnection(GuacamoleSession session,
            String authProviderIdentifier, String identifier)
            throws GuacamoleException {

        UserContext userContext = retrieveUserContext(session, authProviderIdentifier);
        return retrieveConnection(userContext, identifier);

    }

    /**
    /**
     * Retrieves a single connection group from the given GuacamoleSession. If
     * the given identifier is the REST API root identifier, the root
     * connection group will be returned. The underlying authentication
     * provider may additionally use a different identifier for root.
     *
     * @param session
     *     The GuacamoleSession to retrieve the connection group from.
     *
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider that created the
     *     UserContext from which the connection group should be retrieved.
     *     Only one UserContext per User per AuthenticationProvider can exist.
     *
     * @param identifier
     *     The identifier of the connection group to retrieve.
     *
     * @return
     *     The connection group having the given identifier, or the root
     *     connection group if the identifier is the root identifier.
     *
     * @throws GuacamoleException 
     *     If an error occurs while retrieving the connection group, or if the
     *     connection group does not exist.
     */
    public ConnectionGroup retrieveConnectionGroup(GuacamoleSession session,
            String authProviderIdentifier, String identifier) throws GuacamoleException {

        UserContext userContext = retrieveUserContext(session, authProviderIdentifier);
        return retrieveConnectionGroup(userContext, identifier);

    }

import javax.ws.rs.PathParam;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Path("/data/{dataSource}/activeConnections")
     * Service for convenient retrieval of objects.
     */
    @Inject
    private ObjectRetrievalService retrievalService;

    /**
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the active connections to be retrieved.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the active connections to be deleted.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
@Path("/data/{dataSource}/connections")
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection to be retrieved.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionID") String connectionID)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        return new APIConnection(retrievalService.retrieveConnection(session, authProviderIdentifier, connectionID));
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection whose parameters are to be
     *     retrieved.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionID") String connectionID)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection whose history is to be
     *     retrieved.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionID") String connectionID)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);

        Connection connection = retrievalService.retrieveConnection(session, authProviderIdentifier, connectionID);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection to be deleted.
     *
    public void deleteConnection(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionID") String connectionID)
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the connection is to be created.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection to be updated.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionID") String connectionID,
            APIConnection connection) throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
@Path("/data/{dataSource}/connectionGroups")
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection group to be retrieved.
     *
    public APIConnectionGroup getConnectionGroup(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionGroupID") String connectionGroupID)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        return new APIConnectionGroup(retrievalService.retrieveConnectionGroup(session, authProviderIdentifier, connectionGroupID));
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection group to be retrieved.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection group to be deleted.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionGroupID") String connectionGroupID)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the connection group is to be created.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext containing the connection group to be updated.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("connectionGroupID") String connectionGroupID,
            APIConnectionGroup connectionGroup)
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
import javax.ws.rs.PathParam;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
import org.glyptodon.guacamole.net.basic.rest.ObjectRetrievalService;
@Path("/schema/{dataSource}")
     * Service for convenient retrieval of objects.
     */
    @Inject
    private ObjectRetrievalService retrievalService;

    /**
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext dictating the available user attributes.
     *
    public Collection<Form> getUserAttributes(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext dictating the available connection attributes.
     *
    public Collection<Form> getConnectionAttributes(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext dictating the available connection group
     *     attributes.
     *
    public Collection<Form> getConnectionGroupAttributes(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier)
            throws GuacamoleException {
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext dictating the protocols available. Currently, the
     *     UserContext actually does not dictate this, the the same set of
     *     protocols will be retrieved for all users, though the identifier
     *     given here will be validated.
     *
    public Map<String, ProtocolInfo> getProtocols(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier)
            throws GuacamoleException {
        // Verify the given auth token and auth provider identifier are valid
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        retrievalService.retrieveUserContext(session, authProviderIdentifier);
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
 * @author Michael Jumper
@Path("/data/{dataSource}/users")

     * Gets a list of users in the given data source (UserContext), filtering
     * the returned list by the given permission, if specified.
     *
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext from which the users are to be retrieved.
     *
     *     of these permissions for a user to appear in the result.
     *
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
        User self = userContext.self();
        if (!isAdmin && permissions != null && !permissions.isEmpty()) {
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext from which the requested user is to be retrieved.
     *
    public APIUser getUser(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("username") String username)
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        User user = retrievalService.retrieveUser(session, authProviderIdentifier, username);
     *
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the requested user is to be created.
     *
     * @param user
     *     The new user to create.
     *
     * @throws GuacamoleException
     *     If a problem is encountered while creating the user.
     *
     * @return
     *     The username of the newly created user.
    public String createUser(@QueryParam("token") String authToken,
            @PathParam("dataSource") String authProviderIdentifier, APIUser user)
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);

     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the requested user is to be updated.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);

     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the requested user is to be updated.
     *
            @PathParam("dataSource") String authProviderIdentifier,
            @PathParam("username") String username,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);

            AuthenticationProvider authProvider = userContext.getAuthenticationProvider();
            if (authProvider.authenticateUser(credentials) == null) {
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext from which the requested user is to be deleted.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);

     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the requested user is to be found.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);
     *
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider associated with
     *     the UserContext in which the requested user is to be found.
     *
            @PathParam("dataSource") String authProviderIdentifier,
        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        UserContext userContext = retrievalService.retrieveUserContext(session, authProviderIdentifier);

public class WebSocketTunnelRequest extends TunnelRequest {
public class WebSocketTunnelRequest extends TunnelRequest {
        ObjectPermission.Type.READ
import org.glyptodon.guacamole.GuacamoleSecurityException;
            // getConnections() will only be called after a connection has been
            // authenticated (via non-anonymous bind), thus userDN cannot
            // possibly be null
            assert(userDN != null);

        Authorization auth = userMapping.getAuthorization(credentials.getUsername());
        ObjectPermission.Type.READ
            // getConnections() will only be called after a connection has been
            // authenticated (via non-anonymous bind), thus userDN cannot
            // possibly be null
            assert(userDN != null);

        Authorization auth = userMapping.getAuthorization(credentials.getUsername());
            "0.9.8"
            "0.9.8"
        // Attempt to acquire to any child
        ModeledConnection connection;
        try {
            connection = acquire(user, connections);
        }

        // Ensure connection group is always released if child acquire fails
        finally {
            release(user, connectionGroup);
        }

        // Connect to acquired child
        // Attempt to acquire to any child
        ModeledConnection connection;
        try {
            connection = acquire(user, connections);
        }

        // Ensure connection group is always released if child acquire fails
        finally {
            release(user, connectionGroup);
        }

        // Connect to acquired child
        catch (GuacamoleException e) {
            throw e;
        catch (GuacamoleException e) {
            throw e;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
            throw new GuacamoleInvalidCredentialsException("Permission denied.", CredentialsInfo.USERNAME_PASSWORD);
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
            throw new GuacamoleInvalidCredentialsException("Permission denied.", CredentialsInfo.USERNAME_PASSWORD);
        // Send supported image formats
        writer.writeInstruction(
                new GuacamoleInstruction(
                    "image",
                    info.getImageMimetypes().toArray(new String[0])
                ));

     * The list of video mimetypes reported by the client to be supported.
     * The list of image mimetypes reported by the client to be supported.
     */
    private final List<String> imageMimetypes = new ArrayList<String>();

    /**
    /**
     * Returns the list of image mimetypes supported by the client. To add or
     * removed supported mimetypes, the list returned by this function can be
     * modified.
     *
     * @return
     *     The set of image mimetypes supported by the client.
     */
    public List<String> getImageMimetypes() {
        return imageMimetypes;
    }

     * The name of the parameter specifying one supported image mimetype. This
     * will normally appear multiple times within a single tunnel request -
     * once for each mimetype.
     */
    public static final String IMAGE_PARAMETER = "GUAC_IMAGE";

    /**
    /**
     * Returns a list of all image mimetypes declared as supported within the
     * tunnel request.
     *
     * @return
     *     A list of all image mimetypes declared as supported within the
     *     tunnel request, or null if no mimetypes were specified.
     */
    public List<String> getImageMimetypes() {
        return getParameterValues(IMAGE_PARAMETER);
    }

        // Add image mimetypes
        List<String> imageMimetypes = request.getImageMimetypes();
        if (imageMimetypes != null)
            info.getImageMimetypes().addAll(imageMimetypes);

        // Send supported image formats
        writer.writeInstruction(
                new GuacamoleInstruction(
                    "image",
                    info.getImageMimetypes().toArray(new String[0])
                ));

     * The list of video mimetypes reported by the client to be supported.
     * The list of image mimetypes reported by the client to be supported.
     */
    private final List<String> imageMimetypes = new ArrayList<String>();

    /**
    /**
     * Returns the list of image mimetypes supported by the client. To add or
     * removed supported mimetypes, the list returned by this function can be
     * modified.
     *
     * @return
     *     The set of image mimetypes supported by the client.
     */
    public List<String> getImageMimetypes() {
        return imageMimetypes;
    }

     * The name of the parameter specifying one supported image mimetype. This
     * will normally appear multiple times within a single tunnel request -
     * once for each mimetype.
     */
    public static final String IMAGE_PARAMETER = "GUAC_IMAGE";

    /**
    /**
     * Returns a list of all image mimetypes declared as supported within the
     * tunnel request.
     *
     * @return
     *     A list of all image mimetypes declared as supported within the
     *     tunnel request, or null if no mimetypes were specified.
     */
    public List<String> getImageMimetypes() {
        return getParameterValues(IMAGE_PARAMETER);
    }

        // Add image mimetypes
        List<String> imageMimetypes = request.getImageMimetypes();
        if (imageMimetypes != null)
            info.getImageMimetypes().addAll(imageMimetypes);

import org.glyptodon.guacamole.net.auth.ConnectionRecordSet;
import org.glyptodon.guacamole.net.auth.simple.SimpleConnectionRecordSet;
    public ConnectionRecordSet getConnectionHistory()
            throws GuacamoleException {
        return new SimpleConnectionRecordSet();
    }

    @Override
import org.glyptodon.guacamole.net.auth.ConnectionRecordSet;
import org.glyptodon.guacamole.net.auth.simple.SimpleConnectionRecordSet;
    public ConnectionRecordSet getConnectionHistory()
            throws GuacamoleException {
        return new SimpleConnectionRecordSet();
    }

    @Override
     * Retrieves all connection records visible to current user. The resulting
     * set of connection records can be further filtered and ordered using the
     * methods defined on ConnectionRecordSet.
     *
     * @return
     *     A set of all connection records visible to the current user.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the connection records.
     */
    ConnectionRecordSet getConnectionHistory() throws GuacamoleException;

    /**
import org.glyptodon.guacamole.net.auth.ConnectionRecordSet;
    public ConnectionRecordSet getConnectionHistory()
            throws GuacamoleException {
        return new SimpleConnectionRecordSet();
    }

    @Override
     * connection name, user identifier, or any associated date field contain
     * the given value.
import org.glyptodon.guacamole.net.basic.rest.history.HistoryRESTService;
        bind(HistoryRESTService.class);
import org.glyptodon.guacamole.net.basic.rest.history.APIConnectionRecord;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/history/APIConnectionRecord.java
package org.glyptodon.guacamole.net.basic.rest.history;
 *


    public String getConnectionIdentifier() {
        return model.getConnectionIdentifier();
    }

    @Override
    public String getConnectionIdentifier() {
        return connection.getIdentifier();
    }

    @Override
     * Returns the identifier of the connection associated with this
     * connection record.
     *
     * @return
     *     The identifier of the connection associated with this connection
     *     record.
     */
    public String getConnectionIdentifier();

    /**
     * The identifier of the connection associated with this record.
     */
    private final String connectionIdentifier;

    /**
        this.connectionIdentifier = record.getConnectionIdentifier();
     * Returns the identifier of the connection associated with this
     * record.
     *
     * @return
     *     The identifier of the connection associated with this record.
     */
    public String getConnectionIdentifier() {
        return connectionIdentifier;
    }

    /**
     * the given value. This function may also affect the contents of the
     * current ConnectionRecordSet. The contents of the current
     * ConnectionRecordSet should NOT be relied upon after this function is
     * called.
     * <code>limit</code> records, then this function has no effect. This
     * function may also affect the contents of the current
     * ConnectionRecordSet. The contents of the current ConnectionRecordSet
     * should NOT be relied upon after this function is called.
     * sort(). This function may also affect the contents of the current
     * ConnectionRecordSet. The contents of the current ConnectionRecordSet
     * should NOT be relied upon after this function is called.
        for (String required : requiredContents) {
            if (!required.isEmpty())
                history = history.contains(required);
        }
import java.util.Set;

    /**
     * Searches for up to <code>limit</code> connection records that contain 
     * the given terms, sorted by the given predicates.
     * 
     * @param terms
     *     The search terms that must match the returned records.
     * 
     * @param sortPredicates
     *     A list of predicates to sort the returned records by, in order of
     *     priority.
     *
     * @param limit 
     *     The maximum number of records that should be returned.
     * 
     * @return
     *     The results of the search performed with the given parameters. 
     */
    List<ConnectionRecordModel> search(@Param("terms") Set<ConnectionRecordSearchTerm> terms,
            @Param("sortPredicates") List<ConnectionRecordSortPredicate> sortPredicates,
            @Param("limit") int limit);
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionRecordSet;
    /**
     * Provider for creating connection record sets.
     */
    @Inject
    private Provider<ConnectionRecordSet> connectionRecordSetProvider;
    
        ConnectionRecordSet connectionRecordSet = connectionRecordSetProvider.get();
        connectionRecordSet.init(getCurrentUser());
        return connectionRecordSet;
import java.util.Collection;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;
     * Searches for up to <code>limit</code> connection records that contain
     * the given terms, sorted by the given predicates, regardless of whether
     * the data they are associated with is is readable by any particular user.
     * This should only be called on behalf of a system administrator. If
     * records are needed by a non-administrative user who must have explicit
     * read rights, use searchReadable() instead.
     *
     *
     * @param limit
     *
     *     The results of the search performed with the given parameters.
    List<ConnectionRecordModel> search(@Param("terms") Collection<ConnectionRecordSearchTerm> terms,

    /**
     * Searches for up to <code>limit</code> connection records that contain
     * the given terms, sorted by the given predicates. Only records that are
     * associated with data explicitly readable by the given user will be
     * returned. If records are needed by a system administrator (who, by
     * definition, does not need explicit read rights), use search() instead.
     *
     * @param user
     *    The user whose permissions should determine whether a record is
     *    returned.
     *
     * @param terms
     *     The search terms that must match the returned records.
     *
     * @param sortPredicates
     *     A list of predicates to sort the returned records by, in order of
     *     priority.
     *
     * @param limit
     *     The maximum number of records that should be returned.
     *
     * @return
     *     The results of the search performed with the given parameters.
     */
    List<ConnectionRecordModel> searchReadable(@Param("user") UserModel user,
            @Param("terms") Collection<ConnectionRecordSearchTerm> terms,
            @Param("sortPredicates") List<ConnectionRecordSortPredicate> sortPredicates,
            @Param("limit") int limit);

     * Service for managing connection objects.
    private ConnectionService connectionService;
        return connectionService.retrieveHistory(getCurrentUser(),
                requiredContents, connectionRecordSortPredicates, limit);
     * Returns a connection records object which is backed by the given model.
     *
     * @param model
     *     The model object to use to back the returned connection record
     *     object.
     *
     * @return
     *     A connection record object which is backed by the given model.
     */
    protected ConnectionRecord getObjectInstance(ConnectionRecordModel model) {
        return new ModeledConnectionRecord(model);
    }

    /**
     * Returns a list of connection records objects which are backed by the
     * models in the given list.
     *
     * @param models
     *     The model objects to use to back the connection record objects
     *     within the returned list.
     *
     * @return
     *     A list of connection record objects which are backed by the models
     *     in the given list.
     */
    protected List<ConnectionRecord> getObjectInstances(List<ConnectionRecordModel> models) {

        // Create new list of records by manually converting each model
        List<ConnectionRecord> objects = new ArrayList<ConnectionRecord>(models.size());
        for (ConnectionRecordModel model : models)
            objects.add(getObjectInstance(model));

        return objects;
 
    }

    /**

                records.add(getObjectInstance(model));



    /**
     * Retrieves the connection history records matching the given criteria.
     * Retrieves up to <code>limit</code> connection history records matching
     * the given terms and sorted by the given predicates. Only history records
     * associated with data that the given user can read are returned.
     *
     * @param user
     *     The user retrieving the connection history.
     *
     * @param requiredContents
     *     The search terms that must be contained somewhere within each of the
     *     returned records.
     *
     * @param sortPredicates
     *     A list of predicates to sort the returned records by, in order of
     *     priority.
     *
     * @param limit
     *     The maximum number of records that should be returned.
     *
     * @return
     *     The connection history of the given connection, including any
     *     active connections.
     *
     * @throws GuacamoleException
     *     If permission to read the connection history is denied.
     */
    public List<ConnectionRecord> retrieveHistory(AuthenticatedUser user,
            Collection<ConnectionRecordSearchTerm> requiredContents,
            List<ConnectionRecordSortPredicate> sortPredicates, int limit)
            throws GuacamoleException {

        List<ConnectionRecordModel> searchResults;

        // Bypass permission checks if the user is a system admin
        if (user.getUser().isAdministrator())
            searchResults = connectionRecordMapper.search(requiredContents,
                    sortPredicates, limit);

        // Otherwise only return explicitly readable history records
        else
            searchResults = connectionRecordMapper.searchReadable(user.getUser().getModel(),
                    requiredContents, sortPredicates, limit);

        return getObjectInstances(searchResults);

    }

    private final LanguageResourceService languageResourceService;
        this.languageResourceService = new LanguageResourceService(environment);
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
     * The set of all language keys which are explicitly listed as allowed
     * within guacamole.properties, or null if all defined languages should be
     * allowed.
     */
    private final Set<String> allowedLanguages;

    /**
     * Creates a new service for tracking and parsing available translations
     * which reads its configuration from the given environment.
     *
     * @param environment
     *     The environment from which the configuration properties of this
     *     service should be read.
     */
    public LanguageResourceService(Environment environment) {

        Set<String> parsedAllowedLanguages;

        // Parse list of available languages from properties
        try {
            parsedAllowedLanguages = environment.getProperty(BasicGuacamoleProperties.ALLOWED_LANGUAGES);
            logger.debug("Available languages will be restricted to: {}", parsedAllowedLanguages);
        }

        // Warn of failure to parse
        catch (GuacamoleException e) {
            parsedAllowedLanguages = null;
            logger.error("Unable to parse list of allowed languages: {}", e.getMessage());
            logger.debug("Error parsing list of allowed languages.", e);
        }

        this.allowedLanguages = parsedAllowedLanguages;

    }

    /**
     * Returns whether a language having the given key should be allowed to be
     * loaded. If language availability restrictions are imposed through
     * guacamole.properties, this may return false in some cases. By default,
     * this function will always return true. Note that just because a language
     * key is allowed to be loaded does not imply that the language key is
     * valid.
     *
     * @param languageKey
     *     The language key of the language to test.
     *
     * @return
     *     true if the given language key should be allowed to be loaded, false
     *     otherwise.
     */
    private boolean isLanguageAllowed(String languageKey) {

        // If no list is provided, all languages are implicitly available
        if (allowedLanguages == null)
            return true;

        return allowedLanguages.contains(languageKey);

    }

    /**
        // Skip loading of language if not allowed
        if (!isLanguageAllowed(key)) {
            logger.debug("OMITTING language: \"{}\"", key);
            return;
        }

import org.glyptodon.guacamole.properties.StringGuacamoleProperty;
    /**
     * Comma-separated list of all allowed languages, where each language is
     * represented by a language key, such as "en" or "en_US". If specified,
     * only languages within this list will be listed as available by the REST
     * service.
     */
    public static final StringSetProperty ALLOWED_LANGUAGES = new StringSetProperty() {

        @Override
        public String getName() { return "allowed-languages"; }

    };

    private final LanguageResourceService languageResourceService;
        this.languageResourceService = new LanguageResourceService(environment);
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
     * The set of all language keys which are explicitly listed as allowed
     * within guacamole.properties, or null if all defined languages should be
     * allowed.
     */
    private final Set<String> allowedLanguages;

    /**
     * Creates a new service for tracking and parsing available translations
     * which reads its configuration from the given environment.
     *
     * @param environment
     *     The environment from which the configuration properties of this
     *     service should be read.
     */
    public LanguageResourceService(Environment environment) {

        Set<String> parsedAllowedLanguages;

        // Parse list of available languages from properties
        try {
            parsedAllowedLanguages = environment.getProperty(BasicGuacamoleProperties.ALLOWED_LANGUAGES);
            logger.debug("Available languages will be restricted to: {}", parsedAllowedLanguages);
        }

        // Warn of failure to parse
        catch (GuacamoleException e) {
            parsedAllowedLanguages = null;
            logger.error("Unable to parse list of allowed languages: {}", e.getMessage());
            logger.debug("Error parsing list of allowed languages.", e);
        }

        this.allowedLanguages = parsedAllowedLanguages;

    }

    /**
     * Returns whether a language having the given key should be allowed to be
     * loaded. If language availability restrictions are imposed through
     * guacamole.properties, this may return false in some cases. By default,
     * this function will always return true. Note that just because a language
     * key is allowed to be loaded does not imply that the language key is
     * valid.
     *
     * @param languageKey
     *     The language key of the language to test.
     *
     * @return
     *     true if the given language key should be allowed to be loaded, false
     *     otherwise.
     */
    private boolean isLanguageAllowed(String languageKey) {

        // If no list is provided, all languages are implicitly available
        if (allowedLanguages == null)
            return true;

        return allowedLanguages.contains(languageKey);

    }

    /**
        // Skip loading of language if not allowed
        if (!isLanguageAllowed(key)) {
            logger.debug("OMITTING language: \"{}\"", key);
            return;
        }

import org.glyptodon.guacamole.properties.StringGuacamoleProperty;
    /**
     * Comma-separated list of all allowed languages, where each language is
     * represented by a language key, such as "en" or "en_US". If specified,
     * only languages within this list will be listed as available by the REST
     * service.
     */
    public static final StringSetProperty ALLOWED_LANGUAGES = new StringSetProperty() {

        @Override
        public String getName() { return "allowed-languages"; }

    };

     * The name of the connection associated with this connection record.
     */
    private String connectionName;

    /**

    /**
     * Returns the name of the connection associated with this connection
     * record.
     *
     * @return
     *     The name of the connection associated with this connection
     *     record.
     */
    public String getConnectionName() {
        return connectionName;
    }


    /**
     * Sets the name of the connection associated with this connection
     * record.
     *
     * @param connectionName
     *     The name of the connection to associate with this connection
     *     record.
     */
    public void setConnectionName(String connectionName) {
        this.connectionName = connectionName;
    }

    public String getConnectionName() {
        return model.getConnectionName();
    }

    @Override
    public String getConnectionName() {
        return connection.getName();
    }

    @Override
    
    /**
     * Returns the name of the connection associated with this connection
     * record.
     *
     * @return
     *     The name of the connection associated with this connection record.
     */
    public String getConnectionName();
     * The identifier of the connection associated with this record.
     */
    private final String connectionName;

    /**
        this.connectionName       = record.getConnectionName();
        this.startDate            = record.getStartDate();
        this.endDate              = record.getEndDate();
        this.remoteHost           = record.getRemoteHost();
        this.username             = record.getUsername();
        this.active               = record.isActive();
     * Returns the name of the connection associated with this record.
     *
     * @return
     *     The name of the connection associated with this record.
     */
    public String getConnectionName() {
        return connectionName;
    }

    /**
                parseInt(month, 1) - 1,
        connectionName(ConnectionRecordSet.SortableProperty.CONNECTION_NAME),
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/RESTExceptionWrapper.java
 * Copyright (C) 2015 Glyptodon LLC
 * A method interceptor which wraps custom exception handling around methods
 * which can throw GuacamoleExceptions and which are exposed through the REST
 * interface. The various types of GuacamoleExceptions are automatically
 * translated into appropriate HTTP responses, including JSON describing the
 * error that occurred.
 *
 * @author Michael Jumper
public class RESTExceptionWrapper implements MethodInterceptor {
        // Automatically translate GuacamoleExceptions for REST methods
            new RESTMethodMatcher(),
            new RESTExceptionWrapper()
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
     * @param authToken
     *     The token being invalidated.
     *
     * @throws GuacamoleException
     *     If the specified token does not exist.
    public void invalidateToken(@PathParam("token") String authToken)
            throws GuacamoleException {
            throw new GuacamoleResourceNotFoundException("No such token.");
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
            throw new GuacamoleClientException("Username in path does not match username provided JSON data.");
        if (userContext.self().getIdentifier().equals(user.getUsername()))
            throw new GuacamoleSecurityException("Permission denied.");
            if (authProvider.authenticateUser(credentials) == null)
                throw new GuacamoleSecurityException("Permission denied.");
            throw new GuacamoleSecurityException("Permission denied.");

     *
     * @throws GuacamoleException
     *     If the requested patch operation is not supported.
            PermissionType permission) throws GuacamoleException {
                throw new GuacamoleClientException("Unsupported patch operation: \""  operation  "\"");
                throw new GuacamoleClientException("Unsupported patch path: \""  path  "\"");
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/RESTExceptionWrapper.java
 * Copyright (C) 2015 Glyptodon LLC
 * A method interceptor which wraps custom exception handling around methods
 * which can throw GuacamoleExceptions and which are exposed through the REST
 * interface. The various types of GuacamoleExceptions are automatically
 * translated into appropriate HTTP responses, including JSON describing the
 * error that occurred.
 *
 * @author Michael Jumper
public class RESTExceptionWrapper implements MethodInterceptor {
        // Automatically translate GuacamoleExceptions for REST methods
            new RESTMethodMatcher(),
            new RESTExceptionWrapper()
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
     * @param authToken
     *     The token being invalidated.
     *
     * @throws GuacamoleException
     *     If the specified token does not exist.
    public void invalidateToken(@PathParam("token") String authToken)
            throws GuacamoleException {
            throw new GuacamoleResourceNotFoundException("No such token.");
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
            throw new GuacamoleClientException("Username in path does not match username provided JSON data.");
        if (userContext.self().getIdentifier().equals(user.getUsername()))
            throw new GuacamoleSecurityException("Permission denied.");
            if (authProvider.authenticateUser(credentials) == null)
                throw new GuacamoleSecurityException("Permission denied.");
            throw new GuacamoleSecurityException("Permission denied.");

     *
     * @throws GuacamoleException
     *     If the requested patch operation is not supported.
            PermissionType permission) throws GuacamoleException {
                throw new GuacamoleClientException("Unsupported patch operation: \""  operation  "\"");
                throw new GuacamoleClientException("Unsupported patch path: \""  path  "\"");
    private final LanguageResourceService languageResourceService;
        this.languageResourceService = new LanguageResourceService(environment);
import org.glyptodon.guacamole.GuacamoleException;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.net.basic.properties.BasicGuacamoleProperties;
     * The set of all language keys which are explicitly listed as allowed
     * within guacamole.properties, or null if all defined languages should be
     * allowed.
     */
    private final Set<String> allowedLanguages;

    /**
     * Creates a new service for tracking and parsing available translations
     * which reads its configuration from the given environment.
     *
     * @param environment
     *     The environment from which the configuration properties of this
     *     service should be read.
     */
    public LanguageResourceService(Environment environment) {

        Set<String> parsedAllowedLanguages;

        // Parse list of available languages from properties
        try {
            parsedAllowedLanguages = environment.getProperty(BasicGuacamoleProperties.ALLOWED_LANGUAGES);
            logger.debug("Available languages will be restricted to: {}", parsedAllowedLanguages);
        }

        // Warn of failure to parse
        catch (GuacamoleException e) {
            parsedAllowedLanguages = null;
            logger.error("Unable to parse list of allowed languages: {}", e.getMessage());
            logger.debug("Error parsing list of allowed languages.", e);
        }

        this.allowedLanguages = parsedAllowedLanguages;

    }

    /**
     * Returns whether a language having the given key should be allowed to be
     * loaded. If language availability restrictions are imposed through
     * guacamole.properties, this may return false in some cases. By default,
     * this function will always return true. Note that just because a language
     * key is allowed to be loaded does not imply that the language key is
     * valid.
     *
     * @param languageKey
     *     The language key of the language to test.
     *
     * @return
     *     true if the given language key should be allowed to be loaded, false
     *     otherwise.
     */
    private boolean isLanguageAllowed(String languageKey) {

        // If no list is provided, all languages are implicitly available
        if (allowedLanguages == null)
            return true;

        return allowedLanguages.contains(languageKey);

    }

    /**
        // Skip loading of language if not allowed
        if (!isLanguageAllowed(key)) {
            logger.debug("OMITTING language: \"{}\"", key);
            return;
        }

import org.glyptodon.guacamole.properties.StringGuacamoleProperty;
    /**
     * Comma-separated list of all allowed languages, where each language is
     * represented by a language key, such as "en" or "en_US". If specified,
     * only languages within this list will be listed as available by the REST
     * service.
     */
    public static final StringSetProperty ALLOWED_LANGUAGES = new StringSetProperty() {

        @Override
        public String getName() { return "allowed-languages"; }

    };

 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/RESTExceptionWrapper.java
 * Copyright (C) 2015 Glyptodon LLC
 * A method interceptor which wraps custom exception handling around methods
 * which can throw GuacamoleExceptions and which are exposed through the REST
 * interface. The various types of GuacamoleExceptions are automatically
 * translated into appropriate HTTP responses, including JSON describing the
 * error that occurred.
 *
 * @author Michael Jumper
public class RESTExceptionWrapper implements MethodInterceptor {
        // Automatically translate GuacamoleExceptions for REST methods
            new RESTMethodMatcher(),
            new RESTExceptionWrapper()
import org.glyptodon.guacamole.GuacamoleResourceNotFoundException;
     * @param authToken
     *     The token being invalidated.
     *
     * @throws GuacamoleException
     *     If the specified token does not exist.
    public void invalidateToken(@PathParam("token") String authToken)
            throws GuacamoleException {
            throw new GuacamoleResourceNotFoundException("No such token.");
import org.glyptodon.guacamole.GuacamoleClientException;
import org.glyptodon.guacamole.GuacamoleSecurityException;
            throw new GuacamoleClientException("Username in path does not match username provided JSON data.");
        if (userContext.self().getIdentifier().equals(user.getUsername()))
            throw new GuacamoleSecurityException("Permission denied.");
            if (authProvider.authenticateUser(credentials) == null)
                throw new GuacamoleSecurityException("Permission denied.");
            throw new GuacamoleSecurityException("Permission denied.");

     *
     * @throws GuacamoleException
     *     If the requested patch operation is not supported.
            PermissionType permission) throws GuacamoleException {
                throw new GuacamoleClientException("Unsupported patch operation: \""  operation  "\"");
                throw new GuacamoleClientException("Unsupported patch path: \""  path  "\"");
import java.util.Collection;
import org.glyptodon.guacamole.auth.jdbc.user.UserModel;

    /**
     * Searches for up to <code>limit</code> connection records that contain
     * the given terms, sorted by the given predicates, regardless of whether
     * the data they are associated with is is readable by any particular user.
     * This should only be called on behalf of a system administrator. If
     * records are needed by a non-administrative user who must have explicit
     * read rights, use searchReadable() instead.
     *
     * @param terms
     *     The search terms that must match the returned records.
     *
     * @param sortPredicates
     *     A list of predicates to sort the returned records by, in order of
     *     priority.
     *
     * @param limit
     *     The maximum number of records that should be returned.
     *
     * @return
     *     The results of the search performed with the given parameters.
     */
    List<ConnectionRecordModel> search(@Param("terms") Collection<ConnectionRecordSearchTerm> terms,
            @Param("sortPredicates") List<ConnectionRecordSortPredicate> sortPredicates,
            @Param("limit") int limit);

    /**
     * Searches for up to <code>limit</code> connection records that contain
     * the given terms, sorted by the given predicates. Only records that are
     * associated with data explicitly readable by the given user will be
     * returned. If records are needed by a system administrator (who, by
     * definition, does not need explicit read rights), use search() instead.
     *
     * @param user
     *    The user whose permissions should determine whether a record is
     *    returned.
     *
     * @param terms
     *     The search terms that must match the returned records.
     *
     * @param sortPredicates
     *     A list of predicates to sort the returned records by, in order of
     *     priority.
     *
     * @param limit
     *     The maximum number of records that should be returned.
     *
     * @return
     *     The results of the search performed with the given parameters.
     */
    List<ConnectionRecordModel> searchReadable(@Param("user") UserModel user,
            @Param("terms") Collection<ConnectionRecordSearchTerm> terms,
            @Param("sortPredicates") List<ConnectionRecordSortPredicate> sortPredicates,
            @Param("limit") int limit);

     * The name of the connection associated with this connection record.
     */
    private String connectionName;

    /**

    /**
     * Returns the name of the connection associated with this connection
     * record.
     *
     * @return
     *     The name of the connection associated with this connection
     *     record.
     */
    public String getConnectionName() {
        return connectionName;
    }


    /**
     * Sets the name of the connection associated with this connection
     * record.
     *
     * @param connectionName
     *     The name of the connection to associate with this connection
     *     record.
     */
    public void setConnectionName(String connectionName) {
        this.connectionName = connectionName;
    }

     * Returns a connection records object which is backed by the given model.
     *
     * @param model
     *     The model object to use to back the returned connection record
     *     object.
     *
     * @return
     *     A connection record object which is backed by the given model.
     */
    protected ConnectionRecord getObjectInstance(ConnectionRecordModel model) {
        return new ModeledConnectionRecord(model);
    }

    /**
     * Returns a list of connection records objects which are backed by the
     * models in the given list.
     *
     * @param models
     *     The model objects to use to back the connection record objects
     *     within the returned list.
     *
     * @return
     *     A list of connection record objects which are backed by the models
     *     in the given list.
     */
    protected List<ConnectionRecord> getObjectInstances(List<ConnectionRecordModel> models) {

        // Create new list of records by manually converting each model
        List<ConnectionRecord> objects = new ArrayList<ConnectionRecord>(models.size());
        for (ConnectionRecordModel model : models)
            objects.add(getObjectInstance(model));

        return objects;
 
    }

    /**

                records.add(getObjectInstance(model));



    /**
     * Retrieves the connection history records matching the given criteria.
     * Retrieves up to <code>limit</code> connection history records matching
     * the given terms and sorted by the given predicates. Only history records
     * associated with data that the given user can read are returned.
     *
     * @param user
     *     The user retrieving the connection history.
     *
     * @param requiredContents
     *     The search terms that must be contained somewhere within each of the
     *     returned records.
     *
     * @param sortPredicates
     *     A list of predicates to sort the returned records by, in order of
     *     priority.
     *
     * @param limit
     *     The maximum number of records that should be returned.
     *
     * @return
     *     The connection history of the given connection, including any
     *     active connections.
     *
     * @throws GuacamoleException
     *     If permission to read the connection history is denied.
     */
    public List<ConnectionRecord> retrieveHistory(AuthenticatedUser user,
            Collection<ConnectionRecordSearchTerm> requiredContents,
            List<ConnectionRecordSortPredicate> sortPredicates, int limit)
            throws GuacamoleException {

        List<ConnectionRecordModel> searchResults;

        // Bypass permission checks if the user is a system admin
        if (user.getUser().isAdministrator())
            searchResults = connectionRecordMapper.search(requiredContents,
                    sortPredicates, limit);

        // Otherwise only return explicitly readable history records
        else
            searchResults = connectionRecordMapper.searchReadable(user.getUser().getModel(),
                    requiredContents, sortPredicates, limit);

        return getObjectInstances(searchResults);

    }

    public String getConnectionIdentifier() {
        return model.getConnectionIdentifier();
    }

    @Override
    public String getConnectionName() {
        return model.getConnectionName();
    }

    @Override
    public String getConnectionIdentifier() {
        return connection.getIdentifier();
    }

    @Override
    public String getConnectionName() {
        return connection.getName();
    }

    @Override
import org.glyptodon.guacamole.auth.jdbc.connection.ConnectionRecordSet;
    /**
     * Provider for creating connection record sets.
     */
    @Inject
    private Provider<ConnectionRecordSet> connectionRecordSetProvider;
    
    public ConnectionRecordSet getConnectionHistory()
            throws GuacamoleException {
        ConnectionRecordSet connectionRecordSet = connectionRecordSetProvider.get();
        connectionRecordSet.init(getCurrentUser());
        return connectionRecordSet;
    }

    @Override
import org.glyptodon.guacamole.net.auth.ConnectionRecordSet;
import org.glyptodon.guacamole.net.auth.simple.SimpleConnectionRecordSet;
    public ConnectionRecordSet getConnectionHistory()
            throws GuacamoleException {
        return new SimpleConnectionRecordSet();
    }

    @Override
     * Returns the identifier of the connection associated with this
     * connection record.
     *
     * @return
     *     The identifier of the connection associated with this connection
     *     record.
     */
    public String getConnectionIdentifier();
    
    /**
     * Returns the name of the connection associated with this connection
     * record.
     *
     * @return
     *     The name of the connection associated with this connection record.
     */
    public String getConnectionName();

    /**
     * Retrieves all connection records visible to current user. The resulting
     * set of connection records can be further filtered and ordered using the
     * methods defined on ConnectionRecordSet.
     *
     * @return
     *     A set of all connection records visible to the current user.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the connection records.
     */
    ConnectionRecordSet getConnectionHistory() throws GuacamoleException;

    /**
import org.glyptodon.guacamole.net.auth.ConnectionRecordSet;
    public ConnectionRecordSet getConnectionHistory()
            throws GuacamoleException {
        return new SimpleConnectionRecordSet();
    }

    @Override
import org.glyptodon.guacamole.net.basic.rest.history.HistoryRESTService;
        bind(HistoryRESTService.class);
import org.glyptodon.guacamole.net.basic.rest.history.APIConnectionRecord;
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/history/APIConnectionRecord.java
package org.glyptodon.guacamole.net.basic.rest.history;
 *
     * The identifier of the connection associated with this record.
     */
    private final String connectionIdentifier;

    /**
     * The identifier of the connection associated with this record.
     */
    private final String connectionName;

    /**

        this.connectionIdentifier = record.getConnectionIdentifier();
        this.connectionName       = record.getConnectionName();
        this.startDate            = record.getStartDate();
        this.endDate              = record.getEndDate();
        this.remoteHost           = record.getRemoteHost();
        this.username             = record.getUsername();
        this.active               = record.isActive();
    }

    /**
     * Returns the identifier of the connection associated with this
     * record.
     *
     * @return
     *     The identifier of the connection associated with this record.
     */
    public String getConnectionIdentifier() {
        return connectionIdentifier;
    }

    /**
     * Returns the name of the connection associated with this record.
     *
     * @return
     *     The name of the connection associated with this record.
     */
    public String getConnectionName() {
        return connectionName;

import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
public class GuacamoleCredentialsException extends GuacamoleUnauthorizedException {
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import javax.ws.rs.FormParam;
import javax.ws.rs.QueryParam;
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
    /**
     * Logger for this class.
     */
    private final Logger logger = LoggerFactory.getLogger(RESTExceptionWrapper.class);

    /**
     * Determines whether the given parameter is associated with the HTTP
     * request parameter of the given name. For a parameter to be associated
     * with an HTTP request parameter, it must be annotated with either the
     * <code>@QueryParam</code> or <code>@FormParam</code> annotations.
     *
     * @param parameter
     *     The Java parameter to check.
     *
     * @param name
     *     The name of the HTTP request parameter.
     *
     * @return
     *     true if the given parameter is associated with the HTTP request
     *     parameter having the given name, false otherwise.
     */
    private boolean isRequestParameter(Parameter parameter, String name) {

        // Check if parameter is associated with the HTTP query string
        QueryParam queryParam = parameter.getAnnotation(QueryParam.class);
        if (queryParam != null && name.equals(queryParam.value()))
            return true;

        // Failing that, check whether the parameter is associated with the
        // HTTP request body
        FormParam formParam = parameter.getAnnotation(FormParam.class);
        return formParam != null && name.equals(formParam.value());

    }

    /**
     * Returns the authentication token that was passed in the given method
     * invocation. If the given method invocation is not associated with an
     * HTTP request (it lacks the appropriate JAX-RS annotations) or there is
     * no authentication token, null is returned.
     *
     * @param invocation
     *     The method invocation whose corresponding authentication token
     *     should be determined.
     *
     * @return
     *     The authentication token passed in the given method invocation, or
     *     null if there is no such token.
     */
    private String getAuthenticationToken(MethodInvocation invocation) {

        Method method = invocation.getMethod();

        // Iterate through all parameters, looking for the authentication token
        Parameter[] parameters = method.getParameters();
        for (int i = 0; i < parameters.length; i) {

            // Get current parameter
            Parameter parameter = parameters[i];

            // Only inspect String parameters
            if (parameter.getType() != String.class)
                continue;

            // Parameter must be declared as a REST service parameter
            if (!isRequestParameter(parameter, "token"))
                continue;

            // The token parameter has been found - return its value
            Object[] args = invocation.getArguments();
            return (String) args[i];

        }

        // No token parameter is defined
        return null;

    }


            // Invoke wrapped method
            try {
                return invocation.proceed();
            }

            // Ensure any associated session is invalidated if unauthorized
            catch (GuacamoleUnauthorizedException e) {

                // Pull authentication token from request
                String token = getAuthenticationToken(invocation);

                // If there is an associated auth token, invalidate it
                if (token != null) {
                    logger.debug("Implicitly invalidating token \"{}\" due to GuacamoleUnauthorizedException.", token);
                    // STUB - Does not actually invalidate anything at the moment
                }

                // Continue with exception processing
                throw e;

            }

            // Ensure internal errors are logged at the debug level

import java.lang.annotation.Annotation;
     * Determines whether the given set of annotations describes an HTTP
     * @param annotations
     *     The annotations associated with the Java parameter being checked.
     *     true if the given set of annotations describes an HTTP request
    private boolean isRequestParameter(Annotation[] annotations, String name) {
        // Search annotations for associated HTTP parameters
        for (Annotation annotation : annotations) {
            // Check if parameter is associated with the HTTP query string
            if (annotation instanceof QueryParam && name.equals(((QueryParam) annotation).value()))
                return true;

            // Failing that, check whether the parameter is associated with the
            // HTTP request body
            if (annotation instanceof FormParam && name.equals(((FormParam) annotation).value()))
                return true;

        }

        // No parameter annotations are present
        return false;
        // Get the types and annotations associated with each parameter
        Annotation[][] parameterAnnotations = method.getParameterAnnotations();
        Class<?>[] parameterTypes = method.getParameterTypes();
        // The Java standards require these to be parallel arrays
        assert(parameterAnnotations.length == parameterTypes.length);

        // Iterate through all parameters, looking for the authentication token
        for (int i = 0; i < parameterTypes.length; i) {
            Class<?> parameterType = parameterTypes[i];
            if (parameterType != String.class)
            Annotation[] annotations = parameterAnnotations[i];
            if (!isRequestParameter(annotations, "token"))
import org.glyptodon.guacamole.net.basic.rest.RESTServiceModule;
            new RESTServiceModule(sessionMap),
import org.glyptodon.guacamole.net.basic.rest.auth.TokenSessionMap;
     * Singleton instance of TokenSessionMap.
     */
    private final TokenSessionMap tokenSessionMap;

    /**
     * Creates an interceptor which automatically handles GuacamoleExceptions
     * within the REST services, including implicit invalidation of
     * authentication tokens.
     *
     * @param tokenSessionMap
     *     The singleton instance of TokenSessionMap to use if management of
     *     authentication tokens is required to handle a particular error.
     */
    public RESTExceptionWrapper(TokenSessionMap tokenSessionMap) {
        this.tokenSessionMap = tokenSessionMap;
    }

    /**
                if (token != null && tokenSessionMap.remove(token) != null)
                    logger.debug("Implicitly invalidated token \"{}\" due to GuacamoleUnauthorizedException.", token);
 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/RESTServiceModule.java
import org.glyptodon.guacamole.net.basic.rest.auth.AuthTokenGenerator;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
import org.glyptodon.guacamole.net.basic.rest.auth.SecureRandomAuthTokenGenerator;
import org.glyptodon.guacamole.net.basic.rest.auth.TokenSessionMap;
 * A Guice Module to set up the servlet mappings and authentication-specific
 * dependency injection for the Guacamole REST API.
 * @author Michael Jumper
public class RESTServiceModule extends ServletModule {

    /**
     * Singleton instance of TokenSessionMap.
     */
    private final TokenSessionMap tokenSessionMap;

    /**
     * Creates a module which handles binding of REST services and related
     * authentication objects, including the singleton TokenSessionMap.
     *
     * @param tokenSessionMap
     *     An instance of TokenSessionMap to inject as a singleton wherever
     *     needed.
     */
    public RESTServiceModule(TokenSessionMap tokenSessionMap) {
        this.tokenSessionMap = tokenSessionMap;
    }
        // Bind session map
        bind(TokenSessionMap.class).toInstance(tokenSessionMap);

        // Bind low-level services
        bind(AuthenticationService.class);
        bind(AuthTokenGenerator.class).to(SecureRandomAuthTokenGenerator.class);

            new RESTExceptionWrapper(tokenSessionMap)
import org.glyptodon.guacamole.net.basic.GuacamoleSession;
                GuacamoleSession session = tokenSessionMap.remove(token);
                if (session != null) {
                    session.invalidate();
                    logger.debug("Implicitly invalidated session for token \"{}\".", token);
                }
import com.google.inject.Inject;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
     * Service for authenticating users and managing their Guacamole sessions.
    @Inject
    private AuthenticationService authenticationService;
                if (authenticationService.destroyGuacamoleSession(token))
import org.aopalliance.intercept.MethodInterceptor;
        MethodInterceptor interceptor = new RESTExceptionWrapper();
        requestInjection(interceptor);
        bindInterceptor(Matchers.any(), new RESTMethodMatcher(), interceptor);
 * Copyright (C) 2015 Glyptodon LLC
import java.util.ArrayList;
import java.util.regex.Pattern;
import javax.servlet.http.HttpServletRequest;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleCredentialsException;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 * @author Michael Jumper

    /**
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(AuthenticationService.class);

    /**
     * The Guacamole server environment.
     */
    @Inject
    private Environment environment;

    /**
     * All configured authentication providers which can be used to
     * authenticate users or retrieve data associated with authenticated users.
     */
    @Inject
    private List<AuthenticationProvider> authProviders;


    /**
     * A generator for creating new auth tokens.
     */
    @Inject
    private AuthTokenGenerator authTokenGenerator;

    /**
     * Regular expression which matches any IPv4 address.
     */
    private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";

    /**
     * Regular expression which matches any IPv6 address.
     */
    private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";

    /**
     * Regular expression which matches any IP address, regardless of version.
     */
    private static final String IP_ADDRESS_REGEX = "("  IPV4_ADDRESS_REGEX  "|"  IPV6_ADDRESS_REGEX  ")";

    /**
     * Pattern which matches valid values of the de-facto standard
     * "X-Forwarded-For" header.
     */
    private static final Pattern X_FORWARDED_FOR = Pattern.compile("^"  IP_ADDRESS_REGEX  "(, "  IP_ADDRESS_REGEX  ")*$");

    /**
     * Returns a formatted string containing an IP address, or list of IP
     * addresses, which represent the HTTP client and any involved proxies. As
     * the headers used to determine proxies can easily be forged, this data is
     * superficially validated to ensure that it at least looks like a list of
     * IPs.
     *
     * @param request
     *     The HTTP request to format.
     *
     * @return
     *     A formatted string containing one or more IP addresses.
     */
    private String getLoggableAddress(HttpServletRequest request) {

        // Log X-Forwarded-For, if present and valid
        String header = request.getHeader("X-Forwarded-For");
        if (header != null && X_FORWARDED_FOR.matcher(header).matches())
            return "["  header  ", "  request.getRemoteAddr()  "]";

        // If header absent or invalid, just use source IP
        return request.getRemoteAddr();

    }

    /**
     * Attempts authentication against all AuthenticationProviders, in order,
     * using the provided credentials. The first authentication failure takes
     * priority, but remaining AuthenticationProviders are attempted. If any
     * AuthenticationProvider succeeds, the resulting AuthenticatedUser is
     * returned, and no further AuthenticationProviders are tried.
     *
     * @param credentials
     *     The credentials to use for authentication.
     *
     * @return
     *     The AuthenticatedUser given by the highest-priority
     *     AuthenticationProvider for which the given credentials are valid.
     *
     * @throws GuacamoleException
     *     If the given credentials are not valid for any
     *     AuthenticationProvider, or if an error occurs while authenticating
     *     the user.
     */
    private AuthenticatedUser authenticateUser(Credentials credentials)
        throws GuacamoleException {

        GuacamoleCredentialsException authFailure = null;

        // Attempt authentication against each AuthenticationProvider
        for (AuthenticationProvider authProvider : authProviders) {

            // Attempt authentication
            try {
                AuthenticatedUser authenticatedUser = authProvider.authenticateUser(credentials);
                if (authenticatedUser != null)
                    return authenticatedUser;
            }

            // First failure takes priority for now
            catch (GuacamoleCredentialsException e) {
                if (authFailure == null)
                    authFailure = e;
            }

        }

        // If a specific failure occured, rethrow that
        if (authFailure != null)
            throw authFailure;

        // Otherwise, request standard username/password
        throw new GuacamoleInvalidCredentialsException(
            "Permission Denied.",
            CredentialsInfo.USERNAME_PASSWORD
        );

    }

    /**
     * Re-authenticates the given AuthenticatedUser against the
     * AuthenticationProvider that originally created it, using the given
     * Credentials.
     *
     * @param authenticatedUser
     *     The AuthenticatedUser to re-authenticate.
     *
     * @param credentials
     *     The Credentials to use to re-authenticate the user.
     *
     * @return
     *     A AuthenticatedUser which may have been updated due to re-
     *     authentication.
     *
     * @throws GuacamoleException
     *     If an error prevents the user from being re-authenticated.
     */
    private AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // Get original AuthenticationProvider
        AuthenticationProvider authProvider = authenticatedUser.getAuthenticationProvider();

        // Re-authenticate the AuthenticatedUser against the original AuthenticationProvider only
        authenticatedUser = authProvider.updateAuthenticatedUser(authenticatedUser, credentials);
        if (authenticatedUser == null)
            throw new GuacamoleSecurityException("User re-authentication failed.");

        return authenticatedUser;

    }

    /**
     * Returns the AuthenticatedUser associated with the given session and
     * credentials, performing a fresh authentication and creating a new
     * AuthenticatedUser if necessary.
     *
     * @param existingSession
     *     The current GuacamoleSession, or null if no session exists yet.
     *
     * @param credentials
     *     The Credentials to use to authenticate the user.
     *
     * @return
     *     The AuthenticatedUser associated with the given session and
     *     credentials.
     *
     * @throws GuacamoleException
     *     If an error occurs while authenticating or re-authenticating the
     *     user.
     */
    private AuthenticatedUser getAuthenticatedUser(GuacamoleSession existingSession,
            Credentials credentials) throws GuacamoleException {

        try {

            // Re-authenticate user if session exists
            if (existingSession != null)
                return updateAuthenticatedUser(existingSession.getAuthenticatedUser(), credentials);

            // Otherwise, attempt authentication as a new user
            AuthenticatedUser authenticatedUser = AuthenticationService.this.authenticateUser(credentials);
            if (logger.isInfoEnabled())
                logger.info("User \"{}\" successfully authenticated from {}.",
                        authenticatedUser.getIdentifier(),
                        getLoggableAddress(credentials.getRequest()));

            return authenticatedUser;

        }

        // Log and rethrow any authentication errors
        catch (GuacamoleException e) {

            // Get request and username for sake of logging
            HttpServletRequest request = credentials.getRequest();
            String username = credentials.getUsername();

            // Log authentication failures with associated usernames
            if (username != null) {
                if (logger.isWarnEnabled())
                    logger.warn("Authentication attempt from {} for user \"{}\" failed.",
                            getLoggableAddress(request), username);
            }

            // Log anonymous authentication failures
            else if (logger.isDebugEnabled())
                logger.debug("Anonymous authentication attempt from {} failed.",
                        getLoggableAddress(request));

            // Rethrow exception
            throw e;

        }

    }

    /**
     * Returns all UserContexts associated with the given AuthenticatedUser,
     * updating existing UserContexts, if any. If no UserContexts are yet
     * associated with the given AuthenticatedUser, new UserContexts are
     * generated by polling each available AuthenticationProvider.
     *
     * @param existingSession
     *     The current GuacamoleSession, or null if no session exists yet.
     *
     * @param authenticatedUser
     *     The AuthenticatedUser that has successfully authenticated or re-
     *     authenticated.
     *
     * @return
     *     A List of all UserContexts associated with the given
     *     AuthenticatedUser.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating or updating any UserContext.
     */
    private List<UserContext> getUserContexts(GuacamoleSession existingSession,
            AuthenticatedUser authenticatedUser) throws GuacamoleException {

        List<UserContext> userContexts = new ArrayList<UserContext>(authProviders.size());

        // If UserContexts already exist, update them and add to the list
        if (existingSession != null) {

            // Update all old user contexts
            List<UserContext> oldUserContexts = existingSession.getUserContexts();
            for (UserContext oldUserContext : oldUserContexts) {

                // Update existing UserContext
                AuthenticationProvider authProvider = oldUserContext.getAuthenticationProvider();
                UserContext userContext = authProvider.updateUserContext(oldUserContext, authenticatedUser);

                // Add to available data, if successful
                if (userContext != null)
                    userContexts.add(userContext);

                // If unsuccessful, log that this happened, as it may be a bug
                else
                    logger.debug("AuthenticationProvider \"{}\" retroactively destroyed its UserContext.",
                            authProvider.getClass().getName());

            }

        }

        // Otherwise, create new UserContexts from available AuthenticationProviders
        else {

            // Get UserContexts from each available AuthenticationProvider
            for (AuthenticationProvider authProvider : authProviders) {

                // Generate new UserContext
                UserContext userContext = authProvider.getUserContext(authenticatedUser);

                // Add to available data, if successful
                if (userContext != null)
                    userContexts.add(userContext);

            }

        }

        return userContexts;

    }

    /**
     * Authenticates a user using the given credentials and optional
     * authentication token, returning the authentication token associated with
     * the user's Guacamole session, which may be newly generated. If an
     * existing token is provided, the authentication procedure will attempt to
     * update or reuse the provided token, but it is possible that a new token
     * will be returned. Note that this function CANNOT return null.
     *
     * @param credentials
     *     The credentials to use when authenticating the user.
     *
     * @param token
     *     The authentication token to use if attempting to re-authenticate an
     *     existing session, or null to request a new token.
     *
     * @return
     *     The authentication token associated with the newly created or
     *     existing session.
     *
     * @throws GuacamoleException
     *     If the authentication or re-authentication attempt fails.
     */
    public String authenticate(Credentials credentials, String token)
        throws GuacamoleException {

        // Pull existing session if token provided
        GuacamoleSession existingSession;
        if (token != null)
            existingSession = tokenSessionMap.get(token);
        else
            existingSession = null;

        // Get up-to-date AuthenticatedUser and associated UserContexts
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(existingSession, credentials);
        List<UserContext> userContexts = getUserContexts(existingSession, authenticatedUser);

        // Update existing session, if it exists
        String authToken;
        if (existingSession != null) {
            authToken = token;
            existingSession.setAuthenticatedUser(authenticatedUser);
            existingSession.setUserContexts(userContexts);
        }

        // If no existing session, generate a new token/session pair
        else {
            authToken = authTokenGenerator.getToken();
            tokenSessionMap.put(authToken, new GuacamoleSession(environment, authenticatedUser, userContexts));
            logger.debug("Login was successful for user \"{}\".", authenticatedUser.getIdentifier());
        }

        return authToken;

    }

     *
     * Invalidates a specific authentication token and its corresponding
     * Guacamole session, effectively logging out the associated user. If the
     * authentication token is not valid, this function has no effect.
     *
     * @param authToken
     *     The token being invalidated.
     *
     * @return
     *     true if the given authentication token was valid and the
     *     corresponding Guacamole session was destroyed, false if the given
     *     authentication token was not valid and no action was taken.
     */
    public boolean destroyGuacamoleSession(String authToken) {

        // Remove corresponding GuacamoleSession if the token is valid
        GuacamoleSession session = tokenSessionMap.remove(authToken);
        if (session == null)
            return false;

        // Invalidate the removed session
        session.invalidate();
        return true;

    }

    /**
     * Service for authenticating users and managing their Guacamole sessions.
    @Inject
    private AuthenticationService authenticationService;
        // Create/update session producing possibly-new token
        token = authenticationService.authenticate(credentials, token);
        // Pull corresponding session
        GuacamoleSession session = authenticationService.getGuacamoleSession(token);
        if (session == null)
            throw new GuacamoleResourceNotFoundException("No such token.");
        List<UserContext> userContexts = session.getUserContexts();
        AuthenticatedUser authenticatedUser = session.getAuthenticatedUser();
            token,
        // Invalidate session, if it exists
        if (!authenticationService.destroyGuacamoleSession(authToken))
            throw new GuacamoleResourceNotFoundException("No such token.");
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
    protected GuacamoleTunnel createAssociatedTunnel(GuacamoleTunnel tunnel,
            final GuacamoleSession session, final TunnelRequest.Type type,
        try {

            // Create connected tunnel using provided connection ID and client information
            GuacamoleTunnel tunnel = createConnectedTunnel(userContext, type, id, info);

            // Associate tunnel with session
            return createAssociatedTunnel(tunnel, session, type, id);

        }

        // Ensure any associated session is invalidated if unauthorized
        catch (GuacamoleUnauthorizedException e) {

            // If there is an associated auth token, invalidate it
            if (authenticationService.destroyGuacamoleSession(authToken))
                logger.debug("Implicitly invalidated session for token \"{}\".", authToken);

            // Continue with exception processing
            throw e;

        }
     * @param authToken
     *     The authentication token associated with the given session. If
     *     provided, this token will be automatically invalidated (and the
     *     corresponding session destroyed) if tunnel errors imply that the
     *     user is no longer authorized.
     *
            final String authToken,  final GuacamoleSession session,
            final TunnelRequest.Type type, final String id)
            throws GuacamoleException {
                try {

                    // Close and clean up tunnel
                    session.removeTunnel(getUUID().toString());
                    super.close();

                }

                // Ensure any associated session is invalidated if unauthorized
                catch (GuacamoleUnauthorizedException e) {

                    // If there is an associated auth token, invalidate it
                    if (authenticationService.destroyGuacamoleSession(authToken))
                        logger.debug("Implicitly invalidated session for token \"{}\".", authToken);

                    // Continue with exception processing
                    throw e;

                }
            return createAssociatedTunnel(tunnel, authToken, session, type, id);
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
public class GuacamoleCredentialsException extends GuacamoleUnauthorizedException {
import org.glyptodon.guacamole.net.basic.rest.RESTServiceModule;
            new RESTServiceModule(sessionMap),
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
     * @param authToken
     *     The authentication token associated with the given session. If
     *     provided, this token will be automatically invalidated (and the
     *     corresponding session destroyed) if tunnel errors imply that the
     *     user is no longer authorized.
     *
    protected GuacamoleTunnel createAssociatedTunnel(GuacamoleTunnel tunnel,
            final String authToken,  final GuacamoleSession session,
            final TunnelRequest.Type type, final String id)
            throws GuacamoleException {
                try {

                    // Close and clean up tunnel
                    session.removeTunnel(getUUID().toString());
                    super.close();

                }

                // Ensure any associated session is invalidated if unauthorized
                catch (GuacamoleUnauthorizedException e) {

                    // If there is an associated auth token, invalidate it
                    if (authenticationService.destroyGuacamoleSession(authToken))
                        logger.debug("Implicitly invalidated session for token \"{}\".", authToken);

                    // Continue with exception processing
                    throw e;

                }
        try {

            // Create connected tunnel using provided connection ID and client information
            GuacamoleTunnel tunnel = createConnectedTunnel(userContext, type, id, info);

            // Associate tunnel with session
            return createAssociatedTunnel(tunnel, authToken, session, type, id);

        }

        // Ensure any associated session is invalidated if unauthorized
        catch (GuacamoleUnauthorizedException e) {

            // If there is an associated auth token, invalidate it
            if (authenticationService.destroyGuacamoleSession(authToken))
                logger.debug("Implicitly invalidated session for token \"{}\".", authToken);

            // Continue with exception processing
            throw e;

        }
import com.google.inject.Inject;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import javax.ws.rs.FormParam;
import javax.ws.rs.QueryParam;
import org.glyptodon.guacamole.GuacamoleUnauthorizedException;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
    /**
     * Logger for this class.
     */
    private final Logger logger = LoggerFactory.getLogger(RESTExceptionWrapper.class);

    /**
     * Service for authenticating users and managing their Guacamole sessions.
     */
    @Inject
    private AuthenticationService authenticationService;

    /**
     * Determines whether the given set of annotations describes an HTTP
     * request parameter of the given name. For a parameter to be associated
     * with an HTTP request parameter, it must be annotated with either the
     * <code>@QueryParam</code> or <code>@FormParam</code> annotations.
     *
     * @param annotations
     *     The annotations associated with the Java parameter being checked.
     *
     * @param name
     *     The name of the HTTP request parameter.
     *
     * @return
     *     true if the given set of annotations describes an HTTP request
     *     parameter having the given name, false otherwise.
     */
    private boolean isRequestParameter(Annotation[] annotations, String name) {

        // Search annotations for associated HTTP parameters
        for (Annotation annotation : annotations) {

            // Check if parameter is associated with the HTTP query string
            if (annotation instanceof QueryParam && name.equals(((QueryParam) annotation).value()))
                return true;

            // Failing that, check whether the parameter is associated with the
            // HTTP request body
            if (annotation instanceof FormParam && name.equals(((FormParam) annotation).value()))
                return true;

        }

        // No parameter annotations are present
        return false;

    }

    /**
     * Returns the authentication token that was passed in the given method
     * invocation. If the given method invocation is not associated with an
     * HTTP request (it lacks the appropriate JAX-RS annotations) or there is
     * no authentication token, null is returned.
     *
     * @param invocation
     *     The method invocation whose corresponding authentication token
     *     should be determined.
     *
     * @return
     *     The authentication token passed in the given method invocation, or
     *     null if there is no such token.
     */
    private String getAuthenticationToken(MethodInvocation invocation) {

        Method method = invocation.getMethod();

        // Get the types and annotations associated with each parameter
        Annotation[][] parameterAnnotations = method.getParameterAnnotations();
        Class<?>[] parameterTypes = method.getParameterTypes();

        // The Java standards require these to be parallel arrays
        assert(parameterAnnotations.length == parameterTypes.length);

        // Iterate through all parameters, looking for the authentication token
        for (int i = 0; i < parameterTypes.length; i) {

            // Only inspect String parameters
            Class<?> parameterType = parameterTypes[i];
            if (parameterType != String.class)
                continue;

            // Parameter must be declared as a REST service parameter
            Annotation[] annotations = parameterAnnotations[i];
            if (!isRequestParameter(annotations, "token"))
                continue;

            // The token parameter has been found - return its value
            Object[] args = invocation.getArguments();
            return (String) args[i];

        }

        // No token parameter is defined
        return null;

    }


            // Invoke wrapped method
            try {
                return invocation.proceed();
            }

            // Ensure any associated session is invalidated if unauthorized
            catch (GuacamoleUnauthorizedException e) {

                // Pull authentication token from request
                String token = getAuthenticationToken(invocation);

                // If there is an associated auth token, invalidate it
                if (authenticationService.destroyGuacamoleSession(token))
                    logger.debug("Implicitly invalidated session for token \"{}\".", token);

                // Continue with exception processing
                throw e;

            }

            // Ensure internal errors are logged at the debug level

 b/guacamole/src/main/java/org/glyptodon/guacamole/net/basic/rest/RESTServiceModule.java
import org.aopalliance.intercept.MethodInterceptor;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthTokenGenerator;
import org.glyptodon.guacamole.net.basic.rest.auth.AuthenticationService;
import org.glyptodon.guacamole.net.basic.rest.auth.SecureRandomAuthTokenGenerator;
import org.glyptodon.guacamole.net.basic.rest.auth.TokenSessionMap;
 * A Guice Module to set up the servlet mappings and authentication-specific
 * dependency injection for the Guacamole REST API.
 * @author Michael Jumper
public class RESTServiceModule extends ServletModule {

    /**
     * Singleton instance of TokenSessionMap.
     */
    private final TokenSessionMap tokenSessionMap;

    /**
     * Creates a module which handles binding of REST services and related
     * authentication objects, including the singleton TokenSessionMap.
     *
     * @param tokenSessionMap
     *     An instance of TokenSessionMap to inject as a singleton wherever
     *     needed.
     */
    public RESTServiceModule(TokenSessionMap tokenSessionMap) {
        this.tokenSessionMap = tokenSessionMap;
    }
        // Bind session map
        bind(TokenSessionMap.class).toInstance(tokenSessionMap);

        // Bind low-level services
        bind(AuthenticationService.class);
        bind(AuthTokenGenerator.class).to(SecureRandomAuthTokenGenerator.class);

        MethodInterceptor interceptor = new RESTExceptionWrapper();
        requestInjection(interceptor);
        bindInterceptor(Matchers.any(), new RESTMethodMatcher(), interceptor);
 * Copyright (C) 2015 Glyptodon LLC
import java.util.ArrayList;
import java.util.regex.Pattern;
import javax.servlet.http.HttpServletRequest;
import org.glyptodon.guacamole.GuacamoleSecurityException;
import org.glyptodon.guacamole.environment.Environment;
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.net.auth.AuthenticationProvider;
import org.glyptodon.guacamole.net.auth.Credentials;
import org.glyptodon.guacamole.net.auth.credentials.CredentialsInfo;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleCredentialsException;
import org.glyptodon.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 * @author Michael Jumper

    /**
     * Logger for this class.
     */
    private static final Logger logger = LoggerFactory.getLogger(AuthenticationService.class);

    /**
     * The Guacamole server environment.
     */
    @Inject
    private Environment environment;

    /**
     * All configured authentication providers which can be used to
     * authenticate users or retrieve data associated with authenticated users.
     */
    @Inject
    private List<AuthenticationProvider> authProviders;


    /**
     * A generator for creating new auth tokens.
     */
    @Inject
    private AuthTokenGenerator authTokenGenerator;

    /**
     * Regular expression which matches any IPv4 address.
     */
    private static final String IPV4_ADDRESS_REGEX = "([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})";

    /**
     * Regular expression which matches any IPv6 address.
     */
    private static final String IPV6_ADDRESS_REGEX = "([0-9a-fA-F]*(:[0-9a-fA-F]*){0,7})";

    /**
     * Regular expression which matches any IP address, regardless of version.
     */
    private static final String IP_ADDRESS_REGEX = "("  IPV4_ADDRESS_REGEX  "|"  IPV6_ADDRESS_REGEX  ")";

    /**
     * Pattern which matches valid values of the de-facto standard
     * "X-Forwarded-For" header.
     */
    private static final Pattern X_FORWARDED_FOR = Pattern.compile("^"  IP_ADDRESS_REGEX  "(, "  IP_ADDRESS_REGEX  ")*$");

    /**
     * Returns a formatted string containing an IP address, or list of IP
     * addresses, which represent the HTTP client and any involved proxies. As
     * the headers used to determine proxies can easily be forged, this data is
     * superficially validated to ensure that it at least looks like a list of
     * IPs.
     *
     * @param request
     *     The HTTP request to format.
     *
     * @return
     *     A formatted string containing one or more IP addresses.
     */
    private String getLoggableAddress(HttpServletRequest request) {

        // Log X-Forwarded-For, if present and valid
        String header = request.getHeader("X-Forwarded-For");
        if (header != null && X_FORWARDED_FOR.matcher(header).matches())
            return "["  header  ", "  request.getRemoteAddr()  "]";

        // If header absent or invalid, just use source IP
        return request.getRemoteAddr();

    }

    /**
     * Attempts authentication against all AuthenticationProviders, in order,
     * using the provided credentials. The first authentication failure takes
     * priority, but remaining AuthenticationProviders are attempted. If any
     * AuthenticationProvider succeeds, the resulting AuthenticatedUser is
     * returned, and no further AuthenticationProviders are tried.
     *
     * @param credentials
     *     The credentials to use for authentication.
     *
     * @return
     *     The AuthenticatedUser given by the highest-priority
     *     AuthenticationProvider for which the given credentials are valid.
     *
     * @throws GuacamoleException
     *     If the given credentials are not valid for any
     *     AuthenticationProvider, or if an error occurs while authenticating
     *     the user.
     */
    private AuthenticatedUser authenticateUser(Credentials credentials)
        throws GuacamoleException {

        GuacamoleCredentialsException authFailure = null;

        // Attempt authentication against each AuthenticationProvider
        for (AuthenticationProvider authProvider : authProviders) {

            // Attempt authentication
            try {
                AuthenticatedUser authenticatedUser = authProvider.authenticateUser(credentials);
                if (authenticatedUser != null)
                    return authenticatedUser;
            }

            // First failure takes priority for now
            catch (GuacamoleCredentialsException e) {
                if (authFailure == null)
                    authFailure = e;
            }

        }

        // If a specific failure occured, rethrow that
        if (authFailure != null)
            throw authFailure;

        // Otherwise, request standard username/password
        throw new GuacamoleInvalidCredentialsException(
            "Permission Denied.",
            CredentialsInfo.USERNAME_PASSWORD
        );

    }

    /**
     * Re-authenticates the given AuthenticatedUser against the
     * AuthenticationProvider that originally created it, using the given
     * Credentials.
     *
     * @param authenticatedUser
     *     The AuthenticatedUser to re-authenticate.
     *
     * @param credentials
     *     The Credentials to use to re-authenticate the user.
     *
     * @return
     *     A AuthenticatedUser which may have been updated due to re-
     *     authentication.
     *
     * @throws GuacamoleException
     *     If an error prevents the user from being re-authenticated.
     */
    private AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // Get original AuthenticationProvider
        AuthenticationProvider authProvider = authenticatedUser.getAuthenticationProvider();

        // Re-authenticate the AuthenticatedUser against the original AuthenticationProvider only
        authenticatedUser = authProvider.updateAuthenticatedUser(authenticatedUser, credentials);
        if (authenticatedUser == null)
            throw new GuacamoleSecurityException("User re-authentication failed.");

        return authenticatedUser;

    }

    /**
     * Returns the AuthenticatedUser associated with the given session and
     * credentials, performing a fresh authentication and creating a new
     * AuthenticatedUser if necessary.
     *
     * @param existingSession
     *     The current GuacamoleSession, or null if no session exists yet.
     *
     * @param credentials
     *     The Credentials to use to authenticate the user.
     *
     * @return
     *     The AuthenticatedUser associated with the given session and
     *     credentials.
     *
     * @throws GuacamoleException
     *     If an error occurs while authenticating or re-authenticating the
     *     user.
     */
    private AuthenticatedUser getAuthenticatedUser(GuacamoleSession existingSession,
            Credentials credentials) throws GuacamoleException {

        try {

            // Re-authenticate user if session exists
            if (existingSession != null)
                return updateAuthenticatedUser(existingSession.getAuthenticatedUser(), credentials);

            // Otherwise, attempt authentication as a new user
            AuthenticatedUser authenticatedUser = AuthenticationService.this.authenticateUser(credentials);
            if (logger.isInfoEnabled())
                logger.info("User \"{}\" successfully authenticated from {}.",
                        authenticatedUser.getIdentifier(),
                        getLoggableAddress(credentials.getRequest()));

            return authenticatedUser;

        }

        // Log and rethrow any authentication errors
        catch (GuacamoleException e) {

            // Get request and username for sake of logging
            HttpServletRequest request = credentials.getRequest();
            String username = credentials.getUsername();

            // Log authentication failures with associated usernames
            if (username != null) {
                if (logger.isWarnEnabled())
                    logger.warn("Authentication attempt from {} for user \"{}\" failed.",
                            getLoggableAddress(request), username);
            }

            // Log anonymous authentication failures
            else if (logger.isDebugEnabled())
                logger.debug("Anonymous authentication attempt from {} failed.",
                        getLoggableAddress(request));

            // Rethrow exception
            throw e;

        }

    }

    /**
     * Returns all UserContexts associated with the given AuthenticatedUser,
     * updating existing UserContexts, if any. If no UserContexts are yet
     * associated with the given AuthenticatedUser, new UserContexts are
     * generated by polling each available AuthenticationProvider.
     *
     * @param existingSession
     *     The current GuacamoleSession, or null if no session exists yet.
     *
     * @param authenticatedUser
     *     The AuthenticatedUser that has successfully authenticated or re-
     *     authenticated.
     *
     * @return
     *     A List of all UserContexts associated with the given
     *     AuthenticatedUser.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating or updating any UserContext.
     */
    private List<UserContext> getUserContexts(GuacamoleSession existingSession,
            AuthenticatedUser authenticatedUser) throws GuacamoleException {

        List<UserContext> userContexts = new ArrayList<UserContext>(authProviders.size());

        // If UserContexts already exist, update them and add to the list
        if (existingSession != null) {

            // Update all old user contexts
            List<UserContext> oldUserContexts = existingSession.getUserContexts();
            for (UserContext oldUserContext : oldUserContexts) {

                // Update existing UserContext
                AuthenticationProvider authProvider = oldUserContext.getAuthenticationProvider();
                UserContext userContext = authProvider.updateUserContext(oldUserContext, authenticatedUser);

                // Add to available data, if successful
                if (userContext != null)
                    userContexts.add(userContext);

                // If unsuccessful, log that this happened, as it may be a bug
                else
                    logger.debug("AuthenticationProvider \"{}\" retroactively destroyed its UserContext.",
                            authProvider.getClass().getName());

            }

        }

        // Otherwise, create new UserContexts from available AuthenticationProviders
        else {

            // Get UserContexts from each available AuthenticationProvider
            for (AuthenticationProvider authProvider : authProviders) {

                // Generate new UserContext
                UserContext userContext = authProvider.getUserContext(authenticatedUser);

                // Add to available data, if successful
                if (userContext != null)
                    userContexts.add(userContext);

            }

        }

        return userContexts;

    }

    /**
     * Authenticates a user using the given credentials and optional
     * authentication token, returning the authentication token associated with
     * the user's Guacamole session, which may be newly generated. If an
     * existing token is provided, the authentication procedure will attempt to
     * update or reuse the provided token, but it is possible that a new token
     * will be returned. Note that this function CANNOT return null.
     *
     * @param credentials
     *     The credentials to use when authenticating the user.
     *
     * @param token
     *     The authentication token to use if attempting to re-authenticate an
     *     existing session, or null to request a new token.
     *
     * @return
     *     The authentication token associated with the newly created or
     *     existing session.
     *
     * @throws GuacamoleException
     *     If the authentication or re-authentication attempt fails.
     */
    public String authenticate(Credentials credentials, String token)
        throws GuacamoleException {

        // Pull existing session if token provided
        GuacamoleSession existingSession;
        if (token != null)
            existingSession = tokenSessionMap.get(token);
        else
            existingSession = null;

        // Get up-to-date AuthenticatedUser and associated UserContexts
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(existingSession, credentials);
        List<UserContext> userContexts = getUserContexts(existingSession, authenticatedUser);

        // Update existing session, if it exists
        String authToken;
        if (existingSession != null) {
            authToken = token;
            existingSession.setAuthenticatedUser(authenticatedUser);
            existingSession.setUserContexts(userContexts);
        }

        // If no existing session, generate a new token/session pair
        else {
            authToken = authTokenGenerator.getToken();
            tokenSessionMap.put(authToken, new GuacamoleSession(environment, authenticatedUser, userContexts));
            logger.debug("Login was successful for user \"{}\".", authenticatedUser.getIdentifier());
        }

        return authToken;

    }

     *
     * Invalidates a specific authentication token and its corresponding
     * Guacamole session, effectively logging out the associated user. If the
     * authentication token is not valid, this function has no effect.
     *
     * @param authToken
     *     The token being invalidated.
     *
     * @return
     *     true if the given authentication token was valid and the
     *     corresponding Guacamole session was destroyed, false if the given
     *     authentication token was not valid and no action was taken.
     */
    public boolean destroyGuacamoleSession(String authToken) {

        // Remove corresponding GuacamoleSession if the token is valid
        GuacamoleSession session = tokenSessionMap.remove(authToken);
        if (session == null)
            return false;

        // Invalidate the removed session
        session.invalidate();
        return true;

    }

    /**
     * Service for authenticating users and managing their Guacamole sessions.
    @Inject
    private AuthenticationService authenticationService;
        // Create/update session producing possibly-new token
        token = authenticationService.authenticate(credentials, token);
        // Pull corresponding session
        GuacamoleSession session = authenticationService.getGuacamoleSession(token);
        if (session == null)
            throw new GuacamoleResourceNotFoundException("No such token.");
        List<UserContext> userContexts = session.getUserContexts();
        AuthenticatedUser authenticatedUser = session.getAuthenticatedUser();
            token,
        // Invalidate session, if it exists
        if (!authenticationService.destroyGuacamoleSession(authToken))
            throw new GuacamoleResourceNotFoundException("No such token.");
import java.util.List;
     * Determines the DN which corresponds to the user having the given
     * username. The DN will either be derived directly from the user base DN,
     * or queried from the LDAP server, depending on how LDAP authentication
     * has been configured.
     *
     * @param username
     *     The username of the user whose corresponding DN should be returned.
     *
     * @return
     *     The DN which corresponds to the user having the given username.
     *
     * @throws GuacamoleException
     *     If required properties are missing, and thus the user DN cannot be
     *     determined.
     */
    private String getUserBindDN(String username)
            throws GuacamoleException {

        // Pull username attributes from properties
        List<String> usernameAttributes = confService.getUsernameAttributes();
        if (usernameAttributes.isEmpty())
            return null;

        // We need exactly one base DN to derive the user DN
        if (usernameAttributes.size() != 1)
            return null;

        // Derive user DN from base DN
        return
                    escapingService.escapeDN(usernameAttributes.get(0))
             "="  escapingService.escapeDN(username)
             ","  confService.getUserBaseDN();

    }

    /**
        // Get username and password from credentials
        String username = credentials.getUsername();
        String password = credentials.getPassword();

        if (username == null || username.isEmpty()) {
        if (password == null || password.isEmpty()) {
            // Determine user DN
            String userDN = getUserBindDN(username);
            if (userDN == null) {
                logger.error("Unable to determine DN for user \"{}\".", username);
                return null;
            }
                        password.getBytes("UTF-8"));
    /**
     * Returns an AuthenticatedUser representing the user authenticated by the
     * given credentials.
     *
     * @param credentials
     *     The credentials to use for authentication.
     *
     * @return
     *     An AuthenticatedUser representing the user authenticated by the
     *     given credentials.
     *
     * @throws GuacamoleException
     *     If an error occurs while authenticating the user, or if access is
     *     denied.
     */
        LDAPConnection ldapConnection;
        try {
            ldapConnection = bindAs(credentials);
        }
        catch (GuacamoleException e) {
            logger.error("Cannot bind with LDAP server: {}", e.getMessage());
            logger.debug("Error binding with LDAP server.", e);
            ldapConnection = null;
        }

        // If bind fails, permission to login is denied
import java.util.Collections;
import java.util.List;
     * Returns all username attributes which should be used to query and bind
     *     The username attributes which should be used to query and bind users
    public List<String> getUsernameAttributes() throws GuacamoleException {
            Collections.singletonList("uid")
     * The attribute or attributes which identify users. One of these
     * attributes must be present within the each Guacamole user's record in
     * the LDAP directory. If the LDAP authentication will not be given its own
     * credentials for querying other LDAP users, this list may contain only
     * one attribute, and the concatenation of that attribute and the value of
     * LDAP_USER_BASE_DN must equal the user's full DN.
    public static final StringListProperty LDAP_USERNAME_ATTRIBUTE = new StringListProperty() {
     * Adds all Guacamole users accessible to the user currently bound under
     * the given LDAP connection to the provided map. Only users with the
     * specified attribute are added. If the same username is encountered
     * multiple times, warnings about possible ambiguity will be logged.
     *
     * @param ldapConnection
     *     The current connection to the LDAP server, associated with the
     *     current user.
     *
     * @return
     *     All users accessible to the user currently bound under the given
     *     LDAP connection, as a map of connection identifier to corresponding
     *     user object.
     *
     * @throws GuacamoleException
     *     If an error occurs preventing retrieval of users.
     */
    private void putAllUsers(Map<String, User> users, LDAPConnection ldapConnection,
            String usernameAttribute) throws GuacamoleException {

        try {

            // Find all Guacamole users underneath base DN
            LDAPSearchResults results = ldapConnection.search(
                confService.getUserBaseDN(),
                LDAPConnection.SCOPE_SUB,
                "(&(objectClass=*)("  escapingService.escapeLDAPSearchFilter(usernameAttribute)  "=*))",
                null,
                false
            );

            // Read all visible users
            while (results.hasMore()) {

                LDAPEntry entry = results.next();

                // Get username from record
                LDAPAttribute username = entry.getAttribute(usernameAttribute);
                if (username == null) {
                    logger.warn("Queried user is missing the username attribute \"{}\".", usernameAttribute);
                    continue;
                }

                // Store user using their username as the identifier
                String identifier = username.getStringValue();
                if (users.put(identifier, new SimpleUser(identifier)) != null)
                    logger.warn("Possibly ambiguous user account: \"{}\".", identifier);

            }

        }
        catch (LDAPException e) {
            throw new GuacamoleServerException("Error while querying users.", e);
        }

    }

    /**
        // Build map of users by querying each username attribute separately
        Map<String, User> users = new HashMap<String, User>();
        for (String usernameAttribute : confService.getUsernameAttributes())
            putAllUsers(users, ldapConnection, usernameAttribute);
        // Return map of all users
        return users;
     * The base DN of users. All users must be contained somewhere within the
     * subtree of this DN. If the LDAP authentication will not be given its own
     * credentials for querying other LDAP users, all users must be direct
     * children of this base DN, varying only by LDAP_USERNAME_ATTRIBUTE.
        for (String usernameAttribute : confService.getUsernameAttributes()) {

            // Attempt to pull all users with given attribute
            try {
                putAllUsers(users, ldapConnection, usernameAttribute);
            }

            // Log any errors non-fatally
            catch (GuacamoleException e) {
                logger.warn("Could not query list of all users for attribute \"{}\": {}",
                        usernameAttribute, e.getMessage());
                logger.debug("Error querying list of all users.", e);
            }

        }
    /**
     * The DN of the user that the LDAP authentication should bind as when
     * searching for the user accounts of users attempting to log in. If not
     * specified, the DNs of users attempting to log in will be derived from
     * the LDAP_BASE_DN and LDAP_USERNAME_ATTRIBUTE directly.
     */
    public static final StringGuacamoleProperty LDAP_SEARCH_BIND_DN = new StringGuacamoleProperty() {

        @Override
        public String getName() { return "ldap-search-bind-dn"; }

    };

    /**
     * The password to provide to the LDAP server when binding as
     * LDAP_SEARCH_BIND_DN. If LDAP_SEARCH_BIND_DN is not specified, this
     * property has no effect. If this property is not specified, no password
     * will be provided when attempting to bind as LDAP_SEARCH_BIND_DN.
     */
    public static final StringGuacamoleProperty LDAP_SEARCH_BIND_PASSWORD = new StringGuacamoleProperty() {

        @Override
        public String getName() { return "ldap-search-bind-password"; }

    };

        List<String> stringValues = Arrays.asList(DELIMITER_PATTERN.split(values));
        if (stringValues.isEmpty())
            return null;

        return stringValues;
        if (usernameAttributes.size() != 1) {
            logger.warn("Cannot directly derive user DN when multiple username attributes are specified");
        }
     * Binds to the LDAP server using the provided user DN and password.
     * @param userDN
     *     The DN of the user to bind as, or null to bind anonymously.
     *
     * @param password
     *     The password to use when binding as the specified user, or null to
     *     attempt to bind without a password.
    private LDAPConnection bindAs(String userDN, String password)
            throws GuacamoleException {
        
    }

    /**
     * Binds to the LDAP server using the provided Guacamole credentials. The
     * DN of the user is derived using the LDAP configuration properties
     * provided in guacamole.properties, as is the server hostname and port
     * information.
     *
     * @param credentials
     *     The credentials to use to bind to the LDAP server.
     *
     * @return
     *     A bound LDAP connection, or null if the connection could not be
     *     bound.
     *
     * @throws GuacamoleException
     *     If an error occurs while binding to the LDAP server.
     */
    private LDAPConnection bindAs(Credentials credentials)
        throws GuacamoleException {

        // Get username and password from credentials
        String username = credentials.getUsername();
        String password = credentials.getPassword();

        // Require username
        if (username == null || username.isEmpty()) {
            logger.debug("Anonymous bind is not currently allowed by the LDAP authentication provider.");
            return null;
        }

        // Require password, and do not allow anonymous binding
        if (password == null || password.isEmpty()) {
            logger.debug("Anonymous bind is not currently allowed by the LDAP authentication provider.");
            return null;
        }

        // Determine user DN
        String userDN = getUserBindDN(username);
        if (userDN == null) {
            logger.error("Unable to determine DN for user \"{}\".", username);
            return null;
        }

        // Bind using user's DN
        return bindAs(userDN, password);
import java.util.ArrayList;
import java.util.List;
    /**
     * Generates a properly-escaped LDAP query which finds all objects having
     * at least one username attribute set to the specified username, where
     * the possible username attributes are defined within
     * guacamole.properties.
     *
     * @param username
     *     The username that the resulting LDAP query should search for within
     *     objects within the LDAP directory.
     *
     * @return
     *     An LDAP query which will search for arbitrary LDAP objects
     *     containing at least one username attribute set to the specified
     *     username.
     *
     * @throws GuacamoleException
     *     If the LDAP query cannot be generated because the list of username
     *     attributes cannot be parsed from guacamole.properties.
     */
    private String generateLDAPQuery(String username)
            throws GuacamoleException {

        List<String> usernameAttributes = confService.getUsernameAttributes();

        // Build LDAP query for users having at least one username attribute
        // with the specified username as its value
        StringBuilder ldapQuery = new StringBuilder("(&(objectClass=*)");

        // Include all attributes within OR clause if there are more than one
        if (usernameAttributes.size() > 1)
            ldapQuery.append("(|");

        // Add equality comparison for each possible username attribute
        for (String usernameAttribute : usernameAttributes) {
            ldapQuery.append("(");
            ldapQuery.append(escapingService.escapeLDAPSearchFilter(usernameAttribute));
            ldapQuery.append("=");
            ldapQuery.append(escapingService.escapeLDAPSearchFilter(username));
            ldapQuery.append(")");
        }

        // Close OR clause, if any
        if (usernameAttributes.size() > 1)
            ldapQuery.append(")");

        return ldapQuery.toString();

    }

    /**
     * Returns a list of all DNs corresponding to the users having the given
     * username. If multiple username attributes are defined, or if uniqueness
     * is not enforced across the username attribute, it is possible that this
     * will return multiple DNs.
     *
     * @param ldapConnection
     *     The connection to the LDAP server to use when querying user DNs.
     *
     * @param username
     *     The username of the user whose corresponding user account DNs are
     *     to be retrieved.
     *
     * @return
     *     A list of all DNs corresponding to the users having the given
     *     username. If no such DNs exist, this list will be empty.
     *
     * @throws GuacamoleException
     *     If an error occurs while querying the user DNs, or if the username
     *     attribute property cannot be parsed within guacamole.properties.
     */
    public List<String> getUserDNs(LDAPConnection ldapConnection,
            String username) throws GuacamoleException {

        try {

            List<String> userDNs = new ArrayList<String>();

            // Find all Guacamole users underneath base DN and matching the
            // specified username
            LDAPSearchResults results = ldapConnection.search(
                confService.getUserBaseDN(),
                LDAPConnection.SCOPE_SUB,
                generateLDAPQuery(username),
                null,
                false
            );

            // Add all DNs for found users
            while (results.hasMore()) {
                LDAPEntry entry = results.next();
                userDNs.add(entry.getDN());
            }

            // Return all discovered DNs (if any)
            return userDNs;

        }
        catch (LDAPException e) {
            throw new GuacamoleServerException("Error while query user DNs.", e);
        }

    }

import org.glyptodon.guacamole.auth.ldap.user.UserService;
     * Service for retrieving users and their corresponding LDAP DNs.
     */
    @Inject
    private UserService userService;

    /**
        return userService.deriveUserDN(username);
    /**
     * Determines the DN which corresponds to the user having the given
     * username. The DN will either be derived directly from the user base DN,
     * or queried from the LDAP server, depending on how LDAP authentication
     * has been configured.
     *
     * @param username
     *     The username of the user whose corresponding DN should be returned.
     *
     * @return
     *     The DN which corresponds to the user having the given username.
     *
     * @throws GuacamoleException
     *     If required properties are missing, and thus the user DN cannot be
     *     determined.
     */
    public String deriveUserDN(String username)
            throws GuacamoleException {

        // Pull username attributes from properties
        List<String> usernameAttributes = confService.getUsernameAttributes();

        // We need exactly one base DN to derive the user DN
        if (usernameAttributes.size() != 1) {
            logger.warn("Cannot directly derive user DN when multiple username attributes are specified");
            return null;
        }

        // Derive user DN from base DN
        return
                    escapingService.escapeDN(usernameAttributes.get(0))
             "="  escapingService.escapeDN(username)
             ","  confService.getUserBaseDN();

    }

    /**
     * Returns the DN that should be used when searching for the DNs of users
     * attempting to authenticate. If no such search should be performed, null
     * is returned.
     *
     * @return
     *     The DN that should be used when searching for the DNs of users
     *     attempting to authenticate, or null if no such search should be
     *     performed.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed.
     */
    public String getSearchBindDN() throws GuacamoleException {
        return environment.getProperty(
            LDAPGuacamoleProperties.LDAP_SEARCH_BIND_DN
        );
    }

    /**
     * Returns the password that should be used when binding to the LDAP server
     * using the DN returned by getSearchBindDN(). If no password should be
     * used, null is returned.
     *
     * @return
     *     The password that should be used when binding to the LDAP server
     *     using the DN returned by getSearchBindDN(), or null if no password
     *     should be used.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed.
     */
    public String getSearchBindPassword() throws GuacamoleException {
        return environment.getProperty(
            LDAPGuacamoleProperties.LDAP_SEARCH_BIND_PASSWORD
        );
    }

import java.util.List;
     * Disconnects the given LDAP connection, logging any failure to do so
     * appropriately.
     *
     * @param ldapConnection
     *     The LDAP connection to disconnect.
     */
    private void disconnect(LDAPConnection ldapConnection) {

        // Attempt disconnect
        try {
            ldapConnection.disconnect();
        }

        // Warn if disconnect unexpectedly fails
        catch (LDAPException e) {
            logger.warn("Unable to disconnect from LDAP server: {}", e.getMessage());
            logger.debug("LDAP disconnect failed.", e);
        }

    }

    /**
        // If a search DN is provided, search the LDAP directory for the DN
        // corresponding to the given username
        String searchBindDN = confService.getSearchBindDN();
        if (searchBindDN != null) {

            // Create an LDAP connection using the search account
            LDAPConnection searchConnection = bindAs(
                searchBindDN,
                confService.getSearchBindPassword()
            );

            try {

                // Retrieve all DNs associated with the given username
                List<String> userDNs = userService.getUserDNs(searchConnection, username);
                if (userDNs.isEmpty())
                    return null;

                // Warn if multiple DNs exist for the same user
                if (userDNs.size() != 1) {
                    logger.warn("Multiple DNs possible for user \"{}\": {}", username, userDNs);
                    return null;
                }

                // Return the single possible DN
                return userDNs.get(0);

            }

            // Always disconnect
            finally {
                disconnect(searchConnection);
            }

        }

        // Otherwise, derive user DN from base DN
            byte[] passwordBytes;

                // Convert password into corresponding byte array
                if (password != null)
                    passwordBytes = password.getBytes("UTF-8");
                else
                    passwordBytes = null;

            // Bind as user
            ldapConnection.bind(LDAPConnection.LDAP_V3, userDN, passwordBytes);

        // Disconnect if an error occurs during bind
            disconnect(ldapConnection);
            logger.debug("Unable to determine DN for user \"{}\".", username);
            disconnect(ldapConnection);
            disconnect(ldapConnection);
        // Close overall query (AND clause)
        ldapQuery.append(")");

                disconnect(ldapConnection);
     * Service for creating and managing connections to LDAP servers.
     */
    @Inject
    private LDAPConnectionService ldapService;

    /**
            LDAPConnection searchConnection = ldapService.bindAs(
                ldapService.disconnect(searchConnection);
        return ldapService.bindAs(userDN, password);
            ldapService.disconnect(ldapConnection);
            ldapService.disconnect(ldapConnection);
        bind(LDAPConnectionService.class);
            // Warn of failure to find
            if (searchConnection == null) {
                logger.error("Unable to bind using search DN \"{}\"", searchBindDN);
                return null;
            }

     * (connections) will be stored within the LDAP directory. If Guacamole
     * configurations will not be stored within LDAP, null is returned.
     *     within the LDAP directory, or null if no Guacamole configurations
     *     will be stored within the LDAP directory.
     *     If guacamole.properties cannot be parsed.
        return environment.getProperty(
import java.util.Collections;
        // Do not return any connections if base DN is not specified
        String configurationBaseDN = confService.getConfigurationBaseDN();
        if (configurationBaseDN == null)
            return Collections.<String, Connection>emptyMap();

                configurationBaseDN,
     * attributes must be present within each Guacamole user's record in the
     * LDAP directory. If the LDAP authentication will not be given its own
import java.util.List;
import org.glyptodon.guacamole.auth.ldap.user.UserService;
     * Service for creating and managing connections to LDAP servers.
    private LDAPConnectionService ldapService;
     * Service for retrieving users and their corresponding LDAP DNs.
     */
    @Inject
    private UserService userService;

    /**
     * Determines the DN which corresponds to the user having the given
     * username. The DN will either be derived directly from the user base DN,
     * or queried from the LDAP server, depending on how LDAP authentication
     * has been configured.
     *
     * @param username
     *     The username of the user whose corresponding DN should be returned.
     *
     * @return
     *     The DN which corresponds to the user having the given username.
     *
     * @throws GuacamoleException
     *     If required properties are missing, and thus the user DN cannot be
     *     determined.
     */
    private String getUserBindDN(String username)
            throws GuacamoleException {

        // If a search DN is provided, search the LDAP directory for the DN
        // corresponding to the given username
        String searchBindDN = confService.getSearchBindDN();
        if (searchBindDN != null) {

            // Create an LDAP connection using the search account
            LDAPConnection searchConnection = ldapService.bindAs(
                searchBindDN,
                confService.getSearchBindPassword()
            );

            // Warn of failure to find
            if (searchConnection == null) {
                logger.error("Unable to bind using search DN \"{}\"", searchBindDN);
                return null;
            }

            try {

                // Retrieve all DNs associated with the given username
                List<String> userDNs = userService.getUserDNs(searchConnection, username);
                if (userDNs.isEmpty())
                    return null;

                // Warn if multiple DNs exist for the same user
                if (userDNs.size() != 1) {
                    logger.warn("Multiple DNs possible for user \"{}\": {}", username, userDNs);
                    return null;
                }

                // Return the single possible DN
                return userDNs.get(0);

            }

            // Always disconnect
            finally {
                ldapService.disconnect(searchConnection);
            }

        }

        // Otherwise, derive user DN from base DN
        return userService.deriveUserDN(username);

    }

    /**
        // Get username and password from credentials
        String username = credentials.getUsername();
        String password = credentials.getPassword();
        if (username == null || username.isEmpty()) {
        if (password == null || password.isEmpty()) {
        // Determine user DN
        String userDN = getUserBindDN(username);
        if (userDN == null) {
            logger.debug("Unable to determine DN for user \"{}\".", username);
        // Bind using user's DN
        return ldapService.bindAs(userDN, password);
    /**
     * Returns an AuthenticatedUser representing the user authenticated by the
     * given credentials.
     *
     * @param credentials
     *     The credentials to use for authentication.
     *
     * @return
     *     An AuthenticatedUser representing the user authenticated by the
     *     given credentials.
     *
     * @throws GuacamoleException
     *     If an error occurs while authenticating the user, or if access is
     *     denied.
     */
        LDAPConnection ldapConnection;
        try {
            ldapConnection = bindAs(credentials);
        }
        catch (GuacamoleException e) {
            logger.error("Cannot bind with LDAP server: {}", e.getMessage());
            logger.debug("Error binding with LDAP server.", e);
            ldapConnection = null;
        }

        // If bind fails, permission to login is denied
            ldapService.disconnect(ldapConnection);
            ldapService.disconnect(ldapConnection);
import java.util.Collections;
import java.util.List;
     * Returns all username attributes which should be used to query and bind
     *     The username attributes which should be used to query and bind users
    public List<String> getUsernameAttributes() throws GuacamoleException {
            Collections.singletonList("uid")
     * (connections) will be stored within the LDAP directory. If Guacamole
     * configurations will not be stored within LDAP, null is returned.
     *     within the LDAP directory, or null if no Guacamole configurations
     *     will be stored within the LDAP directory.
     *     If guacamole.properties cannot be parsed.
        return environment.getProperty(
    /**
     * Returns the DN that should be used when searching for the DNs of users
     * attempting to authenticate. If no such search should be performed, null
     * is returned.
     *
     * @return
     *     The DN that should be used when searching for the DNs of users
     *     attempting to authenticate, or null if no such search should be
     *     performed.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed.
     */
    public String getSearchBindDN() throws GuacamoleException {
        return environment.getProperty(
            LDAPGuacamoleProperties.LDAP_SEARCH_BIND_DN
        );
    }

    /**
     * Returns the password that should be used when binding to the LDAP server
     * using the DN returned by getSearchBindDN(). If no password should be
     * used, null is returned.
     *
     * @return
     *     The password that should be used when binding to the LDAP server
     *     using the DN returned by getSearchBindDN(), or null if no password
     *     should be used.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed.
     */
    public String getSearchBindPassword() throws GuacamoleException {
        return environment.getProperty(
            LDAPGuacamoleProperties.LDAP_SEARCH_BIND_PASSWORD
        );
    }

        bind(LDAPConnectionService.class);
     * The base DN of users. All users must be contained somewhere within the
     * subtree of this DN. If the LDAP authentication will not be given its own
     * credentials for querying other LDAP users, all users must be direct
     * children of this base DN, varying only by LDAP_USERNAME_ATTRIBUTE.
     * The attribute or attributes which identify users. One of these
     * attributes must be present within each Guacamole user's record in the
     * LDAP directory. If the LDAP authentication will not be given its own
     * credentials for querying other LDAP users, this list may contain only
     * one attribute, and the concatenation of that attribute and the value of
     * LDAP_USER_BASE_DN must equal the user's full DN.
    public static final StringListProperty LDAP_USERNAME_ATTRIBUTE = new StringListProperty() {
    /**
     * The DN of the user that the LDAP authentication should bind as when
     * searching for the user accounts of users attempting to log in. If not
     * specified, the DNs of users attempting to log in will be derived from
     * the LDAP_BASE_DN and LDAP_USERNAME_ATTRIBUTE directly.
     */
    public static final StringGuacamoleProperty LDAP_SEARCH_BIND_DN = new StringGuacamoleProperty() {

        @Override
        public String getName() { return "ldap-search-bind-dn"; }

    };

    /**
     * The password to provide to the LDAP server when binding as
     * LDAP_SEARCH_BIND_DN. If LDAP_SEARCH_BIND_DN is not specified, this
     * property has no effect. If this property is not specified, no password
     * will be provided when attempting to bind as LDAP_SEARCH_BIND_DN.
     */
    public static final StringGuacamoleProperty LDAP_SEARCH_BIND_PASSWORD = new StringGuacamoleProperty() {

        @Override
        public String getName() { return "ldap-search-bind-password"; }

    };

import java.util.Collections;
        // Do not return any connections if base DN is not specified
        String configurationBaseDN = confService.getConfigurationBaseDN();
        if (configurationBaseDN == null)
            return Collections.<String, Connection>emptyMap();

                configurationBaseDN,
import java.util.ArrayList;
import java.util.List;
     * Adds all Guacamole users accessible to the user currently bound under
     * the given LDAP connection to the provided map. Only users with the
     * specified attribute are added. If the same username is encountered
     * multiple times, warnings about possible ambiguity will be logged.
     *
     * @param ldapConnection
     *     The current connection to the LDAP server, associated with the
     *     current user.
     *
     * @return
     *     All users accessible to the user currently bound under the given
     *     LDAP connection, as a map of connection identifier to corresponding
     *     user object.
     *
     * @throws GuacamoleException
     *     If an error occurs preventing retrieval of users.
     */
    private void putAllUsers(Map<String, User> users, LDAPConnection ldapConnection,
            String usernameAttribute) throws GuacamoleException {

        try {

            // Find all Guacamole users underneath base DN
            LDAPSearchResults results = ldapConnection.search(
                confService.getUserBaseDN(),
                LDAPConnection.SCOPE_SUB,
                "(&(objectClass=*)("  escapingService.escapeLDAPSearchFilter(usernameAttribute)  "=*))",
                null,
                false
            );

            // Read all visible users
            while (results.hasMore()) {

                LDAPEntry entry = results.next();

                // Get username from record
                LDAPAttribute username = entry.getAttribute(usernameAttribute);
                if (username == null) {
                    logger.warn("Queried user is missing the username attribute \"{}\".", usernameAttribute);
                    continue;
                }

                // Store user using their username as the identifier
                String identifier = username.getStringValue();
                if (users.put(identifier, new SimpleUser(identifier)) != null)
                    logger.warn("Possibly ambiguous user account: \"{}\".", identifier);

            }

        }
        catch (LDAPException e) {
            throw new GuacamoleServerException("Error while querying users.", e);
        }

    }

    /**
        // Build map of users by querying each username attribute separately
        Map<String, User> users = new HashMap<String, User>();
        for (String usernameAttribute : confService.getUsernameAttributes()) {

            // Attempt to pull all users with given attribute
            try {
                putAllUsers(users, ldapConnection, usernameAttribute);
            }

            // Log any errors non-fatally
            catch (GuacamoleException e) {
                logger.warn("Could not query list of all users for attribute \"{}\": {}",
                        usernameAttribute, e.getMessage());
                logger.debug("Error querying list of all users.", e);
            }

        }

        // Return map of all users
        return users;

    }

    /**
     * Generates a properly-escaped LDAP query which finds all objects having
     * at least one username attribute set to the specified username, where
     * the possible username attributes are defined within
     * guacamole.properties.
     *
     * @param username
     *     The username that the resulting LDAP query should search for within
     *     objects within the LDAP directory.
     *
     * @return
     *     An LDAP query which will search for arbitrary LDAP objects
     *     containing at least one username attribute set to the specified
     *     username.
     *
     * @throws GuacamoleException
     *     If the LDAP query cannot be generated because the list of username
     *     attributes cannot be parsed from guacamole.properties.
     */
    private String generateLDAPQuery(String username)
            throws GuacamoleException {

        List<String> usernameAttributes = confService.getUsernameAttributes();

        // Build LDAP query for users having at least one username attribute
        // with the specified username as its value
        StringBuilder ldapQuery = new StringBuilder("(&(objectClass=*)");

        // Include all attributes within OR clause if there are more than one
        if (usernameAttributes.size() > 1)
            ldapQuery.append("(|");

        // Add equality comparison for each possible username attribute
        for (String usernameAttribute : usernameAttributes) {
            ldapQuery.append("(");
            ldapQuery.append(escapingService.escapeLDAPSearchFilter(usernameAttribute));
            ldapQuery.append("=");
            ldapQuery.append(escapingService.escapeLDAPSearchFilter(username));
            ldapQuery.append(")");
        }

        // Close OR clause, if any
        if (usernameAttributes.size() > 1)
            ldapQuery.append(")");

        // Close overall query (AND clause)
        ldapQuery.append(")");

        return ldapQuery.toString();

    }

    /**
     * Returns a list of all DNs corresponding to the users having the given
     * username. If multiple username attributes are defined, or if uniqueness
     * is not enforced across the username attribute, it is possible that this
     * will return multiple DNs.
     *
     * @param ldapConnection
     *     The connection to the LDAP server to use when querying user DNs.
     *
     * @param username
     *     The username of the user whose corresponding user account DNs are
     *     to be retrieved.
     *
     * @return
     *     A list of all DNs corresponding to the users having the given
     *     username. If no such DNs exist, this list will be empty.
     *
     * @throws GuacamoleException
     *     If an error occurs while querying the user DNs, or if the username
     *     attribute property cannot be parsed within guacamole.properties.
     */
    public List<String> getUserDNs(LDAPConnection ldapConnection,
            String username) throws GuacamoleException {

            List<String> userDNs = new ArrayList<String>();
            // Find all Guacamole users underneath base DN and matching the
            // specified username
                LDAPConnection.SCOPE_SUB,
                generateLDAPQuery(username),
            // Add all DNs for found users
                userDNs.add(entry.getDN());
            // Return all discovered DNs (if any)
            return userDNs;
            throw new GuacamoleServerException("Error while query user DNs.", e);
    /**
     * Determines the DN which corresponds to the user having the given
     * username. The DN will either be derived directly from the user base DN,
     * or queried from the LDAP server, depending on how LDAP authentication
     * has been configured.
     *
     * @param username
     *     The username of the user whose corresponding DN should be returned.
     *
     * @return
     *     The DN which corresponds to the user having the given username.
     *
     * @throws GuacamoleException
     *     If required properties are missing, and thus the user DN cannot be
     *     determined.
     */
    public String deriveUserDN(String username)
            throws GuacamoleException {

        // Pull username attributes from properties
        List<String> usernameAttributes = confService.getUsernameAttributes();

        // We need exactly one base DN to derive the user DN
        if (usernameAttributes.size() != 1) {
            logger.warn("Cannot directly derive user DN when multiple username attributes are specified");
            return null;
        }

        // Derive user DN from base DN
        return
                    escapingService.escapeDN(usernameAttributes.get(0))
             "="  escapingService.escapeDN(username)
             ","  confService.getUserBaseDN();

    }

import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
     * @param user
     *     The AuthenticatedUser object associated with the user who is
     *     currently authenticated with Guacamole.
     *
    public Map<String, Connection> getConnections(AuthenticatedUser user,
            LDAPConnection ldapConnection) throws GuacamoleException {
            // Build token filter containing credential tokens
            TokenFilter tokenFilter = new TokenFilter();
            StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());

                // Filter the configuration, substituting all defined tokens
                tokenFilter.filterValues(config.getParameters());

            connectionService.getConnections(user, ldapConnection)
import org.glyptodon.guacamole.auth.ldap.LDAPGuacamoleProperties;
            logger.warn(String.format("Cannot directly derive user DN when "
                       "multiple username attributes are specified. Please "
                       "define an LDAP search DN using the \"%s\" property "
                       "in your \"guacamole.properties\".",
                      LDAPGuacamoleProperties.LDAP_SEARCH_BIND_DN.getName()));
import org.glyptodon.guacamole.net.auth.AuthenticatedUser;
import org.glyptodon.guacamole.token.StandardTokens;
import org.glyptodon.guacamole.token.TokenFilter;
     * @param user
     *     The AuthenticatedUser object associated with the user who is
     *     currently authenticated with Guacamole.
     *
    public Map<String, Connection> getConnections(AuthenticatedUser user,
            LDAPConnection ldapConnection) throws GuacamoleException {
            // Build token filter containing credential tokens
            TokenFilter tokenFilter = new TokenFilter();
            StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());

                // Filter the configuration, substituting all defined tokens
                tokenFilter.filterValues(config.getParameters());

            connectionService.getConnections(user, ldapConnection)
import org.glyptodon.guacamole.auth.ldap.LDAPGuacamoleProperties;
            logger.warn(String.format("Cannot directly derive user DN when "
                       "multiple username attributes are specified. Please "
                       "define an LDAP search DN using the \"%s\" property "
                       "in your \"guacamole.properties\".",
                      LDAPGuacamoleProperties.LDAP_SEARCH_BIND_DN.getName()));
    private final JDBCEnvironment environment;
            JDBCEnvironment environment) {
        bind(JDBCEnvironment.class).toInstance(environment);
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
    private JDBCEnvironment environment;
import com.google.inject.Inject;
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
    
    /**
     * The configuration for the current JDBC environment.
     */
    @Inject JDBCEnvironment jdbcEnvironment;
                connectionMaxConnectionsPerUser = jdbcEnvironment.getDefaultMaxConnectionsPerUser();
                connectionMaxConnections = jdbcEnvironment.getDefaultMaxConnections();
            connectionGroupMaxConnectionsPerUser = jdbcEnvironment.getDefaultMaxGroupConnectionsPerUser();
            connectionGroupMaxConnections = jdbcEnvironment.getDefaultMaxGroupConnections();
        MySQLEnvironment environment = new MySQLEnvironment();
            new JDBCAuthenticationProviderModule(this, environment)
    public MySQLAuthenticationProviderModule(MySQLEnvironment environment)
        myBatisProperties.setProperty("JDBC.host", environment.getMySQLHostname());
        myBatisProperties.setProperty("JDBC.port", String.valueOf(environment.getMySQLPort()));
        myBatisProperties.setProperty("JDBC.schema", environment.getMySQLDatabase());
        myBatisProperties.setProperty("JDBC.username", environment.getMySQLUsername());
        myBatisProperties.setProperty("JDBC.password", environment.getMySQLPassword());
 *
     * The hostname of the MySQL server hosting the Guacamole authentication 
     * tables.
     * The port number of the MySQL server hosting the Guacamole authentication 
     * tables.
     * The name of the MySQL database containing the Guacamole authentication 
     * tables.
     * The username that should be used when authenticating with the MySQL
     * database containing the Guacamole authentication tables.
     * The password that should be used when authenticating with the MySQL
     * database containing the Guacamole authentication tables.
     * Whether or not multiple users accessing the same connection at the same 
     * time should be disallowed.
     * Whether or not the same user accessing the same connection or connection 
     * group at the same time should be disallowed.
     * The default host to connect to, if MYSQL_HOSTNAME is not specified.
     */
    private static final String DEFAULT_HOSTNAME = "localhost";

    /**
     * The default port to connect to, if MYSQL_PORT is not specified.
     */
    private static final int DEFAULT_PORT = 3306;

    /**
     * Constructs a new MySQLEnvironment, providing access to MySQL-specific
     * configuration options.
        return getProperty(
            MySQLGuacamoleProperties.MYSQL_HOSTNAME,
            DEFAULT_HOSTNAME
        );
        return getProperty(MySQLGuacamoleProperties.MYSQL_PORT, DEFAULT_PORT);
 * @author Michael Jumper
     * The default value for the default maximum number of connections to be
     * allowed per user to any one connection. Note that, as long as the
     * legacy "disallow duplicate" and "disallow simultaneous" properties are
     * still supported, these cannot be constants, as the legacy properties
     * dictate the values that should be used in the absence of the correct
     * properties.
     */
    private int DEFAULT_MAX_CONNECTIONS_PER_USER = 1;

    /**
     * The default value for the default maximum number of connections to be
     * allowed per user to any one connection group. Note that, as long as the
     * legacy "disallow duplicate" and "disallow simultaneous" properties are
     * still supported, these cannot be constants, as the legacy properties
     * dictate the values that should be used in the absence of the correct
     * properties.
     */
    private int DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER = 1;

    /**
     * The default value for the default maximum number of connections to be
     * allowed to any one connection. Note that, as long as the legacy
     * "disallow duplicate" and "disallow simultaneous" properties are still
     * supported, these cannot be constants, as the legacy properties dictate
     * the values that should be used in the absence of the correct properties.
     */
    private int DEFAULT_MAX_CONNECTIONS = 0;

    /**
     * The default value for the default maximum number of connections to be
     * allowed to any one connection group. Note that, as long as the legacy
     * "disallow duplicate" and "disallow simultaneous" properties are still
     * supported, these cannot be constants, as the legacy properties dictate
     * the values that should be used in the absence of the correct properties.
     */
    private int DEFAULT_MAX_GROUP_CONNECTIONS = 0;

    /**
     *     If an error occurs while setting up the underlying JDBCEnvironment
     *     or while parsing legacy MySQL configuration options.

        // Init underlying JDBC environment
        Boolean disallowDuplicate    = getProperty(MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS);
                DEFAULT_MAX_CONNECTIONS       = 1;
                DEFAULT_MAX_GROUP_CONNECTIONS = 0;
                DEFAULT_MAX_CONNECTIONS       = 0;
                DEFAULT_MAX_GROUP_CONNECTIONS = 0;
            // Warn of deprecation
            logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(),
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS.getName(),
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());

            // Inform of new equivalent
            logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_SIMULTANEOUS_CONNECTIONS.getName(), disallowSimultaneous,
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS.getName(),           DEFAULT_MAX_CONNECTIONS,
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName(),     DEFAULT_MAX_GROUP_CONNECTIONS);
        // Legacy "duplicate" property dictates whether connections and groups
        // may be used concurrently only by different users
        if (disallowDuplicate != null) {

            // Translate legacy property
            if (disallowDuplicate) {
                DEFAULT_MAX_CONNECTIONS_PER_USER       = 1;
                DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER = 1;
            }
            else {
                DEFAULT_MAX_CONNECTIONS_PER_USER       = 0;
                DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER = 0;
            }

            // Warn of deprecation
            logger.warn("The \"{}\" property is deprecated. Use \"{}\" and \"{}\" instead.",
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS.getName());

            // Inform of new equivalent
            logger.info("To achieve the same result of setting \"{}\" to \"{}\", set \"{}\" to \"{}\" and \"{}\" to \"{}\".",
                    MySQLGuacamoleProperties.MYSQL_DISALLOW_DUPLICATE_CONNECTIONS.getName(),         disallowDuplicate,
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER.getName(),       DEFAULT_MAX_CONNECTIONS_PER_USER,
                    MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER.getName(), DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER);


    }

    @Override
    public int getDefaultMaxConnections() throws GuacamoleException {
        return getProperty(
            MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS,
            DEFAULT_MAX_CONNECTIONS
        );
        return getProperty(
            MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS,
            DEFAULT_MAX_GROUP_CONNECTIONS
        );
        return getProperty(
            MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_CONNECTIONS_PER_USER,
            DEFAULT_MAX_CONNECTIONS_PER_USER
        );
        return getProperty(
            MySQLGuacamoleProperties.MYSQL_DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER,
            DEFAULT_MAX_GROUP_CONNECTIONS_PER_USER
        );
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
        PostgreSQLEnvironment environment = new PostgreSQLEnvironment();
            new JDBCAuthenticationProviderModule(this, environment)
    public PostgreSQLAuthenticationProviderModule(PostgreSQLEnvironment environment)
        myBatisProperties.setProperty("JDBC.host", environment.getPostgreSQLHostname());
        myBatisProperties.setProperty("JDBC.port", String.valueOf(environment.getPostgreSQLPort()));
        myBatisProperties.setProperty("JDBC.schema", environment.getPostgreSQLDatabase());
        myBatisProperties.setProperty("JDBC.username", environment.getPostgreSQLUsername());
        myBatisProperties.setProperty("JDBC.password", environment.getPostgreSQLPassword());
import org.glyptodon.guacamole.auth.jdbc.tunnel.ConfigurableGuacamoleTunnelService;
        bind(GuacamoleTunnelService.class).to(ConfigurableGuacamoleTunnelService.class);
     * The Guacamole server environment.
    @Inject
    private JDBCEnvironment environment;
                connectionMaxConnectionsPerUser = environment.getDefaultMaxConnectionsPerUser();
                connectionMaxConnections = environment.getDefaultMaxConnections();
            connectionGroupMaxConnectionsPerUser = environment.getDefaultMaxGroupConnectionsPerUser();
            connectionGroupMaxConnections = environment.getDefaultMaxGroupConnections();
import org.glyptodon.guacamole.auth.jdbc.tunnel.RestrictedGuacamoleTunnelService;
        bind(GuacamoleTunnelService.class).to(RestrictedGuacamoleTunnelService.class);
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
     * The environment of the Guacamole server.
     */
    @Inject
    private JDBCEnvironment environment;

    /**
    /**
     * Returns the maximum number of connections that should be allowed to this
     * connection overall. If no limit applies, zero is returned.
     *
     * @return
     *     The maximum number of connections that should be allowed to this
     *     connection overall, or zero if no limit applies.
     *
     * @throws GuacamoleException
     *     If an error occurs while parsing the concurrency limit properties
     *     specified within guacamole.properties.
     */
    public int getMaxConnections() throws GuacamoleException {

        // Pull default from environment if connection limit is unset
        Integer value = getModel().getMaxConnections();
        if (value == null)
            return environment.getDefaultMaxConnections();

        // Otherwise use defined value
        return value;

    }

    /**
     * Returns the maximum number of connections that should be allowed to this
     * connection for any individual user. If no limit applies, zero is
     * returned.
     *
     * @return
     *     The maximum number of connections that should be allowed to this
     *     connection for any individual user, or zero if no limit applies.
     *
     * @throws GuacamoleException
     *     If an error occurs while parsing the concurrency limit properties
     *     specified within guacamole.properties.
     */
    public int getMaxConnectionsPerUser() throws GuacamoleException {

        // Pull default from environment if per-user connection limit is unset
        Integer value = getModel().getMaxConnectionsPerUser();
        if (value == null)
            return environment.getDefaultMaxConnectionsPerUser();

        // Otherwise use defined value
        return value;

    }

import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
     * The environment of the Guacamole server.
     */
    @Inject
    private JDBCEnvironment environment;

    /**
    /**
     * Returns the maximum number of connections that should be allowed to this
     * connection group overall. If no limit applies, zero is returned.
     *
     * @return
     *     The maximum number of connections that should be allowed to this
     *     connection group overall, or zero if no limit applies.
     *
     * @throws GuacamoleException
     *     If an error occurs while parsing the concurrency limit properties
     *     specified within guacamole.properties.
     */
    public int getMaxConnections() throws GuacamoleException {

        // Pull default from environment if connection limit is unset
        Integer value = getModel().getMaxConnections();
        if (value == null)
            return environment.getDefaultMaxGroupConnections();

        // Otherwise use defined value
        return value;

    }

    /**
     * Returns the maximum number of connections that should be allowed to this
     * connection group for any individual user. If no limit applies, zero is
     * returned.
     *
     * @return
     *     The maximum number of connections that should be allowed to this
     *     connection group for any individual user, or zero if no limit
     *     applies.
     *
     * @throws GuacamoleException
     *     If an error occurs while parsing the concurrency limit properties
     *     specified within guacamole.properties.
     */
    public int getMaxConnectionsPerUser() throws GuacamoleException {

        // Pull default from environment if per-user connection limit is unset
        Integer value = getModel().getMaxConnectionsPerUser();
        if (value == null)
            return environment.getDefaultMaxGroupConnectionsPerUser();

        // Otherwise use defined value
        return value;

    }


 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/RestrictedGuacamoleTunnelService.java
public class RestrictedGuacamoleTunnelService
            if (tryAdd(activeSeats, seat,
                    connection.getMaxConnectionsPerUser())) {
                        connection.getMaxConnections()))
                connectionGroup.getMaxConnectionsPerUser())) {
                    connectionGroup.getMaxConnections()))
import org.glyptodon.guacamole.auth.jdbc.tunnel.RestrictedGuacamoleTunnelService;
    private final JDBCEnvironment environment;
            JDBCEnvironment environment) {
        bind(JDBCEnvironment.class).toInstance(environment);
        bind(GuacamoleTunnelService.class).to(RestrictedGuacamoleTunnelService.class);
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
     * The environment of the Guacamole server.
     */
    @Inject
    private JDBCEnvironment environment;

    /**
    /**
     * Returns the maximum number of connections that should be allowed to this
     * connection overall. If no limit applies, zero is returned.
     *
     * @return
     *     The maximum number of connections that should be allowed to this
     *     connection overall, or zero if no limit applies.
     *
     * @throws GuacamoleException
     *     If an error occurs while parsing the concurrency limit properties
     *     specified within guacamole.properties.
     */
    public int getMaxConnections() throws GuacamoleException {

        // Pull default from environment if connection limit is unset
        Integer value = getModel().getMaxConnections();
        if (value == null)
            return environment.getDefaultMaxConnections();

        // Otherwise use defined value
        return value;

    }

    /**
     * Returns the maximum number of connections that should be allowed to this
     * connection for any individual user. If no limit applies, zero is
     * returned.
     *
     * @return
     *     The maximum number of connections that should be allowed to this
     *     connection for any individual user, or zero if no limit applies.
     *
     * @throws GuacamoleException
     *     If an error occurs while parsing the concurrency limit properties
     *     specified within guacamole.properties.
     */
    public int getMaxConnectionsPerUser() throws GuacamoleException {

        // Pull default from environment if per-user connection limit is unset
        Integer value = getModel().getMaxConnectionsPerUser();
        if (value == null)
            return environment.getDefaultMaxConnectionsPerUser();

        // Otherwise use defined value
        return value;

    }

import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
     * The environment of the Guacamole server.
     */
    @Inject
    private JDBCEnvironment environment;

    /**
    /**
     * Returns the maximum number of connections that should be allowed to this
     * connection group overall. If no limit applies, zero is returned.
     *
     * @return
     *     The maximum number of connections that should be allowed to this
     *     connection group overall, or zero if no limit applies.
     *
     * @throws GuacamoleException
     *     If an error occurs while parsing the concurrency limit properties
     *     specified within guacamole.properties.
     */
    public int getMaxConnections() throws GuacamoleException {

        // Pull default from environment if connection limit is unset
        Integer value = getModel().getMaxConnections();
        if (value == null)
            return environment.getDefaultMaxGroupConnections();

        // Otherwise use defined value
        return value;

    }

    /**
     * Returns the maximum number of connections that should be allowed to this
     * connection group for any individual user. If no limit applies, zero is
     * returned.
     *
     * @return
     *     The maximum number of connections that should be allowed to this
     *     connection group for any individual user, or zero if no limit
     *     applies.
     *
     * @throws GuacamoleException
     *     If an error occurs while parsing the concurrency limit properties
     *     specified within guacamole.properties.
     */
    public int getMaxConnectionsPerUser() throws GuacamoleException {

        // Pull default from environment if per-user connection limit is unset
        Integer value = getModel().getMaxConnectionsPerUser();
        if (value == null)
            return environment.getDefaultMaxGroupConnectionsPerUser();

        // Otherwise use defined value
        return value;

    }


import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
    private JDBCEnvironment environment;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/glyptodon/guacamole/auth/jdbc/tunnel/RestrictedGuacamoleTunnelService.java
public class RestrictedGuacamoleTunnelService
            if (tryAdd(activeSeats, seat,
                    connection.getMaxConnectionsPerUser())) {
                        connection.getMaxConnections()))
                connectionGroup.getMaxConnectionsPerUser())) {
                    connectionGroup.getMaxConnections()))
        MySQLEnvironment environment = new MySQLEnvironment();
            new JDBCAuthenticationProviderModule(this, environment)
    public MySQLAuthenticationProviderModule(MySQLEnvironment environment)
        myBatisProperties.setProperty("JDBC.host", environment.getMySQLHostname());
        myBatisProperties.setProperty("JDBC.port", String.valueOf(environment.getMySQLPort()));
        myBatisProperties.setProperty("JDBC.schema", environment.getMySQLDatabase());
        myBatisProperties.setProperty("JDBC.username", environment.getMySQLUsername());
        myBatisProperties.setProperty("JDBC.password", environment.getMySQLPassword());
 *
     * The hostname of the MySQL server hosting the Guacamole authentication 
     * tables.
     * The port number of the MySQL server hosting the Guacamole authentication 
     * tables.
     * The name of the MySQL database containing the Guacamole authentication 
     * tables.
     * The username that should be used when authenticating with the MySQL
     * database containing the Guacamole authentication tables.
     * The password that should be used when authenticating with the MySQL
     * database containing the Guacamole authentication tables.
     * Whether or not multiple users accessing the same connection at the same 
     * time should be disallowed.
     * Whether or not the same user accessing the same connection or connection 
     * group at the same time should be disallowed.
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
        PostgreSQLEnvironment environment = new PostgreSQLEnvironment();
            new JDBCAuthenticationProviderModule(this, environment)
    public PostgreSQLAuthenticationProviderModule(PostgreSQLEnvironment environment)
        myBatisProperties.setProperty("JDBC.host", environment.getPostgreSQLHostname());
        myBatisProperties.setProperty("JDBC.port", String.valueOf(environment.getPostgreSQLPort()));
        myBatisProperties.setProperty("JDBC.schema", environment.getPostgreSQLDatabase());
        myBatisProperties.setProperty("JDBC.username", environment.getPostgreSQLUsername());
        myBatisProperties.setProperty("JDBC.password", environment.getPostgreSQLPassword());
        START_DATE
        startDate(ConnectionRecordSet.SortableProperty.START_DATE);
    private static final int MAXIMUM_HISTORY_SIZE = 1000;
        START_DATE
        startDate(ConnectionRecordSet.SortableProperty.START_DATE);
    private static final int MAXIMUM_HISTORY_SIZE = 1000;
        // A system administrator can view all connections; no need to filter
        if (user.getUser().isAdministrator())
            return records;

        // A system administrator can view all connections; no need to filter
        if (user.getUser().isAdministrator())
            return records;

     * guacamole.properties. The default value depends on which encryption
     * method is being used. For unencrypted LDAP and STARTTLS, this will be
     * 389. For LDAPS (LDAP over SSL) this will be 636.
            getEncryptionMethod().DEFAULT_PORT
    /**
     * Returns the encryption method that should be used when connecting to the
     * LDAP server. By default, no encryption is used.
     *
     * @return
     *     The encryption method that should be used when connecting to the
     *     LDAP server.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed.
     */
    public EncryptionMethod getEncryptionMethod() throws GuacamoleException {
        return environment.getProperty(
            LDAPGuacamoleProperties.LDAP_ENCRYPTION_METHOD,
            EncryptionMethod.NONE
        );
    }

 * Copyright (C) 2015 Glyptodon LLC
    /**
     * The encryption method to use when connecting to the LDAP server, if any.
     * The chosen method will also dictate the default port if not already
     * explicitly specified via LDAP_PORT.
     */
    public static final EncryptionMethodProperty LDAP_ENCRYPTION_METHOD = new EncryptionMethodProperty() {

        @Override
        public String getName() { return "ldap-encryption-method"; }

    };

import com.novell.ldap.LDAPJSSESecureSocketFactory;
import com.novell.ldap.LDAPJSSEStartTLSFactory;
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
     * Creates a new instance of LDAPConnection, configured as required to use
     * whichever encryption method is requested within guacamole.properties.
     *
     * @return
     *     A new LDAPConnection instance which has already been configured to
     *     use the encryption method requested within guacamole.properties.
     *
     * @throws GuacamoleException
     *     If an error occurs while parsing guacamole.properties, or if the
     *     requested encryption method is actually not implemented (a bug).
     */
    private LDAPConnection createLDAPConnection() throws GuacamoleException {

        // Map encryption method to proper connection and socket factory
        EncryptionMethod encryptionMethod = confService.getEncryptionMethod();
        switch (encryptionMethod) {

            // Unencrypted LDAP connection
            case NONE:
                logger.debug("Connection to LDAP server without encryption.");
                return new LDAPConnection();

            // LDAP over SSL (LDAPS)
            case SSL:
                logger.debug("Connecting to LDAP server using SSL/TLS.");
                return new LDAPConnection(new LDAPJSSESecureSocketFactory());

            // LDAP  STARTTLS
            case STARTTLS:
                logger.debug("Connecting to LDAP server using STARTTLS.");
                return new LDAPConnection(new LDAPJSSEStartTLSFactory());

            // The encryption method, though known, is not actually
            // implemented. If encountered, this would be a bug.
            default:
                throw new GuacamoleUnsupportedException("Unimplemented encryption method: "  encryptionMethod);

        }

    }

    /**
        // Obtain appropriately-configured LDAPConnection instance
        LDAPConnection ldapConnection = createLDAPConnection();

            // Connect to LDAP server

            // Explicitly start TLS if requested
            if (confService.getEncryptionMethod() == EncryptionMethod.STARTTLS)
                ldapConnection.startTLS();

     * guacamole.properties. The default value depends on which encryption
     * method is being used. For unencrypted LDAP and STARTTLS, this will be
     * 389. For LDAPS (LDAP over SSL) this will be 636.
            getEncryptionMethod().DEFAULT_PORT
    /**
     * Returns the encryption method that should be used when connecting to the
     * LDAP server. By default, no encryption is used.
     *
     * @return
     *     The encryption method that should be used when connecting to the
     *     LDAP server.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed.
     */
    public EncryptionMethod getEncryptionMethod() throws GuacamoleException {
        return environment.getProperty(
            LDAPGuacamoleProperties.LDAP_ENCRYPTION_METHOD,
            EncryptionMethod.NONE
        );
    }

import com.novell.ldap.LDAPJSSESecureSocketFactory;
import com.novell.ldap.LDAPJSSEStartTLSFactory;
import org.glyptodon.guacamole.GuacamoleUnsupportedException;
     * Creates a new instance of LDAPConnection, configured as required to use
     * whichever encryption method is requested within guacamole.properties.
     *
     * @return
     *     A new LDAPConnection instance which has already been configured to
     *     use the encryption method requested within guacamole.properties.
     *
     * @throws GuacamoleException
     *     If an error occurs while parsing guacamole.properties, or if the
     *     requested encryption method is actually not implemented (a bug).
     */
    private LDAPConnection createLDAPConnection() throws GuacamoleException {

        // Map encryption method to proper connection and socket factory
        EncryptionMethod encryptionMethod = confService.getEncryptionMethod();
        switch (encryptionMethod) {

            // Unencrypted LDAP connection
            case NONE:
                logger.debug("Connection to LDAP server without encryption.");
                return new LDAPConnection();

            // LDAP over SSL (LDAPS)
            case SSL:
                logger.debug("Connecting to LDAP server using SSL/TLS.");
                return new LDAPConnection(new LDAPJSSESecureSocketFactory());

            // LDAP  STARTTLS
            case STARTTLS:
                logger.debug("Connecting to LDAP server using STARTTLS.");
                return new LDAPConnection(new LDAPJSSEStartTLSFactory());

            // The encryption method, though known, is not actually
            // implemented. If encountered, this would be a bug.
            default:
                throw new GuacamoleUnsupportedException("Unimplemented encryption method: "  encryptionMethod);

        }

    }

    /**
        // Obtain appropriately-configured LDAPConnection instance
        LDAPConnection ldapConnection = createLDAPConnection();

            // Connect to LDAP server

            // Explicitly start TLS if requested
            if (confService.getEncryptionMethod() == EncryptionMethod.STARTTLS)
                ldapConnection.startTLS();

 * Copyright (C) 2015 Glyptodon LLC
    /**
     * The encryption method to use when connecting to the LDAP server, if any.
     * The chosen method will also dictate the default port if not already
     * explicitly specified via LDAP_PORT.
     */
    public static final EncryptionMethodProperty LDAP_ENCRYPTION_METHOD = new EncryptionMethodProperty() {

        @Override
        public String getName() { return "ldap-encryption-method"; }

    };

     * Creates a new connection and returns the new connection, with identifier
     * field populated.
     *     The new connection.
    public APIConnection createConnection(@QueryParam("token") String authToken,
        // Return the new connection
        return connection;
     * Creates a new connection group and returns the new connection group,
     * with identifier field populated.
     *     The new connection group.
    public APIConnectionGroup createConnectionGroup(
            @QueryParam("token") String authToken,
        // Return the new connection group
        return connectionGroup;
     * Creates a new user and returns the user that was created.
     *     The newly created user.
    public APIUser createUser(@QueryParam("token") String authToken,
        return user;
import org.glyptodon.guacamole.net.auth.Identifiable;
        ExternalType extends Identifiable, ModelType extends ObjectModel>
        // Set identifier on original object
        object.setIdentifier(model.getIdentifier());

import org.glyptodon.guacamole.net.auth.Identifiable;
        ExternalType extends Identifiable, ModelType extends GroupedObjectModel>
 * and allows user manipulation and removal. Objects returned by a Directory
 * are not necessarily backed by the stored objects, thus updating an object
 * always requires calling the update() function.
public interface Directory<ObjectType extends Identifiable> {
     * Adds the given object to the overall set. If a new identifier is
     * created for the added object, that identifier will be automatically
     * assigned via setIdentifier().
     * @param object
     *     The object to add.
     * @throws GuacamoleException
     *     If an error occurs while adding the object, or if adding the object
     *     is not allowed.
import org.glyptodon.guacamole.net.auth.Identifiable;
public class SimpleDirectory<ObjectType extends Identifiable>
        implements Directory<ObjectType> {
import org.glyptodon.guacamole.net.auth.Identifiable;
        ExternalType extends Identifiable, ModelType extends ObjectModel>
        // Set identifier on original object
        object.setIdentifier(model.getIdentifier());

import org.glyptodon.guacamole.net.auth.Identifiable;
        ExternalType extends Identifiable, ModelType extends GroupedObjectModel>
 * and allows user manipulation and removal. Objects returned by a Directory
 * are not necessarily backed by the stored objects, thus updating an object
 * always requires calling the update() function.
public interface Directory<ObjectType extends Identifiable> {
     * Adds the given object to the overall set. If a new identifier is
     * created for the added object, that identifier will be automatically
     * assigned via setIdentifier().
     * @param object
     *     The object to add.
     * @throws GuacamoleException
     *     If an error occurs while adding the object, or if adding the object
     *     is not allowed.
import org.glyptodon.guacamole.net.auth.Identifiable;
public class SimpleDirectory<ObjectType extends Identifiable>
        implements Directory<ObjectType> {
     * Creates a new connection and returns the new connection, with identifier
     * field populated.
     *     The new connection.
    public APIConnection createConnection(@QueryParam("token") String authToken,
        // Return the new connection
        return connection;
     * Creates a new connection group and returns the new connection group,
     * with identifier field populated.
     *     The new connection group.
    public APIConnectionGroup createConnectionGroup(
            @QueryParam("token") String authToken,
        // Return the new connection group
        return connectionGroup;
     * Creates a new user and returns the user that was created.
     *     The newly created user.
    public APIUser createUser(@QueryParam("token") String authToken,
        return user;
 * Copyright (C) 2015 Glyptodon LLC
        // Create and return tunnel
 * Copyright (C) 2015 Glyptodon LLC
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
    private final Logger logger = LoggerFactory.getLogger(GuacamoleHTTPTunnelServlet.class);

    /**
     * Map of absolutely all active tunnels using HTTP, indexed by tunnel UUID.
     */
    private final ConcurrentMap<String, GuacamoleTunnel> tunnels =
            new ConcurrentHashMap<String, GuacamoleTunnel>();
    /**
     * Registers the given tunnel such that future read/write requests to that
     * tunnel will be properly directed.
     *
     * @param tunnel
     *     The tunnel to register.
     */
    protected void registerTunnel(GuacamoleTunnel tunnel) {
        tunnels.put(tunnel.getUUID().toString(), tunnel);
        logger.debug("Registered tunnel \"{}\".", tunnel.getUUID());
    }

    /**
     * Deregisters the given tunnel such that future read/write requests to
     * that tunnel will be rejected.
     *
     * @param tunnel
     *     The tunnel to deregister.
     */
    protected void deregisterTunnel(GuacamoleTunnel tunnel) {
        tunnels.remove(tunnel.getUUID().toString());
        logger.debug("Deregistered tunnel \"{}\".", tunnel.getUUID());
    }

    /**
     * Returns the tunnel with the given UUID, if it has been registered with
     * registerTunnel() and not yet deregistered with deregisterTunnel().
     *
     * @param tunnelUUID
     *     The UUID of registered tunnel.
     *
     * @return
     *     The tunnel corresponding to the given UUID.
     *
     * @throws GuacamoleException
     *     If the requested tunnel does not exist because it has not yet been
     *     registered or it has been deregistered.
     */
    protected GuacamoleTunnel getTunnel(String tunnelUUID)
            throws GuacamoleException {

        // Pull tunnel from map
        GuacamoleTunnel tunnel = tunnels.get(tunnelUUID);
        if (tunnel == null)
            throw new GuacamoleResourceNotFoundException("No such tunnel.");

        return tunnel;

    }

     * @param response
     *     The HTTP response to use to send the error.
     *
     * @param guacStatus
     *     The status to send
     *
     * @param message
     *     A human-readable message that can be presented to the user.
     *
     * @throws ServletException
     *     If an error prevents sending of the error code.
    protected void sendError(HttpServletResponse response,
            GuacamoleStatus guacStatus, String message)
                response.addHeader("Guacamole-Status-Code", Integer.toString(guacStatus.getGuacamoleStatusCode()));
                response.sendError(guacStatus.getHttpStatusCode());
     * @param request
     *     The HttpServletRequest associated with the GET or POST request
     *     received.
     *
     * @param response
     *     The HttpServletResponse associated with the GET or POST request
     *     received.
     *
     * @throws ServletException
     *     If an error occurs while servicing the request.
    protected void handleTunnelRequest(HttpServletRequest request,
            HttpServletResponse response) throws ServletException {
                    // Register newly-created tunnel
                    registerTunnel(tunnel);
     * request via HTTP. It it up to the implementor of this function to define
     * what conditions must be met for a tunnel to be configured and returned
     * as a result of this connection request (whether some sort of credentials
     * must be specified, for example).
     * @param request
     *     The HttpServletRequest associated with the connection request
     *     received. Any parameters specified along with the connection request
     *     can be read from this object.
     *
     * @return
     *     A newly constructed GuacamoleTunnel if successful, null otherwise.
     *
     * @throws GuacamoleException
     *     If an error occurs while constructing the GuacamoleTunnel, or if the
     *     conditions required for connection are not met.
    protected abstract GuacamoleTunnel doConnect(HttpServletRequest request)
            throws GuacamoleException;
     * @param request
     *     The HttpServletRequest associated with the read request received.
     *
     * @param response
     *     The HttpServletResponse associated with the write request received.
     *     Any data to be sent to the client in response to the write request
     *     should be written to the response body of this HttpServletResponse.
     *
     * @param tunnelUUID
     *     The UUID of the tunnel to read from, as specified in the write
     *     request. This tunnel must have been created by a previous call to
     *     doConnect().
     *
     * @throws GuacamoleException
     *     If an error occurs while handling the read request.
    protected void doRead(HttpServletRequest request,
            HttpServletResponse response, String tunnelUUID)
            throws GuacamoleException {
        GuacamoleTunnel tunnel = getTunnel(tunnelUUID);
                // Deregister tunnel and throw error if we reach EOF without
                // having ever sent any data
                    deregisterTunnel(tunnel);
                // Deregister and close
                deregisterTunnel(tunnel);
                // Deregister and close
                deregisterTunnel(tunnel);
            // Deregister and close
            deregisterTunnel(tunnel);
     * @param request
     *     The HttpServletRequest associated with the write request received.
     *     Any data to be written will be specified within the body of this
     *     request.
     *
     * @param response
     *     The HttpServletResponse associated with the write request received.
     *
     * @param tunnelUUID
     *     The UUID of the tunnel to write to, as specified in the write
     *     request. This tunnel must have been created by a previous call to
     *     doConnect().
     *
     * @throws GuacamoleException
     *     If an error occurs while handling the write request.
    protected void doWrite(HttpServletRequest request,
            HttpServletResponse response, String tunnelUUID)
            throws GuacamoleException {
        GuacamoleTunnel tunnel = getTunnel(tunnelUUID);
            // Deregister and close
            deregisterTunnel(tunnel);
 * Copyright (C) 2015 Glyptodon LLC
@Deprecated
    private final Logger logger = LoggerFactory.getLogger(GuacamoleSession.class);
     * Creates a new GuacamoleSession. In prior versions of Guacamole, the
     * GuacamoleSession object stored the tunnels associated with a particular
     * user's use of the HTTP tunnel. The HTTP tunnel now stores all of these
     * tunnels itself, and thus this class is no longer necessary. Its use will
     * result in a warning being logged, and its functions will have no effect.
     * @param session
     *     The HttpSession that older versions of Guacamole would use as tunnel
     *     storage. This parameter is now ignored, and the GuacamoleSession
     *     class overall is deprecated.
    public GuacamoleSession(HttpSession session) {
        logger.warn("GuacamoleSession is deprecated. It is no longer "
                   "necessary and its use will have no effect.");
     * Attaches the given tunnel to this GuacamoleSession. The GuacamoleSession
     * class is now deprecated, and this function has no effect.
     *
     * @param tunnel
     *     The tunnel to attach to this GucacamoleSession.
        // Deprecated - no effect
     * Detaches the given tunnel to this GuacamoleSession. The GuacamoleSession
     * class is now deprecated, and this function has no effect.
     *
     * @param tunnel
     *     The tunnel to detach to this GucacamoleSession.
        // Deprecated - no effect
     * if any. The GuacamoleSession class is now deprecated, and this function
     * has no effect. It will ALWAYS return null.
     * @param tunnelUUID
     *     The UUID of an attached tunnel.
     *
     * @return
     *     The tunnel corresponding to the given UUID, if attached, or null if
     *     if no such tunnel is attached.

        // Deprecated - no effect
        return null;

    private final GuacamoleHTTPTunnelMap tunnels = new GuacamoleHTTPTunnelMap();
    @Override
    public void destroy() {
        tunnels.shutdown();
    }

 * Copyright (C) 2015 Glyptodon LLC
        // Create and return tunnel
 * Copyright (C) 2015 Glyptodon LLC
    private final Logger logger = LoggerFactory.getLogger(GuacamoleHTTPTunnelServlet.class);

    /**
     * Map of absolutely all active tunnels using HTTP, indexed by tunnel UUID.
     */
    private final GuacamoleHTTPTunnelMap tunnels = new GuacamoleHTTPTunnelMap();
    /**
     * Registers the given tunnel such that future read/write requests to that
     * tunnel will be properly directed.
     *
     * @param tunnel
     *     The tunnel to register.
     */
    protected void registerTunnel(GuacamoleTunnel tunnel) {
        tunnels.put(tunnel.getUUID().toString(), tunnel);
        logger.debug("Registered tunnel \"{}\".", tunnel.getUUID());
    }

    /**
     * Deregisters the given tunnel such that future read/write requests to
     * that tunnel will be rejected.
     *
     * @param tunnel
     *     The tunnel to deregister.
     */
    protected void deregisterTunnel(GuacamoleTunnel tunnel) {
        tunnels.remove(tunnel.getUUID().toString());
        logger.debug("Deregistered tunnel \"{}\".", tunnel.getUUID());
    }

    /**
     * Returns the tunnel with the given UUID, if it has been registered with
     * registerTunnel() and not yet deregistered with deregisterTunnel().
     *
     * @param tunnelUUID
     *     The UUID of registered tunnel.
     *
     * @return
     *     The tunnel corresponding to the given UUID.
     *
     * @throws GuacamoleException
     *     If the requested tunnel does not exist because it has not yet been
     *     registered or it has been deregistered.
     */
    protected GuacamoleTunnel getTunnel(String tunnelUUID)
            throws GuacamoleException {

        // Pull tunnel from map
        GuacamoleTunnel tunnel = tunnels.get(tunnelUUID);
        if (tunnel == null)
            throw new GuacamoleResourceNotFoundException("No such tunnel.");

        return tunnel;

    }

     * @param response
     *     The HTTP response to use to send the error.
     *
     * @param guacStatus
     *     The status to send
     *
     * @param message
     *     A human-readable message that can be presented to the user.
     *
     * @throws ServletException
     *     If an error prevents sending of the error code.
    protected void sendError(HttpServletResponse response,
            GuacamoleStatus guacStatus, String message)
                response.addHeader("Guacamole-Status-Code", Integer.toString(guacStatus.getGuacamoleStatusCode()));
                response.sendError(guacStatus.getHttpStatusCode());
     * @param request
     *     The HttpServletRequest associated with the GET or POST request
     *     received.
     *
     * @param response
     *     The HttpServletResponse associated with the GET or POST request
     *     received.
     *
     * @throws ServletException
     *     If an error occurs while servicing the request.
    protected void handleTunnelRequest(HttpServletRequest request,
            HttpServletResponse response) throws ServletException {
                    // Register newly-created tunnel
                    registerTunnel(tunnel);
     * request via HTTP. It it up to the implementor of this function to define
     * what conditions must be met for a tunnel to be configured and returned
     * as a result of this connection request (whether some sort of credentials
     * must be specified, for example).
     * @param request
     *     The HttpServletRequest associated with the connection request
     *     received. Any parameters specified along with the connection request
     *     can be read from this object.
     *
     * @return
     *     A newly constructed GuacamoleTunnel if successful, null otherwise.
     *
     * @throws GuacamoleException
     *     If an error occurs while constructing the GuacamoleTunnel, or if the
     *     conditions required for connection are not met.
    protected abstract GuacamoleTunnel doConnect(HttpServletRequest request)
            throws GuacamoleException;
     * @param request
     *     The HttpServletRequest associated with the read request received.
     *
     * @param response
     *     The HttpServletResponse associated with the write request received.
     *     Any data to be sent to the client in response to the write request
     *     should be written to the response body of this HttpServletResponse.
     *
     * @param tunnelUUID
     *     The UUID of the tunnel to read from, as specified in the write
     *     request. This tunnel must have been created by a previous call to
     *     doConnect().
     *
     * @throws GuacamoleException
     *     If an error occurs while handling the read request.
    protected void doRead(HttpServletRequest request,
            HttpServletResponse response, String tunnelUUID)
            throws GuacamoleException {
        GuacamoleTunnel tunnel = getTunnel(tunnelUUID);
                // Deregister tunnel and throw error if we reach EOF without
                // having ever sent any data
                    deregisterTunnel(tunnel);
                // Deregister and close
                deregisterTunnel(tunnel);
                // Deregister and close
                deregisterTunnel(tunnel);
            // Deregister and close
            deregisterTunnel(tunnel);
     * @param request
     *     The HttpServletRequest associated with the write request received.
     *     Any data to be written will be specified within the body of this
     *     request.
     *
     * @param response
     *     The HttpServletResponse associated with the write request received.
     *
     * @param tunnelUUID
     *     The UUID of the tunnel to write to, as specified in the write
     *     request. This tunnel must have been created by a previous call to
     *     doConnect().
     *
     * @throws GuacamoleException
     *     If an error occurs while handling the write request.
    protected void doWrite(HttpServletRequest request,
            HttpServletResponse response, String tunnelUUID)
            throws GuacamoleException {
        GuacamoleTunnel tunnel = getTunnel(tunnelUUID);
            // Deregister and close
            deregisterTunnel(tunnel);
    @Override
    public void destroy() {
        tunnels.shutdown();
    }

 * Copyright (C) 2015 Glyptodon LLC
@Deprecated
    private final Logger logger = LoggerFactory.getLogger(GuacamoleSession.class);
     * Creates a new GuacamoleSession. In prior versions of Guacamole, the
     * GuacamoleSession object stored the tunnels associated with a particular
     * user's use of the HTTP tunnel. The HTTP tunnel now stores all of these
     * tunnels itself, and thus this class is no longer necessary. Its use will
     * result in a warning being logged, and its functions will have no effect.
     * @param session
     *     The HttpSession that older versions of Guacamole would use as tunnel
     *     storage. This parameter is now ignored, and the GuacamoleSession
     *     class overall is deprecated.
    public GuacamoleSession(HttpSession session) {
        logger.warn("GuacamoleSession is deprecated. It is no longer "
                   "necessary and its use will have no effect.");
     * Attaches the given tunnel to this GuacamoleSession. The GuacamoleSession
     * class is now deprecated, and this function has no effect.
     *
     * @param tunnel
     *     The tunnel to attach to this GucacamoleSession.
        // Deprecated - no effect
     * Detaches the given tunnel to this GuacamoleSession. The GuacamoleSession
     * class is now deprecated, and this function has no effect.
     *
     * @param tunnel
     *     The tunnel to detach to this GucacamoleSession.
        // Deprecated - no effect
     * if any. The GuacamoleSession class is now deprecated, and this function
     * has no effect. It will ALWAYS return null.
     * @param tunnelUUID
     *     The UUID of an attached tunnel.
     *
     * @return
     *     The tunnel corresponding to the given UUID, if attached, or null if
     *     if no such tunnel is attached.

        // Deprecated - no effect
        return null;

        // Ignore inbound messages if there is no associated tunnel
        if (tunnel == null)
            return;

import org.glyptodon.guacamole.net.basic.TunnelRequest;
     * Unique string which shall be used to store the TunnelRequest
    private static final String TUNNEL_REQUEST_PROPERTY = "WS_GUAC_TUNNEL_REQUEST";
     * Unique string which shall be used to store the TunnelRequestService to
     * be used for processing TunnelRequests.
    private static final String TUNNEL_REQUEST_SERVICE_PROPERTY = "WS_GUAC_TUNNEL_REQUEST_SERVICE";
         * @param tunnelRequestServiceProvider
         *     The tunnel request service provider to use for all new
         *     connections.
        public void modifyHandshake(ServerEndpointConfig config,
                HandshakeRequest request, HandshakeResponse response) {
            // Store tunnel request and tunnel request service for retrieval
            // upon WebSocket open
            userProperties.put(TUNNEL_REQUEST_PROPERTY, new WebSocketTunnelRequest(request));
            userProperties.put(TUNNEL_REQUEST_SERVICE_PROPERTY, tunnelRequestServiceProvider.get());
    protected GuacamoleTunnel createTunnel(Session session,
            EndpointConfig config) throws GuacamoleException {
        // Get original tunnel request
        TunnelRequest tunnelRequest = (TunnelRequest) userProperties.get(TUNNEL_REQUEST_PROPERTY);
        if (tunnelRequest == null)
            return null;

        // Get tunnel request service
        TunnelRequestService tunnelRequestService = (TunnelRequestService) userProperties.get(TUNNEL_REQUEST_SERVICE_PROPERTY);
        if (tunnelRequestService == null)
            return null;

        // Create and return tunnel
        return tunnelRequestService.createTunnel(tunnelRequest);
    public WebSocket doWebSocketConnect(final HttpServletRequest request, String protocol) {
            /**
             * The GuacamoleTunnel associated with the connected WebSocket. If
             * the WebSocket has not yet been connected, this will be null.
             */
            private GuacamoleTunnel tunnel = null;


                // Ignore inbound messages if there is no associated tunnel
                if (tunnel == null)
                    return;


                try {
                    tunnel = doConnect(request);
                }
                catch (GuacamoleException e) {
                    logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
                    logger.debug("Error connecting WebSocket tunnel.", e);
                    closeConnection(connection, e.getStatus());
                    return;
                }

        // Ignore inbound messages if there is no associated tunnel
        if (tunnel == null)
            return;

    public StreamInbound createWebSocketInbound(String protocol,
            final HttpServletRequest request) {
            /**
             * The GuacamoleTunnel associated with the connected WebSocket. If
             * the WebSocket has not yet been connected, this will be null.
             */
            private GuacamoleTunnel tunnel = null;

                // Ignore inbound messages if there is no associated tunnel
                if (tunnel == null)
                    return;

                try {
                    tunnel = doConnect(request);
                }
                catch (GuacamoleException e) {
                    logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
                    logger.debug("Error connecting WebSocket tunnel.", e);
                    closeConnection(outbound, e.getStatus());
                    return;
                }

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
     * A copy of the parameters obtained from the HttpServletRequest used to
     * construct the HttpTunnelRequest.
    private final Map<String, List<String>> parameterMap =
            new HashMap<String, List<String>>();
     * Creates a HTTPTunnelRequest which copies and exposes the parameters
     * from the given HttpServletRequest.
     * @param request
     *     The HttpServletRequest to copy parameter values from.
    @SuppressWarnings("unchecked") // getParameterMap() is defined as returning Map<String, String[]>

        // For each parameter
        for (Map.Entry<String, String[]> mapEntry : ((Map<String, String[]>)
                request.getParameterMap()).entrySet()) {

            // Get parameter name and corresponding values
            String parameterName = mapEntry.getKey();
            List<String> parameterValues = Arrays.asList(mapEntry.getValue());

            // Store copy of all values in our own map
            parameterMap.put(
                parameterName,
                new ArrayList<String>(parameterValues)
            );

        }

        List<String> values = getParameterValues(name);

        // Return the first value from the list if available
        if (values != null && !values.isEmpty())
            return values.get(0);

        return null;
        return parameterMap.get(name);
import org.glyptodon.guacamole.net.basic.TunnelRequest;
    protected GuacamoleTunnel doConnect(TunnelRequest request)
        return tunnelRequestService.createTunnel(request);
import org.glyptodon.guacamole.net.basic.HTTPTunnelRequest;
import org.glyptodon.guacamole.net.basic.TunnelRequest;
    public WebSocket doWebSocketConnect(HttpServletRequest request, String protocol) {

        final TunnelRequest tunnelRequest = new HTTPTunnelRequest(request);
                    tunnel = doConnect(tunnelRequest);
     * @param request The TunnelRequest associated with the connection
    protected abstract GuacamoleTunnel doConnect(TunnelRequest request)
import org.glyptodon.guacamole.net.basic.TunnelRequest;
    protected GuacamoleTunnel doConnect(TunnelRequest request)
        return tunnelRequestService.createTunnel(request);
import org.glyptodon.guacamole.net.basic.HTTPTunnelRequest;
import org.glyptodon.guacamole.net.basic.TunnelRequest;
            HttpServletRequest request) {

        final TunnelRequest tunnelRequest = new HTTPTunnelRequest(request);
                    tunnel = doConnect(tunnelRequest);
     * @param request
     *     The TunnelRequest associated with the connection request received.
     *     Any parameters specified along with the connection request can be
     *     read from this object.
     *
     * @return
     *     A newly constructed GuacamoleTunnel if successful, null otherwise.
     *
     * @throws GuacamoleException
     *     If an error occurs while constructing the GuacamoleTunnel, or if the
     *     conditions required for connection are not met.
    protected abstract GuacamoleTunnel doConnect(TunnelRequest request)
            throws GuacamoleException;
     * construct the HTTPTunnelRequest.
     * @param request
     *     The TunnelRequest associated with the connection request received.
     *     Any parameters specified along with the connection request can be
     *     read from this object.
     *
     * @return
     *     A newly constructed GuacamoleTunnel if successful, null otherwise.
     *
     * @throws GuacamoleException
     *     If an error occurs while constructing the GuacamoleTunnel, or if the
     *     conditions required for connection are not met.
        // Ignore inbound messages if there is no associated tunnel
        if (tunnel == null)
            return;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
     * A copy of the parameters obtained from the HttpServletRequest used to
     * construct the HTTPTunnelRequest.
    private final Map<String, List<String>> parameterMap =
            new HashMap<String, List<String>>();
     * Creates a HTTPTunnelRequest which copies and exposes the parameters
     * from the given HttpServletRequest.
     * @param request
     *     The HttpServletRequest to copy parameter values from.
    @SuppressWarnings("unchecked") // getParameterMap() is defined as returning Map<String, String[]>

        // For each parameter
        for (Map.Entry<String, String[]> mapEntry : ((Map<String, String[]>)
                request.getParameterMap()).entrySet()) {

            // Get parameter name and corresponding values
            String parameterName = mapEntry.getKey();
            List<String> parameterValues = Arrays.asList(mapEntry.getValue());

            // Store copy of all values in our own map
            parameterMap.put(
                parameterName,
                new ArrayList<String>(parameterValues)
            );

        }

        List<String> values = getParameterValues(name);

        // Return the first value from the list if available
        if (values != null && !values.isEmpty())
            return values.get(0);

        return null;
        return parameterMap.get(name);
import org.glyptodon.guacamole.net.basic.TunnelRequest;
     * Unique string which shall be used to store the TunnelRequest
    private static final String TUNNEL_REQUEST_PROPERTY = "WS_GUAC_TUNNEL_REQUEST";
     * Unique string which shall be used to store the TunnelRequestService to
     * be used for processing TunnelRequests.
    private static final String TUNNEL_REQUEST_SERVICE_PROPERTY = "WS_GUAC_TUNNEL_REQUEST_SERVICE";
         * @param tunnelRequestServiceProvider
         *     The tunnel request service provider to use for all new
         *     connections.
        public void modifyHandshake(ServerEndpointConfig config,
                HandshakeRequest request, HandshakeResponse response) {
            // Store tunnel request and tunnel request service for retrieval
            // upon WebSocket open
            userProperties.put(TUNNEL_REQUEST_PROPERTY, new WebSocketTunnelRequest(request));
            userProperties.put(TUNNEL_REQUEST_SERVICE_PROPERTY, tunnelRequestServiceProvider.get());
    protected GuacamoleTunnel createTunnel(Session session,
            EndpointConfig config) throws GuacamoleException {
        // Get original tunnel request
        TunnelRequest tunnelRequest = (TunnelRequest) userProperties.get(TUNNEL_REQUEST_PROPERTY);
        if (tunnelRequest == null)
            return null;

        // Get tunnel request service
        TunnelRequestService tunnelRequestService = (TunnelRequestService) userProperties.get(TUNNEL_REQUEST_SERVICE_PROPERTY);
        if (tunnelRequestService == null)
            return null;

        // Create and return tunnel
        return tunnelRequestService.createTunnel(tunnelRequest);
import org.glyptodon.guacamole.net.basic.TunnelRequest;
    protected GuacamoleTunnel doConnect(TunnelRequest request)
        return tunnelRequestService.createTunnel(request);
import org.glyptodon.guacamole.net.basic.HTTPTunnelRequest;
import org.glyptodon.guacamole.net.basic.TunnelRequest;
        final TunnelRequest tunnelRequest = new HTTPTunnelRequest(request);
            /**
             * The GuacamoleTunnel associated with the connected WebSocket. If
             * the WebSocket has not yet been connected, this will be null.
             */
            private GuacamoleTunnel tunnel = null;


                // Ignore inbound messages if there is no associated tunnel
                if (tunnel == null)
                    return;


                try {
                    tunnel = doConnect(tunnelRequest);
                }
                catch (GuacamoleException e) {
                    logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
                    logger.debug("Error connecting WebSocket tunnel.", e);
                    closeConnection(connection, e.getStatus());
                    return;
                }

     * @param request
     *     The TunnelRequest associated with the connection request received.
     *     Any parameters specified along with the connection request can be
     *     read from this object.
     *
     * @return
     *     A newly constructed GuacamoleTunnel if successful, null otherwise.
     *
     * @throws GuacamoleException
     *     If an error occurs while constructing the GuacamoleTunnel, or if the
     *     conditions required for connection are not met.
    protected abstract GuacamoleTunnel doConnect(TunnelRequest request)
        // Ignore inbound messages if there is no associated tunnel
        if (tunnel == null)
            return;

import org.glyptodon.guacamole.net.basic.TunnelRequest;
    protected GuacamoleTunnel doConnect(TunnelRequest request)
        return tunnelRequestService.createTunnel(request);
import org.glyptodon.guacamole.net.basic.HTTPTunnelRequest;
import org.glyptodon.guacamole.net.basic.TunnelRequest;
    public StreamInbound createWebSocketInbound(String protocol,
            HttpServletRequest request) {
        final TunnelRequest tunnelRequest = new HTTPTunnelRequest(request);
            /**
             * The GuacamoleTunnel associated with the connected WebSocket. If
             * the WebSocket has not yet been connected, this will be null.
             */
            private GuacamoleTunnel tunnel = null;

                // Ignore inbound messages if there is no associated tunnel
                if (tunnel == null)
                    return;

                try {
                    tunnel = doConnect(tunnelRequest);
                }
                catch (GuacamoleException e) {
                    logger.error("Creation of WebSocket tunnel to guacd failed: {}", e.getMessage());
                    logger.debug("Error connecting WebSocket tunnel.", e);
                    closeConnection(outbound, e.getStatus());
                    return;
                }

     * @param request
     *     The TunnelRequest associated with the connection request received.
     *     Any parameters specified along with the connection request can be
     *     read from this object.
     *
     * @return
     *     A newly constructed GuacamoleTunnel if successful, null otherwise.
     *
     * @throws GuacamoleException
     *     If an error occurs while constructing the GuacamoleTunnel, or if the
     *     conditions required for connection are not met.
    protected abstract GuacamoleTunnel doConnect(TunnelRequest request)
            throws GuacamoleException;
            "0.9.9"
            "0.9.9"
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
    private final ConcurrentMap<String, GuacamoleHTTPTunnel> tunnelMap =
            new ConcurrentHashMap<String, GuacamoleHTTPTunnel>();

                    // Remove old entry
                    // Attempt to close tunnel
            } // end for each tunnel
        } // end timeout task run()
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
    private final ConcurrentMap<String, GuacamoleSession> sessionMap =
            new ConcurrentHashMap<String, GuacamoleSession>();
     * which are beyond the session timeout.
            // Get start time of session check time
            long sessionCheckStart = System.currentTimeMillis();

                long age = sessionCheckStart - session.getLastAccessedTime();
            // Log completion and duration
            logger.debug("Session check completed in {} ms.",
                    System.currentTimeMillis() - sessionCheckStart);
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
    private final ConcurrentMap<String, GuacamoleHTTPTunnel> tunnelMap =
            new ConcurrentHashMap<String, GuacamoleHTTPTunnel>();

                    // Remove old entry
                    // Attempt to close tunnel
            } // end for each tunnel
        } // end timeout task run()
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
    private final ConcurrentMap<String, GuacamoleSession> sessionMap =
            new ConcurrentHashMap<String, GuacamoleSession>();
     * which are beyond the session timeout.
            // Get start time of session check time
            long sessionCheckStart = System.currentTimeMillis();

                long age = sessionCheckStart - session.getLastAccessedTime();
            // Log completion and duration
            logger.debug("Session check completed in {} ms.",
                    System.currentTimeMillis() - sessionCheckStart);
        // There are no null auth tokens
        if (authToken == null)
            return null;


        // There are no null auth tokens
        if (authToken == null)
            return null;

        // Attempt to retrieve only if non-null

        // There are no null auth tokens
        if (authToken == null)
            return null;


        // There are no null auth tokens
        if (authToken == null)
            return null;

        // Attempt to retrieve only if non-null

     * Returns the base DN under which all Guacamole role based access control
     * (RBAC) groups will be stored within the LDAP directory.
     *
     * @return
     *     The base DN under which all Guacamole RBAC groups will be stored
     *     within the LDAP directory.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed.
     */
    public String getGroupBaseDN() throws GuacamoleException {
        return environment.getProperty(
            LDAPGuacamoleProperties.LDAP_GROUP_BASE_DN
        );
    }

    /**
    
    /**
     * The base DN of role based access control (RBAC) groups. 
     * All groups should be under this DN.
     */
    public static final StringGuacamoleProperty LDAP_GROUP_BASE_DN = new StringGuacamoleProperty() {

        @Override
        public String getName() { return "ldap-group-base-dn"; }

    };
        if (configurationBaseDN == null) {
        }
            // Get the search filter for finding connections associated to the userDN
            String connectionSearchFilter = getConnectionSearchFilter(userDN, ldapConnection);
            
            // Find all Guacamole connections for the given user by
            // looking for direct membership in the guacConfigGroup
            // and possibly any groups the user is a member of that are
            // referred to in the seeAlso attribute of the guacConfigGroup.
                connectionSearchFilter,
        } catch (LDAPException e) {
    
    /**
     * Returns the connection search filter for the given userDN.
     *
     * @param userDN
     *     DN of the user to search for associated guacConfigGroup connections.
     *
     * @param ldapConnection
     *     LDAP connection to use for searching for associated groups.
     *
     * @return
     *     Search filter for finding guacConfigGroup associated with the userDN.
     *
     * @throws LDAPException
     *     If an error occurs preventing retrieval of user groups.
     *     
     * @throws GuacamoleException
     *     If an error occurs retrieving the group base DN. 
     */
    private String getConnectionSearchFilter(String userDN, LDAPConnection ldapConnection) throws LDAPException, GuacamoleException {
        
        // Create a search filter for the connection search
        StringBuilder connectionSearchFilter = new StringBuilder();

        // Add the prefix to the search filter, prefix filter searches for guacConfigGroups with the userDN as the member attribute value
        connectionSearchFilter.append("(&(objectClass=guacConfigGroup)(|(member=");
        connectionSearchFilter.append(escapingService.escapeLDAPSearchFilter(userDN));
        connectionSearchFilter.append(")");

        // If group base DN is specified search for user groups
        String groupBaseDN = confService.getGroupBaseDN();

        if (groupBaseDN != null) {

            // Get all groups the user is a member of starting at the groupBaseDN, excluding guacConfigGroups
            LDAPSearchResults userRoleGroupResults = ldapConnection.search(
                groupBaseDN,
                LDAPConnection.SCOPE_SUB,
                "(&(!(objectClass=guacConfigGroup))(member="  escapingService.escapeLDAPSearchFilter(userDN)  "))",
                null,
                false
            );

            // Append the additional user groups to the LDAP filter
            // Now the filter will also look for guacConfigGroups that refer 
            // to groups the user is a member of
            // The guacConfig group uses the seeAlso attribute to refer 
            // to these other groups
            while (userRoleGroupResults.hasMore()) {
                LDAPEntry entry = userRoleGroupResults.next();
                connectionSearchFilter.append("(seeAlso=").append(escapingService.escapeLDAPSearchFilter(entry.getDN())).append(")");
            }
        }
        
        // Complete the search filter.
        connectionSearchFilter.append("))");  
        
        return connectionSearchFilter.toString();
    }

     * Returns the base DN under which all Guacamole role based access control
     * (RBAC) groups will be stored within the LDAP directory.
     *
     * @return
     *     The base DN under which all Guacamole RBAC groups will be stored
     *     within the LDAP directory.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed.
     */
    public String getGroupBaseDN() throws GuacamoleException {
        return environment.getProperty(
            LDAPGuacamoleProperties.LDAP_GROUP_BASE_DN
        );
    }

    /**
    
    /**
     * The base DN of role based access control (RBAC) groups. 
     * All groups should be under this DN.
     */
    public static final StringGuacamoleProperty LDAP_GROUP_BASE_DN = new StringGuacamoleProperty() {

        @Override
        public String getName() { return "ldap-group-base-dn"; }

    };
        if (configurationBaseDN == null) {
        }
            // Get the search filter for finding connections associated to the userDN
            String connectionSearchFilter = getConnectionSearchFilter(userDN, ldapConnection);
            
            // Find all Guacamole connections for the given user by
            // looking for direct membership in the guacConfigGroup
            // and possibly any groups the user is a member of that are
            // referred to in the seeAlso attribute of the guacConfigGroup.
                connectionSearchFilter,
        } catch (LDAPException e) {
    
    /**
     * Returns the connection search filter for the given userDN.
     *
     * @param userDN
     *     DN of the user to search for associated guacConfigGroup connections.
     *
     * @param ldapConnection
     *     LDAP connection to use for searching for associated groups.
     *
     * @return
     *     Search filter for finding guacConfigGroup associated with the userDN.
     *
     * @throws LDAPException
     *     If an error occurs preventing retrieval of user groups.
     *     
     * @throws GuacamoleException
     *     If an error occurs retrieving the group base DN. 
     */
    private String getConnectionSearchFilter(String userDN, LDAPConnection ldapConnection) throws LDAPException, GuacamoleException {
        
        // Create a search filter for the connection search
        StringBuilder connectionSearchFilter = new StringBuilder();

        // Add the prefix to the search filter, prefix filter searches for guacConfigGroups with the userDN as the member attribute value
        connectionSearchFilter.append("(&(objectClass=guacConfigGroup)(|(member=");
        connectionSearchFilter.append(escapingService.escapeLDAPSearchFilter(userDN));
        connectionSearchFilter.append(")");

        // If group base DN is specified search for user groups
        String groupBaseDN = confService.getGroupBaseDN();

        if (groupBaseDN != null) {

            // Get all groups the user is a member of starting at the groupBaseDN, excluding guacConfigGroups
            LDAPSearchResults userRoleGroupResults = ldapConnection.search(
                groupBaseDN,
                LDAPConnection.SCOPE_SUB,
                "(&(!(objectClass=guacConfigGroup))(member="  escapingService.escapeLDAPSearchFilter(userDN)  "))",
                null,
                false
            );

            // Append the additional user groups to the LDAP filter
            // Now the filter will also look for guacConfigGroups that refer 
            // to groups the user is a member of
            // The guacConfig group uses the seeAlso attribute to refer 
            // to these other groups
            while (userRoleGroupResults.hasMore()) {
                LDAPEntry entry = userRoleGroupResults.next();
                connectionSearchFilter.append("(seeAlso=").append(escapingService.escapeLDAPSearchFilter(entry.getDN())).append(")");
            }
        }
        
        // Complete the search filter.
        connectionSearchFilter.append("))");  
        
        return connectionSearchFilter.toString();
    }


     * The base DN of role based access control (RBAC) groups. All groups
     * should be under this DN.
        if (configurationBaseDN == null)

        }
        catch (LDAPException e) {

     *
     *     If an error occurs retrieving the group base DN.
    private String getConnectionSearchFilter(String userDN,
            LDAPConnection ldapConnection)
            throws LDAPException, GuacamoleException {

            // Now the filter will also look for guacConfigGroups that refer
            // The guacConfig group uses the seeAlso attribute to refer

        connectionSearchFilter.append("))");

     * The base DN of role based access control (RBAC) groups. All groups which
     * will be used for RBAC must be contained somewhere within the subtree of
     * this DN.
     * (RBAC) groups will be stored within the LDAP directory. If RBAC will not
     * be used, null is returned.
     *     within the LDAP directory, or null if RBAC will not be used.
            // Get the search filter for finding connections accessible by the
            // current user
     * Returns an LDAP search filter which queries all connections accessible
     * by the user having the given DN.
     *     LDAP connection to use if additional information must be queried to
     *     produce the filter, such as groups driving RBAC.
     *     An LDAP search filter which queries all guacConfigGroup objects
     *     accessible by the user having the given DN.
     * Returns the base DN under which all Guacamole role based access control
     * (RBAC) groups will be stored within the LDAP directory. If RBAC will not
     * be used, null is returned.
     *
     * @return
     *     The base DN under which all Guacamole RBAC groups will be stored
     *     within the LDAP directory, or null if RBAC will not be used.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed.
     */
    public String getGroupBaseDN() throws GuacamoleException {
        return environment.getProperty(
            LDAPGuacamoleProperties.LDAP_GROUP_BASE_DN
        );
    }

    /**
     * The base DN of role based access control (RBAC) groups. All groups which
     * will be used for RBAC must be contained somewhere within the subtree of
     * this DN.
     */
    public static final StringGuacamoleProperty LDAP_GROUP_BASE_DN = new StringGuacamoleProperty() {

        @Override
        public String getName() { return "ldap-group-base-dn"; }

    };

    /**
            // Get the search filter for finding connections accessible by the
            // current user
            String connectionSearchFilter = getConnectionSearchFilter(userDN, ldapConnection);

            // Find all Guacamole connections for the given user by
            // looking for direct membership in the guacConfigGroup
            // and possibly any groups the user is a member of that are
            // referred to in the seeAlso attribute of the guacConfigGroup.
                connectionSearchFilter,
    /**
     * Returns an LDAP search filter which queries all connections accessible
     * by the user having the given DN.
     *
     * @param userDN
     *     DN of the user to search for associated guacConfigGroup connections.
     *
     * @param ldapConnection
     *     LDAP connection to use if additional information must be queried to
     *     produce the filter, such as groups driving RBAC.
     *
     * @return
     *     An LDAP search filter which queries all guacConfigGroup objects
     *     accessible by the user having the given DN.
     *
     * @throws LDAPException
     *     If an error occurs preventing retrieval of user groups.
     *
     * @throws GuacamoleException
     *     If an error occurs retrieving the group base DN.
     */
    private String getConnectionSearchFilter(String userDN,
            LDAPConnection ldapConnection)
            throws LDAPException, GuacamoleException {

        // Create a search filter for the connection search
        StringBuilder connectionSearchFilter = new StringBuilder();

        // Add the prefix to the search filter, prefix filter searches for guacConfigGroups with the userDN as the member attribute value
        connectionSearchFilter.append("(&(objectClass=guacConfigGroup)(|(member=");
        connectionSearchFilter.append(escapingService.escapeLDAPSearchFilter(userDN));
        connectionSearchFilter.append(")");

        // If group base DN is specified search for user groups
        String groupBaseDN = confService.getGroupBaseDN();
        if (groupBaseDN != null) {

            // Get all groups the user is a member of starting at the groupBaseDN, excluding guacConfigGroups
            LDAPSearchResults userRoleGroupResults = ldapConnection.search(
                groupBaseDN,
                LDAPConnection.SCOPE_SUB,
                "(&(!(objectClass=guacConfigGroup))(member="  escapingService.escapeLDAPSearchFilter(userDN)  "))",
                null,
                false
            );

            // Append the additional user groups to the LDAP filter
            // Now the filter will also look for guacConfigGroups that refer
            // to groups the user is a member of
            // The guacConfig group uses the seeAlso attribute to refer
            // to these other groups
            while (userRoleGroupResults.hasMore()) {
                LDAPEntry entry = userRoleGroupResults.next();
                connectionSearchFilter.append("(seeAlso=").append(escapingService.escapeLDAPSearchFilter(entry.getDN())).append(")");
            }
        }

        // Complete the search filter.
        connectionSearchFilter.append("))");

        return connectionSearchFilter.toString();
    }


 * Copyright (C) 2016 Glyptodon LLC
 *
 *
 *
import java.text.SimpleDateFormat;
import java.util.Date;
     * The name of the date token (server-local time) added via
     * addStandardTokens().
     */
    private static final String DATE_TOKEN = "GUAC_DATE";

    /**
     * The name of the time token (server-local time) added via
     * addStandardTokens().
     */
    private static final String TIME_TOKEN = "GUAC_TIME";

    /**
     * The date format that should be used for the date token. This format must
     * be compatible with Java's SimpleDateFormat.
     */
    private static final String DATE_FORMAT = "yyyyMMdd";

    /**
     * The date format that should be used for the time token. This format must
     * be compatible with Java's SimpleDateFormat.
     */
    private static final String TIME_FORMAT = "HHmmss";

    /**
     * Adds tokens which are standardized by guacamole-ext to the given
     * TokenFilter using the values from the given Credentials object. These
     * standardized tokens include the current username (GUAC_USERNAME),
     * password (GUAC_PASSWORD), and the server date and time (GUAC_DATE and
     * GUAC_TIME respectively). If either the username or password are not set


        // Add date/time tokens (server-local time)
        Date currentTime = new Date();
        filter.setToken(DATE_TOKEN, new SimpleDateFormat(DATE_FORMAT).format(currentTime));
        filter.setToken(TIME_TOKEN, new SimpleDateFormat(TIME_FORMAT).format(currentTime));

     * TokenFilter and which do not require a corresponding Credentials object.
     * These the server date and time (GUAC_DATE and GUAC_TIME respectively).
     *
     * @param filter
     *     The TokenFilter to add standard tokens to.
     */
    public static void addStandardTokens(TokenFilter filter) {

        // Add date/time tokens (server-local time)
        Date currentTime = new Date();
        filter.setToken(DATE_TOKEN, new SimpleDateFormat(DATE_FORMAT).format(currentTime));
        filter.setToken(TIME_TOKEN, new SimpleDateFormat(TIME_FORMAT).format(currentTime));

    }

    /**
     * Adds tokens which are standardized by guacamole-ext to the given
     *     The TokenFilter to add standard tokens to.
     *     The Credentials to use when populating the GUAC_USERNAME and
     *     GUAC_PASSWORD tokens.
        // Add any tokens which do not require credentials
        addStandardTokens(filter);
    public static final String USERNAME_TOKEN = "GUAC_USERNAME";
    public static final String PASSWORD_TOKEN = "GUAC_PASSWORD";
    public static final String DATE_TOKEN = "GUAC_DATE";
    public static final String TIME_TOKEN = "GUAC_TIME";
 * Copyright (C) 2016 Glyptodon LLC
 *
 *
 *
import java.text.SimpleDateFormat;
import java.util.Date;
    public static final String USERNAME_TOKEN = "GUAC_USERNAME";
    public static final String PASSWORD_TOKEN = "GUAC_PASSWORD";

    /**
     * The name of the date token (server-local time) added via
     * addStandardTokens().
     */
    public static final String DATE_TOKEN = "GUAC_DATE";

    /**
     * The name of the time token (server-local time) added via
     * addStandardTokens().
     */
    public static final String TIME_TOKEN = "GUAC_TIME";

    /**
     * The date format that should be used for the date token. This format must
     * be compatible with Java's SimpleDateFormat.
     */
    private static final String DATE_FORMAT = "yyyyMMdd";

    /**
     * The date format that should be used for the time token. This format must
     * be compatible with Java's SimpleDateFormat.
     */
    private static final String TIME_FORMAT = "HHmmss";
     * Adds tokens which are standardized by guacamole-ext to the given
     * TokenFilter and which do not require a corresponding Credentials object.
     * These the server date and time (GUAC_DATE and GUAC_TIME respectively).
     *
     * @param filter
     *     The TokenFilter to add standard tokens to.
     */
    public static void addStandardTokens(TokenFilter filter) {

        // Add date/time tokens (server-local time)
        Date currentTime = new Date();
        filter.setToken(DATE_TOKEN, new SimpleDateFormat(DATE_FORMAT).format(currentTime));
        filter.setToken(TIME_TOKEN, new SimpleDateFormat(TIME_FORMAT).format(currentTime));

    }

    /**
     * Adds tokens which are standardized by guacamole-ext to the given
     * TokenFilter using the values from the given Credentials object. These
     * standardized tokens include the current username (GUAC_USERNAME),
     * password (GUAC_PASSWORD), and the server date and time (GUAC_DATE and
     * GUAC_TIME respectively). If either the username or password are not set
     *     The TokenFilter to add standard tokens to.
     *     The Credentials to use when populating the GUAC_USERNAME and
     *     GUAC_PASSWORD tokens.


        // Add any tokens which do not require credentials
        addStandardTokens(filter);

     * Map of all HTML patch resources defined within the extension, where each
     * key is the path to that resource within the extension.
     */
    private final Map<String, Resource> htmlResources;

    /**
        htmlResources = getClassPathResources("text/html", manifest.getHTMLPaths());
     * Returns a map of all declared HTML patch resources associated with this
     * extension, where the key of each entry in the map is the path to that
     * resource within the extension .jar. HTML patch resources are declared
     * within the extension manifest.
     *
     * @return
     *     All declared HTML patch resources associated with this extension.
     */
    public Map<String, Resource> getHTMLResources() {
        return htmlResources;
    }

    /**
     * The paths of all HTML patch resources within the .jar of the extension
     * associated with this manifest.
     */
    private Collection<String> htmlPaths;

    /**
     * Returns the paths to all HTML patch resources within the extension. These
     * paths are defined within the manifest by the "html" property as an array
     * of strings, where each string is a path relative to the root of the
     * extension .jar.
     *
     * @return
     *     A collection of paths to all HTML patch resources within the
     *     extension.
     */
    @JsonProperty("html")
    public Collection<String> getHTMLPaths() {
        return htmlPaths;
    }

    /**
     * Sets the paths to all HTML patch resources within the extension. These
     * paths are defined within the manifest by the "html" property as an array
     * of strings, where each string is a path relative to the root of the
     * extension .jar.
     *
     * @param htmlPatchPaths
     *     A collection of paths to all HTML patch resources within the
     *     extension.
     */
    @JsonProperty("html")
    public void setHTMLPaths(Collection<String> htmlPatchPaths) {
        this.htmlPaths = htmlPatchPaths;
    }

    /**

    /**
     * Service for adding and retrieving HTML patch resources.
     */
    private final PatchResourceService patchResourceService;
        this.patchResourceService = new PatchResourceService();
     * @param cssResources
                // Add all HTML patch resources
                patchResourceService.addPatchResources(extension.getHTMLResources().values());

        // Bind resource services
        bind(PatchResourceService.class).toInstance(patchResourceService);

import org.glyptodon.guacamole.net.basic.rest.patch.PatchRESTService;
        bind(PatchRESTService.class);
     * Map of all HTML patch resources defined within the extension, where each
     * key is the path to that resource within the extension.
     */
    private final Map<String, Resource> htmlResources;

    /**
        htmlResources = getClassPathResources("text/html", manifest.getHTMLPaths());
     * Returns a map of all declared HTML patch resources associated with this
     * extension, where the key of each entry in the map is the path to that
     * resource within the extension .jar. HTML patch resources are declared
     * within the extension manifest.
     *
     * @return
     *     All declared HTML patch resources associated with this extension.
     */
    public Map<String, Resource> getHTMLResources() {
        return htmlResources;
    }

    /**
     * The paths of all HTML patch resources within the .jar of the extension
     * associated with this manifest.
     */
    private Collection<String> htmlPaths;

    /**
     * Returns the paths to all HTML patch resources within the extension. These
     * paths are defined within the manifest by the "html" property as an array
     * of strings, where each string is a path relative to the root of the
     * extension .jar.
     *
     * @return
     *     A collection of paths to all HTML patch resources within the
     *     extension.
     */
    @JsonProperty("html")
    public Collection<String> getHTMLPaths() {
        return htmlPaths;
    }

    /**
     * Sets the paths to all HTML patch resources within the extension. These
     * paths are defined within the manifest by the "html" property as an array
     * of strings, where each string is a path relative to the root of the
     * extension .jar.
     *
     * @param htmlPatchPaths
     *     A collection of paths to all HTML patch resources within the
     *     extension.
     */
    @JsonProperty("html")
    public void setHTMLPaths(Collection<String> htmlPatchPaths) {
        this.htmlPaths = htmlPatchPaths;
    }

    /**

    /**
     * Service for adding and retrieving HTML patch resources.
     */
    private final PatchResourceService patchResourceService;
        this.patchResourceService = new PatchResourceService();
     * @param cssResources
                // Add all HTML patch resources
                patchResourceService.addPatchResources(extension.getHTMLResources().values());

        // Bind resource services
        bind(PatchResourceService.class).toInstance(patchResourceService);

import org.glyptodon.guacamole.net.basic.rest.patch.PatchRESTService;
        bind(PatchRESTService.class);
        try {

            char buffer[] = new char[8192];
            int length;

            while ((length = reader.read(buffer)) != -1) {
                contents.append(buffer, 0, length);
            }

        }

        // Ensure resource is always closed
        finally {
            reader.close();
        try {

            char buffer[] = new char[8192];
            int length;

            while ((length = reader.read(buffer)) != -1) {
                contents.append(buffer, 0, length);
            }

        }

        // Ensure resource is always closed
        finally {
            reader.close();
     * Returns the maximum number of concurrent connections to allow overall.
     * As this limit applies globally (independent of which connection is in
     * use or which user is using it), this setting cannot be overridden at the
     * connection level. Zero denotes unlimited.
     *
     * @return
     *     The maximum allowable number of concurrent connections.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the property.
     */
    public abstract int getAbsoluteMaxConnections() throws GuacamoleException;

    /**
import com.google.inject.Inject;
import java.util.concurrent.atomic.AtomicInteger;
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
     * The environment of the Guacamole server.
     */
    @Inject
    private JDBCEnvironment environment;

    /**
     * The total number of active connections within this instance of
     * Guacamole.
     */
    private final AtomicInteger totalActiveConnections = new AtomicInteger(0);

    /**
    /**
     * Attempts to increment the given AtomicInteger without exceeding the
     * specified maximum value. If the AtomicInteger cannot be incremented
     * without exceeding the maximum, false is returned.
     *
     * @param counter
     *     The AtomicInteger to attempt increment.
     *
     * @param max
     *     The maximum value that the given AtomicInteger should contain, or
     *     zero if no limit applies.
     *
     * @return
     *     true if the AtomicInteger was successfully incremented without
     *     exceeding the specified maximum, false if the AtomicInteger could
     *     not be incremented.
     */
    private boolean tryIncrement(AtomicInteger counter, int max) {

        // Repeatedly attempt to increment the given AtomicInteger until we
        // explicitly succeed or explicitly fail
        while (true) {

            // Get current value
            int count = counter.get();

            // Bail out if the maximum has already been reached
            if (count >= max && max != 0)
                return false;

            // Attempt to increment
            if (counter.compareAndSet(count, count1))
                return true;

            // Try again if unsuccessful

        }

    }

        // Do not acquire connection unless within overall limits
        if (!tryIncrement(totalActiveConnections, environment.getAbsoluteMaxConnections()))
            throw new GuacamoleResourceConflictException("Cannot connect. Overall maximum connections reached.");

        // Acquire failed
        totalActiveConnections.decrementAndGet();

        totalActiveConnections.decrementAndGet();
     * The default value for the maximum number of connections to be
     * allowed to the Guacamole server overall.
     */
    private final int ABSOLUTE_MAX_CONNECTIONS = 0;

    /**
    public int getAbsoluteMaxConnections() throws GuacamoleException {
        return getProperty(MySQLGuacamoleProperties.MYSQL_ABSOLUTE_MAX_CONNECTIONS,
            ABSOLUTE_MAX_CONNECTIONS
        );
    }

    @Override
     * The maximum number of concurrent connections to allow overall. Zero
     * denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            MYSQL_ABSOLUTE_MAX_CONNECTIONS =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-absolute-max-connections"; }

    };

    /**
     * The default value for the maximum number of connections to be
     * allowed to the Guacamole server overall.
     */
    private final int ABSOLUTE_MAX_CONNECTIONS = 0;

    /**
    public int getAbsoluteMaxConnections() throws GuacamoleException {
        return getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_ABSOLUTE_MAX_CONNECTIONS,
            ABSOLUTE_MAX_CONNECTIONS
        );
    }

    @Override
     * The maximum number of concurrent connections to allow overall. Zero
     * denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            POSTGRESQL_ABSOLUTE_MAX_CONNECTIONS =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-absolute-max-connections"; }

    };

    /**
     *     The AtomicInteger to attempt to increment.
    private final int DEFAULT_ABSOLUTE_MAX_CONNECTIONS = 0;
            DEFAULT_ABSOLUTE_MAX_CONNECTIONS
    private final int DEFAULT_ABSOLUTE_MAX_CONNECTIONS = 0;
            DEFAULT_ABSOLUTE_MAX_CONNECTIONS
     * Returns the maximum number of concurrent connections to allow overall.
     * As this limit applies globally (independent of which connection is in
     * use or which user is using it), this setting cannot be overridden at the
     * connection level. Zero denotes unlimited.
     *
     * @return
     *     The maximum allowable number of concurrent connections.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the property.
     */
    public abstract int getAbsoluteMaxConnections() throws GuacamoleException;

    /**
import com.google.inject.Inject;
import java.util.concurrent.atomic.AtomicInteger;
import org.glyptodon.guacamole.auth.jdbc.JDBCEnvironment;
     * The environment of the Guacamole server.
     */
    @Inject
    private JDBCEnvironment environment;

    /**
     * The total number of active connections within this instance of
     * Guacamole.
     */
    private final AtomicInteger totalActiveConnections = new AtomicInteger(0);

    /**
    /**
     * Attempts to increment the given AtomicInteger without exceeding the
     * specified maximum value. If the AtomicInteger cannot be incremented
     * without exceeding the maximum, false is returned.
     *
     * @param counter
     *     The AtomicInteger to attempt to increment.
     *
     * @param max
     *     The maximum value that the given AtomicInteger should contain, or
     *     zero if no limit applies.
     *
     * @return
     *     true if the AtomicInteger was successfully incremented without
     *     exceeding the specified maximum, false if the AtomicInteger could
     *     not be incremented.
     */
    private boolean tryIncrement(AtomicInteger counter, int max) {

        // Repeatedly attempt to increment the given AtomicInteger until we
        // explicitly succeed or explicitly fail
        while (true) {

            // Get current value
            int count = counter.get();

            // Bail out if the maximum has already been reached
            if (count >= max && max != 0)
                return false;

            // Attempt to increment
            if (counter.compareAndSet(count, count1))
                return true;

            // Try again if unsuccessful

        }

    }

        // Do not acquire connection unless within overall limits
        if (!tryIncrement(totalActiveConnections, environment.getAbsoluteMaxConnections()))
            throw new GuacamoleResourceConflictException("Cannot connect. Overall maximum connections reached.");

        // Acquire failed
        totalActiveConnections.decrementAndGet();

        totalActiveConnections.decrementAndGet();
     * The default value for the maximum number of connections to be
     * allowed to the Guacamole server overall.
     */
    private final int DEFAULT_ABSOLUTE_MAX_CONNECTIONS = 0;

    /**
    public int getAbsoluteMaxConnections() throws GuacamoleException {
        return getProperty(MySQLGuacamoleProperties.MYSQL_ABSOLUTE_MAX_CONNECTIONS,
            DEFAULT_ABSOLUTE_MAX_CONNECTIONS
        );
    }

    @Override
     * The maximum number of concurrent connections to allow overall. Zero
     * denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            MYSQL_ABSOLUTE_MAX_CONNECTIONS =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-absolute-max-connections"; }

    };

    /**
     * The default value for the maximum number of connections to be
     * allowed to the Guacamole server overall.
     */
    private final int DEFAULT_ABSOLUTE_MAX_CONNECTIONS = 0;

    /**
    public int getAbsoluteMaxConnections() throws GuacamoleException {
        return getProperty(PostgreSQLGuacamoleProperties.POSTGRESQL_ABSOLUTE_MAX_CONNECTIONS,
            DEFAULT_ABSOLUTE_MAX_CONNECTIONS
        );
    }

    @Override
     * The maximum number of concurrent connections to allow overall. Zero
     * denotes unlimited.
     */
    public static final IntegerGuacamoleProperty
            POSTGRESQL_ABSOLUTE_MAX_CONNECTIONS =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-absolute-max-connections"; }

    };

    /**
 b/doc/guacamole-example/src/main/java/org/apache/guacamole/net/example/DummyGuacamoleTunnelServlet.java
package org.apache.guacamole.net.example;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleSocket;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.InetGuacamoleSocket;
import org.apache.guacamole.net.SimpleGuacamoleTunnel;
import org.apache.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
import org.apache.guacamole.servlet.GuacamoleHTTPTunnelServlet;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/JDBCAuthenticationProviderModule.java
package org.apache.guacamole.auth.jdbc;
import org.apache.guacamole.auth.jdbc.user.UserContext;
import org.apache.guacamole.auth.jdbc.connectiongroup.RootConnectionGroup;
import org.apache.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
import org.apache.guacamole.auth.jdbc.connectiongroup.ConnectionGroupDirectory;
import org.apache.guacamole.auth.jdbc.connection.ConnectionDirectory;
import org.apache.guacamole.auth.jdbc.connection.ModeledGuacamoleConfiguration;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.permission.SystemPermissionSet;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.auth.jdbc.user.UserDirectory;
import org.apache.guacamole.auth.jdbc.connectiongroup.ConnectionGroupMapper;
import org.apache.guacamole.auth.jdbc.connection.ConnectionMapper;
import org.apache.guacamole.auth.jdbc.connection.ConnectionRecordMapper;
import org.apache.guacamole.auth.jdbc.connection.ParameterMapper;
import org.apache.guacamole.auth.jdbc.permission.SystemPermissionMapper;
import org.apache.guacamole.auth.jdbc.user.UserMapper;
import org.apache.guacamole.auth.jdbc.connectiongroup.ConnectionGroupService;
import org.apache.guacamole.auth.jdbc.connection.ConnectionService;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.auth.jdbc.security.PasswordEncryptionService;
import org.apache.guacamole.auth.jdbc.security.SHA256PasswordEncryptionService;
import org.apache.guacamole.auth.jdbc.security.SaltService;
import org.apache.guacamole.auth.jdbc.security.SecureRandomSaltService;
import org.apache.guacamole.auth.jdbc.permission.SystemPermissionService;
import org.apache.guacamole.auth.jdbc.user.UserService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionGroupPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.ConnectionGroupPermissionService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionGroupPermissionSet;
import org.apache.guacamole.auth.jdbc.permission.ConnectionPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.ConnectionPermissionService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionPermissionSet;
import org.apache.guacamole.auth.jdbc.permission.UserPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.UserPermissionService;
import org.apache.guacamole.auth.jdbc.permission.UserPermissionSet;
import org.apache.guacamole.auth.jdbc.activeconnection.ActiveConnectionDirectory;
import org.apache.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionService;
import org.apache.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionSet;
import org.apache.guacamole.auth.jdbc.activeconnection.ActiveConnectionService;
import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.tunnel.RestrictedGuacamoleTunnelService;
import org.apache.guacamole.net.auth.AuthenticationProvider;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/JDBCEnvironment.java
package org.apache.guacamole.auth.jdbc;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.LocalEnvironment;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/activeconnection/ActiveConnectionDirectory.java
package org.apache.guacamole.auth.jdbc.activeconnection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.Directory;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/activeconnection/ActiveConnectionPermissionService.java
package org.apache.guacamole.auth.jdbc.activeconnection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.permission.AbstractPermissionService;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionService;
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/activeconnection/ActiveConnectionPermissionSet.java
package org.apache.guacamole.auth.jdbc.activeconnection;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionService;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionSet;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/activeconnection/ActiveConnectionService.java
package org.apache.guacamole.auth.jdbc.activeconnection;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.base.DirectoryObjectService;
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ActiveConnection;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/activeconnection/TrackedActiveConnection.java
package org.apache.guacamole.auth.jdbc.activeconnection;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ActiveConnection;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/activeconnection/package-info.java
package org.apache.guacamole.auth.jdbc.activeconnection;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/DirectoryObjectService.java
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/GroupedObjectModel.java
package org.apache.guacamole.auth.jdbc.base;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ModeledDirectoryObject.java
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.net.auth.Identifiable;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ModeledDirectoryObjectMapper.java
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.auth.jdbc.user.UserModel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ModeledDirectoryObjectService.java
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionModel;
import org.apache.guacamole.auth.jdbc.user.UserModel;
import org.apache.guacamole.net.auth.Identifiable;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ModeledGroupedDirectoryObject.java
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.auth.jdbc.connectiongroup.RootConnectionGroup;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ModeledGroupedDirectoryObjectService.java
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.net.auth.Identifiable;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ModeledObject.java
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ObjectModel.java
package org.apache.guacamole.auth.jdbc.base;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/RestrictedObject.java
package org.apache.guacamole.auth.jdbc.base;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/package-info.java
package org.apache.guacamole.auth.jdbc.base;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionDirectory.java
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.Directory;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionMapper.java
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.apache.guacamole.auth.jdbc.user.UserModel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionModel.java
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.auth.jdbc.base.GroupedObjectModel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionRecordMapper.java
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.auth.jdbc.user.UserModel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionRecordModel.java
package org.apache.guacamole.auth.jdbc.connection;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionRecordSearchTerm.java
package org.apache.guacamole.auth.jdbc.connection;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionRecordSet.java
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.ConnectionRecord;
        implements org.apache.guacamole.net.auth.ConnectionRecordSet {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionRecordSortPredicate.java
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.net.auth.ConnectionRecordSet;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionService.java
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObjectService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ModeledConnection.java
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
import org.apache.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObject;
import org.apache.guacamole.form.Field;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.form.NumericField;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ModeledConnectionRecord.java
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.net.auth.ConnectionRecord;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ModeledGuacamoleConfiguration.java
package org.apache.guacamole.auth.jdbc.connection;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ParameterMapper.java
package org.apache.guacamole.auth.jdbc.connection;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ParameterModel.java
package org.apache.guacamole.auth.jdbc.connection;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/package-info.java
package org.apache.guacamole.auth.jdbc.connection;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connectiongroup/ConnectionGroupDirectory.java
package org.apache.guacamole.auth.jdbc.connectiongroup;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.Directory;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connectiongroup/ConnectionGroupMapper.java
package org.apache.guacamole.auth.jdbc.connectiongroup;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.apache.guacamole.auth.jdbc.user.UserModel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connectiongroup/ConnectionGroupModel.java
package org.apache.guacamole.auth.jdbc.connectiongroup;
import org.apache.guacamole.auth.jdbc.base.GroupedObjectModel;
import org.apache.guacamole.net.auth.ConnectionGroup;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connectiongroup/ConnectionGroupService.java
package org.apache.guacamole.auth.jdbc.connectiongroup;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.GuacamoleUnsupportedException;
import org.apache.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObjectService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionGroupPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connectiongroup/ModeledConnectionGroup.java
package org.apache.guacamole.auth.jdbc.connectiongroup;
import org.apache.guacamole.auth.jdbc.connection.ConnectionService;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
import org.apache.guacamole.auth.jdbc.base.ModeledGroupedDirectoryObject;
import org.apache.guacamole.form.Field;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.form.NumericField;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connectiongroup/RootConnectionGroup.java
package org.apache.guacamole.auth.jdbc.connectiongroup;
import org.apache.guacamole.auth.jdbc.connection.ConnectionService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connectiongroup/package-info.java
package org.apache.guacamole.auth.jdbc.connectiongroup;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/package-info.java
package org.apache.guacamole.auth.jdbc;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/AbstractPermissionService.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.Permission;
import org.apache.guacamole.net.auth.permission.PermissionSet;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/ConnectionGroupPermissionMapper.java
package org.apache.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/ConnectionGroupPermissionService.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/ConnectionGroupPermissionSet.java
package org.apache.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/ConnectionPermissionMapper.java
package org.apache.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/ConnectionPermissionService.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/ConnectionPermissionSet.java
package org.apache.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/ModeledObjectPermissionService.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/ModeledPermissionService.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.permission.Permission;
import org.apache.guacamole.net.auth.permission.PermissionSet;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/ObjectPermissionMapper.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.UserModel;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/ObjectPermissionModel.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/ObjectPermissionService.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/ObjectPermissionSet.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
    implements org.apache.guacamole.net.auth.permission.ObjectPermissionSet {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/PermissionMapper.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.UserModel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/PermissionModel.java
package org.apache.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/PermissionService.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.Permission;
import org.apache.guacamole.net.auth.permission.PermissionSet;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/SystemPermissionMapper.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.UserModel;
import org.apache.guacamole.net.auth.permission.SystemPermission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/SystemPermissionModel.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.net.auth.permission.SystemPermission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/SystemPermissionService.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.GuacamoleUnsupportedException;
import org.apache.guacamole.net.auth.permission.SystemPermission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/SystemPermissionSet.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.permission.SystemPermission;
    implements org.apache.guacamole.net.auth.permission.SystemPermissionSet {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/UserPermissionMapper.java
package org.apache.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/UserPermissionService.java
package org.apache.guacamole.auth.jdbc.permission;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/UserPermissionSet.java
package org.apache.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/permission/package-info.java
package org.apache.guacamole.auth.jdbc.permission;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/security/PasswordEncryptionService.java
package org.apache.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/security/SHA256PasswordEncryptionService.java
package org.apache.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/security/SaltService.java
package org.apache.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/security/SecureRandomSaltService.java
package org.apache.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/security/package-info.java
package org.apache.guacamole.auth.jdbc.security;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/tunnel/AbstractGuacamoleTunnelService.java
package org.apache.guacamole.auth.jdbc.tunnel;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
import org.apache.guacamole.auth.jdbc.connection.ConnectionRecordMapper;
import org.apache.guacamole.auth.jdbc.connection.ParameterMapper;
import org.apache.guacamole.auth.jdbc.connection.ConnectionModel;
import org.apache.guacamole.auth.jdbc.connection.ConnectionRecordModel;
import org.apache.guacamole.auth.jdbc.connection.ParameterModel;
import org.apache.guacamole.auth.jdbc.user.UserModel;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
import org.apache.guacamole.auth.jdbc.connection.ConnectionMapper;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.net.GuacamoleSocket;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
import org.apache.guacamole.token.StandardTokens;
import org.apache.guacamole.token.TokenFilter;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/tunnel/ActiveConnectionMultimap.java
package org.apache.guacamole.auth.jdbc.tunnel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/tunnel/ActiveConnectionRecord.java
package org.apache.guacamole.auth.jdbc.tunnel;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.net.AbstractGuacamoleTunnel;
import org.apache.guacamole.net.GuacamoleSocket;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ConnectionRecord;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/tunnel/GuacamoleTunnelService.java
package org.apache.guacamole.auth.jdbc.tunnel;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/tunnel/ManagedInetGuacamoleSocket.java
package org.apache.guacamole.auth.jdbc.tunnel;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.InetGuacamoleSocket;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/tunnel/ManagedSSLGuacamoleSocket.java
package org.apache.guacamole.auth.jdbc.tunnel;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.SSLGuacamoleSocket;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/tunnel/RestrictedGuacamoleTunnelService.java
package org.apache.guacamole.auth.jdbc.tunnel;
import org.apache.guacamole.GuacamoleClientTooManyException;
import org.apache.guacamole.auth.jdbc.user.AuthenticatedUser;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceConflictException;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
import org.apache.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/tunnel/Seat.java
package org.apache.guacamole.auth.jdbc.tunnel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/tunnel/package-info.java
package org.apache.guacamole.auth.jdbc.tunnel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/user/AuthenticatedUser.java
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
public class AuthenticatedUser implements org.apache.guacamole.net.auth.AuthenticatedUser {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/user/AuthenticationProviderService.java
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.credentials.CredentialsInfo;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
    public UserContext getUserContext(org.apache.guacamole.net.auth.AuthenticatedUser authenticatedUser)
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/user/ModeledUser.java
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObject;
import org.apache.guacamole.auth.jdbc.security.PasswordEncryptionService;
import org.apache.guacamole.auth.jdbc.security.SaltService;
import org.apache.guacamole.auth.jdbc.permission.SystemPermissionService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.activeconnection.ActiveConnectionPermissionService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionGroupPermissionService;
import org.apache.guacamole.auth.jdbc.permission.ConnectionPermissionService;
import org.apache.guacamole.auth.jdbc.permission.UserPermissionService;
import org.apache.guacamole.form.BooleanField;
import org.apache.guacamole.form.DateField;
import org.apache.guacamole.form.Field;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.form.TimeField;
import org.apache.guacamole.form.TimeZoneField;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/user/UserContext.java
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.auth.jdbc.connectiongroup.RootConnectionGroup;
import org.apache.guacamole.auth.jdbc.connectiongroup.ConnectionGroupDirectory;
import org.apache.guacamole.auth.jdbc.connection.ConnectionDirectory;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.auth.jdbc.activeconnection.ActiveConnectionDirectory;
import org.apache.guacamole.auth.jdbc.connection.ConnectionRecordSet;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.connectiongroup.ModeledConnectionGroup;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
    implements org.apache.guacamole.net.auth.UserContext {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/user/UserDirectory.java
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.base.RestrictedObject;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/user/UserMapper.java
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/user/UserModel.java
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.auth.jdbc.base.ObjectModel;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/user/UserService.java
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectMapper;
import org.apache.guacamole.auth.jdbc.base.ModeledDirectoryObjectService;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleUnsupportedException;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.ObjectPermissionModel;
import org.apache.guacamole.auth.jdbc.permission.UserPermissionMapper;
import org.apache.guacamole.auth.jdbc.security.PasswordEncryptionService;
import org.apache.guacamole.form.Field;
import org.apache.guacamole.form.PasswordField;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.credentials.CredentialsInfo;
import org.apache.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
    public ModeledUser retrieveUser(org.apache.guacamole.net.auth.AuthenticatedUser authenticatedUser) {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/user/package-info.java
package org.apache.guacamole.auth.jdbc.user;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProviderModule;
import org.apache.guacamole.auth.jdbc.user.AuthenticationProviderService;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
import org.apache.guacamole.properties.BooleanGuacamoleProperty;
import org.apache.guacamole.properties.IntegerGuacamoleProperty;
import org.apache.guacamole.properties.StringGuacamoleProperty;
 * org.apache for backwards-compatibility.
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-postgresql/src/main/java/org/apache/guacamole/auth/postgresql/PostgreSQLAuthenticationProvider.java
package org.apache.guacamole.auth.postgresql;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProviderModule;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
import org.apache.guacamole.auth.jdbc.user.AuthenticationProviderService;
import org.apache.guacamole.net.auth.AuthenticatedUser;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-postgresql/src/main/java/org/apache/guacamole/auth/postgresql/PostgreSQLAuthenticationProviderModule.java
package org.apache.guacamole.auth.postgresql;
import org.apache.guacamole.GuacamoleException;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-postgresql/src/main/java/org/apache/guacamole/auth/postgresql/PostgreSQLEnvironment.java
package org.apache.guacamole.auth.postgresql;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.JDBCEnvironment;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-postgresql/src/main/java/org/apache/guacamole/auth/postgresql/PostgreSQLGuacamoleProperties.java
package org.apache.guacamole.auth.postgresql;
import org.apache.guacamole.properties.BooleanGuacamoleProperty;
import org.apache.guacamole.properties.IntegerGuacamoleProperty;
import org.apache.guacamole.properties.StringGuacamoleProperty;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-postgresql/src/main/java/org/apache/guacamole/auth/postgresql/package-info.java
package org.apache.guacamole.auth.postgresql;
import org.apache.guacamole.auth.ldap.AuthenticationProviderService;
import org.apache.guacamole.auth.ldap.LDAPAuthenticationProviderModule;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/AuthenticationProviderService.java
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.auth.ldap.user.AuthenticatedUser;
import org.apache.guacamole.auth.ldap.user.UserContext;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.ldap.user.UserService;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.credentials.CredentialsInfo;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
    public UserContext getUserContext(org.apache.guacamole.net.auth.AuthenticatedUser authenticatedUser)
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/ConfigurationService.java
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/EncryptionMethod.java
package org.apache.guacamole.auth.ldap;
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/EncryptionMethodProperty.java
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.properties.GuacamoleProperty;
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/EscapingService.java
package org.apache.guacamole.auth.ldap;
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/LDAPAuthenticationProviderModule.java
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.auth.ldap.connection.ConnectionService;
import org.apache.guacamole.auth.ldap.user.UserService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.auth.AuthenticationProvider;
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/LDAPConnectionService.java
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleUnsupportedException;
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/LDAPGuacamoleProperties.java
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.properties.IntegerGuacamoleProperty;
import org.apache.guacamole.properties.StringGuacamoleProperty;
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/StringListProperty.java
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.properties.GuacamoleProperty;
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/connection/ConnectionService.java
package org.apache.guacamole.auth.ldap.connection;
import org.apache.guacamole.auth.ldap.ConfigurationService;
import org.apache.guacamole.auth.ldap.EscapingService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.simple.SimpleConnection;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
import org.apache.guacamole.token.StandardTokens;
import org.apache.guacamole.token.TokenFilter;
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/user/AuthenticatedUser.java
package org.apache.guacamole.auth.ldap.user;
import org.apache.guacamole.net.auth.AbstractAuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/user/UserContext.java
package org.apache.guacamole.auth.ldap.user;
import org.apache.guacamole.auth.ldap.connection.ConnectionService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.ConnectionRecordSet;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.simple.SimpleConnectionGroup;
import org.apache.guacamole.net.auth.simple.SimpleConnectionGroupDirectory;
import org.apache.guacamole.net.auth.simple.SimpleConnectionRecordSet;
import org.apache.guacamole.net.auth.simple.SimpleDirectory;
import org.apache.guacamole.net.auth.simple.SimpleUser;
public class UserContext implements org.apache.guacamole.net.auth.UserContext {
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/user/UserService.java
package org.apache.guacamole.auth.ldap.user;
import org.apache.guacamole.auth.ldap.ConfigurationService;
import org.apache.guacamole.auth.ldap.EscapingService;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.auth.ldap.LDAPGuacamoleProperties;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.simple.SimpleUser;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.auth.simple.SimpleAuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.properties.FileGuacamoleProperty;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleClientBadTypeException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleClientException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleClientOverrunException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleClientTimeoutException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleClientTooManyException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleConnectionClosedException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleResourceConflictException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleResourceNotFoundException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleSecurityException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleServerBusyException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleServerException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleUnauthorizedException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleUnsupportedException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleUpstreamException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/GuacamoleUpstreamTimeoutException.java
package org.apache.guacamole;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/io/GuacamoleReader.java
package org.apache.guacamole.io;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.protocol.GuacamoleInstruction;
 b/guacamole-common/src/main/java/org/apache/guacamole/io/GuacamoleWriter.java
package org.apache.guacamole.io;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.protocol.GuacamoleInstruction;
 b/guacamole-common/src/main/java/org/apache/guacamole/io/ReaderGuacamoleReader.java
package org.apache.guacamole.io;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.GuacamoleUpstreamTimeoutException;
import org.apache.guacamole.protocol.GuacamoleInstruction;
 b/guacamole-common/src/main/java/org/apache/guacamole/io/WriterGuacamoleWriter.java
package org.apache.guacamole.io;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.GuacamoleUpstreamTimeoutException;
import org.apache.guacamole.protocol.GuacamoleInstruction;
 b/guacamole-common/src/main/java/org/apache/guacamole/io/package-info.java
package org.apache.guacamole.io;
 b/guacamole-common/src/main/java/org/apache/guacamole/net/AbstractGuacamoleTunnel.java
package org.apache.guacamole.net;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
 b/guacamole-common/src/main/java/org/apache/guacamole/net/DelegatingGuacamoleTunnel.java
package org.apache.guacamole.net;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
 b/guacamole-common/src/main/java/org/apache/guacamole/net/GuacamoleSocket.java
package org.apache.guacamole.net;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
 b/guacamole-common/src/main/java/org/apache/guacamole/net/GuacamoleTunnel.java
package org.apache.guacamole.net;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
 b/guacamole-common/src/main/java/org/apache/guacamole/net/InetGuacamoleSocket.java
package org.apache.guacamole.net;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.ReaderGuacamoleReader;
import org.apache.guacamole.io.WriterGuacamoleWriter;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.GuacamoleUpstreamTimeoutException;
 b/guacamole-common/src/main/java/org/apache/guacamole/net/SSLGuacamoleSocket.java
package org.apache.guacamole.net;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.io.ReaderGuacamoleReader;
import org.apache.guacamole.io.WriterGuacamoleWriter;
 b/guacamole-common/src/main/java/org/apache/guacamole/net/SimpleGuacamoleTunnel.java
package org.apache.guacamole.net;
 b/guacamole-common/src/main/java/org/apache/guacamole/net/package-info.java
package org.apache.guacamole.net;
 b/guacamole-common/src/main/java/org/apache/guacamole/package-info.java
package org.apache.guacamole;
 b/guacamole-common/src/main/java/org/apache/guacamole/protocol/ConfiguredGuacamoleSocket.java
package org.apache.guacamole.protocol;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleSocket;
 b/guacamole-common/src/main/java/org/apache/guacamole/protocol/FilteredGuacamoleReader.java
package org.apache.guacamole.protocol;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
 b/guacamole-common/src/main/java/org/apache/guacamole/protocol/FilteredGuacamoleSocket.java
package org.apache.guacamole.protocol;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleSocket;
 b/guacamole-common/src/main/java/org/apache/guacamole/protocol/FilteredGuacamoleWriter.java
package org.apache.guacamole.protocol;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.io.GuacamoleWriter;
 b/guacamole-common/src/main/java/org/apache/guacamole/protocol/GuacamoleClientInformation.java
package org.apache.guacamole.protocol;
 b/guacamole-common/src/main/java/org/apache/guacamole/protocol/GuacamoleConfiguration.java
package org.apache.guacamole.protocol;
 b/guacamole-common/src/main/java/org/apache/guacamole/protocol/GuacamoleFilter.java
package org.apache.guacamole.protocol;
import org.apache.guacamole.GuacamoleException;
 b/guacamole-common/src/main/java/org/apache/guacamole/protocol/GuacamoleInstruction.java
package org.apache.guacamole.protocol;
 b/guacamole-common/src/main/java/org/apache/guacamole/protocol/GuacamoleParser.java
package org.apache.guacamole.protocol;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
 b/guacamole-common/src/main/java/org/apache/guacamole/protocol/GuacamoleStatus.java
package org.apache.guacamole.protocol;
 b/guacamole-common/src/main/java/org/apache/guacamole/protocol/package-info.java
package org.apache.guacamole.protocol;
 b/guacamole-common/src/main/java/org/apache/guacamole/servlet/GuacamoleHTTPTunnel.java
package org.apache.guacamole.servlet;
import org.apache.guacamole.net.DelegatingGuacamoleTunnel;
import org.apache.guacamole.net.GuacamoleTunnel;
 b/guacamole-common/src/main/java/org/apache/guacamole/servlet/GuacamoleHTTPTunnelMap.java
package org.apache.guacamole.servlet;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
 b/guacamole-common/src/main/java/org/apache/guacamole/servlet/GuacamoleHTTPTunnelServlet.java
package org.apache.guacamole.servlet;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-common/src/main/java/org/apache/guacamole/servlet/GuacamoleSession.java
package org.apache.guacamole.servlet;
import org.apache.guacamole.net.GuacamoleTunnel;
 b/guacamole-common/src/main/java/org/apache/guacamole/servlet/package-info.java
package org.apache.guacamole.servlet;
 b/guacamole-common/src/main/java/org/apache/guacamole/websocket/GuacamoleWebSocketTunnelEndpoint.java
package org.apache.guacamole.websocket;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole-ext/src/main/java/org/apache/guacamole/environment/Environment.java
package org.apache.guacamole.environment;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.properties.BooleanGuacamoleProperty;
import org.apache.guacamole.properties.GuacamoleProperty;
import org.apache.guacamole.properties.IntegerGuacamoleProperty;
import org.apache.guacamole.properties.StringGuacamoleProperty;
import org.apache.guacamole.protocols.ProtocolInfo;
 b/guacamole-ext/src/main/java/org/apache/guacamole/environment/LocalEnvironment.java
package org.apache.guacamole.environment;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.properties.GuacamoleProperty;
import org.apache.guacamole.protocols.ProtocolInfo;
                        "/org/apache/guacamole/protocols/"
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/BooleanField.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/DateField.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/EnumField.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/Field.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/FieldOption.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/Form.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/MultilineField.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/NumericField.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/PasswordField.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/TextField.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/TimeField.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/TimeZoneField.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/UsernameField.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/form/package-info.java
package org.apache.guacamole.form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/AbstractActiveConnection.java
package org.apache.guacamole.net.auth;
import org.apache.guacamole.net.GuacamoleTunnel;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/AbstractAuthenticatedUser.java
package org.apache.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/AbstractConnection.java
package org.apache.guacamole.net.auth;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/AbstractConnectionGroup.java
package org.apache.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/AbstractUser.java
package org.apache.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/ActiveConnection.java
package org.apache.guacamole.net.auth;
import org.apache.guacamole.net.GuacamoleTunnel;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/AuthenticatedUser.java
package org.apache.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/AuthenticationProvider.java
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/Connectable.java
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/Connection.java
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/ConnectionGroup.java
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/ConnectionRecord.java
package org.apache.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/ConnectionRecordSet.java
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/Credentials.java
package org.apache.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/Directory.java
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/Identifiable.java
package org.apache.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/User.java
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/UserContext.java
package org.apache.guacamole.net.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.form.Form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/credentials/CredentialsInfo.java
package org.apache.guacamole.net.auth.credentials;
import org.apache.guacamole.form.Field;
import org.apache.guacamole.form.PasswordField;
import org.apache.guacamole.form.UsernameField;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/credentials/GuacamoleCredentialsException.java
package org.apache.guacamole.net.auth.credentials;
import org.apache.guacamole.GuacamoleUnauthorizedException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/credentials/GuacamoleInsufficientCredentialsException.java
package org.apache.guacamole.net.auth.credentials;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/credentials/GuacamoleInvalidCredentialsException.java
package org.apache.guacamole.net.auth.credentials;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/package-info.java
package org.apache.guacamole.net.auth;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/permission/ObjectPermission.java
package org.apache.guacamole.net.auth.permission;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/permission/ObjectPermissionSet.java
package org.apache.guacamole.net.auth.permission;
import org.apache.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/permission/Permission.java
package org.apache.guacamole.net.auth.permission;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/permission/PermissionSet.java
package org.apache.guacamole.net.auth.permission;
import org.apache.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/permission/SystemPermission.java
package org.apache.guacamole.net.auth.permission;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/permission/SystemPermissionSet.java
package org.apache.guacamole.net.auth.permission;
import org.apache.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/permission/package-info.java
package org.apache.guacamole.net.auth.permission;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/SimpleAuthenticationProvider.java
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AbstractAuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
import org.apache.guacamole.token.StandardTokens;
import org.apache.guacamole.token.TokenFilter;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/SimpleConnection.java
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.GuacamoleSocket;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.InetGuacamoleSocket;
import org.apache.guacamole.net.SSLGuacamoleSocket;
import org.apache.guacamole.net.SimpleGuacamoleTunnel;
import org.apache.guacamole.net.auth.AbstractConnection;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.protocol.ConfiguredGuacamoleSocket;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/SimpleConnectionDirectory.java
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.net.auth.Connection;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/SimpleConnectionGroup.java
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.AbstractConnectionGroup;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/SimpleConnectionGroupDirectory.java
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.net.auth.ConnectionGroup;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/SimpleConnectionRecordSet.java
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.net.auth.ConnectionRecordSet;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/SimpleDirectory.java
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.Identifiable;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/SimpleObjectPermissionSet.java
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/SimpleSystemPermissionSet.java
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/SimpleUser.java
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AbstractUser;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/SimpleUserContext.java
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.ConnectionRecordSet;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/SimpleUserDirectory.java
package org.apache.guacamole.net.auth.simple;
import org.apache.guacamole.net.auth.User;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/auth/simple/package-info.java
package org.apache.guacamole.net.auth.simple;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/AuthenticationFailureEvent.java
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.auth.Credentials;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/AuthenticationSuccessEvent.java
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/CredentialEvent.java
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.auth.Credentials;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/TunnelCloseEvent.java
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/TunnelConnectEvent.java
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/TunnelEvent.java
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.GuacamoleTunnel;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/UserEvent.java
package org.apache.guacamole.net.event;
import org.apache.guacamole.net.auth.UserContext;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/listener/AuthenticationFailureListener.java
package org.apache.guacamole.net.event.listener;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.event.AuthenticationFailureEvent;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/listener/AuthenticationSuccessListener.java
package org.apache.guacamole.net.event.listener;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.event.AuthenticationSuccessEvent;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/listener/TunnelCloseListener.java
package org.apache.guacamole.net.event.listener;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.event.TunnelCloseEvent;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/listener/TunnelConnectListener.java
package org.apache.guacamole.net.event.listener;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.event.TunnelConnectEvent;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/listener/package-info.java
package org.apache.guacamole.net.event.listener;
 b/guacamole-ext/src/main/java/org/apache/guacamole/net/event/package-info.java
 * @see org.apache.guacamole.net.event.listener
package org.apache.guacamole.net.event;
 b/guacamole-ext/src/main/java/org/apache/guacamole/properties/BooleanGuacamoleProperty.java
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/properties/FileGuacamoleProperty.java
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/properties/GuacamoleHome.java
package org.apache.guacamole.properties;
 b/guacamole-ext/src/main/java/org/apache/guacamole/properties/GuacamoleProperties.java
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/properties/GuacamoleProperty.java
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/properties/IntegerGuacamoleProperty.java
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/properties/LongGuacamoleProperty.java
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/properties/StringGuacamoleProperty.java
package org.apache.guacamole.properties;
import org.apache.guacamole.GuacamoleException;
 b/guacamole-ext/src/main/java/org/apache/guacamole/properties/package-info.java
package org.apache.guacamole.properties;
 b/guacamole-ext/src/main/java/org/apache/guacamole/protocols/ProtocolInfo.java
package org.apache.guacamole.protocols;
import org.apache.guacamole.form.Form;
 b/guacamole-ext/src/main/java/org/apache/guacamole/token/StandardTokens.java
package org.apache.guacamole.token;
import org.apache.guacamole.net.auth.Credentials;
 b/guacamole-ext/src/main/java/org/apache/guacamole/token/TokenFilter.java
package org.apache.guacamole.token;
 b/guacamole-ext/src/main/java/org/apache/guacamole/xml/DocumentHandler.java
package org.apache.guacamole.xml;
 b/guacamole-ext/src/main/java/org/apache/guacamole/xml/TagHandler.java
package org.apache.guacamole.xml;
 b/guacamole-ext/src/main/java/org/apache/guacamole/xml/package-info.java
package org.apache.guacamole.xml;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.simple.SimpleAuthenticationProvider;
import org.apache.guacamole.net.basic.auth.Authorization;
import org.apache.guacamole.net.basic.auth.UserMapping;
import org.apache.guacamole.xml.DocumentHandler;
import org.apache.guacamole.net.basic.xml.usermapping.UserMappingTagHandler;
import org.apache.guacamole.properties.FileGuacamoleProperty;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/BasicGuacamoleTunnelServlet.java
package org.apache.guacamole.net.basic;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.servlet.GuacamoleHTTPTunnelServlet;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/BasicServletContextListener.java
package org.apache.guacamole.net.basic;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.basic.extension.ExtensionModule;
import org.apache.guacamole.net.basic.log.LogModule;
import org.apache.guacamole.net.basic.rest.RESTServiceModule;
import org.apache.guacamole.net.basic.rest.auth.BasicTokenSessionMap;
import org.apache.guacamole.net.basic.rest.auth.TokenSessionMap;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/ClipboardState.java
package org.apache.guacamole.net.basic;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/EnvironmentModule.java
package org.apache.guacamole.net.basic;
import org.apache.guacamole.environment.Environment;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/GuacamoleClassLoader.java
package org.apache.guacamole.net.basic;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.basic.properties.BasicGuacamoleProperties;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/GuacamoleSession.java
package org.apache.guacamole.net.basic;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.UserContext;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/HTTPTunnelRequest.java
package org.apache.guacamole.net.basic;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/TunnelLoader.java
package org.apache.guacamole.net.basic;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/TunnelModule.java
package org.apache.guacamole.net.basic;
        "org.apache.guacamole.net.basic.websocket.WebSocketTunnelModule",
        "org.apache.guacamole.net.basic.websocket.jetty8.WebSocketTunnelModule",
        "org.apache.guacamole.net.basic.websocket.jetty9.WebSocketTunnelModule",
        "org.apache.guacamole.net.basic.websocket.tomcat.WebSocketTunnelModule"
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/TunnelRequest.java
package org.apache.guacamole.net.basic;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/TunnelRequestService.java
package org.apache.guacamole.net.basic;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.GuacamoleUnauthorizedException;
import org.apache.guacamole.net.DelegatingGuacamoleTunnel;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/auth/Authorization.java
package org.apache.guacamole.net.basic.auth;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/auth/UserMapping.java
package org.apache.guacamole.net.basic.auth;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/auth/package-info.java
package org.apache.guacamole.net.basic.auth;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/extension/AuthenticationProviderFacade.java
package org.apache.guacamole.net.basic.extension;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.credentials.CredentialsInfo;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/extension/DirectoryClassLoader.java
package org.apache.guacamole.net.basic.extension;
import org.apache.guacamole.GuacamoleException;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/extension/Extension.java
package org.apache.guacamole.net.basic.extension;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.basic.resource.ClassPathResource;
import org.apache.guacamole.net.basic.resource.Resource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/extension/ExtensionManifest.java
package org.apache.guacamole.net.basic.extension;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/extension/ExtensionModule.java
package org.apache.guacamole.net.basic.extension;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.apache.guacamole.net.basic.resource.Resource;
import org.apache.guacamole.net.basic.resource.ResourceServlet;
import org.apache.guacamole.net.basic.resource.SequenceResource;
import org.apache.guacamole.net.basic.resource.WebApplicationResource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/extension/LanguageResourceService.java
package org.apache.guacamole.net.basic.extension;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.net.basic.properties.BasicGuacamoleProperties;
import org.apache.guacamole.net.basic.resource.ByteArrayResource;
import org.apache.guacamole.net.basic.resource.Resource;
import org.apache.guacamole.net.basic.resource.WebApplicationResource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/extension/PatchResourceService.java
package org.apache.guacamole.net.basic.extension;
import org.apache.guacamole.net.basic.resource.Resource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/extension/package-info.java
package org.apache.guacamole.net.basic.extension;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/log/LogModule.java
package org.apache.guacamole.net.basic.log;
import org.apache.guacamole.environment.Environment;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/package-info.java
package org.apache.guacamole.net.basic;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/properties/AuthenticationProviderProperty.java
package org.apache.guacamole.net.basic.properties;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.properties.GuacamoleProperty;
            Class<?> authProviderClass = org.apache.guacamole.net.basic.GuacamoleClassLoader.getInstance().loadClass(authProviderClassName);
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/properties/BasicGuacamoleProperties.java
package org.apache.guacamole.net.basic.properties;
import org.apache.guacamole.properties.FileGuacamoleProperty;
import org.apache.guacamole.properties.IntegerGuacamoleProperty;
import org.apache.guacamole.properties.StringGuacamoleProperty;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/properties/StringSetProperty.java
package org.apache.guacamole.net.basic.properties;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.properties.GuacamoleProperty;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/properties/package-info.java
package org.apache.guacamole.net.basic.properties;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/resource/AbstractResource.java
package org.apache.guacamole.net.basic.resource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/resource/ByteArrayResource.java
package org.apache.guacamole.net.basic.resource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/resource/ClassPathResource.java
package org.apache.guacamole.net.basic.resource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/resource/Resource.java
package org.apache.guacamole.net.basic.resource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/resource/ResourceServlet.java
package org.apache.guacamole.net.basic.resource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/resource/SequenceResource.java
package org.apache.guacamole.net.basic.resource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/resource/WebApplicationResource.java
package org.apache.guacamole.net.basic.resource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/resource/package-info.java
package org.apache.guacamole.net.basic.resource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/APIError.java
package org.apache.guacamole.net.basic.rest;
import org.apache.guacamole.form.Field;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/APIException.java
package org.apache.guacamole.net.basic.rest;
import org.apache.guacamole.form.Field;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/APIPatch.java
package org.apache.guacamole.net.basic.rest;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/APIRequest.java
package org.apache.guacamole.net.basic.rest;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/ObjectRetrievalService.java
package org.apache.guacamole.net.basic.rest;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.connectiongroup.APIConnectionGroup;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/PATCH.java
package org.apache.guacamole.net.basic.rest;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/RESTExceptionWrapper.java
package org.apache.guacamole.net.basic.rest;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.GuacamoleUnauthorizedException;
import org.apache.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/RESTMethodMatcher.java
package org.apache.guacamole.net.basic.rest;
import org.apache.guacamole.GuacamoleException;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/RESTServiceModule.java
package org.apache.guacamole.net.basic.rest;
import org.apache.guacamole.net.basic.rest.auth.TokenRESTService;
import org.apache.guacamole.net.basic.rest.connection.ConnectionRESTService;
import org.apache.guacamole.net.basic.rest.connectiongroup.ConnectionGroupRESTService;
import org.apache.guacamole.net.basic.rest.activeconnection.ActiveConnectionRESTService;
import org.apache.guacamole.net.basic.rest.auth.AuthTokenGenerator;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
import org.apache.guacamole.net.basic.rest.auth.SecureRandomAuthTokenGenerator;
import org.apache.guacamole.net.basic.rest.auth.TokenSessionMap;
import org.apache.guacamole.net.basic.rest.history.HistoryRESTService;
import org.apache.guacamole.net.basic.rest.language.LanguageRESTService;
import org.apache.guacamole.net.basic.rest.patch.PatchRESTService;
import org.apache.guacamole.net.basic.rest.schema.SchemaRESTService;
import org.apache.guacamole.net.basic.rest.user.UserRESTService;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/activeconnection/APIActiveConnection.java
package org.apache.guacamole.net.basic.rest.activeconnection;
import org.apache.guacamole.net.auth.ActiveConnection;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/activeconnection/ActiveConnectionRESTService.java
package org.apache.guacamole.net.basic.rest.activeconnection;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleUnsupportedException;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.APIPatch;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.PATCH;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/auth/APIAuthenticationResponse.java
package org.apache.guacamole.net.basic.rest.auth;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/auth/APIAuthenticationResult.java
package org.apache.guacamole.net.basic.rest.auth;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/auth/AuthTokenGenerator.java
package org.apache.guacamole.net.basic.rest.auth;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/auth/AuthenticationService.java
package org.apache.guacamole.net.basic.rest.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.GuacamoleUnauthorizedException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.credentials.CredentialsInfo;
import org.apache.guacamole.net.auth.credentials.GuacamoleCredentialsException;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.apache.guacamole.net.basic.GuacamoleSession;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/auth/BasicTokenSessionMap.java
package org.apache.guacamole.net.basic.rest.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.properties.BasicGuacamoleProperties;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/auth/SecureRandomAuthTokenGenerator.java
package org.apache.guacamole.net.basic.rest.auth;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/auth/TokenRESTService.java
package org.apache.guacamole.net.basic.rest.auth;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.APIRequest;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/auth/TokenSessionMap.java
package org.apache.guacamole.net.basic.rest.auth;
import org.apache.guacamole.net.basic.GuacamoleSession;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/auth/package-info.java
package org.apache.guacamole.net.basic.rest.auth;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/connection/APIConnection.java
package org.apache.guacamole.net.basic.rest.connection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/connection/APIConnectionWrapper.java
package org.apache.guacamole.net.basic.rest.connection;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 * org.apache.guacamole.net.auth.Connection is required.
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/connection/ConnectionRESTService.java
package org.apache.guacamole.net.basic.rest.connection;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
import org.apache.guacamole.net.basic.rest.history.APIConnectionRecord;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/connection/package-info.java
package org.apache.guacamole.net.basic.rest.connection;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/connectiongroup/APIConnectionGroup.java
package org.apache.guacamole.net.basic.rest.connectiongroup;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.ConnectionGroup.Type;
import org.apache.guacamole.net.basic.rest.connection.APIConnection;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/connectiongroup/APIConnectionGroupWrapper.java
package org.apache.guacamole.net.basic.rest.connectiongroup;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.protocol.GuacamoleClientInformation;
 * Useful where a org.apache.guacamole.net.auth.ConnectionGroup is required.
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/connectiongroup/ConnectionGroupRESTService.java
package org.apache.guacamole.net.basic.rest.connectiongroup;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/connectiongroup/ConnectionGroupTree.java
package org.apache.guacamole.net.basic.rest.connectiongroup;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.basic.rest.connection.APIConnection;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/connectiongroup/package-info.java
package org.apache.guacamole.net.basic.rest.connectiongroup;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/history/APIConnectionRecord.java
package org.apache.guacamole.net.basic.rest.history;
import org.apache.guacamole.net.auth.ConnectionRecord;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/history/APIConnectionRecordSortPredicate.java
package org.apache.guacamole.net.basic.rest.history;
import org.apache.guacamole.net.auth.ConnectionRecordSet;
import org.apache.guacamole.net.basic.rest.APIError;
import org.apache.guacamole.net.basic.rest.APIException;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/history/HistoryRESTService.java
package org.apache.guacamole.net.basic.rest.history;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.ConnectionRecord;
import org.apache.guacamole.net.auth.ConnectionRecordSet;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/history/package-info.java
package org.apache.guacamole.net.basic.rest.history;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/language/LanguageRESTService.java
package org.apache.guacamole.net.basic.rest.language;
import org.apache.guacamole.net.basic.extension.LanguageResourceService;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/language/package-info.java
package org.apache.guacamole.net.basic.rest.language;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/package-info.java
package org.apache.guacamole.net.basic.rest;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/patch/PatchRESTService.java
package org.apache.guacamole.net.basic.rest.patch;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.net.basic.extension.PatchResourceService;
import org.apache.guacamole.net.basic.resource.Resource;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/patch/package-info.java
package org.apache.guacamole.net.basic.rest.patch;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/permission/APIPermissionSet.java
package org.apache.guacamole.net.basic.rest.permission;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/permission/package-info.java
package org.apache.guacamole.net.basic.rest.permission;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/schema/SchemaRESTService.java
package org.apache.guacamole.net.basic.rest.schema;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.form.Form;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
import org.apache.guacamole.protocols.ProtocolInfo;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/schema/package-info.java
package org.apache.guacamole.net.basic.rest.schema;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/user/APIUser.java
package org.apache.guacamole.net.basic.rest.user;
import org.apache.guacamole.net.auth.User;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/user/APIUserPasswordUpdate.java
package org.apache.guacamole.net.basic.rest.user;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/user/APIUserWrapper.java
package org.apache.guacamole.net.basic.rest.user;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleUnsupportedException;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
 * org.apache.guacamole.net.auth.User is required. As a simple wrapper for
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/user/PermissionSetPatch.java
package org.apache.guacamole.net.basic.rest.user;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.permission.Permission;
import org.apache.guacamole.net.auth.permission.PermissionSet;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/user/UserRESTService.java
package org.apache.guacamole.net.basic.rest.user;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.net.auth.credentials.GuacamoleCredentialsException;
import org.apache.guacamole.net.auth.permission.ObjectPermission;
import org.apache.guacamole.net.auth.permission.ObjectPermissionSet;
import org.apache.guacamole.net.auth.permission.Permission;
import org.apache.guacamole.net.auth.permission.SystemPermission;
import org.apache.guacamole.net.auth.permission.SystemPermissionSet;
import org.apache.guacamole.net.basic.GuacamoleSession;
import org.apache.guacamole.net.basic.rest.APIPatch;
import static org.apache.guacamole.net.basic.rest.APIPatch.Operation.add;
import static org.apache.guacamole.net.basic.rest.APIPatch.Operation.remove;
import org.apache.guacamole.net.basic.rest.ObjectRetrievalService;
import org.apache.guacamole.net.basic.rest.PATCH;
import org.apache.guacamole.net.basic.rest.auth.AuthenticationService;
import org.apache.guacamole.net.basic.rest.permission.APIPermissionSet;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/rest/user/package-info.java
package org.apache.guacamole.net.basic.rest.user;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/BasicGuacamoleWebSocketTunnelEndpoint.java
package org.apache.guacamole.net.basic.websocket;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.basic.TunnelRequest;
import org.apache.guacamole.net.basic.TunnelRequestService;
import org.apache.guacamole.websocket.GuacamoleWebSocketTunnelEndpoint;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/WebSocketTunnelModule.java
package org.apache.guacamole.net.basic.websocket;
import org.apache.guacamole.net.basic.TunnelLoader;
import org.apache.guacamole.net.basic.TunnelRequestService;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/WebSocketTunnelRequest.java
package org.apache.guacamole.net.basic.websocket;
import org.apache.guacamole.net.basic.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/jetty8/BasicGuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.net.basic.websocket.jetty8;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.basic.TunnelRequestService;
import org.apache.guacamole.net.basic.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/jetty8/GuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.net.basic.websocket.jetty8;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.net.basic.HTTPTunnelRequest;
import org.apache.guacamole.net.basic.TunnelRequest;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/jetty8/WebSocketTunnelModule.java
package org.apache.guacamole.net.basic.websocket.jetty8;
import org.apache.guacamole.net.basic.TunnelLoader;
            Class.forName("org.apache.guacamole.net.basic.websocket.jetty8.BasicGuacamoleWebSocketTunnelServlet");
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/jetty8/package-info.java
package org.apache.guacamole.net.basic.websocket.jetty8;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/jetty9/BasicGuacamoleWebSocketCreator.java
package org.apache.guacamole.net.basic.websocket.jetty9;
import org.apache.guacamole.net.basic.TunnelRequestService;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/jetty9/BasicGuacamoleWebSocketTunnelListener.java
package org.apache.guacamole.net.basic.websocket.jetty9;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.basic.TunnelRequestService;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/jetty9/BasicGuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.net.basic.websocket.jetty9;
import org.apache.guacamole.net.basic.TunnelRequestService;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/jetty9/GuacamoleWebSocketTunnelListener.java
package org.apache.guacamole.net.basic.websocket.jetty9;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/jetty9/WebSocketTunnelModule.java
package org.apache.guacamole.net.basic.websocket.jetty9;
import org.apache.guacamole.net.basic.TunnelLoader;
            Class.forName("org.apache.guacamole.net.basic.websocket.jetty9.BasicGuacamoleWebSocketTunnelServlet");
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/jetty9/WebSocketTunnelRequest.java
package org.apache.guacamole.net.basic.websocket.jetty9;
import org.apache.guacamole.net.basic.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/jetty9/package-info.java
package org.apache.guacamole.net.basic.websocket.jetty9;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/package-info.java
package org.apache.guacamole.net.basic.websocket;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/tomcat/BasicGuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.net.basic.websocket.tomcat;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.net.basic.TunnelRequestService;
import org.apache.guacamole.net.basic.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/tomcat/GuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.net.basic.websocket.tomcat;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.io.GuacamoleReader;
import org.apache.guacamole.io.GuacamoleWriter;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleConnectionClosedException;
import org.apache.guacamole.net.basic.HTTPTunnelRequest;
import org.apache.guacamole.net.basic.TunnelRequest;
import org.apache.guacamole.protocol.GuacamoleStatus;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/tomcat/WebSocketTunnelModule.java
package org.apache.guacamole.net.basic.websocket.tomcat;
import org.apache.guacamole.net.basic.TunnelLoader;
            Class.forName("org.apache.guacamole.net.basic.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet");
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/websocket/tomcat/package-info.java
package org.apache.guacamole.net.basic.websocket.tomcat;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/xml/usermapping/AuthorizeTagHandler.java
package org.apache.guacamole.net.basic.xml.usermapping;
import org.apache.guacamole.net.basic.auth.Authorization;
import org.apache.guacamole.net.basic.auth.UserMapping;
import org.apache.guacamole.xml.TagHandler;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/xml/usermapping/ConnectionTagHandler.java
package org.apache.guacamole.net.basic.xml.usermapping;
import org.apache.guacamole.net.basic.auth.Authorization;
import org.apache.guacamole.xml.TagHandler;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/xml/usermapping/ParamTagHandler.java
package org.apache.guacamole.net.basic.xml.usermapping;
import org.apache.guacamole.xml.TagHandler;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/xml/usermapping/ProtocolTagHandler.java
package org.apache.guacamole.net.basic.xml.usermapping;
import org.apache.guacamole.xml.TagHandler;
import org.apache.guacamole.protocol.GuacamoleConfiguration;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/xml/usermapping/UserMappingTagHandler.java
package org.apache.guacamole.net.basic.xml.usermapping;
import org.apache.guacamole.net.basic.auth.UserMapping;
import org.apache.guacamole.xml.TagHandler;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/xml/usermapping/package-info.java
package org.apache.guacamole.net.basic.xml.usermapping;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-mysql/src/main/java/org/apache/guacamole/auth/mysql/MySQLAuthenticationProvider.java
package org.apache.guacamole.auth.mysql;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-mysql/src/main/java/org/apache/guacamole/auth/mysql/MySQLAuthenticationProviderModule.java
package org.apache.guacamole.auth.mysql;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-mysql/src/main/java/org/apache/guacamole/auth/mysql/MySQLEnvironment.java
package org.apache.guacamole.auth.mysql;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-mysql/src/main/java/org/apache/guacamole/auth/mysql/MySQLGuacamoleProperties.java
package org.apache.guacamole.auth.mysql;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-mysql/src/main/java/org/apache/guacamole/auth/mysql/package-info.java
package org.apache.guacamole.auth.mysql;
 b/extensions/guacamole-auth-ldap/src/main/java/org/apache/guacamole/auth/ldap/LDAPAuthenticationProvider.java
package org.apache.guacamole.auth.ldap;
import org.apache.guacamole.auth.ldap.LDAPAuthenticationProvider;
import org.apache.guacamole.auth.ldap.LDAPAuthenticationProvider;
 b/extensions/guacamole-auth-noauth/src/main/java/org/apache/guacamole/auth/noauth/NoAuthConfigContentHandler.java
package org.apache.guacamole.auth.noauth;
 b/extensions/guacamole-auth-noauth/src/main/java/org/apache/guacamole/auth/noauth/NoAuthenticationProvider.java
package org.apache.guacamole.auth.noauth;
 b/guacamole/src/main/java/org/apache/guacamole/net/basic/BasicFileAuthenticationProvider.java
package org.apache.guacamole.net.basic;
import org.apache.guacamole.net.basic.BasicFileAuthenticationProvider;
 b/guacamole/src/main/java/org/apache/guacamole/BasicGuacamoleTunnelServlet.java
package org.apache.guacamole;
 b/guacamole/src/main/java/org/apache/guacamole/BasicServletContextListener.java
package org.apache.guacamole;
import org.apache.guacamole.extension.ExtensionModule;
import org.apache.guacamole.log.LogModule;
import org.apache.guacamole.rest.RESTServiceModule;
import org.apache.guacamole.rest.auth.BasicTokenSessionMap;
import org.apache.guacamole.rest.auth.TokenSessionMap;
 b/guacamole/src/main/java/org/apache/guacamole/ClipboardState.java
package org.apache.guacamole;
 b/guacamole/src/main/java/org/apache/guacamole/EnvironmentModule.java
package org.apache.guacamole;
 b/guacamole/src/main/java/org/apache/guacamole/GuacamoleClassLoader.java
package org.apache.guacamole;
import org.apache.guacamole.properties.BasicGuacamoleProperties;
 b/guacamole/src/main/java/org/apache/guacamole/GuacamoleSession.java
package org.apache.guacamole;
 b/guacamole/src/main/java/org/apache/guacamole/HTTPTunnelRequest.java
package org.apache.guacamole;
 b/guacamole/src/main/java/org/apache/guacamole/TunnelLoader.java
package org.apache.guacamole;
 b/guacamole/src/main/java/org/apache/guacamole/TunnelModule.java
package org.apache.guacamole;
        "org.apache.guacamole.websocket.WebSocketTunnelModule",
        "org.apache.guacamole.websocket.jetty8.WebSocketTunnelModule",
        "org.apache.guacamole.websocket.jetty9.WebSocketTunnelModule",
        "org.apache.guacamole.websocket.tomcat.WebSocketTunnelModule"
 b/guacamole/src/main/java/org/apache/guacamole/TunnelRequest.java
package org.apache.guacamole;
 b/guacamole/src/main/java/org/apache/guacamole/TunnelRequestService.java
package org.apache.guacamole;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.auth.AuthenticationService;
 b/guacamole/src/main/java/org/apache/guacamole/auth/Authorization.java
package org.apache.guacamole.auth;
 b/guacamole/src/main/java/org/apache/guacamole/auth/UserMapping.java
package org.apache.guacamole.auth;
 b/guacamole/src/main/java/org/apache/guacamole/auth/basic/AuthorizeTagHandler.java
package org.apache.guacamole.auth.basic;
import org.apache.guacamole.auth.Authorization;
import org.apache.guacamole.auth.UserMapping;
 b/guacamole/src/main/java/org/apache/guacamole/auth/basic/BasicFileAuthenticationProvider.java
package org.apache.guacamole.auth.basic;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.Authorization;
import org.apache.guacamole.auth.UserMapping;
 b/guacamole/src/main/java/org/apache/guacamole/auth/basic/ConnectionTagHandler.java
package org.apache.guacamole.auth.basic;
import org.apache.guacamole.auth.Authorization;
 b/guacamole/src/main/java/org/apache/guacamole/auth/basic/ParamTagHandler.java
package org.apache.guacamole.auth.basic;
 b/guacamole/src/main/java/org/apache/guacamole/auth/basic/ProtocolTagHandler.java
package org.apache.guacamole.auth.basic;
 b/guacamole/src/main/java/org/apache/guacamole/auth/basic/UserMappingTagHandler.java
package org.apache.guacamole.auth.basic;
import org.apache.guacamole.auth.UserMapping;
 b/guacamole/src/main/java/org/apache/guacamole/auth/basic/package-info.java
package org.apache.guacamole.auth.basic;
 b/guacamole/src/main/java/org/apache/guacamole/auth/package-info.java
package org.apache.guacamole.auth;
 b/guacamole/src/main/java/org/apache/guacamole/extension/AuthenticationProviderFacade.java
package org.apache.guacamole.extension;
 b/guacamole/src/main/java/org/apache/guacamole/extension/DirectoryClassLoader.java
package org.apache.guacamole.extension;
 b/guacamole/src/main/java/org/apache/guacamole/extension/Extension.java
package org.apache.guacamole.extension;
import org.apache.guacamole.resource.ClassPathResource;
import org.apache.guacamole.resource.Resource;
 b/guacamole/src/main/java/org/apache/guacamole/extension/ExtensionManifest.java
package org.apache.guacamole.extension;
 b/guacamole/src/main/java/org/apache/guacamole/extension/ExtensionModule.java
package org.apache.guacamole.extension;
import org.apache.guacamole.auth.basic.BasicFileAuthenticationProvider;
import org.apache.guacamole.properties.BasicGuacamoleProperties;
import org.apache.guacamole.resource.Resource;
import org.apache.guacamole.resource.ResourceServlet;
import org.apache.guacamole.resource.SequenceResource;
import org.apache.guacamole.resource.WebApplicationResource;
 b/guacamole/src/main/java/org/apache/guacamole/extension/LanguageResourceService.java
package org.apache.guacamole.extension;
import org.apache.guacamole.properties.BasicGuacamoleProperties;
import org.apache.guacamole.resource.ByteArrayResource;
import org.apache.guacamole.resource.Resource;
import org.apache.guacamole.resource.WebApplicationResource;
 b/guacamole/src/main/java/org/apache/guacamole/extension/PatchResourceService.java
package org.apache.guacamole.extension;
import org.apache.guacamole.resource.Resource;
 b/guacamole/src/main/java/org/apache/guacamole/extension/package-info.java
package org.apache.guacamole.extension;
 b/guacamole/src/main/java/org/apache/guacamole/log/LogModule.java
package org.apache.guacamole.log;
 b/guacamole/src/main/java/org/apache/guacamole/package-info.java
package org.apache.guacamole;
 b/guacamole/src/main/java/org/apache/guacamole/properties/AuthenticationProviderProperty.java
package org.apache.guacamole.properties;
            Class<?> authProviderClass = org.apache.guacamole.GuacamoleClassLoader.getInstance().loadClass(authProviderClassName);
 b/guacamole/src/main/java/org/apache/guacamole/properties/BasicGuacamoleProperties.java
package org.apache.guacamole.properties;
 b/guacamole/src/main/java/org/apache/guacamole/properties/StringSetProperty.java
package org.apache.guacamole.properties;
 b/guacamole/src/main/java/org/apache/guacamole/properties/package-info.java
package org.apache.guacamole.properties;
 b/guacamole/src/main/java/org/apache/guacamole/resource/AbstractResource.java
package org.apache.guacamole.resource;
 b/guacamole/src/main/java/org/apache/guacamole/resource/ByteArrayResource.java
package org.apache.guacamole.resource;
 b/guacamole/src/main/java/org/apache/guacamole/resource/ClassPathResource.java
package org.apache.guacamole.resource;
 b/guacamole/src/main/java/org/apache/guacamole/resource/Resource.java
package org.apache.guacamole.resource;
 b/guacamole/src/main/java/org/apache/guacamole/resource/ResourceServlet.java
package org.apache.guacamole.resource;
 b/guacamole/src/main/java/org/apache/guacamole/resource/SequenceResource.java
package org.apache.guacamole.resource;
 b/guacamole/src/main/java/org/apache/guacamole/resource/WebApplicationResource.java
package org.apache.guacamole.resource;
 b/guacamole/src/main/java/org/apache/guacamole/resource/package-info.java
package org.apache.guacamole.resource;
 b/guacamole/src/main/java/org/apache/guacamole/rest/APIError.java
package org.apache.guacamole.rest;
 b/guacamole/src/main/java/org/apache/guacamole/rest/APIException.java
package org.apache.guacamole.rest;
 b/guacamole/src/main/java/org/apache/guacamole/rest/APIPatch.java
package org.apache.guacamole.rest;
 b/guacamole/src/main/java/org/apache/guacamole/rest/APIRequest.java
package org.apache.guacamole.rest;
 b/guacamole/src/main/java/org/apache/guacamole/rest/ObjectRetrievalService.java
package org.apache.guacamole.rest;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.connectiongroup.APIConnectionGroup;
 b/guacamole/src/main/java/org/apache/guacamole/rest/PATCH.java
package org.apache.guacamole.rest;
 b/guacamole/src/main/java/org/apache/guacamole/rest/RESTExceptionWrapper.java
package org.apache.guacamole.rest;
import org.apache.guacamole.rest.auth.AuthenticationService;
 b/guacamole/src/main/java/org/apache/guacamole/rest/RESTMethodMatcher.java
package org.apache.guacamole.rest;
 b/guacamole/src/main/java/org/apache/guacamole/rest/RESTServiceModule.java
package org.apache.guacamole.rest;
import org.apache.guacamole.rest.auth.TokenRESTService;
import org.apache.guacamole.rest.connection.ConnectionRESTService;
import org.apache.guacamole.rest.connectiongroup.ConnectionGroupRESTService;
import org.apache.guacamole.rest.activeconnection.ActiveConnectionRESTService;
import org.apache.guacamole.rest.auth.AuthTokenGenerator;
import org.apache.guacamole.rest.auth.AuthenticationService;
import org.apache.guacamole.rest.auth.SecureRandomAuthTokenGenerator;
import org.apache.guacamole.rest.auth.TokenSessionMap;
import org.apache.guacamole.rest.history.HistoryRESTService;
import org.apache.guacamole.rest.language.LanguageRESTService;
import org.apache.guacamole.rest.patch.PatchRESTService;
import org.apache.guacamole.rest.schema.SchemaRESTService;
import org.apache.guacamole.rest.user.UserRESTService;
 b/guacamole/src/main/java/org/apache/guacamole/rest/activeconnection/APIActiveConnection.java
package org.apache.guacamole.rest.activeconnection;
 b/guacamole/src/main/java/org/apache/guacamole/rest/activeconnection/ActiveConnectionRESTService.java
package org.apache.guacamole.rest.activeconnection;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.APIPatch;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.PATCH;
import org.apache.guacamole.rest.auth.AuthenticationService;
 b/guacamole/src/main/java/org/apache/guacamole/rest/auth/APIAuthenticationResponse.java
package org.apache.guacamole.rest.auth;
 b/guacamole/src/main/java/org/apache/guacamole/rest/auth/APIAuthenticationResult.java
package org.apache.guacamole.rest.auth;
 b/guacamole/src/main/java/org/apache/guacamole/rest/auth/AuthTokenGenerator.java
package org.apache.guacamole.rest.auth;
 b/guacamole/src/main/java/org/apache/guacamole/rest/auth/AuthenticationService.java
package org.apache.guacamole.rest.auth;
import org.apache.guacamole.GuacamoleSession;
 b/guacamole/src/main/java/org/apache/guacamole/rest/auth/BasicTokenSessionMap.java
package org.apache.guacamole.rest.auth;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.properties.BasicGuacamoleProperties;
 b/guacamole/src/main/java/org/apache/guacamole/rest/auth/SecureRandomAuthTokenGenerator.java
package org.apache.guacamole.rest.auth;
 b/guacamole/src/main/java/org/apache/guacamole/rest/auth/TokenRESTService.java
package org.apache.guacamole.rest.auth;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.APIRequest;
 b/guacamole/src/main/java/org/apache/guacamole/rest/auth/TokenSessionMap.java
package org.apache.guacamole.rest.auth;
import org.apache.guacamole.GuacamoleSession;
 b/guacamole/src/main/java/org/apache/guacamole/rest/auth/package-info.java
package org.apache.guacamole.rest.auth;
 b/guacamole/src/main/java/org/apache/guacamole/rest/connection/APIConnection.java
package org.apache.guacamole.rest.connection;
 b/guacamole/src/main/java/org/apache/guacamole/rest/connection/APIConnectionWrapper.java
package org.apache.guacamole.rest.connection;
 b/guacamole/src/main/java/org/apache/guacamole/rest/connection/ConnectionRESTService.java
package org.apache.guacamole.rest.connection;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.auth.AuthenticationService;
import org.apache.guacamole.rest.history.APIConnectionRecord;
 b/guacamole/src/main/java/org/apache/guacamole/rest/connection/package-info.java
package org.apache.guacamole.rest.connection;
 b/guacamole/src/main/java/org/apache/guacamole/rest/connectiongroup/APIConnectionGroup.java
package org.apache.guacamole.rest.connectiongroup;
import org.apache.guacamole.rest.connection.APIConnection;
 b/guacamole/src/main/java/org/apache/guacamole/rest/connectiongroup/APIConnectionGroupWrapper.java
package org.apache.guacamole.rest.connectiongroup;
 b/guacamole/src/main/java/org/apache/guacamole/rest/connectiongroup/ConnectionGroupRESTService.java
package org.apache.guacamole.rest.connectiongroup;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.auth.AuthenticationService;
 b/guacamole/src/main/java/org/apache/guacamole/rest/connectiongroup/ConnectionGroupTree.java
package org.apache.guacamole.rest.connectiongroup;
import org.apache.guacamole.rest.connection.APIConnection;
 b/guacamole/src/main/java/org/apache/guacamole/rest/connectiongroup/package-info.java
package org.apache.guacamole.rest.connectiongroup;
 b/guacamole/src/main/java/org/apache/guacamole/rest/history/APIConnectionRecord.java
package org.apache.guacamole.rest.history;
 b/guacamole/src/main/java/org/apache/guacamole/rest/history/APIConnectionRecordSortPredicate.java
package org.apache.guacamole.rest.history;
import org.apache.guacamole.rest.APIError;
import org.apache.guacamole.rest.APIException;
 b/guacamole/src/main/java/org/apache/guacamole/rest/history/HistoryRESTService.java
package org.apache.guacamole.rest.history;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.auth.AuthenticationService;
 b/guacamole/src/main/java/org/apache/guacamole/rest/history/package-info.java
package org.apache.guacamole.rest.history;
 b/guacamole/src/main/java/org/apache/guacamole/rest/language/LanguageRESTService.java
package org.apache.guacamole.rest.language;
import org.apache.guacamole.extension.LanguageResourceService;
 b/guacamole/src/main/java/org/apache/guacamole/rest/language/package-info.java
package org.apache.guacamole.rest.language;
 b/guacamole/src/main/java/org/apache/guacamole/rest/package-info.java
package org.apache.guacamole.rest;
 b/guacamole/src/main/java/org/apache/guacamole/rest/patch/PatchRESTService.java
package org.apache.guacamole.rest.patch;
import org.apache.guacamole.extension.PatchResourceService;
import org.apache.guacamole.resource.Resource;
 b/guacamole/src/main/java/org/apache/guacamole/rest/patch/package-info.java
package org.apache.guacamole.rest.patch;
 b/guacamole/src/main/java/org/apache/guacamole/rest/permission/APIPermissionSet.java
package org.apache.guacamole.rest.permission;
 b/guacamole/src/main/java/org/apache/guacamole/rest/permission/package-info.java
package org.apache.guacamole.rest.permission;
 b/guacamole/src/main/java/org/apache/guacamole/rest/schema/SchemaRESTService.java
package org.apache.guacamole.rest.schema;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.auth.AuthenticationService;
 b/guacamole/src/main/java/org/apache/guacamole/rest/schema/package-info.java
package org.apache.guacamole.rest.schema;
 b/guacamole/src/main/java/org/apache/guacamole/rest/user/APIUser.java
package org.apache.guacamole.rest.user;
 b/guacamole/src/main/java/org/apache/guacamole/rest/user/APIUserPasswordUpdate.java
package org.apache.guacamole.rest.user;
 b/guacamole/src/main/java/org/apache/guacamole/rest/user/APIUserWrapper.java
package org.apache.guacamole.rest.user;
 b/guacamole/src/main/java/org/apache/guacamole/rest/user/PermissionSetPatch.java
package org.apache.guacamole.rest.user;
 b/guacamole/src/main/java/org/apache/guacamole/rest/user/UserRESTService.java
package org.apache.guacamole.rest.user;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.rest.APIPatch;
import static org.apache.guacamole.rest.APIPatch.Operation.add;
import static org.apache.guacamole.rest.APIPatch.Operation.remove;
import org.apache.guacamole.rest.ObjectRetrievalService;
import org.apache.guacamole.rest.PATCH;
import org.apache.guacamole.rest.auth.AuthenticationService;
import org.apache.guacamole.rest.permission.APIPermissionSet;
 b/guacamole/src/main/java/org/apache/guacamole/rest/user/package-info.java
package org.apache.guacamole.rest.user;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/BasicGuacamoleWebSocketTunnelEndpoint.java
package org.apache.guacamole.websocket;
import org.apache.guacamole.TunnelRequest;
import org.apache.guacamole.TunnelRequestService;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/WebSocketTunnelModule.java
package org.apache.guacamole.websocket;
import org.apache.guacamole.TunnelLoader;
import org.apache.guacamole.TunnelRequestService;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/WebSocketTunnelRequest.java
package org.apache.guacamole.websocket;
import org.apache.guacamole.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/jetty8/BasicGuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.websocket.jetty8;
import org.apache.guacamole.TunnelRequestService;
import org.apache.guacamole.TunnelRequest;
    }
 b/guacamole/src/main/java/org/apache/guacamole/websocket/jetty8/GuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.websocket.jetty8;
import org.apache.guacamole.HTTPTunnelRequest;
import org.apache.guacamole.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/jetty8/WebSocketTunnelModule.java
package org.apache.guacamole.websocket.jetty8;
import org.apache.guacamole.TunnelLoader;
            Class.forName("org.apache.guacamole.websocket.jetty8.BasicGuacamoleWebSocketTunnelServlet");
 b/guacamole/src/main/java/org/apache/guacamole/websocket/jetty8/package-info.java
package org.apache.guacamole.websocket.jetty8;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/jetty9/BasicGuacamoleWebSocketCreator.java
package org.apache.guacamole.websocket.jetty9;
import org.apache.guacamole.TunnelRequestService;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/jetty9/BasicGuacamoleWebSocketTunnelListener.java
package org.apache.guacamole.websocket.jetty9;
import org.apache.guacamole.TunnelRequestService;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/jetty9/BasicGuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.websocket.jetty9;
import org.apache.guacamole.TunnelRequestService;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/jetty9/GuacamoleWebSocketTunnelListener.java
package org.apache.guacamole.websocket.jetty9;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/jetty9/WebSocketTunnelModule.java
package org.apache.guacamole.websocket.jetty9;
import org.apache.guacamole.TunnelLoader;
            Class.forName("org.apache.guacamole.websocket.jetty9.BasicGuacamoleWebSocketTunnelServlet");
 b/guacamole/src/main/java/org/apache/guacamole/websocket/jetty9/WebSocketTunnelRequest.java
package org.apache.guacamole.websocket.jetty9;
import org.apache.guacamole.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/jetty9/package-info.java
package org.apache.guacamole.websocket.jetty9;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/package-info.java
package org.apache.guacamole.websocket;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/tomcat/BasicGuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.websocket.tomcat;
import org.apache.guacamole.TunnelRequestService;
import org.apache.guacamole.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/tomcat/GuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.websocket.tomcat;
import org.apache.guacamole.HTTPTunnelRequest;
import org.apache.guacamole.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/websocket/tomcat/WebSocketTunnelModule.java
package org.apache.guacamole.websocket.tomcat;
import org.apache.guacamole.TunnelLoader;
            Class.forName("org.apache.guacamole.websocket.tomcat.BasicGuacamoleWebSocketTunnelServlet");
 b/guacamole/src/main/java/org/apache/guacamole/websocket/tomcat/package-info.java
package org.apache.guacamole.websocket.tomcat;
            "0.9.9-incubating"
 b/guacamole/src/main/java/org/apache/guacamole/auth/file/Authorization.java
package org.apache.guacamole.auth.file;
 b/guacamole/src/main/java/org/apache/guacamole/auth/file/AuthorizeTagHandler.java
package org.apache.guacamole.auth.file;
 b/guacamole/src/main/java/org/apache/guacamole/auth/file/ConnectionTagHandler.java
package org.apache.guacamole.auth.file;
 b/guacamole/src/main/java/org/apache/guacamole/auth/file/FileAuthenticationProvider.java
package org.apache.guacamole.auth.file;
public class FileAuthenticationProvider extends SimpleAuthenticationProvider {
    private final Logger logger = LoggerFactory.getLogger(FileAuthenticationProvider.class);
     * The XML file to read the user mapping from. This property has been
     * deprecated, as the name "basic" is ridiculous, and providing for
     * configurable user-mapping.xml locations is unnecessary complexity. Use
     * GUACAMOLE_HOME/user-mapping.xml instead.
    @Deprecated
     * The filename to use for the user mapping.
    public static final String USER_MAPPING_FILENAME = "user-mapping.xml";
    public FileAuthenticationProvider() throws GuacamoleException {
    @SuppressWarnings("deprecation") // We must continue to use the "basic-user-mapping" property until it is truly no longer supported

            // Continue supporting deprecated property, but warn in the logs
            if (userMappingFile != null)
                logger.warn("The \"basic-user-mapping\" property is deprecated. Please use the \"GUACAMOLE_HOME/user-mapping.xml\" file instead.");

            // Read user mapping from GUACAMOLE_HOME
                userMappingFile = new File(environment.getGuacamoleHome(), USER_MAPPING_FILENAME);

 b/guacamole/src/main/java/org/apache/guacamole/auth/file/ParamTagHandler.java
package org.apache.guacamole.auth.file;
 b/guacamole/src/main/java/org/apache/guacamole/auth/file/ProtocolTagHandler.java
package org.apache.guacamole.auth.file;
 b/guacamole/src/main/java/org/apache/guacamole/auth/file/UserMapping.java
package org.apache.guacamole.auth.file;
 b/guacamole/src/main/java/org/apache/guacamole/auth/file/UserMappingTagHandler.java
package org.apache.guacamole.auth.file;
 b/guacamole/src/main/java/org/apache/guacamole/auth/file/package-info.java
 * Classes which drive the default, file-based authentication of the Guacamole
package org.apache.guacamole.auth.file;
import org.apache.guacamole.auth.file.FileAuthenticationProvider;
        // Always bind default file-driven auth last
        bindAuthenticationProvider(FileAuthenticationProvider.class);
import org.apache.guacamole.properties.StringSetProperty;
     * Comma-separated list of all allowed languages, where each language is
     * represented by a language key, such as "en" or "en_US". If specified,
     * only languages within this list will be listed as available by the REST
     * service.
     */
    public final StringSetProperty ALLOWED_LANGUAGES = new StringSetProperty() {

        @Override
        public String getName() { return "allowed-languages"; }

    };

    /**
            parsedAllowedLanguages = environment.getProperty(ALLOWED_LANGUAGES);
import org.apache.guacamole.properties.IntegerGuacamoleProperty;
 * A HashMap-based implementation of the TokenSessionMap with support for
 * session timeouts.
 *
     * The session timeout for the Guacamole REST API, in minutes.
     */
    private final IntegerGuacamoleProperty API_SESSION_TIMEOUT =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "api-session-timeout"; }

    };

    /**
            sessionTimeoutValue = environment.getProperty(API_SESSION_TIMEOUT, 60);
 b/guacamole/src/main/java/org/apache/guacamole/GuacamoleServletContextListener.java
import org.apache.guacamole.tunnel.TunnelModule;
import org.apache.guacamole.rest.auth.HashTokenSessionMap;
public class GuacamoleServletContextListener extends GuiceServletContextListener {
    private final Logger logger = LoggerFactory.getLogger(GuacamoleServletContextListener.class);
            sessionMap = new HashTokenSessionMap(environment);
 b/guacamole/src/main/java/org/apache/guacamole/rest/auth/HashTokenSessionMap.java
public class HashTokenSessionMap implements TokenSessionMap {
    private static final Logger logger = LoggerFactory.getLogger(HashTokenSessionMap.class);
    public HashTokenSessionMap(Environment environment) {
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/TunnelLoader.java
package org.apache.guacamole.tunnel;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/TunnelModule.java
package org.apache.guacamole.tunnel;
import org.apache.guacamole.tunnel.http.RestrictedGuacamoleHTTPTunnelServlet;
        serve("/tunnel").with(RestrictedGuacamoleHTTPTunnelServlet.class);
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/TunnelRequest.java
package org.apache.guacamole.tunnel;
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/TunnelRequestService.java
package org.apache.guacamole.tunnel;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.GuacamoleSession;
import org.apache.guacamole.GuacamoleUnauthorizedException;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/http/HTTPTunnelRequest.java
package org.apache.guacamole.tunnel.http;
import org.apache.guacamole.tunnel.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/http/RestrictedGuacamoleHTTPTunnelServlet.java
package org.apache.guacamole.tunnel.http;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.tunnel.TunnelRequestService;
public class RestrictedGuacamoleHTTPTunnelServlet extends GuacamoleHTTPTunnelServlet {
    private static final Logger logger = LoggerFactory.getLogger(RestrictedGuacamoleHTTPTunnelServlet.class);
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/http/package-info.java
 * Classes which leverage Guacamole's built-in HTTP tunnel implementation.
package org.apache.guacamole.tunnel.http;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/package-info.java
 * Classes which are common to all tunnel implementations.
package org.apache.guacamole.tunnel;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/RestrictedGuacamoleWebSocketTunnelEndpoint.java
package org.apache.guacamole.tunnel.websocket;
import org.apache.guacamole.tunnel.TunnelRequest;
import org.apache.guacamole.tunnel.TunnelRequestService;
import org.apache.guacamole.websocket.GuacamoleWebSocketTunnelEndpoint;
public class RestrictedGuacamoleWebSocketTunnelEndpoint extends GuacamoleWebSocketTunnelEndpoint {
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/WebSocketTunnelModule.java
package org.apache.guacamole.tunnel.websocket;
import org.apache.guacamole.tunnel.TunnelLoader;
import org.apache.guacamole.tunnel.TunnelRequestService;
                ServerEndpointConfig.Builder.create(RestrictedGuacamoleWebSocketTunnelEndpoint.class, "/websocket-tunnel")
                                            .configurator(new RestrictedGuacamoleWebSocketTunnelEndpoint.Configurator(tunnelRequestServiceProvider))
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/WebSocketTunnelRequest.java
package org.apache.guacamole.tunnel.websocket;
import org.apache.guacamole.tunnel.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/jetty8/GuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.tunnel.websocket.jetty8;
import org.apache.guacamole.tunnel.http.HTTPTunnelRequest;
import org.apache.guacamole.tunnel.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/jetty8/RestrictedGuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.tunnel.websocket.jetty8;
import org.apache.guacamole.tunnel.TunnelRequestService;
import org.apache.guacamole.tunnel.TunnelRequest;
public class RestrictedGuacamoleWebSocketTunnelServlet extends GuacamoleWebSocketTunnelServlet {
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/jetty8/WebSocketTunnelModule.java
package org.apache.guacamole.tunnel.websocket.jetty8;
import org.apache.guacamole.tunnel.TunnelLoader;
        serve("/websocket-tunnel").with(RestrictedGuacamoleWebSocketTunnelServlet.class);
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/jetty8/package-info.java
package org.apache.guacamole.tunnel.websocket.jetty8;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/jetty9/GuacamoleWebSocketTunnelListener.java
package org.apache.guacamole.tunnel.websocket.jetty9;
    private static final Logger logger = LoggerFactory.getLogger(RestrictedGuacamoleWebSocketTunnelServlet.class);
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/jetty9/RestrictedGuacamoleWebSocketCreator.java
package org.apache.guacamole.tunnel.websocket.jetty9;
import org.apache.guacamole.tunnel.TunnelRequestService;
public class RestrictedGuacamoleWebSocketCreator implements WebSocketCreator {
    public RestrictedGuacamoleWebSocketCreator(TunnelRequestService tunnelRequestService) {
                return new RestrictedGuacamoleWebSocketTunnelListener(tunnelRequestService);
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/jetty9/RestrictedGuacamoleWebSocketTunnelListener.java
package org.apache.guacamole.tunnel.websocket.jetty9;
import org.apache.guacamole.tunnel.TunnelRequestService;
public class RestrictedGuacamoleWebSocketTunnelListener extends GuacamoleWebSocketTunnelListener {
    public RestrictedGuacamoleWebSocketTunnelListener(TunnelRequestService tunnelRequestService) {
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/jetty9/RestrictedGuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.tunnel.websocket.jetty9;
import org.apache.guacamole.tunnel.TunnelRequestService;
public class RestrictedGuacamoleWebSocketTunnelServlet extends WebSocketServlet {
        factory.setCreator(new RestrictedGuacamoleWebSocketCreator(tunnelRequestService));
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/jetty9/WebSocketTunnelModule.java
package org.apache.guacamole.tunnel.websocket.jetty9;
import org.apache.guacamole.tunnel.TunnelLoader;
        serve("/websocket-tunnel").with(RestrictedGuacamoleWebSocketTunnelServlet.class);
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/jetty9/WebSocketTunnelRequest.java
package org.apache.guacamole.tunnel.websocket.jetty9;
import org.apache.guacamole.tunnel.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/jetty9/package-info.java
package org.apache.guacamole.tunnel.websocket.jetty9;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/package-info.java
package org.apache.guacamole.tunnel.websocket;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/tomcat/GuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.tunnel.websocket.tomcat;
import org.apache.guacamole.tunnel.http.HTTPTunnelRequest;
import org.apache.guacamole.tunnel.TunnelRequest;
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/tomcat/RestrictedGuacamoleWebSocketTunnelServlet.java
package org.apache.guacamole.tunnel.websocket.tomcat;
import org.apache.guacamole.tunnel.TunnelRequestService;
import org.apache.guacamole.tunnel.TunnelRequest;
public class RestrictedGuacamoleWebSocketTunnelServlet extends GuacamoleWebSocketTunnelServlet {
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/tomcat/WebSocketTunnelModule.java
package org.apache.guacamole.tunnel.websocket.tomcat;
import org.apache.guacamole.tunnel.TunnelLoader;
        serve("/websocket-tunnel").with(RestrictedGuacamoleWebSocketTunnelServlet.class);
 b/guacamole/src/main/java/org/apache/guacamole/tunnel/websocket/tomcat/package-info.java
package org.apache.guacamole.tunnel.websocket.tomcat;
     * Creates a new FileAuthenticationProvider that authenticates users against
     * simple, monolithic XML file.
     * Create a new HashTokenSessionMap configured using the given environment.
        "org.apache.guacamole.tunnel.websocket.WebSocketTunnelModule",
        "org.apache.guacamole.tunnel.websocket.jetty8.WebSocketTunnelModule",
        "org.apache.guacamole.tunnel.websocket.jetty9.WebSocketTunnelModule",
        "org.apache.guacamole.tunnel.websocket.tomcat.WebSocketTunnelModule"
            Class.forName("org.apache.guacamole.tunnel.websocket.jetty8.RestrictedGuacamoleWebSocketTunnelServlet");
            Class.forName("org.apache.guacamole.tunnel.websocket.jetty9.RestrictedGuacamoleWebSocketTunnelServlet");
            Class.forName("org.apache.guacamole.tunnel.websocket.tomcat.RestrictedGuacamoleWebSocketTunnelServlet");
        catch (LinkageError e) {
            throw new GuacamoleException("Authentication provider class cannot be loaded (wrong version of API?).", e);
        }
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *   http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
import org.apache.guacamole.tunnel.StreamInterceptingTunnel;
    private final Map<String, StreamInterceptingTunnel> tunnels =
            new ConcurrentHashMap<String, StreamInterceptingTunnel>();
    public Map<String, StreamInterceptingTunnel> getTunnels() {
    public void addTunnel(StreamInterceptingTunnel tunnel) {
        StreamInterceptingTunnel monitoredTunnel = new StreamInterceptingTunnel(tunnel) {
import org.apache.guacamole.rest.tunnel.TunnelRESTService;
        bind(TunnelRESTService.class);
     * The Guacamole protocol instruction opcode reserved for arbitrary
     * internal use by tunnel implementations. The value of this opcode is
     * guaranteed to be the empty string (""). Tunnel implementations may use
     * this opcode for any purpose. It is currently used by the HTTP tunnel to
     * mark the end of the HTTP response, and by the WebSocket tunnel to
     * transmit the tunnel UUID.
     */
    static final String INTERNAL_DATA_OPCODE = "";

    /**
import org.apache.guacamole.protocol.GuacamoleInstruction;
                    // Send tunnel UUID
                    remote.sendText(new GuacamoleInstruction(
                        GuacamoleTunnel.INTERNAL_DATA_OPCODE,
                        tunnel.getUUID().toString()
                    ).toString());

import org.apache.guacamole.protocol.GuacamoleInstruction;
                            // Send tunnel UUID
                            connection.sendMessage(new GuacamoleInstruction(
                                GuacamoleTunnel.INTERNAL_DATA_OPCODE,
                                tunnel.getUUID().toString()
                            ).toString());

import org.apache.guacamole.protocol.GuacamoleInstruction;
                    // Send tunnel UUID
                    remote.sendString(new GuacamoleInstruction(
                        GuacamoleTunnel.INTERNAL_DATA_OPCODE,
                        tunnel.getUUID().toString()
                    ).toString());

import org.apache.guacamole.protocol.GuacamoleInstruction;
                            // Send tunnel UUID
                            outbound.writeTextMessage(CharBuffer.wrap(new GuacamoleInstruction(
                                GuacamoleTunnel.INTERNAL_DATA_OPCODE,
                                tunnel.getUUID().toString()
                            ).toString()));

     * The maximum number of milliseconds to wait for notification that a
     * stream has closed before explicitly checking for closure ourselves.
     */
    private static final long STREAM_WAIT_TIMEOUT = 1000;

    /**
                    stream.wait(STREAM_WAIT_TIMEOUT);
     * The Guacamole protocol instruction opcode reserved for arbitrary
     * internal use by tunnel implementations. The value of this opcode is
     * guaranteed to be the empty string (""). Tunnel implementations may use
     * this opcode for any purpose. It is currently used by the HTTP tunnel to
     * mark the end of the HTTP response, and by the WebSocket tunnel to
     * transmit the tunnel UUID.
     */
    static final String INTERNAL_DATA_OPCODE = "";

    /**
import org.apache.guacamole.protocol.GuacamoleInstruction;
                    // Send tunnel UUID
                    remote.sendText(new GuacamoleInstruction(
                        GuacamoleTunnel.INTERNAL_DATA_OPCODE,
                        tunnel.getUUID().toString()
                    ).toString());

import org.apache.guacamole.tunnel.StreamInterceptingTunnel;
    private final Map<String, StreamInterceptingTunnel> tunnels =
            new ConcurrentHashMap<String, StreamInterceptingTunnel>();
    public Map<String, StreamInterceptingTunnel> getTunnels() {
    public void addTunnel(StreamInterceptingTunnel tunnel) {
import org.apache.guacamole.rest.tunnel.TunnelRESTService;
        bind(TunnelRESTService.class);
        StreamInterceptingTunnel monitoredTunnel = new StreamInterceptingTunnel(tunnel) {
import org.apache.guacamole.protocol.GuacamoleInstruction;
                            // Send tunnel UUID
                            connection.sendMessage(new GuacamoleInstruction(
                                GuacamoleTunnel.INTERNAL_DATA_OPCODE,
                                tunnel.getUUID().toString()
                            ).toString());

import org.apache.guacamole.protocol.GuacamoleInstruction;
                    // Send tunnel UUID
                    remote.sendString(new GuacamoleInstruction(
                        GuacamoleTunnel.INTERNAL_DATA_OPCODE,
                        tunnel.getUUID().toString()
                    ).toString());

import org.apache.guacamole.protocol.GuacamoleInstruction;
                            // Send tunnel UUID
                            outbound.writeTextMessage(CharBuffer.wrap(new GuacamoleInstruction(
                                GuacamoleTunnel.INTERNAL_DATA_OPCODE,
                                tunnel.getUUID().toString()
                            ).toString()));

    private static final Logger logger =
            LoggerFactory.getLogger(StreamInterceptingTunnel.class);
     * The filter to use for rerouting received stream data to OutputStreams.
    private final OutputStreamInterceptingFilter outputStreamFilter =
            new OutputStreamInterceptingFilter(this);
        logger.debug("Intercepting output stream #{} of tunnel \"{}\".",
        outputStreamFilter.interceptStream(index, new BufferedOutputStream(stream));
        logger.debug("Intercepted output stream #{} of tunnel \"{}\" ended.",
                index, getUUID());
        return new FilteredGuacamoleReader(super.acquireReader(), outputStreamFilter);
        // Close all intercepted streams
            outputStreamFilter.closeAllInterceptedStreams();
import java.io.InputStream;
import javax.ws.rs.POST;
    /**
     * Intercepts a specific stream, sending the contents of the given
     * InputStream over that stream as "blob" instructions.
     *
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param tunnelUUID
     *     The UUID of the tunnel containing the stream being intercepted.
     *
     * @param streamIndex
     *     The index of the stream to intercept.
     *
     * @param filename
     *     The filename to use for the sake of identifying the data being sent.
     *
     * @param data
     *     An InputStream containing the data to be sent over the intercepted
     *     stream.
     *
     * @throws GuacamoleException
     *     If the session associated with the given auth token cannot be
     *     retrieved, or if no such tunnel exists.
     */
    @POST
    @Consumes(MediaType.WILDCARD)
    @Path("/{tunnel}/streams/{index}/{filename}")
    public void setStreamContents(@QueryParam("token") String authToken,
            @PathParam("tunnel") String tunnelUUID,
            @PathParam("index") final int streamIndex,
            @PathParam("filename") String filename,
            InputStream data)
            throws GuacamoleException {

        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        Map<String, StreamInterceptingTunnel> tunnels = session.getTunnels();

        // Pull tunnel with given UUID
        final StreamInterceptingTunnel tunnel = tunnels.get(tunnelUUID);
        if (tunnel == null)
            throw new GuacamoleResourceNotFoundException("No such tunnel.");

        // Send input over stream
        tunnel.interceptStream(streamIndex, data);

    }

import java.io.BufferedInputStream;
import java.io.InputStream;
 * GuacamoleTunnel implementation which provides for producing or consuming the
 * contents of in-progress streams, rerouting blobs to a provided OutputStream
 * or from a provided InputStream. Interception of streams is requested on a per
 * stream basis and lasts only for the duration of that stream.
     * The filter to use for providing stream data from InputStreams.
     */
    private final InputStreamInterceptingFilter inputStreamFilter =
            new InputStreamInterceptingFilter(this);

    /**
    /**
     * Intercept the given stream, continuously writing the contents of the
     * given InputStream as blobs. The stream will automatically end when
     * when the end of the InputStream is reached. If there is no such
     * stream, then the InputStream will be closed immediately. This function
     * will block until all data from the InputStream has been written to the
     * given stream.
     *
     * @param index
     *     The index of the stream to intercept.
     *
     * @param stream
     *     The InputStream to read all blobs data from.
     */
    public void interceptStream(int index, InputStream stream) {

        // Log beginning of intercepted stream
        logger.debug("Intercepting input stream #{} of tunnel \"{}\".",
                index, getUUID());

        inputStreamFilter.interceptStream(index, new BufferedInputStream(stream));

        // Log end of intercepted stream
        logger.debug("Intercepted input stream #{} of tunnel \"{}\" ended.",
                index, getUUID());

    }


        GuacamoleReader reader = super.acquireReader();

        // Filter both input and output streams
        reader = new FilteredGuacamoleReader(reader, inputStreamFilter);
        reader = new FilteredGuacamoleReader(reader, outputStreamFilter);

        return reader;

            inputStreamFilter.closeAllInterceptedStreams();
     * The associated Guacamole protocol status code.
     */
    private final Integer statusCode;

    /**
        PERMISSION_DENIED(Response.Status.FORBIDDEN),

        /**
         * An error occurred within an intercepted stream, terminating that
         * stream. The Guacamole protocol status code of that error can be
         * retrieved with getStatusCode().
         */
        STREAM_ERROR(Response.Status.BAD_REQUEST);
     * Creates a new APIError of type STREAM_ERROR and having the given
     * Guacamole protocol status code and human-readable message. The status
     * code and message should be taken directly from the "ack" instruction
     * causing the error.
     *
     * @param statusCode
     *     The Guacamole protocol status code describing the error that
     *     occurred within the intercepted stream.
     *
     * @param message
     *     An arbitrary human-readable message describing the error that
     *     occurred.
     */
    public APIError(int statusCode, String message) {
        this.type       = Type.STREAM_ERROR;
        this.message    = message;
        this.statusCode = statusCode;
        this.expected   = null;
    }

    /**
        this.type       = type;
        this.message    = message;
        this.statusCode = null;
        this.expected   = null;
        this.type       = type;
        this.message    = message;
        this.statusCode = null;
        this.expected   = expected;
     * Returns the Guacamole protocol status code associated with the error
     * that occurred. This is only valid for errors of type STREAM_ERROR.
     *
     * @return
     *     The Guacamole protocol status code associated with the error that
     *     occurred. If the error is not of type STREAM_ERROR, this will be
     *     null.
     */
    public Integer getStatusCode() {
        return statusCode;
    }

    /**
import org.apache.guacamole.protocol.GuacamoleStatus;
     * Creates a new APIException which represents an error that occurred within
     * an intercepted Guacamole stream. The nature of that error will be
     * described by a given status code, which should be the status code
     * provided by the "ack" instruction that reported the error.
     *
     * @param status
     *     The Guacamole protocol status code describing the error that
     *     occurred within the intercepted stream.
     *
     * @param message
     *     An arbitrary human-readable message describing the error that
     *     occurred.
     */
    public APIException(int status, String message) {
        this(new APIError(status, message));
    }

    /**
     * Creates a new APIException which represents an error that occurred within
     * an intercepted Guacamole stream. The nature of that error will be
     * described by a given Guacamole protocol status, which should be the
     * status associated with the code provided by the "ack" instruction that
     * reported the error.
     *
     * @param status
     *     The Guacamole protocol status describing the error that occurred
     *     within the intercepted stream.
     *
     * @param message
     *     An arbitrary human-readable message describing the error that
     *     occurred.
     */
    public APIException(GuacamoleStatus status, String message) {
        this(status.getGuacamoleStatusCode(), message);
    }

    /**
import org.apache.guacamole.tunnel.GuacamoleStreamException;
        // Errors from intercepted streams
        catch (GuacamoleStreamException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Error reported by stream.";

            throw new APIException(
                e.getStatus(),
                message
            );

        }


    /**
     * Returns the GuacamoleStatus corresponding to the given Guacamole
     * protocol status code. If no such GuacamoleStatus is defined, null is
     * returned.
     *
     * @param code
     *     The Guacamole protocol status code to translate into a
     *     GuacamoleStatus.
     *
     * @return
     *     The GuacamoleStatus corresponding to the given Guacamole protocol
     *     status code, or null if no such GuacamoleStatus is defined.
     */
    public static GuacamoleStatus fromGuacamoleStatusCode(int code) {

        // Search for a GuacamoleStatus having the given status code
        for (GuacamoleStatus status : values()) {
            if (status.getGuacamoleStatusCode() == code)
                return status;
        }

        // No such status found
        return null;

    }

                try {
                    tunnel.interceptStream(streamIndex, output);
                }
                catch (GuacamoleException e) {
                    throw new IOException(e);
                }
     *     If the session associated with the given auth
     *     token cannot be retrieved, if no such tunnel exists, or if the
     *     intercepted stream itself closes with an error.
import org.apache.guacamole.protocol.GuacamoleStatus;

            // Parse status code as integer
            int code;
            try {
                code = Integer.parseInt(status);
            }

            // Assume internal error if parsing fails
            catch (NumberFormatException e) {
                logger.debug("Translating invalid status code \"{}\" to SERVER_ERROR.", status);
                code = GuacamoleStatus.SERVER_ERROR.getGuacamoleStatusCode();
            }

            // Flag error and close stream
            stream.setStreamError(code, args.get(1));

import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.protocol.GuacamoleStatus;
     * The exception which prevented the stream from completing successfully,
     * if any. If the stream completed successfully, or has not encountered any
     * exception yet, this will be null.
     */
    private GuacamoleException streamError = null;

    /**
    /**
     * Reports that this InterceptedStream did not complete successfully due to
     * the given GuacamoleException, which could not be thrown at the time due
     * to asynchronous handling of the stream contents.
     *
     * @param streamError
     *     The exception which prevented the stream from completing
     *     successfully.
     */
    public void setStreamError(GuacamoleException streamError) {
        this.streamError = streamError;
    }

    /**
     * Reports that this InterceptedStream did not complete successfully due to
     * an error described by the given status code and human-readable message.
     * The error reported by this call can later be retrieved as a
     * GuacamoleStreamException by calling getStreamError().
     *
     * @param code
     *     The Guacamole protocol status code which described the error that
     *     occurred. This should be taken directly from the "ack" instruction
     *     that reported the error witin the intercepted stream.
     *
     * @param message
     *     A human-readable message describing the error that occurred. This
     *     should be taken directly from the "ack" instruction that reported
     *     the error witin the intercepted stream.
     */
    public void setStreamError(int code, String message) {

        // Map status code to GuacamoleStatus, assuming SERVER_ERROR by default
        GuacamoleStatus status = GuacamoleStatus.fromGuacamoleStatusCode(code);
        if (status == null)
            status = GuacamoleStatus.SERVER_ERROR;

        // Associate stream with corresponding GuacamoleStreamException
        setStreamError(new GuacamoleStreamException(status, message));

    }

    /**
     * Returns whether an error has prevented this InterceptedStream from
     * completing successfully. This will return false if the stream has
     * completed successfully OR if the stream simply has not yet completed.
     *
     * @return
     *     true if an error has prevented this InterceptedStream from
     *     completing successfully, false otherwise.
     */
    public boolean hasStreamError() {
        return streamError != null;
    }

    /**
     * Returns a GuacamoleException which describes why this InterceptedStream
     * did not complete successfully.
     *
     * @return
     *     An exception describing the error that prevented the stream from
     *     completing successfully, or null if no such error has occurred.
     */
    public GuacamoleException getStreamError() {
        return streamError;
    }

     *
     * @throws GuacamoleException
     *     If an error occurs while intercepting the stream, or if the stream
     *     itself reports an error.
    public void interceptStream(int index, T stream) throws GuacamoleException {
        // Throw any asynchronously-provided exception
        if (interceptedStream.hasStreamError())
            throw interceptedStream.getStreamError();

     *
     * @throws GuacamoleException
     *     If an error occurs while intercepting the stream, or if the stream
     *     itself reports an error.
    public void interceptStream(int index, OutputStream stream)
            throws GuacamoleException {
        try {
            outputStreamFilter.interceptStream(index, new BufferedOutputStream(stream));
        }
        finally {
            logger.debug("Intercepted output stream #{} of tunnel \"{}\" ended.",
                    index, getUUID());
        }
     *
     * @throws GuacamoleException
     *     If an error occurs while intercepting the stream, or if the stream
     *     itself reports an error.
    public void interceptStream(int index, InputStream stream)
            throws GuacamoleException {
        try {
            inputStreamFilter.interceptStream(index, new BufferedInputStream(stream));
        }
        finally {
            logger.debug("Intercepted input stream #{} of tunnel \"{}\" ended.",
                    index, getUUID());
        }
     *     If the session associated with the given auth token cannot be
     *     retrieved, if no such tunnel exists, or if the intercepted stream
     *     itself closes with an error.
     *     provided by the stream.

    /**
     * Returns the GuacamoleStatus corresponding to the given Guacamole
     * protocol status code. If no such GuacamoleStatus is defined, null is
     * returned.
     *
     * @param code
     *     The Guacamole protocol status code to translate into a
     *     GuacamoleStatus.
     *
     * @return
     *     The GuacamoleStatus corresponding to the given Guacamole protocol
     *     status code, or null if no such GuacamoleStatus is defined.
     */
    public static GuacamoleStatus fromGuacamoleStatusCode(int code) {

        // Search for a GuacamoleStatus having the given status code
        for (GuacamoleStatus status : values()) {
            if (status.getGuacamoleStatusCode() == code)
                return status;
        }

        // No such status found
        return null;

    }

     * The associated Guacamole protocol status code.
     */
    private final Integer statusCode;

    /**
        PERMISSION_DENIED(Response.Status.FORBIDDEN),

        /**
         * An error occurred within an intercepted stream, terminating that
         * stream. The Guacamole protocol status code of that error can be
         * retrieved with getStatusCode().
         */
        STREAM_ERROR(Response.Status.BAD_REQUEST);
     * Creates a new APIError of type STREAM_ERROR and having the given
     * Guacamole protocol status code and human-readable message. The status
     * code and message should be taken directly from the "ack" instruction
     * causing the error.
     *
     * @param statusCode
     *     The Guacamole protocol status code describing the error that
     *     occurred within the intercepted stream.
     *
     * @param message
     *     An arbitrary human-readable message describing the error that
     *     occurred.
     */
    public APIError(int statusCode, String message) {
        this.type       = Type.STREAM_ERROR;
        this.message    = message;
        this.statusCode = statusCode;
        this.expected   = null;
    }

    /**
        this.type       = type;
        this.message    = message;
        this.statusCode = null;
        this.expected   = null;
        this.type       = type;
        this.message    = message;
        this.statusCode = null;
        this.expected   = expected;
     * Returns the Guacamole protocol status code associated with the error
     * that occurred. This is only valid for errors of type STREAM_ERROR.
     *
     * @return
     *     The Guacamole protocol status code associated with the error that
     *     occurred. If the error is not of type STREAM_ERROR, this will be
     *     null.
     */
    public Integer getStatusCode() {
        return statusCode;
    }

    /**
import org.apache.guacamole.protocol.GuacamoleStatus;
     * Creates a new APIException which represents an error that occurred within
     * an intercepted Guacamole stream. The nature of that error will be
     * described by a given status code, which should be the status code
     * provided by the "ack" instruction that reported the error.
     *
     * @param status
     *     The Guacamole protocol status code describing the error that
     *     occurred within the intercepted stream.
     *
     * @param message
     *     An arbitrary human-readable message describing the error that
     *     occurred.
     */
    public APIException(int status, String message) {
        this(new APIError(status, message));
    }

    /**
     * Creates a new APIException which represents an error that occurred within
     * an intercepted Guacamole stream. The nature of that error will be
     * described by a given Guacamole protocol status, which should be the
     * status associated with the code provided by the "ack" instruction that
     * reported the error.
     *
     * @param status
     *     The Guacamole protocol status describing the error that occurred
     *     within the intercepted stream.
     *
     * @param message
     *     An arbitrary human-readable message describing the error that
     *     occurred.
     */
    public APIException(GuacamoleStatus status, String message) {
        this(status.getGuacamoleStatusCode(), message);
    }

    /**
import org.apache.guacamole.tunnel.GuacamoleStreamException;
        // Errors from intercepted streams
        catch (GuacamoleStreamException e) {

            // Generate default message
            String message = e.getMessage();
            if (message == null)
                message = "Error reported by stream.";

            throw new APIException(
                e.getStatus(),
                message
            );

        }

import java.io.InputStream;
import javax.ws.rs.POST;
                try {
                    tunnel.interceptStream(streamIndex, output);
                }
                catch (GuacamoleException e) {
                    throw new IOException(e);
                }
    /**
     * Intercepts a specific stream, sending the contents of the given
     * InputStream over that stream as "blob" instructions.
     *
     * @param authToken
     *     The authentication token that is used to authenticate the user
     *     performing the operation.
     *
     * @param tunnelUUID
     *     The UUID of the tunnel containing the stream being intercepted.
     *
     * @param streamIndex
     *     The index of the stream to intercept.
     *
     * @param filename
     *     The filename to use for the sake of identifying the data being sent.
     *
     * @param data
     *     An InputStream containing the data to be sent over the intercepted
     *     stream.
     *
     * @throws GuacamoleException
     *     If the session associated with the given auth token cannot be
     *     retrieved, if no such tunnel exists, or if the intercepted stream
     *     itself closes with an error.
     */
    @POST
    @Consumes(MediaType.WILDCARD)
    @Path("/{tunnel}/streams/{index}/{filename}")
    public void setStreamContents(@QueryParam("token") String authToken,
            @PathParam("tunnel") String tunnelUUID,
            @PathParam("index") final int streamIndex,
            @PathParam("filename") String filename,
            InputStream data)
            throws GuacamoleException {

        GuacamoleSession session = authenticationService.getGuacamoleSession(authToken);
        Map<String, StreamInterceptingTunnel> tunnels = session.getTunnels();

        // Pull tunnel with given UUID
        final StreamInterceptingTunnel tunnel = tunnels.get(tunnelUUID);
        if (tunnel == null)
            throw new GuacamoleResourceNotFoundException("No such tunnel.");

        // Send input over stream
        tunnel.interceptStream(streamIndex, data);

    }

import java.io.BufferedInputStream;
import java.io.InputStream;
 * GuacamoleTunnel implementation which provides for producing or consuming the
 * contents of in-progress streams, rerouting blobs to a provided OutputStream
 * or from a provided InputStream. Interception of streams is requested on a per
 * stream basis and lasts only for the duration of that stream.
    private static final Logger logger =
            LoggerFactory.getLogger(StreamInterceptingTunnel.class);
     * The filter to use for providing stream data from InputStreams.
    private final InputStreamInterceptingFilter inputStreamFilter =
            new InputStreamInterceptingFilter(this);
     * The filter to use for rerouting received stream data to OutputStreams.
    private final OutputStreamInterceptingFilter outputStreamFilter =
            new OutputStreamInterceptingFilter(this);
     *
     * @throws GuacamoleException
     *     If an error occurs while intercepting the stream, or if the stream
     *     itself reports an error.
    public void interceptStream(int index, OutputStream stream)
            throws GuacamoleException {
        logger.debug("Intercepting output stream #{} of tunnel \"{}\".",
        try {
            outputStreamFilter.interceptStream(index, new BufferedOutputStream(stream));
        finally {
            logger.debug("Intercepted output stream #{} of tunnel \"{}\" ended.",
                    index, getUUID());
        }

    }

    /**
     * Intercept the given stream, continuously writing the contents of the
     * given InputStream as blobs. The stream will automatically end when
     * when the end of the InputStream is reached. If there is no such
     * stream, then the InputStream will be closed immediately. This function
     * will block until all data from the InputStream has been written to the
     * given stream.
     *
     * @param index
     *     The index of the stream to intercept.
     *
     * @param stream
     *     The InputStream to read all blobs data from.
     *
     * @throws GuacamoleException
     *     If an error occurs while intercepting the stream, or if the stream
     *     itself reports an error.
     */
    public void interceptStream(int index, InputStream stream)
            throws GuacamoleException {

        // Log beginning of intercepted stream
        logger.debug("Intercepting input stream #{} of tunnel \"{}\".",
                index, getUUID());

        try {
            inputStreamFilter.interceptStream(index, new BufferedInputStream(stream));
        }

        // Log end of intercepted stream
        finally {
            logger.debug("Intercepted input stream #{} of tunnel \"{}\" ended.",
                    index, getUUID());
        }

        GuacamoleReader reader = super.acquireReader();

        // Filter both input and output streams
        reader = new FilteredGuacamoleReader(reader, inputStreamFilter);
        reader = new FilteredGuacamoleReader(reader, outputStreamFilter);

        return reader;

        // Close all intercepted streams
            inputStreamFilter.closeAllInterceptedStreams();
            outputStreamFilter.closeAllInterceptedStreams();
        recordModel.setUsername(user.getIdentifier());
        recordModel.setConnectionName(connection.getName());
        recordModel.setUsername(user.getIdentifier());
        recordModel.setConnectionName(connection.getName());
     * Whether individual users should be consistently assigned the same
     * connection within a balancing group until they log out.
     */
    private boolean sessionAffinityEnabled;

    /**
    /**
     * Returns whether individual users should be consistently assigned the same
     * connection within a balancing group until they log out.
     *
     * @return
     *     Whether individual users should be consistently assigned the same
     *     connection within a balancing group until they log out.
     */
    public boolean isSessionAffinityEnabled() {
        return sessionAffinityEnabled;
    }

    /**
     * Sets whether individual users should be consistently assigned the same
     * connection within a balancing group until they log out.
     *
     * @param sessionAffinityEnabled
     *     Whether individual users should be consistently assigned the same
     *     connection within a balancing group until they log out.
     */
    public void setSessionAffinityEnabled(boolean sessionAffinityEnabled) {
        this.sessionAffinityEnabled = sessionAffinityEnabled;
    }

import org.apache.guacamole.auth.jdbc.connection.ConnectionService;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.form.BooleanField;
     * The name of the attribute which controls whether individual users will be
     * consistently assigned the same connection within a balancing group until
     * they log out.
     */
    public static final String ENABLE_SESSION_AFFINITY = "enable-session-affinity";

    /**
        new NumericField(MAX_CONNECTIONS_PER_USER_NAME),
        new BooleanField(ENABLE_SESSION_AFFINITY, "true")
        // Set session affinity attribute
        attributes.put(ENABLE_SESSION_AFFINITY,
                getModel().isSessionAffinityEnabled() ? "true" : "");

        // Translate session affinity attribute
        getModel().setSessionAffinityEnabled(
                "true".equals(attributes.get(ENABLE_SESSION_AFFINITY)));

    /**
     * Returns whether individual users should be consistently assigned the same
     * connection within a balancing group until they log out.
     *
     * @return
     *     Whether individual users should be consistently assigned the same
     *     connection within a balancing group until they log out.
     */
    public boolean isSessionAffinityEnabled() {
        return getModel().isSessionAffinityEnabled();
    }
     * Filters the given collection of connection identifiers, returning a new
     * collection which contains only those identifiers which are preferred. If
     * no connection identifiers within the given collection are preferred, the
     * collection is left untouched.
     *
     * @param user
     *     The user whose preferred connections should be used to filter the
     *     given collection of connection identifiers.
     *
     * @param identifiers
     *     The collection of connection identifiers that should be filtered.
     *
     * @return
     *     A collection of connection identifiers containing only the subset of
     *     connection identifiers which are also preferred or, if none of the
     *     provided identifiers are preferred, the original collection of
     *     identifiers.
     */
    private Collection<String> getPreferredConnections(AuthenticatedUser user,
            Collection<String> identifiers) {

        // Search provided identifiers for any preferred connections
        for (String identifier : identifiers) {

            // If at least one prefferred connection is found, assume it is the
            // only preferred connection
            if (user.isPreferredConnection(identifier))
                return Collections.singletonList(identifier);

        }

        // No preferred connections were found
        return identifiers;

    }

    /**
        // Restrict to preferred connections if session affinity is enabled
        if (connectionGroup.isSessionAffinityEnabled())
            identifiers = getPreferredConnections(user, identifiers);

        // If session affinity is enabled, prefer this connection going forward
        if (connectionGroup.isSessionAffinityEnabled())
            user.preferConnection(connection.getIdentifier());

import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
     * The connections which have been committed for use by this user in the
     * context of a balancing connection group. Balancing connection groups
     * will preferentially choose connections within this set, unless those
     * connections are not children of the group in question. If a group DOES
     * have at least one child connection within this set, no connections that
     * are not in this set will be used.
     */
    private final Set<String> preferredConnections =
            Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());

    /**
    /**
     * Returns whether the connection having the given identifier has been
     * marked as preferred for this user's current Guacamole session. A
     * preferred connection is always chosen in favor of other connections when
     * it is a child of a balancing connection group.
     *
     * @param identifier
     *     The identifier of the connection to test.
     *
     * @return
     *     true if the connection having the given identifier has been marked
     *     as preferred, false otherwise.
     */
    public boolean isPreferredConnection(String identifier) {
        return preferredConnections.contains(identifier);
    }

    /**
     * Marks the connection having the given identifier as preferred for this
     * user's current Guacamole session. A preferred connection is always chosen
     * in favor of other connections when it is a child of a balancing
     * connection group.
     *
     * @param identifier
     *     The identifier of the connection to prefer.
     */
    public void preferConnection(String identifier) {
        preferredConnections.add(identifier);
    }

     * Whether individual users should be consistently assigned the same
     * connection within a balancing group until they log out.
     */
    private boolean sessionAffinityEnabled;

    /**
    /**
     * Returns whether individual users should be consistently assigned the same
     * connection within a balancing group until they log out.
     *
     * @return
     *     Whether individual users should be consistently assigned the same
     *     connection within a balancing group until they log out.
     */
    public boolean isSessionAffinityEnabled() {
        return sessionAffinityEnabled;
    }

    /**
     * Sets whether individual users should be consistently assigned the same
     * connection within a balancing group until they log out.
     *
     * @param sessionAffinityEnabled
     *     Whether individual users should be consistently assigned the same
     *     connection within a balancing group until they log out.
     */
    public void setSessionAffinityEnabled(boolean sessionAffinityEnabled) {
        this.sessionAffinityEnabled = sessionAffinityEnabled;
    }

import org.apache.guacamole.auth.jdbc.connection.ConnectionService;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
import org.apache.guacamole.form.BooleanField;
     * The name of the attribute which controls whether individual users will be
     * consistently assigned the same connection within a balancing group until
     * they log out.
     */
    public static final String ENABLE_SESSION_AFFINITY = "enable-session-affinity";

    /**
        new NumericField(MAX_CONNECTIONS_PER_USER_NAME),
        new BooleanField(ENABLE_SESSION_AFFINITY, "true")
        // Set session affinity attribute
        attributes.put(ENABLE_SESSION_AFFINITY,
                getModel().isSessionAffinityEnabled() ? "true" : "");

        // Translate session affinity attribute
        getModel().setSessionAffinityEnabled(
                "true".equals(attributes.get(ENABLE_SESSION_AFFINITY)));

    /**
     * Returns whether individual users should be consistently assigned the same
     * connection within a balancing group until they log out.
     *
     * @return
     *     Whether individual users should be consistently assigned the same
     *     connection within a balancing group until they log out.
     */
    public boolean isSessionAffinityEnabled() {
        return getModel().isSessionAffinityEnabled();
    }
     * Filters the given collection of connection identifiers, returning a new
     * collection which contains only those identifiers which are preferred. If
     * no connection identifiers within the given collection are preferred, the
     * collection is left untouched.
     *
     * @param user
     *     The user whose preferred connections should be used to filter the
     *     given collection of connection identifiers.
     *
     * @param identifiers
     *     The collection of connection identifiers that should be filtered.
     *
     * @return
     *     A collection of connection identifiers containing only the subset of
     *     connection identifiers which are also preferred or, if none of the
     *     provided identifiers are preferred, the original collection of
     *     identifiers.
     */
    private Collection<String> getPreferredConnections(AuthenticatedUser user,
            Collection<String> identifiers) {

        // Search provided identifiers for any preferred connections
        for (String identifier : identifiers) {

            // If at least one prefferred connection is found, assume it is the
            // only preferred connection
            if (user.isPreferredConnection(identifier))
                return Collections.singletonList(identifier);

        }

        // No preferred connections were found
        return identifiers;

    }

    /**
        // Restrict to preferred connections if session affinity is enabled
        if (connectionGroup.isSessionAffinityEnabled())
            identifiers = getPreferredConnections(user, identifiers);

        // If session affinity is enabled, prefer this connection going forward
        if (connectionGroup.isSessionAffinityEnabled())
            user.preferConnection(connection.getIdentifier());

import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
     * The connections which have been committed for use by this user in the
     * context of a balancing connection group. Balancing connection groups
     * will preferentially choose connections within this set, unless those
     * connections are not children of the group in question. If a group DOES
     * have at least one child connection within this set, no connections that
     * are not in this set will be used.
     */
    private final Set<String> preferredConnections =
            Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());

    /**
    /**
     * Returns whether the connection having the given identifier has been
     * marked as preferred for this user's current Guacamole session. A
     * preferred connection is always chosen in favor of other connections when
     * it is a child of a balancing connection group.
     *
     * @param identifier
     *     The identifier of the connection to test.
     *
     * @return
     *     true if the connection having the given identifier has been marked
     *     as preferred, false otherwise.
     */
    public boolean isPreferredConnection(String identifier) {
        return preferredConnections.contains(identifier);
    }

    /**
     * Marks the connection having the given identifier as preferred for this
     * user's current Guacamole session. A preferred connection is always chosen
     * in favor of other connections when it is a child of a balancing
     * connection group.
     *
     * @param identifier
     *     The identifier of the connection to prefer.
     */
    public void preferConnection(String identifier) {
        preferredConnections.add(identifier);
    }

import org.apache.guacamole.rest.session.UserContextResourceFactory;
import org.apache.guacamole.rest.session.SessionResource;
import com.google.inject.assistedinject.FactoryModuleBuilder;
        // Root-level resources
        bind(SessionResource.class);
        install(new FactoryModuleBuilder().build(UserContextResourceFactory.class));

import org.apache.guacamole.GuacamoleClientException;

        // Validate that data was provided
        if (modifiedObject == null)
            throw new GuacamoleClientException("Data must be submitted when updating objects.");

        // Perform update

        // Validate that data was provided
        if (object == null)
            throw new GuacamoleClientException("Data must be submitted when creating objects.");

import org.apache.guacamole.net.auth.UserContext;
     * @param userContext
     *     The UserContext which contains the given Directory.
     *
        create(UserContext userContext, Directory<InternalType> directory,
                InternalType object);
        return resourceFactory.create(userContext, directory, object);
import org.apache.guacamole.rest.connection.ConnectionModule;
        // Resources below root
        install(new ConnectionModule());

import org.apache.guacamole.rest.directory.DirectoryResource;
import org.apache.guacamole.rest.directory.DirectoryResourceFactory;
import com.google.inject.Inject;
import javax.ws.rs.Path;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.rest.connection.APIConnection;
     * Factory for creating DirectoryResources which expose a given
     * Connection Directory.
     */
    @Inject
    private DirectoryResourceFactory<Connection, APIConnection> connectionDirectoryResourceFactory;

    /**
    /**
     * Returns a new resource which represents the Connection Directory
     * contained within the UserContext exposed by this UserContextResource.
     *
     * @return
     *     A new resource which represents the Connection Directory contained
     *     within the UserContext exposed by this UserContextResource.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the Connection Directory.
     */
    @Path("connections")
    public DirectoryResource<Connection, APIConnection> getConnectionDirectoryResource()
            throws GuacamoleException {
        return connectionDirectoryResourceFactory.create(userContext,
                userContext.getConnectionDirectory());
    }

import org.apache.guacamole.rest.connectiongroup.ConnectionGroupModule;
        install(new ConnectionGroupModule());
import org.apache.guacamole.net.auth.ConnectionGroup;
import org.apache.guacamole.rest.connectiongroup.APIConnectionGroup;
    private DirectoryResourceFactory<Connection, APIConnection>
            connectionDirectoryResourceFactory;

    /**
     * Factory for creating DirectoryResources which expose a given
     * ConnectionGroup Directory.
     */
    @Inject
    private DirectoryResourceFactory<ConnectionGroup, APIConnectionGroup>
            connectionGroupDirectoryResourceFactory;
    /**
     * Returns a new resource which represents the ConnectionGroup Directory
     * contained within the UserContext exposed by this UserContextResource.
     *
     * @return
     *     A new resource which represents the ConnectionGroup Directory
     *     contained within the UserContext exposed by this UserContextResource.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the ConnectionGroup Directory.
     */
    @Path("connectionGroups")
    public DirectoryResource<ConnectionGroup, APIConnectionGroup> getConnectionGroupDirectoryResource()
            throws GuacamoleException {
        return connectionGroupDirectoryResourceFactory.create(userContext,
                userContext.getConnectionGroupDirectory());
    }

import org.apache.guacamole.rest.activeconnection.ActiveConnectionModule;
        install(new ActiveConnectionModule());
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.rest.activeconnection.APIActiveConnection;
     * ActiveConnection Directory.
     */
    @Inject
    private DirectoryResourceFactory<ActiveConnection, APIActiveConnection>
            activeConnectionDirectoryResourceFactory;

    /**
     * Factory for creating DirectoryResources which expose a given
     * Returns a new resource which represents the ActiveConnection Directory
     * contained within the UserContext exposed by this UserContextResource.
     *
     * @return
     *     A new resource which represents the ActiveConnection Directory
     *     contained within the UserContext exposed by this UserContextResource.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the ActiveConnection Directory.
     */
    @Path("activeConnections")
    public DirectoryResource<ActiveConnection, APIActiveConnection>
        getActiveConnectionDirectoryResource() throws GuacamoleException {
        return activeConnectionDirectoryResourceFactory.create(userContext,
                userContext.getActiveConnectionDirectory());
    }

    /**
import org.apache.guacamole.rest.user.UserModule;
        install(new UserModule());
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.rest.user.APIUser;
     * Factory for creating DirectoryResources which expose a given
     * User Directory.
     */
    @Inject
    private DirectoryResourceFactory<User, APIUser> userDirectoryResourceFactory;

    /**
    /**
     * Returns a new resource which represents the User Directory contained
     * within the UserContext exposed by this UserContextResource.
     *
     * @return
     *     A new resource which represents the User Directory contained within
     *     the UserContext exposed by this UserContextResource.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the User Directory.
     */
    @Path("users")
    public DirectoryResource<User, APIUser> getUserDirectoryResource()
            throws GuacamoleException {
        return userDirectoryResourceFactory.create(userContext,
                userContext.getUserDirectory());
    }

 b/guacamole/src/main/java/org/apache/guacamole/rest/permission/PermissionSetPatch.java
package org.apache.guacamole.rest.permission;
import org.apache.guacamole.rest.permission.PermissionSetResource;
     * Returns a resource which abstracts operations available on the overall
     * permissions granted to the User represented by this UserResource.
     *     A resource which representing the permissions granted to the User
     *     represented by this UserResource.
    public PermissionSetResource getPermissions() {
        return new PermissionSetResource(user);
import java.util.UUID;
    public APIUser createObject(APIUser object) throws GuacamoleException {

        // Randomly set the password if it wasn't provided
        if (object.getPassword() == null)
            object.setPassword(UUID.randomUUID().toString());

        return super.createObject(object);

    }

    @Override
 b/guacamole/src/main/java/org/apache/guacamole/rest/history/HistoryResource.java
 * A REST resource for retrieving and managing the history records of Guacamole
public class HistoryResource {
     * The UserContext whose associated connection history is being exposed.
    private final UserContext userContext;
     * Creates a new HistoryResource which exposes the connection history
     * associated with the given UserContext.
     *
     * @param userContext
     *     The UserContext whose connection history should be exposed.
    public HistoryResource(UserContext userContext) {
        this.userContext = userContext;
    }
    @Path("connections")
    public List<APIConnectionRecord> getConnectionHistory(
import org.apache.guacamole.rest.history.HistoryResource;
    /**
     * Returns a new resource which represents historical data contained
     * within the UserContext exposed by this UserContextResource.
     *
     * @return
     *     A new resource which represents the historical data contained within
     *     the UserContext exposed by this UserContextResource.
     */
    @Path("history")
    public HistoryResource getHistoryResource() {
        return new HistoryResource(userContext);
    }

import org.apache.guacamole.rest.schema.SchemaResource;
    /**
     * Returns a new resource which represents meta information describing the
     * kind of data which within the UserContext exposed by this
     * UserContextResource.
     *
     * @return
     *     A new resource which represents the meta information describing the
     *     kind of data within the UserContext exposed by this
     *     UserContextResource.
     */
    @Path("schema")
    public SchemaResource getSchemaResource() {
        return new SchemaResource(userContext);
    }

import org.apache.guacamole.rest.session.SessionDataRESTService;
        bind(SessionDataRESTService.class);
 b/guacamole/src/main/java/org/apache/guacamole/rest/session/SessionDataRESTService.java
 * A REST service which exposes all data associated with a Guacamole user's
 * session via the underlying UserContexts.
 * @author Michael Jumper
public class SessionDataRESTService {
 * Provides easy access and automatic error handling for retrieval of objects.
        // A method is also REST method if it overrides a REST method within
        // the superclass
        Class<?> superclass = method.getDeclaringClass().getSuperclass();
        if (superclass != null) {

            // Recheck against identical method within superclass
            try {
                return isRESTMethod(superclass.getMethod(method.getName(),
                        method.getParameterTypes()));
            }

            // If there is no such method, then this method cannot possibly be
            // a REST method
            catch (NoSuchMethodException e) {
                return false;
            }

        }

        // Lacking a superclass, the search stops here - it's not a REST method
import org.apache.guacamole.rest.session.SessionRESTService;
import org.apache.guacamole.rest.session.SessionResourceFactory;
        bind(SessionRESTService.class);
        install(new FactoryModuleBuilder().build(SessionResourceFactory.class));
 b/guacamole/src/main/java/org/apache/guacamole/rest/session/SessionResource.java
import com.google.inject.assistedinject.Assisted;
import com.google.inject.assistedinject.AssistedInject;
 * A REST resource which exposes all data associated with a Guacamole user's
public class SessionResource {
     * The GuacamoleSession being exposed by this SessionResource.
    private final GuacamoleSession session;
     * Creates a new SessionResource which exposes the data within the given
     * GuacamoleSession.
     *
     * @param session
     *     The GuacamoleSession which should be exposed through this
     *     SessionResource.
     */
    @AssistedInject
    public SessionResource(@Assisted GuacamoleSession session) {
        this.session = session;
    }

    /**
     *     If the AuthenticationProvider identifier is invalid.
    @Path("data/{dataSource}")
import javax.ws.rs.Path;
     * <code>@HttpMethod</code> or <code>@Path</code>.
            // A method is a REST method if it is annotated with @Path
            if (Path.class.isAssignableFrom(annotationType))
                return true;

import javax.ws.rs.core.MediaType;
        super(Response.status(error.getType().getStatus())
                .type(MediaType.APPLICATION_JSON)
                .entity(error)
                .build());
import org.apache.guacamole.rest.tunnel.TunnelCollectionResource;
    /**
     * Retrieves a resource representing all tunnels associated with session
     * exposed by this SessionResource.
     *
     * @return
     *     A resource representing all tunnels associated with the
     *     AuthenticationProvider having the given identifier.
     */
    @Path("tunnels")
    public TunnelCollectionResource getTunnelCollectionResource() {
        return new TunnelCollectionResource(session);
    }

import org.apache.guacamole.net.auth.AuthenticationProvider;
     * Returns the UserContext associated with this session that originated
     * from the AuthenticationProvider with the given identifier. If no such
     * UserContext exists, an exception is thrown.
     *
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider that created the
     *     UserContext being retrieved.
     *
     * @return
     *     The UserContext that was created by the AuthenticationProvider
     *     having the given identifier.
     *
     * @throws GuacamoleException
     *     If no such UserContext exists.
     */
    public UserContext getUserContext(String authProviderIdentifier)
            throws GuacamoleException {

        // Locate and return the UserContext associated with the
        // AuthenticationProvider having the given identifier, if any
        for (UserContext userContext : getUserContexts()) {

            // Get AuthenticationProvider associated with current UserContext
            AuthenticationProvider authProvider = userContext.getAuthenticationProvider();

            // If AuthenticationProvider identifier matches, done
            if (authProvider.getIdentifier().equals(authProviderIdentifier))
                return userContext;

        }

        throw new GuacamoleResourceNotFoundException("Session not associated "
                 "with authentication provider \""  authProviderIdentifier  "\".");


    }

    /**
        UserContext userContext = session.getUserContext(authProviderIdentifier);
        UserContext userContext = session.getUserContext(authProviderIdentifier);
     *     of these permissions for the affected objects to appear in the
     *     result. If null, no filtering will be performed.
        // Translate each retrieved object into the corresponding external object
import org.apache.guacamole.net.auth.AuthenticationProvider;
     * Returns the UserContext associated with this session that originated
     * from the AuthenticationProvider with the given identifier. If no such
     * UserContext exists, an exception is thrown.
     *
     * @param authProviderIdentifier
     *     The unique identifier of the AuthenticationProvider that created the
     *     UserContext being retrieved.
     *
     * @return
     *     The UserContext that was created by the AuthenticationProvider
     *     having the given identifier.
     *
     * @throws GuacamoleException
     *     If no such UserContext exists.
     */
    public UserContext getUserContext(String authProviderIdentifier)
            throws GuacamoleException {

        // Locate and return the UserContext associated with the
        // AuthenticationProvider having the given identifier, if any
        for (UserContext userContext : getUserContexts()) {

            // Get AuthenticationProvider associated with current UserContext
            AuthenticationProvider authProvider = userContext.getAuthenticationProvider();

            // If AuthenticationProvider identifier matches, done
            if (authProvider.getIdentifier().equals(authProviderIdentifier))
                return userContext;

        }

        throw new GuacamoleResourceNotFoundException("Session not associated "
                 "with authentication provider \""  authProviderIdentifier  "\".");


    }

    /**
import javax.ws.rs.core.MediaType;
        super(Response.status(error.getType().getStatus())
                .type(MediaType.APPLICATION_JSON)
                .entity(error)
                .build());
import javax.ws.rs.Path;
     * <code>@HttpMethod</code> or <code>@Path</code>.
            // A method is a REST method if it is annotated with @Path
            if (Path.class.isAssignableFrom(annotationType))
                return true;

        // A method is also REST method if it overrides a REST method within
        // the superclass
        Class<?> superclass = method.getDeclaringClass().getSuperclass();
        if (superclass != null) {

            // Recheck against identical method within superclass
            try {
                return isRESTMethod(superclass.getMethod(method.getName(),
                        method.getParameterTypes()));
            }

            // If there is no such method, then this method cannot possibly be
            // a REST method
            catch (NoSuchMethodException e) {
                return false;
            }

        }

        // Lacking a superclass, the search stops here - it's not a REST method
import org.apache.guacamole.rest.session.UserContextResourceFactory;
import org.apache.guacamole.rest.session.SessionRESTService;
import com.google.inject.assistedinject.FactoryModuleBuilder;
import org.apache.guacamole.rest.activeconnection.ActiveConnectionModule;
import org.apache.guacamole.rest.connection.ConnectionModule;
import org.apache.guacamole.rest.connectiongroup.ConnectionGroupModule;
import org.apache.guacamole.rest.session.SessionResourceFactory;
import org.apache.guacamole.rest.user.UserModule;

        // Root-level resources
        bind(SessionRESTService.class);
        install(new FactoryModuleBuilder().build(SessionResourceFactory.class));
        install(new FactoryModuleBuilder().build(UserContextResourceFactory.class));

        // Resources below root
        install(new ActiveConnectionModule());
        install(new ConnectionModule());
        install(new ConnectionGroupModule());
        install(new UserModule());
 b/guacamole/src/main/java/org/apache/guacamole/rest/history/HistoryResource.java
 * A REST resource for retrieving and managing the history records of Guacamole
public class HistoryResource {
     * The UserContext whose associated connection history is being exposed.
    private final UserContext userContext;
     * Creates a new HistoryResource which exposes the connection history
     * associated with the given UserContext.
     *
     * @param userContext
     *     The UserContext whose connection history should be exposed.
    public HistoryResource(UserContext userContext) {
        this.userContext = userContext;
    }
    @Path("connections")
    public List<APIConnectionRecord> getConnectionHistory(
 b/guacamole/src/main/java/org/apache/guacamole/rest/permission/PermissionSetPatch.java
package org.apache.guacamole.rest.permission;
        UserContext userContext = session.getUserContext(authProviderIdentifier);
            // Rethrow unchecked exceptions such that they are properly wrapped
            catch (RuntimeException e) {
                throw new GuacamoleException(e.getMessage(), e);
            }

            // Log all reasonable details of exception
            if (message != null)
                logger.error("Unexpected internal error: {}", message);
            else
                logger.error("An internal error occurred, but did not contain "
                            "an error message. Enable debug-level logging for "
                            "details.");
            // Ensure internal errors are fully logged at the debug level
                "Unexpected server error."
import org.apache.guacamole.rest.directory.DirectoryResource;
                .implement(
                    new TypeLiteral<DirectoryResource<ActiveConnection, APIActiveConnection>>() {},
                    ActiveConnectionDirectoryResource.class
                )
import org.apache.guacamole.rest.directory.DirectoryResource;
                .implement(
                    new TypeLiteral<DirectoryResource<Connection, APIConnection>>() {},
                    ConnectionDirectoryResource.class
                )
public abstract class DirectoryObjectResource<InternalType extends Identifiable, ExternalType> {
    public DirectoryObjectResource(Directory<InternalType> directory, InternalType object,
public abstract class DirectoryResource<InternalType extends Identifiable, ExternalType> {
    public DirectoryResource(UserContext userContext, Directory<InternalType> directory,
            // Rethrow unchecked exceptions such that they are properly wrapped
            catch (RuntimeException e) {
                throw new GuacamoleException(e.getMessage(), e);
            }

            // Log all reasonable details of exception
            if (message != null)
                logger.error("Unexpected internal error: {}", message);
            else
                logger.error("An internal error occurred, but did not contain "
                            "an error message. Enable debug-level logging for "
                            "details.");
            // Ensure internal errors are fully logged at the debug level
                "Unexpected server error."
import org.apache.guacamole.rest.directory.DirectoryResource;
                .implement(
                    new TypeLiteral<DirectoryResource<ActiveConnection, APIActiveConnection>>() {},
                    ActiveConnectionDirectoryResource.class
                )
import org.apache.guacamole.rest.directory.DirectoryResource;
                .implement(
                    new TypeLiteral<DirectoryResource<Connection, APIConnection>>() {},
                    ConnectionDirectoryResource.class
                )
public abstract class DirectoryObjectResource<InternalType extends Identifiable, ExternalType> {
    public DirectoryObjectResource(Directory<InternalType> directory, InternalType object,
public abstract class DirectoryResource<InternalType extends Identifiable, ExternalType> {
    public DirectoryResource(UserContext userContext, Directory<InternalType> directory,
/**
 * Base implementation of an ActiveConnection, providing storage and simply
 * getters/setters for its main properties.
 *
 * @author Michael Jumper
 */
public abstract class AbstractActiveConnection extends AbstractIdentifiable
        implements ActiveConnection {
public abstract class AbstractAuthenticatedUser extends AbstractIdentifiable
        implements AuthenticatedUser {
    // Prior functionality now resides within AbstractIdentifiable
public abstract class AbstractConnection extends AbstractIdentifiable
        implements Connection {
public abstract class AbstractConnectionGroup extends AbstractIdentifiable
        implements ConnectionGroup {
public abstract class AbstractUser extends AbstractIdentifiable
        implements User {
/**
 * Base implementation of an ActiveConnection, providing storage and simply
 * getters/setters for its main properties.
 *
 * @author Michael Jumper
 */
public abstract class AbstractActiveConnection extends AbstractIdentifiable
        implements ActiveConnection {
public abstract class AbstractAuthenticatedUser extends AbstractIdentifiable
        implements AuthenticatedUser {
    // Prior functionality now resides within AbstractIdentifiable
public abstract class AbstractConnection extends AbstractIdentifiable
        implements Connection {
public abstract class AbstractConnectionGroup extends AbstractIdentifiable
        implements ConnectionGroup {
public abstract class AbstractUser extends AbstractIdentifiable
        implements User {
import java.util.Collections;
import java.util.Set;
import org.apache.guacamole.GuacamoleException;
    @Override
    public Set<String> getSharingProfileIdentifiers()
            throws GuacamoleException {
        return Collections.<String>emptySet();
    }

import java.util.Set;
    /**
     * Returns identifiers of all readable sharing profiles that can be used to
     * join this connection when it is active. The level of access granted to a
     * joining user is dictated by the connection parameters associated with
     * the sharing profile, not necessarily the parameters of the primary
     * connection being joined.
     *
     * @return
     *     A Set of identifiers representing the sharing profiles for this
     *     connection.
     *
     * @throws GuacamoleException
     *     If an error occurs while fetching the sharing profiles for this
     *     connection.
     */
    public Set<String> getSharingProfileIdentifiers() throws GuacamoleException;

     * Returns the identifier of the sharing profile that was used to access the
     * connection associated with this connection record. If the connection was
     * accessed directly (without involving a sharing profile), this will be
     * null.
     *
     * @return
     *     The identifier of the sharing profile used to access the connection
     *     associated with this connection record, or null if the connection
     *     was accessed directly.
     */
    public String getSharingProfileIdentifier();

    /**
     * Returns the name of the sharing profile that was used to access the
     * connection associated with this connection record. If the connection was
     * accessed directly (without involving a sharing profile), this will be
     * null.
     *
     * @return
     *     The name of the sharing profile used to access the connection
     *     associated with this connection record, or null if the connection
     *     was accessed directly.
     */
    public String getSharingProfileName();

    /**
     * Retrieves a Directory which can be used to view and manipulate
     * sharing profiles and their configurations, but only as allowed by the
     * permissions given to the user.
     *
     * @return
     *     A Directory whose operations are bound by the permissions of the
     *     user.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the Directory.
     */
    Directory<SharingProfile> getSharingProfileDirectory()
            throws GuacamoleException;

    /**
    /**
     * Retrieves a collection of all attributes applicable to sharing profiles.
     * This collection will contain only those attributes which the current user
     * has general permission to view or modify. If there are no such
     * attributes, this collection will be empty.
     *
     * @return
     *     A collection of all attributes applicable to sharing profile.
     */
    Collection<Form> getSharingProfileAttributes();

import org.apache.guacamole.net.auth.SharingProfile;
    public Directory<SharingProfile> getSharingProfileDirectory()
            throws GuacamoleException {
        return new SimpleDirectory<SharingProfile>();
    }

    @Override
    @Override
    public Collection<Form> getSharingProfileAttributes() {
        return Collections.<Form>emptyList();
    }

import java.util.Set;
    public Set<String> getSharingProfileIdentifiers() {
        throw new UnsupportedOperationException("Operation not supported.");
    }

    @Override
     * Returns all sharing profile permissions given to this user.
     *
     * @return
     *     An ObjectPermissionSet of all sharing profile permissions granted to
     *     this user.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving permissions, or if reading all
     *     permissions is not allowed.
     */
    ObjectPermissionSet getSharingProfilePermissions()
            throws GuacamoleException;

    /**
         * Create sharing profiles.
         */
        CREATE_SHARING_PROFILE,

        /**
    @Override
    public ObjectPermissionSet getSharingProfilePermissions() {
        return new SimpleObjectPermissionSet();
    }

     * The identifier of the associated sharing profile.
     */
    private String sharingProfileIdentifier;

    /**
    public String getSharingProfileIdentifier() {
        return sharingProfileIdentifier;
    }

    @Override
    public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
        this.sharingProfileIdentifier = sharingProfileIdentifier;
    }

    @Override

    /**
     * Returns the identifier of the sharing profile being actively used. If
     * the connection is being accessed directly, this will be null.
     *
     * @return
     *     The identifier of the sharing profile being actively used.
     */
    String getSharingProfileIdentifier();

    /**
     * Sets the identifier of the sharing profile being actively used.
     *
     * @param sharingProfileIdentifier
     *     The identifier of the sharing profile being actively used.
     */
    void setSharingProfileIdentifier(String sharingProfileIdentifier);

        /**
         * An HTTP query parameter which is expected to be embedded in the URL
         * given to a user.
         */
        public static String QUERY_PARAMETER = "QUERY_PARAMETER";

public interface ActiveConnection extends Identifiable, Shareable<SharingProfile> {
import org.apache.guacamole.net.auth.SharingProfile;
    public Directory<SharingProfile> getSharingProfileDirectory()
            throws GuacamoleException {
        return new SimpleDirectory<SharingProfile>();
    }

    @Override
    @Override
    public Collection<Form> getSharingProfileAttributes() {
        return Collections.<Form>emptyList();
    }

import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.credentials.UserCredentials;
     * The identifier of the associated sharing profile.
     */
    private String sharingProfileIdentifier;

    /**
        this.connectionIdentifier     = activeConnectionRecord.getConnectionIdentifier();
        this.sharingProfileIdentifier = activeConnectionRecord.getSharingProfileIdentifier();
        this.identifier               = activeConnectionRecord.getUUID().toString();
        this.startDate                = activeConnectionRecord.getStartDate();
    public String getSharingProfileIdentifier() {
        return sharingProfileIdentifier;
    }

    @Override
    public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
        this.sharingProfileIdentifier = sharingProfileIdentifier;
    }

    @Override
    public UserCredentials getSharingCredentials(String identifier)
            throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied");
    }

    @Override
import java.util.Set;
    public Set<String> getSharingProfileIdentifiers()
            throws GuacamoleException {
        return Collections.<String>emptySet();
    }

    @Override
    public String getSharingProfileIdentifier() {
        return null;
    }

    @Override
    public String getSharingProfileName() {
        return null;
    }

    @Override
    public String getSharingProfileIdentifier() {
        return null;
    }

    @Override
    public String getSharingProfileName() {
        return null;
    }

    @Override
import org.apache.guacamole.net.auth.simple.SimpleObjectPermissionSet;
    public ObjectPermissionSet getSharingProfilePermissions()
            throws GuacamoleException {
        return new SimpleObjectPermissionSet();
    }

    @Override
import java.util.Collections;
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.net.auth.simple.SimpleDirectory;
    public Directory<SharingProfile> getSharingProfileDirectory()
            throws GuacamoleException {
        return new SimpleDirectory<SharingProfile>();
    }

    @Override
    @Override
    public Collection<Form> getSharingProfileAttributes() {
        return Collections.<Form>emptyList();
    }

import org.apache.guacamole.rest.sharingprofile.SharingProfileModule;
        install(new SharingProfileModule());
     * The identifier of the sharing profile associated with this record.
     */
    private final String sharingProfileIdentifier;

    /**
     * The identifier of the sharing profile associated with this record.
     */
    private final String sharingProfileName;

    /**
        this.connectionIdentifier     = record.getConnectionIdentifier();
        this.connectionName           = record.getConnectionName();
        this.sharingProfileIdentifier = record.getSharingProfileIdentifier();
        this.sharingProfileName       = record.getSharingProfileName();
        this.startDate                = record.getStartDate();
        this.endDate                  = record.getEndDate();
        this.remoteHost               = record.getRemoteHost();
        this.username                 = record.getUsername();
        this.active                   = record.isActive();
     * Returns the identifier of the sharing profile associated with this
     * record. If the connection was not being used via a sharing profile, this
     * will be null.
     *
     * @return
     *     The identifier of the sharing profile associated with this record,
     *     or null if no sharing profile was used.
     */
    public String getSharingProfileIdentifier() {
        return sharingProfileIdentifier;
    }

    /**
     * Returns the name of the sharing profile associated with this record. If
     * the connection was not being used via a sharing profile, this will be
     * null.
     *
     * @return
     *     The name of the sharing profile associated with this record, or null
     *     if no sharing profile was used.
     */
    public String getSharingProfileName() {
        return sharingProfileName;
    }

    /**
     * Map of sharing profile ID to the set of granted permissions.
     */
    private Map<String, Set<ObjectPermission.Type>> sharingProfilePermissions =
            new HashMap<String, Set<ObjectPermission.Type>>();

    /**
        addObjectPermissions(sharingProfilePermissions,   user.getSharingProfilePermissions());
     * Returns a map of sharing profile identifiers to the set of permissions
     * granted for that sharing profile. If no permissions are granted to a
     * particular sharing profile, its identifier will not be present as a key
     * in the map. This map is mutable, and changes to this map will affect the
     * permission set directly.
     *
     * @return
     *     A map of sharing profile identifiers to the set of permissions
     *     granted for that sharing profile.
     */
    public Map<String, Set<ObjectPermission.Type>> getSharingProfilePermissions() {
        return sharingProfilePermissions;
    }

    /**
     * Replaces the current map of sharing profile permissions with the given
     * map, which must map each sharing profile identifier to its corresponding
     * set of granted permissions. If a sharing profile has no permissions, its
     * identifier must not be present as a key in the map.
     *
     * @param sharingProfilePermissions
     *     The map which must replace the currently-stored map of permissions.
     */
    public void setSharingProfilePermissions(Map<String, Set<ObjectPermission.Type>> sharingProfilePermissions) {
        this.sharingProfilePermissions = sharingProfilePermissions;
    }

    /**
     * modifies the permissions of a user regarding a specific sharing profile.
     */
    private static final String SHARING_PROFILE_PERMISSION_PATCH_PATH_PREFIX = "/sharingProfilePermissions/";

    /**
     * The prefix of any path within an operation of a JSON patch which
        PermissionSetPatch<ObjectPermission> sharingProfilePermissionPatch   = new PermissionSetPatch<ObjectPermission>();
            // Create sharing profile permission if path has sharing profileprefix
            else if (path.startsWith(SHARING_PROFILE_PERMISSION_PATCH_PATH_PREFIX)) {

                // Get identifier and type from patch operation
                String identifier = path.substring(SHARING_PROFILE_PERMISSION_PATCH_PATH_PREFIX.length());
                ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());

                // Create and update corresponding permission
                ObjectPermission permission = new ObjectPermission(type, identifier);
                updatePermissionSet(patch.getOp(), sharingProfilePermissionPatch, permission);

            }

        sharingProfilePermissionPatch.apply(user.getSharingProfilePermissions());
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
     * SharingProfile Directory.
     */
    @Inject
    private DirectoryResourceFactory<SharingProfile, APISharingProfile>
            sharingProfileDirectoryResourceFactory;

    /**
     * Factory for creating DirectoryResources which expose a given
     * Returns a new resource which represents the SharingProfile Directory
     * contained within the UserContext exposed by this UserContextResource.
     *
     * @return
     *     A new resource which represents the SharingProfile Directory
     *     contained within the UserContext exposed by this UserContextResource.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the SharingProfile Directory.
     */
    @Path("sharingProfiles")
    public DirectoryResource<SharingProfile, APISharingProfile>
        getSharingProfileDirectoryResource() throws GuacamoleException {
        return sharingProfileDirectoryResourceFactory.create(userContext,
                userContext.getSharingProfileDirectory());
    }

    /**
    public ObjectPermissionSet getSharingProfilePermissions() throws GuacamoleException {
        throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
    }

    @Override
import org.apache.guacamole.tunnel.UserTunnel;
    private final Map<String, UserTunnel> tunnels =
            new ConcurrentHashMap<String, UserTunnel>();
    public Map<String, UserTunnel> getTunnels() {
    public void addTunnel(UserTunnel tunnel) {
import org.apache.guacamole.tunnel.UserTunnel;
        Map<String, UserTunnel> tunnels = session.getTunnels();
        final UserTunnel tunnel = tunnels.get(tunnelUUID);
import org.apache.guacamole.tunnel.UserTunnel;
    private final UserTunnel tunnel;
    public TunnelResource(UserTunnel tunnel) {
     * @param context
     *     The UserContext associated with the user for whom the tunnel is
     *     being created.
     *
            final String authToken, final GuacamoleSession session,
            final UserContext context, final TunnelRequest.Type type,
            final String id) throws GuacamoleException {
        UserTunnel monitoredTunnel = new UserTunnel(context, tunnel) {
            return createAssociatedTunnel(tunnel, authToken, session, userContext, type, id);
import org.apache.guacamole.rest.tunnel.TunnelCollectionResourceFactory;
import org.apache.guacamole.rest.tunnel.TunnelResourceFactory;
        install(new FactoryModuleBuilder().build(TunnelCollectionResourceFactory.class));
        install(new FactoryModuleBuilder().build(TunnelResourceFactory.class));
import org.apache.guacamole.rest.tunnel.TunnelCollectionResourceFactory;
     * Factory for creating instances of resources which represent the
     * collection of tunnels within a GuacamoleSession.
     */
    @Inject
    private TunnelCollectionResourceFactory tunnelCollectionResourceFactory;

    /**
        return tunnelCollectionResourceFactory.create(session);
import com.google.inject.Inject;
import com.google.inject.assistedinject.Assisted;
import com.google.inject.assistedinject.AssistedInject;
     * Factory for creating instances of resources which represent tunnels.
     */
    @Inject
    private TunnelResourceFactory tunnelResourceFactory;

    /**
    @AssistedInject
    public TunnelCollectionResource(@Assisted GuacamoleSession session) {
        return tunnelResourceFactory.create(tunnel);
import com.google.inject.Inject;
import com.google.inject.assistedinject.Assisted;
import com.google.inject.assistedinject.AssistedInject;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.rest.activeconnection.APIActiveConnection;
import org.apache.guacamole.rest.directory.DirectoryObjectResource;
import org.apache.guacamole.rest.directory.DirectoryObjectResourceFactory;
     * A factory which can be used to create instances of resources representing
     * ActiveConnections.
     */
    @Inject
    private DirectoryObjectResourceFactory<ActiveConnection, APIActiveConnection>
            activeConnectionResourceFactory;

    /**
    @AssistedInject
    public TunnelResource(@Assisted UserTunnel tunnel) {
     * Retrieves a resource representing the ActiveConnection object associated
     * with this tunnel.
     *
     * @return
     *     A resource representing the ActiveConnection object associated with
     *     this tunnel.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the ActiveConnection.
     */
    @Path("activeConnection")
    public DirectoryObjectResource<ActiveConnection, APIActiveConnection>
        getActiveConnection() throws GuacamoleException {

        // Pull the UserContext from the tunnel
        UserContext userContext = tunnel.getUserContext();

        // Return the associated ActiveConnection as a resource
        return activeConnectionResourceFactory.create(userContext,
                userContext.getActiveConnectionDirectory(),
                tunnel.getActiveConnection());

    }

    /**
import com.google.inject.Inject;
import javax.ws.rs.Path;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.rest.connection.APIConnection;
import org.apache.guacamole.rest.directory.DirectoryResourceFactory;
     * The UserContext associated with the Directory which contains the
     * Connection exposed by this resource.
     */
    private final UserContext userContext;

    /**
     * The ActiveConnection exposed by this ActiveConnectionResource.
     */
    private final ActiveConnection activeConnection;

    /**
     * A factory which can be used to create instances of resources representing
     * Connection.
     */
    @Inject
    private DirectoryResourceFactory<Connection, APIConnection>
            connectionDirectoryResourceFactory;

    /**
     * @param activeConnection
            @Assisted ActiveConnection activeConnection,
        super(directory, activeConnection, translator);
        this.userContext = userContext;
        this.activeConnection = activeConnection;
    }

    /**
     * Retrieves a resource representing the Connection object that is being
     * actively used.
     *
     * @return
     *     A resource representing the Connection object that is being actively
     *     used.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the Connection.
     */
    @Path("connection")
    public DirectoryObjectResource<Connection, APIConnection> getConnection()
            throws GuacamoleException {

        // Return the underlying connection as a resource
        return connectionDirectoryResourceFactory
                .create(userContext, userContext.getConnectionDirectory())
                .getObjectResource(activeConnection.getConnectionIdentifier());

import javax.ws.rs.GET;
import javax.ws.rs.PathParam;
    /**
     * Retrieves a set of credentials which can be POSTed by another user to the
     * "/api/tokens" endpoint to obtain access strictly to this connection. The
     * retrieved credentials may be purpose-generated and temporary.
     *
     * @param sharingProfileIdentifier The identifier of the sharing connection
     * defining the semantics of the shared session.
     *
     * @return The set of credentials which should be used to access strictly
     * this connection.
     *
     * @throws GuacamoleException If an error occurs while retrieving the
     * sharing credentials for this connection.
     */
    @GET
    @Path("sharingCredentials/{sharingProfile}")
    public APIUserCredentials getSharingCredentials(
            @PathParam("sharingProfile") String sharingProfileIdentifier)
            throws GuacamoleException {

        // Generate and return sharing credentials for the active connection
        return new APIUserCredentials(activeConnection.getSharingCredentials(sharingProfileIdentifier));

    }

import com.google.inject.Inject;
import org.apache.guacamole.rest.directory.DirectoryView;
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.rest.directory.DirectoryResource;
import org.apache.guacamole.rest.directory.DirectoryResourceFactory;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
     * A factory which can be used to create instances of resources representing
     * SharingProfiles.
     */
    @Inject
    private DirectoryResourceFactory<SharingProfile, APISharingProfile>
            sharingProfileDirectoryResourceFactory;

    /**
    /**
     * Returns a resource which provides read-only access to the subset of
     * SharingProfiles that the current user can use to share this connection.
     *
     * @return
     *     A resource which provides read-only access to the subset of
     *     SharingProfiles that the current user can use to share this
     *     connection.
     *
     * @throws GuacamoleException
     *     If the SharingProfiles associated with this connection cannot be
     *     retrieved.
     */
    @Path("sharingProfiles")
    public DirectoryResource<SharingProfile, APISharingProfile>
            getSharingProfileDirectoryResource() throws GuacamoleException {

        // Produce subset of all SharingProfiles, containing only those which
        // are associated with this connection
        Directory<SharingProfile> sharingProfiles = new DirectoryView<SharingProfile>(
            userContext.getSharingProfileDirectory(),
            connection.getSharingProfileIdentifiers()
        );

        // Return a new resource which provides access to only those SharingProfiles
        return sharingProfileDirectoryResourceFactory.create(userContext, sharingProfiles);

    }

            // Create sharing profile permission if path has sharing profile prefix
        // Search all connections for a tunnel which matches this tunnel
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.credentials.UserCredentials;
     * The identifier of the associated sharing profile.
     */
    private String sharingProfileIdentifier;

    /**
        this.connectionIdentifier     = activeConnectionRecord.getConnectionIdentifier();
        this.sharingProfileIdentifier = activeConnectionRecord.getSharingProfileIdentifier();
        this.identifier               = activeConnectionRecord.getUUID().toString();
        this.startDate                = activeConnectionRecord.getStartDate();
    public String getSharingProfileIdentifier() {
        return sharingProfileIdentifier;
    }

    @Override
    public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
        this.sharingProfileIdentifier = sharingProfileIdentifier;
    }

    @Override
    public UserCredentials getSharingCredentials(String identifier)
            throws GuacamoleException {
        throw new GuacamoleSecurityException("Permission denied");
    }

    @Override
import java.util.Set;
    public Set<String> getSharingProfileIdentifiers()
            throws GuacamoleException {
        return Collections.<String>emptySet();
    }

    @Override
    public String getSharingProfileIdentifier() {
        return null;
    }

    @Override
    public String getSharingProfileName() {
        return null;
    }

    @Override
    public String getSharingProfileIdentifier() {
        return null;
    }

    @Override
    public String getSharingProfileName() {
        return null;
    }

    @Override
import org.apache.guacamole.net.auth.simple.SimpleObjectPermissionSet;
    public ObjectPermissionSet getSharingProfilePermissions()
            throws GuacamoleException {
        return new SimpleObjectPermissionSet();
    }

    @Override
import java.util.Collections;
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.net.auth.simple.SimpleDirectory;
    public Directory<SharingProfile> getSharingProfileDirectory()
            throws GuacamoleException {
        return new SimpleDirectory<SharingProfile>();
    }

    @Override
    @Override
    public Collection<Form> getSharingProfileAttributes() {
        return Collections.<Form>emptyList();
    }

import org.apache.guacamole.net.auth.SharingProfile;
    public Directory<SharingProfile> getSharingProfileDirectory()
            throws GuacamoleException {
        return new SimpleDirectory<SharingProfile>();
    }

    @Override
    @Override
    public Collection<Form> getSharingProfileAttributes() {
        return Collections.<Form>emptyList();
    }

        /**
         * An HTTP query parameter which is expected to be embedded in the URL
         * given to a user.
         */
        public static String QUERY_PARAMETER = "QUERY_PARAMETER";

     * The identifier of the associated sharing profile.
     */
    private String sharingProfileIdentifier;

    /**
    public String getSharingProfileIdentifier() {
        return sharingProfileIdentifier;
    }

    @Override
    public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
        this.sharingProfileIdentifier = sharingProfileIdentifier;
    }

    @Override
import java.util.Collections;
import java.util.Set;
import org.apache.guacamole.GuacamoleException;
    @Override
    public Set<String> getSharingProfileIdentifiers()
            throws GuacamoleException {
        return Collections.<String>emptySet();
    }

public interface ActiveConnection extends Identifiable, Shareable<SharingProfile> {

    /**
     * Returns the identifier of the sharing profile being actively used. If
     * the connection is being accessed directly, this will be null.
     *
     * @return
     *     The identifier of the sharing profile being actively used.
     */
    String getSharingProfileIdentifier();

    /**
     * Sets the identifier of the sharing profile being actively used.
     *
     * @param sharingProfileIdentifier
     *     The identifier of the sharing profile being actively used.
     */
    void setSharingProfileIdentifier(String sharingProfileIdentifier);

import java.util.Set;
    /**
     * Returns identifiers of all readable sharing profiles that can be used to
     * join this connection when it is active. The level of access granted to a
     * joining user is dictated by the connection parameters associated with
     * the sharing profile, not necessarily the parameters of the primary
     * connection being joined.
     *
     * @return
     *     A Set of identifiers representing the sharing profiles for this
     *     connection.
     *
     * @throws GuacamoleException
     *     If an error occurs while fetching the sharing profiles for this
     *     connection.
     */
    public Set<String> getSharingProfileIdentifiers() throws GuacamoleException;

     * Returns the identifier of the sharing profile that was used to access the
     * connection associated with this connection record. If the connection was
     * accessed directly (without involving a sharing profile), this will be
     * null.
     *
     * @return
     *     The identifier of the sharing profile used to access the connection
     *     associated with this connection record, or null if the connection
     *     was accessed directly.
     */
    public String getSharingProfileIdentifier();

    /**
     * Returns the name of the sharing profile that was used to access the
     * connection associated with this connection record. If the connection was
     * accessed directly (without involving a sharing profile), this will be
     * null.
     *
     * @return
     *     The name of the sharing profile used to access the connection
     *     associated with this connection record, or null if the connection
     *     was accessed directly.
     */
    public String getSharingProfileName();

    /**
     * Returns all sharing profile permissions given to this user.
     *
     * @return
     *     An ObjectPermissionSet of all sharing profile permissions granted to
     *     this user.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving permissions, or if reading all
     *     permissions is not allowed.
     */
    ObjectPermissionSet getSharingProfilePermissions()
            throws GuacamoleException;

    /**
     * Retrieves a Directory which can be used to view and manipulate
     * sharing profiles and their configurations, but only as allowed by the
     * permissions given to the user.
     *
     * @return
     *     A Directory whose operations are bound by the permissions of the
     *     user.
     *
     * @throws GuacamoleException
     *     If an error occurs while creating the Directory.
     */
    Directory<SharingProfile> getSharingProfileDirectory()
            throws GuacamoleException;

    /**
    /**
     * Retrieves a collection of all attributes applicable to sharing profiles.
     * This collection will contain only those attributes which the current user
     * has general permission to view or modify. If there are no such
     * attributes, this collection will be empty.
     *
     * @return
     *     A collection of all attributes applicable to sharing profile.
     */
    Collection<Form> getSharingProfileAttributes();

         * Create sharing profiles.
         */
        CREATE_SHARING_PROFILE,

        /**
    @Override
    public ObjectPermissionSet getSharingProfilePermissions() {
        return new SimpleObjectPermissionSet();
    }

import org.apache.guacamole.net.auth.SharingProfile;
    public Directory<SharingProfile> getSharingProfileDirectory()
            throws GuacamoleException {
        return new SimpleDirectory<SharingProfile>();
    }

    @Override
    @Override
    public Collection<Form> getSharingProfileAttributes() {
        return Collections.<Form>emptyList();
    }

import org.apache.guacamole.tunnel.UserTunnel;
    private final Map<String, UserTunnel> tunnels =
            new ConcurrentHashMap<String, UserTunnel>();
    public Map<String, UserTunnel> getTunnels() {
    public void addTunnel(UserTunnel tunnel) {
import org.apache.guacamole.rest.sharingprofile.SharingProfileModule;
import org.apache.guacamole.rest.tunnel.TunnelCollectionResourceFactory;
import org.apache.guacamole.rest.tunnel.TunnelResourceFactory;
        install(new FactoryModuleBuilder().build(TunnelCollectionResourceFactory.class));
        install(new FactoryModuleBuilder().build(TunnelResourceFactory.class));
        install(new SharingProfileModule());
import com.google.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.Connection;
import org.apache.guacamole.rest.connection.APIConnection;
import org.apache.guacamole.rest.directory.DirectoryResourceFactory;
     * The UserContext associated with the Directory which contains the
     * Connection exposed by this resource.
     */
    private final UserContext userContext;

    /**
     * The ActiveConnection exposed by this ActiveConnectionResource.
     */
    private final ActiveConnection activeConnection;

    /**
     * A factory which can be used to create instances of resources representing
     * Connection.
     */
    @Inject
    private DirectoryResourceFactory<Connection, APIConnection>
            connectionDirectoryResourceFactory;

    /**
     * @param activeConnection
            @Assisted ActiveConnection activeConnection,
        super(directory, activeConnection, translator);
        this.userContext = userContext;
        this.activeConnection = activeConnection;
    }

    /**
     * Retrieves a resource representing the Connection object that is being
     * actively used.
     *
     * @return
     *     A resource representing the Connection object that is being actively
     *     used.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the Connection.
     */
    @Path("connection")
    public DirectoryObjectResource<Connection, APIConnection> getConnection()
            throws GuacamoleException {

        // Return the underlying connection as a resource
        return connectionDirectoryResourceFactory
                .create(userContext, userContext.getConnectionDirectory())
                .getObjectResource(activeConnection.getConnectionIdentifier());

    }

    /**
     * Retrieves a set of credentials which can be POSTed by another user to the
     * "/api/tokens" endpoint to obtain access strictly to this connection. The
     * retrieved credentials may be purpose-generated and temporary.
     *
     * @param sharingProfileIdentifier The identifier of the sharing connection
     * defining the semantics of the shared session.
     *
     * @return The set of credentials which should be used to access strictly
     * this connection.
     *
     * @throws GuacamoleException If an error occurs while retrieving the
     * sharing credentials for this connection.
     */
    @GET
    @Path("sharingCredentials/{sharingProfile}")
    public APIUserCredentials getSharingCredentials(
            @PathParam("sharingProfile") String sharingProfileIdentifier)
            throws GuacamoleException {

        // Generate and return sharing credentials for the active connection
        return new APIUserCredentials(activeConnection.getSharingCredentials(sharingProfileIdentifier));

import java.util.Set;
    public Set<String> getSharingProfileIdentifiers() {
        throw new UnsupportedOperationException("Operation not supported.");
    }

    @Override
import com.google.inject.Inject;
import org.apache.guacamole.rest.directory.DirectoryView;
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.rest.directory.DirectoryResource;
import org.apache.guacamole.rest.directory.DirectoryResourceFactory;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
     * A factory which can be used to create instances of resources representing
     * SharingProfiles.
     */
    @Inject
    private DirectoryResourceFactory<SharingProfile, APISharingProfile>
            sharingProfileDirectoryResourceFactory;

    /**
    /**
     * Returns a resource which provides read-only access to the subset of
     * SharingProfiles that the current user can use to share this connection.
     *
     * @return
     *     A resource which provides read-only access to the subset of
     *     SharingProfiles that the current user can use to share this
     *     connection.
     *
     * @throws GuacamoleException
     *     If the SharingProfiles associated with this connection cannot be
     *     retrieved.
     */
    @Path("sharingProfiles")
    public DirectoryResource<SharingProfile, APISharingProfile>
            getSharingProfileDirectoryResource() throws GuacamoleException {

        // Produce subset of all SharingProfiles, containing only those which
        // are associated with this connection
        Directory<SharingProfile> sharingProfiles = new DirectoryView<SharingProfile>(
            userContext.getSharingProfileDirectory(),
            connection.getSharingProfileIdentifiers()
        );

        // Return a new resource which provides access to only those SharingProfiles
        return sharingProfileDirectoryResourceFactory.create(userContext, sharingProfiles);

    }

     * The identifier of the sharing profile associated with this record.
     */
    private final String sharingProfileIdentifier;

    /**
     * The identifier of the sharing profile associated with this record.
     */
    private final String sharingProfileName;

    /**
        this.connectionIdentifier     = record.getConnectionIdentifier();
        this.connectionName           = record.getConnectionName();
        this.sharingProfileIdentifier = record.getSharingProfileIdentifier();
        this.sharingProfileName       = record.getSharingProfileName();
        this.startDate                = record.getStartDate();
        this.endDate                  = record.getEndDate();
        this.remoteHost               = record.getRemoteHost();
        this.username                 = record.getUsername();
        this.active                   = record.isActive();
     * Returns the identifier of the sharing profile associated with this
     * record. If the connection was not being used via a sharing profile, this
     * will be null.
     *
     * @return
     *     The identifier of the sharing profile associated with this record,
     *     or null if no sharing profile was used.
     */
    public String getSharingProfileIdentifier() {
        return sharingProfileIdentifier;
    }

    /**
     * Returns the name of the sharing profile associated with this record. If
     * the connection was not being used via a sharing profile, this will be
     * null.
     *
     * @return
     *     The name of the sharing profile associated with this record, or null
     *     if no sharing profile was used.
     */
    public String getSharingProfileName() {
        return sharingProfileName;
    }

    /**
     * Map of sharing profile ID to the set of granted permissions.
     */
    private Map<String, Set<ObjectPermission.Type>> sharingProfilePermissions =
            new HashMap<String, Set<ObjectPermission.Type>>();

    /**
        addObjectPermissions(sharingProfilePermissions,   user.getSharingProfilePermissions());
     * Returns a map of sharing profile identifiers to the set of permissions
     * granted for that sharing profile. If no permissions are granted to a
     * particular sharing profile, its identifier will not be present as a key
     * in the map. This map is mutable, and changes to this map will affect the
     * permission set directly.
     *
     * @return
     *     A map of sharing profile identifiers to the set of permissions
     *     granted for that sharing profile.
     */
    public Map<String, Set<ObjectPermission.Type>> getSharingProfilePermissions() {
        return sharingProfilePermissions;
    }

    /**
     * Replaces the current map of sharing profile permissions with the given
     * map, which must map each sharing profile identifier to its corresponding
     * set of granted permissions. If a sharing profile has no permissions, its
     * identifier must not be present as a key in the map.
     *
     * @param sharingProfilePermissions
     *     The map which must replace the currently-stored map of permissions.
     */
    public void setSharingProfilePermissions(Map<String, Set<ObjectPermission.Type>> sharingProfilePermissions) {
        this.sharingProfilePermissions = sharingProfilePermissions;
    }

    /**
     * modifies the permissions of a user regarding a specific sharing profile.
     */
    private static final String SHARING_PROFILE_PERMISSION_PATCH_PATH_PREFIX = "/sharingProfilePermissions/";

    /**
     * The prefix of any path within an operation of a JSON patch which
        PermissionSetPatch<ObjectPermission> sharingProfilePermissionPatch   = new PermissionSetPatch<ObjectPermission>();
            // Create sharing profile permission if path has sharing profile prefix
            else if (path.startsWith(SHARING_PROFILE_PERMISSION_PATCH_PATH_PREFIX)) {

                // Get identifier and type from patch operation
                String identifier = path.substring(SHARING_PROFILE_PERMISSION_PATCH_PATH_PREFIX.length());
                ObjectPermission.Type type = ObjectPermission.Type.valueOf(patch.getValue());

                // Create and update corresponding permission
                ObjectPermission permission = new ObjectPermission(type, identifier);
                updatePermissionSet(patch.getOp(), sharingProfilePermissionPatch, permission);

            }

        sharingProfilePermissionPatch.apply(user.getSharingProfilePermissions());
import org.apache.guacamole.rest.tunnel.TunnelCollectionResourceFactory;
     * Factory for creating instances of resources which represent the
     * collection of tunnels within a GuacamoleSession.
     */
    @Inject
    private TunnelCollectionResourceFactory tunnelCollectionResourceFactory;

    /**
        return tunnelCollectionResourceFactory.create(session);
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
     * SharingProfile Directory.
     */
    @Inject
    private DirectoryResourceFactory<SharingProfile, APISharingProfile>
            sharingProfileDirectoryResourceFactory;

    /**
     * Factory for creating DirectoryResources which expose a given
     * Returns a new resource which represents the SharingProfile Directory
     * contained within the UserContext exposed by this UserContextResource.
     *
     * @return
     *     A new resource which represents the SharingProfile Directory
     *     contained within the UserContext exposed by this UserContextResource.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the SharingProfile Directory.
     */
    @Path("sharingProfiles")
    public DirectoryResource<SharingProfile, APISharingProfile>
        getSharingProfileDirectoryResource() throws GuacamoleException {
        return sharingProfileDirectoryResourceFactory.create(userContext,
                userContext.getSharingProfileDirectory());
    }

    /**
import com.google.inject.Inject;
import com.google.inject.assistedinject.Assisted;
import com.google.inject.assistedinject.AssistedInject;
import org.apache.guacamole.tunnel.UserTunnel;
     * Factory for creating instances of resources which represent tunnels.
     */
    @Inject
    private TunnelResourceFactory tunnelResourceFactory;

    /**
    @AssistedInject
    public TunnelCollectionResource(@Assisted GuacamoleSession session) {
        Map<String, UserTunnel> tunnels = session.getTunnels();
        final UserTunnel tunnel = tunnels.get(tunnelUUID);
        return tunnelResourceFactory.create(tunnel);
import com.google.inject.Inject;
import com.google.inject.assistedinject.Assisted;
import com.google.inject.assistedinject.AssistedInject;
import org.apache.guacamole.net.auth.ActiveConnection;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.rest.activeconnection.APIActiveConnection;
import org.apache.guacamole.rest.directory.DirectoryObjectResource;
import org.apache.guacamole.rest.directory.DirectoryObjectResourceFactory;
import org.apache.guacamole.tunnel.UserTunnel;
    private final UserTunnel tunnel;

    /**
     * A factory which can be used to create instances of resources representing
     * ActiveConnections.
     */
    @Inject
    private DirectoryObjectResourceFactory<ActiveConnection, APIActiveConnection>
            activeConnectionResourceFactory;
    @AssistedInject
    public TunnelResource(@Assisted UserTunnel tunnel) {
     * Retrieves a resource representing the ActiveConnection object associated
     * with this tunnel.
     *
     * @return
     *     A resource representing the ActiveConnection object associated with
     *     this tunnel.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the ActiveConnection.
     */
    @Path("activeConnection")
    public DirectoryObjectResource<ActiveConnection, APIActiveConnection>
        getActiveConnection() throws GuacamoleException {

        // Pull the UserContext from the tunnel
        UserContext userContext = tunnel.getUserContext();

        // Return the associated ActiveConnection as a resource
        return activeConnectionResourceFactory.create(userContext,
                userContext.getActiveConnectionDirectory(),
                tunnel.getActiveConnection());

    }

    /**
    public ObjectPermissionSet getSharingProfilePermissions() throws GuacamoleException {
        throw new GuacamoleUnsupportedException("APIUserWrapper does not provide permission access.");
    }

    @Override
     * @param context
     *     The UserContext associated with the user for whom the tunnel is
     *     being created.
     *
            final String authToken, final GuacamoleSession session,
            final UserContext context, final TunnelRequest.Type type,
            final String id) throws GuacamoleException {
        UserTunnel monitoredTunnel = new UserTunnel(context, tunnel) {
            return createAssociatedTunnel(tunnel, authToken, session, userContext, type, id);
import org.apache.guacamole.auth.jdbc.connection.ConnectionParameterMapper;
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionMapper;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileMapper;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileParameterMapper;
        addMapperClass(ConnectionParameterMapper.class);
        addMapperClass(SharingProfileMapper.class);
        addMapperClass(SharingProfileParameterMapper.class);
        addMapperClass(SharingProfilePermissionMapper.class);
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionParameterMapper.java
public interface ConnectionParameterMapper {
    Collection<ConnectionParameterModel> select(@Param("identifier") String identifier);
    int insert(@Param("parameters") Collection<ConnectionParameterModel> parameters);
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionParameterModel.java
public class ConnectionParameterModel {
    private ConnectionParameterMapper parameterMapper;
    private Collection<ConnectionParameterModel> getParameterModels(ModeledConnection connection) {
        Collection<ConnectionParameterModel> parameterModels = new ArrayList<ConnectionParameterModel>(parameters.size());
            ConnectionParameterModel model = new ConnectionParameterModel();
        Collection<ConnectionParameterModel> parameterModels = getParameterModels(connection);
        Collection<ConnectionParameterModel> parameterModels = getParameterModels(object);
            for (ConnectionParameterModel parameter : parameterMapper.select(identifier))
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/sharingprofile/SharingProfileParameterMapper.java
package org.apache.guacamole.auth.jdbc.sharingprofile;
 * Mapper for sharing profile parameter objects.
public interface SharingProfileParameterMapper {
     * Returns a collection of all parameters associated with the sharing
     * profile having the given identifier.
     *     The identifier of the sharing profile whose parameters are to be
     *     A collection of all parameters associated with the sharing profile
     *     such sharing profile exists.
    Collection<SharingProfileParameterModel> select(@Param("identifier") String identifier);
     * new sharing profile parameters.
     *     The sharing profile parameters to insert.
    int insert(@Param("parameters") Collection<SharingProfileParameterModel> parameters);
     * Deletes all parameters associated with the sharing profile having the
     * given identifier.
     *     The identifier of the sharing profile whose parameters should be
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/sharingprofile/SharingProfileParameterModel.java
package org.apache.guacamole.auth.jdbc.sharingprofile;
 * A single parameter name/value pair belonging to a sharing profile.
public class SharingProfileParameterModel {
     * The identifier of the sharing profile associated with this parameter.
    private String sharingProfileIdentifier;
     * Returns the identifier of the sharing profile associated with this
     * parameter.
     *     The identifier of the sharing profile associated with this
     *     parameter.
    public String getSharingProfileIdentifier() {
        return sharingProfileIdentifier;
     * Sets the identifier of the sharing profile associated with this
     * parameter.
     * @param sharingProfileIdentifier
     *     The identifier of the sharing profile to associate with this
     *     parameter.
    public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
        this.sharingProfileIdentifier = sharingProfileIdentifier;
import org.apache.guacamole.auth.jdbc.connection.ConnectionParameterModel;
import org.apache.guacamole.auth.jdbc.connection.ConnectionParameterMapper;
    private ConnectionParameterMapper parameterMapper;
        Collection<ConnectionParameterModel> parameters = parameterMapper.select(connection.getIdentifier());
        for (ConnectionParameterModel parameter : parameters)
 * connection. If the connection was being shared, the sharing profile used to
 * join the connection is included in the record.
     * The identifier of the sharing profile associated with this connection
     * record. If no sharing profile was used, or the sharing profile that was
     * used was deleted, this will be null.
     */
    private String sharingProfileIdentifier;

    /**
     * The name of the sharing profile associated with this connection record.
     * If no sharing profile was used, this will be null. If the sharing profile
     * that was used was deleted, this will still contain the name of the
     * sharing profile at the time that the connection was used.
     */
    private String sharingProfileName;

    /**
     * Returns the identifier of the sharing profile associated with this
     * connection record. If no sharing profile was used, or the sharing profile
     * that was used was deleted, this will be null.
     *
     * @return
     *     The identifier of the sharing profile associated with this connection
     *     record, or null if no sharing profile was used or if the sharing
     *     profile that was used was deleted.
     */
    public String getSharingProfileIdentifier() {
        return sharingProfileIdentifier;
    }

    /**
     * Sets the identifier of the sharing profile associated with this
     * connection record. If no sharing profile was used, this should be null.
     *
     * @param sharingProfileIdentifier
     *     The identifier of the sharing profile associated with this
     *     connection record, or null if no sharing profile was used.
     */
    public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
        this.sharingProfileIdentifier = sharingProfileIdentifier;
    }

    /**
     * Returns the human-readable name of the sharing profile associated with this
     * connection record. If no sharing profile was used, this will be null.
     *
     * @return
     *     The human-readable name of the sharing profile associated with this
     *     connection record, or null if no sharing profile was used.
     */
    public String getSharingProfileName() {
        return sharingProfileName;
    }

    /**
     * Sets the human-readable name of the sharing profile associated with this
     * connection record. If no sharing profile was used, this should be null.
     *
     * @param sharingProfileName
     *     The human-readable name of the sharing profile associated with this
     *     connection record, or null if no sharing profile was used.
     */
    public void setSharingProfileName(String sharingProfileName) {
        this.sharingProfileName = sharingProfileName;
    }

    /**
        return model.getSharingProfileIdentifier();
        return model.getSharingProfileName();
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionService;
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionSet;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileDirectory;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileService;
        bind(ModeledSharingProfile.class);
        bind(SharingProfileDirectory.class);
        bind(SharingProfilePermissionSet.class);
        bind(SharingProfilePermissionService.class);
        bind(SharingProfileService.class);
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileDirectory;
     * Sharing profile directory restricted by the permissions of the user
     * associated with this context.
     */
    @Inject
    private SharingProfileDirectory sharingProfileDirectory;

    /**
        sharingProfileDirectory.init(currentUser);
        return sharingProfileDirectory;
        return ModeledSharingProfile.ATTRIBUTES;
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionService;
     * Service for retrieving sharing profile permissions.
     */
    @Inject
    private SharingProfilePermissionService sharingProfilePermissionService;

    /**
        return sharingProfilePermissionService.getPermissionSet(getCurrentUser(), this);
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileService;
     * Service for managing sharing profiles.
     */
    @Inject
    private SharingProfileService sharingProfileService;

    /**
        return sharingProfileService.getIdentifiersWithin(getCurrentUser(), getIdentifier());
import org.apache.guacamole.auth.jdbc.connection.ConnectionParameterMapper;
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionMapper;
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionService;
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionSet;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileDirectory;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileMapper;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileParameterMapper;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileService;
        addMapperClass(ConnectionParameterMapper.class);
        addMapperClass(SharingProfileMapper.class);
        addMapperClass(SharingProfileParameterMapper.class);
        addMapperClass(SharingProfilePermissionMapper.class);
        bind(ModeledSharingProfile.class);
        bind(SharingProfileDirectory.class);
        bind(SharingProfilePermissionSet.class);
        bind(SharingProfilePermissionService.class);
        bind(SharingProfileService.class);
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionParameterMapper.java
public interface ConnectionParameterMapper {
    Collection<ConnectionParameterModel> select(@Param("identifier") String identifier);
    int insert(@Param("parameters") Collection<ConnectionParameterModel> parameters);
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/connection/ConnectionParameterModel.java
public class ConnectionParameterModel {
 * connection. If the connection was being shared, the sharing profile used to
 * join the connection is included in the record.
     * The identifier of the sharing profile associated with this connection
     * record. If no sharing profile was used, or the sharing profile that was
     * used was deleted, this will be null.
     */
    private String sharingProfileIdentifier;

    /**
     * The name of the sharing profile associated with this connection record.
     * If no sharing profile was used, this will be null. If the sharing profile
     * that was used was deleted, this will still contain the name of the
     * sharing profile at the time that the connection was used.
     */
    private String sharingProfileName;

    /**
     * Returns the identifier of the sharing profile associated with this
     * connection record. If no sharing profile was used, or the sharing profile
     * that was used was deleted, this will be null.
     *
     * @return
     *     The identifier of the sharing profile associated with this connection
     *     record, or null if no sharing profile was used or if the sharing
     *     profile that was used was deleted.
     */
    public String getSharingProfileIdentifier() {
        return sharingProfileIdentifier;
    }

    /**
     * Sets the identifier of the sharing profile associated with this
     * connection record. If no sharing profile was used, this should be null.
     *
     * @param sharingProfileIdentifier
     *     The identifier of the sharing profile associated with this
     *     connection record, or null if no sharing profile was used.
     */
    public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
        this.sharingProfileIdentifier = sharingProfileIdentifier;
    }

    /**
     * Returns the human-readable name of the sharing profile associated with this
     * connection record. If no sharing profile was used, this will be null.
     *
     * @return
     *     The human-readable name of the sharing profile associated with this
     *     connection record, or null if no sharing profile was used.
     */
    public String getSharingProfileName() {
        return sharingProfileName;
    }

    /**
     * Sets the human-readable name of the sharing profile associated with this
     * connection record. If no sharing profile was used, this should be null.
     *
     * @param sharingProfileName
     *     The human-readable name of the sharing profile associated with this
     *     connection record, or null if no sharing profile was used.
     */
    public void setSharingProfileName(String sharingProfileName) {
        this.sharingProfileName = sharingProfileName;
    }

    /**
    private ConnectionParameterMapper parameterMapper;
    private Collection<ConnectionParameterModel> getParameterModels(ModeledConnection connection) {
        Collection<ConnectionParameterModel> parameterModels = new ArrayList<ConnectionParameterModel>(parameters.size());
            ConnectionParameterModel model = new ConnectionParameterModel();
        Collection<ConnectionParameterModel> parameterModels = getParameterModels(connection);
        Collection<ConnectionParameterModel> parameterModels = getParameterModels(object);
            for (ConnectionParameterModel parameter : parameterMapper.select(identifier))
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileService;
     * Service for managing sharing profiles.
     */
    @Inject
    private SharingProfileService sharingProfileService;

    /**
        return sharingProfileService.getIdentifiersWithin(getCurrentUser(), getIdentifier());
        return model.getSharingProfileIdentifier();
        return model.getSharingProfileName();
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/sharingprofile/SharingProfileParameterMapper.java
package org.apache.guacamole.auth.jdbc.sharingprofile;
 * Mapper for sharing profile parameter objects.
public interface SharingProfileParameterMapper {
     * Returns a collection of all parameters associated with the sharing
     * profile having the given identifier.
     *     The identifier of the sharing profile whose parameters are to be
     *     A collection of all parameters associated with the sharing profile
     *     such sharing profile exists.
    Collection<SharingProfileParameterModel> select(@Param("identifier") String identifier);
     * new sharing profile parameters.
     *     The sharing profile parameters to insert.
    int insert(@Param("parameters") Collection<SharingProfileParameterModel> parameters);
     * Deletes all parameters associated with the sharing profile having the
     * given identifier.
     *     The identifier of the sharing profile whose parameters should be
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/sharingprofile/SharingProfileParameterModel.java
package org.apache.guacamole.auth.jdbc.sharingprofile;
 * A single parameter name/value pair belonging to a sharing profile.
public class SharingProfileParameterModel {
     * The identifier of the sharing profile associated with this parameter.
    private String sharingProfileIdentifier;
     * Returns the identifier of the sharing profile associated with this
     * parameter.
     *     The identifier of the sharing profile associated with this
     *     parameter.
    public String getSharingProfileIdentifier() {
        return sharingProfileIdentifier;
     * Sets the identifier of the sharing profile associated with this
     * parameter.
     * @param sharingProfileIdentifier
     *     The identifier of the sharing profile to associate with this
     *     parameter.
    public void setSharingProfileIdentifier(String sharingProfileIdentifier) {
        this.sharingProfileIdentifier = sharingProfileIdentifier;
import org.apache.guacamole.auth.jdbc.connection.ConnectionParameterModel;
import org.apache.guacamole.auth.jdbc.connection.ConnectionParameterMapper;
    private ConnectionParameterMapper parameterMapper;
        Collection<ConnectionParameterModel> parameters = parameterMapper.select(connection.getIdentifier());
        for (ConnectionParameterModel parameter : parameters)
import org.apache.guacamole.auth.jdbc.permission.SharingProfilePermissionService;
     * Service for retrieving sharing profile permissions.
     */
    @Inject
    private SharingProfilePermissionService sharingProfilePermissionService;

    /**
        return sharingProfilePermissionService.getPermissionSet(getCurrentUser(), this);
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileDirectory;
     * Sharing profile directory restricted by the permissions of the user
     * associated with this context.
     */
    @Inject
    private SharingProfileDirectory sharingProfileDirectory;

    /**
        sharingProfileDirectory.init(currentUser);
        return sharingProfileDirectory;
        return ModeledSharingProfile.ATTRIBUTES;
import com.google.inject.Scopes;
import org.apache.guacamole.auth.jdbc.sharing.SecureRandomShareKeyGenerator;
import org.apache.guacamole.auth.jdbc.sharing.ShareKeyGenerator;
        bind(ShareKeyGenerator.class).to(SecureRandomShareKeyGenerator.class).in(Scopes.SINGLETON);
public class AuthenticatedUser extends RemoteAuthenticatedUser {
        super(authenticationProvider, credentials);
import org.apache.guacamole.auth.jdbc.sharing.HashSharedConnectionMap;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionMap;
        bind(SharedConnectionMap.class).to(HashSharedConnectionMap.class).in(Scopes.SINGLETON);
import org.apache.guacamole.auth.jdbc.sharing.ConnectionSharingService;
        bind(ConnectionSharingService.class);
import com.google.inject.Inject;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.sharing.ConnectionSharingService;
     * Service for managing shared connections.
     */
    @Inject
    private ConnectionSharingService sharingService;

    /**
     * The connection being actively used or shared.
    private ModeledConnection connection;
        this.connection               = activeConnectionRecord.getConnection();

    /**
     * Returns the connection being actively used. If this active connection is
     * not the primary connection, this will be the connection being actively
     * shared.
     *
     * @return
     *     The connection being actively used.
     */
    public ModeledConnection getConnection() {
        return connection;
    }

        return connection.getIdentifier();
        throw new UnsupportedOperationException("The connection identifier of "
                 "TrackedActiveConnection is inherited from the underlying "
                 "connection.");
        return sharingService.generateTemporaryCredentials(getCurrentUser(),
                this, identifier);
import org.apache.guacamole.auth.jdbc.sharing.ConnectionSharingService;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUser;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUserContext;
import org.apache.guacamole.net.auth.AuthenticatedUser;
     * Provider for retrieving SharedConnectionUserContext instances.
     */
    @Inject
    private Provider<SharedConnectionUserContext> sharedUserContextProvider;

    /**
     * Service for sharing active connections.
     */
    @Inject
    private ConnectionSharingService sharingService;

    /**
        AuthenticatedUser user;

        // Check whether user is authenticating with a valid sharing key
        user = sharingService.retrieveSharedConnectionUser(authenticationProvider, credentials);
        if (user != null)
            return user;

        user = userService.retrieveAuthenticatedUser(authenticationProvider, credentials);
    public org.apache.guacamole.net.auth.UserContext getUserContext(
            AuthenticatedUser authenticatedUser) throws GuacamoleException {

        // Produce sharing-specific user context if this is the user of a shared connection
        if (authenticatedUser instanceof SharedConnectionUser) {
            SharedConnectionUserContext context = sharedUserContextProvider.get();
            context.init((SharedConnectionUser) authenticatedUser);
            return context;
        }
     * The connection ID of the connection as determined by guacd, not to be
     * confused with the connection identifier determined by the database. This
     * is the ID that must be supplied to guacd if joining this connection.
     */
    private String connectionID;

    /**
        this.connectionID             = activeConnectionRecord.getConnectionID();
    /**
     * Returns the connection ID of the in-progress connection as determined by
     * guacd, not to be confused with the connection identifier determined by
     * the database. This is the ID that must be supplied to guacd if joining
     * this connection.
     *
     * @return
     *     The ID of the in-progress connection, as determined by guacd.
     */
    public String getConnectionID() {
        return connectionID;
    }

import com.google.inject.Inject;
import org.apache.guacamole.auth.jdbc.tunnel.GuacamoleTunnelService;
     * Service for establishing tunnels to Guacamole connections.
     */
    @Inject
    private GuacamoleTunnelService tunnelService;

    /**
        return tunnelService.getGuacamoleTunnel(user, activeConnection,
                sharingProfile, info);
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUser;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileParameterMapper;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileParameterModel;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
    private ConnectionParameterMapper connectionParameterMapper;

    /**
     * Mapper for accessing sharing profile parameters.
     */
    @Inject
    private SharingProfileParameterMapper sharingProfileParameterMapper;
    protected abstract ModeledConnection acquire(RemoteAuthenticatedUser user,
    protected abstract void release(RemoteAuthenticatedUser user,
    protected abstract void acquire(RemoteAuthenticatedUser user,
    protected abstract void release(RemoteAuthenticatedUser user,
    private GuacamoleConfiguration getGuacamoleConfiguration(RemoteAuthenticatedUser user,
        Collection<ConnectionParameterModel> parameters = connectionParameterMapper.select(connection.getIdentifier());
     * Returns a guacamole configuration which joins the active connection
     * having the given ID, using the provided sharing profile to restrict the
     * access provided to the user accessing the shared connection. If tokens
     * are used in the connection parameter values of the sharing profile,
     * credentials from the given user will be substituted appropriately.
     *
     * @param user
     *     The user whose credentials should be used if necessary.
     *
     * @param sharingProfile
     *     The sharing profile whose associated parameters dictate the level
     *     of access granted to the user joining the connection.
     *
     * @param connectionID
     *     The ID of the connection being joined, as provided by guacd when the
     *     original connection was established, or null if a new connection
     *     should be created instead.
     *
     * @return
     *     A GuacamoleConfiguration containing the protocol and parameters from
     *     the given connection.
     */
    private GuacamoleConfiguration getGuacamoleConfiguration(RemoteAuthenticatedUser user,
            ModeledSharingProfile sharingProfile, String connectionID) {

        // Generate configuration from available data
        GuacamoleConfiguration config = new GuacamoleConfiguration();
        config.setConnectionID(connectionID);

        // Set parameters from associated data
        Collection<SharingProfileParameterModel> parameters = sharingProfileParameterMapper.select(sharingProfile.getIdentifier());
        for (SharingProfileParameterModel parameter : parameters)
            config.setParameter(parameter.getName(), parameter.getValue());

        // Build token filter containing credential tokens
        TokenFilter tokenFilter = new TokenFilter();
        StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());

        // Filter the configuration
        tokenFilter.filterValues(config.getParameters());

        return config;

    }

    /**
        recordModel.setUsername(record.getUsername());
        recordModel.setConnectionIdentifier(record.getConnectionIdentifier());
        recordModel.setConnectionName(record.getConnectionName());
        recordModel.setSharingProfileIdentifier(record.getSharingProfileIdentifier());
        recordModel.setSharingProfileName(record.getSharingProfileName());
            // Remove underlying tunnel from list of active tunnels

            // Get original user
            RemoteAuthenticatedUser user = activeConnection.getUser();

            // Release the associated connection if this is the primary connection
            if (activeConnection.isPrimaryConnection()) {

                // Get connection and associated identifiers
                ModeledConnection connection = activeConnection.getConnection();
                String identifier = connection.getIdentifier();
                String parentIdentifier = connection.getParentIdentifier();

                // Release connection
                activeConnections.remove(identifier, activeConnection);
                activeConnectionGroups.remove(parentIdentifier, activeConnection);
                release(user, connection);

            }
            GuacamoleClientInformation info) throws GuacamoleException {
            GuacamoleConfiguration config;

            // Pull configuration directly from the connection if we are not
            // joining an active connection
            if (activeConnection.isPrimaryConnection()) {
                ModeledConnection connection = activeConnection.getConnection();
                activeConnections.put(connection.getIdentifier(), activeConnection);
                activeConnectionGroups.put(connection.getParentIdentifier(), activeConnection);
                config = getGuacamoleConfiguration(activeConnection.getUser(), connection);
            }

            // If we ARE joining an active connection, generate a configuration
            // which does so
            else {

                // Verify that the connection ID is known
                String connectionID = activeConnection.getConnectionID();
                if (connectionID == null)
                    throw new GuacamoleResourceNotFoundException("No existing connection to be joined.");

                // Build configuration from the sharing profile and the ID of
                // the connection being joined
                config = getGuacamoleConfiguration(activeConnection.getUser(),
                        activeConnection.getSharingProfile(), connectionID);

            }

            ConfiguredGuacamoleSocket socket = new ConfiguredGuacamoleSocket(
                getUnconfiguredGuacamoleSocket(cleanupTask), config, info);
    @Override
    @Transactional
    public GuacamoleTunnel getGuacamoleTunnel(SharedConnectionUser user,
            TrackedActiveConnection activeConnection,
            ModeledSharingProfile sharingProfile,
            GuacamoleClientInformation info)
            throws GuacamoleException {

        // Connect to shared connection
        return assignGuacamoleTunnel(new ActiveConnectionRecord(user, activeConnection, sharingProfile), info);

    }

import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
import org.apache.guacamole.protocol.ConfiguredGuacamoleSocket;
    private final RemoteAuthenticatedUser user;
     * The sharing profile that was used to access the connection associated
     * with this connection record. If the connection was accessed directly
     * (without involving a sharing profile), this will be null.
     */
    private final ModeledSharingProfile sharingProfile;

    /**

    /**
     * The connection ID of the connection as determined by guacd, not to be
     * confused with the connection identifier determined by the database. This
     * is the ID that must be supplied to guacd if joining this connection.
     */
    private String connectionID;

    /**
     * Creates a new connection record associated with the given user,
     * connection, balancing connection group, and sharing profile. The given
     * balancing connection group MUST be the connection group from which the
     * given connection was chosen, and the given sharing profile MUST be the
     * sharing profile that was used to share access to the given connection.
     * The start date of this connection record will be the time of its
     * creation.
     *
     * @param user
     *     The user that connected to the connection associated with this
     *     connection record.
     *
     * @param balancingGroup
     *     The balancing group from which the given connection was chosen, or
     *     null if no balancing group is being used.
     *
     * @param connection
     *     The connection to associate with this connection record.
     *
     * @param sharingProfile
     *     The sharing profile that was used to share access to the given
     *     connection, or null if no sharing profile was used.
     */
    private ActiveConnectionRecord(RemoteAuthenticatedUser user,
            ModeledConnectionGroup balancingGroup,
            ModeledConnection connection,
            ModeledSharingProfile sharingProfile) {
        this.user = user;
        this.balancingGroup = balancingGroup;
        this.connection = connection;
        this.sharingProfile = sharingProfile;
    }
   
    public ActiveConnectionRecord(RemoteAuthenticatedUser user,
        this(user, balancingGroup, connection, null);
    public ActiveConnectionRecord(RemoteAuthenticatedUser user,
     * Creates a new connection record associated with the given user, active
     * connection, and sharing profile. The given sharing profile MUST be the
     * sharing profile that was used to share access to the given connection.
     * The start date of this connection record will be the time of its
     * creation.
     *
     * @param user
     *     The user that connected to the connection associated with this
     *     connection record.
     *
     * @param activeConnection
     *     The active connection which is being shared to the given user via
     *     the given sharing profile.
     *
     * @param sharingProfile
     *     The sharing profile that was used to share access to the given
     *     connection. As a record created in this way always refers to a
     *     shared connection, this value may NOT be null.
     */
    public ActiveConnectionRecord(RemoteAuthenticatedUser user,
            TrackedActiveConnection activeConnection,
            ModeledSharingProfile sharingProfile) {
        this(user, null, activeConnection.getConnection(), sharingProfile);
        this.connectionID = activeConnection.getConnectionID();
    }

    /**
    public RemoteAuthenticatedUser getUser() {
     * Returns the sharing profile that was used to access the connection
     * associated with this connection record. If the connection was accessed
     * directly (without involving a sharing profile), this will be null.
     *
     * @return
     *     The sharing profile that was used to access the connection
     *     associated with this connection record, or null if the connection
     *     was accessed directly.
     */
    public ModeledSharingProfile getSharingProfile() {
        return sharingProfile;
    }

    /**
    /**
     * Returns whether this connection record is associated with a connection
     * being used directly, in the absence of a sharing profile. If a connection
     * is shared, this will continue to return false for the connection being
     * shared, but will return true for the connections which join that
     * connection.
     *
     * @return
     *     true if the connection associated with this connection record is
     *     being used directly, false otherwise.
     */
    public boolean isPrimaryConnection() {
        return sharingProfile == null;
    }


        // Return sharing profile identifier if known
        if (sharingProfile != null)
            return sharingProfile.getIdentifier();

        // No associated sharing profile


        // Return sharing profile name if known
        if (sharingProfile != null)
            return sharingProfile.getName();

        // No associated sharing profile

        return user.getIdentifier();
     *     The ConfiguredGuacamoleSocket to use to create the tunnel associated
     *     with this connection record.
    public GuacamoleTunnel assignGuacamoleTunnel(final ConfiguredGuacamoleSocket socket) {
        // Store connection ID of the primary connection only
        if (isPrimaryConnection())
            this.connectionID = socket.getConnectionID();


    /**
     * Returns the connection ID of the in-progress connection as determined by
     * guacd, not to be confused with the connection identifier determined by
     * the database. This is the ID that must be supplied to guacd if joining
     * this connection. If the in-progress connection is joining another
     * connection, this will be the ID of the connection being joined, NOT the
     * ID of the connection directly represented by this record.
     *
     * @return
     *     The ID of the in-progress connection, as determined by guacd.
     */
    public String getConnectionID() {
        return connectionID;
    }

import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUser;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
    /**
     * Creates a socket for the given user which joins the given active
     * connection. The given client information will be passed to guacd when
     * the connection is established. This function will apply any concurrent
     * usage rules in effect, but will NOT test object- or system-level
     * permissions.
     *
     * @param user
     *     The user for whom the connection is being established.
     *
     * @param activeConnection
     *     The active connection the user is joining.
     *
     * @param sharingProfile
     *     The sharing profile whose associated parameters dictate the level
     *     of access granted to the user joining the connection.
     *
     * @param info
     *     Information describing the Guacamole client connecting to the given
     *     connection.
     *
     * @return
     *     A new GuacamoleTunnel which is configured and connected to the given
     *     active connection.
     *
     * @throws GuacamoleException
     *     If the connection cannot be established due to concurrent usage
     *     rules.
     */
    GuacamoleTunnel getGuacamoleTunnel(SharedConnectionUser user,
            TrackedActiveConnection activeConnection,
            ModeledSharingProfile sharingProfile,
            GuacamoleClientInformation info)
            throws GuacamoleException;

import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
    protected ModeledConnection acquire(RemoteAuthenticatedUser user,
        String username = user.getIdentifier();
    protected void release(RemoteAuthenticatedUser user, ModeledConnection connection) {
        activeSeats.remove(new Seat(user.getIdentifier(), connection.getIdentifier()));
    protected void acquire(RemoteAuthenticatedUser user,
        String username = user.getIdentifier();
    protected void release(RemoteAuthenticatedUser user,
        activeGroupSeats.remove(new Seat(user.getIdentifier(), connectionGroup.getIdentifier()));
import org.apache.guacamole.GuacamoleSecurityException;
        // Verify that this profile is indeed a sharing profile for the
        // requested connection
        String connectionIdentifier = activeConnection.getConnectionIdentifier();
        if (sharingProfile == null || !sharingProfile.getPrimaryConnectionIdentifier().equals(connectionIdentifier))
            throw new GuacamoleSecurityException("Permission denied.");

                if (!activeConnection.isActive() || connectionID == null)
 * null. The associated start date will be the time of this objects creation.
        return tunnel != null && tunnel.isOpen();
import com.google.inject.Scopes;
import org.apache.guacamole.auth.jdbc.sharing.ConnectionSharingService;
import org.apache.guacamole.auth.jdbc.sharing.HashSharedConnectionMap;
import org.apache.guacamole.auth.jdbc.sharing.SecureRandomShareKeyGenerator;
import org.apache.guacamole.auth.jdbc.sharing.ShareKeyGenerator;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionMap;
        bind(ConnectionSharingService.class);
        bind(SharedConnectionMap.class).to(HashSharedConnectionMap.class).in(Scopes.SINGLETON);
        bind(ShareKeyGenerator.class).to(SecureRandomShareKeyGenerator.class).in(Scopes.SINGLETON);
import com.google.inject.Inject;
import org.apache.guacamole.auth.jdbc.connection.ModeledConnection;
import org.apache.guacamole.auth.jdbc.sharing.ConnectionSharingService;
     * Service for managing shared connections.
     */
    @Inject
    private ConnectionSharingService sharingService;

    /**
     * The connection being actively used or shared.
    private ModeledConnection connection;
     * The connection ID of the connection as determined by guacd, not to be
     * confused with the connection identifier determined by the database. This
     * is the ID that must be supplied to guacd if joining this connection.
     */
    private String connectionID;

    /**
        this.connection               = activeConnectionRecord.getConnection();
        this.connectionID             = activeConnectionRecord.getConnectionID();

    /**
     * Returns the connection being actively used. If this active connection is
     * not the primary connection, this will be the connection being actively
     * shared.
     *
     * @return
     *     The connection being actively used.
     */
    public ModeledConnection getConnection() {
        return connection;
    }

    /**
     * Returns the connection ID of the in-progress connection as determined by
     * guacd, not to be confused with the connection identifier determined by
     * the database. This is the ID that must be supplied to guacd if joining
     * this connection.
     *
     * @return
     *     The ID of the in-progress connection, as determined by guacd.
     */
    public String getConnectionID() {
        return connectionID;
    }

        return connection.getIdentifier();
        throw new UnsupportedOperationException("The connection identifier of "
                 "TrackedActiveConnection is inherited from the underlying "
                 "connection.");
        return sharingService.generateTemporaryCredentials(getCurrentUser(),
                this, identifier);
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUser;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileParameterMapper;
import org.apache.guacamole.auth.jdbc.sharingprofile.SharingProfileParameterModel;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
    private ConnectionParameterMapper connectionParameterMapper;

    /**
     * Mapper for accessing sharing profile parameters.
     */
    @Inject
    private SharingProfileParameterMapper sharingProfileParameterMapper;
    protected abstract ModeledConnection acquire(RemoteAuthenticatedUser user,
    protected abstract void release(RemoteAuthenticatedUser user,
    protected abstract void acquire(RemoteAuthenticatedUser user,
    protected abstract void release(RemoteAuthenticatedUser user,
    private GuacamoleConfiguration getGuacamoleConfiguration(RemoteAuthenticatedUser user,
        Collection<ConnectionParameterModel> parameters = connectionParameterMapper.select(connection.getIdentifier());
     * Returns a guacamole configuration which joins the active connection
     * having the given ID, using the provided sharing profile to restrict the
     * access provided to the user accessing the shared connection. If tokens
     * are used in the connection parameter values of the sharing profile,
     * credentials from the given user will be substituted appropriately.
     *
     * @param user
     *     The user whose credentials should be used if necessary.
     *
     * @param sharingProfile
     *     The sharing profile whose associated parameters dictate the level
     *     of access granted to the user joining the connection.
     *
     * @param connectionID
     *     The ID of the connection being joined, as provided by guacd when the
     *     original connection was established, or null if a new connection
     *     should be created instead.
     *
     * @return
     *     A GuacamoleConfiguration containing the protocol and parameters from
     *     the given connection.
     */
    private GuacamoleConfiguration getGuacamoleConfiguration(RemoteAuthenticatedUser user,
            ModeledSharingProfile sharingProfile, String connectionID) {

        // Generate configuration from available data
        GuacamoleConfiguration config = new GuacamoleConfiguration();
        config.setConnectionID(connectionID);

        // Set parameters from associated data
        Collection<SharingProfileParameterModel> parameters = sharingProfileParameterMapper.select(sharingProfile.getIdentifier());
        for (SharingProfileParameterModel parameter : parameters)
            config.setParameter(parameter.getName(), parameter.getValue());

        // Build token filter containing credential tokens
        TokenFilter tokenFilter = new TokenFilter();
        StandardTokens.addStandardTokens(tokenFilter, user.getCredentials());

        // Filter the configuration
        tokenFilter.filterValues(config.getParameters());

        return config;

    }

    /**
        recordModel.setUsername(record.getUsername());
        recordModel.setConnectionIdentifier(record.getConnectionIdentifier());
        recordModel.setConnectionName(record.getConnectionName());
        recordModel.setSharingProfileIdentifier(record.getSharingProfileIdentifier());
        recordModel.setSharingProfileName(record.getSharingProfileName());
            // Remove underlying tunnel from list of active tunnels

            // Get original user
            RemoteAuthenticatedUser user = activeConnection.getUser();

            // Release the associated connection if this is the primary connection
            if (activeConnection.isPrimaryConnection()) {

                // Get connection and associated identifiers
                ModeledConnection connection = activeConnection.getConnection();
                String identifier = connection.getIdentifier();
                String parentIdentifier = connection.getParentIdentifier();

                // Release connection
                activeConnections.remove(identifier, activeConnection);
                activeConnectionGroups.remove(parentIdentifier, activeConnection);
                release(user, connection);

            }
            GuacamoleClientInformation info) throws GuacamoleException {
            GuacamoleConfiguration config;

            // Pull configuration directly from the connection if we are not
            // joining an active connection
            if (activeConnection.isPrimaryConnection()) {
                ModeledConnection connection = activeConnection.getConnection();
                activeConnections.put(connection.getIdentifier(), activeConnection);
                activeConnectionGroups.put(connection.getParentIdentifier(), activeConnection);
                config = getGuacamoleConfiguration(activeConnection.getUser(), connection);
            }

            // If we ARE joining an active connection, generate a configuration
            // which does so
            else {

                // Verify that the connection ID is known
                String connectionID = activeConnection.getConnectionID();
                if (!activeConnection.isActive() || connectionID == null)
                    throw new GuacamoleResourceNotFoundException("No existing connection to be joined.");

                // Build configuration from the sharing profile and the ID of
                // the connection being joined
                config = getGuacamoleConfiguration(activeConnection.getUser(),
                        activeConnection.getSharingProfile(), connectionID);

            }

            ConfiguredGuacamoleSocket socket = new ConfiguredGuacamoleSocket(
                getUnconfiguredGuacamoleSocket(cleanupTask), config, info);
    @Override
    @Transactional
    public GuacamoleTunnel getGuacamoleTunnel(SharedConnectionUser user,
            TrackedActiveConnection activeConnection,
            ModeledSharingProfile sharingProfile,
            GuacamoleClientInformation info)
            throws GuacamoleException {

        // Connect to shared connection
        return assignGuacamoleTunnel(new ActiveConnectionRecord(user, activeConnection, sharingProfile), info);

    }

import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
import org.apache.guacamole.protocol.ConfiguredGuacamoleSocket;
 * null. The associated start date will be the time of this objects creation.
    private final RemoteAuthenticatedUser user;
     * The sharing profile that was used to access the connection associated
     * with this connection record. If the connection was accessed directly
     * (without involving a sharing profile), this will be null.
     */
    private final ModeledSharingProfile sharingProfile;

    /**

    /**
     * The connection ID of the connection as determined by guacd, not to be
     * confused with the connection identifier determined by the database. This
     * is the ID that must be supplied to guacd if joining this connection.
     */
    private String connectionID;

    /**
     * Creates a new connection record associated with the given user,
     * connection, balancing connection group, and sharing profile. The given
     * balancing connection group MUST be the connection group from which the
     * given connection was chosen, and the given sharing profile MUST be the
     * sharing profile that was used to share access to the given connection.
     * The start date of this connection record will be the time of its
     * creation.
     *
     * @param user
     *     The user that connected to the connection associated with this
     *     connection record.
     *
     * @param balancingGroup
     *     The balancing group from which the given connection was chosen, or
     *     null if no balancing group is being used.
     *
     * @param connection
     *     The connection to associate with this connection record.
     *
     * @param sharingProfile
     *     The sharing profile that was used to share access to the given
     *     connection, or null if no sharing profile was used.
     */
    private ActiveConnectionRecord(RemoteAuthenticatedUser user,
            ModeledConnectionGroup balancingGroup,
            ModeledConnection connection,
            ModeledSharingProfile sharingProfile) {
        this.user = user;
        this.balancingGroup = balancingGroup;
        this.connection = connection;
        this.sharingProfile = sharingProfile;
    }
   
    public ActiveConnectionRecord(RemoteAuthenticatedUser user,
        this(user, balancingGroup, connection, null);
    public ActiveConnectionRecord(RemoteAuthenticatedUser user,
     * Creates a new connection record associated with the given user, active
     * connection, and sharing profile. The given sharing profile MUST be the
     * sharing profile that was used to share access to the given connection.
     * The start date of this connection record will be the time of its
     * creation.
     *
     * @param user
     *     The user that connected to the connection associated with this
     *     connection record.
     *
     * @param activeConnection
     *     The active connection which is being shared to the given user via
     *     the given sharing profile.
     *
     * @param sharingProfile
     *     The sharing profile that was used to share access to the given
     *     connection. As a record created in this way always refers to a
     *     shared connection, this value may NOT be null.
     */
    public ActiveConnectionRecord(RemoteAuthenticatedUser user,
            TrackedActiveConnection activeConnection,
            ModeledSharingProfile sharingProfile) {
        this(user, null, activeConnection.getConnection(), sharingProfile);
        this.connectionID = activeConnection.getConnectionID();
    }

    /**
    public RemoteAuthenticatedUser getUser() {
     * Returns the sharing profile that was used to access the connection
     * associated with this connection record. If the connection was accessed
     * directly (without involving a sharing profile), this will be null.
     *
     * @return
     *     The sharing profile that was used to access the connection
     *     associated with this connection record, or null if the connection
     *     was accessed directly.
     */
    public ModeledSharingProfile getSharingProfile() {
        return sharingProfile;
    }

    /**
    /**
     * Returns whether this connection record is associated with a connection
     * being used directly, in the absence of a sharing profile. If a connection
     * is shared, this will continue to return false for the connection being
     * shared, but will return true for the connections which join that
     * connection.
     *
     * @return
     *     true if the connection associated with this connection record is
     *     being used directly, false otherwise.
     */
    public boolean isPrimaryConnection() {
        return sharingProfile == null;
    }


        // Return sharing profile identifier if known
        if (sharingProfile != null)
            return sharingProfile.getIdentifier();

        // No associated sharing profile


        // Return sharing profile name if known
        if (sharingProfile != null)
            return sharingProfile.getName();

        // No associated sharing profile

        return user.getIdentifier();
        return tunnel != null && tunnel.isOpen();
     *     The ConfiguredGuacamoleSocket to use to create the tunnel associated
     *     with this connection record.
    public GuacamoleTunnel assignGuacamoleTunnel(final ConfiguredGuacamoleSocket socket) {
        // Store connection ID of the primary connection only
        if (isPrimaryConnection())
            this.connectionID = socket.getConnectionID();


    /**
     * Returns the connection ID of the in-progress connection as determined by
     * guacd, not to be confused with the connection identifier determined by
     * the database. This is the ID that must be supplied to guacd if joining
     * this connection. If the in-progress connection is joining another
     * connection, this will be the ID of the connection being joined, NOT the
     * ID of the connection directly represented by this record.
     *
     * @return
     *     The ID of the in-progress connection, as determined by guacd.
     */
    public String getConnectionID() {
        return connectionID;
    }

import org.apache.guacamole.auth.jdbc.activeconnection.TrackedActiveConnection;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUser;
import org.apache.guacamole.auth.jdbc.sharingprofile.ModeledSharingProfile;
    /**
     * Creates a socket for the given user which joins the given active
     * connection. The given client information will be passed to guacd when
     * the connection is established. This function will apply any concurrent
     * usage rules in effect, but will NOT test object- or system-level
     * permissions.
     *
     * @param user
     *     The user for whom the connection is being established.
     *
     * @param activeConnection
     *     The active connection the user is joining.
     *
     * @param sharingProfile
     *     The sharing profile whose associated parameters dictate the level
     *     of access granted to the user joining the connection.
     *
     * @param info
     *     Information describing the Guacamole client connecting to the given
     *     connection.
     *
     * @return
     *     A new GuacamoleTunnel which is configured and connected to the given
     *     active connection.
     *
     * @throws GuacamoleException
     *     If the connection cannot be established due to concurrent usage
     *     rules.
     */
    GuacamoleTunnel getGuacamoleTunnel(SharedConnectionUser user,
            TrackedActiveConnection activeConnection,
            ModeledSharingProfile sharingProfile,
            GuacamoleClientInformation info)
            throws GuacamoleException;

import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
    protected ModeledConnection acquire(RemoteAuthenticatedUser user,
        String username = user.getIdentifier();
    protected void release(RemoteAuthenticatedUser user, ModeledConnection connection) {
        activeSeats.remove(new Seat(user.getIdentifier(), connection.getIdentifier()));
    protected void acquire(RemoteAuthenticatedUser user,
        String username = user.getIdentifier();
    protected void release(RemoteAuthenticatedUser user,
        activeGroupSeats.remove(new Seat(user.getIdentifier(), connectionGroup.getIdentifier()));
public class AuthenticatedUser extends RemoteAuthenticatedUser {
        super(authenticationProvider, credentials);
import org.apache.guacamole.auth.jdbc.sharing.ConnectionSharingService;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUser;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionUserContext;
import org.apache.guacamole.net.auth.AuthenticatedUser;
     * Provider for retrieving SharedConnectionUserContext instances.
     */
    @Inject
    private Provider<SharedConnectionUserContext> sharedUserContextProvider;

    /**
     * Service for sharing active connections.
     */
    @Inject
    private ConnectionSharingService sharingService;

    /**
        AuthenticatedUser user;

        // Check whether user is authenticating with a valid sharing key
        user = sharingService.retrieveSharedConnectionUser(authenticationProvider, credentials);
        if (user != null)
            return user;

        user = userService.retrieveAuthenticatedUser(authenticationProvider, credentials);
    public org.apache.guacamole.net.auth.UserContext getUserContext(
            AuthenticatedUser authenticatedUser) throws GuacamoleException {

        // Produce sharing-specific user context if this is the user of a shared connection
        if (authenticatedUser instanceof SharedConnectionUser) {
            SharedConnectionUserContext context = sharedUserContextProvider.get();
            context.init((SharedConnectionUser) authenticatedUser);
            return context;
        }
        connectionMap.add(new SharedConnectionDefinition(activeConnection,
                sharingProfile, key));
    public void add(SharedConnectionDefinition definition) {

        // Store definition by share key
        String shareKey = definition.getShareKey();
        connectionMap.put(shareKey, definition);

     * The unique key with which a user may access the shared connection.
     */
    private final String shareKey;

    /**
     *
     * @param shareKey
     *     The unique key with which a user may access the shared connection.
            ModeledSharingProfile sharingProfile, String shareKey) {
        this.shareKey = shareKey;
    /**
     * Returns the unique key with which a user may access the shared
     * connection.
     *
     * @return
     *     The unique key with which a user may access the shared connection.
     */
    public String getShareKey() {
        return shareKey;
    }

     * Stores the given SharedConnectionDefinition by its associated share key,
     *     shared.
    public void add(SharedConnectionDefinition definition);
     * The SharedConnectionDefinition dictating the connection being shared and
     * any associated restrictions.
    private SharedConnectionDefinition definition;
        this.definition = definition;
        return definition.getSharingProfile().getName();

        // Pull the connection being shared
        Connection primaryConnection = definition.getActiveConnection().getConnection();

        // Construct a skeletal configuration that exposes only the protocol in use
        config.setProtocol(primaryConnection.getConfiguration().getProtocol());

        return tunnelService.getGuacamoleTunnel(user, definition, info);
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionDefinition;
                if (connectionID == null)
            SharedConnectionDefinition definition,
        return assignGuacamoleTunnel(
                new ActiveConnectionRecord(user, definition.getActiveConnection(),
                        definition.getSharingProfile()), info);
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionDefinition;
     * @param definition
     *     The SharedConnectionDefinition dictating the connection being shared
     *     and any associated restrictions.
            SharedConnectionDefinition definition,
     * The actual connection record from which this ActiveConnection derives its
     * data.
     */
    private ActiveConnectionRecord connectionRecord;

    /**
        this.connectionRecord = activeConnectionRecord;
                connectionRecord, identifier);
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
            ActiveConnectionRecord activeConnection,
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
    private final ActiveConnectionRecord activeConnection;
    public SharedConnectionDefinition(ActiveConnectionRecord activeConnection,
     * Returns the ActiveConnectionRecord of the actual in-progress connection
     *     The ActiveConnectionRecord being shared.
    public ActiveConnectionRecord getActiveConnection() {
            ActiveConnectionRecord activeConnection,
        // Ensure the share key is properly invalidated when the original
        // connection is closed
        activeConnection.registerShareKey(key);

        SharedConnectionDefinition definition = connectionMap.remove(key);
        if (definition == null)
            return null;

        // Close all associated tunnels and disallow further sharing
        definition.invalidate();
        return definition;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private final Logger logger = LoggerFactory.getLogger(SharedConnectionDefinition.class);

    /**
     * Manager which tracks all tunnels associated with this shared connection
     * definition. All tunnels registered with this manager will be
     * automatically closed once the manager is invalidated.
     */
    private final SharedObjectManager<GuacamoleTunnel> tunnels =
            new SharedObjectManager<GuacamoleTunnel>() {

        @Override
        protected void cleanup(GuacamoleTunnel tunnel) {

            try {
                tunnel.close();
            }
            catch (GuacamoleException e) {
                logger.debug("Unable to close tunnel of shared connection.", e);
            }

        }

    };

    /**
    /**
     * Registers the given tunnel with this SharedConnectionDefinition, such
     * that the tunnel is automatically closed when this
     * SharedConnectionDefinition is invalidated. For shared connections to be
     * properly closed when the associated share key ceases being valid, the
     * tunnels resulting from the use of the share key MUST be registered to the
     * SharedConnectionDefinition associated with that share key.
     *
     * @param tunnel
     *     The tunnel which should automatically be closed when this
     *     SharedConnectionDefinition is invalidated.
     */
    public void registerTunnel(GuacamoleTunnel tunnel) {
        tunnels.register(tunnel);
    }

    /**
     * Invalidates this SharedConnectionDefinition and closes all registered
     * tunnels. If any additional tunnels are registered after this function is
     * invoked, those tunnels will be immediately closed. This function MUST be
     * invoked when the share key associated with this
     * SharedConnectionDefinition will no longer be used.
     */
    public void invalidate() {
        tunnels.invalidate();
    }

     * Provider for creating active connection records.
     */
    @Inject
    private Provider<ActiveConnectionRecord> activeConnectionRecordProvider;

    /**
            // Connection can no longer be shared
            activeConnection.invalidate();

        // Acquire access to single connection

        // Connect only if the connection was successfully acquired
        ActiveConnectionRecord connectionRecord = activeConnectionRecordProvider.get();
        connectionRecord.init(user, connection);
        return assignGuacamoleTunnel(connectionRecord, info);
        ActiveConnectionRecord connectionRecord = activeConnectionRecordProvider.get();
        connectionRecord.init(user, connectionGroup, connection);
        return assignGuacamoleTunnel(connectionRecord, info);
        // Create a connection record which describes the shared connection
        ActiveConnectionRecord connectionRecord = activeConnectionRecordProvider.get();
        connectionRecord.init(user, definition.getActiveConnection(),
                definition.getSharingProfile());

        // Connect to shared connection described by the created record
        GuacamoleTunnel tunnel = assignGuacamoleTunnel(connectionRecord, info);

        // Register tunnel, such that it is closed when the
        // SharedConnectionDefinition is invalidated
        definition.registerTunnel(tunnel);
        return tunnel;
import com.google.inject.Inject;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionMap;
import org.apache.guacamole.auth.jdbc.sharing.SharedObjectManager;
    private RemoteAuthenticatedUser user;
    private ModeledConnectionGroup balancingGroup;
    private ModeledConnection connection;
    private ModeledSharingProfile sharingProfile;
     * Map of all currently-shared connections.
     */
    @Inject
    private SharedConnectionMap connectionMap;

    /**
     * Manager which tracks all share keys associated with this connection
     * record. All share keys registered with this manager will automatically be
     * removed from the common SharedConnectionMap once the manager is
     * invalidated.
     */
    private final SharedObjectManager<String> shareKeyManager =
            new SharedObjectManager<String>() {

        @Override
        protected void cleanup(String key) {
            connectionMap.remove(key);
        }

    };

    /**
     * Initializes this connection record, associating it with the given user,
    private void init(RemoteAuthenticatedUser user,
     * Initializes this connection record, associating it with the given user,
    public void init(RemoteAuthenticatedUser user,
        init(user, balancingGroup, connection, null);
     * Initializes this connection record, associating it with the given user
     * and connection. The start date of this connection record will be the time
     * of its creation.
    public void init(RemoteAuthenticatedUser user,
        init(user, null, connection);
     * Initializes this connection record, associating it with the given user,
     * active connection, and sharing profile. The given sharing profile MUST be
     * the sharing profile that was used to share access to the given
     * connection. The start date of this connection record will be the time of
     * its creation.
    public void init(RemoteAuthenticatedUser user,
        init(user, null, activeConnection.getConnection(), sharingProfile);
    /**
     * Registers the given share key with this ActiveConnectionRecord, such that
     * the key is automatically removed from the common SharedConnectionMap when
     * the connection represented by this ActiveConnectionRecord is closed. For
     * share keys to be properly invalidated when the connection being shared is
     * closed, all such share keys MUST be registered with the
     * ActiveConnectionRecord of the connection being shared.
     *
     * @param key
     *     The share key which should automatically be removed from the common
     *     SharedConnectionMap when the connection represented by this
     *     ActiveConnectionRecord is closed.
     */
    public void registerShareKey(String key) {
        shareKeyManager.register(key);
    }

    /**
     * Invalidates this ActiveConnectionRecord and all registered share keys. If
     * any additional share keys are registered after this function is invoked,
     * those keys will be immediately invalidated. This function MUST be invoked
     * when the connection represented by this ActiveConnectionRecord is
     * closing.
     */
    public void invalidate() {
        shareKeyManager.invalidate();
    }

     * The actual connection record from which this ActiveConnection derives its
     * data.
     */
    private ActiveConnectionRecord connectionRecord;

    /**
        this.connectionRecord = activeConnectionRecord;
                connectionRecord, identifier);
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
            ActiveConnectionRecord activeConnection,
        connectionMap.add(new SharedConnectionDefinition(activeConnection,
                sharingProfile, key));

        // Ensure the share key is properly invalidated when the original
        // connection is closed
        activeConnection.registerShareKey(key);
    public void add(SharedConnectionDefinition definition) {

        // Store definition by share key
        String shareKey = definition.getShareKey();
        connectionMap.put(shareKey, definition);

        SharedConnectionDefinition definition = connectionMap.remove(key);
        if (definition == null)
            return null;

        // Close all associated tunnels and disallow further sharing
        definition.invalidate();
        return definition;
     * The SharedConnectionDefinition dictating the connection being shared and
     * any associated restrictions.
    private SharedConnectionDefinition definition;
        this.definition = definition;
        return definition.getSharingProfile().getName();

        // Pull the connection being shared
        Connection primaryConnection = definition.getActiveConnection().getConnection();

        // Construct a skeletal configuration that exposes only the protocol in use
        config.setProtocol(primaryConnection.getConfiguration().getProtocol());

        return tunnelService.getGuacamoleTunnel(user, definition, info);
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.tunnel.ActiveConnectionRecord;
import org.apache.guacamole.net.GuacamoleTunnel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
     * Logger for this class.
     */
    private final Logger logger = LoggerFactory.getLogger(SharedConnectionDefinition.class);

    /**
    private final ActiveConnectionRecord activeConnection;
     * The unique key with which a user may access the shared connection.
     */
    private final String shareKey;

    /**
     * Manager which tracks all tunnels associated with this shared connection
     * definition. All tunnels registered with this manager will be
     * automatically closed once the manager is invalidated.
     */
    private final SharedObjectManager<GuacamoleTunnel> tunnels =
            new SharedObjectManager<GuacamoleTunnel>() {

        @Override
        protected void cleanup(GuacamoleTunnel tunnel) {

            try {
                tunnel.close();
            }
            catch (GuacamoleException e) {
                logger.debug("Unable to close tunnel of shared connection.", e);
            }

        }

    };

    /**
     *
     * @param shareKey
     *     The unique key with which a user may access the shared connection.
    public SharedConnectionDefinition(ActiveConnectionRecord activeConnection,
            ModeledSharingProfile sharingProfile, String shareKey) {
        this.shareKey = shareKey;
     * Returns the ActiveConnectionRecord of the actual in-progress connection
     *     The ActiveConnectionRecord being shared.
    public ActiveConnectionRecord getActiveConnection() {
    /**
     * Returns the unique key with which a user may access the shared
     * connection.
     *
     * @return
     *     The unique key with which a user may access the shared connection.
     */
    public String getShareKey() {
        return shareKey;
    }

    /**
     * Registers the given tunnel with this SharedConnectionDefinition, such
     * that the tunnel is automatically closed when this
     * SharedConnectionDefinition is invalidated. For shared connections to be
     * properly closed when the associated share key ceases being valid, the
     * tunnels resulting from the use of the share key MUST be registered to the
     * SharedConnectionDefinition associated with that share key.
     *
     * @param tunnel
     *     The tunnel which should automatically be closed when this
     *     SharedConnectionDefinition is invalidated.
     */
    public void registerTunnel(GuacamoleTunnel tunnel) {
        tunnels.register(tunnel);
    }

    /**
     * Invalidates this SharedConnectionDefinition and closes all registered
     * tunnels. If any additional tunnels are registered after this function is
     * invoked, those tunnels will be immediately closed. This function MUST be
     * invoked when the share key associated with this
     * SharedConnectionDefinition will no longer be used.
     */
    public void invalidate() {
        tunnels.invalidate();
    }

     * Stores the given SharedConnectionDefinition by its associated share key,
     *     shared.
    public void add(SharedConnectionDefinition definition);
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionDefinition;
     * Provider for creating active connection records.
     */
    @Inject
    private Provider<ActiveConnectionRecord> activeConnectionRecordProvider;

    /**
            // Connection can no longer be shared
            activeConnection.invalidate();

                if (connectionID == null)
        // Acquire access to single connection

        // Connect only if the connection was successfully acquired
        ActiveConnectionRecord connectionRecord = activeConnectionRecordProvider.get();
        connectionRecord.init(user, connection);
        return assignGuacamoleTunnel(connectionRecord, info);
        ActiveConnectionRecord connectionRecord = activeConnectionRecordProvider.get();
        connectionRecord.init(user, connectionGroup, connection);
        return assignGuacamoleTunnel(connectionRecord, info);
            SharedConnectionDefinition definition,
        // Create a connection record which describes the shared connection
        ActiveConnectionRecord connectionRecord = activeConnectionRecordProvider.get();
        connectionRecord.init(user, definition.getActiveConnection(),
                definition.getSharingProfile());

        // Connect to shared connection described by the created record
        GuacamoleTunnel tunnel = assignGuacamoleTunnel(connectionRecord, info);

        // Register tunnel, such that it is closed when the
        // SharedConnectionDefinition is invalidated
        definition.registerTunnel(tunnel);
        return tunnel;
import com.google.inject.Inject;
import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionMap;
import org.apache.guacamole.auth.jdbc.sharing.SharedObjectManager;
    private RemoteAuthenticatedUser user;
    private ModeledConnectionGroup balancingGroup;
    private ModeledConnection connection;
    private ModeledSharingProfile sharingProfile;
     * Map of all currently-shared connections.
     */
    @Inject
    private SharedConnectionMap connectionMap;

    /**
     * Manager which tracks all share keys associated with this connection
     * record. All share keys registered with this manager will automatically be
     * removed from the common SharedConnectionMap once the manager is
     * invalidated.
     */
    private final SharedObjectManager<String> shareKeyManager =
            new SharedObjectManager<String>() {

        @Override
        protected void cleanup(String key) {
            connectionMap.remove(key);
        }

    };

    /**
     * Initializes this connection record, associating it with the given user,
    private void init(RemoteAuthenticatedUser user,
     * Initializes this connection record, associating it with the given user,
    public void init(RemoteAuthenticatedUser user,
        init(user, balancingGroup, connection, null);
     * Initializes this connection record, associating it with the given user
     * and connection. The start date of this connection record will be the time
     * of its creation.
    public void init(RemoteAuthenticatedUser user,
        init(user, null, connection);
     * Initializes this connection record, associating it with the given user,
     * active connection, and sharing profile. The given sharing profile MUST be
     * the sharing profile that was used to share access to the given
     * connection. The start date of this connection record will be the time of
     * its creation.
    public void init(RemoteAuthenticatedUser user,
            ActiveConnectionRecord activeConnection,
        init(user, null, activeConnection.getConnection(), sharingProfile);
    /**
     * Registers the given share key with this ActiveConnectionRecord, such that
     * the key is automatically removed from the common SharedConnectionMap when
     * the connection represented by this ActiveConnectionRecord is closed. For
     * share keys to be properly invalidated when the connection being shared is
     * closed, all such share keys MUST be registered with the
     * ActiveConnectionRecord of the connection being shared.
     *
     * @param key
     *     The share key which should automatically be removed from the common
     *     SharedConnectionMap when the connection represented by this
     *     ActiveConnectionRecord is closed.
     */
    public void registerShareKey(String key) {
        shareKeyManager.register(key);
    }

    /**
     * Invalidates this ActiveConnectionRecord and all registered share keys. If
     * any additional share keys are registered after this function is invoked,
     * those keys will be immediately invalidated. This function MUST be invoked
     * when the connection represented by this ActiveConnectionRecord is
     * closing.
     */
    public void invalidate() {
        shareKeyManager.invalidate();
    }

import org.apache.guacamole.auth.jdbc.sharing.SharedConnectionDefinition;
     * @param definition
     *     The SharedConnectionDefinition dictating the connection being shared
     *     and any associated restrictions.
            SharedConnectionDefinition definition,
import org.apache.guacamole.GuacamoleResourceNotFoundException;
        // Fail if the active connection cannot be found
        ActiveConnection activeConnection = tunnel.getActiveConnection();
        if (activeConnection == null)
            throw new GuacamoleResourceNotFoundException("No readable active connection for tunnel.");

                userContext.getActiveConnectionDirectory(), activeConnection);
        String username = user.getIdentifier();
            // Sensitive information should be included if the connection was
            // started by the current user OR the user is an admin
            boolean includeSensitiveInformation =
                    isAdmin || username.equals(record.getUsername());

                activeConnection.init(user, record, includeSensitiveInformation);
        String username = user.getIdentifier();
            // Sensitive information should be included if the connection was
            // started by the current user OR the user is an admin
            boolean includeSensitiveInformation =
                    isAdmin || username.equals(record.getUsername());

                activeConnection.init(user, record, includeSensitiveInformation);
import org.apache.guacamole.GuacamoleResourceNotFoundException;
        // Fail if the active connection cannot be found
        ActiveConnection activeConnection = tunnel.getActiveConnection();
        if (activeConnection == null)
            throw new GuacamoleResourceNotFoundException("No readable active connection for tunnel.");

                userContext.getActiveConnectionDirectory(), activeConnection);
    public JDBCAuthenticationProviderModule(JDBCEnvironment environment) {
        // Associate the originating authentication provider
        this.authProvider = user.getAuthenticationProvider();

        return getCurrentUser().getAuthenticationProvider();
            new JDBCAuthenticationProviderModule(environment)
            new JDBCAuthenticationProviderModule(environment)
    public JDBCAuthenticationProviderModule(JDBCEnvironment environment) {
        // Associate the originating authentication provider
        this.authProvider = user.getAuthenticationProvider();

        return getCurrentUser().getAuthenticationProvider();
            new JDBCAuthenticationProviderModule(environment)
            new JDBCAuthenticationProviderModule(environment)
import javax.xml.bind.DatatypeConverter;
        return DatatypeConverter.printHexBinary(bytes);
import javax.xml.bind.DatatypeConverter;
        return DatatypeConverter.printHexBinary(bytes);
import javax.xml.stream.events.Characters;
        // Ignore invalid identifiers
        identifiers = ObjectModel.filterIdentifiers(identifiers);

import java.util.ArrayList;
import java.util.Collection;

    /**
     * Returns whether the given string is a valid identifier within the JDBC
     * authentication extension. Invalid identifiers may result in SQL errors
     * from the underlying database when used in queries.
     *
     * @param identifier
     *     The string to check for validity.
     *
     * @return
     *     true if the given string is a valid identifier, false otherwise.
     */
    public static boolean isValidIdentifier(String identifier) {

        // Empty identifiers are invalid
        if (identifier.isEmpty())
            return false;

        // Identifier is invalid if any non-numeric characters are present
        for (int i = 0; i < identifier.length(); i) {
            if (!Character.isDigit(identifier.charAt(i)))
                return false;
        }

        // Identifier is valid - contains only numeric characters
        return true;

    }

    /**
     * Filters the given collection of strings, returning a new collection
     * containing only those strings which are valid identifiers. If no strings
     * within the collection are valid identifiers, the returned collection will
     * simply be empty.
     *
     * @param identifiers
     *     The collection of strings to filter.
     *
     * @return
     *     A new collection containing only the strings within the provided
     *     collection which are valid identifiers.
     */
    public static Collection<String> filterIdentifiers(Collection<String> identifiers) {

        // Obtain enough space for a full copy of the given identifiers
        Collection<String> validIdentifiers = new ArrayList<String>(identifiers.size());

        // Add only valid identifiers to the copy
        for (String identifier : identifiers) {
            if (ObjectModel.isValidIdentifier(identifier))
                validIdentifiers.add(identifier);
        }

        return validIdentifiers;

    }

import javax.xml.stream.events.Characters;
        // Ignore invalid identifiers
        identifiers = ObjectModel.filterIdentifiers(identifiers);

import java.util.ArrayList;
import java.util.Collection;

    /**
     * Returns whether the given string is a valid identifier within the JDBC
     * authentication extension. Invalid identifiers may result in SQL errors
     * from the underlying database when used in queries.
     *
     * @param identifier
     *     The string to check for validity.
     *
     * @return
     *     true if the given string is a valid identifier, false otherwise.
     */
    public static boolean isValidIdentifier(String identifier) {

        // Empty identifiers are invalid
        if (identifier.isEmpty())
            return false;

        // Identifier is invalid if any non-numeric characters are present
        for (int i = 0; i < identifier.length(); i) {
            if (!Character.isDigit(identifier.charAt(i)))
                return false;
        }

        // Identifier is valid - contains only numeric characters
        return true;

    }

    /**
     * Filters the given collection of strings, returning a new collection
     * containing only those strings which are valid identifiers. If no strings
     * within the collection are valid identifiers, the returned collection will
     * simply be empty.
     *
     * @param identifiers
     *     The collection of strings to filter.
     *
     * @return
     *     A new collection containing only the strings within the provided
     *     collection which are valid identifiers.
     */
    public static Collection<String> filterIdentifiers(Collection<String> identifiers) {

        // Obtain enough space for a full copy of the given identifiers
        Collection<String> validIdentifiers = new ArrayList<String>(identifiers.size());

        // Add only valid identifiers to the copy
        for (String identifier : identifiers) {
            if (ObjectModel.isValidIdentifier(identifier))
                validIdentifiers.add(identifier);
        }

        return validIdentifiers;

    }

import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProvider;
public class MySQLAuthenticationProvider extends JDBCAuthenticationProvider {
    public MySQLAuthenticationProvider() {
        super(new MySQLInjectorProvider());
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProvider;
public class PostgreSQLAuthenticationProvider extends JDBCAuthenticationProvider {
    public PostgreSQLAuthenticationProvider() {
        super(new PostgreSQLInjectorProvider());
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/InjectedAuthenticationProvider.java
 * Provides a base implementation of an AuthenticationProvider which delegates
 * the various function calls to an underlying AuthenticationProviderService
 * implementation. As such a service is injectable by Guice, this provides a
 * means for Guice to (effectively) apply dependency injection to an
 * AuthenticationProvider, even though it is the AuthenticationProvider that
 * serves as the entry point.
public abstract class InjectedAuthenticationProvider implements AuthenticationProvider {
     * The AuthenticationProviderService to which all AuthenticationProvider
     * calls will be delegated.
    private final AuthenticationProviderService authProviderService;
     * Creates a new AuthenticationProvider that delegates all calls to an
     * underlying AuthenticationProviderService. The behavior of the
     * AuthenticationProvider is defined by the given
     * AuthenticationProviderService implementation, which will be injected by
     * the Guice Injector provided by the given JDBCInjectorProvider.
     *
     * @param authProviderServiceClass
     *    The AuthenticationProviderService implementation which defines the
     *    behavior of this AuthenticationProvider.
     *
     * @throws GuacamoleException
     *     If the Injector cannot be created due to an error.
    public InjectedAuthenticationProvider(JDBCInjectorProvider injectorProvider,
            Class<? extends AuthenticationProviderService> authProviderServiceClass)
        throws GuacamoleException {

        Injector injector = injectorProvider.get();
        authProviderService = injector.getInstance(authProviderServiceClass);

import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.InjectedAuthenticationProvider;
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProviderService;
public class MySQLAuthenticationProvider extends InjectedAuthenticationProvider {
     *
     * @throws GuacamoleException
     *     If a required property is missing, or an error occurs while parsing
     *     a property.
    public MySQLAuthenticationProvider() throws GuacamoleException {
        super(new MySQLInjectorProvider(), JDBCAuthenticationProviderService.class);
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.auth.jdbc.InjectedAuthenticationProvider;
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProviderService;
public class PostgreSQLAuthenticationProvider extends InjectedAuthenticationProvider {
     *
     * @throws GuacamoleException
     *     If a required property is missing, or an error occurs while parsing
     *     a property.
    public PostgreSQLAuthenticationProvider() throws GuacamoleException {
        super(new PostgreSQLInjectorProvider(), JDBCAuthenticationProviderService.class);
import org.apache.guacamole.auth.jdbc.InjectedAuthenticationProvider;
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProviderService;
public class MySQLAuthenticationProvider extends InjectedAuthenticationProvider {
        super(new MySQLInjectorProvider(), JDBCAuthenticationProviderService.class);
import org.apache.guacamole.auth.jdbc.InjectedAuthenticationProvider;
import org.apache.guacamole.auth.jdbc.JDBCAuthenticationProviderService;
public class PostgreSQLAuthenticationProvider extends InjectedAuthenticationProvider {
        super(new PostgreSQLInjectorProvider(), JDBCAuthenticationProviderService.class);
     * @param authenticationProvider
     *     The AuthenticationProvider on behalf of which the UserContext is
     *     being produced.
     *
    public UserContext getUserContext(AuthenticationProvider authenticationProvider,
            AuthenticatedUser authenticatedUser) throws GuacamoleException;
        return authProviderService.getUserContext(this, authenticatedUser);
    public UserContext getUserContext(AuthenticationProvider authenticationProvider,
        ModeledUser user = userService.retrieveUser(authenticationProvider, authenticatedUser);
            AuthenticationProvider authenticationProvider,
     * The ModeledUser object which is backed by the data associated with this
     * user in the database.
     * The AuthenticationProvider that is associated with this user's
     * corresponding ModeledUser.
     */
    private final AuthenticationProvider modelAuthenticationProvider;

    /**
     * Creates a copy of the given AuthenticatedUser which is associated with
     * the data stored in the provided ModeledUser. The AuthenticatedUser need
     * not have come from the same AuthenticationProvider which produced the
     * given ModeledUser.
     *
     * @param authenticatedUser
     *     An existing AuthenticatedUser representing the user that
     *     authenticated.
     *
     * @param modelAuthenticationProvider
     *     The AuthenticationProvider that is associated with the given user's
     *     corresponding ModeledUser.
     *
     * @param user
     *     A ModeledUser object which is backed by the data associated with
     *     this user in the database.
     */
    public AuthenticatedUser(org.apache.guacamole.net.auth.AuthenticatedUser authenticatedUser,
            AuthenticationProvider modelAuthenticationProvider, ModeledUser user) {
        super(authenticatedUser.getAuthenticationProvider(), authenticatedUser.getCredentials());
        this.modelAuthenticationProvider = modelAuthenticationProvider;
        this.user = user;
    }

    /**
     *     The AuthenticationProvider that has authenticated the given user
     *     and which produced the given ModeledUser.
     *     A ModeledUser object which is backed by the data associated with
     *     this user in the database.
        this.modelAuthenticationProvider = authenticationProvider;
     * Returns a ModeledUser object which is backed by the data associated with
     * this user within the database.
     *     A ModeledUser object which is backed by the data associated with
     *     this user in the database.
     * Returns the AuthenticationProvider which produced the ModeledUser
     * retrievable via getUser(). This is not necessarily the same as the
     * AuthenticationProvider which authenticated that user, which can be
     * retrieved with getAuthenticationProvider().
     *
     * @return
     *     The AuthenticationProvider which produced the ModeledUser
     *     retrievable via getUser().
     */
    public AuthenticationProvider getModelAuthenticationProvider() {
        return modelAuthenticationProvider;
    }

    /**
        return getCurrentUser().getModelAuthenticationProvider();
     * @param authenticationProvider
     *     The AuthenticationProvider on behalf of which the user is being
     *     retrieved.
     *
    public ModeledUser retrieveUser(AuthenticationProvider authenticationProvider,
            org.apache.guacamole.net.auth.AuthenticatedUser authenticatedUser) {
        user.setCurrentUser(new AuthenticatedUser(authenticatedUser,
                authenticationProvider, user));
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public ObjectPermission retrievePermission(ModeledAuthenticatedUser user,
    public Set<ObjectPermission> retrievePermissions(ModeledAuthenticatedUser user,
    public Collection<String> retrieveAccessibleIdentifiers(ModeledAuthenticatedUser user,
    public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
    public void createPermissions(ModeledAuthenticatedUser user,
    public void deletePermissions(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public TrackedActiveConnection retrieveObject(ModeledAuthenticatedUser user,
    public Collection<TrackedActiveConnection> retrieveObjects(ModeledAuthenticatedUser user,
    public void deleteObject(ModeledAuthenticatedUser user, String identifier)
    public Set<String> getIdentifiers(ModeledAuthenticatedUser user)
    public TrackedActiveConnection createObject(ModeledAuthenticatedUser user,
    public void updateObject(ModeledAuthenticatedUser user, TrackedActiveConnection object)
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public void init(ModeledAuthenticatedUser currentUser,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    InternalType retrieveObject(ModeledAuthenticatedUser user, String identifier)
    Collection<InternalType> retrieveObjects(ModeledAuthenticatedUser user,
    InternalType createObject(ModeledAuthenticatedUser user, ExternalType object)
    void deleteObject(ModeledAuthenticatedUser user, String identifier)
    void updateObject(ModeledAuthenticatedUser user, InternalType object)
    Set<String> getIdentifiers(ModeledAuthenticatedUser user) throws GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected abstract InternalType getObjectInstance(ModeledAuthenticatedUser currentUser,
    protected abstract ModelType getModelInstance(ModeledAuthenticatedUser currentUser,
    protected abstract boolean hasCreatePermission(ModeledAuthenticatedUser user)
    protected boolean hasObjectPermission(ModeledAuthenticatedUser user,
    protected abstract ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
    protected Collection<InternalType> getObjectInstances(ModeledAuthenticatedUser currentUser,
    protected void beforeCreate(ModeledAuthenticatedUser user,
    protected void beforeUpdate(ModeledAuthenticatedUser user,
    protected void beforeDelete(ModeledAuthenticatedUser user,
    public InternalType retrieveObject(ModeledAuthenticatedUser user,
    public Collection<InternalType> retrieveObjects(ModeledAuthenticatedUser user,
    protected Collection<ObjectPermissionModel> getImplicitPermissions(ModeledAuthenticatedUser user,
    public InternalType createObject(ModeledAuthenticatedUser user, ExternalType object)
    public void deleteObject(ModeledAuthenticatedUser user, String identifier)
    public void updateObject(ModeledAuthenticatedUser user, InternalType object)
    public Set<String> getIdentifiers(ModeledAuthenticatedUser user)
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected Collection<String> getModifiedGroups(ModeledAuthenticatedUser user,
    protected boolean canUpdateModifiedGroups(ModeledAuthenticatedUser user,
    protected void beforeCreate(ModeledAuthenticatedUser user,
    protected void beforeUpdate(ModeledAuthenticatedUser user,
    protected void beforeDelete(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public void init(ModeledAuthenticatedUser currentUser, ModelType model) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    private ModeledAuthenticatedUser currentUser;
    public void init(ModeledAuthenticatedUser currentUser) {
    public ModeledAuthenticatedUser getCurrentUser() {
    public void setCurrentUser(ModeledAuthenticatedUser currentUser) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected ModeledConnection getObjectInstance(ModeledAuthenticatedUser currentUser,
    protected ConnectionModel getModelInstance(ModeledAuthenticatedUser currentUser,
    protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
    protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
    protected void beforeCreate(ModeledAuthenticatedUser user,
    protected void beforeUpdate(ModeledAuthenticatedUser user,
    public ModeledConnection createObject(ModeledAuthenticatedUser user, Connection object)
    public void updateObject(ModeledAuthenticatedUser user, ModeledConnection object)
    public Set<String> getIdentifiersWithin(ModeledAuthenticatedUser user,
    public Map<String, String> retrieveParameters(ModeledAuthenticatedUser user,
    public List<ConnectionRecord> retrieveHistory(ModeledAuthenticatedUser user,
    public List<ConnectionRecord> retrieveHistory(ModeledAuthenticatedUser user,
    public GuacamoleTunnel connect(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    private ModeledAuthenticatedUser currentUser;
    public void init(ModeledAuthenticatedUser currentUser, ConnectionModel connectionModel) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected ModeledConnectionGroup getObjectInstance(ModeledAuthenticatedUser currentUser,
    protected ConnectionGroupModel getModelInstance(ModeledAuthenticatedUser currentUser,
    protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
    protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
    protected void beforeCreate(ModeledAuthenticatedUser user,
    protected void beforeUpdate(ModeledAuthenticatedUser user,
    public Set<String> getIdentifiersWithin(ModeledAuthenticatedUser user,
    public GuacamoleTunnel connect(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected boolean canReadPermissions(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected boolean canAlterPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
    public void createPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
    public void deletePermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
    public ObjectPermission retrievePermission(ModeledAuthenticatedUser user,
    public Collection<String> retrieveAccessibleIdentifiers(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public Set<PermissionType> retrievePermissions(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    ObjectPermission retrievePermission(ModeledAuthenticatedUser user,
    Collection<String> retrieveAccessibleIdentifiers(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public void init(ModeledAuthenticatedUser currentUser, ModeledUser user) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    PermissionSetType getPermissionSet(ModeledAuthenticatedUser user,
    Set<PermissionType> retrievePermissions(ModeledAuthenticatedUser user,
    void createPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
    void deletePermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public SystemPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
    public void createPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
    public void deletePermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
    public SystemPermission retrievePermission(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public void init(ModeledAuthenticatedUser currentUser, ModeledUser user) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public UserCredentials generateTemporaryCredentials(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected ModeledSharingProfile getObjectInstance(ModeledAuthenticatedUser currentUser,
    protected SharingProfileModel getModelInstance(ModeledAuthenticatedUser currentUser,
    protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
    protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
    protected void beforeCreate(ModeledAuthenticatedUser user,
    protected void beforeUpdate(ModeledAuthenticatedUser user,
    public ModeledSharingProfile createObject(ModeledAuthenticatedUser user, SharingProfile object)
    public void updateObject(ModeledAuthenticatedUser user, ModeledSharingProfile object)
    public Set<String> getIdentifiersWithin(ModeledAuthenticatedUser user,
    public Map<String, String> retrieveParameters(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    private Collection<String> getPreferredConnections(ModeledAuthenticatedUser user,
    private List<ModeledConnection> getBalancedConnections(ModeledAuthenticatedUser user,
    public Collection<ActiveConnectionRecord> getActiveConnections(ModeledAuthenticatedUser user)
    public GuacamoleTunnel getGuacamoleTunnel(final ModeledAuthenticatedUser user,
    public GuacamoleTunnel getGuacamoleTunnel(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public Collection<ActiveConnectionRecord> getActiveConnections(ModeledAuthenticatedUser user)
    GuacamoleTunnel getGuacamoleTunnel(ModeledAuthenticatedUser user,
    GuacamoleTunnel getGuacamoleTunnel(ModeledAuthenticatedUser user,
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/user/ModeledAuthenticatedUser.java
import org.apache.guacamole.net.auth.AuthenticatedUser;
 * Associates a user with the credentials they used to authenticate, their
 * corresponding ModeledUser, and the AuthenticationProvider which produced
 * that ModeledUser.
public class ModeledAuthenticatedUser extends RemoteAuthenticatedUser {
    public ModeledAuthenticatedUser(AuthenticatedUser authenticatedUser,
    public ModeledAuthenticatedUser(AuthenticationProvider authenticationProvider,
    public void init(ModeledAuthenticatedUser currentUser) {
import org.apache.guacamole.net.auth.AuthenticatedUser;
    protected ModeledUser getObjectInstance(ModeledAuthenticatedUser currentUser,
    protected UserModel getModelInstance(ModeledAuthenticatedUser currentUser,
    protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
    protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
    protected void beforeCreate(ModeledAuthenticatedUser user, UserModel model)
    protected void beforeUpdate(ModeledAuthenticatedUser user,
        getImplicitPermissions(ModeledAuthenticatedUser user, UserModel model) {
    protected void beforeDelete(ModeledAuthenticatedUser user, String identifier) throws GuacamoleException {
    public ModeledAuthenticatedUser retrieveAuthenticatedUser(AuthenticationProvider authenticationProvider,
        user.setCurrentUser(new ModeledAuthenticatedUser(authenticationProvider, user, credentials));
            AuthenticatedUser authenticatedUser) {
        if (authenticatedUser instanceof ModeledAuthenticatedUser)
            return ((ModeledAuthenticatedUser) authenticatedUser).getUser();
        user.setCurrentUser(new ModeledAuthenticatedUser(authenticatedUser,
import org.apache.guacamole.auth.jdbc.user.ModeledUserContext;
        bind(ModeledUserContext.class);
import org.apache.guacamole.auth.jdbc.user.ModeledUserContext;
    private Provider<ModeledUserContext> userContextProvider;
    public ModeledUserContext getUserContext(AuthenticationProvider authenticationProvider,
        ModeledUserContext context = userContextProvider.get();
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/user/ModeledUserContext.java
public class ModeledUserContext extends RestrictedObject
            AuthenticatedUser authenticatedUser, Credentials credentials)
            throws GuacamoleException {
            AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {
     * @param credentials
     *     The credentials which were most recently submitted. These are not
     *     guaranteed to be the same as the credentials associated with the
     *     AuthenticatedUser when they originally authenticated.
     *
            AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException;
        AuthenticatedUser authorizedUser, Credentials credentials)
            throws GuacamoleException {
            AuthenticatedUser authenticatedUser, Credentials credentials)
        return authProvider.updateUserContext(context, authenticatedUser, credentials);
     * @param credentials
     *     The Credentials provided by the user in the most recent
     *     authentication attempt.
     *
            AuthenticatedUser authenticatedUser, Credentials credentials)
            throws GuacamoleException {
                UserContext userContext = authProvider.updateUserContext(oldUserContext, authenticatedUser, credentials);
        List<UserContext> userContexts = getUserContexts(existingSession, authenticatedUser, credentials);
                    closeConnection(session, GuacamoleStatus.SERVER_ERROR);
                            closeConnection(connection, GuacamoleStatus.SERVER_ERROR);
                    closeConnection(session, GuacamoleStatus.SERVER_ERROR);
                            closeConnection(outbound, GuacamoleStatus.SERVER_ERROR);
                    closeConnection(session, GuacamoleStatus.SERVER_ERROR);
                            closeConnection(connection, GuacamoleStatus.SERVER_ERROR);
                    closeConnection(session, GuacamoleStatus.SERVER_ERROR);
                            closeConnection(outbound, GuacamoleStatus.SERVER_ERROR);
     * @param authenticationProvider
     *     The AuthenticationProvider on behalf of which the UserContext is
     *     being produced.
     *
    public UserContext getUserContext(AuthenticationProvider authenticationProvider,
            AuthenticatedUser authenticatedUser) throws GuacamoleException;
        return authProviderService.getUserContext(this, authenticatedUser);
import org.apache.guacamole.auth.jdbc.user.ModeledUserContext;
        bind(ModeledUserContext.class);
import org.apache.guacamole.auth.jdbc.user.ModeledUserContext;
    private Provider<ModeledUserContext> userContextProvider;
    public ModeledUserContext getUserContext(AuthenticationProvider authenticationProvider,
        ModeledUser user = userService.retrieveUser(authenticationProvider, authenticatedUser);
        ModeledUserContext context = userContextProvider.get();
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public ObjectPermission retrievePermission(ModeledAuthenticatedUser user,
    public Set<ObjectPermission> retrievePermissions(ModeledAuthenticatedUser user,
    public Collection<String> retrieveAccessibleIdentifiers(ModeledAuthenticatedUser user,
    public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
    public void createPermissions(ModeledAuthenticatedUser user,
    public void deletePermissions(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public TrackedActiveConnection retrieveObject(ModeledAuthenticatedUser user,
    public Collection<TrackedActiveConnection> retrieveObjects(ModeledAuthenticatedUser user,
    public void deleteObject(ModeledAuthenticatedUser user, String identifier)
    public Set<String> getIdentifiers(ModeledAuthenticatedUser user)
    public TrackedActiveConnection createObject(ModeledAuthenticatedUser user,
    public void updateObject(ModeledAuthenticatedUser user, TrackedActiveConnection object)
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public void init(ModeledAuthenticatedUser currentUser,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    InternalType retrieveObject(ModeledAuthenticatedUser user, String identifier)
    Collection<InternalType> retrieveObjects(ModeledAuthenticatedUser user,
    InternalType createObject(ModeledAuthenticatedUser user, ExternalType object)
    void deleteObject(ModeledAuthenticatedUser user, String identifier)
    void updateObject(ModeledAuthenticatedUser user, InternalType object)
    Set<String> getIdentifiers(ModeledAuthenticatedUser user) throws GuacamoleException;
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected abstract InternalType getObjectInstance(ModeledAuthenticatedUser currentUser,
    protected abstract ModelType getModelInstance(ModeledAuthenticatedUser currentUser,
    protected abstract boolean hasCreatePermission(ModeledAuthenticatedUser user)
    protected boolean hasObjectPermission(ModeledAuthenticatedUser user,
    protected abstract ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
    protected Collection<InternalType> getObjectInstances(ModeledAuthenticatedUser currentUser,
    protected void beforeCreate(ModeledAuthenticatedUser user,
    protected void beforeUpdate(ModeledAuthenticatedUser user,
    protected void beforeDelete(ModeledAuthenticatedUser user,
    public InternalType retrieveObject(ModeledAuthenticatedUser user,
    public Collection<InternalType> retrieveObjects(ModeledAuthenticatedUser user,
    protected Collection<ObjectPermissionModel> getImplicitPermissions(ModeledAuthenticatedUser user,
    public InternalType createObject(ModeledAuthenticatedUser user, ExternalType object)
    public void deleteObject(ModeledAuthenticatedUser user, String identifier)
    public void updateObject(ModeledAuthenticatedUser user, InternalType object)
    public Set<String> getIdentifiers(ModeledAuthenticatedUser user)
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected Collection<String> getModifiedGroups(ModeledAuthenticatedUser user,
    protected boolean canUpdateModifiedGroups(ModeledAuthenticatedUser user,
    protected void beforeCreate(ModeledAuthenticatedUser user,
    protected void beforeUpdate(ModeledAuthenticatedUser user,
    protected void beforeDelete(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public void init(ModeledAuthenticatedUser currentUser, ModelType model) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    private ModeledAuthenticatedUser currentUser;
    public void init(ModeledAuthenticatedUser currentUser) {
    public ModeledAuthenticatedUser getCurrentUser() {
    public void setCurrentUser(ModeledAuthenticatedUser currentUser) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected ModeledConnection getObjectInstance(ModeledAuthenticatedUser currentUser,
    protected ConnectionModel getModelInstance(ModeledAuthenticatedUser currentUser,
    protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
    protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
    protected void beforeCreate(ModeledAuthenticatedUser user,
    protected void beforeUpdate(ModeledAuthenticatedUser user,
    public ModeledConnection createObject(ModeledAuthenticatedUser user, Connection object)
    public void updateObject(ModeledAuthenticatedUser user, ModeledConnection object)
    public Set<String> getIdentifiersWithin(ModeledAuthenticatedUser user,
    public Map<String, String> retrieveParameters(ModeledAuthenticatedUser user,
    public List<ConnectionRecord> retrieveHistory(ModeledAuthenticatedUser user,
    public List<ConnectionRecord> retrieveHistory(ModeledAuthenticatedUser user,
    public GuacamoleTunnel connect(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    private ModeledAuthenticatedUser currentUser;
    public void init(ModeledAuthenticatedUser currentUser, ConnectionModel connectionModel) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected ModeledConnectionGroup getObjectInstance(ModeledAuthenticatedUser currentUser,
    protected ConnectionGroupModel getModelInstance(ModeledAuthenticatedUser currentUser,
    protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
    protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
    protected void beforeCreate(ModeledAuthenticatedUser user,
    protected void beforeUpdate(ModeledAuthenticatedUser user,
    public Set<String> getIdentifiersWithin(ModeledAuthenticatedUser user,
    public GuacamoleTunnel connect(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected boolean canReadPermissions(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected boolean canAlterPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
    public void createPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
    public void deletePermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
    public ObjectPermission retrievePermission(ModeledAuthenticatedUser user,
    public Collection<String> retrieveAccessibleIdentifiers(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public Set<PermissionType> retrievePermissions(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    ObjectPermission retrievePermission(ModeledAuthenticatedUser user,
    Collection<String> retrieveAccessibleIdentifiers(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public void init(ModeledAuthenticatedUser currentUser, ModeledUser user) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    PermissionSetType getPermissionSet(ModeledAuthenticatedUser user,
    Set<PermissionType> retrievePermissions(ModeledAuthenticatedUser user,
    void createPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
    void deletePermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public SystemPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
    public void createPermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
    public void deletePermissions(ModeledAuthenticatedUser user, ModeledUser targetUser,
    public SystemPermission retrievePermission(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public void init(ModeledAuthenticatedUser currentUser, ModeledUser user) {
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public UserCredentials generateTemporaryCredentials(ModeledAuthenticatedUser user,
            AuthenticationProvider authenticationProvider,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    protected ModeledSharingProfile getObjectInstance(ModeledAuthenticatedUser currentUser,
    protected SharingProfileModel getModelInstance(ModeledAuthenticatedUser currentUser,
    protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
    protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
    protected void beforeCreate(ModeledAuthenticatedUser user,
    protected void beforeUpdate(ModeledAuthenticatedUser user,
    public ModeledSharingProfile createObject(ModeledAuthenticatedUser user, SharingProfile object)
    public void updateObject(ModeledAuthenticatedUser user, ModeledSharingProfile object)
    public Set<String> getIdentifiersWithin(ModeledAuthenticatedUser user,
    public Map<String, String> retrieveParameters(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    private Collection<String> getPreferredConnections(ModeledAuthenticatedUser user,
    private List<ModeledConnection> getBalancedConnections(ModeledAuthenticatedUser user,
    public Collection<ActiveConnectionRecord> getActiveConnections(ModeledAuthenticatedUser user)
    public GuacamoleTunnel getGuacamoleTunnel(final ModeledAuthenticatedUser user,
    public GuacamoleTunnel getGuacamoleTunnel(ModeledAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.user.ModeledAuthenticatedUser;
    public Collection<ActiveConnectionRecord> getActiveConnections(ModeledAuthenticatedUser user)
    GuacamoleTunnel getGuacamoleTunnel(ModeledAuthenticatedUser user,
    GuacamoleTunnel getGuacamoleTunnel(ModeledAuthenticatedUser user,
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/user/ModeledUserContext.java
public class ModeledUserContext extends RestrictedObject
    public void init(ModeledAuthenticatedUser currentUser) {
        return getCurrentUser().getModelAuthenticationProvider();
import org.apache.guacamole.net.auth.AuthenticatedUser;
    protected ModeledUser getObjectInstance(ModeledAuthenticatedUser currentUser,
    protected UserModel getModelInstance(ModeledAuthenticatedUser currentUser,
    protected boolean hasCreatePermission(ModeledAuthenticatedUser user)
    protected ObjectPermissionSet getPermissionSet(ModeledAuthenticatedUser user)
    protected void beforeCreate(ModeledAuthenticatedUser user, UserModel model)
    protected void beforeUpdate(ModeledAuthenticatedUser user,
        getImplicitPermissions(ModeledAuthenticatedUser user, UserModel model) {
    protected void beforeDelete(ModeledAuthenticatedUser user, String identifier) throws GuacamoleException {
    public ModeledAuthenticatedUser retrieveAuthenticatedUser(AuthenticationProvider authenticationProvider,
        user.setCurrentUser(new ModeledAuthenticatedUser(authenticationProvider, user, credentials));
     * @param authenticationProvider
     *     The AuthenticationProvider on behalf of which the user is being
     *     retrieved.
     *
    public ModeledUser retrieveUser(AuthenticationProvider authenticationProvider,
            AuthenticatedUser authenticatedUser) {
        if (authenticatedUser instanceof ModeledAuthenticatedUser)
            return ((ModeledAuthenticatedUser) authenticatedUser).getUser();
        user.setCurrentUser(new ModeledAuthenticatedUser(authenticatedUser,
                authenticationProvider, user));
    /**
     * Returns whether the given string is a valid identifier within the JDBC
     * authentication extension. Invalid identifiers may result in SQL errors
     * from the underlying database when used in queries.
     *
     * @param identifier
     *     The string to check for validity.
     *
     * @return
     *     true if the given string is a valid identifier, false otherwise.
     */
    protected boolean isValidIdentifier(String identifier) {

        // Empty identifiers are invalid
        if (identifier.isEmpty())
            return false;

        // Identifier is invalid if any non-numeric characters are present
        for (int i = 0; i < identifier.length(); i) {
            if (!Character.isDigit(identifier.charAt(i)))
                return false;
        }

        // Identifier is valid - contains only numeric characters
        return true;

    }

    /**
     * Filters the given collection of strings, returning a new collection
     * containing only those strings which are valid identifiers. If no strings
     * within the collection are valid identifiers, the returned collection will
     * simply be empty.
     *
     * @param identifiers
     *     The collection of strings to filter.
     *
     * @return
     *     A new collection containing only the strings within the provided
     *     collection which are valid identifiers.
     */
    protected Collection<String> filterIdentifiers(Collection<String> identifiers) {

        // Obtain enough space for a full copy of the given identifiers
        Collection<String> validIdentifiers = new ArrayList<String>(identifiers.size());

        // Add only valid identifiers to the copy
        for (String identifier : identifiers) {
            if (isValidIdentifier(identifier))
                validIdentifiers.add(identifier);
        }

        return validIdentifiers;

    }

        identifiers = filterIdentifiers(identifiers);
    @Override
    protected boolean isValidIdentifier(String identifier) {

        // All strings are valid user identifiers
        return true;

    }

    /**
     * Returns whether the given string is a valid identifier within the JDBC
     * authentication extension. Invalid identifiers may result in SQL errors
     * from the underlying database when used in queries.
     *
     * @param identifier
     *     The string to check for validity.
     *
     * @return
     *     true if the given string is a valid identifier, false otherwise.
     */
    protected boolean isValidIdentifier(String identifier) {

        // Empty identifiers are invalid
        if (identifier.isEmpty())
            return false;

        // Identifier is invalid if any non-numeric characters are present
        for (int i = 0; i < identifier.length(); i) {
            if (!Character.isDigit(identifier.charAt(i)))
                return false;
        }

        // Identifier is valid - contains only numeric characters
        return true;

    }

    /**
     * Filters the given collection of strings, returning a new collection
     * containing only those strings which are valid identifiers. If no strings
     * within the collection are valid identifiers, the returned collection will
     * simply be empty.
     *
     * @param identifiers
     *     The collection of strings to filter.
     *
     * @return
     *     A new collection containing only the strings within the provided
     *     collection which are valid identifiers.
     */
    protected Collection<String> filterIdentifiers(Collection<String> identifiers) {

        // Obtain enough space for a full copy of the given identifiers
        Collection<String> validIdentifiers = new ArrayList<String>(identifiers.size());

        // Add only valid identifiers to the copy
        for (String identifier : identifiers) {
            if (isValidIdentifier(identifier))
                validIdentifiers.add(identifier);
        }

        return validIdentifiers;

    }

        identifiers = filterIdentifiers(identifiers);
    @Override
    protected boolean isValidIdentifier(String identifier) {

        // All strings are valid user identifiers
        return true;

    }

            AuthenticatedUser authenticatedUser, Credentials credentials)
            throws GuacamoleException {
            AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {
     * @param credentials
     *     The credentials which were most recently submitted. These are not
     *     guaranteed to be the same as the credentials associated with the
     *     AuthenticatedUser when they originally authenticated.
     *
            AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException;
        AuthenticatedUser authorizedUser, Credentials credentials)
            throws GuacamoleException {
            AuthenticatedUser authenticatedUser, Credentials credentials)
        return authProvider.updateUserContext(context, authenticatedUser, credentials);
     * @param credentials
     *     The Credentials provided by the user in the most recent
     *     authentication attempt.
     *
            AuthenticatedUser authenticatedUser, Credentials credentials)
            throws GuacamoleException {
                UserContext userContext = authProvider.updateUserContext(oldUserContext, authenticatedUser, credentials);
        List<UserContext> userContexts = getUserContexts(existingSession, authenticatedUser, credentials);
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
import org.apache.guacamole.auth.jdbc.sharing.user.SharedAuthenticatedUser;
     * Returns a SharedAuthenticatedUser if the given credentials contain a
     * valid share key. The returned user will be associated with the single
     * shared connection to which they have been granted temporary access. If
     * the share key is invalid, or no share key is contained within the given
     * credentials, null is returned.
     *     A SharedAuthenticatedUser with access to a single shared connection,
     *     if the share key within the given credentials is valid, or null if
     *     the share key is invalid or absent.
    public SharedAuthenticatedUser retrieveSharedConnectionUser(
        // Validate the share key
        if (connectionMap.get(shareKey) == null)
        // Return temporary in-memory user
        return new SharedAuthenticatedUser(authProvider, credentials, shareKey);
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
import org.apache.guacamole.auth.jdbc.sharing.user.SharedAuthenticatedUser;
import org.apache.guacamole.auth.jdbc.sharing.user.SharedUserContext;
 * creation of corresponding UserContexts. The created UserContext objects are
 * restricted to the connections associated with those share keys via a common
     * Provider for retrieving SharedUserContext instances.
    private Provider<SharedUserContext> sharedUserContextProvider;
    public SharedUserContext getUserContext(
        // Obtain a reference to a correct AuthenticatedUser which can be used
        // for accessing shared connections
        SharedAuthenticatedUser sharedAuthenticatedUser;
        if (authenticatedUser instanceof SharedAuthenticatedUser)
            sharedAuthenticatedUser = (SharedAuthenticatedUser) authenticatedUser;
        else
            sharedAuthenticatedUser = new SharedAuthenticatedUser(authenticatedUser);
        // Produce empty user context for known-authenticated user
        SharedUserContext context = sharedUserContextProvider.get();
        context.init(authenticationProvider, sharedAuthenticatedUser);

        // Add the shared connection associated with the originally-provided
        // share key (if any)
        String shareKey = sharedAuthenticatedUser.getShareKey();
        if (shareKey != null)
            context.registerShareKey(shareKey);

        return context;
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;

 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/sharing/connection/SharedConnection.java
package org.apache.guacamole.auth.jdbc.sharing.connection;
import org.apache.guacamole.auth.jdbc.sharing.connectiongroup.SharedRootConnectionGroup;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
    private RemoteAuthenticatedUser user;
    public void init(RemoteAuthenticatedUser user, SharedConnectionDefinition definition) {
        return definition.getShareKey();
        return SharedRootConnectionGroup.IDENTIFIER;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/sharing/connection/SharedConnectionDefinition.java
package org.apache.guacamole.auth.jdbc.sharing.connection;
import org.apache.guacamole.auth.jdbc.sharing.SharedObjectManager;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/sharing/user/SharedUserContext.java
package org.apache.guacamole.auth.jdbc.sharing.user;
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDirectory;
import org.apache.guacamole.auth.jdbc.sharing.connectiongroup.SharedRootConnectionGroup;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
 * The user context of a SharedUser, providing access ONLY to the user
 * themselves, the any SharedConnections associated with that user via share
 * keys, and an internal root connection group containing only those
 * connections.
public class SharedUserContext implements UserContext {
     * The AuthenticationProvider that created this SharedUserContext.
    @Inject
    private SharedConnectionDirectory connectionDirectory;
     * Creates a new SharedUserContext which provides access ONLY to the given
     * user, the SharedConnections associated with the share keys used by that
     * user, and an internal root connection group containing only those
     * SharedConnections.
     *
     * @param authProvider
     *     The AuthenticationProvider that created this
     *     SharedUserContext;
     *     The RemoteAuthenticatedUser for whom this SharedUserContext is being
     *     created.
    public void init(AuthenticationProvider authProvider, RemoteAuthenticatedUser user) {
        this.authProvider = authProvider;
        // Provide access to all connections shared with the given user
        this.connectionDirectory.init(user);
        this.rootGroup = new SharedRootConnectionGroup(this);
        this.self = new SharedUser(user, this);
    /**
     * Registers a new share key with this SharedUserContext such that the user
     * will have access to the connection associated with that share key. The
     * share key will be automatically de-registered when it is no longer valid.
     *
     * @param shareKey
     *     The share key to register.
     */
    public void registerShareKey(String shareKey) {
        connectionDirectory.registerShareKey(shareKey);
    }

import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
    public GuacamoleTunnel getGuacamoleTunnel(RemoteAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
    GuacamoleTunnel getGuacamoleTunnel(RemoteAuthenticatedUser user,
    /**
     * Returns an updated UserContext instance for the given
     * already-authenticated user. If no changes need be made to the
     * UserContext, the original UserContext will be returned.
     *
     * @param authenticationProvider
     *     The AuthenticationProvider on behalf of which the UserContext is
     *     being updated.
     *
     * @param context
     *     The UserContext to update.
     *
     * @param authenticatedUser
     *     The AuthenticatedUser associated with the UserContext being updated.
     *
     * @param credentials
     *     The credentials most recently submitted by the user. These
     *     credentials are not guaranteed to be the same as the credentials
     *     already associated with the AuthenticatedUser.
     *
     * @return
     *     A new UserContext instance for the user identified by the given
     *     credentials.
     *
     * @throws GuacamoleException
     *     If an error occurs during authentication, or if the given
     *     credentials are invalid or expired.
     */
    public UserContext updateUserContext(AuthenticationProvider authenticationProvider,
            UserContext context, AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException;

        return authProviderService.updateUserContext(this, context,
                authenticatedUser, credentials);
import org.apache.guacamole.net.auth.UserContext;
    @Override
    public UserContext updateUserContext(AuthenticationProvider authenticationProvider,
            UserContext context, AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // No need to update the context
        return context;

    }

     * Returns the share key contained within the given credentials. If there is
     * no such share key, null is returned.
     *
     * @param credentials
     *     The credentials from which the share key should be retrieved.
     *
     * @return
     *     The share key contained within the given credentials, or null if
     *     the credentials do not contain a share key.
     */
    public String getShareKey(Credentials credentials) {

        // Pull associated HTTP request
        HttpServletRequest request = credentials.getRequest();
        if (request == null)
            return null;

        // Retrieve the share key from the request
        return request.getParameter(SHARE_KEY_NAME);

    }

    /**
        String shareKey = getShareKey(credentials);
        if (shareKey == null || connectionMap.get(shareKey) == null)
import org.apache.guacamole.net.auth.UserContext;
    @Override
    public UserContext updateUserContext(AuthenticationProvider authenticationProvider,
            UserContext context, AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // Retrieve the share key from the request
        String shareKey = sharingService.getShareKey(credentials);

        // Update the user context with the share key, if given
        if (shareKey != null)
            ((SharedUserContext) context).registerShareKey(shareKey);

        return context;

    }

     * The name of the attribute which contains the username of the user that
     * shared this connection.
     */
    public static final String CONNECTION_OWNER = "jdbc-shared-by";

    /**
        String sharedBy = definition.getActiveConnection().getUser().getIdentifier();
        return Collections.<String, String>singletonMap(CONNECTION_OWNER, sharedBy);
        // Do nothing - changing attributes not supported
        return definition.getActiveConnection().getConnection().getName();
        return Type.ORGANIZATIONAL;
    /**
     * Returns an updated UserContext instance for the given
     * already-authenticated user. If no changes need be made to the
     * UserContext, the original UserContext will be returned.
     *
     * @param authenticationProvider
     *     The AuthenticationProvider on behalf of which the UserContext is
     *     being updated.
     *
     * @param context
     *     The UserContext to update.
     *
     * @param authenticatedUser
     *     The AuthenticatedUser associated with the UserContext being updated.
     *
     * @param credentials
     *     The credentials most recently submitted by the user. These
     *     credentials are not guaranteed to be the same as the credentials
     *     already associated with the AuthenticatedUser.
     *
     * @return
     *     A new UserContext instance for the user identified by the given
     *     credentials.
     *
     * @throws GuacamoleException
     *     If an error occurs during authentication, or if the given
     *     credentials are invalid or expired.
     */
    public UserContext updateUserContext(AuthenticationProvider authenticationProvider,
            UserContext context, AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException;

        return authProviderService.updateUserContext(this, context,
                authenticatedUser, credentials);
import org.apache.guacamole.net.auth.UserContext;
    @Override
    public UserContext updateUserContext(AuthenticationProvider authenticationProvider,
            UserContext context, AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // No need to update the context
        return context;

    }

import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
import org.apache.guacamole.auth.jdbc.sharing.user.SharedAuthenticatedUser;
     * Returns the share key contained within the given credentials. If there is
     * no such share key, null is returned.
     *
     * @param credentials
     *     The credentials from which the share key should be retrieved.
     *
     * @return
     *     The share key contained within the given credentials, or null if
     *     the credentials do not contain a share key.
     */
    public String getShareKey(Credentials credentials) {

        // Pull associated HTTP request
        HttpServletRequest request = credentials.getRequest();
        if (request == null)
            return null;

        // Retrieve the share key from the request
        return request.getParameter(SHARE_KEY_NAME);

    }

    /**
     * Returns a SharedAuthenticatedUser if the given credentials contain a
     * valid share key. The returned user will be associated with the single
     * shared connection to which they have been granted temporary access. If
     * the share key is invalid, or no share key is contained within the given
     * credentials, null is returned.
     *     A SharedAuthenticatedUser with access to a single shared connection,
     *     if the share key within the given credentials is valid, or null if
     *     the share key is invalid or absent.
    public SharedAuthenticatedUser retrieveSharedConnectionUser(
        // Validate the share key
        String shareKey = getShareKey(credentials);
        if (shareKey == null || connectionMap.get(shareKey) == null)
        // Return temporary in-memory user
        return new SharedAuthenticatedUser(authProvider, credentials, shareKey);
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
import org.apache.guacamole.auth.jdbc.sharing.user.SharedAuthenticatedUser;
import org.apache.guacamole.auth.jdbc.sharing.user.SharedUserContext;
import org.apache.guacamole.net.auth.UserContext;
 * creation of corresponding UserContexts. The created UserContext objects are
 * restricted to the connections associated with those share keys via a common
     * Provider for retrieving SharedUserContext instances.
    private Provider<SharedUserContext> sharedUserContextProvider;
    public SharedUserContext getUserContext(
        // Obtain a reference to a correct AuthenticatedUser which can be used
        // for accessing shared connections
        SharedAuthenticatedUser sharedAuthenticatedUser;
        if (authenticatedUser instanceof SharedAuthenticatedUser)
            sharedAuthenticatedUser = (SharedAuthenticatedUser) authenticatedUser;
        else
            sharedAuthenticatedUser = new SharedAuthenticatedUser(authenticatedUser);
        // Produce empty user context for known-authenticated user
        SharedUserContext context = sharedUserContextProvider.get();
        context.init(authenticationProvider, sharedAuthenticatedUser);

        // Add the shared connection associated with the originally-provided
        // share key (if any)
        String shareKey = sharedAuthenticatedUser.getShareKey();
        if (shareKey != null)
            context.registerShareKey(shareKey);

        return context;

    }

    @Override
    public UserContext updateUserContext(AuthenticationProvider authenticationProvider,
            UserContext context, AuthenticatedUser authenticatedUser,
            Credentials credentials) throws GuacamoleException {

        // Retrieve the share key from the request
        String shareKey = sharingService.getShareKey(credentials);

        // Update the user context with the share key, if given
        if (shareKey != null)
            ((SharedUserContext) context).registerShareKey(shareKey);

        return context;
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;

 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/sharing/connection/SharedConnection.java
package org.apache.guacamole.auth.jdbc.sharing.connection;
import org.apache.guacamole.auth.jdbc.sharing.connectiongroup.SharedRootConnectionGroup;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
     * The name of the attribute which contains the username of the user that
     * shared this connection.
     */
    public static final String CONNECTION_OWNER = "jdbc-shared-by";

    /**
    private RemoteAuthenticatedUser user;
    public void init(RemoteAuthenticatedUser user, SharedConnectionDefinition definition) {
        return definition.getShareKey();
        return definition.getActiveConnection().getConnection().getName();
        return SharedRootConnectionGroup.IDENTIFIER;
        String sharedBy = definition.getActiveConnection().getUser().getIdentifier();
        return Collections.<String, String>singletonMap(CONNECTION_OWNER, sharedBy);
        // Do nothing - changing attributes not supported
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/sharing/connection/SharedConnectionDefinition.java
package org.apache.guacamole.auth.jdbc.sharing.connection;
import org.apache.guacamole.auth.jdbc.sharing.SharedObjectManager;
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/sharing/user/SharedUserContext.java
package org.apache.guacamole.auth.jdbc.sharing.user;
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDirectory;
import org.apache.guacamole.auth.jdbc.sharing.connectiongroup.SharedRootConnectionGroup;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
 * The user context of a SharedUser, providing access ONLY to the user
 * themselves, the any SharedConnections associated with that user via share
 * keys, and an internal root connection group containing only those
 * connections.
public class SharedUserContext implements UserContext {
     * The AuthenticationProvider that created this SharedUserContext.
    @Inject
    private SharedConnectionDirectory connectionDirectory;
     * Creates a new SharedUserContext which provides access ONLY to the given
     * user, the SharedConnections associated with the share keys used by that
     * user, and an internal root connection group containing only those
     * SharedConnections.
     *
     * @param authProvider
     *     The AuthenticationProvider that created this
     *     SharedUserContext;
     *     The RemoteAuthenticatedUser for whom this SharedUserContext is being
     *     created.
    public void init(AuthenticationProvider authProvider, RemoteAuthenticatedUser user) {
        this.authProvider = authProvider;
        // Provide access to all connections shared with the given user
        this.connectionDirectory.init(user);
        this.rootGroup = new SharedRootConnectionGroup(this);
        this.self = new SharedUser(user, this);
    /**
     * Registers a new share key with this SharedUserContext such that the user
     * will have access to the connection associated with that share key. The
     * share key will be automatically de-registered when it is no longer valid.
     *
     * @param shareKey
     *     The share key to register.
     */
    public void registerShareKey(String shareKey) {
        connectionDirectory.registerShareKey(shareKey);
    }

import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
    public GuacamoleTunnel getGuacamoleTunnel(RemoteAuthenticatedUser user,
import org.apache.guacamole.auth.jdbc.sharing.connection.SharedConnectionDefinition;
import org.apache.guacamole.auth.jdbc.user.RemoteAuthenticatedUser;
    GuacamoleTunnel getGuacamoleTunnel(RemoteAuthenticatedUser user,
import java.util.Collection;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
     * All associated sharing profiles. If sharing profiles are not being
     * queried, this may be omitted.
     */
    private Collection<APISharingProfile> sharingProfiles;

    /**
    /**
     * Returns a collection of all associated sharing profiles, or null if
     * sharing profiles have not been queried.
     *
     * @return
     *     A collection of all associated sharing profiles, or null if sharing
     *     profiles have not been queried.
     */
    public Collection<APISharingProfile> getSharingProfiles() {
        return sharingProfiles;
    }

    /**
     * Sets the collection of all associated sharing profiles to the given
     * collection, which may be null if sharing profiles have not been queried.
     *
     * @param sharingProfiles
     *     The collection containing all sharing profiles associated with this
     *     connection, or null if sharing profiles have not been queried.
     */
    public void setSharingProfiles(Collection<APISharingProfile> sharingProfiles) {
        this.sharingProfiles = sharingProfiles;
    }

import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
 * Provides access to the entire tree of connection groups, their
 * connections, and any associated sharing profiles.
     * All connection permissions granted to the user obtaining this tree.
     */
    private final ObjectPermissionSet connectionPermissions;

    /**
     * All sharing profile permissions granted to the user obtaining this tree.
     */
    private final ObjectPermissionSet sharingProfilePermissions;

    /**
     * The directory of all connections visible to the user obtaining this tree.
     */
    private final Directory<Connection> connectionDirectory;

    /**
     * The directory of all connection groups visible to the user obtaining this
     * tree.
     */
    private final Directory<ConnectionGroup> connectionGroupDirectory;

    /**
     * The directory of all sharing profiles visible to the user obtaining this
     * tree.
     */
    private final Directory<SharingProfile> sharingProfileDirectory;

    /**
     * All connections that have been retrieved, stored by their identifiers.
     */
    private final Map<String, APIConnection> retrievedConnections =
            new HashMap<String, APIConnection>();

    /**
                APIConnection apiConnection = new APIConnection(connection);
                retrievedConnections.put(connection.getIdentifier(), apiConnection);
                children.add(apiConnection);

    /**
     * Adds each of the provided sharing profiles to the current tree as
     * children of their respective primary connections. The primary connections
     * must already be added.
     *
     * @param sharingProfiles
     *     The sharing profiles to add to the tree.
     *
     * @throws GuacamoleException
     *     If an error occurs while adding the sharing profiles to the tree.
     */
    private void addSharingProfiles(Collection<SharingProfile> sharingProfiles)
        throws GuacamoleException {

        // Add each sharing profile to the tree
        for (SharingProfile sharingProfile : sharingProfiles) {

            // Retrieve the sharing profile's associated connection
            String primaryConnectionIdentifier = sharingProfile.getPrimaryConnectionIdentifier();
            APIConnection primaryConnection = retrievedConnections.get(primaryConnectionIdentifier);

            // Add the sharing profile as a child of the primary connection
            if (primaryConnection != null) {

                Collection<APISharingProfile> children = primaryConnection.getSharingProfiles();

                // Create child collection if it does not yet exist
                if (children == null) {
                    children = new ArrayList<APISharingProfile>();
                    primaryConnection.setSharingProfiles(children);
                }

                // Add child
                children.add(new APISharingProfile(sharingProfile));

            }

            // Warn of internal consistency issues
            else
                logger.debug("Sharing profile \"{}\" cannot be added to the "
                         "tree: primary connection \"{}\" does not actually "
                         "exist.", sharingProfile.getIdentifier(),
                        primaryConnectionIdentifier);

        } // end for each sharing profile

    }

    private void addConnectionGroupDescendants(Collection<ConnectionGroup> parents,
        if (permissions != null && !permissions.isEmpty())
            childConnectionIdentifiers = connectionPermissions.getAccessibleObjects(
                    permissions, childConnectionIdentifiers);
            Collection<Connection> childConnections = connectionDirectory.getAll(childConnectionIdentifiers);
            addConnectionDescendants(childConnections, permissions);
            Collection<ConnectionGroup> childConnectionGroups = connectionGroupDirectory.getAll(childConnectionGroupIdentifiers);
            addConnectionGroupDescendants(childConnectionGroups, permissions);
        }

    }

    /**
     * Adds all descendant sharing profiles of the given connections to their
     * corresponding primary connections already stored under root.
     *
     * @param connections
     *     The connections whose descendant sharing profiles should be added to
     *     the tree.
     *
     * @param permissions
     *     If specified and non-empty, limit added sharing profiles to only
     *     those for which the current user has any of the given
     *     permissions. Otherwise, all visible sharing profiles are added.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the descendants.
     */
    private void addConnectionDescendants(Collection<Connection> connections,
            List<ObjectPermission.Type> permissions)
        throws GuacamoleException {

        // If no connections, nothing to do
        if (connections.isEmpty())
            return;

        // Build lists of sharing profile identifiers for retrieval
        Collection<String> identifiers = new ArrayList<String>();
        for (Connection connection : connections)
            identifiers.addAll(connection.getSharingProfileIdentifiers());

        // Filter identifiers based on permissions, if requested
        if (permissions != null && !permissions.isEmpty())
            identifiers = sharingProfilePermissions.getAccessibleObjects(
                    permissions, identifiers);

        // Retrieve and add all associated sharing profiles
        if (!identifiers.isEmpty()) {
            Collection<SharingProfile> sharingProfiles = sharingProfileDirectory.getAll(identifiers);
            addSharingProfiles(sharingProfiles);
        // Store user's current permissions
        User self = userContext.self();
        this.connectionPermissions = self.getConnectionPermissions();
        this.sharingProfilePermissions = self.getSharingProfilePermissions();

        // Store required directories
        this.connectionDirectory = userContext.getConnectionDirectory();
        this.connectionGroupDirectory = userContext.getConnectionGroupDirectory();
        this.sharingProfileDirectory = userContext.getSharingProfileDirectory();

        addConnectionGroupDescendants(Collections.singleton(root), permissions);
import java.util.Collection;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
     * All associated sharing profiles. If sharing profiles are not being
     * queried, this may be omitted.
     */
    private Collection<APISharingProfile> sharingProfiles;

    /**
    /**
     * Returns a collection of all associated sharing profiles, or null if
     * sharing profiles have not been queried.
     *
     * @return
     *     A collection of all associated sharing profiles, or null if sharing
     *     profiles have not been queried.
     */
    public Collection<APISharingProfile> getSharingProfiles() {
        return sharingProfiles;
    }

    /**
     * Sets the collection of all associated sharing profiles to the given
     * collection, which may be null if sharing profiles have not been queried.
     *
     * @param sharingProfiles
     *     The collection containing all sharing profiles associated with this
     *     connection, or null if sharing profiles have not been queried.
     */
    public void setSharingProfiles(Collection<APISharingProfile> sharingProfiles) {
        this.sharingProfiles = sharingProfiles;
    }

import org.apache.guacamole.net.auth.Directory;
import org.apache.guacamole.net.auth.SharingProfile;
import org.apache.guacamole.net.auth.User;
import org.apache.guacamole.rest.sharingprofile.APISharingProfile;
 * Provides access to the entire tree of connection groups, their
 * connections, and any associated sharing profiles.
     * All connection permissions granted to the user obtaining this tree.
     */
    private final ObjectPermissionSet connectionPermissions;

    /**
     * All sharing profile permissions granted to the user obtaining this tree.
     */
    private final ObjectPermissionSet sharingProfilePermissions;

    /**
     * The directory of all connections visible to the user obtaining this tree.
     */
    private final Directory<Connection> connectionDirectory;

    /**
     * The directory of all connection groups visible to the user obtaining this
     * tree.
     */
    private final Directory<ConnectionGroup> connectionGroupDirectory;

    /**
     * The directory of all sharing profiles visible to the user obtaining this
     * tree.
     */
    private final Directory<SharingProfile> sharingProfileDirectory;

    /**
     * All connections that have been retrieved, stored by their identifiers.
     */
    private final Map<String, APIConnection> retrievedConnections =
            new HashMap<String, APIConnection>();

    /**
                APIConnection apiConnection = new APIConnection(connection);
                retrievedConnections.put(connection.getIdentifier(), apiConnection);
                children.add(apiConnection);

    /**
     * Adds each of the provided sharing profiles to the current tree as
     * children of their respective primary connections. The primary connections
     * must already be added.
     *
     * @param sharingProfiles
     *     The sharing profiles to add to the tree.
     *
     * @throws GuacamoleException
     *     If an error occurs while adding the sharing profiles to the tree.
     */
    private void addSharingProfiles(Collection<SharingProfile> sharingProfiles)
        throws GuacamoleException {

        // Add each sharing profile to the tree
        for (SharingProfile sharingProfile : sharingProfiles) {

            // Retrieve the sharing profile's associated connection
            String primaryConnectionIdentifier = sharingProfile.getPrimaryConnectionIdentifier();
            APIConnection primaryConnection = retrievedConnections.get(primaryConnectionIdentifier);

            // Add the sharing profile as a child of the primary connection
            if (primaryConnection != null) {

                Collection<APISharingProfile> children = primaryConnection.getSharingProfiles();

                // Create child collection if it does not yet exist
                if (children == null) {
                    children = new ArrayList<APISharingProfile>();
                    primaryConnection.setSharingProfiles(children);
                }

                // Add child
                children.add(new APISharingProfile(sharingProfile));

            }

            // Warn of internal consistency issues
            else
                logger.debug("Sharing profile \"{}\" cannot be added to the "
                         "tree: primary connection \"{}\" does not actually "
                         "exist.", sharingProfile.getIdentifier(),
                        primaryConnectionIdentifier);

        } // end for each sharing profile

    }

    private void addConnectionGroupDescendants(Collection<ConnectionGroup> parents,
        if (permissions != null && !permissions.isEmpty())
            childConnectionIdentifiers = connectionPermissions.getAccessibleObjects(
                    permissions, childConnectionIdentifiers);
            Collection<Connection> childConnections = connectionDirectory.getAll(childConnectionIdentifiers);
            addConnectionDescendants(childConnections, permissions);
            Collection<ConnectionGroup> childConnectionGroups = connectionGroupDirectory.getAll(childConnectionGroupIdentifiers);
            addConnectionGroupDescendants(childConnectionGroups, permissions);
        }

    }

    /**
     * Adds all descendant sharing profiles of the given connections to their
     * corresponding primary connections already stored under root.
     *
     * @param connections
     *     The connections whose descendant sharing profiles should be added to
     *     the tree.
     *
     * @param permissions
     *     If specified and non-empty, limit added sharing profiles to only
     *     those for which the current user has any of the given
     *     permissions. Otherwise, all visible sharing profiles are added.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the descendants.
     */
    private void addConnectionDescendants(Collection<Connection> connections,
            List<ObjectPermission.Type> permissions)
        throws GuacamoleException {

        // If no connections, nothing to do
        if (connections.isEmpty())
            return;

        // Build lists of sharing profile identifiers for retrieval
        Collection<String> identifiers = new ArrayList<String>();
        for (Connection connection : connections)
            identifiers.addAll(connection.getSharingProfileIdentifiers());

        // Filter identifiers based on permissions, if requested
        if (permissions != null && !permissions.isEmpty())
            identifiers = sharingProfilePermissions.getAccessibleObjects(
                    permissions, identifiers);

        // Retrieve and add all associated sharing profiles
        if (!identifiers.isEmpty()) {
            Collection<SharingProfile> sharingProfiles = sharingProfileDirectory.getAll(identifiers);
            addSharingProfiles(sharingProfiles);
        // Store user's current permissions
        User self = userContext.self();
        this.connectionPermissions = self.getConnectionPermissions();
        this.sharingProfilePermissions = self.getSharingProfilePermissions();

        // Store required directories
        this.connectionDirectory = userContext.getConnectionDirectory();
        this.connectionGroupDirectory = userContext.getConnectionGroupDirectory();
        this.sharingProfileDirectory = userContext.getSharingProfileDirectory();

        addConnectionGroupDescendants(Collections.singleton(root), permissions);
     * Retrieves the possible attributes of a sharing profile object.
     *
     * @return
     *     A collection of forms which describe the possible attributes of a
     *     sharing profile object.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the possible attributes.
     */
    @GET
    @Path("sharingProfileAttributes")
    public Collection<Form> getSharingProfileAttributes()
            throws GuacamoleException {

        // Retrieve all possible sharing profile attributes
        return userContext.getSharingProfileAttributes();

    }

    /**
 * Describes a protocol and all parameters associated with it, as required by
 * a protocol plugin for guacd. Each parameter is described with a Form, which
 * allows the parameters of a protocol to be exposed to the user as friendly
 * groupings of fields.
     * A collection of forms describing all known parameters for a connection
     * using this protocol.
    private Collection<Form> connectionForms;

    /**
     * A collection of forms describing all known parameters relevant to a
     * sharing profile whose primary connection uses this protocol.
     */
    private Collection<Form> sharingProfileForms;

    /**
     * Creates a new ProtocolInfo having the given name and forms. The given
     * collections of forms are used to describe the parameters for connections
     * and sharing profiles respectively.
     *
     * @param name
     *     The unique name associated with the protocol.
     *
     * @param connectionForms
     *     A collection of forms describing all known parameters for a
     *     connection using this protocol.
     *
     * @param sharingProfileForms
     *     A collection of forms describing all known parameters relevant to a
     *     sharing profile whose primary connection uses this protocol.
     */
    public ProtocolInfo(String name, Collection<Form> connectionForms,
            Collection<Form> sharingProfileForms) {
        this.name = name;
        this.connectionForms = connectionForms;
        this.sharingProfileForms = sharingProfileForms;
    }
        this(null);
        this(name, new ArrayList<Form>());
     * Creates a new ProtocolInfo having the given name and forms. The given
     * forms are used to describe the parameters for both connections and
     * sharing profiles.
     *     A collection of forms describing all known parameters for this
     *     protocol, regardless of whether it is used in the context of a
     *     connection or a sharing profile.
        this(name, forms, new ArrayList<Form>(forms));
     * Returns a mutable collection of forms describing all known parameters for
     * a connection using this protocol. Changes to this collection affect the
     * forms exposed to the user.
     * @return
     *     A mutable collection of forms describing all known parameters for a
     *     connection using this protocol.
    public Collection<Form> getConnectionForms() {
        return connectionForms;
     * Sets the collection of forms describing all known parameters for a
     * connection using this protocol. The provided collection must be mutable.
     * @param connectionForms
     *     A mutable collection of forms describing all known parameters for a
     *     connection using this protocol.
    public void setConnectionForms(Collection<Form> connectionForms) {
        this.connectionForms = connectionForms;

    /**
     * Returns a mutable collection of forms describing all known parameters
     * relevant to a sharing profile whose primary connection uses this
     * protocol. Changes to this collection affect the forms exposed to the
     * user.
     *
     * @return
     *     A mutable collection of forms describing all known parameters
     *     relevant to a sharing profile whose primary connection uses this
     *     protocol.
     */
    public Collection<Form> getSharingProfileForms() {
        return sharingProfileForms;
    }

    /**
     * Sets the collection of forms describing all known parameters relevant to
     * a sharing profile whose primary connection uses this protocol. The
     * provided collection must be mutable.
     *
     * @param sharingProfileForms
     *     A mutable collection of forms describing all known parameters
     *     relevant to a sharing profile whose primary connection uses this
     *     protocol.
     */
    public void setSharingProfileForms(Collection<Form> sharingProfileForms) {
        this.sharingProfileForms = sharingProfileForms;
    }

     * Retrieves the possible attributes of a sharing profile object.
     *
     * @return
     *     A collection of forms which describe the possible attributes of a
     *     sharing profile object.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the possible attributes.
     */
    @GET
    @Path("sharingProfileAttributes")
    public Collection<Form> getSharingProfileAttributes()
            throws GuacamoleException {

        // Retrieve all possible sharing profile attributes
        return userContext.getSharingProfileAttributes();

    }

    /**
 * Describes a protocol and all parameters associated with it, as required by
 * a protocol plugin for guacd. Each parameter is described with a Form, which
 * allows the parameters of a protocol to be exposed to the user as friendly
 * groupings of fields.
     * A collection of forms describing all known parameters for a connection
     * using this protocol.
    private Collection<Form> connectionForms;

    /**
     * A collection of forms describing all known parameters relevant to a
     * sharing profile whose primary connection uses this protocol.
     */
    private Collection<Form> sharingProfileForms;

    /**
     * Creates a new ProtocolInfo having the given name and forms. The given
     * collections of forms are used to describe the parameters for connections
     * and sharing profiles respectively.
     *
     * @param name
     *     The unique name associated with the protocol.
     *
     * @param connectionForms
     *     A collection of forms describing all known parameters for a
     *     connection using this protocol.
     *
     * @param sharingProfileForms
     *     A collection of forms describing all known parameters relevant to a
     *     sharing profile whose primary connection uses this protocol.
     */
    public ProtocolInfo(String name, Collection<Form> connectionForms,
            Collection<Form> sharingProfileForms) {
        this.name = name;
        this.connectionForms = connectionForms;
        this.sharingProfileForms = sharingProfileForms;
    }
        this(null);
        this(name, new ArrayList<Form>());
     * Creates a new ProtocolInfo having the given name and forms. The given
     * forms are used to describe the parameters for both connections and
     * sharing profiles.
     *     A collection of forms describing all known parameters for this
     *     protocol, regardless of whether it is used in the context of a
     *     connection or a sharing profile.
        this(name, forms, new ArrayList<Form>(forms));
     * Returns a mutable collection of forms describing all known parameters for
     * a connection using this protocol. Changes to this collection affect the
     * forms exposed to the user.
     * @return
     *     A mutable collection of forms describing all known parameters for a
     *     connection using this protocol.
    public Collection<Form> getConnectionForms() {
        return connectionForms;
     * Sets the collection of forms describing all known parameters for a
     * connection using this protocol. The provided collection must be mutable.
     * @param connectionForms
     *     A mutable collection of forms describing all known parameters for a
     *     connection using this protocol.
    public void setConnectionForms(Collection<Form> connectionForms) {
        this.connectionForms = connectionForms;

    /**
     * Returns a mutable collection of forms describing all known parameters
     * relevant to a sharing profile whose primary connection uses this
     * protocol. Changes to this collection affect the forms exposed to the
     * user.
     *
     * @return
     *     A mutable collection of forms describing all known parameters
     *     relevant to a sharing profile whose primary connection uses this
     *     protocol.
     */
    public Collection<Form> getSharingProfileForms() {
        return sharingProfileForms;
    }

    /**
     * Sets the collection of forms describing all known parameters relevant to
     * a sharing profile whose primary connection uses this protocol. The
     * provided collection must be mutable.
     *
     * @param sharingProfileForms
     *     A mutable collection of forms describing all known parameters
     *     relevant to a sharing profile whose primary connection uses this
     *     protocol.
     */
    public void setSharingProfileForms(Collection<Form> sharingProfileForms) {
        this.sharingProfileForms = sharingProfileForms;
    }

public class SecureRandomShareKeyGenerator extends SecureRandom
        implements ShareKeyGenerator {
     * The length of each generated share key, in base64-digits.
    private static final int KEY_LENGTH = 44;

    /**
     * The character representations of each possible base64 digit. This class
     * uses the URL-safe variant of base64 (also known as "base64url"), which
     * uses '-' and '_' instead of '' and '/' for digits 62 and 63
     * respectively. See RFC 4648, Section 5: "Base 64 Encoding with URL and
     * Filename Safe Alphabet" (https://tools.ietf.org/html/rfc4648#section-5).
     */
    private static final char[] URL_SAFE_BASE64_DIGITS = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'
    };

        // Produce storage space for required share key length
        char[] key = new char[KEY_LENGTH];

        // Fill key with random digits
        for (int i = 0; i < KEY_LENGTH; i)
            key[i] = URL_SAFE_BASE64_DIGITS[next(6)];

        return new String(key);

     * The identifier reserved for representing a user that has authenticated
     * anonymously.
     */
    public static final String ANONYMOUS_IDENTIFIER = "";

    /**
     * of the user will be the standard identifier for anonymous users as
     * defined by the Guacamole extension API.
        this.identifier = AuthenticatedUser.ANONYMOUS_IDENTIFIER;
public class SecureRandomShareKeyGenerator extends SecureRandom
        implements ShareKeyGenerator {
     * The length of each generated share key, in base64-digits.
    private static final int KEY_LENGTH = 44;

    /**
     * The character representations of each possible base64 digit. This class
     * uses the URL-safe variant of base64 (also known as "base64url"), which
     * uses '-' and '_' instead of '' and '/' for digits 62 and 63
     * respectively. See RFC 4648, Section 5: "Base 64 Encoding with URL and
     * Filename Safe Alphabet" (https://tools.ietf.org/html/rfc4648#section-5).
     */
    private static final char[] URL_SAFE_BASE64_DIGITS = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'
    };

        // Produce storage space for required share key length
        char[] key = new char[KEY_LENGTH];

        // Fill key with random digits
        for (int i = 0; i < KEY_LENGTH; i)
            key[i] = URL_SAFE_BASE64_DIGITS[next(6)];

        return new String(key);

     * of the user will be the standard identifier for anonymous users as
     * defined by the Guacamole extension API.
        this.identifier = AuthenticatedUser.ANONYMOUS_IDENTIFIER;
     * The identifier reserved for representing a user that has authenticated
     * anonymously.
     */
    public static final String ANONYMOUS_IDENTIFIER = "";

    /**
    /**
     * Returns maximum number of results a LDAP query can return,
     * as configured with guacamole.properties.
     * By default, this will be 1000.
     *
     * @return
     *     The maximum number of results a LDAP query can return,
     *     as configured with guacamole.properties.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed.
     */
    public int getMaxResults() throws GuacamoleException {
        return environment.getProperty(
            LDAPGuacamoleProperties.LDAP_MAX_SEARCH_RESULTS,
            1000 
        );
    }

    /**
     * The maximum number of results a LDAP query can return.
     */
    public static final IntegerGuacamoleProperty LDAP_MAX_SEARCH_RESULTS = new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "ldap-max-search-results"; }

    };

import com.novell.ldap.LDAPSearchConstraints;
            // Set search limits
            LDAPSearchConstraints constraints = new LDAPSearchConstraints();
            constraints.setMaxResults(confService.getMaxResults());
                false,
                constraints
import java.util.HashSet;
import java.util.Set;
     * The identifiers of all readable sharing profiles associated with this
     * connection.
     */
    private Set<String> sharingProfileIdentifiers = new HashSet<String>();

    /**
    /**
     * Returns the identifiers of all readable sharing profiles associated with
     * this connection. This is set only when the connection is queried, and has
     * no effect when a connection is inserted, updated, or deleted.
     *
     * @return
     *     The identifiers of all readable sharing profiles associated with
     *     this connection.
     */
    public Set<String> getSharingProfileIdentifiers() {
        return sharingProfileIdentifiers;
    }

    /**
     * Sets the identifiers of all readable sharing profiles associated with
     * this connection. This should be set only when the connection is queried,
     * as it has no effect when a connection is inserted, updated, or deleted.
     *
     * @param sharingProfileIdentifiers
     *     The identifiers of all readable sharing profiles associated with
     *     this connection.
     */
    public void setSharingProfileIdentifiers(Set<String> sharingProfileIdentifiers) {
        this.sharingProfileIdentifiers = sharingProfileIdentifiers;
    }

        return getModel().getSharingProfileIdentifiers();
import java.util.HashSet;
import java.util.Set;
     * The identifiers of all readable child connections within this connection
     * group.
     */
    private Set<String> connectionIdentifiers = new HashSet<String>();

    /**
     * The identifiers of all readable child connection groups within this
     * connection group.
     */
    private Set<String> connectionGroupIdentifiers = new HashSet<String>();

    /**
    /**
     * Returns the identifiers of all readable child connections within this
     * connection group. This is set only when the parent connection group is
     * queried, and has no effect when a connection group is inserted, updated,
     * or deleted.
     *
     * @return
     *     The identifiers of all readable child connections within this
     *     connection group.
     */
    public Set<String> getConnectionIdentifiers() {
        return connectionIdentifiers;
    }

    /**
     * Sets the identifiers of all readable child connections within this
     * connection group. This should be set only when the parent connection
     * group is queried, as it has no effect when a connection group is
     * inserted, updated, or deleted.
     *
     * @param connectionIdentifiers
     *     The identifiers of all readable child connections within this
     *     connection group.
     */
    public void setConnectionIdentifiers(Set<String> connectionIdentifiers) {
        this.connectionIdentifiers = connectionIdentifiers;
    }

    /**
     * Returns the identifiers of all readable child connection groups within
     * this connection group. This is set only when the parent connection group
     * is queried, and has no effect when a connection group is inserted,
     * updated, or deleted.
     *
     * @return
     *     The identifiers of all readable child connection groups within this
     *     connection group.
     */
    public Set<String> getConnectionGroupIdentifiers() {
        return connectionGroupIdentifiers;
    }

    /**
     * Sets the identifiers of all readable child connection groups within this
     * connection group. This should be set only when the parent connection
     * group is queried, as it has no effect when a connection group is
     * inserted, updated, or deleted.
     *
     * @param connectionGroupIdentifiers
     *     The identifiers of all readable child connection groups within this
     *     connection group.
     */
    public void setConnectionGroupIdentifiers(Set<String> connectionGroupIdentifiers) {
        this.connectionGroupIdentifiers = connectionGroupIdentifiers;
    }

        return getModel().getConnectionIdentifiers();
        return getModel().getConnectionGroupIdentifiers();
        // Allow use of multiple statements within a single query
        driverProperties.setProperty("allowMultiQueries", "true");
        driverProperties.setProperty("characterEncoding", "UTF-8");
        // Bind JDBC driver properties
        driverProperties.setProperty("characterEncoding", "UTF-8");
        // Bind JDBC driver properties
import org.apache.guacamole.rest.directory.DirectoryObjectResource;
import org.apache.guacamole.rest.directory.DirectoryObjectResourceFactory;
     * Factory for creating DirectoryObjectResources which expose a given User.
     */
    @Inject
    private DirectoryObjectResourceFactory<User, APIUser> userResourceFactory;

    /**
     * Returns a new resource which represents the User whose access rights
     * control the operations of the UserContext exposed by this
     * UserContextResource.
     *
     * @return
     *     A new resource which represents the User whose access rights
     *     control the operations of the UserContext exposed by this
     *     UserContextResource.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the User.
     */
    @Path("self")
    public DirectoryObjectResource<User, APIUser> getSelfResource()
            throws GuacamoleException {
        return userResourceFactory.create(userContext,
                userContext.getUserDirectory(), userContext.self());
    }

    /**
        // Create internal pseudo-account representing the authenticated user

        // Do not provide access to any user accounts via the directory
        this.userDirectory = new SimpleDirectory<User>();
import java.util.HashSet;
import java.util.Set;
     * The identifiers of all readable sharing profiles associated with this
     * connection.
     */
    private Set<String> sharingProfileIdentifiers = new HashSet<String>();

    /**
    /**
     * Returns the identifiers of all readable sharing profiles associated with
     * this connection. This is set only when the connection is queried, and has
     * no effect when a connection is inserted, updated, or deleted.
     *
     * @return
     *     The identifiers of all readable sharing profiles associated with
     *     this connection.
     */
    public Set<String> getSharingProfileIdentifiers() {
        return sharingProfileIdentifiers;
    }

    /**
     * Sets the identifiers of all readable sharing profiles associated with
     * this connection. This should be set only when the connection is queried,
     * as it has no effect when a connection is inserted, updated, or deleted.
     *
     * @param sharingProfileIdentifiers
     *     The identifiers of all readable sharing profiles associated with
     *     this connection.
     */
    public void setSharingProfileIdentifiers(Set<String> sharingProfileIdentifiers) {
        this.sharingProfileIdentifiers = sharingProfileIdentifiers;
    }

        return getModel().getSharingProfileIdentifiers();
import java.util.HashSet;
import java.util.Set;
     * The identifiers of all readable child connections within this connection
     * group.
     */
    private Set<String> connectionIdentifiers = new HashSet<String>();

    /**
     * The identifiers of all readable child connection groups within this
     * connection group.
     */
    private Set<String> connectionGroupIdentifiers = new HashSet<String>();

    /**
    /**
     * Returns the identifiers of all readable child connections within this
     * connection group. This is set only when the parent connection group is
     * queried, and has no effect when a connection group is inserted, updated,
     * or deleted.
     *
     * @return
     *     The identifiers of all readable child connections within this
     *     connection group.
     */
    public Set<String> getConnectionIdentifiers() {
        return connectionIdentifiers;
    }

    /**
     * Sets the identifiers of all readable child connections within this
     * connection group. This should be set only when the parent connection
     * group is queried, as it has no effect when a connection group is
     * inserted, updated, or deleted.
     *
     * @param connectionIdentifiers
     *     The identifiers of all readable child connections within this
     *     connection group.
     */
    public void setConnectionIdentifiers(Set<String> connectionIdentifiers) {
        this.connectionIdentifiers = connectionIdentifiers;
    }

    /**
     * Returns the identifiers of all readable child connection groups within
     * this connection group. This is set only when the parent connection group
     * is queried, and has no effect when a connection group is inserted,
     * updated, or deleted.
     *
     * @return
     *     The identifiers of all readable child connection groups within this
     *     connection group.
     */
    public Set<String> getConnectionGroupIdentifiers() {
        return connectionGroupIdentifiers;
    }

    /**
     * Sets the identifiers of all readable child connection groups within this
     * connection group. This should be set only when the parent connection
     * group is queried, as it has no effect when a connection group is
     * inserted, updated, or deleted.
     *
     * @param connectionGroupIdentifiers
     *     The identifiers of all readable child connection groups within this
     *     connection group.
     */
    public void setConnectionGroupIdentifiers(Set<String> connectionGroupIdentifiers) {
        this.connectionGroupIdentifiers = connectionGroupIdentifiers;
    }

        return getModel().getConnectionIdentifiers();
        return getModel().getConnectionGroupIdentifiers();
        driverProperties.setProperty("characterEncoding", "UTF-8");
        // Allow use of multiple statements within a single query
        driverProperties.setProperty("allowMultiQueries", "true");
        // Bind JDBC driver properties
        driverProperties.setProperty("characterEncoding", "UTF-8");
        // Bind JDBC driver properties
        // Create internal pseudo-account representing the authenticated user

        // Do not provide access to any user accounts via the directory
        this.userDirectory = new SimpleDirectory<User>();
import org.apache.guacamole.rest.directory.DirectoryObjectResource;
import org.apache.guacamole.rest.directory.DirectoryObjectResourceFactory;
     * Factory for creating DirectoryObjectResources which expose a given User.
     */
    @Inject
    private DirectoryObjectResourceFactory<User, APIUser> userResourceFactory;

    /**
     * Returns a new resource which represents the User whose access rights
     * control the operations of the UserContext exposed by this
     * UserContextResource.
     *
     * @return
     *     A new resource which represents the User whose access rights
     *     control the operations of the UserContext exposed by this
     *     UserContextResource.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the User.
     */
    @Path("self")
    public DirectoryObjectResource<User, APIUser> getSelfResource()
            throws GuacamoleException {
        return userResourceFactory.create(userContext,
                userContext.getUserDirectory(), userContext.self());
    }

    /**
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ChildObjectModel.java
 * Object representation of a Guacamole object which can be the child of another
 * object, such as a connection or sharing profile, as represented in the
 * database.
public abstract class ChildObjectModel extends ObjectModel {
    public ChildObjectModel() {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ModeledChildDirectoryObject.java
public abstract class ModeledChildDirectoryObject<ModelType extends ChildObjectModel>
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ModeledChildDirectoryObjectService.java
 * manipulating objects that can be children of other objects. This service will
public abstract class ModeledChildDirectoryObjectService<InternalType extends ModeledChildDirectoryObject<ModelType>,
        ExternalType extends Identifiable, ModelType extends ChildObjectModel>
     * Returns the permission set associated with the given user and related
     * to the type of objects which can be parents of the child objects handled
     * by this directory object service.
     *
     * @param user
     *     The user whose permissions are being retrieved.
     *
     * @return
     *     A permission set which contains the permissions associated with the
     *     given user and related to the type of objects which can be parents
     *     of the child objects handled by this directory object service.
     *
     * @throws GuacamoleException
     *     If permission to read the user's permissions is denied.
     */
    protected abstract ObjectPermissionSet getParentPermissionSet(
            ModeledAuthenticatedUser user) throws GuacamoleException;

    /**
     * Returns the set of parent objects that are modified by the given model
     * object (by virtue of the object changing parents). If the model is not
     * changing parents, the resulting collection will be empty.
     *     A collection of the identifiers of all parents that will be affected
     *     (updated) by the change.
     *     If an error occurs while determining which parents are affected.
    protected Collection<String> getModifiedParents(ModeledAuthenticatedUser user,
        // Return collection of all non-root parents involved
        Collection<String> parents = new ArrayList<String>(2);
        if (oldParentIdentifier != null) parents.add(oldParentIdentifier);
        if (parentIdentifier    != null) parents.add(parentIdentifier);
        return parents;
     * Returns whether the given user has permission to modify the parents
     * affected by the modifications made to the given model object.
     *     true if the user has update permission for all modified parents,
     *     If an error occurs while determining which parents are affected.
    protected boolean canUpdateModifiedParents(ModeledAuthenticatedUser user,
        // Verify that we have permission to modify any modified parents
        Collection<String> modifiedParents = getModifiedParents(user, identifier, model);
        if (!modifiedParents.isEmpty()) {
            ObjectPermissionSet permissionSet = getParentPermissionSet(user);
            Collection<String> updateableParents = permissionSet.getAccessibleObjects(
                modifiedParents
            return updateableParents.size() == modifiedParents.size();
        // Validate that we can update all applicable parents
        if (!canUpdateModifiedParents(user, null, model))
        // Validate that we can update all applicable parents
        if (!canUpdateModifiedParents(user, model.getIdentifier(), model))
        // Validate that we can update all applicable parents
        if (!canUpdateModifiedParents(user, identifier, null))
import org.apache.guacamole.auth.jdbc.base.ChildObjectModel;
public class ConnectionModel extends ChildObjectModel {
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObjectService;
public class ConnectionService extends ModeledChildDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
    protected ObjectPermissionSet getParentPermissionSet(ModeledAuthenticatedUser user)
            throws GuacamoleException {

        // Connections are contained by connection groups
        return user.getUser().getConnectionGroupPermissions();

    }

    @Override
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObject;
public class ModeledConnection extends ModeledChildDirectoryObject<ConnectionModel>
import org.apache.guacamole.auth.jdbc.base.ChildObjectModel;
public class ConnectionGroupModel extends ChildObjectModel {
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObjectService;
public class ConnectionGroupService extends ModeledChildDirectoryObjectService<ModeledConnectionGroup,
    protected ObjectPermissionSet getParentPermissionSet(ModeledAuthenticatedUser user)
            throws GuacamoleException {

        // Connection groups are contained by other connection groups
        return user.getUser().getConnectionGroupPermissions();

    }

    @Override
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObject;
public class ModeledConnectionGroup extends ModeledChildDirectoryObject<ConnectionGroupModel>
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObject;
        extends ModeledChildDirectoryObject<SharingProfileModel>
        return getModel().getParentIdentifier();
        getModel().setParentIdentifier(identifier);
     * @param parentIdentifier
            @Param("parentIdentifier") String parentIdentifier,
import org.apache.guacamole.auth.jdbc.base.ChildObjectModel;
public class SharingProfileModel extends ChildObjectModel {
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObjectService;
        extends ModeledChildDirectoryObjectService<ModeledSharingProfile,
    protected ObjectPermissionSet getParentPermissionSet(ModeledAuthenticatedUser user)
            throws GuacamoleException {

        // Sharing profiles are children of connections
        return user.getUser().getConnectionPermissions();

    }

    @Override
        SharingProfileModel existing = sharingProfileMapper.selectOneByName(model.getParentIdentifier(), model.getName());
        SharingProfileModel existing = sharingProfileMapper.selectOneByName(model.getParentIdentifier(), model.getName());
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ChildObjectModel.java
 * Object representation of a Guacamole object which can be the child of another
 * object, such as a connection or sharing profile, as represented in the
 * database.
public abstract class ChildObjectModel extends ObjectModel {
    public ChildObjectModel() {
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ModeledChildDirectoryObject.java
public abstract class ModeledChildDirectoryObject<ModelType extends ChildObjectModel>
 b/extensions/guacamole-auth-jdbc/modules/guacamole-auth-jdbc-base/src/main/java/org/apache/guacamole/auth/jdbc/base/ModeledChildDirectoryObjectService.java
 * manipulating objects that can be children of other objects. This service will
public abstract class ModeledChildDirectoryObjectService<InternalType extends ModeledChildDirectoryObject<ModelType>,
        ExternalType extends Identifiable, ModelType extends ChildObjectModel>
     * Returns the permission set associated with the given user and related
     * to the type of objects which can be parents of the child objects handled
     * by this directory object service.
     *
     * @param user
     *     The user whose permissions are being retrieved.
     *
     * @return
     *     A permission set which contains the permissions associated with the
     *     given user and related to the type of objects which can be parents
     *     of the child objects handled by this directory object service.
     *
     * @throws GuacamoleException
     *     If permission to read the user's permissions is denied.
     */
    protected abstract ObjectPermissionSet getParentPermissionSet(
            ModeledAuthenticatedUser user) throws GuacamoleException;

    /**
     * Returns the set of parent objects that are modified by the given model
     * object (by virtue of the object changing parents). If the model is not
     * changing parents, the resulting collection will be empty.
     *     A collection of the identifiers of all parents that will be affected
     *     (updated) by the change.
     *     If an error occurs while determining which parents are affected.
    protected Collection<String> getModifiedParents(ModeledAuthenticatedUser user,
        // Return collection of all non-root parents involved
        Collection<String> parents = new ArrayList<String>(2);
        if (oldParentIdentifier != null) parents.add(oldParentIdentifier);
        if (parentIdentifier    != null) parents.add(parentIdentifier);
        return parents;
     * Returns whether the given user has permission to modify the parents
     * affected by the modifications made to the given model object.
     *     true if the user has update permission for all modified parents,
     *     If an error occurs while determining which parents are affected.
    protected boolean canUpdateModifiedParents(ModeledAuthenticatedUser user,
        // Verify that we have permission to modify any modified parents
        Collection<String> modifiedParents = getModifiedParents(user, identifier, model);
        if (!modifiedParents.isEmpty()) {
            ObjectPermissionSet permissionSet = getParentPermissionSet(user);
            Collection<String> updateableParents = permissionSet.getAccessibleObjects(
                modifiedParents
            return updateableParents.size() == modifiedParents.size();
        // Validate that we can update all applicable parents
        if (!canUpdateModifiedParents(user, null, model))
        // Validate that we can update all applicable parents
        if (!canUpdateModifiedParents(user, model.getIdentifier(), model))
        // Validate that we can update all applicable parents
        if (!canUpdateModifiedParents(user, identifier, null))
import org.apache.guacamole.auth.jdbc.base.ChildObjectModel;
public class ConnectionModel extends ChildObjectModel {
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObjectService;
public class ConnectionService extends ModeledChildDirectoryObjectService<ModeledConnection, Connection, ConnectionModel> {
    protected ObjectPermissionSet getParentPermissionSet(ModeledAuthenticatedUser user)
            throws GuacamoleException {

        // Connections are contained by connection groups
        return user.getUser().getConnectionGroupPermissions();

    }

    @Override
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObject;
public class ModeledConnection extends ModeledChildDirectoryObject<ConnectionModel>
import org.apache.guacamole.auth.jdbc.base.ChildObjectModel;
public class ConnectionGroupModel extends ChildObjectModel {
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObjectService;
public class ConnectionGroupService extends ModeledChildDirectoryObjectService<ModeledConnectionGroup,
    protected ObjectPermissionSet getParentPermissionSet(ModeledAuthenticatedUser user)
            throws GuacamoleException {

        // Connection groups are contained by other connection groups
        return user.getUser().getConnectionGroupPermissions();

    }

    @Override
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObject;
public class ModeledConnectionGroup extends ModeledChildDirectoryObject<ConnectionGroupModel>
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObject;
        extends ModeledChildDirectoryObject<SharingProfileModel>
        return getModel().getParentIdentifier();
        getModel().setParentIdentifier(identifier);
     * @param parentIdentifier
            @Param("parentIdentifier") String parentIdentifier,
import org.apache.guacamole.auth.jdbc.base.ChildObjectModel;
public class SharingProfileModel extends ChildObjectModel {
import org.apache.guacamole.auth.jdbc.base.ModeledChildDirectoryObjectService;
        extends ModeledChildDirectoryObjectService<ModeledSharingProfile,
    protected ObjectPermissionSet getParentPermissionSet(ModeledAuthenticatedUser user)
            throws GuacamoleException {

        // Sharing profiles are children of connections
        return user.getUser().getConnectionPermissions();

    }

    @Override
        SharingProfileModel existing = sharingProfileMapper.selectOneByName(model.getParentIdentifier(), model.getName());
        SharingProfileModel existing = sharingProfileMapper.selectOneByName(model.getParentIdentifier(), model.getName());
            "0.9.10-incubating"
            "0.9.10-incubating"
    /**
     * Returns maximum number of results a LDAP query can return,
     * as configured with guacamole.properties.
     * By default, this will be 1000.
     *
     * @return
     *     The maximum number of results a LDAP query can return,
     *     as configured with guacamole.properties.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed.
     */
    public int getMaxResults() throws GuacamoleException {
        return environment.getProperty(
            LDAPGuacamoleProperties.LDAP_MAX_SEARCH_RESULTS,
            1000 
        );
    }

    /**
     * The maximum number of results a LDAP query can return.
     */
    public static final IntegerGuacamoleProperty LDAP_MAX_SEARCH_RESULTS = new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "ldap-max-search-results"; }

    };

import com.novell.ldap.LDAPSearchConstraints;
            // Set search limits
            LDAPSearchConstraints constraints = new LDAPSearchConstraints();
            constraints.setMaxResults(confService.getMaxResults());
                false,
                constraints
     * user.
     *     credentials, or null if no such user exists within the database.
import org.apache.guacamole.auth.jdbc.sharing.user.SharedAuthenticatedUser;
     * The environment of the Guacamole server.
     */
    @Inject
    private JDBCEnvironment environment;

    /**
        if (user == null) {

            // Do not invalidate the authentication result of users who were
            // authenticated via our own connection sharing links
            if (authenticatedUser instanceof SharedAuthenticatedUser)
                return null;

            // Simply return no data if a database user account is not required
            if (!environment.isUserRequired())
                return null;

            // Otherwise, invalidate the authentication result, as database user
            // accounts are absolutely required
            throw new GuacamoleInvalidCredentialsException("Invalid login",
                    CredentialsInfo.USERNAME_PASSWORD);

        }
     * Returns whether a database user account is required for authentication to
     * succeed, even if another authentication provider has already
     * authenticated the user.
     *
     * @return
     *     true if database user accounts are required for absolutely all
     *     authentication attempts, false otherwise.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the property.
     */
    public abstract boolean isUserRequired() throws GuacamoleException;

    /**
     * Whether a database user account is required by default for authentication
     * to succeed.
     */
    private static final boolean DEFAULT_USER_REQUIRED = false;

    /**
    public boolean isUserRequired() throws GuacamoleException {
        return getProperty(
            MySQLGuacamoleProperties.MYSQL_USER_REQUIRED,
            DEFAULT_USER_REQUIRED
        );
    }

    @Override
     * Whether a user account within the database is required for authentication
     * to succeed, even if the user has been authenticated via another
     * authentication provider.
     */
    public static final BooleanGuacamoleProperty MYSQL_USER_REQUIRED = new BooleanGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-user-required"; }

    };

    /**
     * Whether a database user account is required by default for authentication
     * to succeed.
     */
    private static final boolean DEFAULT_USER_REQUIRED = false;

    /**
    public boolean isUserRequired() throws GuacamoleException {
        return getProperty(
            PostgreSQLGuacamoleProperties.POSTGRESQL_USER_REQUIRED,
            DEFAULT_USER_REQUIRED
        );
    }

    @Override
     * Whether a user account within the database is required for authentication
     * to succeed, even if the user has been authenticated via another
     * authentication provider.
     */
    public static final BooleanGuacamoleProperty
            POSTGRESQL_USER_REQUIRED = new BooleanGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-user-required"; }

    };

    /**
     * user.
     *     credentials, or null if no such user exists within the database.
import org.apache.guacamole.auth.jdbc.sharing.user.SharedAuthenticatedUser;
     * The environment of the Guacamole server.
     */
    @Inject
    private JDBCEnvironment environment;

    /**
        if (user == null) {

            // Do not invalidate the authentication result of users who were
            // authenticated via our own connection sharing links
            if (authenticatedUser instanceof SharedAuthenticatedUser)
                return null;

            // Simply return no data if a database user account is not required
            if (!environment.isUserRequired())
                return null;

            // Otherwise, invalidate the authentication result, as database user
            // accounts are absolutely required
            throw new GuacamoleInvalidCredentialsException("Invalid login",
                    CredentialsInfo.USERNAME_PASSWORD);

        }
     * Returns whether a database user account is required for authentication to
     * succeed, even if another authentication provider has already
     * authenticated the user.
     *
     * @return
     *     true if database user accounts are required for absolutely all
     *     authentication attempts, false otherwise.
     *
     * @throws GuacamoleException
     *     If an error occurs while retrieving the property.
     */
    public abstract boolean isUserRequired() throws GuacamoleException;

    /**
     * Whether a database user account is required by default for authentication
     * to succeed.
     */
    private static final boolean DEFAULT_USER_REQUIRED = false;

    /**
    public boolean isUserRequired() throws GuacamoleException {
        return getProperty(
            MySQLGuacamoleProperties.MYSQL_USER_REQUIRED,
            DEFAULT_USER_REQUIRED
        );
    }

    @Override
     * Whether a user account within the database is required for authentication
     * to succeed, even if the user has been authenticated via another
     * authentication provider.
     */
    public static final BooleanGuacamoleProperty MYSQL_USER_REQUIRED = new BooleanGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-user-required"; }

    };

    /**
     * Whether a database user account is required by default for authentication
     * to succeed.
     */
    private static final boolean DEFAULT_USER_REQUIRED = false;

    /**
    public boolean isUserRequired() throws GuacamoleException {
        return getProperty(
            PostgreSQLGuacamoleProperties.POSTGRESQL_USER_REQUIRED,
            DEFAULT_USER_REQUIRED
        );
    }

    @Override
     * Whether a user account within the database is required for authentication
     * to succeed, even if the user has been authenticated via another
     * authentication provider.
     */
    public static final BooleanGuacamoleProperty
            POSTGRESQL_USER_REQUIRED = new BooleanGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-user-required"; }

    };

    /**
import org.webjars.servlet.WebjarsServlet;
        // Serve Webjar JavaScript dependencies
        bind(WebjarsServlet.class).in(Scopes.SINGLETON);
        serve("/webjars/*").with(WebjarsServlet.class);

import org.webjars.servlet.WebjarsServlet;
        // Serve Webjar JavaScript dependencies
        bind(WebjarsServlet.class).in(Scopes.SINGLETON);
        serve("/webjars/*").with(WebjarsServlet.class);

import org.webjars.servlet.WebjarsServlet;
        // Serve Webjar JavaScript dependencies
        bind(WebjarsServlet.class).in(Scopes.SINGLETON);
        serve("/webjars/*").with(WebjarsServlet.class);

import org.apache.guacamole.auth.jdbc.user.UserModel;
        // Update password if password is expired
        UserModel userModel = user.getModel();
        if (userModel.isExpired())
            userService.resetExpiredPassword(user, authenticatedUser.getCredentials());

    /**
     * Resets the password of the given user to the new password specified via
     * the "new-password" and "confirm-new-password" parameters from the
     * provided credentials. If these parameters are missing or invalid,
     * additional credentials will be requested.
     *
     * @param user
     *     The user whose password should be reset.
     *
     * @param credentials
     *     The credentials from which the parameters required for password
     *     reset should be retrieved.
     *
     * @throws GuacamoleException
     *     If the password reset parameters within the given credentials are
     *     invalid or missing.
     */
    public void resetExpiredPassword(ModeledUser user, Credentials credentials)
            throws GuacamoleException {

        UserModel userModel = user.getModel();

        // Get username
        String username = user.getIdentifier();

        // Pull new password from HTTP request
        HttpServletRequest request = credentials.getRequest();
        String newPassword = request.getParameter(NEW_PASSWORD_PARAMETER);
        String confirmNewPassword = request.getParameter(CONFIRM_NEW_PASSWORD_PARAMETER);

        // Require new password if account is expired
        if (newPassword == null || confirmNewPassword == null) {
            logger.info("The password of user \"{}\" has expired and must be reset.", username);
            throw new GuacamoleInsufficientCredentialsException("LOGIN.INFO_PASSWORD_EXPIRED", EXPIRED_PASSWORD);
        }

        // New password must be different from old password
        if (newPassword.equals(credentials.getPassword()))
            throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_SAME");

        // New password must not be blank
        if (newPassword.isEmpty())
            throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_BLANK");

        // Confirm that the password was entered correctly twice
        if (!newPassword.equals(confirmNewPassword))
            throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_MISMATCH");

        // Change password and reset expiration flag
        userModel.setExpired(false);
        user.setPassword(newPassword);
        userMapper.update(userModel);
        logger.info("Expired password of user \"{}\" has been reset.", username);

    }

import org.apache.guacamole.auth.jdbc.user.UserModel;
        // Update password if password is expired
        UserModel userModel = user.getModel();
        if (userModel.isExpired())
            userService.resetExpiredPassword(user, authenticatedUser.getCredentials());

    /**
     * Resets the password of the given user to the new password specified via
     * the "new-password" and "confirm-new-password" parameters from the
     * provided credentials. If these parameters are missing or invalid,
     * additional credentials will be requested.
     *
     * @param user
     *     The user whose password should be reset.
     *
     * @param credentials
     *     The credentials from which the parameters required for password
     *     reset should be retrieved.
     *
     * @throws GuacamoleException
     *     If the password reset parameters within the given credentials are
     *     invalid or missing.
     */
    public void resetExpiredPassword(ModeledUser user, Credentials credentials)
            throws GuacamoleException {

        UserModel userModel = user.getModel();

        // Get username
        String username = user.getIdentifier();

        // Pull new password from HTTP request
        HttpServletRequest request = credentials.getRequest();
        String newPassword = request.getParameter(NEW_PASSWORD_PARAMETER);
        String confirmNewPassword = request.getParameter(CONFIRM_NEW_PASSWORD_PARAMETER);

        // Require new password if account is expired
        if (newPassword == null || confirmNewPassword == null) {
            logger.info("The password of user \"{}\" has expired and must be reset.", username);
            throw new GuacamoleInsufficientCredentialsException("LOGIN.INFO_PASSWORD_EXPIRED", EXPIRED_PASSWORD);
        }

        // New password must be different from old password
        if (newPassword.equals(credentials.getPassword()))
            throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_SAME");

        // New password must not be blank
        if (newPassword.isEmpty())
            throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_BLANK");

        // Confirm that the password was entered correctly twice
        if (!newPassword.equals(confirmNewPassword))
            throw new GuacamoleClientException("LOGIN.ERROR_PASSWORD_MISMATCH");

        // Change password and reset expiration flag
        userModel.setExpired(false);
        user.setPassword(newPassword);
        userMapper.update(userModel);
        logger.info("Expired password of user \"{}\" has been reset.", username);

    }

        UserVerificationService verificationService =
                injector.getInstance(UserVerificationService.class);
        verificationService.verifyAuthenticatedUser(authenticatedUser);
        bind(UserVerificationService.class);
 b/extensions/guacamole-auth-duo/src/main/java/org/apache/guacamole/auth/duo/UserVerificationService.java
 * Service for verifying the identity of a user against Duo.
public class UserVerificationService {
import org.apache.guacamole.auth.duo.api.DuoService;
        bind(DuoService.class);
import org.apache.guacamole.auth.duo.api.DuoService;
     * Service for verifying users against Duo.
    private DuoService duoService;
                    duoService.createSignedRequest(authenticatedUser));
        if (!duoService.isValidSignedResponse(authenticatedUser, signedResponse))
import org.apache.guacamole.auth.duo.api.DuoService;
        bind(DuoService.class);
import org.apache.guacamole.auth.duo.api.DuoService;
     * Service for verifying users against Duo.
    private DuoService duoService;
                    duoService.createSignedRequest(authenticatedUser));
        if (!duoService.isValidSignedResponse(authenticatedUser, signedResponse))
import org.apache.guacamole.GuacamoleClientException;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.GuacamoleResourceNotFoundException;
import org.apache.guacamole.GuacamoleSecurityException;
import org.apache.guacamole.net.auth.credentials.GuacamoleCredentialsException;
import org.apache.guacamole.net.auth.credentials.GuacamoleInsufficientCredentialsException;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
import org.apache.guacamole.tunnel.GuacamoleStreamException;
        BAD_REQUEST,
        INVALID_CREDENTIALS,
        INSUFFICIENT_CREDENTIALS,
        INTERNAL_ERROR,
        NOT_FOUND,
        PERMISSION_DENIED,
        STREAM_ERROR;
         * Returns the REST API error type which corresponds to the type of the
         * given exception.
         * @param exception
         *     The exception to use to derive the API error type.
         *     The API error type which corresponds to the type of the given
         *     exception.
        public static Type fromGuacamoleException(GuacamoleException exception) {

            // Additional credentials are needed
            if (exception instanceof GuacamoleInsufficientCredentialsException)
                return INSUFFICIENT_CREDENTIALS;

            // The provided credentials are wrong
            if (exception instanceof GuacamoleInvalidCredentialsException)
                return INVALID_CREDENTIALS;

            // Generic permission denied
            if (exception instanceof GuacamoleSecurityException)
                return PERMISSION_DENIED;

            // Arbitrary resource not found
            if (exception instanceof GuacamoleResourceNotFoundException)
                return NOT_FOUND;

            // Arbitrary bad requests
            if (exception instanceof GuacamoleClientException)
                return BAD_REQUEST;

            // Errors from intercepted streams
            if (exception instanceof GuacamoleStreamException)
                return STREAM_ERROR;

            // All other errors
            return INTERNAL_ERROR;

     * Creates a new APIError which exposes the details of the given
     * GuacamoleException.
     * @param exception
     *     The GuacamoleException from which the details of the new APIError
     *     should be derived.
    public APIError(GuacamoleException exception) {
        // Build base REST service error
        this.type = Type.fromGuacamoleException(exception);
        this.message = exception.getMessage();
        // Add expected credentials if applicable
        if (exception instanceof GuacamoleCredentialsException) {
            GuacamoleCredentialsException credentialsException = (GuacamoleCredentialsException) exception;
            this.expected = credentialsException.getCredentialsInfo().getFields();
        }
        else
            this.expected = null;

        // Add stream status code if applicable
        if (exception instanceof GuacamoleStreamException) {
            GuacamoleStreamException streamException = (GuacamoleStreamException) exception;
            this.statusCode = streamException.getStatus().getGuacamoleStatusCode();
        }
        else
            this.statusCode = null;

import org.apache.guacamole.GuacamoleException;
 * An exception which exposes a given error within the API layer. When thrown
 * within the context of the REST API, an appropriate HTTP status code will be
 * set for the failing response, and the details of the error will be exposed in
 * the body of the response as an APIError structure.
     * Construct a new APIException based on the given GuacamoleException and
     * HTTP status. The details of the GuacamoleException relevant to the REST
     * API will be exposed via an APIError.
     * @param status
     *     The HTTP status which corresponds to the GuacamoleException.
     *
     * @param exception
     *     The GuacamoleException that occurred.
    public APIException(Response.Status status, GuacamoleException exception) {
        super(Response.status(status)
                .entity(new APIError(exception))
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
    public Object invoke(MethodInvocation invocation) throws WebApplicationException {
        // Translate GuacamoleException subclasses to HTTP error codes
            throw new APIException(Response.Status.FORBIDDEN, e);
            throw new APIException(Response.Status.NOT_FOUND, e);
            throw new APIException(Response.Status.BAD_REQUEST, e);
            throw new APIException(Response.Status.INTERNAL_SERVER_ERROR, e);
        }
        // Rethrow unchecked exceptions such that they are properly wrapped
        catch (Throwable t) {

            // Log all reasonable details of error
            String message = t.getMessage();
            logger.debug("Unexpected error in REST endpoint.", t);
            throw new APIException(Response.Status.INTERNAL_SERVER_ERROR,
                    new GuacamoleException("Unexpected internal error.", t));
import javax.ws.rs.core.Response;
import org.apache.guacamole.GuacamoleClientException;
                Response.Status.BAD_REQUEST,
                new GuacamoleClientException(String.format("Invalid sort property: \"%s\"", value))
import org.apache.guacamole.language.Translatable;
import org.apache.guacamole.language.TranslatableMessage;
     * The human-readable error message.
     * A translatable message representing the error that occurred.
     */
    private final TranslatableMessage translatableMessage;

    /**
     * GuacamoleException. If the given GuacamoleException implements
     * Translatable, then its translation string and values will be exposed as
     * well.
        // Pull translatable message and values if available
        if (exception instanceof Translatable) {
            Translatable translatable = (Translatable) exception;
            this.translatableMessage = translatable.getTranslatableMessage();
        }
        else
            this.translatableMessage = new TranslatableMessage(this.message);

    /**
     * Returns a translatable message describing the error that occurred. If no
     * translatable message is associated with the error, this will be null.
     *
     * @return
     *     A translatable message describing the error that occurred, or null
     *     if there is no such message defined.
     */
    public TranslatableMessage getTranslatableMessage() {
        return translatableMessage;
    }

            ExternalType object, ModelType model) throws GuacamoleException {
        super.beforeCreate(user, object, model);
     * @param object
     *     The object being created.
     *
            ExternalType object, ModelType model) throws GuacamoleException {
        beforeCreate(user, object, model);
            Connection object, ConnectionModel model)
            throws GuacamoleException {
        super.beforeCreate(user, object, model);
            ConnectionGroup object, ConnectionGroupModel model)
            throws GuacamoleException {
        super.beforeCreate(user, object, model);
            SharingProfile object, SharingProfileModel model)
            throws GuacamoleException {
        super.beforeCreate(user, object, model);
    protected void beforeCreate(ModeledAuthenticatedUser user, User object,
            UserModel model) throws GuacamoleException {
        super.beforeCreate(user, object, model);
            InternalType object, ModelType model) throws GuacamoleException {
        super.beforeUpdate(user, object, model);
     * @param object
     *     The object being updated.
     *
            InternalType object, ModelType model) throws GuacamoleException {
        beforeUpdate(user, object, model);
            ModeledConnection object, ConnectionModel model)
            throws GuacamoleException {
        super.beforeUpdate(user, object, model);

            ModeledConnectionGroup object, ConnectionGroupModel model)
            throws GuacamoleException {
        super.beforeUpdate(user, object, model);
            ModeledSharingProfile object, SharingProfileModel model)
            throws GuacamoleException {
        super.beforeUpdate(user, object, model);
            ModeledUser object, UserModel model) throws GuacamoleException {
        super.beforeUpdate(user, object, model);
import org.apache.guacamole.auth.jdbc.security.PasswordPolicyService;
        bind(PasswordPolicyService.class);
import org.apache.guacamole.auth.jdbc.security.PasswordPolicy;
    /**
     * Returns the policy which applies to newly-set passwords. Passwords which
     * apply to Guacamole user accounts will be required to conform to this
     * policy.
     *
     * @return
     *     The password policy which applies to Guacamole user accounts.
     */
    public abstract PasswordPolicy getPasswordPolicy();

import org.apache.guacamole.auth.jdbc.security.PasswordPolicyService;
    /**
     * Service for enforcing password complexity policies.
     */
    @Inject
    private PasswordPolicyService passwordPolicyService;

        // Verify new password does not violate defined policies (if specified)
        if (object.getPassword() != null)
            passwordPolicyService.verifyPassword(object.getIdentifier(), object.getPassword());


        // Verify new password does not violate defined policies (if specified)
        if (object.getPassword() != null)
            passwordPolicyService.verifyPassword(object.getIdentifier(), object.getPassword());

        // Verify new password does not violate defined policies
        passwordPolicyService.verifyPassword(username, newPassword);

import org.apache.guacamole.auth.jdbc.security.PasswordPolicy;
    @Override
    public PasswordPolicy getPasswordPolicy() {
        return new MySQLPasswordPolicy(this);
    }

import org.apache.guacamole.auth.jdbc.security.PasswordPolicy;
    @Override
    public PasswordPolicy getPasswordPolicy() {
        return new PostgreSQLPasswordPolicy(this);
    }

        // If no password provided, set random password
            userModel.setPasswordSalt(saltService.generateSalt());
            userModel.setPasswordHash(saltService.generateSalt());
import java.sql.Timestamp;
     * The time this user's password was last reset.
     */
    private Timestamp passwordDate;

    /**
     * Returns the date that this user's password was last set/reset. This
     * value is required to be manually updated whenever the user's password is
     * changed; it will not be automatically updated by the database.
     *
     * @return
     *     The date that this user's password was last set/reset.
     */
    public Timestamp getPasswordDate() {
        return passwordDate;
    }

    /**
     * Sets the date that this user's password was last set/reset. This
     * value is required to be manually updated whenever the user's password is
     * changed; it will not be automatically updated by the database.
     *
     * @param passwordDate
     *     The date that this user's password was last set/reset.
     */
    public void setPasswordDate(Timestamp passwordDate) {
        this.passwordDate = passwordDate;
    }

    /**
import org.apache.guacamole.auth.jdbc.security.PasswordPolicyService;
     * Service for enforcing password complexity policies.
     */
    @Inject
    private PasswordPolicyService passwordPolicyService;

    /**
        if (userModel.isExpired() || passwordPolicyService.isPasswordExpired(userModel))
     * Returns the minimum number of days which must elapse before the user's
     * password may be reset. If this restriction does not apply, this will be
     * zero.
     *
     * @return
     *     The minimum number of days which must elapse before the user's
     *     password must be reset, or zero if this restriction does not apply.
     *
     * @throws GuacamoleException
     *     If the minimum password age cannot be parsed from
     *     guacamole.properties.
     */
    int getMinimumAge() throws GuacamoleException;

    /**
     * Returns the maximum number of days which may elapse before the user's
     * password must be reset. If this restriction does not apply, this will be
     * zero.
     *
     * @return
     *     The maximum number of days which may elapse before the user's
     *     password must be reset, or zero if this restriction does not apply.
     *
     * @throws GuacamoleException
     *     If the maximum password age cannot be parsed from
     *     guacamole.properties.
     */
    int getMaximumAge() throws GuacamoleException;

    /**
import java.util.concurrent.TimeUnit;
import org.apache.guacamole.auth.jdbc.user.UserModel;
    /**
     * Returns the age of the given user's password, in days. The age of a
     * user's password is the amount of time elapsed since the password was last
     * changed or reset.
     *
     * @param user
     *     The user to calculate the password age of.
     *
     * @return
     *     The age of the given user's password, in days.
     */
    private long getPasswordAge(UserModel user) {

        // Pull both current time and the time the password was last reset
        long currentTime = System.currentTimeMillis();
        long lastResetTime = user.getPasswordDate().getTime();

        // Calculate the number of days elapsed since the password was last reset
        return TimeUnit.DAYS.convert(currentTime - lastResetTime, TimeUnit.MILLISECONDS);
        
    }

    /**
     * Verifies that the given user can change their password without violating
     * password aging policy. If changing the user's password would violate the
     * aging policy, a GuacamoleException will be thrown.
     *
     * @param user
     *     The user whose password is changing.
     *
     * @throws GuacamoleException
     *     If the user's password cannot be changed due to the password aging
     *     policy, or of the password policy cannot be parsed from
     *     guacamole.properties.
     */
    public void verifyPasswordAge(UserModel user) throws GuacamoleException {

        // Retrieve password policy from environment
        PasswordPolicy policy = environment.getPasswordPolicy();

        long minimumAge = policy.getMinimumAge();
        long passwordAge = getPasswordAge(user);

        // Require that sufficient time has elapsed before allowing the password
        // to be changed
        if (passwordAge < minimumAge)
            throw new PasswordTooYoungException("Password was already recently changed.",
                    minimumAge - passwordAge);

    }

    /**
     * Returns whether the given user's password is expired due to the password
     * aging policy.
     *
     * @param user
     *     The user to check.
     *
     * @return
     *     true if the user needs to change their password to comply with the
     *     password aging policy, false otherwise.
     *
     * @throws GuacamoleException
     *     If the password policy cannot be parsed.
     */
    public boolean isPasswordExpired(UserModel user)
            throws GuacamoleException {

        // Retrieve password policy from environment
        PasswordPolicy policy = environment.getPasswordPolicy();

        // There is no maximum password age if 0
        int maxPasswordAge = policy.getMaximumAge();
        if (maxPasswordAge == 0)
            return false;

        // Determine whether password is expired based on maximum age
        return getPasswordAge(user) >= maxPasswordAge;

    }

import java.sql.Timestamp;
        // Update password reset date
        model.setPasswordDate(new Timestamp(System.currentTimeMillis()));

        if (object.getPassword() != null) {

            // Enforce password age only for non-adminstrators
            if (!user.getUser().isAdministrator())
                passwordPolicyService.verifyPasswordAge(model);

            // Always verify password complexity
            // Update password reset date
            model.setPasswordDate(new Timestamp(System.currentTimeMillis()));

        }

     * The property which specifies the minimum number of days which must
     * elapse before a user may reset their password. If set to zero, the
     * default, then this restriction does not apply.
     */
    private static final IntegerGuacamoleProperty MIN_AGE =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-user-password-min-age"; }

    };

    /**
     * The property which specifies the maximum number of days which may
     * elapse before a user is required to reset their password. If set to zero,
     * the default, then this restriction does not apply.
     */
    private static final IntegerGuacamoleProperty MAX_AGE =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-user-password-max-age"; }

    };

    /**
    public int getMinimumAge() throws GuacamoleException {
        return environment.getProperty(MIN_AGE, 0);
    }

    @Override
    public int getMaximumAge() throws GuacamoleException {
        return environment.getProperty(MAX_AGE, 0);
    }

    @Override
     * The property which specifies the minimum number of days which must
     * elapse before a user may reset their password. If set to zero, the
     * default, then this restriction does not apply.
     */
    private static final IntegerGuacamoleProperty MIN_AGE =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-user-password-min-age"; }

    };

    /**
     * The property which specifies the maximum number of days which may
     * elapse before a user is required to reset their password. If set to zero,
     * the default, then this restriction does not apply.
     */
    private static final IntegerGuacamoleProperty MAX_AGE =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-user-password-max-age"; }

    };

    /**
    public int getMinimumAge() throws GuacamoleException {
        return environment.getProperty(MIN_AGE, 0);
    }

    @Override
    public int getMaximumAge() throws GuacamoleException {
        return environment.getProperty(MAX_AGE, 0);
    }

    @Override
        if (userModel.isExpired() || passwordPolicyService.isPasswordExpired(user))
import org.apache.guacamole.auth.jdbc.user.ModeledUser;
    private long getPasswordAge(ModeledUser user) {
        long lastResetTime = user.getPreviousPasswordDate().getTime();
    public void verifyPasswordAge(ModeledUser user) throws GuacamoleException {
    public boolean isPasswordExpired(ModeledUser user)
import java.sql.Timestamp;

    /**
     * The time and date that this user's password was previously set (prior to
     * being queried). If the user is new, this will be null.
     */
    private Timestamp previousPasswordDate = null;
    public void setModel(UserModel model) {
        super.setModel(model);
        this.previousPasswordDate = model.getPasswordDate();
    }

    @Override
        userModel.setPasswordDate(new Timestamp(System.currentTimeMillis()));

    }

    /**
     * Returns the time and date that this user's password was previously set.
     * If the user is new, this will be null. Unlike getPasswordDate() of
     * UserModel (which is updated automatically along with the password salt
     * and hash whenever setPassword() is invoked), this value is unaffected by
     * calls to setPassword(), and will always be the value stored in the
     * database at the time this user was queried.
     *
     * @return
     *     The time and date that this user's password was previously set, or
     *     null if the user is new.
     */
    public Timestamp getPreviousPasswordDate() {
        return previousPasswordDate;
                passwordPolicyService.verifyPasswordAge(object);
import org.apache.guacamole.auth.jdbc.user.PasswordRecordModel;
        // If no password was set, then no time has elapsed
        PasswordRecordModel previousPassword = user.getPreviousPassword();
        if (previousPassword == null)
            return 0;

        long lastResetTime = previousPassword.getPasswordDate().getTime();
     * The data associated with this user's password at the time this user was
     * queried. If the user is new, this will be null.
    private PasswordRecordModel previousPassword = null;


        // Store previous password, if any
        if (model.getPasswordHash() != null)
            this.previousPassword = new PasswordRecordModel(model);

     * Returns the data associated with this user's previous password as a
     * password record. If the user is new, this will be null. Unlike the other
     * password-related functions of UserModel, this data returned by this
     * function is historical and is unaffected by calls to setPassword(). It
     * will always return the values stored in the database at the time this
     * user was queried.
     *     The data associated with this user's previous password, or null if
     *     the user is new.
    public PasswordRecordModel getPreviousPassword() {
        return previousPassword;
import org.apache.guacamole.auth.jdbc.user.PasswordRecordMapper;
        addMapperClass(PasswordRecordMapper.class);
     * Returns the number of previous passwords remembered for each user. If
     * greater than zero, users will be prohibited from reusing their past
     * passwords.
     *
     * @return
     *     The number of previous passwords remembered for each user.
     *
     * @throws GuacamoleException
     *     If the password history size cannot be parsed from
     *     guacamole.properties.
     */
    int getHistorySize() throws GuacamoleException;

    /**
import org.apache.guacamole.auth.jdbc.user.PasswordRecordMapper;
     * Mapper for creating/retrieving previously-set passwords.
     */
    @Inject
    private PasswordRecordMapper passwordRecordMapper;

    /**
    /**
     * Records the password that was associated with the given user at the time
     * the user was queried, such that future attempts to set that same password
     * for that user will be denied. The number of passwords remembered for each
     * user is limited by the password policy.
     *
     * @param user
     *     The user whose previous password should be recorded.
     *
     * @throws GuacamoleException
     *     If the password policy cannot be parsed.
     */
    public void recordPreviousPassword(ModeledUser user)
            throws GuacamoleException {

        // Retrieve password policy from environment
        PasswordPolicy policy = environment.getPasswordPolicy();

        // Nothing to do if history is not being recorded
        int historySize = policy.getHistorySize();
        if (historySize <= 0)
            return;
        
        // Store previous password in history
        passwordRecordMapper.insert(user.getPreviousPassword(), historySize);

    }

            // Store previous password in history
            passwordPolicyService.recordPreviousPassword(object);

     * The property which specifies the number of previous passwords remembered
     * for each user. If set to zero, the default, then this restriction does
     * not apply.
     */
    private static final IntegerGuacamoleProperty HISTORY_SIZE =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "mysql-user-password-history-size"; }

    };

    /**
    public int getHistorySize() throws GuacamoleException {
        return environment.getProperty(HISTORY_SIZE, 0);
    }

    @Override
     * The property which specifies the number of previous passwords remembered
     * for each user. If set to zero, the default, then this restriction does
     * not apply.
     */
    private static final IntegerGuacamoleProperty HISTORY_SIZE =
            new IntegerGuacamoleProperty() {

        @Override
        public String getName() { return "postgresql-user-password-history-size"; }

    };

    /**
    public int getHistorySize() throws GuacamoleException {
        return environment.getProperty(HISTORY_SIZE, 0);
    }

    @Override
import java.util.Arrays;
import java.util.List;
     * Service for hashing passwords.
     */
    @Inject
    private PasswordEncryptionService encryptionService;

    /**
     * Returns whether the given password matches any of the user's previous
     * passwords. Regardless of the value specified here, the maximum number of
     * passwords involved in this check depends on how many previous passwords
     * were actually recorded, which depends on the password policy.
     *
     * @param password
     *     The password to check.
     *
     * @param username
     *     The username of the user whose history should be compared against
     *     the given password.
     *
     * @param historySize
     *     The maximum number of history records to compare the password
     *     against.
     *
     * @return
     *     true if the given password matches any of the user's previous
     *     passwords, up to the specified limit, false otherwise.
     */
    private boolean matchesPreviousPasswords(String password, String username,
            int historySize) {

        // No need to compare if no history is relevant
        if (historySize <= 0)
            return false;

        // Check password against all recorded hashes
        List<PasswordRecordModel> history = passwordRecordMapper.select(username, historySize);
        for (PasswordRecordModel record : history) {

            byte[] hash = encryptionService.createPasswordHash(password, record.getPasswordSalt());
            if (Arrays.equals(hash, record.getPasswordHash()))
                return true;
            
        }

        // No passwords match
        return false;
        
    }

    /**
        // Prohibit password reuse
        int historySize = policy.getHistorySize();
        if (matchesPreviousPasswords(password, username, historySize))
            throw new PasswordReusedException(
                    "Password matches a previously-used password.", historySize);

import org.apache.guacamole.auth.jdbc.connection.GuacamoleProxyConfiguration;
import org.apache.guacamole.environment.Environment;
     * The hostname to use when connecting to guacd if no hostname is provided
     * within guacamole.properties.
     */
    private static final String DEFAULT_GUACD_HOSTNAME = "localhost";

    /**
     * The port to use when connecting to guacd if no port is provided within
     * guacamole.properties.
     */
    private static final int DEFAULT_GUACD_PORT = 4822;

    /**
     * Returns the connection information which should be used, by default, to
     * connect to guacd when establishing a remote desktop connection.
     *
     * @return
     *     The connection information which should be used, by default, to
     *     connect to guacd.
     *
     * @throws GuacamoleException
     *     If the properties describing the connection information for guacd
     *     cannot be parsed.
     */
    public GuacamoleProxyConfiguration getDefaultGuacamoleProxyConfiguration()
            throws GuacamoleException {

        // Parse guacd hostname/port/ssl properties
        return new GuacamoleProxyConfiguration(
            getProperty(Environment.GUACD_HOSTNAME, DEFAULT_GUACD_HOSTNAME),
            getProperty(Environment.GUACD_PORT, DEFAULT_GUACD_PORT),
            getProperty(Environment.GUACD_SSL, false)
        );

    }

    /**
import org.apache.guacamole.auth.jdbc.connection.GuacamoleProxyConfiguration.EncryptionMethod;
     * The hostname of the guacd instance to use, or null if the hostname of the
     * default guacd instance should be used.
     */
    private String proxyHostname;

    /**
     * The port of the guacd instance to use, or null if the port of the default
     * guacd instance should be used.
     */
    private Integer proxyPort;

    /**
     * The encryption method required by the desired guacd instance, or null if
     * the encryption method of the default guacd instance should be used.
     */
    private EncryptionMethod proxyEncryptionMethod;

    /**
     * Returns the hostname of the guacd instance to use. If the hostname of the
     * default guacd instance should be used instead, null is returned.
     *
     * @return
     *     The hostname of the guacd instance to use, or null if the hostname
     *     of the default guacd instance should be used.
     */
    public String getProxyHostname() {
        return proxyHostname;
    }

    /**
     * Sets the hostname of the guacd instance to use.
     *
     * @param proxyHostname
     *     The hostname of the guacd instance to use, or null if the hostname
     *     of the default guacd instance should be used.
     */
    public void setProxyHostname(String proxyHostname) {
        this.proxyHostname = proxyHostname;
    }

    /**
     * Returns the port of the guacd instance to use. If the port of the default
     * guacd instance should be used instead, null is returned.
     *
     * @return
     *     The port of the guacd instance to use, or null if the port of the
     *     default guacd instance should be used.
     */
    public Integer getProxyPort() {
        return proxyPort;
    }

    /**
     * Sets the port of the guacd instance to use.
     *
     * @param proxyPort
     *     The port of the guacd instance to use, or null if the port of the
     *     default guacd instance should be used.
     */
    public void setProxyPort(Integer proxyPort) {
        this.proxyPort = proxyPort;
    }

    /**
     * Returns the type of encryption required by the desired guacd instance.
     * If the encryption method of the default guacd instance should be used
     * instead, null is returned.
     *
     * @return
     *     The type of encryption required by the desired guacd instance, or
     *     null if the encryption method of the default guacd instance should
     *     be used.
     */
    public EncryptionMethod getProxyEncryptionMethod() {
        return proxyEncryptionMethod;
    }

    /**
     * Sets the type of encryption which should be used when connecting to
     * guacd, if any.
     *
     * @param proxyEncryptionMethod
     *     The type of encryption required by the desired guacd instance, or
     *     null if the encryption method of the default guacd instance should
     *     be used.
     */
    public void setProxyEncryptionMethod(EncryptionMethod proxyEncryptionMethod) {
        this.proxyEncryptionMethod = proxyEncryptionMethod;
    }

    /**
import org.apache.guacamole.auth.jdbc.connection.GuacamoleProxyConfiguration.EncryptionMethod;
import org.apache.guacamole.form.EnumField;
import org.apache.guacamole.form.TextField;
     * The name of the attribute which overrides the hostname used to connect
     * to guacd for this connection.
     */
    public static final String GUACD_HOSTNAME_NAME = "guacd-hostname";

    /**
     * The name of the attribute which overrides the port used to connect to
     * guacd for this connection.
     */
    public static final String GUACD_PORT_NAME = "guacd-port";

    /**
     * The name of the attribute which overrides the encryption method used to
     * connect to guacd for this connection.
     */
    public static final String GUACD_ENCRYPTION_NAME = "guacd-encryption";

    /**
     * The value specified for the "guacd-encryption" attribute if encryption
     * should not be used to connect to guacd.
     */
    public static final String GUACD_ENCRYPTION_VALUE_NONE = "none";

    /**
     * The value specified for the "guacd-encryption" attribute if SSL/TLS
     * encryption should be used to connect to guacd.
     */
    public static final String GUACD_ENCRYPTION_VALUE_SSL = "ssl";

    /**
     * All attributes which describe the configuration of the guacd instance
     * which will be used to connect to the remote desktop described by this
     * connection.
     */
    public static final Form GUACD_PARAMETERS = new Form("guacd", Arrays.<Field>asList(
        new TextField(GUACD_HOSTNAME_NAME),
        new NumericField(GUACD_PORT_NAME),
        new EnumField(GUACD_ENCRYPTION_NAME, Arrays.asList(
            "",
            GUACD_ENCRYPTION_VALUE_NONE,
            GUACD_ENCRYPTION_VALUE_SSL
        ))
    ));

    /**
        CONCURRENCY_LIMITS,
        GUACD_PARAMETERS
        // Set guacd (proxy) hostname and port
        attributes.put(GUACD_HOSTNAME_NAME, getModel().getProxyHostname());
        attributes.put(GUACD_PORT_NAME, NumericField.format(getModel().getProxyPort()));

        // Set guacd (proxy) encryption method
        EncryptionMethod encryptionMethod = getModel().getProxyEncryptionMethod();
        if (encryptionMethod == null)
            attributes.put(GUACD_ENCRYPTION_NAME, null);

        else {
            switch (encryptionMethod) {

                // Unencrypted
                case NONE:
                    attributes.put(GUACD_ENCRYPTION_NAME, GUACD_ENCRYPTION_VALUE_NONE);
                    break;

                // SSL / TLS encryption
                case SSL:
                    attributes.put(GUACD_ENCRYPTION_NAME, GUACD_ENCRYPTION_VALUE_SSL);
                    break;

                // Unimplemented / unspecified
                default:
                    attributes.put(GUACD_ENCRYPTION_NAME, null);

            }
        }

        // Set guacd hostname (no translation necessary)
        getModel().setProxyHostname(attributes.get(GUACD_HOSTNAME_NAME));

        // Translate guacd port
        try { getModel().setProxyPort(NumericField.parse(attributes.get(GUACD_PORT_NAME))); }
        catch (NumberFormatException e) {
            logger.warn("Not setting guacd port: {}", e.getMessage());
            logger.debug("Unable to parse numeric attribute.", e);
        }

        // Translate guacd encryption method
        String encryptionMethod = attributes.get(GUACD_ENCRYPTION_NAME);

        // Unencrypted
        if (GUACD_ENCRYPTION_VALUE_NONE.equals(encryptionMethod))
            getModel().setProxyEncryptionMethod(EncryptionMethod.NONE);

        // SSL / TLS
        else if (GUACD_ENCRYPTION_VALUE_SSL.equals(encryptionMethod))
            getModel().setProxyEncryptionMethod(EncryptionMethod.SSL);

        // Unimplemented / unspecified
        else
            getModel().setProxyEncryptionMethod(null);

    /**
     * Returns the connection information which should be used to connect to
     * guacd when establishing a connection to the remote desktop described by
     * this connection. If no such information is defined for this specific
     * remote desktop connection, the default guacd connection information will
     * be used instead, as defined by JDBCEnvironment.
     *
     * @return
     *     The connection information which should be used to connect to guacd
     *     when establishing a connection to the remote desktop described by
     *     this connection.
     *
     * @throws GuacamoleException
     *     If the connection information for guacd cannot be parsed.
     */
    public GuacamoleProxyConfiguration getGuacamoleProxyConfiguration()
            throws GuacamoleException {

        // Retrieve default proxy configuration from environment
        GuacamoleProxyConfiguration defaultConfig = environment.getDefaultGuacamoleProxyConfiguration();

        // Retrieve proxy configuration overrides from model
        String hostname = getModel().getProxyHostname();
        Integer port = getModel().getProxyPort();
        EncryptionMethod encryptionMethod = getModel().getProxyEncryptionMethod();

        // Produce new proxy configuration from model, using defaults where unspecified
        return new GuacamoleProxyConfiguration(
            hostname         != null ? hostname         : defaultConfig.getHostname(),
            port             != null ? port             : defaultConfig.getPort(),
            encryptionMethod != null ? encryptionMethod : defaultConfig.getEncryptionMethod()
        );

    }

import org.apache.guacamole.GuacamoleServerException;
import org.apache.guacamole.auth.jdbc.connection.GuacamoleProxyConfiguration;
     * @param proxyConfig
     *     The configuration information to use when connecting to guacd.
     *
     * @param socketClosedCallback
     *     The callback which should be invoked whenever the returned socket
     *     closes.
     *
    private GuacamoleSocket getUnconfiguredGuacamoleSocket(
            GuacamoleProxyConfiguration proxyConfig,
            Runnable socketClosedCallback) throws GuacamoleException {
        // Select socket type depending on desired encryption
        switch (proxyConfig.getEncryptionMethod()) {
            // Use SSL if requested
            case SSL:
                return new ManagedSSLGuacamoleSocket(
                    proxyConfig.getHostname(),
                    proxyConfig.getPort(),
                    socketClosedCallback
                );

            // Use straight TCP if unencrypted
            case NONE:
                return new ManagedInetGuacamoleSocket(
                    proxyConfig.getHostname(),
                    proxyConfig.getPort(),
                    socketClosedCallback
                );

        }

        // Bail out if encryption method is unknown
        throw new GuacamoleServerException("Unimplemented encryption method.");
            // Retrieve connection information associated with given connection record
            ModeledConnection connection = activeConnection.getConnection();

                getUnconfiguredGuacamoleSocket(connection.getGuacamoleProxyConfiguration(),
                        cleanupTask), config, info);
import com.google.inject.Guice;
import com.google.inject.Injector;
    /**
     * Injector which will manage the object graph of this authentication
     * provider.
     */
    private final Injector injector;

    /**
     * Creates a new OAuthAuthenticationProvider that authenticates users
     * against an OAuth service
     *
     * @throws GuacamoleException
     *     If a required property is missing, or an error occurs while parsing
     *     a property.
     */
    public OAuthAuthenticationProvider() throws GuacamoleException {

        // Set up Guice injector.
        injector = Guice.createInjector(
            new OAuthAuthenticationProviderModule(this)
        );

    }

        // Attempt to authenticate user with given credentials
        AuthenticationProviderService authProviderService = injector.getInstance(AuthenticationProviderService.class);
        return authProviderService.authenticateUser(credentials);
        super(OAUTH_CODE_PARAMETER_NAME, "GUAC_OAUTH_CODE");
import com.google.inject.Provider;
import javax.servlet.http.HttpServletRequest;
import org.apache.guacamole.auth.oauth.user.AuthenticatedUser;
     * Provider for AuthenticatedUser objects.
     */
    @Inject
    private Provider<AuthenticatedUser> authenticatedUserProvider;

    /**
        String code = null;

        // Pull OAuth code from request if present
        HttpServletRequest request = credentials.getRequest();
        if (request != null)
            code = request.getParameter(OAuthCodeField.PARAMETER_NAME);

        // TODO: Actually complete authentication using received code
        if (code != null) {
            AuthenticatedUser authenticatedUser = authenticatedUserProvider.get();
            authenticatedUser.init("STUB", credentials);
            return authenticatedUser;
        }

    public static final String PARAMETER_NAME = "code";
        super(PARAMETER_NAME, "GUAC_OAUTH_CODE");
import org.apache.guacamole.auth.oauth.conf.ConfigurationService;
import org.apache.guacamole.auth.oauth.form.OAuthCodeField;
import org.apache.guacamole.auth.oauth.conf.ConfigurationService;
 b/extensions/guacamole-auth-openid/src/main/java/org/apache/guacamole/auth/oauth/conf/ConfigurationService.java
package org.apache.guacamole.auth.oauth.conf;
 b/extensions/guacamole-auth-openid/src/main/java/org/apache/guacamole/auth/oauth/conf/OAuthGuacamoleProperties.java
package org.apache.guacamole.auth.oauth.conf;
 b/extensions/guacamole-auth-openid/src/main/java/org/apache/guacamole/auth/oauth/form/OAuthCodeField.java
package org.apache.guacamole.auth.oauth.form;
     * Returns the token endpoint (URI) of the OAuth service as configured with
     * guacamole.properties.
     *
     * @return
     *     The token endpoint of the OAuth service, as configured with
     *     guacamole.properties.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed, or if the authorization
     *     endpoint property is missing.
     */
    public String getTokenEndpoint() throws GuacamoleException {
        return environment.getRequiredProperty(OAuthGuacamoleProperties.OAUTH_TOKEN_ENDPOINT);
    }

    /**
     * The token endpoint (URI) of the OAuth service.
     */
    public static final StringGuacamoleProperty OAUTH_TOKEN_ENDPOINT =
            new StringGuacamoleProperty() {

        @Override
        public String getName() { return "oauth-token-endpoint"; }

    };

    /**
import org.apache.guacamole.auth.oauth.token.TokenResponse;
import org.apache.guacamole.auth.oauth.token.TokenService;
     * Service for producing authentication tokens from OAuth codes.
     */
    @Inject
    private TokenService tokenService;

    /**

            // POST code and client information to OAuth token endpoint
            TokenResponse response = tokenService.getTokenFromCode(code);
            logger.debug("RESPONSE: {}", response);

            // Create corresponding authenticated user

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.api.client.config.DefaultClientConfig;
import org.apache.guacamole.auth.oauth.token.TokenService;
import org.codehaus.jackson.jaxrs.JacksonJaxbJsonProvider;
import org.codehaus.jackson.map.DeserializationConfig;
     * A reference to the shared HTTP client to be used when making calls to
     * the OAuth service.
     */
    private final Client client;

    /**
        // Set up configuration for HTTP client
        ClientConfig clientConfig = new DefaultClientConfig();
        clientConfig.getSingletons().add(new JacksonJaxbJsonProvider()
            .configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false)
        );

        // Store pre-configured HTTP client
        this.client = Client.create(clientConfig);

        bind(TokenService.class);

        // Bind HTTP client
        bind(Client.class).toInstance(client);
import org.apache.guacamole.auth.oauth.form.OAuthTokenField;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.form.Field;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.credentials.CredentialsInfo;
import org.apache.guacamole.net.auth.credentials.GuacamoleInvalidCredentialsException;
        String token = null;
        // Pull OAuth token from request if present
            token = request.getParameter(OAuthTokenField.PARAMETER_NAME);
        // TODO: Actually validate received token
        if (token != null) {
        // Request OAuth token
                // OAuth-specific token (will automatically redirect the user
                // to the authorization page via JavaScript)
                new OAuthTokenField(
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.net.auth.AuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.net.auth.UserContext;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.environment.LocalEnvironment;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.GuacamoleException;
import org.apache.guacamole.environment.Environment;
import org.apache.guacamole.properties.StringGuacamoleProperty;
 b/extensions/guacamole-auth-openid/src/main/java/org/apache/guacamole/auth/oauth/form/OAuthTokenField.java
import java.util.UUID;
import org.apache.guacamole.form.Field;
 * Field definition which represents the token returned by an OAuth service.
public class OAuthTokenField extends Field {
    public static final String PARAMETER_NAME = "id_token";
     * Creates a new OAuth "id_token" field which links to the given OAuth
     * service using the provided client ID. Successful authentication at the
     * OAuth service will result in the client being redirected to the specified
     * redirect URI. The OAuth token will be embedded in the fragment (the part
     * following the hash symbol) of that URI, which the JavaScript side of
     * this extension will move to the query parameters.
    public OAuthTokenField(String authorizationEndpoint, String clientID,
        super(PARAMETER_NAME, "GUAC_OAUTH_TOKEN");
                     "&response_type=id_token"
                     "&redirect_uri="  URLEncoder.encode(redirectURI, "UTF-8")
                     "&nonce="  UUID.randomUUID().toString();
     * Returns the full URI that this field should link to when a new token
import org.apache.guacamole.net.auth.AbstractAuthenticatedUser;
import org.apache.guacamole.net.auth.AuthenticationProvider;
import org.apache.guacamole.net.auth.Credentials;
import org.apache.guacamole.auth.oauth.token.TokenValidationService;
import org.apache.guacamole.auth.oauth.user.AuthenticatedUser;
     * Service for validating received ID tokens.
     */
    @Inject
    private TokenValidationService tokenService;

    /**
        // If token provided, validate and produce authenticated user
            authenticatedUser.init(tokenService.processUsername(token), credentials);
import org.apache.guacamole.auth.oauth.token.TokenValidationService;
        bind(TokenValidationService.class);
     *     If guacamole.properties cannot be parsed, or if the redirect URI
    /**
     * Returns the issuer to expect for all received ID tokens, as configured
     * with guacamole.properties.
     *
     * @return
     *     The issuer to expect for all received ID tokens, as configured with
     *     guacamole.properties.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed, or if the issuer property
     *     is missing.
     */
    public String getIssuer() throws GuacamoleException {
        return environment.getRequiredProperty(OAuthGuacamoleProperties.OAUTH_ISSUER);
    }

    /**
     * Returns the endpoint (URI) of the JWKS service which defines how
     * received ID tokens (JWTs) shall be validated, as configured with
     * guacamole.properties.
     *
     * @return
     *     The endpoint (URI) of the JWKS service which defines how received ID
     *     tokens (JWTs) shall be validated, as configured with
     *     guacamole.properties.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed, or if the JWKS endpoint
     *     property is missing.
     */
    public String getJWKSEndpoint() throws GuacamoleException {
        return environment.getRequiredProperty(OAuthGuacamoleProperties.OAUTH_JWKS_ENDPOINT);
    }

    /**
     * Returns the claim type which contains the authenticated user's username
     * within any valid JWT, as configured with guacamole.properties.
     *
     * @return
     *     The claim type which contains the authenticated user's username
     *     within any valid JWT, as configured with guacamole.properties.
     *
     * @throws GuacamoleException
     *     If guacamole.properties cannot be parsed, or if the username claim
     *     type property is missing.
     */
    public String getUsernameClaimType() throws GuacamoleException {
        return environment.getRequiredProperty(OAuthGuacamoleProperties.OAUTH_USERNAME_CLAIM_TYPE);
    }

     * The endpoint (URI) of the JWKS service which defines how received ID
     * tokens (JWTs) shall be validated.
     */
    public static final StringGuacamoleProperty OAUTH_JWKS_ENDPOINT =
            new StringGuacamoleProperty() {

        @Override
        public String getName() { return "oauth-jwks-endpoint"; }

    };

    /**
     * The issuer to expect for all received ID tokens.
     */
    public static final StringGuacamoleProperty OAUTH_ISSUER =
            new StringGuacamoleProperty() {

        @Override
        public String getName() { return "oauth-issuer"; }

    };

    /**
     * The claim type which contains the authenticated user's username within
     * any valid JWT.
     */
    public static final StringGuacamoleProperty OAUTH_USERNAME_CLAIM_TYPE =
            new StringGuacamoleProperty() {

        @Override
        public String getName() { return "oauth-username-claim-type"; }

    };

    /**
import java.math.BigInteger;
import java.security.SecureRandom;
     * Cryptographically-secure random number generator for generating the
     * required nonce.
     */
    private static final SecureRandom random = new SecureRandom();

    /**
     * Generates a cryptographically-secure nonce value. The nonce is intended
     * to be used to prevent replay attacks.
     *
     * @return
     *     A cryptographically-secure nonce value.
     */
    private static String generateNonce() {
        return new BigInteger(130, random).toString(32);
    }

    /**
                     "&nonce="  generateNonce();
    /**
     * Service for retrieving OAuth configuration information.
     */
            AuthenticatedUser authenticatedUser, Credentials credentials)
            throws GuacamoleException {
